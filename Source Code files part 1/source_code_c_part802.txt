de premissions
    //

    OpenProcessToken (
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        );

    LookupPrivilegeValue (
        NULL,
        SE_SHUTDOWN_NAME,
        &tkp.Privileges[0].Luid
        );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges (
        hToken,
        FALSE,
        &tkp,
        0,
        NULL,
        0
    );

    //
    // Process args
    //

    while (argc) {
        argc--;

        if (streql(*argv, "-v")) {
            Verbose1 = TRUE;
        }

        if (streql(*argv, "-V")) {
            Verbose1 = TRUE;
            Verbose2 = TRUE;
        }

        for (p = *argv; *p; p++) {
            if (*p >= 'A' &&  *p <= 'Z') {
                *p += 'a' - 'A';
            }
        }

        p = *argv;
        argv += 1;

        if (streql(p, "ac")) {
            SelectItem(SEL_AC);
        }

        if (streql(p, "dc")) {
            SelectItem(SEL_DC);
        }

        if (streql(p, "current")) {
            SelectItem(SEL_CURRENT);
        }

        if (streql(p, "cap")) {
            SelectItem(SEL_CAP);
        }

        if (streql(p, "ps")) {
            SelectItem(SEL_NONE);
            PrintPowerStatus ();
        }

        if (streql(p, "bs")) {
            SelectItem(SEL_NONE);
            PrintBattStatus();
        }

        if (streql(p, "admin")) {
            SelectItem(SEL_ADMIN);
        }

        if (streql(p, "pdc")) {
            SelectItem(SEL_PDC);
        }

        if (streql(p, "pac")) {
            SelectItem(SEL_PAC);
        }

        if (streql(p, "pcurrent")) {
            SelectItem(SEL_PCURRENT);
        }

        //
        // Check if this is a assignment
        //

        for (p1=p; *p1; p1++) {
            if (*p1 == '=') {
                *p1 = 0;
                AssignSetting (p, p1+1);
            }
        }
    }

    // flush
    SelectItem(SEL_NONE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ech\ech.c ===
#include <stdio.h>
#include <string.h>
#include <cvtoem.h>

int
__cdecl
main (
    int c,
    char *v[]
    )
{
    ConvertAppToOem(c, v);
    while (--c)
        if (!strcmp( *++v, ";" ))
            printf ("\n" );
        else
            printf ("%s ", *v);
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\echotime\echotime.c ===
/* echotime - prints current time and input args to stdout
 *
 * HISTORY:
 * 23-Jan-87    danl    added /n switch and ';' processing
 * 23-Nov-87    brianwi Exit code 0
 */

#include <string.h>
#include <time.h>
#include <stdio.h>
#include <process.h>
#include <windows.h>
#include <tools.h>

// Function Forward Parameters...
void Usage( void );
int __cdecl main( int, char ** );


const char rgstrUsage[] = {
    "Usage: ECHOTIME [/t] [/WODHMSCYb] [/v] [/n] [/N] [;] text\n"
    " /t  current day, time and year\n"
    " /WODHMSCYb\n"
    "     Weekday, mOnth, Day, Hour, Min, Sec, Century, Yr, blank\n"
    "     other char are themselves\n"
    "     e.g. echotime /O-D-Y this becomes Jan-02-86\n"
    "     e.g. echotime /ObDbY this becomes Jan 02 86\n"
    " /v  volume id of C:\n"
    " /n  no newline after outputting text\n"
    " /N  no trailing blank at end of lines\n"
    " a semicolon surrounded by white space is replaced by a newline\n"};

int fNewline = TRUE;
int fTrailingBlank = TRUE;

void Usage( void )
{
    puts(rgstrUsage);

    exit (1);
}

int
__cdecl
main (
    int c,
    char *v[]
    )
{
    // struct  findType findBuf;
    time_t    now;
    char    *p, *strTime, *p2, *p3, *printstring;
    char    ch;
    int     i, len;
    int     fFirstWord = TRUE;
    char    timestring[1000];           //plenty of room for formatted time string

    ConvertAppToOem( c, v );
    SHIFT( c, v );
    while ( c ) {
        printstring="";                 //default no text for this arg
        if ( !strcmp( *v, "/?" ))
            Usage ();
        if ( !strcmp( *v, "/n" ))
            fNewline = FALSE;
        else if ( !strcmp( *v, "/N" ))
            fTrailingBlank = FALSE;
        else if ( !strcmp( *v, "/v" )) {
            //
            //  It would make more sense to replace by the volume id of the
            //  current drive, but the original code used drive C: and
            //  it is described as so in the help file, so I'll do the same.
            //
            char    VolumeName[MAX_PATH];
            BOOL    StatusOk;

            StatusOk = GetVolumeInformation( "C:\\",
                                             VolumeName,
                                             MAX_PATH,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             0 );
            if (!StatusOk) {
                printstring = "NO_VOL_ID";
            } else {
                printstring = VolumeName;
            }


            }
        else if (**v == '/') {
            *timestring='\0';
            p2 = *v;
            time( &now );
            strTime = _strdup( ctime( &now ) );
            if (!strTime) {
                puts("Out of memory");
                exit(1);
            }
            p = strend( strTime );
            *--p = '\0';
            while ((ch = *++p2)) {
                len = 2;
                switch (ch) {
                    case 'W':   /* Week */
                        len = 3;
                        i = 0;
                        break;
                    case 'O':   /* mOnth */
                        len = 3;
                        i = 4;
                        break;
                    case 'D':   /* Day  */
                        i = 8;
                        break;
                    case 'H':   /* Hour */
                        i = 11;
                        break;
                    case 'M':   /* Min  */
                        i = 14;
                        break;
                    case 'S':   /* Sec  */
                        i = 17;
                        break;
                    case 'C':   /* Century */
                        i = 20;
                        break;
                    case 'Y':   /* Year */
                        i = 22;
                        break;
                    case 'b':   /* Blank */
                        len = 1;
                        i = 3;
                        break;
                    case 't':
                        len = 25;
                        i = 0;
                        break;
                    default:
                        strTime[3] = ch;
                        len = 1;
                        i = 3;
                        break;
                    }
                p = strTime + i;
                p3 = p + len;
                ch = *p3;
                *p3 = '\0';
                strcat(timestring, p);  /* N.B. no trailing blanks */
                *p3 = ch;
                strTime[3] = ' ';
                }
            printstring = timestring;
            }
        else if (!strcmp( *v, ";" )) {
            if (fTrailingBlank)
               printf(" ");
            printf ("\n" );
            fFirstWord = TRUE;
            // printstring remains pointing to empty string
        }
        else
            printstring= *v;

        if (*printstring) {
            if (!fFirstWord)
               printf( " ");
            else
               fFirstWord=FALSE;
            printf("%s", printstring);
        }

        SHIFT( c, v );
        }
    if (fTrailingBlank)
        printf( " ");
    if ( fNewline )
        printf("\n" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\efinvram\efinvram.c ===
#include "efinvram.h"

PWSTR SystemPartitionNtName;

PBOOT_OPTIONS BootOptions;
ULONG BootOptionsLength;
PBOOT_OPTIONS OriginalBootOptions;
ULONG OriginalBootOptionsLength;

PULONG BootEntryOrder;
ULONG BootEntryOrderCount;
PULONG OriginalBootEntryOrder;
ULONG OriginalBootEntryOrderCount;

LIST_ENTRY BootEntries;
LIST_ENTRY DeletedBootEntries;
LIST_ENTRY ActiveUnorderedBootEntries;
LIST_ENTRY InactiveUnorderedBootEntries;

VOID
ConcatenatePaths (
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    );

VOID
ConvertBootEntries (
    PBOOT_ENTRY_LIST BootEntries
    );

PMY_BOOT_ENTRY
CreateBootEntryFromBootEntry (
    IN PMY_BOOT_ENTRY OldBootEntry
    );

VOID
FreeBootEntry (
    IN PMY_BOOT_ENTRY BootEntry
    );

VOID
InitializeEfi (
    VOID
    );

NTSTATUS
(*AddBootEntry) (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );

NTSTATUS
(*DeleteBootEntry) (
    IN ULONG Id
    );

NTSTATUS
(*ModifyBootEntry) (
    IN PBOOT_ENTRY BootEntry
    );

NTSTATUS
(*EnumerateBootEntries) (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );

NTSTATUS
(*QueryBootEntryOrder) (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );

NTSTATUS
(*SetBootEntryOrder) (
    IN PULONG Ids,
    IN ULONG Count
    );

NTSTATUS
(*QueryBootOptions) (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );

NTSTATUS
(*SetBootOptions) (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );

NTSTATUS
(*TranslateFilePath) (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputFilePath,
    IN OUT PULONG OutputFilePathLength
    );

int
__cdecl
main (
    int argc,
    char *argv[]
    )
{
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    InitializeMenuSystem( );

    InitializeEfi( );

    MainMenu( );

    return 0;
}

VOID
ConvertBootEntries (
    PBOOT_ENTRY_LIST NtBootEntries
    )

/*++

Routine Description:

    Convert boot entries read from EFI NVRAM into our internal format.

Arguments:

    None.

Return Value:

    NTSTATUS - Not STATUS_SUCCESS if an unexpected error occurred.

--*/

{
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length;

    bootEntryList = NtBootEntries;

    while (TRUE) {

        bootEntry = &bootEntryList->BootEntry;

        //
        // Calculate the length of our internal structure. This includes
        // the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
        //
        length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
        myBootEntry = MemAlloc(length);

        RtlZeroMemory(myBootEntry, length);

        //
        // Link the new entry into the list.
        //
        if ( (bootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0 ) {
            InsertTailList( &ActiveUnorderedBootEntries, &myBootEntry->ListEntry );
            myBootEntry->ListHead = &ActiveUnorderedBootEntries;
        } else {
            InsertTailList( &InactiveUnorderedBootEntries, &myBootEntry->ListEntry );
            myBootEntry->ListHead = &InactiveUnorderedBootEntries;
        }

        //
        // Copy the NT BOOT_ENTRY into the allocated buffer.
        //
        bootEntryCopy = &myBootEntry->NtBootEntry;
        memcpy(bootEntryCopy, bootEntry, bootEntry->Length);

        //
        // Fill in the base part of the structure.
        //
        myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + length - 1;
        myBootEntry->Id = bootEntry->Id;
        myBootEntry->Attributes = bootEntry->Attributes;
        myBootEntry->FriendlyName = ADD_OFFSET(bootEntryCopy, FriendlyNameOffset);
        myBootEntry->FriendlyNameLength =
            ((ULONG)wcslen(myBootEntry->FriendlyName) + 1) * sizeof(WCHAR);
        myBootEntry->BootFilePath = ADD_OFFSET(bootEntryCopy, BootFilePathOffset);

        //
        // If this is an NT boot entry, capture the NT-specific information in
        // the OsOptions.
        //
        osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;

        if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
            (strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0)) {

            MBE_SET_IS_NT( myBootEntry );
            myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
            myBootEntry->OsLoadOptionsLength =
                ((ULONG)wcslen(myBootEntry->OsLoadOptions) + 1) * sizeof(WCHAR);
            myBootEntry->OsFilePath = ADD_OFFSET(osOptions, OsLoadPathOffset);

        } else {

            //
            // Foreign boot entry. Just capture whatever OS options exist.
            //

            myBootEntry->ForeignOsOptions = bootEntryCopy->OsOptions;
            myBootEntry->ForeignOsOptionsLength = bootEntryCopy->OsOptionsLength;
        }

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0) {
            break;
        }
        bootEntryList = ADD_OFFSET(bootEntryList, NextEntryOffset);
    }

    return;

} // ConvertBootEntries

VOID
ConcatenatePaths (
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

{
    BOOL NeedBackslash = TRUE;
    DWORD l;
     
    if(!Path1)
        return;

    l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(Path2 && ((l+lstrlen(Path2)) < BufferSizeChars)) {
        lstrcat(Path1,Path2);
    }
}

PMY_BOOT_ENTRY
CreateBootEntryFromBootEntry (
    IN PMY_BOOT_ENTRY OldBootEntry
    )
{
    ULONG requiredLength;
    ULONG osOptionsOffset;
    ULONG osLoadOptionsLength;
    ULONG osLoadPathOffset;
    ULONG osLoadPathLength;
    ULONG osOptionsLength;
    ULONG friendlyNameOffset;
    ULONG friendlyNameLength;
    ULONG bootPathOffset;
    ULONG bootPathLength;
    PMY_BOOT_ENTRY newBootEntry;
    PBOOT_ENTRY ntBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    PFILE_PATH osLoadPath;
    PWSTR friendlyName;
    PFILE_PATH bootPath;

    //
    // Calculate how long the internal boot entry needs to be. This includes
    // our internal structure, plus the BOOT_ENTRY structure that the NT APIs
    // use.
    //
    // Our structure:
    //
    requiredLength = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);

    //
    // Base part of NT structure:
    //
    requiredLength += FIELD_OFFSET(BOOT_ENTRY, OsOptions);

    //
    // Save offset to BOOT_ENTRY.OsOptions. Add in base part of
    // WINDOWS_OS_OPTIONS. Calculate length in bytes of OsLoadOptions
    // and add that in.
    //
    osOptionsOffset = requiredLength;

    if ( MBE_IS_NT( OldBootEntry ) ) {

        //
        // Add in base part of WINDOWS_OS_OPTIONS. Calculate length in
        // bytes of OsLoadOptions and add that in.
        //
        requiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
        osLoadOptionsLength = OldBootEntry->OsLoadOptionsLength;
        requiredLength += osLoadOptionsLength;

        //
        // Round up to a ULONG boundary for the OS FILE_PATH in the
        // WINDOWS_OS_OPTIONS. Save offset to OS FILE_PATH. Calculate length
        // in bytes of FILE_PATH and add that in. Calculate total length of 
        // WINDOWS_OS_OPTIONS.
        // 
        requiredLength = ALIGN_UP(requiredLength, ULONG);
        osLoadPathOffset = requiredLength;
        requiredLength += OldBootEntry->OsFilePath->Length;
        osLoadPathLength = requiredLength - osLoadPathOffset;

    } else {

        //
        // Add in length of foreign OS options.
        //
        requiredLength += OldBootEntry->ForeignOsOptionsLength;

        osLoadOptionsLength = 0;
        osLoadPathOffset = 0;
        osLoadPathLength = 0;
    }

    osOptionsLength = requiredLength - osOptionsOffset;

    //
    // Round up to a ULONG boundary for the friendly name in the BOOT_ENTRY.
    // Save offset to friendly name. Calculate length in bytes of friendly name
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    friendlyNameOffset = requiredLength;
    friendlyNameLength = OldBootEntry->FriendlyNameLength;
    requiredLength += friendlyNameLength;

    //
    // Round up to a ULONG boundary for the boot FILE_PATH in the BOOT_ENTRY.
    // Save offset to boot FILE_PATH. Calculate length in bytes of FILE_PATH
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    bootPathOffset = requiredLength;
    requiredLength += OldBootEntry->BootFilePath->Length;
    bootPathLength = requiredLength - bootPathOffset;

    //
    // Allocate memory for the boot entry.
    //
    newBootEntry = MemAlloc(requiredLength);
    ASSERT(newBootEntry != NULL);

    RtlZeroMemory(newBootEntry, requiredLength);

    //
    // Calculate addresses of various substructures using the saved offsets.
    //
    ntBootEntry = &newBootEntry->NtBootEntry;
    osOptions = (PWINDOWS_OS_OPTIONS)ntBootEntry->OsOptions;
    osLoadPath = (PFILE_PATH)((PUCHAR)newBootEntry + osLoadPathOffset);
    friendlyName = (PWSTR)((PUCHAR)newBootEntry + friendlyNameOffset);
    bootPath = (PFILE_PATH)((PUCHAR)newBootEntry + bootPathOffset);

    //
    // Fill in the internal-format structure.
    //
    newBootEntry->AllocationEnd = (PUCHAR)newBootEntry + requiredLength;
    newBootEntry->Status = OldBootEntry->Status & MBE_STATUS_IS_NT;
    newBootEntry->Attributes = OldBootEntry->Attributes;
    newBootEntry->Id = OldBootEntry->Id;
    newBootEntry->FriendlyName = friendlyName;
    newBootEntry->FriendlyNameLength = friendlyNameLength;
    newBootEntry->BootFilePath = bootPath;
    if ( MBE_IS_NT( OldBootEntry ) ) {
        newBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
        newBootEntry->OsLoadOptionsLength = osLoadOptionsLength;
        newBootEntry->OsFilePath = osLoadPath;
    }

    //
    // Fill in the base part of the NT boot entry.
    //
    ntBootEntry->Version = BOOT_ENTRY_VERSION;
    ntBootEntry->Length = requiredLength - FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);
    ntBootEntry->Attributes = OldBootEntry->Attributes;
    ntBootEntry->Id = OldBootEntry->Id;
    ntBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)friendlyName - (PUCHAR)ntBootEntry);
    ntBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)bootPath - (PUCHAR)ntBootEntry);
    ntBootEntry->OsOptionsLength = osOptionsLength;

    if ( MBE_IS_NT( OldBootEntry ) ) {
    
        //
        // Fill in the base part of the WINDOWS_OS_OPTIONS, including the
        // OsLoadOptions.
        //
        strcpy((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
        osOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
        osOptions->Length = osOptionsLength;
        osOptions->OsLoadPathOffset = (ULONG)((PUCHAR)osLoadPath - (PUCHAR)osOptions);
        wcscpy(osOptions->OsLoadOptions, OldBootEntry->OsLoadOptions);
    
        //
        // Copy the OS FILE_PATH.
        //
        memcpy( osLoadPath, OldBootEntry->OsFilePath, osLoadPathLength );

    } else {

        //
        // Copy the foreign OS options.
        //

        memcpy( osOptions, OldBootEntry->ForeignOsOptions, osOptionsLength );
    }

    //
    // Copy the friendly name.
    //
    wcscpy(friendlyName, OldBootEntry->FriendlyName);

    //
    // Copy the boot FILE_PATH.
    //
    memcpy( bootPath, OldBootEntry->BootFilePath, bootPathLength );

    return newBootEntry;

} // CreateBootEntryFromBootEntry

VOID
FreeBootEntry (
    IN PMY_BOOT_ENTRY BootEntry
    )
{
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, FriendlyName );
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, OsLoadOptions );
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, BootFilePath );
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, OsFilePath );

    MemFree( BootEntry );

    return;

} // FreeBootEntry

VOID
InitializeEfi (
    VOID
    )
{
    DWORD error;
    NTSTATUS status;
    BOOLEAN wasEnabled;
    HMODULE h;
    WCHAR dllName[MAX_PATH]; 
    ULONG length;
    HKEY key;
    DWORD type;
    PBOOT_ENTRY_LIST ntBootEntries;
    ULONG i;
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY bootEntry;

    //
    // Enable the privilege that is necessary to query/set NVRAM.
    //

    status = RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &wasEnabled
                );
    if ( !NT_SUCCESS(status) ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Insufficient privilege.\n" );
    }

    //
    // Get the NT name of the system partition from the registry.
    //

    error = RegOpenKey( HKEY_LOCAL_MACHINE, TEXT("System\\Setup"), &key );
    if ( error != ERROR_SUCCESS ) {
        FatalError( error, L"Unable to read SystemPartition registry value: %d\n", error );
    }

    error = RegQueryValueEx( key, TEXT("SystemPartition"), NULL, &type, NULL, &length );
    if ( error != ERROR_SUCCESS ) {
        FatalError( error, L"Unable to read SystemPartition registry value: %d\n", error );
    }
    if ( type != REG_SZ ) {
        FatalError(
            ERROR_INVALID_PARAMETER,
            L"Unable to read SystemPartition registry value: wrong type\n"
            );
    }

    SystemPartitionNtName = MemAlloc( length );

    error = RegQueryValueEx( 
                key,
                TEXT("SystemPartition"),
                NULL,
                &type,
                (PBYTE)SystemPartitionNtName,
                &length
                );
    if ( error != ERROR_SUCCESS ) {
        FatalError( error, L"Unable to read SystemPartition registry value: %d\n", error );
    }
    
    RegCloseKey( key );

    //
    // Load ntdll.dll from the system directory.
    //

    GetSystemDirectory( dllName, MAX_PATH );
    ConcatenatePaths( dllName, TEXT("ntdll.dll"), MAX_PATH );
    h = LoadLibrary( dllName );
    if ( h == NULL ) {
        error = GetLastError();
        FatalError( error, L"Can't load NTDLL.DLL: %d\n", error );
    }

    //
    // Get the addresses of the NVRAM APIs that we need to use. If any of
    // these APIs are not available, this must be a pre-EFI NVRAM build.
    //

    (FARPROC)AddBootEntry = GetProcAddress( h, "NtAddBootEntry" );
    (FARPROC)DeleteBootEntry = GetProcAddress( h, "NtDeleteBootEntry" );
    (FARPROC)ModifyBootEntry = GetProcAddress( h, "NtModifyBootEntry" );
    (FARPROC)EnumerateBootEntries = GetProcAddress( h, "NtEnumerateBootEntries" );
    (FARPROC)QueryBootEntryOrder = GetProcAddress( h, "NtQueryBootEntryOrder" );
    (FARPROC)SetBootEntryOrder = GetProcAddress( h, "NtSetBootEntryOrder" );
    (FARPROC)QueryBootOptions = GetProcAddress( h, "NtQueryBootOptions" );
    (FARPROC)SetBootOptions = GetProcAddress( h, "NtSetBootOptions" );
    (FARPROC)TranslateFilePath = GetProcAddress( h, "NtTranslateFilePath" );

    if ( (AddBootEntry == NULL) ||
         (DeleteBootEntry == NULL) ||
         (ModifyBootEntry == NULL) ||
         (EnumerateBootEntries == NULL) ||
         (QueryBootEntryOrder == NULL) ||
         (SetBootEntryOrder == NULL) ||
         (QueryBootOptions == NULL) ||
         (SetBootOptions == NULL) ||
         (TranslateFilePath == NULL) ) {
        FatalError( ERROR_OLD_WIN_VERSION, L"This build does not support EFI NVRAM\n" );
    }

    //
    // Get the global system boot options. If the call fails with
    // STATUS_NOT_IMPLEMENTED, this is not an EFI machine.
    //

    length = 0;
    status = QueryBootOptions( NULL, &length );

    if ( status == STATUS_NOT_IMPLEMENTED ) {
        FatalError( ERROR_OLD_WIN_VERSION, L"This build does not support EFI NVRAM\n" );
    }

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unexpected error from NtQueryBootOptions: 0x%x\n", status );
    }

    BootOptions = MemAlloc( length );
    OriginalBootOptions = MemAlloc( length );

    status = QueryBootOptions( BootOptions, &length );
    if ( status != STATUS_SUCCESS ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unexpected error from NtQueryBootOptions: 0x%x\n", status );
    }

    memcpy( OriginalBootOptions, BootOptions, length );
    BootOptionsLength = length;
    OriginalBootOptionsLength = length;

    //
    // Get the system boot order list.
    //

    length = 0;
    status = QueryBootEntryOrder( NULL, &length );

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        if ( status == STATUS_SUCCESS ) {
            length = 0;
        } else {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtQueryBootEntryOrder: 0x%x\n", status );
        }
    }

    if ( length != 0 ) {

        BootEntryOrder = MemAlloc( length * sizeof(ULONG) );
        OriginalBootEntryOrder = MemAlloc( length * sizeof(ULONG) );

        status = QueryBootEntryOrder( BootEntryOrder, &length );
        if ( status != STATUS_SUCCESS ) {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtQueryBootEntryOrder: 0x%x\n", status );
        }

        memcpy( OriginalBootEntryOrder, BootEntryOrder, length * sizeof(ULONG) );
    }

    BootEntryOrderCount = length;
    OriginalBootEntryOrderCount = length;

    //
    // Get all existing boot entries.
    //

    length = 0;
    status = EnumerateBootEntries( NULL, &length );
    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        if ( status == STATUS_SUCCESS ) {
            length = 0;
        } else {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtEnumerateBootEntries: 0x%x\n", status );
        }
    }

    InitializeListHead( &BootEntries );
    InitializeListHead( &DeletedBootEntries );
    InitializeListHead( &ActiveUnorderedBootEntries );
    InitializeListHead( &InactiveUnorderedBootEntries );

    if ( length != 0 ) {
    
        ntBootEntries = MemAlloc( length );

        status = EnumerateBootEntries( ntBootEntries, &length );
        if ( status != STATUS_SUCCESS ) {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtEnumerateBootEntries: 0x%x\n", status );
        }

        //
        // Convert the boot entries into an internal representation.
        //

        ConvertBootEntries( ntBootEntries );

        //
        // Free the enumeration buffer.
        //

        MemFree( ntBootEntries );
    }

    //
    // Build the ordered boot entry list.
    //

    for ( i = 0; i < BootEntryOrderCount; i++ ) {
        ULONG id = BootEntryOrder[i];
        for ( listEntry = ActiveUnorderedBootEntries.Flink;
              listEntry != &ActiveUnorderedBootEntries;
              listEntry = listEntry->Flink ) {
            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            if ( bootEntry->Id == id ) {
                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &BootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &BootEntries;
            }
        }
        for ( listEntry = InactiveUnorderedBootEntries.Flink;
              listEntry != &InactiveUnorderedBootEntries;
              listEntry = listEntry->Flink ) {
            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            if ( bootEntry->Id == id ) {
                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &BootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &BootEntries;
            }
        }
    }

    return;

} // InitializeEfi

PMY_BOOT_ENTRY
SaveChanges (
    PMY_BOOT_ENTRY CurrentBootEntry
    )
{
    NTSTATUS status;
    DWORD error;
    PLIST_ENTRY listHeads[4];
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    ULONG list;
    PMY_BOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY newBootEntry;
    PMY_BOOT_ENTRY newCurrentBootEntry;
    ULONG count;

    SetStatusLine( L"Saving changes..." );

    //
    // Walk the three lists, updating boot entries in NVRAM.
    //

    newCurrentBootEntry = CurrentBootEntry;

    listHeads[0] = &DeletedBootEntries;
    listHeads[1] = &InactiveUnorderedBootEntries;
    listHeads[2] = &ActiveUnorderedBootEntries;
    listHeads[3] = &BootEntries;

    for ( list = 0; list < 4; list++ ) {
    
        listHead = listHeads[list];

        for ( listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink ) {

            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

            //
            // Check first for deleted entries, then for new entries, and
            // finally for modified entries.
            //

            if ( MBE_IS_DELETED( bootEntry ) ) {

                //
                // If it's also marked as new, it's not in NVRAM, so there's
                // nothing to delete.
                //

                if ( !MBE_IS_NEW( bootEntry ) ) {

                    status = DeleteBootEntry( bootEntry->Id );
                    if ( !NT_SUCCESS(status) ) {
                        if ( status != STATUS_VARIABLE_NOT_FOUND ) {
                            error = RtlNtStatusToDosError( status );
                            FatalError( error, L"Unable to delete boot entry: 0x%x\n", status );
                        }
                    }
                }

                //
                // Delete this entry from the list and from memory.
                //

                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );

                FreeBootEntry( bootEntry );
                ASSERT( bootEntry != CurrentBootEntry );

            } else if ( MBE_IS_NEW( bootEntry ) ) {

                //
                // We don't support this yet.
                //

                FatalError(
                    ERROR_GEN_FAILURE,
                    L"How did we end up in SaveChanges with a NEW boot entry?!?\n"
                    );

            } else if ( MBE_IS_MODIFIED( bootEntry ) ) {

                //
                // Create a new boot entry structure using the existing one.
                // This is necessary to make an NT BOOT_ENTRY that can be
                // passed to NtModifyBootEntry.
                //

                newBootEntry = CreateBootEntryFromBootEntry( bootEntry );

                status = ModifyBootEntry( &newBootEntry->NtBootEntry );
                if ( !NT_SUCCESS(status) ) {
                    error = RtlNtStatusToDosError( status );
                    FatalError( error, L"Unable to modify boot entry: 0x%x\n", status );
                }

                //
                // Insert the new boot entry in place of the existing one.
                // Free the old one.
                //

                InsertHeadList( &bootEntry->ListEntry, &newBootEntry->ListEntry );
                RemoveEntryList( &bootEntry->ListEntry );

                FreeBootEntry( bootEntry );
                if ( bootEntry == CurrentBootEntry ) {
                    newCurrentBootEntry = newBootEntry;
                }
            }
        }
    }

    //
    // Build and write the new boot entry order list.
    //

    listHead = &BootEntries;

    count = 0;
    for ( listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink ) {
        count++;
    }

    MemFree( BootEntryOrder );
    BootEntryOrder = MemAlloc( count * sizeof(ULONG) );

    count = 0;
    for ( listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink ) {
        bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
        BootEntryOrder[count++] = bootEntry->Id;
    }

    status = SetBootEntryOrder( BootEntryOrder, count );
    if ( !NT_SUCCESS(status) ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unable to set boot entry order: 0x%x\n", status );
    }

    MemFree( OriginalBootEntryOrder );
    OriginalBootEntryOrder = MemAlloc( count * sizeof(ULONG) );
    memcpy( OriginalBootEntryOrder, BootEntryOrder, count * sizeof(ULONG) );

    //
    // Write the new timeout.
    //

    status = SetBootOptions( BootOptions, BOOT_OPTIONS_FIELD_TIMEOUT );
    if ( !NT_SUCCESS(status) ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unable to set boot options: 0x%x\n", status );
    }

    MemFree( OriginalBootOptions );
    OriginalBootOptions = MemAlloc( BootOptionsLength );
    memcpy( OriginalBootOptions, BootOptions, BootOptionsLength );
    OriginalBootOptionsLength = BootOptionsLength;

    return newCurrentBootEntry;

} // SaveChanges

PWSTR
GetNtNameForFilePath (
    IN PFILE_PATH FilePath
    )
{
    NTSTATUS status;
    ULONG length;
    PFILE_PATH ntPath;
    PWSTR osDeviceNtName;
    PWSTR osDirectoryNtName;
    PWSTR fullNtName;

    length = 0;
    status = TranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                NULL,
                &length
                );
    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        return NULL;
    }

    ntPath = MemAlloc( length );
    status = TranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                ntPath,
                &length
                );
    if ( !NT_SUCCESS(status) ) {
        MemFree( ntPath );
        return NULL;
    }

    osDeviceNtName = (PWSTR)ntPath->FilePath;
    osDirectoryNtName = osDeviceNtName + wcslen(osDeviceNtName) + 1;

    length = (ULONG)(wcslen(osDeviceNtName) + wcslen(osDirectoryNtName) + 1) * sizeof(WCHAR);
    fullNtName = MemAlloc( length );

    wcscpy( fullNtName, osDeviceNtName );
    wcscat( fullNtName, osDirectoryNtName );

    MemFree( ntPath );

    return fullNtName;

} // GetNtNameForFilePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\emptydirs\exe\precomp.h ===
#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <scan.h>

#if SCAN_DEBUG
extern BOOL dprinton;
#define dprintf(_x_) if (dprinton) printf _x_
#else
#define dprintf(_x_)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\emptydirs\exe\emptydirs.c ===
#include "precomp.h"
#pragma hdrstop

#if SCAN_DEBUG
BOOL dprinton = FALSE;
#endif

//
// This flag indicates whether empty directories should be deleted.
//

BOOL DeleteEmptyDirectories = FALSE;
BOOL ContinueOnError = FALSE;
BOOL Quiet = FALSE;
BOOL ShowWriteableFiles = FALSE;

DWORD
NewFile (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW ExistingFileData OPTIONAL,
    IN PWIN32_FIND_DATAW NewFileData,
    IN PVOID *FileUserData,
    IN PVOID *ParentDirectoryUserData
    )

/*++

Routine Description:

    Called when ScanDirectory finds a file.

Arguments:

    Context - User-supplied context. Not used by emptydirs.

    Path - Directory containing this file.

    ExistingFileData - Pointer to data describing previous found file with
        same name, if any.

    NewFileData - Pointer to data for this file.

    FileUserData - Pointer to user-controlled data field for the file.

    ParentDirectoryUserData - Pointer to user-controlled data field for the
        parent directory.

Return Value:

    DWORD - Indicates whether an error occurred.

--*/

{
    //
    // Increment the directory/file count for the parent. Set the file's
    // user data pointer to NULL, indicating that we don't need the
    // scan library to remember this file.
    //

    (*(DWORD *)ParentDirectoryUserData)++;
    *FileUserData = NULL;

    dprintf(( "  NF: File %ws\\%ws: parent count %d, file count %d\n",
                Path, NewFileData->cFileName,
                *(DWORD *)ParentDirectoryUserData, *FileUserData ));

    //
    // If we're supposed to show writeable files, check for that now.
    //

    if ( ShowWriteableFiles &&
         ((NewFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) == 0) ) {
        printf( "FILE: %ws\\%ws\n", Path, NewFileData->cFileName );
    }

    return 0;

} // NewFile

DWORD
NewDirectory (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW ExistingDirectoryData OPTIONAL,
    IN PWIN32_FIND_DATAW NewDirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData
    )

/*++

Routine Description:

    Called when ScanDirectory finds a directory.

Arguments:

    Context - User-supplied context. Not used by emptydirs.

    Path - Directory containing this directory.

    ExistingDirectoryData - Pointer to data describing previous found directory with
        same name, if any.

    NewDirectoryData - Pointer to data for this directory.

    DirectoryUserData - Pointer to user-controlled data field for the directory.

    ParentDirectoryUserData - Pointer to user-controlled data field for the
        parent directory.

Return Value:

    DWORD - Indicates whether an error occurred.

--*/

{
    //
    // Increment the directory/file count for the parent. Set the directory's
    // user data pointer to 1, indicating that the scan library should
    // remember this directory and scan it.
    //

    (*(DWORD *)ParentDirectoryUserData)++;
    *(DWORD *)DirectoryUserData = 1;

    dprintf(( "  ND: Dir  %ws\\%ws: parent count %d, dir  count %d\n",
                Path, NewDirectoryData->cFileName,
                *(DWORD *)ParentDirectoryUserData, *DirectoryUserData ));

    return 0;

} // NewDirectory

DWORD
CheckDirectory (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW DirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData
    )

/*++

Routine Description:

    Called when ScanDirectory has completed the recursive scan for a directory.

Arguments:

    Context - User-supplied context. Not used by emptydirs.

    Path - Path to this directory. (Not to containing directory.)

    DirectoryData - Pointer to data for this directory.

    DirectoryUserData - Pointer to user-controlled data field for the directory.

    ParentDirectoryUserData - Pointer to user-controlled data field for the
        parent directory.

Return Value:

    DWORD - Indicates whether an error occurred.

--*/

{
    BOOL ok;
    DWORD error;

    //
    // If the directory's directory/file count is 1, then the directory
    // contains no files or directories (the count is biased by 1), and
    // is empty.
    //

    if ( *(DWORD *)DirectoryUserData == 1 ) {

        if ( !Quiet ) {
            if ( ShowWriteableFiles ) {
                printf( "DIR:  " );
            }
            printf( "%ws", Path );
        }

        //
        // If requested, delete this empty directory.
        //

        if ( DeleteEmptyDirectories ) {
            ok = RemoveDirectory( Path );
            if ( !ok ) {
                error = GetLastError( );
                if ( !Quiet ) printf( " - error %d\n", error );
                fprintf( stderr, "Error %d deleting %ws\n", error, Path );
                if ( !ContinueOnError ) {
                    return error;
                }
            } else {
                if ( !Quiet ) printf( " - deleted\n" );
            }
        } else {
            if ( !Quiet ) printf( "\n" );
        }

        //
        // Decrement the parent directory's directory/file count.
        //

        (*(DWORD *)ParentDirectoryUserData)--;
    }

    dprintf(( "  CD: Dir  %ws: parent count %d, dir  count %d\n",
                Path, 
                *(DWORD *)ParentDirectoryUserData, *DirectoryUserData ));

    return 0;

} // CheckDirectory

int
__cdecl
wmain (
    int argc,
    WCHAR *argv[]
    )
{
    BOOL ok;
    DWORD error;
    WCHAR directory[MAX_PATH];
    PVOID scanHandle = NULL;

    //
    // Parse switches.
    //

    argc--;
    argv++;

    while ( (argc != 0) && ((argv[0][0] == '-') || (argv[0][0] == '/')) ) {

        argv[0]++;

        switch ( towlower(argv[0][0]) ) {
        case 'c':
            ContinueOnError = TRUE;
            break;
        case 'd':
            DeleteEmptyDirectories = TRUE;
            break;
        case 'q':
            Quiet = TRUE;
            break;
        case 'w':
            ShowWriteableFiles = TRUE;
            break;
        default:
            fprintf( stderr, "usage: emptydirs [-cdqw]\n" );
            return 1;
        }
        argc--;
        argv++;
    }

    //
    // If a directory was specified, CD to it and get its path.
    //

    if ( argc != 0 ) {
        ok = SetCurrentDirectory( argv[0] );
        if ( !ok ) {
            error = GetLastError( );
            fprintf( stderr, "error: Unable to change to specified directory %ws: %d\n", argv[0], error );
            goto cleanup;
        }
    }
    argc--;
    argv++;

    GetCurrentDirectory( MAX_PATH, directory );

    //
    // Initialize the scan library.
    //

    error = ScanInitialize(
                &scanHandle,
                TRUE,           // recurse
                FALSE,          // don't skip root
                NULL
                );
    if (error != 0) {
        fprintf( stderr, "ScanInitialize(%ws) failed %d\n", directory, error );
        error = 1;
        goto cleanup;
    }

    //
    // Scan the specified directory.
    //

    error = ScanDirectory(
                scanHandle,
                directory,
                NULL,
                NewDirectory,
                CheckDirectory,
                NULL,
                NewFile,
                NULL
                );
    if (error != 0) {
        fprintf( stderr, "ScanDirectory(%ws) failed %d\n", directory, error );
        error = 1;
        goto cleanup;
    }

cleanup:

    //
    // Close down the scan library.
    //

    if ( scanHandle != NULL ) {
        ScanTerminate( scanHandle );
    }

    return error;

} // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\efinvram\efinvram.h ===
#define UNICODE 1

#include <nt.h>
//#include <ntosp.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4213)   // nonstandard extension used : cast on l-value

#include <stdio.h>
#include <stdlib.h>

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

extern PBOOT_OPTIONS BootOptions;
extern ULONG BootOptionsLength;
extern PBOOT_OPTIONS OriginalBootOptions;
extern ULONG OriginalBootOptionsLength;

extern PULONG BootEntryOrder;
extern ULONG BootEntryOrderCount;
extern PULONG OriginalBootEntryOrder;
extern ULONG OriginalBootEntryOrderCount;

//
// MY_BOOT_ENTRY is the internal representation of an EFI NVRAM boot item.
// The NtBootEntry item is the structure passed to/from the NT boot entry APIs.
//
typedef struct _MY_BOOT_ENTRY {
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PUCHAR AllocationEnd;
    ULONG Status;
    ULONG Id;
    ULONG Attributes;
    PWSTR FriendlyName;
    ULONG FriendlyNameLength;
    PWSTR OsLoadOptions;
    ULONG OsLoadOptionsLength;
    PFILE_PATH BootFilePath;
    PFILE_PATH OsFilePath;
    PUCHAR ForeignOsOptions;
    ULONG ForeignOsOptionsLength;
    BOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;

#define MBE_STATUS_IS_NT        0x00000001
#define MBE_STATUS_NEW          0x00000002
#define MBE_STATUS_DELETED      0x00000004
#define MBE_STATUS_MODIFIED     0x00000008
#define MBE_STATUS_COMMITTED    0x80000000

#define MBE_IS_NT(_be) (((_be)->Status & MBE_STATUS_IS_NT) != 0)
#define MBE_IS_NEW(_be) (((_be)->Status & MBE_STATUS_NEW) != 0)
#define MBE_IS_DELETED(_be) (((_be)->Status & MBE_STATUS_DELETED) != 0)
#define MBE_IS_MODIFIED(_be) (((_be)->Status & MBE_STATUS_MODIFIED) != 0)
#define MBE_IS_COMMITTED(_be) (((_be)->Status & MBE_STATUS_COMMITTED) != 0)

#define MBE_SET_IS_NT(_be) ((_be)->Status |= MBE_STATUS_IS_NT)
#define MBE_SET_NEW(_be) ((_be)->Status |= MBE_STATUS_NEW)
#define MBE_SET_DELETED(_be) ((_be)->Status |= MBE_STATUS_DELETED)
#define MBE_SET_MODIFIED(_be) ((_be)->Status |= MBE_STATUS_MODIFIED)
#define MBE_SET_COMMITTED(_be) ((_be)->Status |= MBE_STATUS_COMMITTED)

#define MBE_CLEAR_IS_NT(_be) ((_be)->Status &= ~MBE_STATUS_IS_NT)
#define MBE_CLEAR_NEW(_be) ((_be)->Status &= ~MBE_STATUS_NEW)
#define MBE_CLEAR_DELETED(_be) ((_be)->Status &= ~MBE_STATUS_DELETED)
#define MBE_CLEAR_MODIFIED(_be) ((_be)->Status &= ~MBE_STATUS_MODIFIED)
#define MBE_CLEAR_COMMITTED(_be) ((_be)->Status &= ~MBE_STATUS_COMMITTED)

#define MBE_IS_ACTIVE(_be) (((_be)->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0)
#define MBE_SET_ACTIVE(_be) ((_be)->Status |= BOOT_ENTRY_ATTRIBUTE_ACTIVE)
#define MBE_CLEAR_ACTIVE(_be) ((_be)->Status &= ~BOOT_ENTRY_ATTRIBUTE_ACTIVE)

#define IS_SEPARATE_ALLOCATION(_be,_p)                                  \
        ((_be->_p != NULL) &&                                           \
         (((PUCHAR)_be->_p < (PUCHAR)_be) ||                            \
          ((PUCHAR)_be->_p > (PUCHAR)_be->AllocationEnd)))

#define FREE_IF_SEPARATE_ALLOCATION(_be,_p)                             \
        if (IS_SEPARATE_ALLOCATION(_be,_p)) {                           \
            MemFree(_be->_p);                                           \
        }

extern LIST_ENTRY BootEntries;
extern LIST_ENTRY DeletedBootEntries;
extern LIST_ENTRY ActiveUnorderedBootEntries;
extern LIST_ENTRY InactiveUnorderedBootEntries;

PVOID
MemAlloc(
    IN SIZE_T Size
    );

PVOID
MemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    );

VOID
MemFree(
    IN PVOID Block
    );

VOID
InitializeMenuSystem (
    VOID
    );

VOID
MainMenu (
    VOID
    );

VOID
ClearMenuArea (
    VOID
    );

PMY_BOOT_ENTRY
SaveChanges (
    PMY_BOOT_ENTRY CurrentBootEntry
    );

PWSTR
GetNtNameForFilePath (
    IN PFILE_PATH FilePath
    );

VOID
FatalError (
    DWORD Error,
    PWSTR Format,
    ...
    );

VOID
SetStatusLine (
    PWSTR Status
    );

VOID
SetStatusLineAndWait (
    PWSTR Status
    );

VOID
SetStatusLine2 (
    PWSTR Status
    );

VOID
SetStatusLine2AndWait (
    PWSTR Status
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\efinvram\memory.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmemory.c

Abstract:

    Memory allocation routines for text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/



#include "efinvram.h"

PVOID
MemAlloc(
    IN SIZE_T Size
    )

/*++

Routine Description:

    This function is guaranteed to succeed.

Arguments:

Return Value:

--*/

{
    PSIZE_T p;

    //
    // Add space for storing the size of the block.
    //
    p = RtlAllocateHeap( RtlProcessHeap(), 0, Size + sizeof(SIZE_T) );

    if ( p == NULL ) {
        FatalError( ERROR_NOT_ENOUGH_MEMORY, L"Insufficient memory\n" );
    }

    //
    // Store the size of the block, and return the address
    // of the user portion of the block.
    //
    *p++ = Size;

    return p;
}



PVOID
MemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    )

/*++

Routine Description:

    This function is guaranteed to succeed.

Arguments:

Return Value:

--*/

{
    PSIZE_T NewBlock;
    SIZE_T  OldSize;

    //
    // Get the size of the block being reallocated.
    //
    OldSize = ((PSIZE_T)Block)[-1];

    //
    // Allocate a new block of the new size.
    //
    NewBlock = MemAlloc(NewSize);
    ASSERT(NewBlock);

    //
    // Copy the old block to the new block.
    //
    if (NewSize < OldSize) {
        RtlCopyMemory(NewBlock, Block, NewSize);
    } else {
        RtlCopyMemory(NewBlock, Block, OldSize);
    }

    //
    // Free the old block.
    //
    MemFree(Block);

    //
    // Return the address of the new block.
    //
    return(NewBlock);
}


VOID
MemFree(
    IN PVOID Block
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (Block == NULL)
        return;

    //
    // Free the block at its real address.
    //
    RtlFreeHeap( RtlProcessHeap(), 0, (PSIZE_T)Block - 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\efinvram\menu.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmenu.c

Abstract:

    Text setup menu support.

Author:

    Ted Miller (tedm) 8-September-1993

Revision History:

--*/


#include "efinvram.h"

WCHAR line[512];

HANDLE InputHandle;
HANDLE OutputHandle;
HANDLE OriginalOutputHandle = NULL;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;
CONSOLE_CURSOR_INFO OriginalCursorInfo;
DWORD OriginalInputMode;
WORD NormalAttribute;
WORD HighlightAttribute;
DWORD NumberOfColumns;
DWORD NumberOfRows;
DWORD NumberOfMenuLines;

#define MENUITEM_NORMAL     0x00000000
#define MENUITEM_STATIC     0x00000001


typedef struct _MENU_ITEM {

    PWSTR Text;

    ULONG Flags;

    ULONG LeftX;

    ULONG_PTR UserData;

    SIZE_T OriginalLength;

} MENU_ITEM, *PMENU_ITEM;


typedef struct _MENU {

    PMENU_ITEM Items;
    ULONG      ItemCount;

    ULONG      TopY;
    ULONG      Height;

    ULONG      LeftX;
    ULONG      Width;

    ULONG      TopDisplayedIndex;

    BOOLEAN    MoreUp,MoreDown;

} MENU, *PMENU;


BOOL
AddItems (
    PVOID Menu,
    PWSTR StaticText,
    PLIST_ENTRY ListHead
    );

VOID
DisplayMainMenuKeys (
    VOID
    );

VOID
DisplayEditMenuKeys (
    VOID
    );

VOID
EditBootEntry (
    IN PMY_BOOT_ENTRY BootEntry,
    IN OUT PBOOL ChangesMade
    );

VOID
EditTimeout (
    IN OUT PBOOL ChangesMade
    );

BOOL
PromptToSaveChanges (
    VOID
    );

PVOID
SpMnCreate(
    IN ULONG   LeftX,
    IN ULONG   TopY,
    IN ULONG   Width,
    IN ULONG   Height
    );

VOID
SpMnDestroy(
    IN PVOID Menu
    );

BOOLEAN
SpMnAddItem(
    IN PVOID   Menu,
    IN PWSTR   Text,
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN BOOLEAN Selectable,
    IN ULONG_PTR UserData
    );

PWSTR
SpMnGetText(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    );

PWSTR
SpMnGetTextDup(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    );

VOID
SpMnDisplay(
    IN  PVOID                  Menu,
    IN  ULONG_PTR              UserDataOfHighlightedItem,
    IN  PULONG                 ValidKeys,
    OUT PULONG                 KeyPressed,
    OUT PULONG_PTR             UserDataOfSelectedItem
    );

VOID
SpMnClearArea (
    IN ULONG Top,
    IN ULONG Bottom
    );

ULONG
SpWaitValidKey(
    IN PULONG ValidKeys1,
    IN PULONG ValidKeys2 OPTIONAL
    );

VOID
WriteConsoleLine (
    ULONG Row,
    ULONG Column,
    PWSTR Text,
    BOOL Highlight
    );

VOID
pSpMnDrawMenu(
    IN PMENU   pMenu,
    IN ULONG   SelectedIndex,
    IN BOOLEAN IndicateMore,
    IN PWSTR   MoreUpText,
    IN PWSTR   MoreDownText
    );


PVOID
SpMnCreate(
    IN ULONG   LeftX,
    IN ULONG   TopY,
    IN ULONG   Width,
    IN ULONG   Height
    )

/*++

Routine Description:

    Create a new menu by allocating space for a new menu structure
    and initializing its fields.

Arguments:

    LeftX - supplies the 0-based X coordinate of the leftmost column
        of the menu.

    TopY - supplies the 0-based Y coordinate of the topmost line
        of the menu.

    Width - supplies the maximum displayed width for lines in the menu.

    Height - supplies the maximum displayed height of the menu.
        The menu will scroll if it is too long to fit in the
        allotted space.

Return Value:

    Menu handle (expressed as a pvoid) of NULL if memory couldn't
    be allocated.

--*/

{
    PMENU p;

    p = MemAlloc( sizeof(MENU) );

    RtlZeroMemory( p, sizeof(MENU) );

    p->Items = MemAlloc( 0 );
    p->LeftX = LeftX;
    p->TopY = TopY;
    p->Width = Width;
    p->Height = Height;

    return p;
}


VOID
SpMnDestroy(
    IN PVOID Menu
    )

/*++

Routine Description:

    Destroy a menu, releasing all memory associated with it.

Arguments:

    Menu - supplies handle to menu to destroy.

Return Value:

    None.

--*/

{
    PMENU pMenu = Menu;
    ULONG u;


    for(u=0; u<pMenu->ItemCount; u++) {
        if(pMenu->Items[u].Text) {
            MemFree(pMenu->Items[u].Text);
        }
    }

    MemFree(pMenu->Items);

    MemFree(pMenu);
}



BOOLEAN
SpMnAddItem(
    IN PVOID   Menu,
    IN PWSTR   Text,
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN BOOLEAN Selectable,
    IN ULONG_PTR UserData
    )

/*++

Routine Description:

    Add an item to a menu.

Arguments:

    Menu - supplies handle to menu to which the item is to be added.

    Text - supplies text that comprises the menu selection.  This routine
        will make a copy of the text.

    LeftX - supplies 0-based x coordinate of leftmost character of the text
        when it is displayed.

    Width - supplies width in characters of the field for this selection.
        If this is larger than the number of characters in the text, then
        the text is padded to the right with blanks when highlighted.

    Selectable - if FALSE, then this text is static -- ie, not selectable.

    UserData - supplies a ulong's worth of caller-specific data to be associated
        with this menu item.

Return Value:

    TRUE if the menu item was added successfully; FALSE if insufficient memory.

--*/

{
    PMENU pMenu = Menu;
    PMENU_ITEM p;
    SIZE_T TextLen;
    SIZE_T PaddedLen;
    PWSTR String;
    ULONG u;
    SIZE_T ColumnLen;
    SIZE_T FillLen;

    //
    // Build a string that is padded to the right with blanks to make
    // it the right width.
    //
    TextLen = wcslen(Text);
    PaddedLen = max(TextLen,Width);
    ColumnLen = TextLen;
    FillLen = (PaddedLen <= ColumnLen) ? 0 : PaddedLen - ColumnLen;

    String = MemAlloc((PaddedLen+1)*sizeof(WCHAR));
    if(!String) {
        return(FALSE);
    }

    wcsncpy(String,Text,TextLen);
    for(u=0; u<FillLen; u++) {
        String[TextLen+u] = L' ';
    }
    String[TextLen+u] = 0;

    //
    // Make space for the item.
    //
    if((p = MemRealloc(pMenu->Items,(pMenu->ItemCount+1) * sizeof(MENU_ITEM))) == NULL) {
        MemFree(String);
        return(FALSE);
    }

    pMenu->Items = p;

    //
    // Calculate the address of the new menu item and
    // indicate that there is now an additional item in the menu.
    //
    p = &pMenu->Items[pMenu->ItemCount++];

    //
    // Set the fields of the menu.
    //
    p->LeftX = LeftX;
    p->UserData = UserData;

    p->Flags = Selectable ? MENUITEM_NORMAL : MENUITEM_STATIC;

    p->Text = String;

    p->OriginalLength = TextLen;

    return(TRUE);
}


PWSTR
SpMnGetText(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    )
{
    PMENU pMenu = Menu;
    ULONG i;

    for(i=0; i<pMenu->ItemCount; i++) {
        if(pMenu->Items[i].UserData == UserData) {
            return(pMenu->Items[i].Text);
        }
    }

    return(NULL);
}

PWSTR
SpMnGetTextDup(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    )
{
    PMENU pMenu = Menu;
    ULONG i;
    PWSTR p;

    for(i=0; i<pMenu->ItemCount; i++) {
        if(pMenu->Items[i].UserData == UserData) {
            //
            // Make a duplicate; leave off trailing pad spaces.
            //
            p = MemAlloc((pMenu->Items[i].OriginalLength+1)*sizeof(WCHAR));
            wcsncpy(p,pMenu->Items[i].Text,pMenu->Items[i].OriginalLength);
            p[pMenu->Items[i].OriginalLength] = 0;
            return(p);
        }
    }

    return(NULL);
}


VOID
SpMnDisplay(
    IN  PVOID                  Menu,
    IN  ULONG_PTR              UserDataOfHighlightedItem,
    IN  PULONG                 ValidKeys,
    OUT PULONG                 KeyPressed,
    OUT PULONG_PTR             UserDataOfSelectedItem
    )

/*++

Routine Description:

    Display a menu and accept keystrokes.

    When the user presses a menu keystroke (up/down arrow keys), this
    routine automatically updates the highlight and calls a callback function
    to inform the caller that a new item has the highlight.

    When the user presses a keystroke in a list provided by the caller,
    this routine returns, providing information about the key pressed and
    the item that was highlighted when the key was pressed.

Arguments:

    Menu - supplies handle to menu to be displayed.

    UserDataOfHighlightedItem - supplies user data of the menu item which
        is to receive the highlight initially.

    ValidKeys - supplies a list of keystrokes that cause this routine to
        return to the caller.  The list must be terminated with a 0 entry.

    KeyPressed - receives the key press that caused this routine to exit.
        This will be a valid from the ValidKeys array.

    UserDataOfSelectedItem - receives the UserData of the item that had the
        highlight when the user pressed a key in ValidKeys.

Return Value:

    None.

--*/


{
    ULONG ValidMenuKeys[3] = { VK_UP, VK_DOWN, 0 };
    ULONG key;
    PMENU pMenu = Menu;
    ULONG SelectedIndex,OldIndex;
    BOOLEAN FoundNewItem;
    ULONG NewTopDisplayedIndex;
    BOOLEAN MustScroll;
    PWSTR MoreUpText,MoreDownText;
    CONSOLE_CURSOR_INFO cursorInfo;

    cursorInfo = OriginalCursorInfo;
    cursorInfo.bVisible = FALSE;
    SetConsoleCursorInfo( OutputHandle, &cursorInfo );

    //
    // Get the text for the text that indicate that there are more
    // selections.
    //
    MoreUpText =   L"[More above...]";
    MoreDownText = L"[More below...]";

    //
    // Locate the seleccted item.
    //
    for(SelectedIndex=0; SelectedIndex<pMenu->ItemCount; SelectedIndex++) {
        if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)
        && (pMenu->Items[SelectedIndex].UserData == UserDataOfHighlightedItem))
        {
            break;
        }
    }
    ASSERT(SelectedIndex < pMenu->ItemCount);

    //
    // Make sure the selected item will be visible when we draw the menu.
    //
    pMenu->TopDisplayedIndex = 0;
    while(SelectedIndex >= pMenu->TopDisplayedIndex + pMenu->Height) {
        pMenu->TopDisplayedIndex += pMenu->Height;
    }

    //
    // Draw the menu itself.
    //
    pSpMnDrawMenu(pMenu,SelectedIndex,TRUE,MoreUpText,MoreDownText);

    while ( TRUE ) {

        //
        // Wait for a valid keypress.
        //
        key = SpWaitValidKey(ValidKeys,ValidMenuKeys);

        //
        // If the key is a menu keystroke, handle it here.
        //
        FoundNewItem = FALSE;
        MustScroll = FALSE;
        NewTopDisplayedIndex = 0;
        OldIndex = SelectedIndex;

        switch(key) {

        case VK_UP:

            //
            // Locate the previous selectable item.
            //
            if(SelectedIndex) {

                for(SelectedIndex=SelectedIndex-1; (LONG)SelectedIndex>=0; SelectedIndex--) {
                    if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)) {
                        FoundNewItem = TRUE;
                        break;
                    }
                }

                if(FoundNewItem) {
                    //
                    // Figure out whether we have to scroll the menu.
                    //
                    if(SelectedIndex < pMenu->TopDisplayedIndex) {
                        MustScroll = TRUE;
                        NewTopDisplayedIndex = SelectedIndex;
                    }
                } else {
                    //
                    // If the first lines are static text, there might be no
                    // way to get them back on the screen -- the tests above
                    // fail in this case.  So if the user hits the up arrow
                    // when he's at the topmost selectable item but there are
                    // static items above him, we'll simply scroll the menu
                    // so that item #0 is at the top.
                    //
                    FoundNewItem = TRUE;
                    NewTopDisplayedIndex = 0;
                    MustScroll = TRUE;
                    SelectedIndex = OldIndex;
                }
            }
            break;

        case VK_DOWN:

            //
            // Locate the next selectable item.
            //
            if(SelectedIndex < pMenu->ItemCount) {

                for(SelectedIndex=SelectedIndex+1; SelectedIndex < pMenu->ItemCount; SelectedIndex++) {

                    if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)) {
                        FoundNewItem = TRUE;
                        break;
                    }
                }

                if(FoundNewItem) {
                    //
                    // Figure out whether we have to scroll the menu.
                    //
                    if(SelectedIndex >= pMenu->TopDisplayedIndex + pMenu->Height) {
                        MustScroll = TRUE;
                        NewTopDisplayedIndex = pMenu->TopDisplayedIndex + SelectedIndex - OldIndex;
                    }
                }
            }
            break;

        default:

            //
            // User pressed a non-menu key.
            //
            *KeyPressed = key;
            *UserDataOfSelectedItem = pMenu->Items[SelectedIndex].UserData;

            SetConsoleCursorInfo( OutputHandle, &OriginalCursorInfo );
            return;
        }


        if(FoundNewItem) {

            //
            // Unhighlight the currently selected item.
            //
            WriteConsoleLine(
                pMenu->TopY + OldIndex - pMenu->TopDisplayedIndex,
                pMenu->Items[OldIndex].LeftX,
                pMenu->Items[OldIndex].Text,
                FALSE
                );


            //
            // Highlight the newly selected item.  This may involve
            // scrolling the menu.
            //
            if(MustScroll) {
                //
                // Redraw the menu so the newly highlighted line is in view.
                //
                pMenu->TopDisplayedIndex = NewTopDisplayedIndex;

                pSpMnDrawMenu(pMenu,SelectedIndex,TRUE,MoreUpText,MoreDownText);
            }

            //
            // Highlight the newly selected item.
            //
            WriteConsoleLine(
                pMenu->TopY + SelectedIndex - pMenu->TopDisplayedIndex,
                pMenu->Items[SelectedIndex].LeftX,
                pMenu->Items[SelectedIndex].Text,
                TRUE
                );


        } else {
            SelectedIndex = OldIndex;
        }
    }
}


VOID
pSpMnDrawMenu(
    IN PMENU   pMenu,
    IN ULONG   SelectedIndex,
    IN BOOLEAN IndicateMore,
    IN PWSTR   MoreUpText,
    IN PWSTR   MoreDownText
    )
{
    ULONG item;
    BOOLEAN MoreUp,MoreDown,MoreStatusChanged;

    //
    // Blank out the on-screen menu display.
    //
    for ( item = pMenu->TopY; item < (pMenu->TopY + pMenu->Height); item++ ) {
        WriteConsoleLine( item, 0, NULL, FALSE );
    }


    MoreUp = (BOOLEAN)(pMenu->TopDisplayedIndex > 0);
    MoreDown = (BOOLEAN)(pMenu->TopDisplayedIndex + pMenu->Height < pMenu->ItemCount);

    MoreStatusChanged = (BOOLEAN)(    IndicateMore
                                   && (    (pMenu->MoreUp != MoreUp)
                                        || (pMenu->MoreDown != MoreDown)
                                      )
                                 );

    //
    // Draw each item that is currently on-screen.
    //
    ASSERT(pMenu->TopDisplayedIndex < pMenu->ItemCount);
    for(item = pMenu->TopDisplayedIndex;
        item < min(pMenu->TopDisplayedIndex+pMenu->Height,pMenu->ItemCount);
        item++)
    {
        WriteConsoleLine(
            pMenu->TopY + item - pMenu->TopDisplayedIndex,
            pMenu->Items[item].LeftX,
            pMenu->Items[item].Text,
            (BOOLEAN)(item == SelectedIndex)
            );
    }


    //
    // If there are more selections above or below us,
    // indicate so by placing a small bit of text on the frame.
    // Note that the arrow chars can sometimes be DBCS.
    //
    if(MoreStatusChanged) {

        if(MoreUp) {
            WriteConsoleLine(
                pMenu->TopY - 1,
                pMenu->LeftX + 4,
                MoreUpText,
                FALSE
                );
        } else {
            WriteConsoleLine(
                pMenu->TopY - 1,
                0,
                NULL,
                FALSE
                );
        }

        if(MoreDown) {
            WriteConsoleLine(
                pMenu->TopY + pMenu->Height,
                pMenu->LeftX + 4,
                MoreDownText,
                FALSE
                );
        } else {
            WriteConsoleLine(
                pMenu->TopY + pMenu->Height,
                0,
                NULL,
                FALSE
                );
        }

        pMenu->MoreUp = MoreUp;
        pMenu->MoreDown = MoreDown;
    }
}

VOID
InitializeMenuSystem (
    VOID
    )
{
    DWORD error;
    COORD windowSize;
    CONSOLE_CURSOR_INFO cursorInfo;
    cursorInfo = OriginalCursorInfo;
    cursorInfo.bVisible = FALSE;

    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    if ( InputHandle == NULL ) {
        error = GetLastError( );
        FatalError( error, L"Unable to get stdin handle: %d\n", error );
    }

    if ( !GetConsoleMode( InputHandle, &OriginalInputMode ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to get stdin mode: %d\n", error );
    }

    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    if ( OriginalOutputHandle == NULL ) {
        error = GetLastError( );
        FatalError( error, L"Unable to get stdout handle: %d\n", error );
    }

    OutputHandle = CreateConsoleScreenBuffer(
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,
                        CONSOLE_TEXTMODE_BUFFER,
                        NULL
                        );
    if ( OutputHandle == NULL ) {
        error = GetLastError( );
        FatalError( error, L"Unable to create console screen buffer: %d\n", error );
    }

    if ( !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to get console screen buffer info: %d\n", error );
    }
    
    if ( !GetConsoleCursorInfo( OriginalOutputHandle, &OriginalCursorInfo ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to get console screen buffer info: %d\n", error );
    }
    
    NormalAttribute = 0x1F;
    HighlightAttribute = 0x71;
    NumberOfColumns = OriginalConsoleInfo.srWindow.Right - OriginalConsoleInfo.srWindow.Left + 1;
    NumberOfRows = OriginalConsoleInfo.srWindow.Bottom - OriginalConsoleInfo.srWindow.Top + 1;
    NumberOfMenuLines = NumberOfRows - (3 + 1 + 1 + 1 + 8);
    if ( NumberOfMenuLines > 12 ) {
        NumberOfMenuLines = 12;
    }

    if ( NumberOfRows < 20 ) {
        FatalError(
            ERROR_INVALID_PARAMETER,
            L"Please run this program in a console window with 20 or more lines\n"
            );
    }
    if ( NumberOfColumns < 80 ) {
        FatalError(
            ERROR_INVALID_PARAMETER,
            L"Please run this program in a console window with 80 or more columns\n"
            );
    }

    windowSize.X = (SHORT)NumberOfColumns;
    windowSize.Y = (SHORT)NumberOfRows;

    if ( !SetConsoleScreenBufferSize( OutputHandle, windowSize ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to set console screen buffer size: %d\n", error );
    }

    if ( !SetConsoleActiveScreenBuffer( OutputHandle ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to set active screen buffer: %d\n", error );
    }

    if ( !SetConsoleMode( InputHandle, 0 ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to set console mode: %d\n", error );
    }

    return;

} // InitializeMenuSystem

VOID
FatalError (
    DWORD Error,
    PWSTR Format,
    ...
    )
{
    va_list marker;

    if ( OutputHandle != NULL ) {
        SetConsoleCursorInfo( OutputHandle, &OriginalCursorInfo );
        CloseHandle( OutputHandle );
        if ( OriginalOutputHandle != NULL ) {
            SetConsoleActiveScreenBuffer( OriginalOutputHandle );
            SetConsoleMode( InputHandle, OriginalInputMode );
        }
    }

    va_start( marker, Format );
    vwprintf( Format, marker );
    va_end( marker );

    if ( Error == NO_ERROR ) {
        Error = ERROR_GEN_FAILURE;
    }
    exit( Error );

} // FatalError

VOID
WriteConsoleLine (
    ULONG Row,
    ULONG Column,
    PWSTR Text,
    BOOL Highlight
    )
{
    BOOL ok;
    DWORD error;
    COORD writeCoord;
    DWORD numberWritten;
    DWORD textLength;

    writeCoord.X = 0;
    writeCoord.Y = (SHORT)Row;

    ok = FillConsoleOutputCharacter(
            OutputHandle,
            ' ',
            NumberOfColumns,
            writeCoord,
            &numberWritten
            );
    if ( !ok ) {
        error = GetLastError( );
        FatalError( error, L"Error filling console line: %d\n", error );
    }

    ok = FillConsoleOutputAttribute(
            OutputHandle,
            OriginalConsoleInfo.wAttributes,
            NumberOfColumns,
            writeCoord,
            &numberWritten
            );
    if ( !ok ) {
        error = GetLastError( );
        FatalError( error, L"Error filling console attributes: %d\n", error );
    }

    if ( (Text == NULL) || ((textLength = (DWORD)wcslen( Text )) == 0) ) {
        return;
    }

    writeCoord.X = (SHORT)Column;

    ok = WriteConsoleOutputCharacter(
            OutputHandle,
            Text,
            textLength,
            writeCoord,
            &numberWritten
            );
    if ( !ok ) {
        error = GetLastError( );
        FatalError( error, L"Error writing console line: %d\n", error );
    }

    if (Highlight) {

        WORD attr = ((OriginalConsoleInfo.wAttributes & 0xf0) >> 4) +
                    ((OriginalConsoleInfo.wAttributes & 0x0f) << 4);

        ok = FillConsoleOutputAttribute(
                OutputHandle,
                attr,
                textLength,
                writeCoord,
                &numberWritten
                );
        if ( !ok ) {
            error = GetLastError( );
            FatalError( error, L"Error writing console attributes: %d\n", error );
        }
    }

    return;

} // WriteConsoleLine

ULONG
SpWaitValidKey(
    IN PULONG ValidKeys1,
    IN PULONG ValidKeys2 OPTIONAL
    )

/*++

Routine Description:

    Wait for a key to be pressed that appears in a list of valid keys.

Arguments:

    ValidKeys1 - supplies list of valid keystrokes.  The list must be
        terminated with a 0 entry.

    ValidKeys2 - if specified, supplies an additional list of valid keystrokes.

Return Value:

    The key that was pressed (see above).

--*/

{
    ULONG c;
    ULONG i;
    INPUT_RECORD InputRecord;
    ULONG NumberOfInputRecords;

    FlushConsoleInputBuffer( InputHandle );

    while ( TRUE ) {

        WaitForSingleObject( InputHandle, INFINITE );
        if ( ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
             InputRecord.EventType == KEY_EVENT &&
             InputRecord.Event.KeyEvent.bKeyDown ) {

            c = InputRecord.Event.KeyEvent.wVirtualKeyCode;

            //
            // Check for normal key.
            //
    
            for(i=0; ValidKeys1[i]; i++) {
                if(c == ValidKeys1[i]) {
                    return(c);
                }
            }
    
            //
            // Check secondary list.
            //
            if(ValidKeys2) {
                for(i=0; ValidKeys2[i]; i++) {
                    if(c == ValidKeys2[i]) {
                        return(c);
                    }
                }
            }
        }
    }
}

VOID
SpMnClearArea (
    IN ULONG Top,
    IN ULONG Bottom
    )
{
    ULONG row;

    for ( row = Top; row <= Bottom; row++ ) {
        WriteConsoleLine( row, 0, NULL, FALSE );
    }

    return;

} // SpMnClearArea

VOID
MainMenu (
    VOID
    )
{
    BOOL b;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY listEntry2;
    PMY_BOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY currentBootEntry;
    ULONG validKeys[] = {
        VK_ESCAPE,
        VK_RETURN,
        VK_PRIOR,
        VK_NEXT,
        VK_HOME,
        VK_END,
        VK_DELETE,
        'Q',
        'U',
        'D',
        'T',
        'B',
        'X',
        'A',
        'O',
        'E',
        'M',
        'S',
        0
        };
    PVOID menu;
    ULONG pressedKey;
    BOOL changesMade = FALSE;

    WriteConsoleLine( 1, 1, L"Windows EFI NVRAM Editor", FALSE );

    listEntry = BootEntries.Flink;
    if ( listEntry != &BootEntries ) {
        currentBootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
    } else {
        currentBootEntry = NULL;
    }

    while ( TRUE ) {

        menu = SpMnCreate( 4, 4, NumberOfColumns - 4, NumberOfMenuLines );

        b = AddItems(
                menu,
                NULL,
                &BootEntries
                );
        b |= AddItems(
                menu,
                L"The following boot entries are marked active, but are not in the boot order list:",
                &ActiveUnorderedBootEntries
                );
        b |= AddItems(
                menu,
                L"The following boot entries are marked inactive, and are not in the boot order list:",
                &InactiveUnorderedBootEntries
                );

        if ( !b ) {
    
            swprintf( line, L"No boot entries to display" );
            SpMnAddItem(
                menu,
                line,
                4,
                (ULONG)wcslen( line ),
                TRUE,
                (ULONG_PTR)NULL
                );
            currentBootEntry = NULL;
        }
    
        DisplayMainMenuKeys( );

        SpMnDisplay(
            menu,
            (ULONG_PTR)currentBootEntry,
            validKeys,
            &pressedKey,
            (ULONG_PTR *)&bootEntry
            );
    
        SpMnDestroy( menu );

        if ( (pressedKey == 'Q') || (pressedKey == VK_ESCAPE) ) {
            if ( changesMade ) {
                if ( PromptToSaveChanges( ) ) {
                    ClearMenuArea( );
                    SaveChanges( NULL );
                }
            }
            break;
        }

        if ( bootEntry != NULL ) {

            currentBootEntry = bootEntry;

            if ( bootEntry->ListHead == &BootEntries ) {
            
                if ( (pressedKey == 'U') || (pressedKey == VK_PRIOR) ) {
    
                    listEntry2 = bootEntry->ListEntry.Blink;
                    if ( listEntry2 != &BootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertTailList( listEntry2, &bootEntry->ListEntry );
                        changesMade = TRUE;
                    }
                    continue;
            
                } else if ( (pressedKey == 'D') || (pressedKey == VK_NEXT) ) {
    
                    listEntry2 = bootEntry->ListEntry.Flink;
                    if ( listEntry2 != &BootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertHeadList( listEntry2, &bootEntry->ListEntry );
                        changesMade = TRUE;
                    }
                    continue;
            
                } else if ( (pressedKey == 'T') || (pressedKey == VK_HOME) ) {
    
                    listEntry2 = bootEntry->ListEntry.Blink;
                    if ( listEntry2 != &BootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertHeadList( &BootEntries, &bootEntry->ListEntry );
                        changesMade = TRUE;
                    }
                    continue;
            
                } else if ( (pressedKey == 'B') || (pressedKey == VK_END) ) {
    
                    listEntry2 = bootEntry->ListEntry.Flink;
                    if ( listEntry2 != &BootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertTailList( &BootEntries, &bootEntry->ListEntry );
                        changesMade = TRUE;
                    }
                    continue;
                }
        
            }

            if ( (pressedKey == 'X') || (pressedKey == VK_DELETE) ) {

                MBE_SET_DELETED( bootEntry );
                listEntry2 = bootEntry->ListEntry.Flink;
                currentBootEntry = CONTAINING_RECORD( listEntry2, MY_BOOT_ENTRY, ListEntry );
                if ( listEntry2 == bootEntry->ListHead ) {
                    listEntry2 = bootEntry->ListEntry.Blink;
                    currentBootEntry = CONTAINING_RECORD( listEntry2, MY_BOOT_ENTRY, ListEntry );
                    if ( listEntry2 == bootEntry->ListHead ) {
                        currentBootEntry = NULL;
                    }
                }
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &DeletedBootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &DeletedBootEntries;
                changesMade = TRUE;

            } else if ( (pressedKey == 'E') || (pressedKey == VK_RETURN) ) {

                EditBootEntry( bootEntry, &changesMade );

            } else if ( pressedKey == 'M' ) {

                EditTimeout( &changesMade );

            } else if ( pressedKey == 'S' ) {

                if ( changesMade ) {
                    ClearMenuArea( );
                    currentBootEntry = SaveChanges( currentBootEntry );
                    changesMade = FALSE;
                }

            } else if ( pressedKey == 'A' ) {

                if ( MBE_IS_ACTIVE( bootEntry ) ) {

                    MBE_CLEAR_ACTIVE( bootEntry );
                    MBE_SET_MODIFIED( bootEntry );
                    if ( bootEntry->ListHead == &ActiveUnorderedBootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertTailList( &InactiveUnorderedBootEntries, &bootEntry->ListEntry );
                        bootEntry->ListHead = &InactiveUnorderedBootEntries;
                    }

                } else {

                    MBE_SET_ACTIVE( bootEntry );
                    MBE_SET_MODIFIED( bootEntry );
                    if ( bootEntry->ListHead == &InactiveUnorderedBootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertTailList( &ActiveUnorderedBootEntries, &bootEntry->ListEntry );
                        bootEntry->ListHead = &ActiveUnorderedBootEntries;
                    }
                }
                changesMade = TRUE;

            } else if ( pressedKey == 'O' ) {

                RemoveEntryList( &bootEntry->ListEntry );

                if ( bootEntry->ListHead == &BootEntries ) {

                    if ( MBE_IS_ACTIVE( bootEntry ) ) {
                        InsertTailList( &ActiveUnorderedBootEntries, &bootEntry->ListEntry );
                        bootEntry->ListHead = &ActiveUnorderedBootEntries;
                    } else {
                        InsertTailList( &InactiveUnorderedBootEntries, &bootEntry->ListEntry );
                        bootEntry->ListHead = &InactiveUnorderedBootEntries;
                    }

                } else {

                    InsertTailList( &BootEntries, &bootEntry->ListEntry );
                    bootEntry->ListHead = &BootEntries;
                }
                changesMade = TRUE;
            }
        }
    }

} // MainMenu

BOOL
AddItems (
    PVOID Menu,
    PWSTR StaticText,
    PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY bootEntry;

    if ( ListHead->Flink != ListHead ) {

        if ( ARGUMENT_PRESENT(StaticText) ) {
        
            SpMnAddItem(
                Menu,
                L"",
                4,
                0,
                FALSE,
                (ULONG_PTR)NULL
                );
            SpMnAddItem(
                Menu,
                StaticText,
                4,
                (ULONG)wcslen( StaticText ),
                FALSE,
                (ULONG_PTR)NULL
                );
        }

        for ( listEntry = ListHead->Flink;
              listEntry != ListHead;
              listEntry = listEntry->Flink ) {

            PWSTR osDirectoryNtName = NULL;

            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

            if ( MBE_IS_NT( bootEntry ) ) {

                osDirectoryNtName = GetNtNameForFilePath( bootEntry->OsFilePath );
            }

            if ( osDirectoryNtName != NULL) {
                swprintf(
                    line,
                    L"%-40ws %ws",
                    bootEntry->FriendlyName,
                    osDirectoryNtName
                    );
            } else {
                swprintf(
                    line,
                    L"%ws",
                    bootEntry->FriendlyName
                    );
            }
            SpMnAddItem(
                Menu,
                line,
                6,
                (ULONG)wcslen( line ),
                TRUE,
                (ULONG_PTR)bootEntry
                );

            if ( osDirectoryNtName != NULL ) {
                MemFree( osDirectoryNtName );
            }
        }

        return TRUE;
    }

    return FALSE;

} // AddItems

VOID
EditFriendlyName (
    IN OUT PMY_BOOT_ENTRY BootEntry,
    IN OUT PBOOL ChangesMade
    )
{
    COORD position;
    DWORD numberRead;

    SpMnClearArea( 3, 3 + NumberOfMenuLines + 1 );

    swprintf( line, L"Current friendly name: %ws", BootEntry->FriendlyName );
    WriteConsoleLine( 4, 4, line, FALSE );

    swprintf( line, L"    New friendly name: " );
    WriteConsoleLine( 6, 4, line, FALSE );

    position.X = (USHORT)(4 + wcslen( line ));
    position.Y = 6;
    SetConsoleCursorPosition( OutputHandle, position );

    SetConsoleMode( InputHandle, OriginalInputMode );
    ReadConsole( InputHandle, line, 511, &numberRead, NULL );
    SetConsoleMode( InputHandle, 0 );

    if ( numberRead >= 2 ) {
        numberRead -= 2;
    }

    if ( numberRead != 0 ) {

        line[numberRead] = 0;

        if ( wcscmp( BootEntry->FriendlyName, line ) != 0 ) {
            FREE_IF_SEPARATE_ALLOCATION( BootEntry, FriendlyName );
            BootEntry->FriendlyNameLength = (numberRead + 1) * sizeof(WCHAR);
            BootEntry->FriendlyName = MemAlloc( BootEntry->FriendlyNameLength );
            wcscpy( BootEntry->FriendlyName, line );
            MBE_SET_MODIFIED( BootEntry );
            *ChangesMade = TRUE;
        }
    }
    
    return;

} // EditFriendlyName

VOID
EditLoadOptions (
    IN OUT PMY_BOOT_ENTRY BootEntry,
    IN OUT PBOOL ChangesMade
    )
{
    COORD position;
    DWORD numberRead;

    SpMnClearArea( 3, 3 + NumberOfMenuLines + 1 );

    swprintf( line, L"Current load options: %ws", BootEntry->OsLoadOptions );
    WriteConsoleLine( 4, 4, line, FALSE );

    swprintf( line, L"    New load options: " );
    WriteConsoleLine( 6, 4, line, FALSE );

    position.X = (USHORT)(4 + wcslen( line ));
    position.Y = 6;
    SetConsoleCursorPosition( OutputHandle, position );

    SetConsoleMode( InputHandle, OriginalInputMode );
    ReadConsole( InputHandle, line, 511, &numberRead, NULL );
    SetConsoleMode( InputHandle, 0 );

    if ( numberRead >= 2 ) {
        numberRead -= 2;
    }

    if ( numberRead != 0 ) {

        line[numberRead] = 0;

        if ( wcscmp( BootEntry->OsLoadOptions, line ) != 0 ) {
            FREE_IF_SEPARATE_ALLOCATION( BootEntry, OsLoadOptions );
            BootEntry->OsLoadOptionsLength = (numberRead + 1) * sizeof(WCHAR);
            BootEntry->OsLoadOptions = MemAlloc( BootEntry->OsLoadOptionsLength );
            wcscpy( BootEntry->OsLoadOptions, line );
            MBE_SET_MODIFIED( BootEntry );
            *ChangesMade = TRUE;
        }
    }
    
    return;

} // EditLoadOptions

VOID
EditBootEntry (
    IN PMY_BOOT_ENTRY BootEntry,
    IN OUT PBOOL ChangesMade
    )
{
    ULONG numValidKeys;
    ULONG validKeys[20];
    PVOID menu;
    ULONG pressedKey;
    ULONG_PTR itemToEdit;

    while ( TRUE ) {

        menu = SpMnCreate( 4, 4, NumberOfColumns - 4, NumberOfMenuLines );

        numValidKeys = 0;
        validKeys[numValidKeys++] = VK_ESCAPE;
        validKeys[numValidKeys++] = 'Q';
        validKeys[numValidKeys++] = VK_RETURN;
        validKeys[numValidKeys++] = 'E';

        swprintf(
            line,
            L"Friendly name: %ws",
            BootEntry->FriendlyName
            );
        SpMnAddItem(
            menu,
            line,
            4,
            (ULONG)wcslen( line ),
            TRUE,
            1
            );
        validKeys[numValidKeys++] = 'F';

        if ( MBE_IS_NT( BootEntry ) ) {
        
            swprintf(
                line,
                L"Load options: %ws",
                BootEntry->OsLoadOptions
                );
            SpMnAddItem(
                menu,
                line,
                4,
                (ULONG)wcslen( line ),
                TRUE,
                2
                );
            validKeys[numValidKeys++] = 'L';
        }
    
        validKeys[numValidKeys] = 0;

        DisplayEditMenuKeys( );

        SpMnDisplay(
            menu,
            1,
            validKeys,
            &pressedKey,
            &itemToEdit
            );
    
        SpMnDestroy( menu );

        if ( (pressedKey == 'Q') || (pressedKey == VK_ESCAPE) ) {
            break;
        }

        if ( (itemToEdit == 1) || (pressedKey == 'F') ) {
            EditFriendlyName( BootEntry, ChangesMade );
        } else if ( (itemToEdit == 2) || (pressedKey == 'L') ) {
            EditLoadOptions( BootEntry, ChangesMade );
        }
    }

    return;

} // EditBootEntry

VOID
EditTimeout (
    IN OUT PBOOL ChangesMade
    )
{
    COORD position;
    DWORD numberRead;
    ULONG timeout;
    ULONG i;
    PWSTR p;

    SpMnClearArea( 3, 3 + NumberOfMenuLines + 1 );

    swprintf( line, L"Current timeout: %d", BootOptions->Timeout );
    WriteConsoleLine( 4, 4, line, FALSE );

again:

    swprintf( line, L"    New timeout: " );
    WriteConsoleLine( 6, 4, line, FALSE );

    position.X = (USHORT)(4 + wcslen( line ));
    position.Y = 6;
    SetConsoleCursorPosition( OutputHandle, position );

    SetConsoleMode( InputHandle, OriginalInputMode );
    ReadConsole( InputHandle, line, 511, &numberRead, NULL );
    SetConsoleMode( InputHandle, 0 );

    if ( numberRead >= 2 ) {
        numberRead -= 2;
    }

    if ( numberRead != 0 ) {

        line[numberRead] = 0;

        timeout = 0;
        p = line;

        while ( *p != 0 ) {

            if ( (*p < L'0') || (*p > L'9') ) {
                swprintf( line, L"Invalid characters in number" );
                WriteConsoleLine( 8, 4, line, TRUE );
                goto again;
            }

            i = (timeout * 10) + (*p - L'0');

            if ( i < timeout ) {
                swprintf( line, L"Overflow in number %d %d", i, timeout );
                WriteConsoleLine( 8, 4, line, TRUE );
                goto again;
            }

            timeout = i;

            p++;
        }

        if ( timeout != BootOptions->Timeout ) {
            BootOptions->Timeout = timeout;
            *ChangesMade = TRUE;
        }
    }
    
    return;

} // EditTimeout

BOOL
PromptToSaveChanges (
    VOID
    )
{
    COORD position;
    ULONG keys[] = { 'Y', 'N', 0 };
    ULONG key;

    SpMnClearArea( 3, 3 + NumberOfMenuLines + 1 );

    swprintf( line, L"Save changes?" );
    WriteConsoleLine( 4, 4, line, TRUE );

    position.X = (USHORT)(4 + wcslen( line ));
    position.Y = 4;
    SetConsoleCursorPosition( OutputHandle, position );

    key = SpWaitValidKey( keys, NULL );

    return (BOOL)(key == 'Y');

} // PromptToSaveChanges

VOID
ClearMenuArea (
    VOID
    )
{
    SpMnClearArea( 3, 3 + NumberOfMenuLines + 1 );
}

VOID
SetStatusLine (
    PWSTR Status
    )
{
    COORD position;

    WriteConsoleLine( 4, 4, Status, TRUE );

    position.X = (USHORT)(4 + wcslen( Status ));
    position.Y = 4;
    SetConsoleCursorPosition( OutputHandle, position );
}

VOID
SetStatusLineAndWait (
    PWSTR Status
    )
{
    ULONG keys[] = { VK_ESCAPE, VK_RETURN, VK_SPACE, 0 };

    SetStatusLine( Status );

    SpWaitValidKey( keys, NULL );
}

VOID
SetStatusLine2 (
    PWSTR Status
    )
{
    COORD position;

    WriteConsoleLine( 6, 4, Status, TRUE );

    position.X = (USHORT)(4 + wcslen( Status ));
    position.Y = 6;
    SetConsoleCursorPosition( OutputHandle, position );
}

VOID
SetStatusLine2AndWait (
    PWSTR Status
    )
{
    ULONG keys[] = { VK_ESCAPE, VK_RETURN, VK_SPACE, 0 };

    SetStatusLine2( Status );

    SpWaitValidKey( keys, NULL );
}

VOID
DisplayMainMenuKeys (
    VOID
    )
{
    ULONG startLine = 3 + 1 + NumberOfMenuLines + 1 + 1;

    SpMnClearArea( startLine, NumberOfRows - 1 );

    WriteConsoleLine(
        startLine,
        1,
        L"PGUP/U = Move up      | HOME/T = Move to top    | DELETE/X = Delete",
        FALSE
        );
    WriteConsoleLine(
        startLine + 1,
        1,
        L"PGDN/D = Move down    |  END/B = Move to bottom | RETURN/E = Edit",
        FALSE
        );

    WriteConsoleLine(
        startLine + 3,
        1,
        L"     A = [De]activate |      O = Remove from/add to boot order",
        FALSE
        );

    WriteConsoleLine(
        startLine + 5,
        1,
        L"     M = Set timeout",
        FALSE
        );

    WriteConsoleLine(
        startLine + 7,
        1,
        L" ESC/Q = Quit         |      S = Save changes",
        FALSE
        );

    return;

} // DisplayMainMenuKeys

VOID
DisplayEditMenuKeys (
    VOID
    )
{
    ULONG startLine = 3 + 1 + NumberOfMenuLines + 1 + 1 + 1;

    SpMnClearArea( startLine, NumberOfRows - 1 );

    WriteConsoleLine(
        startLine + 1,
        1,
        L" ESC/Q = Quit         |                         | RETURN/E = Edit",
        FALSE
        );

    return;

} // DisplayEditMenuKeys
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\emptydirs\scanlib\precomp.h ===
#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "scan.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\emptydirs\scanlib\scan.c ===
#include "precomp.h"
#pragma hdrstop

#if SCAN_DEBUG
BOOL scan_dprinton = FALSE;
#define dprintf(_x_) if (scan_dprinton) printf _x_
#else
#define dprintf(_x_)
#endif

#define FlagOn(_mask,_flag)  (((_mask) & (_flag)) != 0)
#define FlagOff(_mask,_flag) (((_mask) & (_flag)) == 0)
#define SetFlag(_mask,_flag) ((_mask) |= (_flag))
#define ClearFlag(_mask,_flag) ((_mask) &= ~(_flag))

typedef struct _CONTAINER_ENTRY {
    LIST_ENTRY SiblingListEntry;
    LIST_ENTRY ContainerList;
    LIST_ENTRY ObjectList;
    struct _CONTAINER_ENTRY *Parent;
    PVOID UserData;
} CONTAINER_ENTRY, *PCONTAINER_ENTRY;

typedef struct _OBJECT_ENTRY {
    LIST_ENTRY SiblingListEntry;
    PVOID UserData;
} OBJECT_ENTRY, *POBJECT_ENTRY;

#define InitializeContainer(_container,_parent) {               \
        InitializeListHead(&(_container)->ContainerList);       \
        InitializeListHead(&(_container)->ObjectList);          \
        (_container)->Parent = (PCONTAINER_ENTRY)(_parent);     \
    }

#define InitializeObject(_object)

#define InsertContainer(_container,_subcontainer)                                           \
        InsertTailList(&(_container)->ContainerList,&(_subcontainer)->SiblingListEntry)

#define InsertObject(_container,_object)                                        \
        InsertTailList(&(_container)->ObjectList,&(_object)->SiblingListEntry)

#define RemoveObject(_object) RemoveEntryList(&(_object)->SiblingListEntry)
#define RemoveContainer(_container) RemoveEntryList(&(_container)->SiblingListEntry)

#define GetFirstObject(_container)                                      \
        ((_container)->ObjectList.Flink != &(_container)->ObjectList ?  \
            CONTAINING_RECORD( (_container)->ObjectList.Flink,          \
                               OBJECT_ENTRY,                            \
                               SiblingListEntry ) : NULL)

#define GetNextObject(_container,_object)                                   \
        ((_object)->SiblingListEntry.Flink != &(_container)->ObjectList ?   \
            CONTAINING_RECORD( (_object)->SiblingListEntry.Flink,           \
                               OBJECT_ENTRY,                                \
                               SiblingListEntry ) : NULL)

#define GetFirstContainer(_container)                                               \
        ((_container)->ContainerList.Flink != &(_container)->ContainerList ?        \
            CONTAINING_RECORD( (_container)->ContainerList.Flink,                   \
                               CONTAINER_ENTRY,                                     \
                               SiblingListEntry ) : NULL)

#define GetNextContainer(_container)                                                        \
        ((_container)->SiblingListEntry.Flink != &(_container)->Parent->ContainerList ?     \
            CONTAINING_RECORD( (_container)->SiblingListEntry.Flink,                        \
                               CONTAINER_ENTRY,                                             \
                               SiblingListEntry ) : NULL)

#define GetParent(_container) ((_container)->Parent)
#define GetParentUserData(_container) &(GetParent(_container))->UserData

typedef struct _DIRECTORY_ENTRY {
    CONTAINER_ENTRY ;
    SMALL_WIN32_FIND_DATAW FindData;
} DIRECTORY_ENTRY, *PDIRECTORY_ENTRY;

typedef struct _FILE_ENTRY {
    OBJECT_ENTRY ;
    SMALL_WIN32_FIND_DATAW FindData;
} FILE_ENTRY, *PFILE_ENTRY;

typedef struct _SCAN_PARAMETERS {
    PSCAN_FREE_USER_DATA_CALLBACK FreeUserDataCallback;
    BOOL Recurse;
    BOOL SkipRoot;
    DIRECTORY_ENTRY RootDirectoryEntry;
} SCAN_PARAMETERS, *PSCAN_PARAMETERS;

VOID
ScanFreeChildren (
    IN PSCAN_PARAMETERS Parameters,
    IN PCONTAINER_ENTRY Container
    );

DWORD
ScanInitialize (
    OUT PVOID *ScanHandle,
    IN BOOL Recurse,
    IN BOOL SkipRoot,
    IN PSCAN_FREE_USER_DATA_CALLBACK FreeUserDataCallback OPTIONAL
    )
{
    PSCAN_PARAMETERS params;
    DWORD size;
    DWORD error;

    params = malloc( sizeof(SCAN_PARAMETERS) );
    if ( params == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    *ScanHandle = params;

    params->Recurse = Recurse;
    params->SkipRoot = SkipRoot;
    params->FreeUserDataCallback = FreeUserDataCallback;

    InitializeContainer( &params->RootDirectoryEntry, NULL );
    params->RootDirectoryEntry.UserData = NULL;
    params->RootDirectoryEntry.FindData.cFileName[0] = 0;
    
    return NO_ERROR;
}

DWORD
ScanDirectory (
    IN PVOID ScanHandle,
    IN PWCH ScanPath,
    IN PVOID Context OPTIONAL,
    IN PSCAN_NEW_DIRECTORY_CALLBACK NewDirectoryCallback OPTIONAL,
    IN PSCAN_CHECK_DIRECTORY_CALLBACK CheckDirectoryCallback OPTIONAL,
    IN PSCAN_RECURSE_DIRECTORY_CALLBACK RecurseDirectoryCallback OPTIONAL,
    IN PSCAN_NEW_FILE_CALLBACK NewFileCallback OPTIONAL,
    IN PSCAN_CHECK_FILE_CALLBACK CheckFileCallback OPTIONAL
    )
{
    BOOL ok;
    DWORD error;
    PSCAN_PARAMETERS params;
    PDIRECTORY_ENTRY rootDirectory;
    PDIRECTORY_ENTRY currentDirectory;
    PDIRECTORY_ENTRY newDirectory;
    PFILE_ENTRY newFile;
    WIN32_FIND_DATA fileData;
    HANDLE findHandle;
    PVOID userData;
    WCHAR currentDirectoryName[MAX_PATH + 1];

    params = ScanHandle;
    rootDirectory = &params->RootDirectoryEntry;
    currentDirectory = rootDirectory;
    wcscpy( currentDirectoryName, ScanPath );

    do {

        wcscat( currentDirectoryName, L"\\*" );
        dprintf(( "FindFirst for %ws\n", currentDirectoryName ));
        findHandle = FindFirstFile( currentDirectoryName, &fileData );
        currentDirectoryName[wcslen(currentDirectoryName) - 2] = 0;

        if ( findHandle != INVALID_HANDLE_VALUE ) {

            do {

                if ( FlagOff(fileData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) &&
                     (!params->SkipRoot || (currentDirectory != rootDirectory)) ) {

                    dprintf(( "  found file %ws\\%ws\n", currentDirectoryName, fileData.cFileName ));
                    newFile = (PFILE_ENTRY)GetFirstObject( currentDirectory );
                    while ( newFile != NULL ) {
                        if ( _wcsicmp( newFile->FindData.cFileName, fileData.cFileName ) == 0 ) {
                            break;
                        }
                        newFile = (PFILE_ENTRY)GetNextObject( currentDirectory, newFile );
                    }

                    userData = NULL;
                    if ( newFile != NULL ) {
                        userData = newFile->UserData;
                    }

                    if ( ARGUMENT_PRESENT(NewFileCallback) ) {
                        error = NewFileCallback(
                                    Context,
                                    currentDirectoryName,
                                    (newFile == NULL) ? NULL : &newFile->FindData,
                                    &fileData,
                                    &userData,
                                    &currentDirectory->UserData
                                    );
                        if ( error != NO_ERROR ) {
                            FindClose( findHandle );
                            return error;
                        }
                    }

                    if ( newFile != NULL ) {

                        if ( userData != NULL ) {
                            newFile->UserData = userData;
                        } else {
                            RemoveObject( newFile );
                            free( newFile );
                        }

                    } else if ( userData != NULL ) {

                        newFile = malloc( sizeof(FILE_ENTRY) - sizeof(WCHAR) +
                                            ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR)) );
                        if ( newFile == NULL ) {
                            if ( (userData != NULL) &&
                                 (params->FreeUserDataCallback != NULL) ) {
                                params->FreeUserDataCallback( userData );
                            }
                            FindClose( findHandle );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
    
                        InitializeObject( newFile );

                        newFile->FindData.dwFileAttributes = fileData.dwFileAttributes;
                        newFile->FindData.ftCreationTime = fileData.ftCreationTime;
                        newFile->FindData.ftLastAccessTime = fileData.ftLastAccessTime;
                        newFile->FindData.ftLastWriteTime = fileData.ftLastWriteTime;
                        newFile->FindData.nFileSizeHigh = fileData.nFileSizeHigh;
                        newFile->FindData.nFileSizeLow = fileData.nFileSizeLow;
                        wcscpy( newFile->FindData.cAlternateFileName, fileData.cAlternateFileName );
                        wcscpy( newFile->FindData.cFileName, fileData.cFileName );

                        newFile->UserData = userData;

                        InsertObject( currentDirectory, newFile );
                    }

                } else if ( params->Recurse &&
                            (wcscmp(fileData.cFileName,L".") != 0) &&
                            (wcscmp(fileData.cFileName,L"..") != 0) ) {

                    dprintf(( "  found directory %ws\\%ws\n", currentDirectoryName, fileData.cFileName ));
                    newDirectory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
                    while ( newDirectory != NULL ) {
                        if ( _wcsicmp( newDirectory->FindData.cFileName, fileData.cFileName ) == 0 ) {
                            ok = TRUE;
                            break;
                        }
                        newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( newDirectory );
                    }

                    userData = NULL;
                    if ( newDirectory != NULL ) {
                        userData = newDirectory->UserData;
                    }

                    if ( ARGUMENT_PRESENT(NewDirectoryCallback) ) {
                        error = NewDirectoryCallback(
                                    Context,
                                    currentDirectoryName,
                                    (newDirectory == NULL) ? NULL : &newDirectory->FindData,
                                    &fileData,
                                    &userData,
                                    &currentDirectory->UserData
                                    );
                        if ( error != NO_ERROR ) {
                            FindClose( findHandle );
                            return error;
                        }
                    }

                    if ( newDirectory != NULL ) {

                        newDirectory->UserData = userData;

                    } else if ( userData != NULL ) {

                        newDirectory = malloc( sizeof(DIRECTORY_ENTRY) - sizeof(WCHAR) +
                                                 ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR)) );
                        if ( newDirectory == NULL ) {
                            if ( (userData != NULL) &&
                                 (params->FreeUserDataCallback != NULL) ) {
                                params->FreeUserDataCallback( userData );
                            }
                            FindClose( findHandle );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
    
                        InitializeContainer( newDirectory, currentDirectory );

                        newDirectory->FindData.dwFileAttributes = fileData.dwFileAttributes;
                        newDirectory->FindData.ftCreationTime = fileData.ftCreationTime;
                        newDirectory->FindData.ftLastAccessTime = fileData.ftLastAccessTime;
                        newDirectory->FindData.ftLastWriteTime = fileData.ftLastWriteTime;
                        newDirectory->FindData.nFileSizeHigh = fileData.nFileSizeHigh;
                        newDirectory->FindData.nFileSizeLow = fileData.nFileSizeLow;
                        wcscpy( newDirectory->FindData.cAlternateFileName, fileData.cAlternateFileName );
                        wcscpy( newDirectory->FindData.cFileName, fileData.cFileName );

                        newDirectory->UserData = userData;

                        InsertContainer( currentDirectory, newDirectory );
                    }
                }

                ok = FindNextFile( findHandle, &fileData );

            } while ( ok );

            FindClose( findHandle );

        } // findHandle != INVALID_HANDLE_VALUE

        if ( ARGUMENT_PRESENT(CheckFileCallback) ) {
            newFile = (PFILE_ENTRY)GetFirstObject( currentDirectory );
            while ( newFile != NULL ) {
                error = CheckFileCallback(
                            Context,
                            currentDirectoryName,
                            &newFile->FindData,
                            &newFile->UserData,
                            &currentDirectory->UserData
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
                newFile = (PFILE_ENTRY)GetNextObject( currentDirectory, newFile );
            }
        }

        newDirectory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
        while ( newDirectory != NULL ) {
            if ( !ARGUMENT_PRESENT(RecurseDirectoryCallback) ||
                 RecurseDirectoryCallback(
                    Context,
                    currentDirectoryName,
                    &newDirectory->FindData,
                    &newDirectory->UserData,
                    &currentDirectory->UserData
                    ) ) {
                break;
            }
            newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( newDirectory );
        }

        if ( newDirectory != NULL ) {

            currentDirectory = newDirectory;
            wcscat( currentDirectoryName, L"\\" );
            wcscat( currentDirectoryName, currentDirectory->FindData.cFileName );

        } else {

            while ( TRUE ) {

                if ( currentDirectory == rootDirectory ) {
                    currentDirectory = NULL;
                    break;
                }

                if ( ARGUMENT_PRESENT(CheckDirectoryCallback) ) {
                    error = CheckDirectoryCallback(
                                Context,
                                currentDirectoryName,
                                &currentDirectory->FindData,
                                &currentDirectory->UserData,
                                GetParentUserData(currentDirectory)
                                );
                    if ( error != NO_ERROR ) {
                        return error;
                    }
                }
                                
                *wcsrchr(currentDirectoryName, L'\\') = 0;

                newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( currentDirectory );

                while ( newDirectory != NULL ) {
                    if ( !ARGUMENT_PRESENT(RecurseDirectoryCallback) ||
                         RecurseDirectoryCallback(
                            Context,
                            currentDirectoryName,
                            &newDirectory->FindData,
                            &newDirectory->UserData,
                            &currentDirectory->UserData
                            ) ) {
                        break;
                    }
                    newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( newDirectory );
                }

                if ( newDirectory != NULL ) {
                    currentDirectory = newDirectory;
                    wcscat( currentDirectoryName, L"\\" );
                    wcscat( currentDirectoryName, currentDirectory->FindData.cFileName );
                    break;
                } else {
                    currentDirectory = (PDIRECTORY_ENTRY)GetParent( currentDirectory );
                }
            }
        }

    } while ( currentDirectory != NULL );

    return ERROR_SUCCESS;
}

DWORD
ScanEnumTree (
    IN PVOID ScanHandle,
    IN PVOID Context,
    IN PSCAN_ENUM_DIRECTORY_CALLBACK EnumDirectoryCallback OPTIONAL,
    IN PSCAN_ENUM_FILE_CALLBACK EnumFileCallback OPTIONAL
    )
{
    DWORD error;
    PSCAN_PARAMETERS params;
    PDIRECTORY_ENTRY rootDirectory;
    PDIRECTORY_ENTRY currentDirectory;
    PDIRECTORY_ENTRY directory;
    PFILE_ENTRY file;
    WCHAR relativePath[MAX_PATH + 1];

    params = ScanHandle;
    rootDirectory = (PDIRECTORY_ENTRY)&params->RootDirectoryEntry;
    currentDirectory = rootDirectory;
    relativePath[0] = 0;

    do {

        if ( ARGUMENT_PRESENT(EnumFileCallback) ) {
            file = (PFILE_ENTRY)GetFirstObject( currentDirectory );
            while ( file != NULL ) {
                error = EnumFileCallback(
                            Context,
                            relativePath,
                            &file->FindData,
                            &file->UserData,
                            &currentDirectory->UserData
                            );
                if ( error != ERROR_SUCCESS ) {
                    dprintf(( "EnumFileCallback returned %d\n", error ));
                    return error;
                }
                file = (PFILE_ENTRY)GetNextObject( currentDirectory, file );
            }
        }

        directory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );

        if ( directory != NULL ) {

            currentDirectory = directory;
            wcscat( relativePath, L"\\" );
            wcscat( relativePath, currentDirectory->FindData.cFileName );

        } else {

            while ( TRUE ) {

                if ( currentDirectory == rootDirectory ) {
                    currentDirectory = NULL;
                    break;
                }

                *wcsrchr(relativePath, L'\\') = 0;

                if ( ARGUMENT_PRESENT(EnumDirectoryCallback) ) {
                    error = EnumDirectoryCallback(
                                Context,
                                relativePath,
                                &currentDirectory->FindData,
                                &currentDirectory->UserData,
                                GetParentUserData(currentDirectory)
                                );
                    if ( error != ERROR_SUCCESS ) {
                        dprintf(( "EnumDirectoryCallback returned %d\n", error ));
                        return error;
                    }
                }

                directory = (PDIRECTORY_ENTRY)GetNextContainer( currentDirectory );

                if ( directory != NULL ) {

                    currentDirectory = directory;
                    wcscat( relativePath, L"\\" );
                    wcscat( relativePath, currentDirectory->FindData.cFileName );
                    break;

                } else {

                    currentDirectory = (PDIRECTORY_ENTRY)GetParent( currentDirectory );
                }
            }
        }

    } while ( currentDirectory != NULL );

    return ERROR_SUCCESS;
}

VOID
ScanTerminate (
    IN PVOID ScanHandle
    )
{
    PSCAN_PARAMETERS params;

    params = ScanHandle;

    ScanFreeChildren( params, (PCONTAINER_ENTRY)&params->RootDirectoryEntry );
    if ( (params->RootDirectoryEntry.UserData != NULL) &&
         (params->FreeUserDataCallback != NULL) ) {
        params->FreeUserDataCallback( params->RootDirectoryEntry.UserData );
    }
    free( params );

    return;
}

VOID
ScanFreeChildren (
    IN PSCAN_PARAMETERS Parameters,
    IN PCONTAINER_ENTRY RootContainer
    )
{
    PCONTAINER_ENTRY currentContainer;
    PCONTAINER_ENTRY container;
    PCONTAINER_ENTRY parent;
    POBJECT_ENTRY object;
#if SCAN_DEBUG
    WCHAR currentPath[MAX_PATH + 1];
#endif

#if SCAN_DEBUG
#define CONTAINER_NAME(_container) ((PDIRECTORY_ENTRY)(_container))->FindData.cFileName
#define OBJECT_NAME(_object) ((PFILE_ENTRY)(_object))->FindData.cFileName

    currentPath[0] = 0;
#endif

    currentContainer = RootContainer;

    do {

        object = GetFirstObject( currentContainer );
        while ( object != NULL ) {
#if SCAN_DEBUG
            dprintf(( "Deleting entry for object %ws\\%ws\n", currentPath, OBJECT_NAME(object) ));
#endif
            RemoveObject( object );
            if ( (object->UserData != NULL) &&
                 (Parameters->FreeUserDataCallback != NULL) ) {
                Parameters->FreeUserDataCallback( object->UserData );
            }
            free( object );
            object = GetFirstObject( currentContainer );
        }

        container = GetFirstContainer( currentContainer );
        if ( container != NULL ) {
            currentContainer = container;
#if SCAN_DEBUG
            wcscat( currentPath, L"\\" );
            wcscat( currentPath, CONTAINER_NAME(currentContainer) );
#endif
        } else {
            while ( TRUE ) {
                if ( currentContainer == RootContainer ) {
                    currentContainer = NULL;
                    break;
                }
#if SCAN_DEBUG
                dprintf(( "Deleting entry for container %ws\n", currentPath ));
                *wcsrchr(currentPath, L'\\') = 0;
#endif

                parent = GetParent( currentContainer );
                RemoveContainer( currentContainer );
                if ( (currentContainer->UserData != NULL) &&
                     (Parameters->FreeUserDataCallback != NULL) ) {
                    Parameters->FreeUserDataCallback( currentContainer->UserData );
                }
                free( currentContainer );

                currentContainer = GetFirstContainer( parent );
                if ( currentContainer != NULL ) {
#if SCAN_DEBUG
                    wcscat( currentPath, L"\\" );
                    wcscat( currentPath, CONTAINER_NAME(currentContainer) );
#endif
                    break;
                } else {
                    currentContainer = parent;
                }
            }
        }

    } while ( currentContainer != NULL );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\emptydirs\scanlib\scan.h ===
#ifndef _SCAN_H_

#define _SCAN_H_

#if SCAN_DEBUG
extern BOOL scan_dprinton;
#endif

typedef struct _SMALL_WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    WCHAR  cAlternateFileName[ 14 ];
    WCHAR  cFileName[ 1 ];
} SMALL_WIN32_FIND_DATAW, *PSMALL_WIN32_FIND_DATAW, *LPSMALL_WIN32_FIND_DATAW;

typedef
VOID
(* PSCAN_FREE_USER_DATA_CALLBACK) (
    IN PVOID UserData
    );

typedef
DWORD
(* PSCAN_NEW_FILE_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW ExistingFileData OPTIONAL,
    IN PWIN32_FIND_DATAW NewFileData,
    IN PVOID *FileUserData,
    IN PVOID *ParentDirectoryUserData
    );

typedef
DWORD
(* PSCAN_NEW_DIRECTORY_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW ExistingDirectoryData OPTIONAL,
    IN PWIN32_FIND_DATAW NewDirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData
    );

typedef
DWORD
(* PSCAN_CHECK_FILE_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW FileData,
    IN PVOID *FileUserData,
    IN PVOID *ParentDirectoryUserData
    );

typedef
DWORD
(* PSCAN_CHECK_DIRECTORY_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW DirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData OPTIONAL
    );

typedef
DWORD
(* PSCAN_ENUM_FILE_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW FileData,
    IN PVOID *FileUserData,
    IN PVOID *ParentDirectoryUserData
    );

typedef
DWORD
(* PSCAN_ENUM_DIRECTORY_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW DirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData OPTIONAL
    );

typedef
BOOL
(* PSCAN_RECURSE_DIRECTORY_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW DirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData OPTIONAL
    );

DWORD
ScanInitialize (
    OUT PVOID *ScanHandle,
    IN BOOL Recurse,
    IN BOOL SkipRoot,
    IN PSCAN_FREE_USER_DATA_CALLBACK FreeUserDataCallback OPTIONAL
    );

DWORD
ScanDirectory (
    IN PVOID ScanHandle,
    IN PWCH ScanPath,
    IN PVOID Context OPTIONAL,
    IN PSCAN_NEW_DIRECTORY_CALLBACK NewDirectoryCallback OPTIONAL,
    IN PSCAN_CHECK_DIRECTORY_CALLBACK CheckDirectoryCallback OPTIONAL,
    IN PSCAN_RECURSE_DIRECTORY_CALLBACK RecurseDirectoryCallback OPTIONAL,
    IN PSCAN_NEW_FILE_CALLBACK NewFileCallback OPTIONAL,
    IN PSCAN_CHECK_FILE_CALLBACK CheckFileCallback OPTIONAL
    );

DWORD
ScanEnumTree (
    IN PVOID ScanHandle,
    IN PVOID Context,
    IN PSCAN_ENUM_DIRECTORY_CALLBACK EnumDirectoryCallback OPTIONAL,
    IN PSCAN_ENUM_FILE_CALLBACK EnumFileCallback OPTIONAL
    );

VOID
ScanTerminate (
    IN PVOID ScanHandle
    );

DWORD
OpenAndMapFile (
    IN PWCH FileName,
    IN DWORD DesiredAccess,
    OUT PHANDLE FileHandle,
    OUT PLARGE_INTEGER Size,
    OUT PHANDLE MappingHandle,
    OUT PVOID *MappedBase
    );

DWORD
OpenAndMapFileA (
    IN PSZ FileName,
    IN DWORD DesiredAccess,
    OUT PHANDLE FileHandle,
    OUT PLARGE_INTEGER Size,
    OUT PHANDLE MappingHandle,
    OUT PVOID *MappedBase
    );

VOID
CloseMappedFile (
    IN HANDLE FileHandle,
    IN HANDLE MappingHandle,
    IN PVOID MappedBase
    );

#define SCAN_FILETYPE_TEXT          0
#define SCAN_FILETYPE_UNICODE_TEXT  1
#define SCAN_FILETYPE_BINARY        2
#define SCAN_FILETYPE_MAYBE_BINARY  3

DWORD
DataLooksBinary (
    IN PVOID MappedBase,
    IN DWORD FileSize,
    OUT PUCHAR BinaryData OPTIONAL,
    OUT PDWORD BinaryDataOffset OPTIONAL
    );

DWORD
FileLooksBinary (
    IN PWCH DirectoryName,
    IN PWCH FileName,
    OUT PUCHAR BinaryData OPTIONAL,
    OUT PDWORD BinaryDataOffset OPTIONAL
    );

#endif // _SCAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ethstat\ethstat.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ethstat.h

Abstract:


Author: Rod Gamache (rodga)


Revision History:

--*/

#ifndef _ETHSTAT_
#define _ETHSTAT_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <memory.h>
#include <string.h>
#include <ctype.h>
#include <ntddndis.h>



#define MAX_NIC 8


typedef struct {
    char DeviceName[64];
    HANDLE Handle;
} DEVICE, *PDEVICE;


typedef struct _NET_SAMPLE_STATISTICS {
    ULONGLONG OidGenMediaInUse;
    ULONGLONG OidGenLinkSpeed;
    ULONGLONG OidGenXmitError;
    ULONGLONG OidGenRcvError;
    ULONGLONG OidGenRcvNoBuffer;
    ULONGLONG OidGenDirectedBytesXmit;
    ULONGLONG OidGenDirectedFramesXmit;
    ULONGLONG OidGenDirectedBytesRcv;
    ULONGLONG OidGenDirectedFramesRcv;
    ULONGLONG OidGenMulticastBytesXmit;
    ULONGLONG OidGenMulticastFramesXmit;
    ULONGLONG OidGenBroadcastBytesXmit;
    ULONGLONG OidGenBroadcastFramesXmit;
    ULONGLONG OidGenMulticastBytesRcv;
    ULONGLONG OidGenMulticastFramesRcv;
    ULONGLONG OidGenBroadcastBytesRcv;
    ULONGLONG OidGenBroadcastFramesRcv;
    ULONGLONG OidGenRcvCrcError;
    ULONGLONG OidGenTransmitQueueLength;
    ULONGLONG Oid802_3RcvErrorAlignment;
    ULONGLONG Oid802_3XmitOneCollision;
    ULONGLONG Oid802_3XmitMoreCollisions;
    ULONGLONG Oid802_3XmitDeferred;
    ULONGLONG Oid802_3XmitMaxCollisions;
    ULONGLONG Oid802_3RcvOverRun;
    ULONGLONG Oid802_3XmitUnderRun;
    ULONGLONG Oid802_3XmitTimesCrsLost;
    ULONGLONG Oid802_3XmitLateCollisions;
} NET_SAMPLE_STATISTICS, *PNET_SAMPLE_STATISTICS;



extern char *NetworkMedium[];


#endif // _ETHSTAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ethstat\ethstat.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ethstat.c

Abstract:

    This module displays counters for ethernet devices.

Author:

    Rod Gamache (rodga) 26-Apr-1995

Revision History:

--*/




#include "ethstat.h"


DEVICE DeviceList[MAX_NIC] = {0};

NTSTATUS
NetStatsClose(
    VOID
    );

NTSTATUS
NetStatsInit(
    OUT LONG *NumberNetCards
    );

NTSTATUS
NetStatsReadSample(
    PNET_SAMPLE_STATISTICS PNetSampleStatistics
    );

//
// The following warning being disabled and the conversions into High and Low
// below are all hacks to get around the fact that we cannot easily print out
// LONGLONGs in the present versions of Windows NT - except for Alpha. This
// should be fixed later, but the code should probably not change for a long
// time, so that we can continue to build and use it on older versions of
// Windows NT.
//

#pragma warning(disable:4244)               // skip warnings about loss of data


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    NET_SAMPLE_STATISTICS NetSampleStatistics[MAX_NIC];
    PDEVICE device;
    ULONG NumberNetCards;
    ULONG i;
    ULONG High;
    ULONG Low;
    ULONG Div = 1000000000;
    ULONGLONG Number;
    ULONGLONG Number2;
    ULONGLONG Number3;


    //
    // Determine the number of net cards in the system and do an open
    // on the driver.
    //
    NumberNetCards = 0;
    NetStatsInit(&NumberNetCards);

    NetStatsReadSample( NetSampleStatistics );

    device = &DeviceList[0];

    for (i = 0; i < NumberNetCards; i++) {
        printf("\n\nCounters for Network Card: %s\n\n", device->DeviceName);
        Number = NetSampleStatistics[i].OidGenDirectedFramesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Frames Received:              %0.0u%u\n", High, Low);
        Number = NetSampleStatistics[i].OidGenMulticastFramesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Multicast Frames Received:    %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenBroadcastFramesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Broadcast Frames Received:    %0.0u%u\n\n", High, Low);

        Number = NetSampleStatistics[i].OidGenDirectedFramesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Frames Transmitted:           %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenMulticastFramesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Multicast Frames Transmitted: %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenBroadcastFramesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Broadcast Frames Transmitted: %0.0u%u\n\n", High, Low);

        Number = NetSampleStatistics[i].OidGenDirectedBytesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Bytes Received:               %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenMulticastBytesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Multicast Bytes Received:     %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenBroadcastBytesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Broadcast Bytes Received:     %0.0u%u\n", High, Low);

        Number2 = NetSampleStatistics[i].OidGenDirectedBytesRcv;
        Number3 = NetSampleStatistics[i].OidGenDirectedFramesRcv;
        Number = Number2 / Number3;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number2 != -1 && Number3 != -1 ) printf("Bytes Per Receive Frame:      %0.0u%u\n\n", High, Low);

        Number = NetSampleStatistics[i].OidGenDirectedBytesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Bytes Transmitted:            %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenMulticastBytesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Multicast Bytes Transmitted:  %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenBroadcastBytesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Broadcast Bytes Transmitted:  %0.0u%u\n", High, Low);

        Number2 = NetSampleStatistics[i].OidGenDirectedBytesXmit;
        Number3 = NetSampleStatistics[i].OidGenDirectedFramesXmit;
        Number = Number2 / Number3;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number2 != -1 && Number3 != -1 ) printf("Bytes Per Transmit Frame:     %0.0u%u\n", High, Low);

        Number2 = NetSampleStatistics[i].OidGenDirectedBytesRcv;
        Number3 = NetSampleStatistics[i].OidGenDirectedBytesXmit;
        Number = Number2 + Number3;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number2 != -1 && Number3 != -1 ) printf("Bytes Total (xmt + rcv):      %0.0u%u\n\n", High, Low);

        Number = NetSampleStatistics[i].OidGenMediaInUse;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Media In Use:                 %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenLinkSpeed;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Link Speed:                   %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenXmitError;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Errors:              %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenRcvError;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Receive Errors:               %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenRcvNoBuffer;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Receive No Buffer Avail:      %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenRcvCrcError;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Receive CRC Errors:           %0.0u%u\n\n", High, Low);

        Number = NetSampleStatistics[i].OidGenTransmitQueueLength;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Queue Length:        %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3RcvErrorAlignment;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Receive Error Alignment:      %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitOneCollision;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit One Collision:       %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitMoreCollisions;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Multiple Collisions: %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitDeferred;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmits Deferred:           %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitMaxCollisions;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmits Max Collisions:     %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3RcvOverRun;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Receive Over Runs:            %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitUnderRun;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Under Runs:          %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitTimesCrsLost;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Carrier Lost:        %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitLateCollisions;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Late Collisions:     %0.0u%u\n\n\n", High, Low);

        device += 1;
    }

    NetStatsClose();

    return 0;

}   // end of main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\emptydirs\scanlib\utils.c ===
#include "precomp.h"
#pragma hdrstop

DWORD
pOpenAndMapFile (
    IN PVOID FileName,
    IN BOOL NameIsUnicode,
    IN DWORD DesiredAccess,
    OUT PHANDLE FileHandle,
    OUT PLARGE_INTEGER Size,
    OUT PHANDLE MappingHandle,
    OUT PVOID *MappedBase
    )
{
    BOOL ok;
    DWORD error;
    LARGE_INTEGER Zero;

    *MappingHandle = NULL;
    *MappedBase = NULL;

    if ( NameIsUnicode ) {
        *FileHandle = CreateFile(
                        FileName,
                        DesiredAccess,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );
    } else {
        *FileHandle = CreateFileA(
                        FileName,
                        DesiredAccess,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );
    }
    if ( *FileHandle == INVALID_HANDLE_VALUE ) {
        error = GetLastError( );
        goto cleanup;
    }

    Zero.QuadPart = 0;
    ok = SetFilePointerEx( *FileHandle, Zero, Size, FILE_END );
    if ( !ok ) {
        error = GetLastError( );
        goto cleanup;
    }
    if ( Size->QuadPart == 0 ) {
        error = NO_ERROR;
        goto cleanup;
    }

    *MappingHandle = CreateFileMapping(
                        *FileHandle,
                        NULL,
                        (DesiredAccess == GENERIC_READ) ? PAGE_READONLY : PAGE_READWRITE,
                        Size->HighPart,
                        Size->LowPart,
                        NULL
                        );
    if ( *MappingHandle == NULL ) {
        error = GetLastError( );
        goto cleanup;
    }

    *MappedBase = MapViewOfFile(
                    *MappingHandle,
                    (DesiredAccess == GENERIC_READ) ? FILE_MAP_READ : (FILE_MAP_READ | FILE_MAP_WRITE),
                    0,
                    0,
                    Size->LowPart
                    );
    if ( *MappedBase == NULL ) {
        error = GetLastError( );
        goto cleanup;
    }

    return NO_ERROR;

cleanup:

    if ( *MappedBase != NULL ) {
        UnmapViewOfFile( *MappedBase );
        *MappedBase = NULL;
    }
    if ( *MappingHandle != NULL ) {
        CloseHandle( *MappingHandle );
        *MappingHandle = NULL;
    }
    if ( *FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( *FileHandle );
        *FileHandle = INVALID_HANDLE_VALUE;
    }

    return error;
}

DWORD
OpenAndMapFile (
    IN PWCH FileName,
    IN DWORD DesiredAccess,
    OUT PHANDLE FileHandle,
    OUT PLARGE_INTEGER Size,
    OUT PHANDLE MappingHandle,
    OUT PVOID *MappedBase
    )
{
    return pOpenAndMapFile(
                FileName,
                TRUE,
                DesiredAccess,
                FileHandle,
                Size,
                MappingHandle,
                MappedBase
                );
}

DWORD
OpenAndMapFileA (
    IN PSZ FileName,
    IN DWORD DesiredAccess,
    OUT PHANDLE FileHandle,
    OUT PLARGE_INTEGER Size,
    OUT PHANDLE MappingHandle,
    OUT PVOID *MappedBase
    )
{
    return pOpenAndMapFile(
                FileName,
                FALSE,
                DesiredAccess,
                FileHandle,
                Size,
                MappingHandle,
                MappedBase
                );
}

VOID
CloseMappedFile (
    IN HANDLE FileHandle,
    IN HANDLE MappingHandle,
    IN PVOID MappedBase
    )
{
    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        if ( MappedBase != NULL ) {
            UnmapViewOfFile( MappedBase );
        }
        if ( MappingHandle != NULL ) {
            CloseHandle( MappingHandle );
        }
        CloseHandle( FileHandle );
    }

    return;
}

DWORD
DataLooksBinary (
    IN PVOID MappedBase,
    IN DWORD FileSize,
    OUT PUCHAR BinaryData OPTIONAL,
    OUT PDWORD BinaryDataOffset OPTIONAL
    )
{
    DWORD nBytes;
    DWORD nBinary;
    DWORD offset;
    DWORD i;
    PUCHAR p;
    UCHAR c;
    DWORD previousBinary;
    BOOL anyBinaryFound;

    if ( IsTextUnicode( MappedBase, FileSize < 512 ? FileSize : 512, NULL ) ) {
        return SCAN_FILETYPE_UNICODE_TEXT;
    }

    anyBinaryFound = FALSE;

    for ( offset = 0;
          offset < FileSize;
          offset += nBytes ) {
    
        previousBinary = MAXULONG;
        nBinary = 0;

        nBytes = 512;
        if ( offset + nBytes > FileSize ) {
            nBytes = FileSize - offset;
        }

        for ( i = 0, p = (PUCHAR)MappedBase + offset;
              i < nBytes;
              i++, p++ ) {
    
            c = *p;
            switch ( c ) {
            
            case '\a':  // ignore all BELL for this test
            case '\b':  //            BS
            case '\f':  //            FF
            case '\n':  //            LF
            case '\r':  //            CR
            case '\t':  //            tab
            case '\v':  //            VT
            case 0x1A:  //            ^Z
                break;
    
            default:
                if ( (c < ' ') || (c > '~') ) {   // worry about DBCS?
                    nBinary++;
                    if ( previousBinary == MAXULONG ) {
                        if ( ARGUMENT_PRESENT(BinaryData) ) {
                            *BinaryData = c;
                        }
                        if ( ARGUMENT_PRESENT(BinaryDataOffset) ) {
                            *BinaryDataOffset = offset + i;
                        }
                        previousBinary = c;
                    }
                }
                break;
            }
        }

        if ( nBinary != 0 ) {
            anyBinaryFound = TRUE;
            if ( nBinary > (nBytes / 5) ) {
                return SCAN_FILETYPE_BINARY;
            }
        }
    }

    if ( anyBinaryFound ) {
        return SCAN_FILETYPE_MAYBE_BINARY;
    }
    return SCAN_FILETYPE_TEXT;

} // DataLooksBinary

DWORD
FileLooksBinary (
    PWCH DirectoryName,
    PWCH FileName,
    OUT PUCHAR BinaryData OPTIONAL,
    OUT PDWORD BinaryDataOffset OPTIONAL
    )
{
    DWORD error;
    LARGE_INTEGER size;
    HANDLE fileHandle;
    HANDLE mappingHandle;
    PVOID mappedBase;
    WCHAR fullName[MAX_PATH+1];
    DWORD i;

    wcscpy( fullName, DirectoryName );
    wcscat( fullName, L"\\" );
    wcscat( fullName, FileName );

    error = OpenAndMapFile (
                fullName,
                GENERIC_READ,
                &fileHandle,
                &size,
                &mappingHandle,
                &mappedBase
                );
    if ( error != NO_ERROR ) {
        return SCAN_FILETYPE_TEXT;
    }

    if ( size.QuadPart == 0 ) {
        return SCAN_FILETYPE_TEXT;
    }

    i = DataLooksBinary(
            mappedBase,
            size.HighPart == 0 ? size.LowPart : MAXULONG,
            BinaryData,
            BinaryDataOffset
            );

    CloseMappedFile( fileHandle, mappingHandle, mappedBase );

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ethstat\netstats.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    netstats.c

Abstract:

    This module reads the netcard statistics.

Author:

    David Orbits (davidor) 22-March-1995

Revision History:

    Rod Gamache (rodga) 10-May-1995
    Slight mods for using with Ethstat main program.

--*/



#include "ethstat.h"


NTSTATUS
ReadNetCardNames(
    IN OUT char DeviceNameString[],
    IN LONG DeviceNameLength
    );


char *OidListName[] = {
    "OID_GEN_MEDIA_IN_USE",
    "OID_GEN_LINK_SPEED",
    "OID_GEN_XMIT_ERROR",
    "OID_GEN_RCV_ERROR",
    "OID_GEN_RCV_NO_BUFFER",
    "OID_GEN_DIRECTED_BYTES_XMIT",
    "OID_GEN_DIRECTED_FRAMES_XMIT",
    "OID_GEN_DIRECTED_BYTES_RCV",
    "OID_GEN_DIRECTED_FRAMES_RCV",
    "OID_GEN_MULTICAST_BYTES_XMIT",
    "OID_GEN_MULTICAST_FRAMES_XMIT",
    "OID_GEN_BROADCAST_BYTES_XMIT",
    "OID_GEN_BROADCAST_FRAMES_XMIT",
    "OID_GEN_MULTICAST_BYTES_RCV",
    "OID_GEN_MULTICAST_FRAMES_RCV",
    "OID_GEN_BROADCAST_BYTES_RCV",
    "OID_GEN_BROADCAST_FRAMES_RCV",
    "OID_GEN_RCV_CRC_ERROR",
    "OID_GEN_TRANSMIT_QUEUE_LENGTH",
    "OID_802_3_RCV_ERROR_ALIGNMENT",
    "OID_802_3_XMIT_ONE_COLLISION",
    "OID_802_3_XMIT_MORE_COLLISIONS",
    "OID_802_3_XMIT_DEFERRED",
    "OID_802_3_XMIT_MAX_COLLISIONS",
    "OID_802_3_RCV_OVERRUN",
    "OID_802_3_XMIT_UNDERRUN",
    "OID_802_3_XMIT_TIMES_CRS_LOST",
    "OID_802_3_XMIT_LATE_COLLISIONS"
    };

NDIS_OID OidList[] = {
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_LINK_SPEED,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_DIRECTED_BYTES_XMIT,
    OID_GEN_DIRECTED_FRAMES_XMIT,
    OID_GEN_DIRECTED_BYTES_RCV,
    OID_GEN_DIRECTED_FRAMES_RCV,
    OID_GEN_MULTICAST_BYTES_XMIT,
    OID_GEN_MULTICAST_FRAMES_XMIT,
    OID_GEN_BROADCAST_BYTES_XMIT,
    OID_GEN_BROADCAST_FRAMES_XMIT,
    OID_GEN_MULTICAST_BYTES_RCV,
    OID_GEN_MULTICAST_FRAMES_RCV,
    OID_GEN_BROADCAST_BYTES_RCV,
    OID_GEN_BROADCAST_FRAMES_RCV,
    OID_GEN_RCV_CRC_ERROR,
    OID_GEN_TRANSMIT_QUEUE_LENGTH,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_802_3_XMIT_DEFERRED,
    OID_802_3_XMIT_MAX_COLLISIONS,
    OID_802_3_RCV_OVERRUN,
    OID_802_3_XMIT_UNDERRUN,
    OID_802_3_XMIT_TIMES_CRS_LOST,
    OID_802_3_XMIT_LATE_COLLISIONS
};



LONG OpenNetDevices = 0;
extern DEVICE DeviceList[MAX_NIC];





NTSTATUS
NetStatsInit(
    OUT LONG *NumberNetCards
    )
{

    PDEVICE device;
    NTSTATUS Status;
    char DeviceNameString[64];
    char FullDeviceName[256];
    LONG i;

    *NumberNetCards = 0;
    i = 0;

    Status = ReadNetCardNames(DeviceNameString, sizeof(DeviceNameString));


    if (!NT_SUCCESS(Status)) {
        printf( "NetStatsInit: No netcard devices found.\n" );
        return STATUS_UNSUCCESSFUL;
    }

    device = &DeviceList[0];

    while ( NT_SUCCESS(Status) ) {

        strcpy(device->DeviceName, DeviceNameString);

        //
        // First create a symbolic link to the driver.
        //

        strcpy( FullDeviceName, "\\Device\\" );
        strcat( FullDeviceName, DeviceNameString );

        if (!DefineDosDevice(DDD_RAW_TARGET_PATH, DeviceNameString, FullDeviceName)) {
            printf("\nNetStatsInit: DefineDosDevice (%s, %s) failed\n",
                   DeviceNameString,
                   FullDeviceName );
            return STATUS_UNSUCCESSFUL;
        }


        //
        // Next, try to open the device.
        //

        strcpy( FullDeviceName, "\\\\.\\" );
        strcat( FullDeviceName, DeviceNameString );

        device->Handle = CreateFile(FullDeviceName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

        if ( device->Handle == (HANDLE)-1 ) {
            printf("NetStatsInit: Can't get a handle to %s (%s)\n",
                    DeviceNameString,
                    FullDeviceName );
            DefineDosDevice( DDD_REMOVE_DEFINITION, DeviceNameString, NULL );
        } else {

            if (OpenNetDevices == MAX_NIC) {
                printf( "NetStatsInit: Too many netcard devices.\n" );
                printf( "NetStatsInit: Only first %d will be monitored.\n", OpenNetDevices);
                CloseHandle( device->Handle );
                DefineDosDevice( DDD_REMOVE_DEFINITION, DeviceNameString, NULL );
                break;
            }

            OpenNetDevices += 1;
            device += 1;
        }

        //
        // Get next netcard device name.
        //
        Status = ReadNetCardNames(DeviceNameString, sizeof(DeviceNameString));

    }

    *NumberNetCards = OpenNetDevices;

#ifdef debug
    printf("\nNetcard devices found -- %d\n", OpenNetDevices);
    for ( i = 0; i < OpenNetDevices; i++ ) {
        device = &DeviceList[i];
        printf("%s  ", device->DeviceName);
    }
    printf("\n\n");
#endif

    return STATUS_SUCCESS;
}



NTSTATUS
NetStatsReadSample(
    PNET_SAMPLE_STATISTICS PNetSampleStatistics
    )
{

    ULONG Status;
    PDEVICE device;
    LONG i;
    ULONG j;
    DWORD cbReturned;
    PLONGLONG PCounter;
    PNET_SAMPLE_STATISTICS PDeviceSampleStatistics = PNetSampleStatistics;

	memset(PDeviceSampleStatistics, 0, sizeof(NET_SAMPLE_STATISTICS));

    for ( i = 0; i < OpenNetDevices; i++ ) {

        device = &DeviceList[i];
        PCounter = (PLONGLONG) PDeviceSampleStatistics;

        //
        // Now loop through each of our potential OIDs.
        //
        for ( j = 0; j < sizeof(OidList)/sizeof(NDIS_OID); j++ ) {

            *PCounter = 0;
            if ( !(Status = DeviceIoControl(
                    device->Handle,
                    (DWORD)IOCTL_NDIS_QUERY_GLOBAL_STATS,
                    (PVOID)&OidList[j],
                    sizeof(NDIS_OID),
                    (PVOID)PCounter,
                    sizeof(LONGLONG),
                    &cbReturned,
                    0
                    )) ) {
#ifdef debug
                printf("DeviceIoControl Failed!, Status = 0x%lx, OID: %s\n", Status, OidListName[j]);
#endif
                *PCounter = (LONGLONG)-1;
            }
            PCounter += 1;
        }

        PDeviceSampleStatistics += 1;
    }

#ifdef debug
    printf("\n                                 ");
    for ( i = 0; i < OpenNetDevices; i++ ) {
        device = &DeviceList[i];
        printf("  %12s", device->DeviceName);
    }
    printf("\n\n");

    for ( j = 0; j < sizeof(OidList)/sizeof(NDIS_OID); j++ ) {
        printf( "%-30s:  ", OidListName[j]);
        PCounter = (PLONGLONG) PNetSampleStatistics + j;

        for ( i = 0; i < OpenNetDevices; i++ ) {
            device = &DeviceList[i];
            if (OidList[j] != OID_GEN_MEDIA_IN_USE) {
                printf("  %d", *PCounter );
            } else {
                printf("  Media in use problem\n");
            }
            (PNET_SAMPLE_STATISTICS) PCounter += 1;
        }
        printf("\n");
    }
#endif

    return STATUS_SUCCESS;

}


NTSTATUS
NetStatsClose(
    VOID
    )
{

    PDEVICE device;
    LONG i;

    for ( i = 0; i < OpenNetDevices; i++ ) {

        device = &DeviceList[i];

        if ( device->Handle != (HANDLE)-1 ) {
            CloseHandle( device->Handle );
        }

        DefineDosDevice( DDD_REMOVE_DEFINITION, device->DeviceName, NULL );

    }

    return STATUS_SUCCESS;

}



NTSTATUS
ReadNetCardNames(
    IN OUT char DeviceNameString[],
    IN LONG DeviceNameLength
    )

{
    int i;
    LONG Result;
    HKEY Key;
    DWORD Size;
    char KeyString[128];
    static LONG RegNetCardNumber = 0;

    //
    // Scan registry for installed netcards.
    //
    RegNetCardNumber++;

    while (RegNetCardNumber < 32) {

        sprintf(KeyString,
                "software\\microsoft\\windows nt\\currentversion\\networkcards\\%d",
                RegNetCardNumber);

        Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              KeyString,
                              0,
                              KEY_QUERY_VALUE,
                              &Key);

        if (Result == ERROR_SUCCESS) {
            //
            // Query out the value we are interested in
            //
            Size = DeviceNameLength;
            Result = RegQueryValueEx(Key,
                                     "ServiceName",
                                     0,
                                     NULL,
                                     (LPBYTE)DeviceNameString,
                                     &Size);
            RegCloseKey(Key);

            if (Result == ERROR_SUCCESS) {
                //printf("%s    netcard = %s\n", KeyString, DeviceNameString);
                return STATUS_SUCCESS;

            } else {
                printf("%s\n", KeyString);
                printf("reg query failed, status = %08X\n", Result);
            }

        } else {
            //printf("%s\n", KeyString);
            //printf("reg open key failed, status = %08X\n", Result);
        }

        RegNetCardNumber++;
    }

    return STATUS_UNSUCCESSFUL;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\exctrlst\exctrdlg.h ===
// exctrdlg.h : header file
//

#define RESERVED    0L
#define  OLD_VERSION 0x010000

#define ENABLE_PERF_CTR_QUERY   0
#define ENABLE_PERF_CTR_ENABLE  1
#define ENABLE_PERF_CTR_DISABLE 2

#define SORT_ORDER_LIBRARY  1
#define SORT_ORDER_SERVICE  2
#define SORT_ORDER_ID       3

typedef struct _REG_NOTIFY_THREAD_INFO {
    HKEY    hKeyToMonitor;
    HWND    hWndToNotify;
} REG_NOTIFY_THREAD_INFO, *PREG_NOTIFY_THREAD_INFO;

/////////////////////////////////////////////////////////////////////////////
// CExctrlstDlg dialog

class CExctrlstDlg : public CDialog
{
// Construction
public:
    CExctrlstDlg(CWnd* pParent = NULL); // standard constructor
    ~CExctrlstDlg (void);               // destructor

// Dialog Data
    //{{AFX_DATA(CExctrlstDlg)
    enum { IDD = IDD_EXCTRLST_DIALOG };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CExctrlstDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CExctrlstDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnSelchangeExtList();
    afx_msg void OnDestroy();
    afx_msg void OnRefresh();
    afx_msg void OnAbout();
    afx_msg void OnKillfocusMachineName();
    afx_msg void OnSortButton();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnEnablePerf();

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL    IndexHasString (DWORD   dwIndex);
    void    ScanForExtensibleCounters();
    void    UpdateDllInfo();
    void    UpdateSystemInfo();
    void    ResetListBox();
    void    SetSortButtons();
    DWORD   EnablePerfCounters (HKEY hKeyItem, DWORD dwNewValue);
    HKEY    hKeyMachine;
    HKEY    hKeyServices;
    TCHAR   szThisComputerName[MAX_PATH];
    TCHAR   szComputerName[MAX_PATH];
    REG_NOTIFY_THREAD_INFO  rntInfo;
    DWORD   dwSortOrder;
    BOOL    bReadWriteAccess;
    DWORD   dwRegAccessMask;
    LPWSTR  *pNameTable;
    DWORD   dwLastElement;
    DWORD   dwListBoxHorizExtent;
    DWORD   dwTabStopCount;
    DWORD   dwTabStopArray[1];
    // 0 = Last Counter ID from Reg
    // 1 = Last Counter ID from text
    // 2 = Last Help ID from reg
    // 3 = Last Help ID from text
    DWORD   dwIdArray[4];   
};
/////////////////////////////////////////////////////////////////////////////
// CAbout dialog

class CAbout : public CDialog
{
// Construction
public:
	CAbout(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAbout)
	enum { IDD = IDD_ABOUT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAbout)
        virtual BOOL OnInitDialog();
        // NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\exctrlst\exctrdlg.cpp ===
// exctrdlg.cpp : implementation file
//

#ifndef UNICODE
#define UNICODE     1
#endif
#ifndef _UNICODE
#define _UNICODE    1
#endif

#include "stdafx.h"
#include "exctrlst.h"
#include "exctrdlg.h"
#include "tchar.h"

// string constants
// displayed strings
const TCHAR  cszNotFound[] = {TEXT("Not Found")};
const TCHAR  cszNA[] = {TEXT("N/A")};

// strings that are not displayed

const WCHAR  cszServiceKeyName[] = L"SYSTEM\\CurrentControlSet\\Services";
const WCHAR  cszNamesKey[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";

// Performance subkey registry value names
const WCHAR  cszDisablePerformanceCounters[] = {L"Disable Performance Counters"};
const TCHAR  cszDoubleBackslash[] = {TEXT("\\\\")};
const TCHAR  cszSpace[] = {TEXT(" ")};
const TCHAR  cszSplat[] = {TEXT("*")};
const TCHAR  cszServIdFmt[] = {TEXT("%d %s")};
const TCHAR  cszOpen[] = {TEXT("Open")};
const TCHAR  cszCollect[] = {TEXT("Collect")};
const TCHAR  cszClose[] = {TEXT("Close")};
const TCHAR  cszIdFmt[] = {TEXT("0x%8.8x  (%d) %s")};
const TCHAR  cszSortIdFmt[] = {TEXT("0x%8.8x\t%s")};
const TCHAR  cszTab[] = {TEXT("\t")};
const TCHAR  cszFirstCounter[] = {TEXT("First Counter")};
const TCHAR  cszLastCounter[] = {TEXT("Last Counter")};
const TCHAR  cszFirstHelp[] = {TEXT("First Help")};
const TCHAR  cszLastHelp[] = {TEXT("Last Help")};
const TCHAR  cszLibrary[] = {TEXT("Library")};
const TCHAR  cszPerformance[] = {TEXT("\\Performance")};
const TCHAR  cszSlash[] = {TEXT("\\")};
const WCHAR  cszVersionName[] = {L"Version"};
const WCHAR  cszCounterName[] = {L"Counter "};
const WCHAR  cszHelpName[] = {L"Explain "};
const WCHAR  cszCounters[] = {L"Counters"};
const TCHAR  cszHelp[] = {TEXT("Help")};

// Perflib registry values
const WCHAR  cszDefaultLangId[] = L"009";
const WCHAR  cszConfigurationFlags[] = L"Configuration Flags";
const WCHAR  cszEventLogLevel[] = L"EventLogLevel";
const WCHAR  cszExtCounterTestLevel[] = L"ExtCounterTestLevel";
const WCHAR  cszFailureLimit[] = L"Error Count Limit";

#ifdef _DEBUG
#undef THIS_FILE
char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL CExctrlstDlg::IndexHasString (
    DWORD   dwIndex
)
{
    if ((dwIndex <= dwLastElement) && (pNameTable != NULL)) {
        if (pNameTable[dwIndex] != NULL) {
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

LPWSTR
*BuildNameTable(
    LPCWSTR szMachineName,
    LPCWSTR lpszLangIdArg,     // unicode value of Language subkey
    PDWORD  pdwLastItem,     // size of array in elements
    PDWORD  pdwIdArray      // array for index ID's
)
/*++
   
BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:
     
    pointer to an allocated table. (the caller must MemoryFree it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{
    HKEY    hKeyRegistry;   // handle to registry db with counter names

    LPWSTR  *lpReturnValue;
    LPCWSTR lpszLangId;

    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    DWORD   dwThisCounter;
    
    DWORD   dwSystemVersion;
    DWORD   dwLastId;
    DWORD   dwLastHelpId;

    DWORD   dwLastCounterIdUsed;
    DWORD   dwLastHelpIdUsed;
    
    HKEY    hKeyValue;
    HKEY    hKeyNames;

    LPWSTR  lpValueNameString;
    WCHAR   CounterNameBuffer [50];
    WCHAR   HelpNameBuffer [50];


    hKeyRegistry = NULL;
    if (szMachineName != NULL) {
        lWin32Status = RegConnectRegistryW (szMachineName,
            HKEY_LOCAL_MACHINE,
            &hKeyRegistry);
    } else {
        lWin32Status = ERROR_SUCCESS;
        hKeyRegistry = HKEY_LOCAL_MACHINE;
    }

    lpValueNameString = NULL;   //initialize to NULL
    lpReturnValue = NULL;
    hKeyValue = NULL;
    hKeyNames = NULL;
   
    // check for null arguments and insert defaults if necessary

    if (!lpszLangIdArg) {
        lpszLangId = cszDefaultLangId;
    } else {
        lpszLangId = lpszLangIdArg;
    }

    // open registry to get number of items for computing array size

    if (lWin32Status == ERROR_SUCCESS) {
        lWin32Status = RegOpenKeyEx (
            hKeyRegistry,
            cszNamesKey,
            RESERVED,
            KEY_READ,
            &hKeyValue);
    }
    
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get number of items
    
    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        cszLastHelp,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastHelpId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    pdwIdArray[2] = dwLastHelpId;

    // get number of items
    
    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        cszLastCounter,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }
    
    pdwIdArray[0] = dwLastId;
    
    if (dwLastId < dwLastHelpId)
        dwLastId = dwLastHelpId;

    dwArraySize = dwLastId * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof (dwSystemVersion);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        cszVersionName,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
        // reset the error status
        lWin32Status = ERROR_SUCCESS;
    }

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        lpValueNameString = (LPWSTR)HeapAlloc (GetProcessHeap(), 0,
            lstrlen(cszNamesKey) * sizeof (WCHAR) +
            lstrlen(cszSlash) * sizeof (WCHAR) +
            lstrlen(lpszLangId) * sizeof (WCHAR) +
            sizeof (UNICODE_NULL));
        
        if (!lpValueNameString) goto BNT_BAILOUT;

        lstrcpy (lpValueNameString, cszNamesKey);
        lstrcat (lpValueNameString, cszSlash);
        lstrcat (lpValueNameString, lpszLangId);

        lWin32Status = RegOpenKeyEx (
            hKeyRegistry,
            lpValueNameString,
            RESERVED,
            KEY_READ,
            &hKeyNames);
    } else {
        if (szMachineName[0] == 0) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        } else {
            lWin32Status = RegConnectRegistry (szMachineName,
                HKEY_PERFORMANCE_DATA,
                &hKeyNames);
        }
        lstrcpy (CounterNameBuffer, cszCounterName);
        lstrcat (CounterNameBuffer, lpszLangId);

        lstrcpy (HelpNameBuffer, cszHelpName);
        lstrcat (HelpNameBuffer, lpszLangId);
    }

    // get size of counter names and add that to the arrays
    
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }
    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == (DWORD)OLD_VERSION ? cszCounters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays
    
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == (DWORD)OLD_VERSION ? cszHelp : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    dwHelpSize = dwBufferSize;

    lpReturnValue = (LPWSTR *)HeapAlloc (GetProcessHeap(), 0,dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) {
        goto BNT_BAILOUT;
    }
    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? cszCounters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        (LPBYTE)lpCounterNames,
        &dwBufferSize);

    if (!lpReturnValue) {
        goto BNT_BAILOUT;
    }
 
    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? cszHelp : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        (LPBYTE)lpHelpText,
        &dwBufferSize);
                            
    if (!lpReturnValue) {
        goto BNT_BAILOUT;
    }

    dwLastCounterIdUsed = 0;
    dwLastHelpIdUsed = 0;

    // load counter array items

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) {
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);  

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastCounterIdUsed) dwLastCounterIdUsed = dwThisCounter;

    }

    pdwIdArray[1] = dwLastCounterIdUsed;

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) {
            goto BNT_BAILOUT;  // bad entry
        }
        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastHelpIdUsed) dwLastHelpIdUsed= dwThisCounter;
    }

    pdwIdArray[3] = dwLastHelpIdUsed;

    dwLastId = dwLastHelpIdUsed;
    if (dwLastId < dwLastCounterIdUsed) dwLastId = dwLastCounterIdUsed;

    if (pdwLastItem) *pdwLastItem = dwLastId;

    HeapFree (GetProcessHeap(), 0, (LPVOID)lpValueNameString);
    RegCloseKey (hKeyValue);
//    if (dwSystemVersion == OLD_VERSION)
    RegCloseKey (hKeyNames);

    if ((hKeyRegistry != HKEY_LOCAL_MACHINE) &&
        (hKeyRegistry != NULL)) {
        RegCloseKey(hKeyRegistry);
    }
    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }

    if (lpValueNameString) {
        HeapFree (GetProcessHeap(), 0, (LPVOID)lpValueNameString);
    }
    
    if (lpReturnValue) {
        HeapFree (GetProcessHeap(), 0, (LPVOID)lpReturnValue);
    }
    
    if ((hKeyValue != NULL) && (hKeyValue != INVALID_HANDLE_VALUE)) {
        RegCloseKey (hKeyValue);
    }

//    if (dwSystemVersion == OLD_VERSION &&
//        hKeyNames) 
    if ((hKeyNames != NULL) && (hKeyNames != INVALID_HANDLE_VALUE)) {
       RegCloseKey (hKeyNames);
    }

    if ((hKeyRegistry != HKEY_LOCAL_MACHINE) &&
        (hKeyRegistry != NULL)) {
        RegCloseKey(hKeyRegistry);
    }
    return NULL;
}

BOOL
IsMsObject(CString *pLibraryName)
{
    CString LocalLibraryName;

    LocalLibraryName = *pLibraryName;
    LocalLibraryName.MakeLower();

    // for now this just compares known DLL names. valid as of
    // NT v4.0
    if (LocalLibraryName.Find((LPCWSTR)L"perfctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"ftpctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"rasctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"winsctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"sfmctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"atkctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"bhmon.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"tapictrs.dll") >= 0) return TRUE;
    // NT v5.0
    if (LocalLibraryName.Find((LPCWSTR)L"perfdisk.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"perfos.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"perfproc.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"perfnet.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"winspool.drv") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"tapiperf.dll") >= 0) return TRUE;

    return FALSE;
}
/////////////////////////////////////////////////////////////////////////////
// CExctrlstDlg dialog

CExctrlstDlg::CExctrlstDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CExctrlstDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CExctrlstDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    hKeyMachine = HKEY_LOCAL_MACHINE;
    hKeyServices = NULL;
    dwSortOrder = SORT_ORDER_SERVICE;
    bReadWriteAccess = TRUE;
    dwRegAccessMask = KEY_READ | KEY_WRITE;
    pNameTable = NULL;
    dwLastElement = 0;
    dwListBoxHorizExtent = 0;
    dwTabStopCount = 1;
    dwTabStopArray[0] = 85;
    memset (&dwIdArray[0], 0, sizeof(dwIdArray));
}

CExctrlstDlg::~CExctrlstDlg()
{
    if (hKeyServices != NULL && hKeyServices != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyServices);
    }
    if (hKeyMachine != NULL && hKeyMachine != INVALID_HANDLE_VALUE
                            && hKeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey(hKeyMachine);
    }
    if (pNameTable != NULL) {
        HeapFree (GetProcessHeap(), 0, pNameTable);
        pNameTable = NULL;
        dwLastElement = 0;
    }
}

void CExctrlstDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CExctrlstDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CExctrlstDlg, CDialog)
    //{{AFX_MSG_MAP(CExctrlstDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_LBN_SELCHANGE(IDC_EXT_LIST, OnSelchangeExtList)
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
    ON_BN_CLICKED(IDC_ABOUT, OnAbout)
    ON_EN_KILLFOCUS(IDC_MACHINE_NAME, OnKillfocusMachineName)
    ON_BN_CLICKED(IDC_SORT_LIBRARY, OnSortButton)
    ON_BN_CLICKED(IDC_SORT_SERVICE, OnSortButton)
    ON_BN_CLICKED(IDC_SORT_ID, OnSortButton)
    ON_BN_CLICKED(IDC_ENABLED_BTN, OnEnablePerf)
    ON_WM_SYSCOMMAND()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CExctrlstDlg::EnablePerfCounters (HKEY hKeyItem, DWORD dwNewValue)
{
    DWORD   dwStatus;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   dwSize;
    DWORD   dwReturn;
    
    switch (dwNewValue) {
        case ENABLE_PERF_CTR_QUERY:
            dwType = 0;
            dwSize = sizeof (dwValue);
            dwValue = 0;
            dwStatus = RegQueryValueExW (
                hKeyItem,
                cszDisablePerformanceCounters,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &dwSize);

            if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                switch (dwValue) {
                    case 0: dwReturn = ENABLE_PERF_CTR_ENABLE; break;
                    case 1: dwReturn = ENABLE_PERF_CTR_DISABLE; break;
                    default: dwReturn = 0; break;
                }
            } else {
                // if the value is not present, or not = 1, then the perfctrs
                // are enabled
                dwReturn = ENABLE_PERF_CTR_ENABLE;
            }
            break;

        case ENABLE_PERF_CTR_ENABLE:
            dwType = REG_DWORD;
            dwSize = sizeof (dwValue);
            dwValue = 0;
            dwStatus = RegSetValueExW (
                hKeyItem,
                cszDisablePerformanceCounters,
                0L,
                dwType,
                (LPBYTE)&dwValue,
                dwSize);
            if (dwStatus == ERROR_SUCCESS) {
                dwReturn = ENABLE_PERF_CTR_ENABLE;
            } else {
                dwReturn = 0;
            }
            break;

        case ENABLE_PERF_CTR_DISABLE:
            dwType = REG_DWORD;
            dwSize = sizeof (dwValue);
            dwValue = 1;
            dwStatus = RegSetValueExW (
                hKeyItem,
                cszDisablePerformanceCounters,
                0L,
                dwType,
                (LPBYTE)&dwValue,
                dwSize);
            if (dwStatus == ERROR_SUCCESS) {
                dwReturn = ENABLE_PERF_CTR_DISABLE;
            } else {
                dwReturn = 0;
            }
            break;

        default:
            dwReturn = 0;
    }
    return dwReturn;
}

void CExctrlstDlg::ScanForExtensibleCounters ()
{
    LONG    lStatus = ERROR_SUCCESS;
    LONG    lEnumStatus = ERROR_SUCCESS;
    DWORD   dwServiceIndex;
    TCHAR   szServiceSubKeyName[MAX_PATH];
    TCHAR   szPerfSubKeyName[MAX_PATH+20];
    TCHAR   szItemText[MAX_PATH];
    TCHAR   szListText[MAX_PATH*2];
    DWORD   dwNameSize;
    HKEY    hKeyPerformance;
    UINT_PTR nListBoxEntry;
    DWORD   dwItemSize, dwType, dwValue;
    HCURSOR hOldCursor;
    DWORD   dwThisExtent;
    HDC     hDcListBox;
    CWnd    *pCWndListBox;

    hOldCursor = ::SetCursor (LoadCursor(NULL, IDC_WAIT));

    ResetListBox();
    
    if (hKeyServices == NULL) {
        // try read/write access
        lStatus = RegOpenKeyEx (hKeyMachine,
            cszServiceKeyName,
            0L,
            dwRegAccessMask,
            &hKeyServices);
        if (lStatus != ERROR_SUCCESS) {
            // try read-only then
            dwRegAccessMask = KEY_READ;
            bReadWriteAccess = FALSE;
            lStatus = RegOpenKeyEx (hKeyMachine,
                cszServiceKeyName,
                0L,
                dwRegAccessMask,
                &hKeyServices);
            if (lStatus != ERROR_SUCCESS) {
                // display Read Only message
                AfxMessageBox (IDS_READ_ONLY);
            } else {
                // fall through with error code
                // display no access message
                AfxMessageBox (IDS_NO_ACCESS);
            }
        }
    } else {
        lStatus = ERROR_SUCCESS;
    }
        
    if (lStatus == ERROR_SUCCESS) {
        pCWndListBox = GetDlgItem (IDC_EXT_LIST);
        hDcListBox = ::GetDC (pCWndListBox->m_hWnd);
        if (hDcListBox == NULL) {
            return;
        }
        dwServiceIndex = 0;
        dwNameSize = MAX_PATH;
        while ((lEnumStatus = RegEnumKeyEx (
            hKeyServices,
            dwServiceIndex,
            szServiceSubKeyName,
            &dwNameSize,
            NULL,
            NULL,
            NULL,
            NULL)) == ERROR_SUCCESS) {

            //try to open the perfkey under this key.
            lstrcpy (szPerfSubKeyName, szServiceSubKeyName);
            lstrcat (szPerfSubKeyName, cszPerformance);

            lStatus = RegOpenKeyEx (
                hKeyServices,
                szPerfSubKeyName,
                0L,
                dwRegAccessMask,
                &hKeyPerformance);

            if (lStatus == ERROR_SUCCESS) {
                // look up the library name

                dwItemSize = MAX_PATH * sizeof(TCHAR);
                dwType = 0;
                lStatus = RegQueryValueEx (
                     hKeyPerformance,
                     cszLibrary,
                     NULL,
                     &dwType,
                     (LPBYTE)&szItemText[0],
                     &dwItemSize);

                if ((lStatus != ERROR_SUCCESS) ||
                    ((dwType != REG_SZ) && dwType != REG_EXPAND_SZ)) {
                    lstrcpy (szItemText, cszNotFound);
                }

                dwItemSize = sizeof(DWORD);
                dwType = 0;
                dwValue = 0;
                lStatus = RegQueryValueEx (
                     hKeyPerformance,
                     cszFirstCounter,
                     NULL,
                     &dwType,
                     (LPBYTE)&dwValue,
                     &dwItemSize);

                if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                    dwValue = 0;
                }

                // make the string for the list box here depending
                // on the selected sort order.

                if (dwSortOrder == SORT_ORDER_LIBRARY) {
                    lstrcpy(szListText, szItemText);
                    lstrcat(szListText, cszTab);
                    lstrcat(szListText, szServiceSubKeyName);
                } else if (dwSortOrder == SORT_ORDER_ID) {
                    _stprintf (szListText, cszSortIdFmt,
                        dwValue, szServiceSubKeyName);
                } else { // default is sort by service
                    lstrcpy(szListText, szServiceSubKeyName);
                    lstrcat(szListText, cszTab);
                    lstrcat(szListText, szItemText);
                }

                // add this name to the list box
                nListBoxEntry = SendDlgItemMessage(IDC_EXT_LIST,
                    LB_ADDSTRING, 0, (LPARAM)&szListText[0]);

                if (nListBoxEntry != LB_ERR) {
                    dwThisExtent = GetTabbedTextExtent (
                        hDcListBox,
                        szListText,
                        lstrlen(szListText),
                        (int)dwTabStopCount,
                        (int *)&dwTabStopArray[0]);

                    if (dwThisExtent > dwListBoxHorizExtent) {
                        dwListBoxHorizExtent = dwThisExtent;
                        SendDlgItemMessage(IDC_EXT_LIST,
                            LB_SETHORIZONTALEXTENT, 
                            (WPARAM)LOWORD(dwListBoxHorizExtent), (LPARAM)0);                
                    }
                    // save key to this entry in the registry
                    SendDlgItemMessage(IDC_EXT_LIST,
                        LB_SETITEMDATA, (WPARAM)nListBoxEntry,
                        (LPARAM)hKeyPerformance);

                    // Ignore PREFIX complains of handle leak for hKeyPerformance.
                    //
                    // local variable hKeyPerformance (registry key for "<service>\Performace") is
                    // put in persistent data storage so that later EXCTRLST can retrieve its value in
                    // CExctrlstDlg::UpdateDllInfo() and CExctrlstDlg::OnEnablePerf() and uses it as
                    // a parameter in RegQueryValueEx() calls.
                    // These registry keys will be released in CExctrlstDlg::ResetListBox().
                }
                else {
                    // close the key since there's no point in
                    // keeping it open
                    RegCloseKey(hKeyPerformance);
                    SendDlgItemMessage(IDC_EXT_LIST,
                            LB_SETITEMDATA, (WPARAM) nListBoxEntry,
                            (LPARAM) NULL);
                }
            }
            // reset for next loop
            dwServiceIndex++;
            dwNameSize = MAX_PATH;
        }
        ::ReleaseDC (pCWndListBox->m_hWnd, hDcListBox);
    }
    nListBoxEntry = SendDlgItemMessage (IDC_EXT_LIST, LB_GETCOUNT);
    if (nListBoxEntry > 0) {
        SendDlgItemMessage (IDC_EXT_LIST, LB_SETCURSEL, 0, 0);
    }
    ::SetCursor (hOldCursor);

}

void CExctrlstDlg::UpdateSystemInfo () {
    TCHAR   szItemText[MAX_PATH];

    _stprintf (szItemText, cszIdFmt, 
        dwIdArray[0], dwIdArray[0], cszSpace);
    SetDlgItemText (IDC_LAST_COUNTER_VALUE, szItemText);

    _stprintf (szItemText, cszIdFmt, 
        dwIdArray[1], dwIdArray[1],
        dwIdArray[1] != dwIdArray[0] ? cszSplat : cszSpace);
    SetDlgItemText (IDC_LAST_TEXT_COUNTER_VALUE, szItemText);

    _stprintf (szItemText, cszIdFmt, 
        dwIdArray[2], dwIdArray[2], cszSpace);
    SetDlgItemText (IDC_LAST_HELP_VALUE, szItemText);

    _stprintf (szItemText, cszIdFmt, 
        dwIdArray[3], dwIdArray[3],
        dwIdArray[3] != dwIdArray[2] ? cszSplat : cszSpace);
    SetDlgItemText (IDC_LAST_TEXT_HELP_VALUE, szItemText);

}

void CExctrlstDlg::UpdateDllInfo () {
    HKEY    hKeyItem;
    TCHAR   szItemText[MAX_PATH];
    UINT_PTR nSelectedItem;
    LONG    lStatus;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   dwItemSize;
    BOOL    bNoIndexValues = FALSE;
    DWORD   dwEnabled;

    CString OpenProcName;
    CString LibraryName;
    
    HCURSOR hOldCursor;

    hOldCursor = ::SetCursor (LoadCursor(NULL, IDC_WAIT));

    OpenProcName.Empty();
    LibraryName.Empty();
    // update the performance counter information

    nSelectedItem = SendDlgItemMessage (IDC_EXT_LIST, LB_GETCURSEL);

    if (nSelectedItem != LB_ERR) {
        // get registry key for the selected item
        hKeyItem = (HKEY)SendDlgItemMessage(IDC_EXT_LIST, LB_GETITEMDATA,
            (WPARAM)nSelectedItem, 0);

        if (hKeyItem == NULL) {
            lStatus = ERROR_INVALID_HANDLE;
        }
        else {
            dwItemSize = MAX_PATH * sizeof(TCHAR);
            dwType = 0;
            lStatus = RegQueryValueEx(
                             hKeyItem,
                             cszLibrary,
                             NULL,
                             & dwType,
                             (LPBYTE) & szItemText[0],
                             & dwItemSize);
        }

        if ((lStatus != ERROR_SUCCESS) ||
            ((dwType != REG_SZ) && dwType != REG_EXPAND_SZ)) {
            lstrcpy (szItemText, cszNotFound);
        } else {
            LibraryName = szItemText;
        }
        SetDlgItemText (IDC_DLL_NAME, szItemText);

        dwItemSize = MAX_PATH * sizeof(TCHAR);
        dwType = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszOpen,
             NULL,
             &dwType,
             (LPBYTE)&szItemText[0],
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) ||
            ((dwType != REG_SZ) && dwType != REG_EXPAND_SZ)) {
            lstrcpy (szItemText, cszNotFound);
        } else {
            OpenProcName = szItemText;
        }
        SetDlgItemText (IDC_OPEN_PROC, szItemText);

        dwItemSize = MAX_PATH * sizeof(TCHAR);
        dwType = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszCollect,
             NULL,
             &dwType,
             (LPBYTE)&szItemText[0],
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) ||
            ((dwType != REG_SZ) && dwType != REG_EXPAND_SZ)) {
            lstrcpy (szItemText, cszNotFound);
        }
        SetDlgItemText (IDC_COLLECT_PROC, szItemText);

        dwItemSize = MAX_PATH * sizeof(TCHAR);
        dwType = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszClose,
             NULL,
             &dwType,
             (LPBYTE)&szItemText[0],
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) ||
            ((dwType != REG_SZ) && dwType != REG_EXPAND_SZ)) {
            lstrcpy (szItemText, cszNotFound);
        }
        SetDlgItemText (IDC_CLOSE_PROC, szItemText);

        dwItemSize = sizeof(DWORD);
        dwType = 0;
        dwValue = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszFirstCounter,
             NULL,
             &dwType,
             (LPBYTE)&dwValue,
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
            lstrcpy (szItemText, cszNotFound);
            bNoIndexValues = TRUE;
        } else {
            _stprintf (szItemText, cszServIdFmt, dwValue, IndexHasString (dwValue) ? cszSpace : cszSplat);
        }
        SetDlgItemText (IDC_FIRST_CTR_ID, szItemText);

        dwItemSize = sizeof(DWORD);
        dwType = 0;
        dwValue = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszLastCounter,
             NULL,
             &dwType,
             (LPBYTE)&dwValue,
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
            lstrcpy (szItemText, cszNotFound);
        } else {
            _stprintf (szItemText, cszServIdFmt, dwValue, IndexHasString (dwValue) ? cszSpace : cszSplat);
        }
        SetDlgItemText (IDC_LAST_CTR_ID, szItemText);

        dwItemSize = sizeof(DWORD);
        dwType = 0;
        dwValue = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszFirstHelp,
             NULL,
             &dwType,
             (LPBYTE)&dwValue,
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
            lstrcpy (szItemText, cszNotFound);
            bNoIndexValues = TRUE;
        } else {
            _stprintf (szItemText, cszServIdFmt, dwValue, IndexHasString (dwValue) ? cszSpace : cszSplat);
        }
        SetDlgItemText (IDC_FIRST_HELP_ID, szItemText);

        dwItemSize = sizeof(DWORD);
        dwType = 0;
        dwValue = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszLastHelp,
             NULL,
             &dwType,
             (LPBYTE)&dwValue,
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
            lstrcpy (szItemText, cszNotFound);
        } else {
            _stprintf (szItemText, cszServIdFmt, dwValue, IndexHasString (dwValue) ? cszSpace : cszSplat);
        }
        SetDlgItemText (IDC_LAST_HELP_ID, szItemText);

        if (bNoIndexValues) {
            // test to see if this is a "standard" i.e. Microsoft provided
            // extensible counter or simply one that hasn't been completely
            // installed
            if (IsMsObject(&LibraryName)) {
                SetDlgItemText (IDC_FIRST_HELP_ID, cszNA);
                SetDlgItemText (IDC_LAST_HELP_ID, cszNA);
                SetDlgItemText (IDC_FIRST_CTR_ID, cszNA);
                SetDlgItemText (IDC_LAST_CTR_ID, cszNA);
            }
        }

        GetDlgItem(IDC_ENABLED_BTN)->ShowWindow (bReadWriteAccess ? SW_SHOW : SW_HIDE);
        GetDlgItem(IDC_ENABLED_BTN)->EnableWindow (bReadWriteAccess);

        dwEnabled = EnablePerfCounters (hKeyItem, ENABLE_PERF_CTR_QUERY);

        if (bReadWriteAccess) {
            // then set the check box
            CheckDlgButton (IDC_ENABLED_BTN, dwEnabled == ENABLE_PERF_CTR_ENABLE ? 1 : 0);
            GetDlgItem(IDC_DISABLED_TEXT)->ShowWindow (SW_HIDE);
        } else {
            // update the text message
            GetDlgItem(IDC_DISABLED_TEXT)->ShowWindow (
                (!(dwEnabled == ENABLE_PERF_CTR_ENABLE))  ?
                    SW_SHOW : SW_HIDE);
            GetDlgItem(IDC_DISABLED_TEXT)->EnableWindow (TRUE);
        }


    }
    ::SetCursor (hOldCursor);
}

void CExctrlstDlg::ResetListBox ()
{
    INT_PTR nItemCount;
    INT nThisItem;
    HKEY    hKeyItem;
    
    nItemCount = SendDlgItemMessage (IDC_EXT_LIST, LB_GETCOUNT);
    nThisItem = 0;
    while (nThisItem > nItemCount) {
        hKeyItem = (HKEY) SendDlgItemMessage(IDC_EXT_LIST,
            LB_GETITEMDATA, (WPARAM)nThisItem);
        if (hKeyItem != NULL) RegCloseKey(hKeyItem);
        nThisItem++;
    }
    SendDlgItemMessage (IDC_EXT_LIST, LB_RESETCONTENT);
    dwListBoxHorizExtent = 0;
    SendDlgItemMessage(IDC_EXT_LIST,
        LB_SETHORIZONTALEXTENT, 
        (WPARAM)LOWORD(dwListBoxHorizExtent), (LPARAM)0);                
}

void    CExctrlstDlg::SetSortButtons()
{
    DWORD   dwBtn;
   
    switch (dwSortOrder) {
        case SORT_ORDER_LIBRARY: dwBtn = IDC_SORT_LIBRARY; break;
        case SORT_ORDER_SERVICE: dwBtn = IDC_SORT_SERVICE; break;
        case SORT_ORDER_ID:      dwBtn = IDC_SORT_ID; break;
        default:                 dwBtn = IDC_SORT_SERVICE; break;
    }

    CheckRadioButton (
        IDC_SORT_LIBRARY,
        IDC_SORT_ID,
        dwBtn);
}
/////////////////////////////////////////////////////////////////////////////
// CExctrlstDlg message handlers

BOOL CExctrlstDlg::OnInitDialog()
{
    HCURSOR hOldCursor;
    DWORD   dwLength;

    hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));

    CDialog::OnInitDialog();
    CenterWindow();

    lstrcpy (szThisComputerName, cszDoubleBackslash);
    dwLength = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName (&szThisComputerName[2], &dwLength);

    lstrcpy (szComputerName, szThisComputerName);

    SetDlgItemText (IDC_MACHINE_NAME, szComputerName);

    hKeyMachine = HKEY_LOCAL_MACHINE;

    pNameTable = BuildNameTable (
        szComputerName,
        cszDefaultLangId,
        &dwLastElement,     // size of array in elements
        &dwIdArray[0]);

    SendDlgItemMessage (IDC_MACHINE_NAME, EM_LIMITTEXT,
        (WPARAM)MAX_COMPUTERNAME_LENGTH+2, 0);   // include 2 leading backslash

    SendDlgItemMessage (IDC_EXT_LIST, LB_SETTABSTOPS,
        (WPARAM)dwTabStopCount, (LPARAM)&dwTabStopArray[0]);

    SetSortButtons();

    ScanForExtensibleCounters(); //.checks for access to the registry

    UpdateSystemInfo();

    // set the check box to the appropriate state

    UpdateDllInfo ();   
    
    ::SetCursor(hOldCursor);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CExctrlstDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CExctrlstDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CExctrlstDlg::OnSelchangeExtList()
{
    UpdateDllInfo ();   
}

void CExctrlstDlg::OnDestroy()
{
    ResetListBox();
    CDialog::OnDestroy();
}

void CExctrlstDlg::OnAbout()
{
    CAbout dlg;
    dlg.DoModal();
}

void CExctrlstDlg::OnRefresh()
{
    HCURSOR hOldCursor;

    hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));

    ScanForExtensibleCounters();
    if (pNameTable != NULL) {
        HeapFree (GetProcessHeap(), 0, pNameTable);
        pNameTable = NULL;
        dwLastElement = 0;
    }

    pNameTable = BuildNameTable (
        szComputerName,
        cszDefaultLangId,
        &dwLastElement,     // size of array in elements
        &dwIdArray[0]);

    UpdateSystemInfo();

    UpdateDllInfo ();
    ::SetCursor(hOldCursor);
}

void CExctrlstDlg::OnKillfocusMachineName()
{
    TCHAR   szNewMachineName[MAX_PATH];
    HKEY    hKeyNewMachine;
    LONG    lStatus;
    HCURSOR hOldCursor;

    hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));

    GetDlgItemText (IDC_MACHINE_NAME, szNewMachineName, MAX_PATH);

    if (lstrcmpi(szComputerName, szNewMachineName) != 0) {
        // a new computer has been entered so try to connect to it
        lStatus = RegConnectRegistry (szNewMachineName,
            HKEY_LOCAL_MACHINE, &hKeyNewMachine);
        if (lStatus == ERROR_SUCCESS) {
            RegCloseKey (hKeyServices); // close the old key
            hKeyServices = NULL;        // clear it
            bReadWriteAccess = TRUE;                // reset the access variables
            dwRegAccessMask = KEY_READ | KEY_WRITE;
            if (hKeyMachine != NULL && hKeyMachine != INVALID_HANDLE_VALUE
                                    && hKeyMachine != HKEY_LOCAL_MACHINE) {
                RegCloseKey(hKeyMachine);  // close the old machine
            }
            hKeyMachine = hKeyNewMachine; // update to the new machine  
            lstrcpy (szComputerName, szNewMachineName); // update the name
            OnRefresh();                // get new counters
        } else {
            SetDlgItemText (IDC_MACHINE_NAME, szComputerName);
        }
    } else {
        // the machine name has not changed
    }
    ::SetCursor (hOldCursor);
}

void CExctrlstDlg::OnSortButton()
{
    if (IsDlgButtonChecked(IDC_SORT_LIBRARY)) {
        dwSortOrder = SORT_ORDER_LIBRARY;
    } else if (IsDlgButtonChecked(IDC_SORT_SERVICE)) {
        dwSortOrder = SORT_ORDER_SERVICE;
    } else if (IsDlgButtonChecked(IDC_SORT_ID)) {
        dwSortOrder = SORT_ORDER_ID;
    }
    ScanForExtensibleCounters();
    UpdateDllInfo ();   
}

void CExctrlstDlg::OnEnablePerf()
{
    HKEY    hKeyItem;
    UINT_PTR    nSelectedItem;
    DWORD   dwNewValue;
                    
    nSelectedItem = SendDlgItemMessage (IDC_EXT_LIST, LB_GETCURSEL);

    if (nSelectedItem != LB_ERR) {
        // get registry key for the selected item
        hKeyItem = (HKEY)SendDlgItemMessage (IDC_EXT_LIST, LB_GETITEMDATA,
            (WPARAM)nSelectedItem, 0);

        if (hKeyItem != NULL) {
            // get selected perf item and the corre
            dwNewValue = IsDlgButtonChecked(IDC_ENABLED_BTN) ?
                            ENABLE_PERF_CTR_ENABLE :
                            ENABLE_PERF_CTR_DISABLE;

            if (EnablePerfCounters (hKeyItem, dwNewValue) == 0) {
                MessageBeep(0xFFFFFFFF);
                // then it failed so reset to the curent value
                dwNewValue = EnablePerfCounters (hKeyItem, ENABLE_PERF_CTR_QUERY);
                CheckDlgButton (IDC_ENABLED_BTN, dwNewValue == ENABLE_PERF_CTR_ENABLE ? 1 : 0);
            }
        }
    }
}

void CExctrlstDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    switch (nID) {
    case SC_CLOSE:
        EndDialog(IDOK);
        break;

    default:
        CDialog::OnSysCommand (nID, lParam);
        break;
    }
}
/////////////////////////////////////////////////////////////////////////////
// CAbout dialog


CAbout::CAbout(CWnd* pParent /*=NULL*/)
	: CDialog(CAbout::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAbout)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAbout)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BOOL CAbout::OnInitDialog()
{
	CDialog::OnInitDialog();

    TCHAR buffer[512];
    TCHAR strProgram[1024];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    dw = GetModuleFileName(NULL, strProgram, 1024);

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){
     
            pVersionInfo = (BYTE*)malloc(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        GetDlgItem(IDC_COPYRIGHT)->SetWindowText( pCopyRight );
                        GetDlgItem(IDC_VERSION)->SetWindowText( pVersion );
                    }
                }
                free( pVersionInfo );
            }
        }
    }

    return TRUE;
}


BEGIN_MESSAGE_MAP(CAbout, CDialog)
	//{{AFX_MSG_MAP(CAbout)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAbout message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\exctrlst\exctrlst.cpp ===
// exctrlst.cpp : Defines the class behaviors for the application.
//

#ifndef UNICODE
#define UNICODE     1
#endif
#ifndef _UNICODE
#define _UNICODE    1
#endif

#include "stdafx.h"
#include "exctrlst.h"
#include "exctrdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExctrlstApp

BEGIN_MESSAGE_MAP(CExctrlstApp, CWinApp)
    //{{AFX_MSG_MAP(CExctrlstApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExctrlstApp construction

CExctrlstApp::CExctrlstApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CExctrlstApp object

CExctrlstApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CExctrlstApp initialization

BOOL CExctrlstApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    Enable3dControls();
    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    CExctrlstDlg dlg;
    m_pMainWnd = &dlg;
    INT_PTR nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with OK
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with Cancel
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\exctrlst\exctrlst.h ===
// exctrlst.h : main header file for the EXCTRLST application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CExctrlstApp:
// See exctrlst.cpp for the implementation of this class
//

class CExctrlstApp : public CWinApp
{
public:
	CExctrlstApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExctrlstApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CExctrlstApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\exctrlst\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\exctrlst\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	exctrlst.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\exctrlst\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by exctrlst.rc
//
#define IDC_REFRESH                     2
#define IDD_EXCTRLST_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_ABOUT                       129
#define IDC_EXT_LIST                    1001
#define IDC_MACHINE_NAME                1002
#define IDC_DLL_NAME                    1003
#define IDC_OPEN_PROC                   1004
#define IDC_COLLECT_PROC                1005
#define IDC_CLOSE_PROC                  1006
#define IDC_FIRST_CTR_ID                1007
#define IDC_LAST_CTR_ID                 1008
#define IDC_FIRST_HELP_ID               1009
#define IDC_LAST_HELP_ID                1010
#define IDC_SORT_LIBRARY                1011
#define IDC_SORT_SERVICE                1012
#define IDC_SORT_ID                     1013
#define IDC_ENABLED_BTN                 1014
#define IDC_DISABLED_TEXT               1015
#define IDC_LAST_COUNTER_CAPTION        1017
#define IDC_LAST_HELP_CAPTION           1018
#define IDC_LAST_TEXT_ID_CAPTION        1019
#define IDC_LAST_HELP_ID_CAPTION        1020
#define IDC_LAST_COUNTER_VALUE          1021
#define IDC_LAST_TEXT_COUNTER_VALUE     1022
#define IDC_LAST_HELP_VALUE             1023
#define IDC_LAST_TEXT_HELP_VALUE        1024
#define IDC_ABOUT                       1025
#define IDC_VERSION                     1026
#define IDC_COPYRIGHT                   1027
#define IDS_READ_ONLY                   59142
#define IDS_NO_ACCESS                   59143

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\exp\exp.c ===
/*** EXP.C - expunge deleted files deleted with the rm program ****************
*
*       Copyright (c) 1986-1990, Microsoft Corporation.  All rights reserved.
*
* Purpose:
*  The three tools EXP, RM and UNDEL are used to delete files so
*  that they can be undeleted.  This is done my renaming the file into
*  a hidden directory called DELETED.
*
* Notes:
*  Exp command line syntax:
*
*   EXP [options] [path ...]
*
*  where the [options] are :-
*
*       /r      Recursively expunge from path specified
*       /q      Quiet mode; no extraneous messages
*       /help   spawn Qh if possible, else issue a Usage message
*
* Revision History:
*  08-Jan-1990 SB SLM version upgrading added; Add CopyRightYrs Macro
*  03-Jan-1990 SB define QH_TOPIC_NOT_FOUND
*  20-Dec-1989 SB Add check for return code of 3 for qh
*  14-Dec-1989 LN Update Copyright to include 1990
*  23-Oct-1989 LN Version no bumped to 1.01
*  02-Oct-1989 LN Changed Version no to 1.00
*  08-Aug-1989 BW Add Version number. Fix usage syntax. Update copyright.
*  15-May-1989 WB Add /help
*  06-Apr-1987 BW Add copyright notice to Usage().
*  22-Jul-1986 DL Make test for flag case insensitive, add /q
*
******************************************************************************/

/* I N C L U D E    Files */

#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <windows.h>
#include <tools.h>

#include <string.h>


/* D E F I N E s */

#define CopyRightYrs "1987-90"
/* Need 2 steps, first to get correct values in and 2nd to paste them */
/* paste() is hacked to allow LEADING  ZEROES    */
#define paste(a, b, c) #a ".0" #b ".00" #c
#define VERSION(major, minor, buildno) paste(major, minor, buildno)
#define QH_TOPIC_NOT_FOUND 3


/* G L O B A L s */

flagType fRecurse = FALSE;
FILE *pFile;
char cd[MAX_PATH];


/*
 * Forward Function Declarations...
 */
void DoExp( char *, struct findType *, void *);
void Usage( void );

void
DoExp(p, b, dummy)
char *p;
struct findType *b;
void *dummy;
{
    if (b == NULL ||
            (_strcmpi(b->fbuf.cFileName, "deleted") && TESTFLAG(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY) &&
            strcmp(b->fbuf.cFileName, ".") && strcmp(b->fbuf.cFileName, ".."))) {
        fexpunge(p, pFile);
        if (fRecurse) {
            if (!fPathChr(*(strend(p)-1)))
                strcat(p, "\\");
            strcat(p, "*.*");
            forfile(p, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, DoExp, NULL);
        }
    }
    dummy;
}

void
Usage()
{
    printf(
"Microsoft File Expunge Utility.  Version %s\n"
"Copyright (C) Microsoft Corp %s.  All rights reserved.\n\n"
"Usage: EXP [/help] [/rq] [{dir}*]\n",
    VERSION(rmj, rmm, rup), CopyRightYrs);

    exit( 1 );
}


__cdecl main(c, v)
int c;
char *v[];
{
    char *p;
    intptr_t iRetCode;

    pFile = stdout;
    ConvertAppToOem( c, v );
    SHIFT(c,v);
    while( c && fSwitChr( *( p = *v ) ) ) {
        while (*++p) {
            switch (tolower(*p)) {
                case 'r':
                    fRecurse = TRUE;
                    break;
                case 'q':
                    pFile = NULL;
                    break;
                case 'h':
                    if (!_strcmpi(p, "help")) {
                        iRetCode = _spawnlp(P_WAIT, "qh.exe", "qh", "/u",
                                           "exp.exe", NULL);
                        /* qh returns QH_TOPIC_NOT_FOUND and
                         *            -1 is returned when the spawn fails
                         */
                        if (iRetCode != QH_TOPIC_NOT_FOUND && iRetCode != -1)
                            exit(0);
                    }
                    /*
                     * else fall thru...
                     */

                default:
                    Usage();
            }
        }
        SHIFT(c,v);
    }
    if (!c) {
        rootpath(".", cd);
        DoExp(cd, NULL, NULL);
    }
    else
        while (c) {
            strcpy(cd, *v);
            DoExp(cd, NULL, NULL);
            SHIFT(c,v);
        }
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\extag\extag.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       extag.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-17-96   RichardW   Created
//
//----------------------------------------------------------------------------

#define UNICODE
#include <windows.h>
#include <wchar.h>
#include <stdio.h>

WCHAR   ExportTag[] = L"Export Version";
WCHAR   DomesticTag[] = L"US/Canada Only, Not for Export";
WCHAR   OldDomesticTag[] = L"Domestic Use Only";
DWORD   DefLang = 0x04b00409;

#define BINARY_TYPE_UNKNOWN         0
#define BINARY_TYPE_CONTROLLED      1
#define BINARY_TYPE_OPEN            2
#define BINARY_TYPE_CONTROLLED_OLD  3


BOOL
CheckIfControlled(
    LPWSTR  Path,
    DWORD   Flags)
{
    PUCHAR  pData;
    DWORD   cbData;
    DWORD   Zero;
    PWSTR   Description;
    WCHAR   ValueTag[64];
    PDWORD  pdwTranslation;
    DWORD   uLen;

    cbData = GetFileVersionInfoSize( Path, &Zero );

    if ( cbData == 0 )
    {
        return( BINARY_TYPE_UNKNOWN );
    }

    pData = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, cbData );

    if ( !pData )
    {
        return( BINARY_TYPE_UNKNOWN );
    }

    if ( ! GetFileVersionInfo( Path, 0, cbData, pData ) )
    {
        LocalFree( pData );
        return( BINARY_TYPE_UNKNOWN );
    }

    if(!VerQueryValue(pData, L"\\VarFileInfo\\Translation", &pdwTranslation, &uLen))
    {
        pdwTranslation = &DefLang;

        uLen = sizeof(DWORD);
    }

    swprintf( ValueTag, L"\\StringFileInfo\\%04x%04x\\FileDescription",
                LOWORD( *pdwTranslation ), HIWORD( *pdwTranslation ) );

    // L"\\StringFileInfo\\040904b0\\FileDescription",
    if (VerQueryValue(  pData,
                        ValueTag,
                        &Description,
                        &cbData ) )
    {
        if (wcsstr( Description, DomesticTag ) )
        {
            LocalFree( pData );
            return( BINARY_TYPE_CONTROLLED );
        }

        if (wcsstr( Description, OldDomesticTag ) )
        {
            LocalFree( pData );
            return( BINARY_TYPE_CONTROLLED_OLD );
        }

        if ( wcsstr( Description, ExportTag ) )
        {
            LocalFree( pData );

            return( BINARY_TYPE_OPEN );
        }

        LocalFree( pData );

        return( BINARY_TYPE_UNKNOWN );

    }

    return( BINARY_TYPE_UNKNOWN );

}

VOID
Usage( PWSTR Me )
{
    printf("%ws: usage\n", Me);
    printf("  %ws file\tCheck file for export / domestic tags\n", Me);
    printf("  %ws dir\tCheck all files in directory\n", Me);

}

int
__cdecl
wmain(
    int argc,
    WCHAR * argv[] )
{
    DWORD   Result;
    PWSTR   Path;
    WCHAR   FullPath[ MAX_PATH ];
    WCHAR   SearchPath[ MAX_PATH ];
    PWSTR   FilePart;
    DWORD   Attrs;
    WIN32_FIND_DATA Results;
    HANDLE  SearchHandle;
    DWORD   Error;
    DWORD   FileCount;
    DWORD   FileErrors;
    DWORD   FileControlled;
    DWORD   FileExport;
    DWORD   FileUntagged;


    if ( argc < 2 )
    {
        Path = TEXT(".");
    }
    else
    {
        if ((wcscmp(argv[1], L"-?") == 0) ||
            (wcscmp(argv[1], L"/?") == 0) )
        {
            Usage( argv[0] );
            return( 0 );
        }
        Path = argv[1];
    }

    //
    // Expand it:

    if( GetFullPathName(Path,
                        MAX_PATH,
                        FullPath,
                        &FilePart))
    {
        Path = FullPath;
    }

    Result = wcslen( Path );

    if ( Path[Result - 1] == '\\' )
    {
        Path[Result - 1] = '\0';
    }

    Attrs = GetFileAttributes( Path );

    if ( Attrs == (DWORD) -1 )
    {
        Attrs = 0;
    }

    if ( Attrs & FILE_ATTRIBUTE_DIRECTORY )
    {
        //
        // Yikes!
        //

        printf("Searching path %ws ...\n\n", Path );

        FileCount = 0;
        FileErrors = 0;
        FileControlled = 0;
        FileExport = 0;
        FileUntagged = 0;

        swprintf( SearchPath, TEXT("%s\\*.*"), Path );

        SearchHandle = FindFirstFile( SearchPath, &Results );

        if (SearchHandle == INVALID_HANDLE_VALUE)
        {
            return( 0 );
        }

        do
        {
            if ( Results.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            {
                continue;
            }

            FileCount++;

            swprintf( SearchPath, TEXT("%s\\%s"), Path, Results.cFileName );

            Result = CheckIfControlled( SearchPath, 0 );

            switch ( Result )
            {
                case BINARY_TYPE_UNKNOWN :
                    Error = GetLastError();
                    if ( Error )
                    {
                        FileErrors++;
                        if ((Error == ERROR_RESOURCE_DATA_NOT_FOUND) ||
                            (Error == ERROR_RESOURCE_TYPE_NOT_FOUND) )
                        {
                            printf( "File %ws:  expected resource data not found\n", SearchPath );
                        }
                        else
                        {
                            printf( "Error %d while accessing %ws\n", Error, SearchPath );
                        }

                    }
                    else
                    {
                        FileUntagged++;
                    }
                    break;

                case BINARY_TYPE_CONTROLLED:
                    printf("%ws is DOMESTIC USE ONLY\n", SearchPath );
                    FileControlled++;
                    break;

                case BINARY_TYPE_CONTROLLED_OLD:
                    printf("%ws is DOMESTIC USE ONLY (Old Style Tag)\n", SearchPath );
                    FileControlled++;
                    break;

                case BINARY_TYPE_OPEN:
                    FileExport++;
                    printf("%ws tagged as okay for export\n", SearchPath );
                    break;

            }

        } while ( FindNextFile( SearchHandle, &Results ) );

        FindClose( SearchHandle );

        //
        // Dump Stats:
        //

        printf("\n%d files scanned in directory %ws\n", FileCount, Path );
        printf("  %5d file(s) were tagged as export controlled\n", FileControlled );
        printf("  %5d file(s) were tagged as okay for export\n", FileExport);
        printf("  %5d file(s) were not tagged\n", FileUntagged );
        if ( FileErrors )
        {
            printf("  %5d files(s) could not be checked due to errors\n", FileErrors );
        }

    }
    else
    {

        Result = CheckIfControlled( Path, 0 ) ;

        switch ( Result )
        {
            case BINARY_TYPE_UNKNOWN :
                Error = GetLastError();
                if ( Error )
                {
                    if ((Error == ERROR_RESOURCE_DATA_NOT_FOUND) ||
                        (Error == ERROR_RESOURCE_TYPE_NOT_FOUND) )
                    {
                        printf( "File %ws:  expected resource data not found\n", Path );
                    }
                    else
                    {
                        printf( "Error %d while accessing %ws\n", Error, Path );
                    }
                }
                else
                {
                    printf("Image untagged\n");
                }
                break;

            case BINARY_TYPE_CONTROLLED:
                printf("%ws is DOMESTIC USE ONLY\n", Path );
                break;

            case BINARY_TYPE_CONTROLLED_OLD:
                printf("%ws is DOMESTIC USE ONLY (Old Style Tag)\n", Path );
                break;

            case BINARY_TYPE_OPEN:
                printf("%ws is okay for export\n", Path );
                break;

        }
    }

    return( Result );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fcom\fcom.c ===
/* fcom.c - file compare
 *
 *  4/30/86  daniel lipkie  LineCompare, at end, if NOT Same then error
 *  5/01/86  daniel lipkie  SYM files treaded as binary
 *                           if (quiet mode) then exit(1) on FIRST difference
 *  27-May-1986 mz          Make line arrays dynamically allocated at read
 *                          time.
 *                          Make default size be 300 lines.
 *  05-Aug-1986 DANL        MAX default line size 255
 *  10-Feb-1987 mz          Make /m imply /t
 *  10-Jun-1987 danl        fill -> fillbuf
 *  09-Nov-1987 mz          Fix 0D0D0A bug
 *                          Fix different at line 2 bug
 *  25-Nov-1987 mz          All errors to stderr
 *  30-Nov-1987 mz          Resync fails dumps entire file
 *  21-Jul-1988 bw          Don't GP fault on empty test files
 *  06-Aug-1990 davegi      Changed Move to memmove (OS/2 2.0)
 *
 *  Fcom compares two files in either a line-by-line mode or in a strict
 *  byte-by-byte mode.
 *
 *  The byte-by-byte mode is simple; merely read both files and print the
 *  offsets where they differ and the contents.
 *
 *  The line compare mode attempts to isolate differences in ranges of lines.
 *  Two buffers of lines are read and compared.  No hashing of lines needs
 *  to be done; hashing only speedily tells you when things are different,
 *  not the same.  Most files run through this are expected to be largely
 *  the same.  Thus, hashing buys nothing.
 *
 *  [0]     Fill buffers
 *  [1]     If both buffers are empty then
 *  [1.1]       Done
 *  [2]     Adjust buffers so 1st differing lines are at top.
 *  [3]     If buffers are empty then
 *  [3.1]       Goto [0]
 *
 *  This is the difficult part.  We assume that there is a sequence of inserts,
 *  deletes and replacements that will bring the buffers back into alignment.
 *
 *  [4]     xd = yd = FALSE
 *  [5]     xc = yc = 1
 *  [6]     xp = yp = 1
 *  [7]     If buffer1[xc] and buffer2[yp] begin a "sync" range then
 *  [7.1]       Output lines 1 through xc-1 in buffer 1
 *  [7.2]       Output lines 1 through yp-1 in buffer 2
 *  [7.3]       Adjust buffer 1 so line xc is at beginning
 *  [7.4]       Adjust buffer 2 so line yp is at beginning
 *  [7.5]       Goto [0]
 *  [8]     If buffer1[xp] and buffer2[yc] begin a "sync" range then
 *  [8.1]       Output lines 1 through xp-1 in buffer 1
 *  [8.2]       Output lines 1 through yc-1 in buffer 2
 *  [8.3]       Adjust buffer 1 so line xp is at beginning
 *  [8.4]       Adjust buffer 2 so line yc is at beginning
 *  [8.5]       Goto [0]
 *  [9]     xp = xp + 1
 *  [10]    if xp > xc then
 *  [10.1]      xp = 1
 *  [10.2]      xc = xc + 1
 *  [10.3]      if xc > number of lines in buffer 1 then
 *  [10.4]          xc = number of lines
 *  [10.5]          xd = TRUE
 *  [11]    if yp > yc then
 *  [11.1]      yp = 1
 *  [11.2]      yc = yc + 1
 *  [11.3]      if yc > number of lines in buffer 2 then
 *  [11.4]          yc = number of lines
 *  [11.5]          yd = TRUE
 *  [12]    if not xd or not yd then
 *  [12.1]      goto [6]
 *
 *  At this point there is no possible match between the buffers.  For
 *  simplicity, we punt.
 *
 *  [13]    Display error message.
 *
 *  Certain flags may be set to modify the behavior of the comparison:
 *
 *  -a      abbreviated output.  Rather than displaying all of the modified
 *          ranges, just display the beginning, ... and the ending difference
 *  -b      compare the files in binary (or byte-by-byte) mode.  This mode is
 *          default on .EXE, .OBJ, .SYM, .LIB, .COM, .BIN, and .SYS files
 *  -c      ignore case on compare (cmp = strcmpi instead of strcmp)
 *  -l      compare files in line-by-line mode
 *  -lb n   set the size of the internal line buffer to n lines from default
 *          of 300
 *  -m      merge the input files into one for output.  Use extention to
 *          indicate what kind of separators to use.
 *  -n      output the line number also
 *  -NNNN   set the number of lines to resynchronize to NNNN which defaults
 *          to 2
 *  -w      ignore blank lines and white space (ignore len 0, use strcmps)
 *  -t      do not untabify (use fgets instead of fgetl)
 */

#include <malloc.h>

#include <stdio.h>
#include <string.h>
#include <process.h>
#include <ctype.h>
#include <math.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>


int ctSync  =   -1;                     /* number of lines required to sync  */
int cLine = -1;                         /* number of lines in internal buffs */
flagType fAbbrev = FALSE;               /* abbreviated output                */
flagType fBinary = FALSE;               /* binary comparison                 */
flagType fLine   = FALSE;               /* line comparison                   */
flagType fNumb   = FALSE;               /* display line numbers              */
flagType fCase   = TRUE;                /* case is significant               */
flagType fIgnore = FALSE;               /* ignore spaces and blank lines     */
flagType fQuiet  = FALSE;               /* TRUE => no messages output        */
flagType fMerge  = FALSE;               /* TRUE => merge files onto stdout   */

int debug;
#define D_COMP      0x0001
#define D_CCALL     0x0002
#define D_RESYNC    0x0004
#define D_CALL      0x0008
#define D_SYNC      0x0010

struct lineType {
    int     line;                       /* line number                       */
    char    *text;                      /* body of line                      */
};

struct lineType *buffer1, *buffer2;

/*
 * Forward Function Declarations
 */
void usage( char *, int );
int fillbuf( struct lineType *, FILE *, int, int * );
flagType compare( int, int, int, register int, register int);
int BinaryCompare( char *, char * );
void pline(struct lineType *);
void dump(struct lineType *, int, int);
int adjust (struct lineType *, int, int);
void LineCompare (char *, char *);

char * (__cdecl *funcRead) (char *, int, FILE *);
					/* function to use to read lines */

int (__cdecl *fCmp)(const char *, const char *);
					/* function to use to compare lines */

char line[MAXLINELEN];                  /* single line buffer                */

char *extBin[]  = { ".EXE", ".OBJ", ".SYM", ".LIB", ".COM", ".BIN",
                    ".SYS", NULL };


void
usage (p, erc)
char *p;
int erc;
{
    if (!fQuiet) {
        if (p)
            fprintf (stderr, "fcom: %s\n", p);
        else
            fprintf (stderr, "usage: fcom [/a] [/b] [/c] [/l] [/lb n] [/m] [/n] [/NNNN] [/w] [/t] file1 file2\n");
        }
    exit(erc);
}

/*  return number of lines read in
 *
 *  pl          line buffer to fill
 *  fh          handle to read
 *  ct          max number to read
 *  plnum       line number counter to use
 *
 *  returns     number of lines read
 */
int fillbuf( struct lineType *pl, FILE *fh, int ct, int *plnum )
{
    char *line;
    int i, l;

    if ((line = malloc (MAXLINELEN)) == NULL)
        usage ("out of memory", 2);

    if (TESTFLAG (debug, D_CALL))
        printf ("fillbuf  (%p, %p, %d)\n", pl, fh, ct);
    i = 0;
    while (ct-- && (*funcRead) (line, MAXLINELEN, fh) != NULL) {
        if (pl->text != NULL)
            free (pl->text);
        l = strlen (line);
        if ((pl->text = malloc (l+1)) == NULL)
            usage ("out of memory", 2);
// djg  Move ((char far *)line, (char far *) (pl->text), l+1);
        memmove ((char *) (pl->text), (char *)line, l+1);
	if (funcRead == fgets)
            pl->text[l-2] = 0;
        if (fIgnore && !strcmps (pl->text, ""))
            pl->text[0] = 0;
        if (l != 0 || !fIgnore) {
            pl->line = ++*plnum;
            pl++;
            i++;
            }
        }
    if (TESTFLAG (debug, D_CALL))
        printf ("fillbuf  returns %d\n", i);
    free (line);
    return i;
}

/*  compare a range of lines
 *
 *  l1, l2      number of lines in each line buffer
 *  s1, s2      beginning location in each buffer to begin compare
 *  ct          number of contiguous lines to compare
 */
flagType compare (l1, s1, l2, s2, ct)
int l1, l2, ct;
register int s1, s2;
{
    if (TESTFLAG (debug, D_CCALL))
        printf ("compare (%d, %d, %d, %d, %d)\n", l1, s1, l2, s2, ct);
    if (ct <= 0 || s1+ct > l1 || s2+ct > l2)
        return FALSE;
    while (ct--) {
        if (TESTFLAG (debug, D_COMP))
            printf ("'%s' == '%s'? ", buffer1[s1].text, buffer2[s2].text);
        if ((*fCmp)(buffer1[s1++].text, buffer2[s2++].text)) {
            if (TESTFLAG (debug, D_CCALL))
                printf ("No\n");
            return FALSE;
            }
        }
    if (TESTFLAG (debug, D_CCALL))
        printf ("Yes\n");
    return TRUE;
}



BinaryCompare (f1, f2)
char *f1, *f2;
{
    register int c1, c2;
    long pos;
    FILE *fh1, *fh2;
    flagType fSame;

    fSame = TRUE;
    if ((fh1 = fopen (f1, "rb")) == NULL) {
        sprintf (line, "cannot open %s - %s", f1, error ());
        usage (line, 2);
        }
    if ((fh2 = fopen (f2, "rb")) == NULL) {
        sprintf (line, "cannot open %s - %s", f2, error ());
        usage (line, 2);
        }
    pos = 0L;
    while (TRUE) {
        if ((c1 = getc (fh1)) != EOF)
            if ((c2 = getc (fh2)) != EOF)
                if (c1 == c2)
                    ;
                else {
                    fSame = FALSE;
                    if (fQuiet)
                        exit(1);
                    else
                        printf ("%08lx: %02x %02x\n", pos, c1, c2);
                    }
            else {
                sprintf (line, "%s longer than %s", f1, f2);
                usage (line, 1);
                }
        else
        if ((c2 = getc (fh2)) == EOF)
            if (fSame)
                usage ("no differences encountered", 0);
            else
                exit (1);
        else {
            sprintf (line, "%s longer than %s", f2, f1);
            usage (line, 1);
            }
        pos++;
        }
    return( 0 );
}

/* print out a single line */
void pline (pl)
struct lineType *pl;
{
    if (fNumb)
        printf ("%5d:  ", pl->line);
    printf ("%s\n", pl->text);
}

/* output a range of lines */
void dump( struct lineType *pl, int start, int end )
{
    if (fAbbrev && end-start > 2) {
        pline (pl+start);
        printf ("...\n");
        pline (pl+end);
        }
    else
        while (start <= end)
            pline (pl+start++);
}

/*  adjust returns number of lines in buffer
 *
 *  pl          line buffer to be adjusted
 *  ml          number of line in line buffer
 *  lt          number of lines to scroll
 */
adjust( struct lineType *pl, int ml, int lt)
{
    int i;

    if (TESTFLAG (debug, D_CALL))
        printf ("adjust (%p, %d, %d) = ", pl, ml, lt);
    if (TESTFLAG (debug, D_CALL))
        printf ("%d\n", ml-lt);
    if (ml <= lt)
        return 0;
    if (TESTFLAG (debug, D_CALL))
        printf ("move (%p, %p, %04x)\n", &pl[lt], &pl[0], sizeof (*pl)*(ml-lt));
    /*  buffer has 0..lt-1 lt..ml
     *  we free 0..lt-1
     */
    for (i = 0; i < lt; i++)
        if (pl[i].text != NULL)
            free (pl[i].text);
    /*  buffer is 0..0 lt..ml
     *  compact to lt..ml ???
     */
// djg  Move ((char far *)&pl[lt], (char far *)&pl[0], sizeof (*pl)*(ml-lt));
    memmove ((char *)&pl[0], (char *)&pl[lt], sizeof (*pl)*(ml-lt));
    /*  buffer is lt..ml ??
     *  fill to be lt..ml 0..0
     */
    for (i = ml-lt; i < ml; i++)
        pl[i].text = NULL;
    return ml-lt;
}


void LineCompare (f1, f2)
char *f1, *f2;
{
    FILE *fh1, *fh2;
    int l1, l2, i, xp, yp, xc, yc;
    flagType xd, yd, fSame, fFirstLineDifferent;
    int line1, line2;

    fFirstLineDifferent = TRUE;
    fSame = TRUE;
    if ((fh1 = fopen (f1, "rb")) == NULL) {
        sprintf (line, "cannot open %s - %s", f1, error ());
        usage (line, 2);
        }
    if ((fh2 = fopen (f2, "rb")) == NULL) {
        sprintf (line, "cannot open %s - %s", f2, error ());
        usage (line, 2);
        }
    if ((buffer1 = (struct lineType *)calloc (cLine, sizeof *buffer1)) == NULL ||
        (buffer2 = (struct lineType *)calloc (cLine, sizeof *buffer1)) == NULL)
        usage ("out of memory\n", 2);
    l1 = l2 = 0;
    line1 = line2 = 0;

l0: if (TESTFLAG (debug, D_SYNC))
        printf ("At scan beginning\n");
    if (fQuiet && !fSame)
        exit(1);
    l1 += fillbuf  (buffer1+l1, fh1, cLine-l1, &line1);
    l2 += fillbuf  (buffer2+l2, fh2, cLine-l2, &line2);
    if (l1 == 0 && l2 == 0) {
        if (fSame)
            usage ("no differences encountered", 0);
        else
            usage ("differences encountered", 1);
        }

    /*  find first line that differs in buffer
     */
    xc = min (l1, l2);
    for (i=0; i < xc; i++)
        if (!compare (l1, i, l2, i, 1))
            break;
    if (fMerge)
        dump (buffer2, 0, i-1);

    /*  If we are different at a place other than at the top then we know
     *  that there will be a matching line at the head of the buffer
     */
    if (i != 0)
        fFirstLineDifferent = FALSE;

    /*  if we found one at all, then adjust all buffers so last matching
     *  line is at top.  Note that if we are doing this for the first buffers
     *  worth in the file then the top lines WON'T MATCH
     */
    if (i != xc)
        i = max (i-1, 0);

    l1 = adjust (buffer1, l1, i);
    l2 = adjust (buffer2, l2, i);

    /*  if we've matched the entire buffers-worth then go back and fill some
     *  more
     */
    if (l1 == 0 && l2 == 0) {
        fFirstLineDifferent = FALSE;
        goto l0;
        }

    /*  Fill up the buffers as much as possible; the next match may occur
     *  AFTER the current set of buffers
     */
    l1 += fillbuf  (buffer1+l1, fh1, cLine-l1, &line1);
    l2 += fillbuf  (buffer2+l2, fh2, cLine-l2, &line2);
    if (TESTFLAG (debug, D_SYNC))
        printf ("buffers are adjusted, %d, %d remain\n", l1, l2);
    xd = yd = FALSE;
    xc = yc = 1;
    xp = yp = 1;

    /*  begin trying to match the buffers
     */
l6: if (TESTFLAG (debug, D_RESYNC))
        printf ("Trying resync %d,%d  %d,%d\n", xc, xp, yc, yp);
    i = min (l1-xc,l2-yp);
    i = min (i, ctSync);
    if (compare (l1, xc, l2, yp, i)) {
        fSame = FALSE;
        if (fMerge) {
            printf ("#if OLDVERSION\n");
            dump (buffer1, fFirstLineDifferent ? 0 : 1, xc-1);
            printf ("#else\n");
            dump (buffer2, fFirstLineDifferent ? 0 : 1, yp-1);
            printf ("#endif\n");
            }
        else
        if (!fQuiet) {
            printf ("***** %s\n", f1);
            dump (buffer1, 0, xc);
            printf ("***** %s\n", f2);
            dump (buffer2, 0, yp);
            printf ("*****\n\n");
            }
        if (TESTFLAG (debug, D_SYNC))
            printf ("Sync at %d,%d\n", xc, yp);
        l1 = adjust (buffer1, l1, xc);
        l2 = adjust (buffer2, l2, yp);
        fFirstLineDifferent = FALSE;
        goto l0;
        }
    i = min (l1-xp, l2-yc);
    i = min (i, ctSync);
    if (compare (l1, xp, l2, yc, i)) {
        fSame = FALSE;
        if (fMerge) {
            printf ("#if OLDVERSION\n");
            dump (buffer1, fFirstLineDifferent ? 0 : 1, xp-1);
            printf ("#else\n");
            dump (buffer2, fFirstLineDifferent ? 0 : 1, yc-1);
            printf ("#endif\n");
            }
        else
        if (!fQuiet) {
            printf ("***** %s\n", f1);
            dump (buffer1, 0, xp);
            printf ("***** %s\n", f2);
            dump (buffer2, 0, yc);
            printf ("*****\n\n");
            }
        if (TESTFLAG (debug, D_SYNC))
            printf ("Sync at %d,%d\n", xp, yc);
        l1 = adjust (buffer1, l1, xp);
        l2 = adjust (buffer2, l2, yc);
        fFirstLineDifferent = FALSE;
        goto l0;
        }
    if (++xp > xc) {
        xp = 1;
        if (++xc >= l1) {
            xc = l1;
            xd = TRUE;
            }
        }
    if (++yp > yc) {
        yp = 1;
        if (++yc >= l2) {
            yc = l1;
            yd = TRUE;
            }
        }
    if (!xd || !yd)
        goto l6;
    fSame = FALSE;
    if (fMerge) {
        if (l1 >= cLine || l2 >= cLine)
            fprintf (stderr, "resync failed.  Files are too different\n");
        printf ("#if OLDVERSION\n");
        do {
            dump (buffer1, 0, l1-1);
            l1 = adjust (buffer1, l1, l1);
        } while (l1 += fillbuf  (buffer1+l1, fh1, cLine-l1, &line1));
        printf ("#else\n");
        do {
            dump (buffer2, 0, l2-1);
            l2 = adjust (buffer2, l2, l2);
        } while (l2 += fillbuf  (buffer2+l2, fh2, cLine-l2, &line2));
        printf ("#endif\n");
        }
    else
    if (!fQuiet) {
        if (l1 >= cLine || l2 >= cLine)
            fprintf (stderr, "resync failed.  Files are too different\n");
        printf ("***** %s\n", f1);
        do {
            dump (buffer1, 0, l1-1);
            l1 = adjust (buffer1, l1, l1);
        } while (l1 += fillbuf  (buffer1+l1, fh1, cLine-l1, &line1));
        printf ("***** %s\n", f2);
        do {
            dump (buffer2, 0, l2-1);
            l2 = adjust (buffer2, l2, l2);
        } while (l2 += fillbuf  (buffer2+l2, fh2, cLine-l2, &line2));
        printf ("*****\n\n");
        }
    exit (1);
}

__cdecl main (c, v)
int c;
char *v[];
{
    int i;

    funcRead = fgetl;

    ConvertAppToOem( c, v );
    if (c == 1)
        usage (NULL, 2);
    SHIFT(c,v);
    while (fSwitChr (**v)) {
        if (!strcmp (*v+1, "a"))
            fAbbrev = TRUE;
        else
        if (!strcmp (*v+1, "b"))
            fBinary = TRUE;
        else
        if (!strcmp (*v+1, "c"))
            fCase = FALSE;
        else
        if (!strncmp (*v+1, "d", 1))
            debug = atoi (*v+2);
        else
        if (!strcmp (*v+1, "l"))
            fLine = TRUE;
        else
        if (!strcmp (*v+1, "lb")) {
            SHIFT(c,v);
            cLine = ntoi (*v, 10);
            }
        else
        if (!strcmp (*v+1, "m")) {
            fMerge = TRUE;
	    funcRead = fgets;
            }
        else
        if (!strcmp (*v+1, "n"))
            fNumb = TRUE;
        else
        if (!strcmp (*v+1, "q"))
            fQuiet = TRUE;
        else
        if (*strbskip (*v+1, "0123456789") == '\0')
            ctSync = ntoi (*v+1, 10);
        else
        if (!strcmp (*v+1, "t"))
	    funcRead = fgets;
        else
        if (!strcmp (*v+1, "w"))
            fIgnore = TRUE;
        else
            usage (NULL, 2);
        SHIFT(c,v);
        }
    if (c != 2)
        usage (NULL, 2);
    if (ctSync != -1)
        fLine = TRUE;
    else
        ctSync = 2;
    if (cLine == -1)
        cLine = 300;
    if (!fBinary && !fLine) {
        extention (v[0], line);
        for (i = 0; extBin[i]; i++)
            if (!_strcmpi (extBin[i], line))
                fBinary = TRUE;
        if (!fBinary)
            fLine = TRUE;
        }
    if (fBinary && (fLine || fNumb))
        usage ("incompatable switches", 2);
    if (fIgnore)
        if (fCase)
	    fCmp = strcmps;
        else
	    fCmp = strcmpis;
    else
    if (fCase)
	fCmp = strcmp;
    else
	fCmp = _strcmpi;
    if (fBinary)
        BinaryCompare (v[0], v[1]);
    else
        LineCompare (v[0], v[1]);
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\frespace\frespace.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <stdio.h>
#include <string.h>

void DiskFreeSpace(char *DirectoryName)
{

 ULARGE_INTEGER freeBytesAvailableToCaller;
 ULARGE_INTEGER totalNumberOfBytes;
 ULARGE_INTEGER totalNumberOfFreeBytes;
 HINSTANCE FHandle;
 FARPROC PAddress;



 FHandle = LoadLibrary("Kernel32");
 PAddress = GetProcAddress(FHandle,"GetDiskFreeSpaceEx");

 if (GetDiskFreeSpaceEx(DirectoryName, &freeBytesAvailableToCaller, &totalNumberOfBytes, &totalNumberOfFreeBytes))
 {
	 /*printf("Total number of free bytes (low): %f\n", totalNumberOfFreeBytes.LowPart/1048576.0);
	 printf("Total number of free bytes (high): %lu\n", totalNumberOfFreeBytes.HighPart*4096);*/
	 printf("%f", totalNumberOfFreeBytes.LowPart/1048576.0 + totalNumberOfFreeBytes.HighPart*4096.0);
	 /*printf("Free bytes available to caller(low): %f\n", freeBytesAvailableToCaller.LowPart/1048576.0);
	 printf("Free bytes available to caller(high): %lu\n", freeBytesAvailableToCaller.HighPart*4096);*/
	 /*printf("Free bytes available to caller: %f MB\n", freeBytesAvailableToCaller.LowPart/1048576.0 + freeBytesAvailableToCaller.HighPart*4096.0);
	 /*printf("Total number of bytes (low): %f\n", totalNumberOfBytes.LowPart/1048576.0);
	 printf("Total number of bytes (high): %lu\n", totalNumberOfBytes.HighPart*4096);
	 printf("Total number of bytes: %f MB\n",totalNumberOfBytes.LowPart/1048576.0 + freeBytesAvailableToCaller.HighPart*4096.0);*/
	
 }
 else
 {
	 printf("Error");
 }

}

void __cdecl main(int arc, char *argv[])
{

  char *Path;

  /* Path is the second argument in the command line when calling the executable "freespace" */
  Path = argv[1];

  DiskFreeSpace(Path);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\filever\filever.h ===
// function prototypes
DWORD GetVersionStuff(LPTSTR szFileName, DWORD *pdwLangRet, VS_FIXEDFILEINFO *pvsRet);

VOID PrintFileType(DWORD lBinaryType);
VOID PrintFileAttributes(DWORD dwAttr);
VOID PrintFileSizeAndDate(WIN32_FIND_DATA *pfd);
VOID PrintFileVersion(LPTSTR szFileName);

BOOL FListFiles(LPTSTR szDir, LPTSTR szPat);
DWORD MyGetBinaryType(LPTSTR szFileName);
VOID __cdecl PrintErrorMessage(DWORD dwError, LPTSTR szFmt, ...);

#define FA_DIR(_x)    ((_x) & FILE_ATTRIBUTE_DIRECTORY)

// filever cmd line flags
#define FSTR_RECURSE    0x0001
#define FSTR_VERBOSE    0x0002
#define FSTR_EXESONLY   0x0004
#define FSTR_SHORTNAME  0x0008
#define FSTR_BAREFORMAT 0x0010
#define FSTR_PRINTDIR   0x0020
#define FSTR_NOATTRS    0x0040
#define FSTR_NODATETIME 0x0080
#ifdef DEBUG
#define FSTR_DEBUG      0x8000
#endif

// PrintFileAttr struct
typedef struct _FileAttr
{
    DWORD dwAttr;
    TCHAR ch;
} FileAttr;

// MyGetBinaryType exe type defines
#define NE_UNKNOWN  0x0     /* Unknown (any "new-format" OS) */
#define NE_OS2      0x1     /* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS  0x2     /* Microsoft Windows */
#define NE_DOS4     0x3     /* Microsoft MS-DOS 4.x */
#define NE_DEV386   0x4     /* Microsoft Windows 386 */

// MyGetBinaryType return values
enum {
    // SCS_32BIT_BINARY,
    // SCS_DOS_BINARY,
    // SCS_WOW_BINARY,
    // SCS_PIF_BINARY,
    // SCS_POSIX_BINARY,
    // SCS_OS216_BINARY,
    SCS_32BIT_BINARY_INTEL = SCS_OS216_BINARY + 1,
    SCS_32BIT_BINARY_MIPS,
    SCS_32BIT_BINARY_ALPHA,
    SCS_32BIT_BINARY_PPC,
    SCS_32BIT_BINARY_AXP64,
    SCS_32BIT_BINARY_IA64,
    SCS_32BIT_BINARY_AMD64
};

#define SCS_UNKOWN      (DWORD)-1

static const TCHAR   *szType[] = {
    "W32    ",
    "DOS    ",
    "W16    ",
    "PIF    ",
    "PSX    ",
    "OS2    ",
    "W32i   ",
    "W32m   ",
    "W32a   ",
    "W32p   ",
    "W32a64 ",
    "W32i64 ",
    "WAMD64 "
};

CONST static TCHAR *VersionKeys[] =
{
    TEXT("CompanyName"),
    TEXT("FileDescription"),
    TEXT("InternalName"),
    TEXT("OriginalFilename"),
    TEXT("ProductName"),
    TEXT("ProductVersion"),
    TEXT("FileVersion"),
    TEXT("LegalCopyright"),
    TEXT("LegalTrademarks"),
    TEXT("PrivateBuild"),
    TEXT("SpecialBuild"),
    TEXT("Comments")
};

// languages map
typedef struct _LangTag {
	WORD		wLangId;
	LPSTR		szName;
	LPSTR		szDesc;
	LPSTR		szKey;
} LangTag;

CONST static LangTag ltLang[] =
{
	{0x0406,"Danish","Danish","DAN"},
	{0x0413,"Dutch","Dutch (Standard)","NLD"},
	{0x0813,"Dutch","Belgian (Flemish)","NLB"},
	{0x0409,"English","American","ENU"},
	{0x0809,"English","British","ENG"},
	{0x0c09,"English","Australian","ENA"},
	{0x1009,"English","Canadian","ENC"},
	{0x1409,"English","New Zealand","ENZ"},
	{0x1809,"English","Ireland","ENI"},
	{0x040b,"Finnish","Finnish","FIN"},
	{0x040c,"French","French (Standard)","FRA"},
	{0x080c,"French","Belgian","FRB"},
	{0x0c0c,"French","Canadian","FRC"},
	{0x100c,"French","Swiss","FRS"},
	{0x0407,"German","German (Standard)","DEU"},
	{0x0807,"German","Swiss","DES"},
	{0x0c07,"German","Austrian","DEA"},
	{0x040f,"Icelandic","Icelandic","ISL"},
	{0x0410,"Italian","Italian (Standard)","ITA"},
	{0x0810,"Italian","Swiss","ITS"},
	{0x0414,"Norwegian","Norwegian (Bokmal)","NOR"},
	{0x0814,"Norwegian","Norwegian (Nynorsk)","NON"},
	{0x0416,"Portuguese","Portuguese (Brazilian)","PTB"},
	{0x0816,"Portuguese","Portuguese (Portugal)","PTG"},
	{0x041D,"Swedish","Swedish","SVE"},
	{0x040a,"Spanish","Spanish (Standard/Traditional)","ESP"},
	{0x080a,"Spanish","Mexican","ESM"},
	{0x0c0a,"Spanish","Spanish","ESN"},
	{0x041f,"Turkish","TRK","TRK"},
	{0x0415,"Polish","PLK","PLK"},
	{0x0405,"Czech","CSY","CSY"},
	{0x041b,"Slovak","SKY","SKY"},
	{0x040e,"Hungarian","HUN","HUN"},
	{0x0419,"Russian","RUS","RUS"},
	{0x0408,"Greek","ELL","ELL"},
	{0x0804,"Chinese","CHS","CHS"},
	{0x0404,"Taiwan","CHT","CHT"},
	{0x0411,"Japan","JPN","JPN"},
	{0x0412,"Korea","KOR","KOR"}
};

// languages map
typedef struct _CharSetTag {
	WORD		wCharSetId;
	LPSTR		szDesc;
} CharSetTag;

CONST static CharSetTag ltCharSet[] =
{
	{0, "7-bit ASCII"},
	{932, "Windows, Japan (Shift  JIS X-0208)"},
	{949, "Windows, Korea (Shift  KSC 5601)"},
	{950, "Windows, Taiwan (GB5)"},
	{1200, "Unicode"},
	{1250, "Windows, Latin-2 (Eastern European)"},
	{1251, "Windows, Cyrillic"},
	{1252, "Windows, Multilingual"},
	{1253, "Windows, Greek"},
	{1254, "Windows, Turkish"},
	{1255, "Windows, Hebrew"},
	{1256, "Windows, Arabic"}
};

typedef struct  _ffTypeTag {
    DWORD   dwTypeMask;
    LPSTR   szTypeStr;
    LPSTR   szFullStr;
} TypeTag;

// file flags map

TypeTag  ttFileFlags[]= {
    { VS_FF_DEBUG,       "D",   "debug"},
    { VS_FF_PRERELEASE,  "P",   "prerelease"},
    { VS_FF_PATCHED,     "A",   "patched"},
    { VS_FF_PRIVATEBUILD,"I",   "private"},
    { VS_FF_INFOINFERRED,"F",   "infoInferred"},
    { VS_FF_SPECIALBUILD,"S",   "special"}
};

// file OS map

TypeTag ttFileOsHi[] = {
    { VOS_DOS,          "DOS",  "MS-DOS"},
    { VOS_OS216,        "O16",  "OS2/16"},
    { VOS_OS232,        "O32",  "OS2/32"},
    { VOS_NT,           "NT",   "NT"},
};

TypeTag ttFileOsLo[] = {
    { VOS__WINDOWS16,   "Win16","Win16"},
    { VOS__PM16,        "PM16", "PM16"},
    { VOS__PM32,        "PM32", "PM32"},
    { VOS__WINDOWS32,   "Win32","Win32"}
};

// type map
TypeTag  ttFType[] = {
    { VFT_APP,          "APP",  "App"},
    { VFT_DLL,          "DLL",  "Dll"},
    { VFT_DRV,          "DRV",  "Driver"},
    { VFT_FONT,         "FNT",  "Font"},
    { VFT_VXD,          "VXD",  "VXD"},
    { VFT_STATIC_LIB,   "LIB",  "lib"}
};

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
TypeTag ttFTypeDrv[] = {
	{ VFT2_DRV_PRINTER, "", "PrinterDrv"},
	{ VFT2_DRV_KEYBOARD, "", "KeyBoardDrv"},
	{ VFT2_DRV_LANGUAGE, "", "LangDrv"},
	{ VFT2_DRV_DISPLAY, "", "DisplayDrv"},
	{ VFT2_DRV_MOUSE, "", "MouseDrv"},
	{ VFT2_DRV_NETWORK, "", "NetworkDrv"},
	{ VFT2_DRV_SYSTEM, "", "SystemDrv"},
	{ VFT2_DRV_INSTALLABLE, "", "InstallableDrv"},
	{ VFT2_DRV_SOUND, "", "SoundDrv"},
	{ VFT2_DRV_COMM, "", "CommDrv"}
};

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
TypeTag ttFTypeFont[] = {
	{ VFT2_FONT_RASTER, "", "Raster"},
	{ VFT2_FONT_VECTOR, "", "Vectore"},
	{ VFT2_FONT_TRUETYPE, "", "Truetype"}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\filever\filever.c ===
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>

#include "filever.h"

// command line flags
UINT    fFlags = 0;

VOID
usage(CHAR *szProgName)
{
    puts  ("Prints file version information.\n");
    printf("%s [/S] [/V] [/E] [/X] [/B] [/A] [/D] [[drive:][path][filename]]\n", szProgName);
    puts  ("\n"
           "/S\tDisplays files in specified directory and all subdirectories.\n"
           "/V\tList verbose version information if available.\n"
           "/E\tList executables only.\n"
           "/X\tDisplays short names generated for non-8dot3 file names.\n"
           "/B\tUses bare format (no dir listing).\n"
           "/A\tDon't display file attributes.\n"
           "/D\tDon't display file date and time."
#ifdef DEBUG
           "\n/z\tPrint debug messages."
#endif
          );
}

int __cdecl
main(INT argc, CHAR **argv)
{
    INT     i;
    LPTSTR  szT;
    UINT    cDirs = 0;

    if (argc < 2)
    {
        usage(argv[0]);
        exit(0);
    }

    // Loop through and process all the args
    for(i = 1; i < argc; ++i)
    {
        if(argv[i][0] != '/' && argv[i][0] != '-')
        {
            cDirs++;
            continue;
        }

        for(szT = &argv[i][1]; *szT; ++szT)
        {
            switch(*szT)
            {
#ifdef DEBUG
            case 'z':
                fFlags |= FSTR_DEBUG;
                break;
#endif
            case 'l':
            case 'L':
                // provided for compatability (list format is default now)
                break;
            case 'd':
            case 'D':
                fFlags |= FSTR_NODATETIME;
                break;
            case 'a':
            case 'A':
                fFlags |= FSTR_NOATTRS;
                break;
            case 'b':
            case 'B':
                fFlags |= FSTR_BAREFORMAT;
                break;
            case 'x':
            case 'X':
                fFlags |= FSTR_SHORTNAME;
                break;
            case 'S':
            case 's':
                fFlags |= (FSTR_RECURSE | FSTR_PRINTDIR);
                break;
            case 'V':
            case 'v':
                fFlags |= FSTR_VERBOSE;
                break;
            case 'e':
            case 'E':
                fFlags |= FSTR_EXESONLY;
                break;
            case '?':
            case 'h':
            case 'H':
                usage(argv[0]);
                exit(0);
            default:
                printf("Invalid flag specified: (-%c)\n", *szT);
                usage(argv[0]);
                exit(-1);
            }
        }
    }

#ifdef DEBUG
    if(fFlags & FSTR_DEBUG)
        printf("DBG> Command line dir count: %d\n", cDirs);
#endif

    // If they didn't specify a dir, default to current one
    if(!cDirs)
    {
        argc = 2;
        argv[1] = ".";
    }
    else if(cDirs > 1)
    {
        // turn on dir printing if we have more than one dir
        fFlags |= FSTR_PRINTDIR;
    }

    // if we have bareformat on, turn dir printing off
    if(fFlags & FSTR_BAREFORMAT)
        fFlags &= ~FSTR_PRINTDIR;

    for(i = 1; i < argc; ++i)
    {
        DWORD   dwAttr;
        LPTSTR  szDir = NULL;
        LPTSTR  szPat = NULL;
        TCHAR   szFullPath[MAX_PATH + 1];
        TCHAR   szPattern[MAX_PATH + 1];

        // skip flags
        if(argv[i][0] == '/' || argv[i][0] == '-')
            continue;

        // Grab de dir
        szDir = argv[i];

        // get the full path to our dir
        if(GetFullPathName(szDir, MAX_PATH, szFullPath, &szT)) {
            szDir = szFullPath;
        } else {
            lstrcpy(szFullPath, szDir);
            szDir = szFullPath;
        }

        dwAttr = GetFileAttributes(szDir);

#ifdef NEVER
        // If it's not a directory or -1, assume a single file and flip on verbose
        if(!(fFlags & FSTR_RECURSE) && !FA_DIR(dwAttr))
            fFlags |= FSTR_VERBOSE;
#endif

        // If GetFileAttributes failed or it isn't a directory, grab the pattern
        if((dwAttr == (DWORD)-1) || !FA_DIR(dwAttr))
        {
            for(szT = szDir; *szT; szT++)
            {
                if(*szT == '\\')
                    szPat = szT;
            }

            if(szPat)
                *szPat++ = 0;
        }

        // make sure we have a pattern
        if(!szPat || !*szPat)
            szPat = "*.*";
        lstrcpy(szPattern, szPat);

        FListFiles(szDir, szPattern);
    }

    return 0;
}


BOOL
FListFiles(LPTSTR szDir, LPTSTR szPat)
{
    HANDLE          hf;
    WIN32_FIND_DATA fd;
    UINT            cchDir;
    TCHAR           szFileName[MAX_PATH + 1];
    BOOL            fPrintedDir = !(fFlags & FSTR_PRINTDIR);

#ifdef DEBUG
    if(fFlags & FSTR_DEBUG)
        printf("DBG> FListFiles('%s', '%s')\n", szDir, szPat);
#endif

    // Get short name if that's what they want
    if(fFlags & FSTR_SHORTNAME)
        GetShortPathName(szDir, szDir, MAX_PATH);

    // Get dir length and add trailing '\' if not there
    cchDir = lstrlen(szDir);
    if(szDir[cchDir - 1] != '\\')
    {
        szDir[cchDir++] = '\\';
        szDir[cchDir] = 0;
    }

    // Concat pattern to dir
    CharLower(szDir);
    lstrcpy(szFileName, szDir);
    lstrcpy(&szFileName[cchDir], szPat);

    // list all the files
    hf = FindFirstFile(szFileName, &fd);
    if(hf != INVALID_HANDLE_VALUE)
    {
        do
        {
            DWORD   lBinaryType;
            BOOL    fIsDir = FA_DIR(fd.dwFileAttributes);

            if(fIsDir && (fd.cFileName[0] == '.'))
            {
                // skip . and ..
                if(!fd.cFileName[1] ||
                    ((fd.cFileName[1] == '.') && !fd.cFileName[2]))
                        continue;
            }

            CharLower(fd.cFileName);
            lstrcpy(&szFileName[cchDir], fd.cFileName);

            // get type of file
            lBinaryType = MyGetBinaryType(szFileName);
            if(!(fFlags & FSTR_EXESONLY) || (lBinaryType != SCS_UNKOWN))
            {
                // Print out our dir name
                if(!fPrintedDir)
                {
                    printf("\t%s%s\n", szDir, szPat);
                    fPrintedDir = TRUE;
                }

                // file attributes
                if(!(fFlags & FSTR_NOATTRS))
                    PrintFileAttributes(fd.dwFileAttributes);
                // file type
                PrintFileType(lBinaryType);
                // version
                PrintFileVersion(szFileName);
                // size & date
                if(!(fFlags & FSTR_NODATETIME))
                    PrintFileSizeAndDate(&fd);
                // print file name
                printf(fIsDir ? " [%s%s]\n" : " %s%s\n",
                    fFlags & FSTR_BAREFORMAT ? szDir : "",
                    ((fFlags & FSTR_SHORTNAME) && fd.cAlternateFileName[0]) ?
                    fd.cAlternateFileName : fd.cFileName);

                // print verbose info if this isn't a dir
                // Win95 also craps out on dos files so ignore those too
                if((fFlags & FSTR_VERBOSE) &&
                    (lBinaryType != SCS_UNKOWN) &&
                    (lBinaryType != SCS_DOS_BINARY))
                        GetVersionStuff(szFileName, NULL, NULL);
            }
        } while(FindNextFile(hf, &fd));

        FindClose(hf);
    }

    // dive into all the subdirs
    if(fFlags & FSTR_RECURSE)
    {
        // Concat pattern to dir
        lstrcpy(&szFileName[cchDir], "*.*");

        hf = FindFirstFile(szFileName, &fd);
        if(hf != INVALID_HANDLE_VALUE)
        {
            do
            {
                if(FA_DIR(fd.dwFileAttributes))
                {
                    if(fd.cFileName[0] == '.')
                    {
                        if(!fd.cFileName[1] ||
                            ((fd.cFileName[1] == '.') && !fd.cFileName[2]))
                                continue;
                    }

                    // create new dir name and dive in
                    lstrcpy(&szFileName[cchDir], fd.cFileName);
                    FListFiles(szFileName, szPat);
                }
            } while(FindNextFile(hf, &fd));

            FindClose(hf);
        }
    }

    return TRUE;
}

#define PrintFlagsMap(_structname, _flags) \
    for(iType = 0; iType < sizeof(_structname)/sizeof(TypeTag); iType++) \
    { \
        if((_flags) & _structname[iType].dwTypeMask) \
            printf(" %s", _structname[iType].szFullStr); \
    }

#define PrintFlagsVal(_structname, _flags) \
    for(iType = 0; iType < sizeof(_structname)/sizeof(TypeTag); iType++) \
    { \
        if((_flags) == _structname[iType].dwTypeMask) \
        { \
            printf(" %s", _structname[iType].szFullStr); \
            break; \
        } \
    }

VOID
PrintFixedFileInfo(VS_FIXEDFILEINFO *pvs)
{
    UINT    iType;

    printf("\tVS_FIXEDFILEINFO:\n");
    printf("\tSignature:\t%08.8lx\n", pvs->dwSignature);
    printf("\tStruc Ver:\t%08.8lx\n", pvs->dwStrucVersion);
    printf("\tFileVer:\t%08.8lx:%08.8lx (%d.%d:%d.%d)\n",
        pvs->dwFileVersionMS, pvs->dwFileVersionLS,
        HIWORD(pvs->dwFileVersionMS), LOWORD(pvs->dwFileVersionMS),
        HIWORD(pvs->dwFileVersionLS), LOWORD(pvs->dwFileVersionLS));
    printf("\tProdVer:\t%08.8lx:%08.8lx (%d.%d:%d.%d)\n",
        pvs->dwProductVersionMS, pvs->dwProductVersionLS,
        HIWORD(pvs->dwProductVersionMS), LOWORD(pvs->dwProductVersionMS),
        HIWORD(pvs->dwProductVersionLS), LOWORD(pvs->dwProductVersionLS));

    printf("\tFlagMask:\t%08.8lx\n", pvs->dwFileFlagsMask);
    printf("\tFlags:\t\t%08.8lx", pvs->dwFileFlags);
    PrintFlagsMap(ttFileFlags, pvs->dwFileFlags);

    printf("\n\tOS:\t\t%08.8lx", pvs->dwFileOS);
    PrintFlagsVal(ttFileOsHi, pvs->dwFileOS & 0xffff000);
    PrintFlagsVal(ttFileOsLo, LOWORD(pvs->dwFileOS));

    printf("\n\tFileType:\t%08.8lx", pvs->dwFileType);
    PrintFlagsVal(ttFType, pvs->dwFileType);

    printf("\n\tSubType:\t%08.8lx", pvs->dwFileSubtype);
    if(pvs->dwFileType == VFT_FONT)
    {
        PrintFlagsVal(ttFTypeFont, pvs->dwFileSubtype);
    }
    else if(pvs->dwFileType == VFT_DRV)
    {
        PrintFlagsVal(ttFTypeDrv, pvs->dwFileSubtype);
    }
    printf("\n\tFileDate:\t%08.8lx:%08.8lx\n", pvs->dwFileDateMS, pvs->dwFileDateLS);
}


typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;

/*
 *  [alanau]
 *
 *  MyGetFileVersionInfo: Maps a file directly without using LoadLibrary.  This ensures
 *   that the right version of the file is examined without regard to where the loaded image
 *   is.  Since this is a local function, it allocates the memory which is freed by the caller.
 *   This makes it slightly more efficient than a GetFileVersionInfoSize/GetFileVersionInfo pair.
 */
BOOL
MyGetFileVersionInfo(LPTSTR lpszFilename, LPVOID *lpVersionInfo)
{
    VS_FIXEDFILEINFO  *pvsFFI = NULL;
    UINT              uiBytes = 0;
    HINSTANCE         hinst;
    HRSRC             hVerRes;
    HANDLE            FileHandle = NULL;
    HANDLE            MappingHandle = NULL;
    LPVOID            DllBase = NULL;
    VERHEAD           *pVerHead;
    BOOL              bResult = FALSE;
    DWORD             dwHandle;
    DWORD             dwLength;

    if (!lpVersionInfo)
        return FALSE;

    *lpVersionInfo = NULL;

    FileHandle = CreateFile( lpszFilename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL
                            );
    if (FileHandle == INVALID_HANDLE_VALUE)
        goto Cleanup;

    MappingHandle = CreateFileMapping( FileHandle,
                                        NULL,
                                        PAGE_READONLY,
                                        0,
                                        0,
                                        NULL
                                      );

    if (MappingHandle == NULL)
        goto Cleanup;

    DllBase = MapViewOfFileEx( MappingHandle,
                               FILE_MAP_READ,
                               0,
                               0,
                               0,
                               NULL
                             );
    if (DllBase == NULL)
        goto Cleanup;

    hinst = (HMODULE)((ULONG_PTR)DllBase | 0x00000001);
    __try {

        hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
        if (hVerRes == NULL)
        {
            // Probably a 16-bit file.  Fall back to system APIs.
            if(!(dwLength = GetFileVersionInfoSize(lpszFilename, &dwHandle)))
            {
                if(!GetLastError())
                    SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
                __leave;
            }

            if(!(*lpVersionInfo = GlobalAllocPtr(GHND, dwLength)))
                __leave;

            if(!GetFileVersionInfo(lpszFilename, 0, dwLength, *lpVersionInfo))
                __leave;

            bResult = TRUE;
            __leave;
        }

        pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
        if (pVerHead == NULL)
            __leave;

        *lpVersionInfo = GlobalAllocPtr(GHND, pVerHead->wTotLen + pVerHead->wTotLen/2);
        if (*lpVersionInfo == NULL)
            __leave;

        memcpy(*lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
        bResult = TRUE;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

Cleanup:
    if (FileHandle)
        CloseHandle(FileHandle);
    if (MappingHandle)
        CloseHandle(MappingHandle);
    if (DllBase)
        UnmapViewOfFile(DllBase);
    if (*lpVersionInfo && bResult == FALSE)
        GlobalFreePtr(*lpVersionInfo);

    return bResult;
}


DWORD
GetVersionStuff(LPTSTR szFileName, DWORD *pdwLangRet, VS_FIXEDFILEINFO *pvsRet)
{
    LPVOID              lpInfo;
    TCHAR               key[80];
    DWORD               dwLength;
    LPVOID              lpvData = NULL;
    DWORD               *pdwTranslation;
    UINT                i, iType, cch, uLen;
    VS_FIXEDFILEINFO    *pvs;
    DWORD               dwDefLang = 0x409;

    if(!MyGetFileVersionInfo(szFileName, &lpvData))
        goto err;

    if(!VerQueryValue(lpvData, "\\VarFileInfo\\Translation", &pdwTranslation, &uLen))
    {
        if(!pdwLangRet)
            printf("\t- No \\VarFileInfo\\Translation, assuming %08lx\n", dwDefLang);
        pdwTranslation = &dwDefLang;
        uLen = sizeof(DWORD);
    }

    if(pdwLangRet)
    {
        *pdwLangRet = *pdwTranslation;
        goto fixedfileinfo;
    }

    while(uLen)
    {
        // Language
        printf("\tLanguage\t0x%04x", LOWORD(*pdwTranslation));
        if(VerLanguageName(LOWORD(*pdwTranslation), key, sizeof(key) / sizeof(TCHAR)))
            printf(" (%s)", key);
        printf("\n");

        // CharSet
        printf("\tCharSet\t\t0x%04x", HIWORD(*pdwTranslation));
        for(iType = 0; iType < sizeof(ltCharSet)/sizeof(CharSetTag); iType++)
        {
            if(HIWORD(*pdwTranslation) == ltCharSet[iType].wCharSetId)
                printf(" %s", ltCharSet[iType].szDesc);
        }
        printf("\n");

tryagain:
        wsprintf(key, "\\StringFileInfo\\%04x%04x\\",
            LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));

        lstrcat(key, "OleSelfRegister");
        printf("\t%s\t%s\n", "OleSelfRegister",
            VerQueryValue(lpvData, key, &lpInfo, &cch) ? "Enabled" : "Disabled");

        for(i = 0; i < (sizeof(VersionKeys) / sizeof(VersionKeys[0])); i++)
        {
            wsprintf(key, "\\StringFileInfo\\%04x%04x\\",
                LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));
            lstrcat(key, VersionKeys[i]);

            if(VerQueryValue(lpvData, key, &lpInfo, &cch))
            {
                lstrcpy(key, VersionKeys[i]);
                key[15] = 0;
                printf("\t%s\t%s\n", key, lpInfo);
            }
        }

        // if the Lang is neutral, go try again with the default lang
        // (this seems to work with msspell32.dll)
        if(LOWORD(*pdwTranslation) == 0)
        {
            pdwTranslation = &dwDefLang;
            goto tryagain;
        }

        uLen -= sizeof(DWORD);
        pdwTranslation++;
        printf("\n");
    }

fixedfileinfo:
    if(!VerQueryValue(lpvData, "\\", (LPVOID *)&pvs, &uLen))
        goto err;

    if(pvsRet)
        *pvsRet = *pvs;
    else
        PrintFixedFileInfo(pvs);

err:
    dwLength = GetLastError();
    if(dwLength &&
      (dwLength != ERROR_RESOURCE_DATA_NOT_FOUND) &&
      (dwLength != ERROR_RESOURCE_TYPE_NOT_FOUND) &&
      !pvsRet)
    {
        PrintErrorMessage(dwLength, NULL);
    }

    if(lpvData)
        GlobalFreePtr(lpvData);
    return dwLength;
}

DWORD
MyGetBinaryType(LPTSTR szFileName)
{
    HANDLE              hFile;
    DWORD               cbRead;
    IMAGE_DOS_HEADER    img_dos_hdr;
    PIMAGE_OS2_HEADER   pimg_os2_hdr;
    IMAGE_NT_HEADERS    img_nt_hdrs;
    DWORD               lFileType = SCS_UNKOWN;

    if((hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)) == INVALID_HANDLE_VALUE)
            goto err;

    if(!ReadFile(hFile, &img_dos_hdr, sizeof(img_dos_hdr), &cbRead, NULL))
        goto err;

    if(img_dos_hdr.e_magic != IMAGE_DOS_SIGNATURE)
        goto err;
    lFileType = SCS_DOS_BINARY;

    if(SetFilePointer(hFile, img_dos_hdr.e_lfanew, 0, FILE_BEGIN) == -1)
        goto err;
    if(!ReadFile(hFile, &img_nt_hdrs, sizeof(img_nt_hdrs), &cbRead, NULL))
        goto err;
    if((img_nt_hdrs.Signature & 0xffff) == IMAGE_OS2_SIGNATURE)
    {
        pimg_os2_hdr = (PIMAGE_OS2_HEADER)&img_nt_hdrs;
        switch(pimg_os2_hdr->ne_exetyp)
        {
        case NE_OS2:
            lFileType = SCS_OS216_BINARY;
            break;
        case NE_DEV386:
        case NE_WINDOWS:
            lFileType = SCS_WOW_BINARY;
            break;
        case NE_DOS4:
        case NE_UNKNOWN:
        default:
            // lFileType = SCS_DOS_BINARY;
            break;
        }
    }
    else if(img_nt_hdrs.Signature == IMAGE_NT_SIGNATURE)
    {
        switch(img_nt_hdrs.OptionalHeader.Subsystem)
        {
        case IMAGE_SUBSYSTEM_OS2_CUI:
            lFileType = SCS_OS216_BINARY;
            break;
        case IMAGE_SUBSYSTEM_POSIX_CUI:
            lFileType = SCS_POSIX_BINARY;
            break;
        case IMAGE_SUBSYSTEM_NATIVE:
        case IMAGE_SUBSYSTEM_WINDOWS_GUI:
        case IMAGE_SUBSYSTEM_WINDOWS_CUI:
        default:
            switch(img_nt_hdrs.FileHeader.Machine)
            {
            case IMAGE_FILE_MACHINE_I386:
                lFileType = SCS_32BIT_BINARY_INTEL;
                break;
            case IMAGE_FILE_MACHINE_R3000:
            case IMAGE_FILE_MACHINE_R4000:
                lFileType = SCS_32BIT_BINARY_MIPS;
                break;
            case IMAGE_FILE_MACHINE_ALPHA:
                lFileType = SCS_32BIT_BINARY_ALPHA;
                break;
            case IMAGE_FILE_MACHINE_ALPHA64:
                lFileType = SCS_32BIT_BINARY_AXP64;
                break;
            case IMAGE_FILE_MACHINE_IA64:
                lFileType = SCS_32BIT_BINARY_IA64;
                break;
            case IMAGE_FILE_MACHINE_POWERPC:
                lFileType = SCS_32BIT_BINARY_PPC;
                break;
            case IMAGE_FILE_MACHINE_AMD64:
                lFileType = SCS_32BIT_BINARY_AMD64;
                break;
            default:
            case IMAGE_FILE_MACHINE_UNKNOWN:
                lFileType = SCS_32BIT_BINARY;
                break;
            }
            break;
        }
    }

err:
    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    return lFileType;
}

VOID __cdecl
PrintErrorMessage(DWORD dwError, LPTSTR szFmt, ...)
{
    LPTSTR  szT;
    va_list arglist;
    LPTSTR  szErrMessage = NULL;

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, dwError, 0/*LANG_USER_DEFAULT*/, (LPTSTR)&szErrMessage, 0, NULL);
    if(szFmt && szErrMessage)
    {
        for(szT = szErrMessage; *szT; szT++)
        {
            if(*szT == '\r' || *szT == '\n')
                *szT = 0;
        }
    }

    printf("Error 0x%08lx. %s", dwError, szErrMessage ? szErrMessage : "");

    if(szFmt)
    {
        va_start(arglist, szFmt);
        vprintf(szFmt, arglist);
        va_end(arglist);
    }

    if(szErrMessage)
        LocalFree((HLOCAL)szErrMessage);
}

VOID
PrintFileType(DWORD lBinaryType)
{
    LPCTSTR szFmtFileType = "   - ";

    if(lBinaryType < (sizeof(szType) / sizeof(szType[0])))
        szFmtFileType = szType[lBinaryType];
    printf("%s", szFmtFileType);
}

VOID
PrintFileAttributes(DWORD dwAttr)
{
    DWORD   dwT;
    static const FileAttr attrs[] =
       {{FILE_ATTRIBUTE_DIRECTORY, 'd'},
        {FILE_ATTRIBUTE_READONLY,  'r'},
        {FILE_ATTRIBUTE_ARCHIVE,   'a'},
        {FILE_ATTRIBUTE_HIDDEN,    'h'},
        {FILE_ATTRIBUTE_SYSTEM,    's'} };
    TCHAR   szAttr[(sizeof(attrs) / sizeof(attrs[0])) + 1];

    for(dwT = 0; dwT < (sizeof(attrs) / sizeof(attrs[0])); dwT++)
        szAttr[dwT] = (dwAttr & attrs[dwT].dwAttr) ? attrs[dwT].ch : '-';
    szAttr[dwT] = 0;

    printf("%s ", szAttr);
}

VOID
PrintFileSizeAndDate(WIN32_FIND_DATA *pfd)
{
    FILETIME    ft;
    SYSTEMTIME  st = {0};
    TCHAR       szSize[15];

    szSize[0] = 0;
    if(FileTimeToLocalFileTime(&pfd->ftLastWriteTime, &ft) &&
        FileTimeToSystemTime(&ft, &st))
    {
        TCHAR       szVal[15];
        NUMBERFMT   numfmt = {0, 0, 3, "", ",", 0};

        wsprintf(szVal, "%ld", pfd->nFileSizeLow); //$ SPEED
        GetNumberFormat(GetUserDefaultLCID(), 0, szVal, &numfmt, szSize, 15);
    }

    printf(" %10s %02d-%02d-%02d", szSize, st.wMonth, st.wDay, st.wYear);
}

VOID
PrintFileVersion(LPTSTR szFileName)
{
    VS_FIXEDFILEINFO    vs = {0};
    INT                 iType;
    DWORD               dwLang;
    TCHAR               szBuffer[100];

    dwLang = (DWORD)-1;
    vs.dwFileVersionMS = (DWORD)-1;
    vs.dwFileVersionLS = (DWORD)-1;
    GetVersionStuff(szFileName, &dwLang, &vs);
    dwLang = LOWORD(dwLang);

    szBuffer[0] = 0;
    for(iType = 0; iType < sizeof(ttFType) / sizeof(TypeTag); iType++)
    {
        if(vs.dwFileType == ttFType[iType].dwTypeMask)
        {
            printf("%3.3s ", ttFType[iType].szTypeStr);
            break;
        }
    }
    if(iType == (sizeof(ttFType) / sizeof(TypeTag)))
        printf("  - ");

    for(iType = 0; iType < sizeof(ltLang) / sizeof(LangTag); iType++)
    {
        if(dwLang == ltLang[iType].wLangId)
        {
            printf("%3.3s ", ltLang[iType].szKey);
            break;
        }
    }
    if(iType == (sizeof(ltLang) / sizeof(LangTag)))
        printf("  - ");

    if(vs.dwFileVersionMS != (DWORD)-1)
    {
        wsprintf(szBuffer, "%u.%u.%u.%u %s",
                HIWORD(vs.dwFileVersionMS),
                LOWORD(vs.dwFileVersionMS),
                HIWORD(vs.dwFileVersionLS),
                LOWORD(vs.dwFileVersionLS),
                vs.dwFileFlags & VS_FF_DEBUG ? "dbg" : "shp");
    }
    else
    {
        lstrcpy(szBuffer, "-   -");
    }

    printf(" %18.18s", szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\cli\fsdump.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsdump.cpp

Abstract:

    Main entry point for the fsdump utility

Author:

    Stefan R. Steiner   [ssteiner]        02-17-2000

Revision History:

    ssteiner    08-15-2000
        Fixed bugs:
            154375 - Short name support
            153050 - Better handling of RSS files
            154363 - Dump security descriptor control word
            157042 - Handle the case where hard-link file attributes are stale

    Avinash Pillai	[apillai]		07-29-2002	Added options -o:t, -o:y, -o:f and -o:i
--*/

#include <windows.h>

#include "bsstring.h"
#include "params.h"
#include "direntrs.h"
#include "engine.h"

//
//  Forward defines
//
VOID PrintUsage();
VOID PrintHeaderInformation();

INT ProcessCommandLine( 
    IN INT argc,
    IN WCHAR *argv[],
    OUT CDumpParameters *pcDumpParameters,
    OUT WCHAR **ppwszFileDirSpecList[],
    OUT DWORD *pdwDirSpecListSize
    );
    
/*++

Routine Description:

    The main entry point into the fsdump utility.

Arguments:

Return Value:

    <Enter return values here>

--*/
extern "C" INT __cdecl wmain( 
    IN INT argc, 
    IN WCHAR *argv[] )
{
    BOOL bDebugMode = FALSE;

    try
    {
        INT iRc;
        CDumpParameters cDumpParameters( 0 );
        WCHAR **pwszFileDirSpecList;
        DWORD dwDirSpecListSize;

        //
        //  Process the command line and get back the dump parameters and list
        //  of volumes, directories and files to dump.
        //
        iRc = ::ProcessCommandLine( 
            argc, 
            argv, 
            &cDumpParameters, 
            &pwszFileDirSpecList, 
            &dwDirSpecListSize );
        if ( iRc != 0 )
            return iRc;
        
        bDebugMode = cDumpParameters.m_bPrintDebugInfo;
        
        //
        //  Setup the error log and dump streams
        //
        iRc = cDumpParameters.Initialize( argc, argv );
        if ( iRc != 0 )
            return iRc;
            
        //
        //  Now loop through the list, dumping each.
        //
        for ( DWORD dwIdx = 0; dwIdx < dwDirSpecListSize; ++dwIdx )
        {
            CDumpEngine cEngine( pwszFileDirSpecList[ dwIdx ], cDumpParameters );
            cEngine.PerformDump();
        }

        delete [] pwszFileDirSpecList;
    }
    catch ( HRESULT hr )
    {
        if ( hr == E_OUTOFMEMORY )
            fwprintf( stderr, L"wmain::Out of memory\n" );
        else
            fwprintf( stderr, L"wmain::Unexpected hr exception: 0x%08x\n", hr );
        
        return hr;                        
    }
    catch ( ... )
    {
        fwprintf( stderr, L"ERROR - fsdump::wmain, caught unexpected exception\n" );
    }
    
    if ( bDebugMode )
    {
        fwprintf( stderr, L"Press <enter> to end program...\n" );
        getchar();
    }
    
    return 0;
}

VOID PrintUsage()
{
    fprintf( stdout, 
        "fsdump.exe - File system dump facility - Version 1.3g - 8/23/2000\n"
        "Copyright (c) Microsoft Corporation, 2000.\n\n"
        "fsdump [-dv|-dd[n]|-df] [-f DumpFileName] [-l ErrorLogFileName] [-h]\n"
        "       [-a:XXXX] [-e[r]] [i[a|c|s[d]] [-p] [-t] [-z] [-x]\n"
        "       [-o:[c][d][h][l][m][n][o][s][u][x][z]]\n"
        "       [DirFileSpec [...]]\n"
        "   Note: Options can be before and/or after DirFileSpec entries.\n"
        "         fsdump is mostly useful for NTFS volumes.\n"
        "         fsdump by default dumps in Excel CSV (comma-delimited format) see -o:n\n"
        "\t-dv  - Dump entries in DirFileSpec volume - Default\n"
        "\t       (DirFileSpec format - D: or E:\\xxxx\\MountPoint - no wildcards)\n"
        "\t-dd  - Dump entries in DirFileSpec directory branch\n"
        "\t       (DirFileSpec format - D:\\foo - no wildcard chars)\n"
        "\t-ddn - Dump entries in DirFileSpec directory with no subdir traversal\n"
        "\t       (DirFileSpec format - D:\\foo - no wildcard chars)\n"
        "\t-df  - Dump DirFileSpec file\n"
        "\t       (DirFileSpec format - D:\\foo\\file - no wildcard chars)\n"
        "\t-f   - Dump file name.  If not specified, dumps to stdout\n"
        "\t-l   - Error log file name.  If not specified, dumps to stderr\n"
        "\t-h   - This usage information\n\n"
        "\t-a:  - Specify a hex mask of file attributes to mask in the output\n"
        "\t       The default mask is 00A0 - masks archive and normal attributes\n"
        "\t-e   - Exclude files in dump based on FilesNotToBackup reg key and\n"
        "\t       .exclude files in the same directory as the fsdump executable.\n"
        "\t       Also if the fsdump.exe is on NTFS, a data stream named\n"
        "\t       :ExcludeList will also be checked for existence.  If it exists\n"
        "\t       it too will be read for exclusion rules.\n"
        "\t-er  - Same as -e but does not include the FilesNotToBackup reg keys.\n"
        "\t-ia  - Info about file attribute bits\n"
        "\t-ic  - Info on the column names\n"
        "\t-is  - Info about the security descriptor control word bits\n"
        "\t-isd - Detailed info about the security descriptor control word bits\n"
        "\t-o:  - Output options:\n"
        "\t        c - No file data checksums\n"
        "\t        d - Show directory timestamps\n"
        "\t        f - No Short file names\n"
        "\t        h - Only dumps file info with no header or summary info\n"
        "\t        i - No File system type (applicable only in CSV format)\n"
        "\t        l - Checksum high latency data (HSM migrated data)\n"
        "\t        m - Add millisecs to timestamps (cannot be used in conjunction with 't')\n"
        "\t        n - Dumps entries in an easy to read format instead of CSV\n"
        "\t        o - Enable Object Id extended data checksums\n"
        "\t        s - Convert SIDs to symbolic DOMAIN\\ACCOUNTNAME format\n"
        "\t        t - Exclude secs from timestamps (cannot be used in conjunction with 'm')\n"
        "\t        u - Dump file and error log in Unicode format\n"
        "\t        x - Hexidecimal size values (decimal default)\n"
        "\t        y - No encrypted data checksum\n"
        "\t        z - Disable special handling of certain reparse points\n"
        "\t            (i.e. RSS)\n"
        "\t-p   - Disable long path support (the use of \\\\?\\ in front of paths)\n"
        "\t-t   - Don't traverse mountpoints\n"
        "\t-z   - Print debug information to stdout\n\n" );
}

VOID PrintFileAttributesInformation()
{
    fprintf( stdout, "Information about file attribute types (in hex):\n"
        "\t0001 - Read-only\n"
        "\t0002 - Hidden\n"
        "\t0004 - System\n"
        "\t0010 - Directory\n"
        "\t0020 - Archive - Masked out by fsdump by default\n"
        "\t0040 - Device\n"
        "\t0080 - Normal - Masked out by fsdump by default\n"
        "\t0100 - Temporary\n"
        "\t0200 - Sparse\n"
        "\t0400 - Reparse point\n"
        "\t0800 - Compressed\n"
        "\t1000 - Offline\n"
        "\t2000 - Not content indexed\n"
        "\t4000 - Encrypted\n" );
}

VOID PrintSecDescControlWordInformation(
    IN BOOL bDetailed
    )
{
    if ( bDetailed )
    {
        fprintf( stdout, "Detailed information about the Security Descriptor control word bits (in hex):\n"
            "\t0001 - SE_OWNER_DEFAULTED\n"
            "\t\tIndicates that the SID pointed to by the Owner field was\n"
            "\t\tprovided by a defaulting mechanism rather than explicitly\n"
            "\t\tprovided by the original provider of the security descriptor.\n"
            "\t\tThis may affect the treatment of the SID with respect to\n"
            "\t\tinheritence of an owner.\n"
            "\t0002 - SE_GROUP_DEFAULTED\n"
            "\t\tIndicates that the SID in the Group field was provided by a\n"
            "\t\tdefaulting mechanism rather than explicitly provided by the\n"
            "\t\toriginal provider of the security descriptor.  This may affect\n"
            "\t\tthe treatment of the SID with respect to inheritence of a\n"
            "\t\tprimary group.\n"
            "\t0004 - SE_DACL_PRESENT\n"
            "\t\tIndicates a security descriptor that has a DACL. If this flag\n"
            "\t\tis not set, or if this flag is set and the DACL is NULL, the\n"
            "\t\tsecurity descriptor allows full access to everyone.\n"
            "\t0008 - SE_DACL_DEFAULTED\n"
            "\t\tIndicates that the DACL was provided by a defaulting mechanism\n"
            "\t\trather than explicitly provided by the original provider of the\n"
            "\t\tsecurity descriptor.  This may affect the treatment of the ACL\n"
            "\t\twith respect to inheritence of an ACL. This flag is ignored if\n"
            "\t\tthe SE_DACL_PRESENT flag is not set.\n"
            "\t0010 - SE_SACL_PRESENT\n"
            "\t\tIndicates that the security descriptor contains a system ACL.\n"
            "\t\tIf this flag is set and the SACL is NULL, then an empty (but\n"
            "\t\tpresent) ACL is being specified.\n"
            "\t0020 - SE_SACL_DEFAULTED\n"
            "\t\tIndicates that the SACL was provided by a defaulting mechanism\n"
            "\t\trather than explicitly provided by the original provider of the\n"
            "\t\tsecurity descriptor.  This may affect the treatment of the ACL\n"
            "\t\twith respect to inheritence of an ACL. This flag is ignored if\n"
            "\t\tthe SE_SACL_PRESENT flag is not set.\n"
            "\t0040 - SE_DACL_UNTRUSTED\n"
            "\t\tIndicates that the DACL was not provided by a trusted source\n"
            "\t\tand does not require any editing of compound ACEs.  If this\n"
            "\t\tflag is set and a compound ACE is encountered, the system will\n"
            "\t\tsubstitute known valid SIDs for the server SIDs in the ACEs.\n"
            "\t0080 - SE_SERVER_SECURITY\n"
            "\t\tIndicates that the caller wishes the system to create a Server\n"
            "\t\tACL based on the input ACL, regardess of its source (explicit\n"
            "\t\tor defaulting).  This is done by replacing all of the GRANT\n"
            "\t\tACEs with compound ACEs granting the current server.  This flag\n"
            "\t\tis only meaningful if the subject is impersonating.\n"
            "\t0100 - SE_DACL_AUTO_INHERIT_REQ - Never set, informational only\n"
            "\t\tRequests that the provider for the object protected by the\n"
            "\t\tsecurity descriptor automatically propagate the DACL to\n"
            "\t\texisting child objects. If the provider supports automatic\n"
            "\t\tinheritance, it propagates the DACL to any existing child\n"
            "\t\tobjects, and sets the SE_DACL_AUTO_INHERITED bit in the\n"
            "\t\tsecurity descriptors of the object and its child objects.\n"
            "\t0200 - SE_SACL_AUTO_INHERIT_REQ - Never set, informational only\n"
            "\t\tRequests that the provider for the object protected by the\n"
            "\t\tsecurity descriptor automatically propagate the SACL to\n"
            "\t\texisting child objects. If the provider supports automatic\n"
            "\t\tinheritance, it propagates the SACL to any existing child\n"
            "\t\tobjects, and sets the SE_SACL_AUTO_INHERITED bit in the\n"
            "\t\tsecurity descriptors of the object and its child objects.\n"
            "\t0400 - SE_DACL_AUTO_INHERITED (Win2K and above)\n"
            "\t\tIndicates a security descriptor in which the DACL is set up to\n"
            "\t\tsupport automatic propagation of inheritable ACEs to existing\n"
            "\t\tchild objects. This bit is set only if the automatic\n"
            "\t\tinheritance algorithm has been performed for the object and\n"
            "\t\tits existing child objects.\n"
            "\t0800 - SE_SACL_AUTO_INHERITED (Win2K and above)\n"
            "\t\tIndicates a security descriptor in which the SACL is set up to\n"
            "\t\tsupport automatic propagation of inheritable ACEs to existing\n"
            "\t\tchild objects. This bit is set only if the automatic\n"
            "\t\tinheritance algorithm has been performed for the object and its\n"
            "\t\texisting child objects.\n"
            "\t1000 - SE_DACL_PROTECTED (Win2K and above)\n"
            "\t\tProtects the DACL of the security descriptor from being\n"
            "\t\tmodified by inheritable ACEs.\n"
            "\t2000 - SE_SACL_PROTECTED (Win2K and above)\n"
            "\t\tProtects the SACL of the security descriptor from being\n"
            "\t\tmodified by inheritable ACEs.\n"
            "\t4000 - SE_RM_CONTROL_VALID\n"
            "\t\t???\n"
            "\t8000 - SE_SELF_RELATIVE - This bit is masked out by fsdump\n" 
            "\t\tIndicates a security descriptor in self-relative format with\n"
            "\t\tall the security information in a contiguous block of memory.\n"
            "\t\tIf this flag is not set, the security descriptor is in\n"
            "\t\tabsolute format.\n" );
    }
    else
    {
        fprintf( stdout, "Information about the Security Descriptor control word bits (in hex):\n"
            "\t0001 - SE_OWNER_DEFAULTED\n"
            "\t0002 - SE_GROUP_DEFAULTED\n"
            "\t0004 - SE_DACL_PRESENT\n"
            "\t0008 - SE_DACL_DEFAULTED\n"
            "\t0010 - SE_SACL_PRESENT\n"
            "\t0020 - SE_SACL_DEFAULTED\n"
            "\t0040 - SE_DACL_UNTRUSTED\n"
            "\t0080 - SE_SERVER_SECURITY\n"
            "\t0100 - SE_DACL_AUTO_INHERIT_REQ - Never set, informational only\n"
            "\t0200 - SE_SACL_AUTO_INHERIT_REQ - Never set, informational only\n"
            "\t0400 - SE_DACL_AUTO_INHERITED (Win2K and above)\n"
            "\t0800 - SE_SACL_AUTO_INHERITED (Win2K and above)\n"
            "\t1000 - SE_DACL_PROTECTED (Win2K and above)\n"
            "\t2000 - SE_SACL_PROTECTED (Win2K and above)\n"
            "\t4000 - SE_RM_CONTROL_VALID\n"
            "\t8000 - SE_SELF_RELATIVE - This bit is masked out by fsdump\n" );
    }
}
    
VOID PrintHeaderInformation()
{
    fprintf( stdout, "Information about the column names in the dump:\n" );
    fprintf( stdout, "%s", CDumpEngine::GetHeaderInformation() );
}

INT ProcessCommandLine( 
    IN INT argc,
    IN WCHAR *argv[],
    OUT CDumpParameters *pcDumpParameters,
    OUT WCHAR **ppwszFileDirSpecList[],
    OUT DWORD *pdwDirSpecListSize
    )
{
    pcDumpParameters->m_cwsArgv0 = argv[0];

    if ( argc < 2 )
    {
        PrintUsage();
        return 1;
    }

    *ppwszFileDirSpecList = new LPWSTR[ argc - 1 ];
    if ( *ppwszFileDirSpecList == NULL )  // Prefix #118831
        throw E_OUTOFMEMORY;
    
    *pdwDirSpecListSize = 0;
    
    INT i = 1;
    for ( ; i < argc; ++i )
    {
        if ( argv[ i ][ 0 ] != L'-' && argv[ i ][ 0 ] != L'/' )
        {
            ( *ppwszFileDirSpecList )[ *pdwDirSpecListSize ] = argv[ i ];
            ++*pdwDirSpecListSize;
        }
        else
        {
            ::_wcslwr( argv[ i ] );
            switch ( argv[ i ][ 1 ] )
            {
                case L'd': // type of dump
                    if ( argv[ i ][ 2 ] == L'v' )
                        pcDumpParameters->m_eFsDumpType = eFsDumpVolume;
                    else if ( argv[ i ][ 2 ] == L'd' && argv[ i ][ 3 ] == L'\0' )
                        pcDumpParameters->m_eFsDumpType = eFsDumpDirTraverse;
                    else if ( argv[ i ][ 2 ] == L'd' && argv[ i ][ 3 ] == L'n' )
                        pcDumpParameters->m_eFsDumpType = eFsDumpDirNoTraverse;
                    else if ( argv[ i ][ 2 ] == L'f' )
                        pcDumpParameters->m_eFsDumpType = eFsDumpFile;
                    else
                    {
                        PrintUsage();
                        return 2;
                    }
                    break;
                case L'l': // error log name
                    ++i;
                    if ( i < argc )
                        pcDumpParameters->m_cwsErrLogFileName = argv[ i ];
                    else
                    {
                        PrintUsage();
                        return 3;
                    }
                    break;
                case L'f': // dump file name
                    ++i;
                    if ( i < argc )
                        pcDumpParameters->m_cwsDumpFileName = argv[ i ];
                    else
                    {
                        PrintUsage();
                        return 4;
                    }
                    break;
                case L't':
                    pcDumpParameters->m_bDontTraverseMountpoints = TRUE;
                    break;
                case L'e':
                    pcDumpParameters->m_bUseExcludeProcessor = TRUE;
                    if ( argv[ i ][ 2 ] != L'\0' )
                    {
                        if ( argv[ i ][ 2 ] == L'r' )
                           pcDumpParameters->m_bDontUseRegistryExcludes = TRUE;                        
                        else
                        {
                            PrintUsage();
                            return 5;
                        }
                    }
                    break;
                case L'p':
                    pcDumpParameters->m_bDisableLongPaths = TRUE;
                    break;
                    
                case L'x':  // TEMPORARY
                    pcDumpParameters->m_bEnableSDCtrlWordDump = FALSE;
                    wprintf( L"***** Enabling Secrurity Descriptor Control Word dump****\n" );
                    break;
                    
                case L'z':
                    pcDumpParameters->m_bPrintDebugInfo = TRUE;
                    break;
                case L'a':
                    {
                        if ( argv[ i ][ 2 ] == L'\0' )
                        {
                            PrintFileAttributesInformation();
                            return 11;
                        }
                        if ( argv[ i ][ 2 ] != L':' )
                        {
                            PrintUsage();
                            return 10;
                        }
                        if ( argv[ i ][ 3 ] == L'\0' )
                        {
                            pcDumpParameters->m_dwFileAttributesMask = 0;
                            break;
                        }
                        
                        LPWSTR pwstrEnd;
                        pcDumpParameters->m_dwFileAttributesMask = ( DWORD )::wcstol( &argv[ i ][ 3 ], &pwstrEnd, 16 );
                        if ( pwstrEnd[ 0 ] != L'\0' )
                        {
                            fprintf( stderr, " ERROR - File attributes mask contain non-hex characters\n" );
                            PrintUsage();
                            return 11;
                        }
                    }
                    break;                            
                                            
                case L'o':
                    {
                        if ( argv[ i ][ 2 ] != L':' )
                        {
                            PrintUsage();
                            return 10;
                        }
                        for ( INT j = 3; argv[ i ][ j ] != L'\0'; ++j )
                        {
                            switch ( argv[ i ][ j ] )
                            {
                            case L'c':
                                pcDumpParameters->m_bNoChecksums = TRUE;
                                break;
                            case L'u':
                                pcDumpParameters->m_bUnicode = TRUE;
                                break;
                            case L'x':
                                pcDumpParameters->m_bHex = TRUE;
                                break;
                            case L'l':
                                pcDumpParameters->m_bDontChecksumHighLatencyData = FALSE;
                                break;
                            case L'm':
				    if(!pcDumpParameters->m_bAddSecsToTimestamps)
                                {
					fprintf( stderr, " ERROR - Attempt to add milliseconds to timestamp after excluding seconds from timestamp\n" );
                                	PrintUsage();
                                	return 5;
                                }
                                pcDumpParameters->m_bAddMillisecsToTimestamps = TRUE;
                                break;
                            case L'o':
                                pcDumpParameters->m_bEnableObjectIdExtendedDataChecksums = TRUE;
                                break;
                            case L'd':
                                pcDumpParameters->m_bDontShowDirectoryTimestamps = FALSE;
                                break;
                            case L's':
                                pcDumpParameters->m_bShowSymbolicSIDNames = TRUE;
                                break;
                            case L'e': // legacy
                                pcDumpParameters->m_bDumpCommaDelimited = TRUE;
                                pcDumpParameters->m_bNoHeaderFooter     = TRUE;
                                break;
                            case L'n':
                                pcDumpParameters->m_bDumpCommaDelimited = FALSE;
                                pcDumpParameters->m_bNoHeaderFooter     = FALSE;
                                break;
                            case L'h':
                                pcDumpParameters->m_bNoHeaderFooter = TRUE;
                                break;
                            case L'z':
                                pcDumpParameters->m_bNoSpecialReparsePointProcessing = TRUE;
                                break;
                            case L't':
                                if(pcDumpParameters->m_bAddMillisecsToTimestamps)
                                {
					fprintf( stderr, " ERROR - Attempt to exclude seconds from timestamp after adding milliseconds to timestamp\n" );
                                	PrintUsage();
                                	return 5;
                                }
                                pcDumpParameters->m_bAddSecsToTimestamps = FALSE;
                                break;
                            case L'y':
                                pcDumpParameters->m_bNoEncryptedChecksum = TRUE;
                                break;
                            case L'f':
                                pcDumpParameters->m_bNoShortFileName = TRUE;
                                break;
                            case L'i':
                                pcDumpParameters->m_bNoFileSystemType = TRUE;
                                break;
                            default:
                                PrintUsage();
                                return 5;
                            }
                        }
                    }
                    break;
                case L'c':
                    PrintHeaderInformation();
                    return 20;
                    break;
                case L'i':
                    switch ( argv[ i ][ 2 ] )
                    {
                    case L'a':
                        PrintFileAttributesInformation();                       
                        break;
                    case L'c':
                        PrintHeaderInformation();
                        break;
                    case L's':
                        PrintSecDescControlWordInformation( argv[i ][ 3 ] == L'd' );
                        break;
                    default:
                        PrintUsage();
                        return 22;
                    }
                    return 21;
                    break;
                case L'?':
                case L'h':
                    PrintUsage();
                    return 5;
                    break;
                default:
                    PrintUsage();
                    return 5;
                    break;
            }
        }                    
    }

    if ( *pdwDirSpecListSize == 0 )
    {
        PrintUsage();
        return 6;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\inc\bsfixalloc.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bsfixalloc.h

Abstract:

    Adapted rom MFC fixalloc.h

Author:

    Stefan R. Steiner   [ssteiner]        04-10-2000

Revision History:

--*/

#ifndef __H_BSFIXALLOC_
#define __H_BSFIXALLOC_

// fixalloc.h - declarations for fixed block allocator

#pragma pack(push, 8)

struct CBsPlex     // warning variable length structure
{
	CBsPlex* pNext;
	DWORD dwReserved[1];    // align on 8 byte boundary
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CBsPlex* PASCAL Create(CBsPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// CBsFixedAlloc

class CBsFixedAlloc
{
// Constructors
public:
	CBsFixedAlloc(UINT nAllocSize, UINT nBlockSize = 64);

// Attributes
	UINT GetAllocSize() { return m_nAllocSize; }

// Operations
public:
	void* Alloc();  // return a chunk of memory of nAllocSize
	void Free(void* p); // free chunk of memory returned from Alloc
	void FreeAll(); // free everything allocated from this allocator

// Implementation
public:
	~CBsFixedAlloc();

protected:
	struct CNode
	{
		CNode* pNext;   // only valid when in free list
	};

	UINT m_nAllocSize;  // size of each block from Alloc
	UINT m_nBlockSize;  // number of blocks to get at a time
	CBsPlex* m_pBlocks;   // linked list of blocks (is nBlocks*nAllocSize)
	CNode* m_pNodeFree; // first free node (NULL if no free nodes)
	CRITICAL_SECTION m_protect;
};

#ifndef _DEBUG

// DECLARE_FIXED_ALLOC -- used in class definition
#define DECLARE_FIXED_ALLOC(class_name) \
public: \
	void* operator new(size_t size) \
	{ \
		ASSERT(size == s_alloc.GetAllocSize()); \
		UNUSED(size); \
		return s_alloc.Alloc(); \
	} \
	void* operator new(size_t, void* p) \
		{ return p; } \
	void operator delete(void* p) { s_alloc.Free(p); } \
	void* operator new(size_t size, LPCSTR, int) \
	{ \
		ASSERT(size == s_alloc.GetAllocSize()); \
		UNUSED(size); \
		return s_alloc.Alloc(); \
	} \
protected: \
	static CBsFixedAlloc s_alloc \

// IMPLEMENT_FIXED_ALLOC -- used in class implementation file
#define IMPLEMENT_FIXED_ALLOC(class_name, block_size) \
CBsFixedAlloc class_name::s_alloc(sizeof(class_name), block_size) \

#else //!_DEBUG

#define DECLARE_FIXED_ALLOC(class_name)     // nothing in debug
#define IMPLEMENT_FIXED_ALLOC(class_name, block_size)   // nothing in debug

#endif //!_DEBUG

#endif // __H_BSFIXALLOC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\inc\direntrs.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    direntrs.h

Abstract:

    Definition of the directory entries class.  Given a path to a directory, 
    creates two linked lists, one a list of all sub-directories (including 
    mountpoints) and another a list of non-directories.


Author:

    Stefan R. Steiner   [ssteiner]        02-21-2000

Revision History:

--*/

#ifndef __H_DIRENTRS_
#define __H_DIRENTRS_

#pragma once

#include "vs_list.h"

//
//  The structure filled in per file/dir.
//  
//
struct SDirectoryEntry
{
    CBsString &GetFileName() { return m_cwsFileName; }
    CBsString &GetShortName() { return m_cwsShortName; }
    
    CBsString m_cwsFileName;
    CBsString m_cwsShortName;
    WIN32_FILE_ATTRIBUTE_DATA m_sFindData;
};

//
//  The linked list iterator type definition
//
typedef CVssDLListIterator< SDirectoryEntry * > CDirectoryEntriesIterator;

//
//  Class: CDirectoryEntries
//
class CDirectoryEntries
{
public:
    CDirectoryEntries(
        IN CDumpParameters *pcDumpParameters,        
        IN const CBsString& cwsDirPath
        );
    
    virtual ~CDirectoryEntries();

    CDirectoryEntriesIterator *GetDirListIterator() 
    { 
        CVssDLListIterator< SDirectoryEntry * > *pcListIter;
        pcListIter = new CDirectoryEntriesIterator( m_cDirList );
        if ( pcListIter == NULL )  // fix future prefix bug
            throw E_OUTOFMEMORY;
        
        return pcListIter;
    }
    
    CDirectoryEntriesIterator *GetFileListIterator() 
    { 
        CVssDLListIterator< SDirectoryEntry * > *pcListIter;
        pcListIter = new CDirectoryEntriesIterator( m_cFileList );
        if ( pcListIter == NULL )  // fix future prefix bug
            throw E_OUTOFMEMORY;
        
        return pcListIter;
    }
    
private:
    DWORD GetDirectoryEntries();

    CBsString m_cwsDirPath;
    CVssDLList< SDirectoryEntry * > m_cDirList;
    CVssDLList< SDirectoryEntry * > m_cFileList;    
    CDumpParameters *m_pcParams;
};

#endif // __H_DIRENTRS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\inc\exclproc.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    exclproc.h

Abstract:

    Exclude processing mechanism.  Processes the FilesNotToBackup key and
    zero or more exclude files with exclude rules.

Author:

    Stefan R. Steiner   [ssteiner]        03-21-2000

Revision History:

--*/

#ifndef __H_EXCLPROC_
#define __H_EXCLPROC_

#define FSD_REG_EXCLUDE_PATH L"SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup"

struct SFsdVolumeId;

//
//  Structure definition of one exclude rule
//
class SFsdExcludeRule
{
public:
    CBsString cwsExcludeFromSource; // File name or key name
    CBsString cwsExcludeDescription;    //  Description of the exclusion rule
    CBsString cwsExcludeRule;   // The actual exclude pattern    
    
    // Compiled match string fields follow:
    BOOL      bInvalidRule; //  If TRUE, rule was deemed invalid by pattern compiler
    BOOL      bAnyVol;  //  If TRUE, matches any volume in the system
    SFsdVolumeId *psVolId;    //  If bAnyVol is FALSE, volid of the file system
    CBsString cwsDirPath;   //  Directory path relative to volume mountpoint (no \ at start of string, \ at end of string)
    CBsString cwsFileNamePattern;   //  File name pattern; may include * and ? chars (no \ at start of string)
    BOOL    bInclSubDirs;   //  If TRUE, include subdirectories under cwsDirPath
    BOOL    bWCInFileName;  //  If TRUE, Wildcard chars in the file name
    CVssDLList< CBsString > cExcludedFileList;  //  List of files excluded by this rule
    
    SFsdExcludeRule() : bAnyVol( FALSE ),
                        bInclSubDirs( FALSE ),
                        bWCInFileName( FALSE ),
                        psVolId( NULL ),
                        bInvalidRule( FALSE ) {}
    virtual ~SFsdExcludeRule();
    
    VOID PrintRule(
        IN FILE *fpOut,
        IN BOOL bInvalidRulePrint
        );
};

class CFsdFileSystemExcludeProcessor;

//
//  Class that maintains the complete list of exclusion rules.  There should be one of
//  these objects per base mountpoint.  This object will manage mountpoints within that
//  mountpoint.  
//
class CFsdExclusionManager
{
public:
    CFsdExclusionManager(
        IN CDumpParameters *pcDumpParameters
        );
    
    virtual ~CFsdExclusionManager();

    VOID GetFileSystemExcludeProcessor(
        IN CBsString cwsVolumePath,
        IN SFsdVolumeId *psVolId,
        OUT CFsdFileSystemExcludeProcessor **ppcFSExcludeProcessor
        );

    VOID PrintExclusionInformation();
    
private:
    VOID ProcessRegistryExcludes( 
        IN HKEY hKey,
        IN LPCWSTR pwszFromSource
        );
    
    VOID ProcessExcludeFiles( 
        IN const CBsString& cwsPathToExcludeFiles
        );
    
    BOOL ProcessOneExcludeFile(
        IN const CBsString& cwsExcludeFileName
        );
    
    VOID CompileExclusionRules();
    
    CDumpParameters *m_pcParams;
    CVssDLList< SFsdExcludeRule * > m_cCompleteExcludeList;  // pointers cleaned up in destructor
};

//
//  Class that maintains the list of exclusion rules for one particular file system.
//
class CFsdFileSystemExcludeProcessor
{
friend class CFsdExclusionManager;

public:
    CFsdFileSystemExcludeProcessor(
        IN CDumpParameters *pcDumpParameters,
        IN const CBsString& cwsVolumePath,
        IN SFsdVolumeId *psVolId
        );
    
    virtual ~CFsdFileSystemExcludeProcessor();

    BOOL IsExcludedFile(
        IN const CBsString &cwsFullDirPath,
        IN DWORD dwEndOfVolMountPointOffset,
        IN const CBsString &cwsFileName
        );
    
private:
    CDumpParameters *m_pcParams;
    CBsString m_cwsVolumePath;
    SFsdVolumeId *m_psVolId;
    CVssDLList< SFsdExcludeRule * > m_cFSExcludeList;            
};

#endif // __H_EXCLPROC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\inc\params.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    params.h

Abstract:

    Header of class that manages the dump parameters.

Author:

    Stefan R. Steiner   [ssteiner]        02-18-2000

Revision History:

    Avinash Pillai	[apillai]		07-29-2002	Added options -o:t, -o:y, -o:f and -o:i

--*/

#ifndef __H_PARAMS_
#define __H_PARAMS_

#define FSD_MAX_PATH ( 8 * 1024 )

enum EFsDumpType
{
    eFsDumpVolume = 1,
    eFsDumpDirTraverse,
    eFsDumpDirNoTraverse,
    eFsDumpFile,
    eFsDump_Last
};

#define FSDMP_DEFAULT_MASKED_ATTRIBS ( FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL )
//
//  The dump parameters and methods to write to the dump file and error log
//  file.
//
class CDumpParameters
{
public:
    //  Set up defaults for the parameters
    CDumpParameters(
        IN DWORD dwReserved
        ) : m_eFsDumpType( eFsDumpVolume ),
            m_fpErrLog( stderr ),
            m_fpDump( stdout ),
            m_fpExtraInfoDump( stdout ),
            m_bNoChecksums( FALSE ),
            m_bNoEncryptedChecksum (FALSE),	//Added by apillai
            m_bHex( FALSE ),
            m_bDontTraverseMountpoints( FALSE ),
            m_bDontChecksumHighLatencyData( TRUE ),
            m_bNoSpecialReparsePointProcessing( FALSE ),
            m_bAddMillisecsToTimestamps( FALSE ),
            m_bAddSecsToTimestamps(TRUE),			//Added by apillai
            m_bDontShowDirectoryTimestamps( TRUE ),
            m_bUnicode( FALSE),
            m_bNoHeaderFooter( TRUE ),
            m_bDumpCommaDelimited( TRUE ),
            m_bUseExcludeProcessor( FALSE ),
            m_bDontUseRegistryExcludes( FALSE ),
            m_bPrintDebugInfo( FALSE ),
            m_bHaveSecurityPrivilege( TRUE ),
            m_dwFileAttributesMask( FSDMP_DEFAULT_MASKED_ATTRIBS ),
            m_bDisableLongPaths( FALSE ),
            m_bEnableSDCtrlWordDump( TRUE ),
            m_bEnableObjectIdExtendedDataChecksums( FALSE ),
            m_bShowSymbolicSIDNames( FALSE ),
            m_bNoShortFileName(FALSE),
            m_bNoFileSystemType(FALSE) { ; }

    virtual ~CDumpParameters();

    WCHAR       m_pwszULongHexFmt[16];  // Checksum printf style format
    EFsDumpType m_eFsDumpType;
    CBsString   m_cwsErrLogFileName;
    CBsString   m_cwsDumpFileName;
    CBsString   m_cwsArgv0;
    CBsString   m_cwsFullPathToEXE;
    BOOL        m_bNoChecksums;
    BOOL	      m_bNoEncryptedChecksum;
    BOOL        m_bUnicode;
    BOOL        m_bHex;
    BOOL        m_bDontTraverseMountpoints;
    BOOL        m_bDontChecksumHighLatencyData;
    BOOL        m_bNoSpecialReparsePointProcessing;
    BOOL        m_bAddMillisecsToTimestamps;
    BOOL	      m_bAddSecsToTimestamps;
    BOOL        m_bDontShowDirectoryTimestamps;
    BOOL        m_bShowSymbolicSIDNames;
    BOOL        m_bNoHeaderFooter;
    BOOL        m_bDumpCommaDelimited;
    BOOL        m_bUseExcludeProcessor;
    BOOL        m_bDontUseRegistryExcludes;
    BOOL        m_bPrintDebugInfo;
    BOOL        m_bDisableLongPaths;
    BOOL        m_bHaveSecurityPrivilege;
    BOOL        m_bEnableObjectIdExtendedDataChecksums;
    BOOL        m_bEnableSDCtrlWordDump;    //  This is a temporary flag
    BOOL	      m_bNoShortFileName;
    BOOL	      m_bNoFileSystemType;
    
    DWORD       m_dwFileAttributesMask;

    INT
    Initialize(
        IN INT argc,
        IN WCHAR *argv[]
        );

    //  Adds a wprintf style string to the error log file, automatically puts
    //  a CR-LF at the end of each line
    inline VOID ErrPrint(
        IN LPCWSTR pwszMsgFormat,
        IN ...
        )
    {
        ::fwprintf( m_fpErrLog, L"  *** ERROR: " );
        va_list marker;
        va_start( marker, pwszMsgFormat );
        ::vfwprintf( m_fpErrLog, pwszMsgFormat, marker );
        va_end( marker );
        ::fwprintf( m_fpErrLog, m_bUnicode ? L"\r\n" : L"\n" );
    }

    //  Adds a wprintf style string to the dump file, automatically puts
    //  a CR-LF at the end of each line
    inline VOID DumpPrintAlways(
        IN LPCWSTR pwszMsgFormat,
        IN ...
        )
    {
        va_list marker;
        va_start( marker, pwszMsgFormat );
        ::vfwprintf( m_fpDump, pwszMsgFormat, marker );
        va_end( marker );
        ::fwprintf( m_fpDump, m_bUnicode ? L"\r\n" : L"\n" );
    }

    inline VOID DumpPrint(
        IN LPCWSTR pwszMsgFormat,
        IN ...
        )
    {
        if ( m_fpExtraInfoDump != NULL )
        {
            va_list marker;
            va_start( marker, pwszMsgFormat );
            ::vfwprintf( m_fpExtraInfoDump, pwszMsgFormat, marker );
            va_end( marker );
            ::fwprintf( m_fpExtraInfoDump, m_bUnicode ? L"\r\n" : L"\n" );
        }
    }

    inline FILE *GetDumpFile() { return m_fpExtraInfoDump; }
    inline FILE *GetDumpAlwaysFile() { return m_fpDump; }
    inline FILE *GEtErrLogFile() { return m_fpErrLog; }

private:
    CDumpParameters() {}   //  Disallow copying
    FILE *m_fpErrLog;
    FILE *m_fpDump;
    FILE *m_fpExtraInfoDump;
};

#endif // __H_PARAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\inc\vs_hash.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bshash.h

Abstract:

    Template for a hash table class.

Author:

    Stefan R. Steiner   [SSteiner]      1-Mar-1998

Revision History:

    3/9/2000    SSteiner    Converted it for use with fsdump
	10/27/1999	aoltean		Took it from bscommon and remove the critical section.

--*/


#ifndef _H_BS_HASH_
#define _H_BS_HASH_

#define BSHASHMAP_NO_ERROR 0
#define BSHASHMAP_ALREADY_EXISTS 1
#define BSHASHMAP_OUT_OF_MEMORY 2
//
//  Forward defines
//

template< class KeyType, class ValueType > class TBsHashMapBucket;
template< class KeyType, class ValueType > class TBsHashMapBucketElem;

//
//  The equality test
//
inline BOOL AreKeysEqual( const PSID& lhK, const PSID& rhK )
{
    return ( ::EqualSid( lhK, rhK ) );
}

inline BOOL AreKeysEqual( const LPCWSTR& lhK, const LPCWSTR& rhK ) 
{ 
    return (::wcscmp(lhK, rhK) == 0); 
}

template < class KeyType >
inline BOOL AreKeysEqual( const KeyType& lhK, const KeyType& rhK ) 
{ 
    return ( ::memcmp( &lhK, &rhK, sizeof KeyType ) == 0 );
//    return lhK == rhK; 
}

//
//  Some possible hash table sizes
//
#define BSHASHMAP_HUGE 65521
#define BSHASHMAP_LARGE 4091
#define BSHASHMAP_MEDIUM 211
#define BSHASHMAP_SMALL 23

//
//  template< class KeyType, class ValueType > class bshashmap
//
//  TBsHashMap template.  Uses a hash table to maintain a mapping of KeyType
//  keys to ValueType values.
//
//template < class KeyType, class ValueType > typedef TBsHashMapBucketElem< KeyType, ValueType > ElemType;

/*
Hash table class. methods hash the key value to the correct bucket, the bucket
class methods then operate on the element list associated with the bucket.
*/
template < class KeyType, class ValueType >
class TBsHashMap 
{
public:
    typedef LONG ( *PFN_HASH_FUNC )( const KeyType& Key, LONG NumBuckets );
    typedef TBsHashMapBucket< KeyType, ValueType > BucketType;
    typedef TBsHashMapBucketElem< KeyType, ValueType > ElemType;

    TBsHashMap( LONG NumBuckets = BSHASHMAP_SMALL, PFN_HASH_FUNC pfHashFunc = DefaultHashFunc )
        : m_pfHashFunc( pfHashFunc ), 
          m_cNumBuckets( NumBuckets ), 
          m_cNumElems( 0 ) 
    { 
        m_pHashTab = new BucketType [ m_cNumBuckets ];
        if ( m_pHashTab == NULL ) {
            m_cNumBuckets = 0;
            throw E_OUTOFMEMORY;    // fix future prefix bug
        }
        m_pElemEnum = NULL;
        m_bInEnum = FALSE;
    }
    
    virtual ~TBsHashMap() 
    {
                

        Unlock();  // unlock the CS from either StartEnum() or TryEnterCriticalSection()

        //
		// First go through the double-linked list and delete all of the elements
		//

        for ( ElemType *pElem = m_ElemChainHead.m_pForward, *pNextElem = pElem->m_pForward;
              pElem != &m_ElemChainHead;
              pElem = pNextElem, pNextElem = pNextElem->m_pForward )
            delete pElem;
        delete [] m_pHashTab;
    }

    //  Clear all entries
    void Clear() 
    {
        if ( m_cNumElems == 0 )
            return; // no work to do
        Lock();
        for ( ElemType *pElem = m_ElemChainHead.m_pForward, *pNextElem = pElem->m_pForward;
              pElem != &m_ElemChainHead;
              pElem = pNextElem, pNextElem = pNextElem->m_pForward )
            delete pElem;
        delete [] m_pHashTab;
        m_pHashTab = new BucketType [ m_cNumBuckets ];
        if ( m_pHashTab == NULL ) {
            m_cNumBuckets = 0;
            throw E_OUTOFMEMORY;    // fix future prefix bug
        }
        m_pElemEnum = NULL;
        m_cNumElems = 0;
        Unlock();
    }

    // returns:
    //   BSHASHMAP_NO_ERROR - successful completion
    //   BSHASHMAP_OUT_OF_MEMORY - out of memory
    //   BSHASHMAP_ALREADY_EXISTS - Key already exists in map.  Old value is
    //       replaced by passed in Value.
    
	LONG Insert( 
	    IN const KeyType& Key, 
	    IN const ValueType& Value,
	    OUT void **ppCookie = NULL
	    ) 
	{
        Lock();
        LONG status;
        LONG hashVal = (*m_pfHashFunc)( Key, m_cNumBuckets );

        assert( hashVal % m_cNumBuckets == hashVal );

        status = m_pHashTab[ hashVal ].Insert( Key, Value, &m_ElemChainHead );

        if ( status == BSHASHMAP_NO_ERROR ) {
            ++m_cNumElems;
            if ( ppCookie != NULL )
                *ppCookie = ( void * )m_ElemChainHead.m_pBackward;
        }
        Unlock();
        return status;
    }

    // Erase an entry. Returns TRUE if it succeeds.
    BOOL Erase( const KeyType& Key ) 
    {
        Lock();
        BOOL erased = FALSE;
        LONG hashVal = (*m_pfHashFunc)( Key, m_cNumBuckets );
        
        assert( hashVal % m_cNumBuckets == hashVal );

        erased = m_pHashTab[ hashVal ].Erase( Key, &m_ElemChainHead );
        if ( erased ) {
            --m_cNumElems;
        }
        Unlock();
        return erased;
    }

    // Erase by cookie
    BOOL EraseByCookie( void *pCookie ) 
    {
        Lock();
        
        BucketType::EraseElement( ( ElemType *)pCookie );
        --m_cNumElems;
        
        Unlock();
        return TRUE;
    }
   
    // Find an entry.  Returns TRUE if it succeeds.  pValue may be NULL, in
    // which case this method is just a test of existence
    BOOL Find( const KeyType& Key, ValueType *pValue = NULL ) 
    {
        Lock();
        ElemType *pElem;
        LONG hashVal = (*m_pfHashFunc)( Key, m_cNumBuckets );
        BOOL found = FALSE;

        assert( hashVal % m_cNumBuckets == hashVal );

        found = m_pHashTab[ hashVal ].Find( Key, &pElem );
        if ( found && pValue != NULL ) {
            *pValue = pElem->m_Value;
        }
        Unlock();
        return found;
    }

    // Find an entry and return a pointer to the value to allow inplace update.  The
    // caller must call Unlock() when finished with the Value item.  If the item is
    // not found, this method returns FALSE and hash table is not locked.
    BOOL FindForUpdate( const KeyType& Key, ValueType **ppValue ) 
    {
        Lock();
        ElemType *pElem;
        LONG hashVal = (*m_pfHashFunc)( Key, m_cNumBuckets );
        BOOL found = FALSE;

        assert( hashVal % m_cNumBuckets == hashVal );

        found = m_pHashTab[ hashVal ].Find( Key, &pElem );
        if ( found ) {
            *ppValue = &(pElem->m_Value);
        } else
            Unlock();   //  Item not found so unlock the table
        return found;
    }

    // Default hash function
    static LONG DefaultHashFunc( const KeyType &Key, LONG NumBuckets ) 
    {
        const BYTE *pByteKey = (BYTE *)&Key;
        LONG dwHashVal = 0;
    
        for ( LONG i = 0; i < sizeof KeyType; ++i ) {
            dwHashVal += pByteKey[i];
        }
//        wprintf( L"Key: dwSerialNum: %u, hashed to: %u\n", Key.m_dwVolSerialNumber, dwHashVal % NumBuckets );
        // cout << "Key: " << Key << " hashed to: " << dwHashVal % NumBuckets << endl;
        return dwHashVal % NumBuckets;
    }

    // Start enumerating all entries in the hash table. Always returns TRUE.
	// Sets the index to the first element in the list. Lock() calls 
	// EnteringCriticalSection.
    BOOL StartEnum() 
    {
        assert( m_bInEnum == FALSE );
        Lock(); // Enumerating the table locks out all other threads
        m_pElemEnum = m_ElemChainHead.m_pForward; // Start at the head of the double-linked list
        m_bInEnum = TRUE;
        return TRUE;
    }

    // Returns the value of the current entry, and then moves the index
	// to the next item in the list. Must call StartEnum() first.
    BOOL GetNextEnum( KeyType *pKey, ValueType *pValue ) 
    {
        assert( m_bInEnum == TRUE );
        if ( m_pElemEnum == &m_ElemChainHead )
            return FALSE;  // Finished enumerating
        *pKey       = m_pElemEnum->m_Key;
        *pValue     = m_pElemEnum->m_Value;
        m_pElemEnum = m_pElemEnum->m_pForward;
        return TRUE;
    }

    // End enumerating the table.  This function must be called when finished, 
	// otherwise other threads will not be able to get past the critical section,
	// because the Unlock() call below, calls LeavingCriticalSection().
    BOOL EndEnum() 
    {
        assert( m_bInEnum == TRUE );
        m_pElemEnum = NULL;
        m_bInEnum = FALSE;
        Unlock();
        return TRUE;
    }

    LONG Size() 
    { 
        return m_cNumElems; 
    }
    
    LONG NumBuckets() 
    { 
        return m_cNumBuckets; 
    }
    
    inline void Lock() 
    { 
    }
    
    inline void Unlock() 
    { 
    }

private:
    BucketType *m_pHashTab;
    LONG m_cNumBuckets;
    LONG m_cNumElems;
    ElemType m_ElemChainHead;  // head of double-linked list of all elements
    ElemType *m_pElemEnum; // Current position of the enumeration
    BOOL m_bInEnum; // true StartEnum() was called and EndEnum() hasn't
    PFN_HASH_FUNC m_pfHashFunc;
};

/* 
Hash bucket class. Methods operate on the element list associated with the hash bucket
*/
template < class KeyType, class ValueType >
class TBsHashMapBucket {
    friend class TBsHashMap< KeyType, ValueType >;

private:
    typedef TBsHashMapBucketElem< KeyType, ValueType > ElemType;
    TBsHashMapBucket( )
    { 
        m_pHead = NULL; // done here to allow for easier debugging
    }
    
    virtual ~TBsHashMapBucket( ) 
    { 
        ; 
    }  // -- not really needed; however, if commented out, memory exception occurs during destruction
    
	
	/*
	Adds an element to the hash table. If the Key for the new element already 
	exists, in the table, set the key's vvalue to this new value, in the table.
	*/
	LONG Insert( const KeyType &Key, const ValueType &Val, ElemType *pElemChainHead ) 
	{        
		ElemType *pElem;
        
		//
		// if the element exists in this hash bucket's element list, set the new value
		//
		
		if ( Find( Key, &pElem ) == TRUE ) {
            pElem->m_Value = Val;
            return BSHASHMAP_ALREADY_EXISTS;
        }
        
		//
		// if the element doesn't exist, create a new element
		//

        ElemType *pVal = new ElemType( Key, Val );
        if ( pVal == NULL ) {
            return BSHASHMAP_OUT_OF_MEMORY;
        }
        
		//
		// Add the element into the hash bucket list
		//

        if ( m_pHead != NULL )
            m_pHead->m_ppPrevious = &(pVal->m_pNext);
        pVal->m_pNext      = m_pHead;
        m_pHead            = pVal;
        pVal->m_ppPrevious = &m_pHead;
        
		//
		// Set the back pointer -  double-linked list of elements
		//

        pVal->m_pBackward = pElemChainHead->m_pBackward;
        pVal->m_pForward  = pElemChainHead;
        pVal->m_pBackward->m_pForward  = pVal;
        pElemChainHead->m_pBackward = pVal;
        return BSHASHMAP_NO_ERROR;
    }

	/*
	Deletes an element from this hash bucket's list, within the hash table. 
	*/
    BOOL Erase( const KeyType &Key, ElemType *pElemChainHead ) 
    {
		//
		// Walk the list of elements for this hash bucket
		//

        for ( ElemType *pElem = m_pHead; pElem != NULL; pElem = pElem->m_pNext ) {
            
			//
			// if the key is found, delete it from the hash bucket's list.
			//
			
			if ( AreKeysEqual( pElem->m_Key, Key ) ) {
			    EraseElement( pElem );
                return TRUE;
            }
        }
        return FALSE;
    }

    /*
    Erases one element from the two chains
    */
    inline static void EraseElement( ElemType *pElem )
    {
        assert( pElem->IsValid() );
        
        // remove it from the hash chain
        if ( pElem->m_pNext != NULL )
            pElem->m_pNext->m_ppPrevious = pElem->m_ppPrevious;
        *( pElem->m_ppPrevious ) = pElem->m_pNext;

        // remove it from the double-linked list of elements
        pElem->m_pBackward->m_pForward = pElem->m_pForward;
        pElem->m_pForward->m_pBackward = pElem->m_pBackward;
        delete pElem;
    }
    
	/*
	Looks for an element in the list associated with this hash bucket. 
	*/
    BOOL Find( const KeyType &Key, ElemType **ppElemFound ) 
    {
		//
		// Walk the list for this bucket, looking for the key.
		//

        for ( ElemType *pElem = m_pHead; pElem != NULL; pElem = pElem->m_pNext ) {
            if ( AreKeysEqual( pElem->m_Key,  Key ) ) {
                *ppElemFound = pElem;
                return TRUE;
            }
        }
        *ppElemFound = NULL;
        return FALSE;
    }

private:
    ElemType *m_pHead;    
};

//
//  template< class KeyType, class ValueType > class TBsHashMapBucketElem
//
//  Template for individual elements in a bucket of a CMap
//
#define BS_HASH_ELEM_SIGNATURE "ELEMTYPE"
#define BS_HASH_ELEM_SIGNATURE_LEN 8

template< class KeyType, class ValueType >
class TBsHashMapBucketElem {
    friend class TBsHashMapBucket< KeyType, ValueType >;
    friend class TBsHashMap< KeyType, ValueType >;

private:
    typedef TBsHashMapBucketElem< KeyType, ValueType > ElemType;

    TBsHashMapBucketElem() : m_ppPrevious( NULL ),
                            m_pNext( NULL )
    {
        m_pForward  = this;
        m_pBackward = this;
    }

    TBsHashMapBucketElem( const KeyType K, const ValueType V ) : m_Key( K ), m_Value( V )
    { 
#ifdef _DEBUG
        memcpy( m_sSignature, BS_HASH_ELEM_SIGNATURE, sizeof( m_sSignature ) / sizeof( char ) );
#endif       
    }

    BOOL
    IsValid()
    {
        assert( this != NULL );
#ifdef _DEBUG
        return( memcmp( m_sSignature, BS_HASH_ELEM_SIGNATURE, sizeof( m_sSignature ) / sizeof( char ) ) == 0 );
#else
        return TRUE;
#endif  
    }
    
    virtual ~TBsHashMapBucketElem() 
    { 
#ifdef _DEBUG   // make sure reuse of list will cause errors
        m_pNext     = NULL;
        m_pForward  = NULL;
        m_pBackward = NULL;
        memset( m_sSignature, 0xAA, sizeof( m_sSignature ) / sizeof( char ) );
#endif
    }

#ifdef _DEBUG
    char       m_sSignature[BS_HASH_ELEM_SIGNATURE_LEN];
#endif
    ElemType **m_ppPrevious; // pointer to previous reference
    ElemType  *m_pNext;      // pointer to next element in bucket
    ElemType  *m_pForward;   // forward pointer to next element in double-link list of all elements
    ElemType  *m_pBackward;  // backward pointer to next element in double-link list of all elements
    KeyType    m_Key;
    ValueType  m_Value;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\inc\engine.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    engine.h

Abstract:

    Header file for the file system dump utility engine

Author:

    Stefan R. Steiner   [ssteiner]        02-18-2000

Revision History:

--*/

#ifndef __H_ENGINE_
#define __H_ENGINE_

class CFsdVolumeStateManager;
class CFsdVolumeState;

class CDumpEngine
{
public:
    CDumpEngine(
        IN CBsString cwsDirFileSpec,
        IN CDumpParameters &cDumpParameters
        ) : m_pcParams( &cDumpParameters ),
            m_ullNumDirs( 0 ),
            m_ullNumMountpoints( 0 ),
            m_ullNumBytesChecksummed( 0 ),
            m_ullNumBytesTotalUnnamedStream( 0 ),
            m_ullNumBytesTotalNamedDataStream( 0 ),
            m_ullNumReparsePoints( 0 ),
            m_ullNumFiles( 0 ),
            m_bShareName( FALSE ),
            m_ullNumFilesExcluded( 0 ),
            m_ullNumHardLinks( 0 ),
            m_ullNumDiscreteDACEs( 0 ),
            m_ullNumDiscreteSACEs( 0 ),
            m_ullNumEncryptedFiles( 0 ),
            m_ullNumFilesWithObjectIds( 0 )
    { 
        assert( cwsDirFileSpec.GetLength() >= 1 );

        //
        //  Let's do a bunch of stuff to normalize the given directory path.  Windows doesn't
        //  make this easy....
        //
        BOOL bPathIsInLongPathForm = FALSE;

        if ( cwsDirFileSpec.Left( 4 ) == L"\\\\?\\" || cwsDirFileSpec.Left( 4 ) == L"\\\\.\\" )
        {
            //
            //  Switch . with ? if it is there
            //
            cwsDirFileSpec.SetAt( 2, L'?' );
            bPathIsInLongPathForm = TRUE;
        } 
        else if ( cwsDirFileSpec.Left( 2 ) == L"\\\\"  )
        {
            // 
            //  Remote path
            //
            m_bShareName = TRUE;
        }
        else if ( cwsDirFileSpec.GetLength() == 2 && cwsDirFileSpec[1] == L':' )
        {
            //
            //  Just the drive letter and :.  GetFullPathNameW thinks that means
            //  the current directory on the drive whereas I mean for it to be the
            //  entire volume, i.e. L:\
            //
            cwsDirFileSpec += L'\\';
        }
        
        //
        //  Let's get the full path
        //
        LPWSTR pwszFileName;
        
        if ( ::GetFullPathNameW( 
                cwsDirFileSpec,
                FSD_MAX_PATH,
                m_cwsDirFileSpec.GetBufferSetLength( FSD_MAX_PATH ),
                &pwszFileName ) == 0 )
        {
            m_pcParams->ErrPrint( L"ERROR - Unable to get full path name of '%s', dwRet: %d, trying with relative pathname", 
                cwsDirFileSpec.c_str(), ::GetLastError() );
            m_cwsDirFileSpec.ReleaseBuffer() ;
            m_cwsDirFileSpec = cwsDirFileSpec;
        }
        else
        {
            m_cwsDirFileSpec.ReleaseBuffer();
        }
        
        //
        //  Must prepare the path to support > MAX_PATH file path by
        //  tacking on \\?\ on the front of the path.  Shares have 
        //  a slightly different format.
        //
        if ( !( m_pcParams->m_bDisableLongPaths || bPathIsInLongPathForm ) )
        {
            if ( m_bShareName )
            {
                //  BUGBUG: When the bug in GetVolumePathNameW() is fixed, uncomment the
                //  following:
                // m_cwsDirFileSpec  = L"\\\\?\\UNC";
                // m_cwsDirFileSpec += cwsDirFileSpec.c_str() + 1; // Have to chop off one '\'
            }
            else
            {
                m_cwsDirFileSpec  = L"\\\\?\\" + m_cwsDirFileSpec;
            }
        }

        //
        //  Add a trailing '\' if necessary
        //
        if (    m_pcParams->m_eFsDumpType != eFsDumpFile 
             && m_cwsDirFileSpec.Right( 1 ) != L"\\" )
            m_cwsDirFileSpec += L'\\';

        //
        //  Finally done mucking with paths...
        //
    }
    
    virtual ~CDumpEngine()
    {
    }

    DWORD PerformDump();

    static LPCSTR GetHeaderInformation();
    
private:
    DWORD ProcessDir( 
        IN CFsdVolumeStateManager *pcFsdVolStateManager,
        IN CFsdVolumeState *pcFsdVolState,
        IN const CBsString& cwsDirPath,
        IN INT cDirFileSpecLength,
        IN INT cVolMountPointOffset
        );

    VOID PrintEntry(
        IN CFsdVolumeState *pcFsdVolState,
        IN const CBsString& cwsDirPath,    
        IN INT cDirFileSpecLength,    
        IN SDirectoryEntry *psDirEntry,
        IN BOOL bSingleEntryOutput = FALSE
        );
    
    CBsString       m_cwsDirFileSpec;
    CDumpParameters *m_pcParams;
    ULONGLONG       m_ullNumDirs;
    ULONGLONG       m_ullNumFiles;
    ULONGLONG       m_ullNumMountpoints;
    ULONGLONG       m_ullNumReparsePoints;
    ULONGLONG       m_ullNumBytesChecksummed;
    ULONGLONG       m_ullNumBytesTotalUnnamedStream;
    ULONGLONG       m_ullNumBytesTotalNamedDataStream;
    ULONGLONG       m_ullNumFilesExcluded;
    ULONGLONG       m_ullNumHardLinks;
    ULONGLONG       m_ullNumDiscreteDACEs;
    ULONGLONG       m_ullNumDiscreteSACEs;
    ULONGLONG       m_ullNumEncryptedFiles;
    ULONGLONG       m_ullNumFilesWithObjectIds;
    BOOL            m_bShareName;
};

#endif // __H_ENGINE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\inc\volstate.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volstate.h

Abstract:

    Contains definition of the volume state class.  This class
    maintains state about one volume.

Author:

    Stefan R. Steiner   [ssteiner]        03-14-2000

Revision History:

--*/

#ifndef __H_VOLSTATE_
#define __H_VOLSTATE_

#include "exclproc.h"
#include "vs_hash.h"
#include "hardlink.h"

//
//  Definition of the volume id
//
struct SFsdVolumeId
{
    DWORD m_dwVolSerialNumber;

    inline BOOL IsEqual(
        IN SFsdVolumeId *psVolid
        )
    {
        return m_dwVolSerialNumber == psVolid->m_dwVolSerialNumber;
    }
};

//
//  Forward define
//
class CFsdVolumeState;

//
//  Definition of the list of volume state objects with SFsdVolumeId key.
//
typedef TBsHashMap< SFsdVolumeId, CFsdVolumeState * > FSD_VOLUME_STATE_LIST;

class CFsdVolumeStateManager
{
public:
    CFsdVolumeStateManager(
        IN CDumpParameters *pcDumpParameters
        );

    virtual ~CFsdVolumeStateManager();
    
    DWORD GetVolumeState(
        IN const CBsString& cwsVolumePath,
        OUT CFsdVolumeState **ppcVolState
        );

    VOID PrintExclusionInformation()
    {
        //  Pass the buck...
        m_pcExclManager->PrintExclusionInformation();
    }

    VOID PrintHardLinkInfo();
    
    static DWORD CFsdVolumeStateManager::GetVolumeIdAndPath( 
        IN CDumpParameters *pcDumpParameters,
        IN const CBsString& cwsPathOnVolume,
        OUT SFsdVolumeId *psVolId,
        OUT CBsString& cwsVolPath
        );
    
private:
    CDumpParameters *m_pcParams;
    CFsdExclusionManager *m_pcExclManager;
    FSD_VOLUME_STATE_LIST m_cVolumeStateList;
};

class CFsdVolumeState
{
friend class CFsdVolumeStateManager;
public:
    CFsdVolumeState(
        IN CDumpParameters *pcDumpParameters,
        IN const CBsString& cwsVolumePath
        ) : m_pcParams( pcDumpParameters ),
            m_cHardLinkManager( pcDumpParameters, cwsVolumePath.GetLength() ),
            m_cwsVolumePath( cwsVolumePath ),
            m_pcFSExclProcessor( NULL ),
            m_dwFileSystemFlags( 0 ),
            m_dwMaxComponentLength( 0 ),
            m_dwVolSerialNumber( 0 ) { }
    
    virtual ~CFsdVolumeState() 
    {
        delete m_pcFSExclProcessor;
    }

    //
    //  DirPath is relative to this volume
    //
    inline BOOL IsExcludedFile(
        IN const CBsString &cwsFullDirPath,
        IN DWORD dwEndOfVolMountPointOffset,
        IN const CBsString &cwsFileName
        )
    {
        if ( m_pcFSExclProcessor == NULL )
            return FALSE;
        return m_pcFSExclProcessor->IsExcludedFile( cwsFullDirPath, dwEndOfVolMountPointOffset, cwsFileName );
    }
    
    inline BOOL IsNtfs() { return ( m_dwFileSystemFlags & FS_PERSISTENT_ACLS ); }
    inline LPCWSTR GetFileSystemName() { return m_cwsFileSystemName.c_str(); }
    inline LPCWSTR GetVolumePath() { return m_cwsVolumePath.c_str(); }

    BOOL IsHardLinkInList(
        IN ULONGLONG ullFileIndex,
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName,
        OUT WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
        OUT SFileExtendedInfo *psExtendedInfo
        )
    {
        return m_cHardLinkManager.IsHardLinkInList( ullFileIndex, cwsDirPath, cwsFileName, psFileAttributeData, psExtendedInfo );
    }

    VOID AddHardLinkToList(
        IN ULONGLONG ullFileIndex,
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName,
        IN WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
        IN SFileExtendedInfo *psExtendedInfo
        )
    {
        m_cHardLinkManager.AddHardLinkToList( ullFileIndex, cwsDirPath, cwsFileName, psFileAttributeData, psExtendedInfo );
    }

    VOID PrintHardLinkInfo()
    {
        //
        //  Pass it on...
        //
        m_cHardLinkManager.PrintHardLinkInfo();
    }
    
private:
    CFsdVolumeState();  //  No copying please
    CDumpParameters *m_pcParams; 
    CBsString m_cwsVolumePath;    // Path to the volume
    CBsString m_cwsFileSystemName;
    CFsdHardLinkManager m_cHardLinkManager;
    CFsdFileSystemExcludeProcessor *m_pcFSExclProcessor;
    DWORD m_dwFileSystemFlags;    // GetVolumeInformation() fs flags
    DWORD m_dwMaxComponentLength;
    DWORD m_dwVolSerialNumber;    // Should be volume GUID
};

#endif // __H_VOLSTATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\inc\bsstring.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsstring.h

Abstract:

    This module defines the CBsString class.  This class manages character
    arrays in a similar manner as the CString class in VC++.  In fact, this
    class is a copy of the CString class with the MFC specific stuff ripped
    out since LTS doesn't use MTF.
    Added methods in addition to CString:
        c_str() - returns a C string pointer ala the STL string class
        size()  - returns length of string ala the STL string class

Author:

    Stefan R. Steiner   [SSteiner]      1-Mar-1998

Revision History:

    Stefan R. Steiner   [SSteiner]      10-Apr-2000
        Added fixed allocator code and resynced with MFC 6 SR-1 code

--*/

#ifndef __H_BSSTRING_
#define __H_BSSTRING_

#ifndef __cplusplus
	#error requires C++ compilation
#endif

/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#ifndef _INC_STRING
	#include <string.h>
#endif
#ifndef _INC_STDIO
	#include <stdio.h>
#endif
#ifndef _INC_STDLIB
	#include <stdlib.h>
#endif
#ifndef _INC_TIME
	#include <time.h>
#endif
#ifndef _INC_LIMITS
	#include <limits.h>
#endif
#ifndef _INC_STDDEF
	#include <stddef.h>
#endif
#ifndef _INC_STDARG
	#include <stdarg.h>
#endif
#ifndef _INC_ASSERT
	#include <assert.h>
#endif

#ifndef ASSERT
    #define ASSERT assert
#endif

#include "bsfixalloc.h"

class CBsString;

//
//  The purpose of this class is to generate a compiler error when different string classes
//  are used in bad contexts (example: CBsWString used if _UNICODE is not defined)
//
//  [aoltean] I introduce this small class to hide a class of LINT warnings.
//
class CBsStringErrorGenerator 
{};                     // Private constructor

// CBsString only operates on string that are TCHAR arrays.  Programs should use 
// the following types to make sure they are getting what they are expecting.
#ifdef _UNICODE
    #define CBsWString CBsString
    #define CBsAString CBsStringErrorGenerator   // trigger a compile time bug
#else
    #define CBsAString CBsString
    #define CBsWString CBsStringErrorGenerator   // trigger a compile time bug
#endif

#include <tchar.h>

#ifndef BSAFXAPI
    #define BSAFXAPI __cdecl
    #define BSAFX_CDECL __cdecl
#endif

// FASTCALL is used for static member functions with little or no params
#ifndef FASTCALL
	#define FASTCALL __fastcall
#endif

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the BSAFX include files
#ifndef ALL_WARNINGS
// warnings generated with common MFC/Windows code
#pragma warning(disable: 4127)  // constant expression for TRACE/ASSERT
#pragma warning(disable: 4134)  // message map member fxn casts
#pragma warning(disable: 4201)  // nameless unions are part of C++
#pragma warning(disable: 4511)  // private copy constructors are good to have
#pragma warning(disable: 4512)  // private operator= are good to have
#pragma warning(disable: 4514)  // unreferenced inlines are common
#pragma warning(disable: 4710)  // private constructors are disallowed
#pragma warning(disable: 4705)  // statement has no effect in optimized code
#pragma warning(disable: 4191)  // pointer-to-function casting
// warnings caused by normal optimizations
#ifndef _DEBUG
#pragma warning(disable: 4701)  // local variable *may* be used without init
#pragma warning(disable: 4702)  // unreachable code caused by optimizations
#pragma warning(disable: 4791)  // loss of debugging info in release version
#pragma warning(disable: 4189)  // initialized but unused variable
#pragma warning(disable: 4390)  // empty controlled statement
#endif
// warnings specific to _BSAFXDLL version
#ifdef _BSAFXDLL
#pragma warning(disable: 4204)  // non-constant aggregate initializer
#endif
#ifdef _BSAFXDLL
#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#endif
#endif //!ALL_WARNINGS

#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) x
#endif
#define UNUSED_ALWAYS(x) x

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
	typedef LPSTR BSTR;
#else
	typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif
#endif

struct CBsStringData
{
	long nRefs;             // reference count
	int nDataLength;        // length of data (including terminator)
	int nAllocLength;       // length of allocation
	// TCHAR data[nAllocLength]

	TCHAR* data()           // TCHAR* to managed data
		{ return (TCHAR*)(this+1); }
};

class CBsString
{
public:
// Constructors

	// constructs empty CBsString
	CBsString();
	// copy constructor
	CBsString(const CBsString& stringSrc);
	// from a single character
	CBsString(TCHAR ch, int nRepeat = 1);
	// from an ANSI string (converts to TCHAR)
	CBsString(LPCSTR lpsz);
	// from a UNICODE string (converts to TCHAR)
	CBsString(LPCWSTR lpsz);
	// subset of characters from an ANSI string (converts to TCHAR)
	CBsString(LPCSTR lpch, int nLength);
	// subset of characters from a UNICODE string (converts to TCHAR)
	CBsString(LPCWSTR lpch, int nLength);
	// from unsigned characters
	CBsString(const unsigned char* psz);
	CBsString(GUID guid);

// Attributes & Operations

	// get data length
	int GetLength() const;
	// TRUE if zero length
	BOOL IsEmpty() const;
	// clear contents to empty
	void Empty();
	int size() const;                   // ala STL string class size()

	// return single character at zero-based index
	TCHAR GetAt(int nIndex) const;
	// return single character at zero-based index
	TCHAR operator[](int nIndex) const;
	// set a single character at zero-based index
	void SetAt(int nIndex, TCHAR ch);
	// return pointer to const string
	operator LPCTSTR() const;
    const LPCTSTR c_str() const;        // as a C string in STL string style

	// overloaded assignment

	// ref-counted copy from another CBsString
	const CBsString& operator=(const CBsString& stringSrc);
	// set string content to single character
	const CBsString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CBsString& operator=(char ch);
#endif
	// copy string content from ANSI string (converts to TCHAR)
	const CBsString& operator=(LPCSTR lpsz);
	// copy string content from UNICODE string (converts to TCHAR)
	const CBsString& operator=(LPCWSTR lpsz);
	// copy string content from unsigned chars
	const CBsString& operator=(const unsigned char* psz);

	// string concatenation

	// concatenate from another CBsString
	const CBsString& operator+=(const CBsString& string);

	// concatenate a single character
	const CBsString& operator+=(TCHAR ch);
#ifdef _UNICODE
	// concatenate an ANSI character after converting it to TCHAR
	const CBsString& operator+=(char ch);
#endif
	// concatenate a UNICODE character after converting it to TCHAR
	const CBsString& operator+=(LPCTSTR lpsz);

	friend CBsString BSAFXAPI operator+(const CBsString& string1,
			const CBsString& string2);
	friend CBsString BSAFXAPI operator+(const CBsString& string, TCHAR ch);
	friend CBsString BSAFXAPI operator+(TCHAR ch, const CBsString& string);
#ifdef _UNICODE
	friend CBsString BSAFXAPI operator+(const CBsString& string, char ch);
	friend CBsString BSAFXAPI operator+(char ch, const CBsString& string);
#endif
	friend CBsString BSAFXAPI operator+(const CBsString& string, LPCTSTR lpsz);
	friend CBsString BSAFXAPI operator+(LPCTSTR lpsz, const CBsString& string);

	// string comparison

	// straight character comparison
	int Compare(LPCTSTR lpsz) const;
	// compare ignoring case
	int CompareNoCase(LPCTSTR lpsz) const;
	// NLS aware comparison, case sensitive
	int Collate(LPCTSTR lpsz) const;
	// NLS aware comparison, case insensitive
	int CollateNoCase(LPCTSTR lpsz) const;

	// simple sub-string extraction

	// return nCount characters starting at zero-based nFirst
	CBsString Mid(int nFirst, int nCount) const;
	// return all characters starting at zero-based nFirst
	CBsString Mid(int nFirst) const;
	// return first nCount characters in string
	CBsString Left(int nCount) const;
	// return nCount characters from end of string
	CBsString Right(int nCount) const;

	//  characters from beginning that are also in passed string
	CBsString SpanIncluding(LPCTSTR lpszCharSet) const;
	// characters from beginning that are not also in passed string
	CBsString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion

	// NLS aware conversion to uppercase
	void MakeUpper();
	// NLS aware conversion to lowercase
	void MakeLower();
	// reverse string right-to-left
	void MakeReverse();

	// trimming whitespace (either side)

	// remove whitespace starting from right edge
	void TrimRight();
	// remove whitespace starting from left side
	void TrimLeft();

	// trimming anything (either side)

	// remove continuous occurrences of chTarget starting from right
	void TrimRight(TCHAR chTarget);
	// remove continuous occcurrences of characters in passed string,
	// starting from right
	void TrimRight(LPCTSTR lpszTargets);
	// remove continuous occurrences of chTarget starting from left
	void TrimLeft(TCHAR chTarget);
	// remove continuous occcurrences of characters in
	// passed string, starting from left
	void TrimLeft(LPCTSTR lpszTargets);

	// advanced manipulation

	// replace occurrences of chOld with chNew
	int Replace(TCHAR chOld, TCHAR chNew);
	// replace occurrences of substring lpszOld with lpszNew;
	// empty lpszNew removes instances of lpszOld
	int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	// remove occurrences of chRemove
	int Remove(TCHAR chRemove);
	// insert character at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, TCHAR ch);
	// insert substring at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, LPCTSTR pstr);
	// delete nCount characters starting at zero-based index
	int Delete(int nIndex, int nCount = 1);

	// searching

	// find character starting at left, -1 if not found
	int Find(TCHAR ch) const;
	// find character starting at right
	int ReverseFind(TCHAR ch) const;
	// find character starting at zero-based index and going right
	int Find(TCHAR ch, int nStart) const;
	// find first instance of any character in passed string
	int FindOneOf(LPCTSTR lpszCharSet) const;
	// find first instance of substring
	int Find(LPCTSTR lpszSub) const;
	// find first instance of substring starting at zero-based index
	int Find(LPCTSTR lpszSub, int nStart) const;

	// simple formatting

	// printf-like formatting using passed string
	void BSAFX_CDECL Format(LPCTSTR lpszFormat, ...);
	// printf-like formatting using variable arguments parameter
	void FormatV(LPCTSTR lpszFormat, va_list argList);

#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)

	// convert string from ANSI to OEM in-place
	void AnsiToOem();
	// convert string from OEM to ANSI in-place
	void OemToAnsi();
#endif

#ifndef _BSAFX_NO_BSTR_SUPPORT
	// OLE BSTR support (use for OLE automation)

	// return a BSTR initialized with this CBsString's data
	BSTR AllocSysString() const;
	// reallocates the passed BSTR, copies content of this CBsString to it
	BSTR SetSysString(BSTR* pbstr) const;
#endif

	// Access to string implementation buffer as "C" character array

	// get pointer to modifiable buffer at least as long as nMinBufLength
	LPTSTR GetBuffer(int nMinBufLength);
	// release buffer, setting length to nNewLength (or to first nul if -1)
	void ReleaseBuffer(int nNewLength = -1);
	// get pointer to modifiable buffer exactly as long as nNewLength
	LPTSTR GetBufferSetLength(int nNewLength);
	// release memory allocated to but unused by string
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off

	// turn refcounting back on
	LPTSTR LockBuffer();
	// turn refcounting off
	void UnlockBuffer();

// Implementation
public:
	~CBsString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // Pointer to ref counted string data.  This is actually
                        // a pointer to memory after the CBsStringData structure.

	// implementation helpers
	CBsStringData* GetData() const;
	void Init();
	void AllocCopy(CBsString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CBsStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
	static void FASTCALL FreeData(CBsStringData* pData);
};

// Compare helpers
bool BSAFXAPI operator==(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator==(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator==(LPCTSTR s1, const CBsString& s2);
bool BSAFXAPI operator!=(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator!=(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator!=(LPCTSTR s1, const CBsString& s2);
bool BSAFXAPI operator<(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator<(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator<(LPCTSTR s1, const CBsString& s2);
bool BSAFXAPI operator>(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator>(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator>(LPCTSTR s1, const CBsString& s2);
bool BSAFXAPI operator<=(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator<=(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator<=(LPCTSTR s1, const CBsString& s2);
bool BSAFXAPI operator>=(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator>=(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator>=(LPCTSTR s1, const CBsString& s2);

// conversion helpers
int BSAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int BSAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// valid address test helpers
BOOL BSAFXAPI BsAfxIsValidString(LPCWSTR lpsz, int nLength = -1);
BOOL BSAFXAPI BsAfxIsValidString(LPCSTR lpsz, int nLength = -1);
BOOL BSAFXAPI BsAfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE);

// Globals
extern TCHAR bsafxChNil;
const CBsString& BSAFXAPI BsAfxGetEmptyString();
#define bsafxEmptyString BsAfxGetEmptyString()

inline CBsStringData* CBsString::GetData() const
	{ ASSERT(m_pchData != NULL); return ((CBsStringData*)m_pchData)-1; }
inline void CBsString::Init()
	{ m_pchData = bsafxEmptyString.m_pchData; }
inline CBsString::CBsString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CBsString& CBsString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
inline const CBsString& CBsString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CBsString& CBsString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CBsString BSAFXAPI operator+(const CBsString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CBsString BSAFXAPI operator+(char ch, const CBsString& string)
	{ return (TCHAR)ch + string; }
#endif

inline int CBsString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CBsString::size() const
	{ return GetData()->nDataLength; }
inline int CBsString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CBsString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CBsString::operator LPCTSTR() const
	{ return m_pchData; }
inline const LPCTSTR CBsString::c_str() const
	{ return m_pchData; }
inline int PASCAL CBsString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CBsString support (windows specific)
inline int CBsString::Compare(LPCTSTR lpsz) const
	{ ASSERT(BsAfxIsValidString(lpsz)); return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CBsString::CompareNoCase(LPCTSTR lpsz) const
	{ ASSERT(BsAfxIsValidString(lpsz)); return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CBsString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CBsString::Collate(LPCTSTR lpsz) const
	{ ASSERT(BsAfxIsValidString(lpsz)); return _tcscoll(m_pchData, lpsz); }   // locale sensitive
inline int CBsString::CollateNoCase(LPCTSTR lpsz) const
	{ ASSERT(BsAfxIsValidString(lpsz)); return _tcsicoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CBsString::GetAt(int nIndex) const
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CBsString::operator[](int nIndex) const
{
	// same as GetAt
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool BSAFXAPI operator==(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool BSAFXAPI operator==(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool BSAFXAPI operator==(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool BSAFXAPI operator!=(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool BSAFXAPI operator!=(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool BSAFXAPI operator!=(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool BSAFXAPI operator<(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool BSAFXAPI operator<(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool BSAFXAPI operator<(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool BSAFXAPI operator>(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool BSAFXAPI operator>(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool BSAFXAPI operator>(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool BSAFXAPI operator<=(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool BSAFXAPI operator<=(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool BSAFXAPI operator<=(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool BSAFXAPI operator>=(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool BSAFXAPI operator>=(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool BSAFXAPI operator>=(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) <= 0; }

#endif // __H_BSSTRING_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\extattr.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    extattr.h

Abstract:

    Get's additional file attributes beyond what you get with
    FindFirstFile/FindNextFile.

Author:

    Stefan R. Steiner   [ssteiner]        02-27-2000

Revision History:

--*/

#ifndef __H_EXTATTR_
#define __H_EXTATTR_

class CFsdVolumeState;
struct SDirectoryEntry;

static CBsString cwsFsdNoData = L"--------";

inline VOID FsdEaSetNoDataString( 
    IN LPCWSTR pwszStr
    )
{
    cwsFsdNoData = pwszStr;
}

struct SFileExtendedInfo
{   
    CBsString cwsOwnerSid;
    CBsString cwsGroupSid;
    ULONGLONG ullTotalBytesChecksummed;
    ULONGLONG ullTotalBytesNamedDataStream;
    ULONGLONG ullFileIndex;
    LONG      lNumberOfLinks;  // hard links
    LONG      lNumDACEs;
    LONG      lNumSACEs;
    LONG      lNumNamedDataStreams;
    LONG      lNumPropertyStreams;
    WORD      wReparsePointDataSize;
    WORD      wDACLSize;
    WORD      wSACLSize;
    WORD      wSecurityDescriptorControl;
    ULONG     ulReparsePointTag;
    CBsString cwsReparsePointDataChecksum;
    CBsString cwsUnnamedStreamChecksum;
    CBsString cwsNamedDataStreamChecksum;
    CBsString cwsDACLChecksum;
    CBsString cwsSACLChecksum;
    CBsString cwsEncryptedRawDataChecksum;
    CBsString cwsObjectId;
    CBsString cwsObjectIdExtendedDataChecksum;
    SFileExtendedInfo() : lNumDACEs( 0 ),
                          lNumSACEs( 0 ),
                          lNumNamedDataStreams( 0 ),
                          lNumPropertyStreams( 0 ),
                          ulReparsePointTag( 0 ),
                          ullTotalBytesChecksummed( 0 ),
                          ullTotalBytesNamedDataStream( 0 ),
                          ullFileIndex( 0 ),
                          lNumberOfLinks( 0 ),
                          wReparsePointDataSize( 0 ),
                          wDACLSize( 0 ),
                          wSACLSize( 0 ),
                          wSecurityDescriptorControl( 0 ),
                          cwsReparsePointDataChecksum( cwsFsdNoData ),
                          cwsUnnamedStreamChecksum( cwsFsdNoData ),
                          cwsNamedDataStreamChecksum( cwsFsdNoData ),
                          cwsDACLChecksum( cwsFsdNoData ),
                          cwsSACLChecksum( cwsFsdNoData ),
                          cwsObjectIdExtendedDataChecksum( cwsFsdNoData ),
                          cwsEncryptedRawDataChecksum( cwsFsdNoData ) { }
};


VOID 
GetExtendedFileInfo(
    IN CDumpParameters *pcParams,
    IN CFsdVolumeState *pcFsdVolState,
    IN const CBsString& cwsDirPath,
    IN BOOL bSingleEntryOutput,        
    IN OUT SDirectoryEntry *psDirEntry,
    OUT SFileExtendedInfo *psExtendedInfo    
    );

#endif // __H_EXTATTR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\engine.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    engine.cpp

Abstract:

    The file system dump utility engine.

Author:

    Stefan R. Steiner   [ssteiner]        02-18-2000

Revision History:

    Avinash Pillai	[apillai]		07-29-2002	Added options -o:t, -o:y, -o:f and -o:i

--*/

#include "stdafx.h"

#include "direntrs.h"
#include "extattr.h"

#include "engine.h"

static VOID 
TimeString(
    IN FILETIME *pFileTime,
    IN BOOL bAddSecsToTimestamps,
    IN BOOL bAddMillisecsToTimestamps,
    OUT LPWSTR pwszTimeStr
    );

/*++

Routine Description:

    Performs the actual dump of the directory or file.

Arguments:

Return Value:

    <Enter return values here>

--*/
DWORD
CDumpEngine::PerformDump()
{
    //
    //  Perform the actual dump
    //
    DWORD dwRet;

    //
    //  Kind of a hack, set the no data string if we want something other than dashes
    //
    if ( m_pcParams->m_bDumpCommaDelimited )
        FsdEaSetNoDataString( L"" );
    
    //
    //  Volume state manager manages all state about all volumes that are encountered during
    //  the dump.
    //
    CFsdVolumeStateManager cFsdVolStateManager( m_pcParams );
    
    //
    //  Get information about the volume
    //
    CFsdVolumeState *pcFsdVolState;
    
    dwRet = cFsdVolStateManager.GetVolumeState( m_cwsDirFileSpec, &pcFsdVolState );
    assert( dwRet != ERROR_ALREADY_EXISTS );
    if ( dwRet != ERROR_SUCCESS )
        return dwRet;

    if ( m_pcParams->m_bDumpCommaDelimited )
    {
	if(!m_pcParams->m_bNoShortFileName)
	{
		if(!m_pcParams->m_bNoFileSystemType)
        		m_pcParams->DumpPrintAlways( L"File name,Short Name,Creation date,Last modification date,File size,Attr,DACE,SACE,SDCtl,UNamChkS,DStr,DStrSize,DStrChkS,Prop,RPTag,RPSize,RPChkS,EncrChkS,DACLSize,DACLChkS,SACLSize,SACLChkS,NLnk,ObjectId,OIDChkS,FS,Owner Sid,Group Sid" );
		else
			m_pcParams->DumpPrintAlways( L"File name,Short Name,Creation date,Last modification date,File size,Attr,DACE,SACE,SDCtl,UNamChkS,DStr,DStrSize,DStrChkS,Prop,RPTag,RPSize,RPChkS,EncrChkS,DACLSize,DACLChkS,SACLSize,SACLChkS,NLnk,ObjectId,OIDChkS,Owner Sid,Group Sid" );
	}
	else
	{
		if(!m_pcParams->m_bNoFileSystemType)
			m_pcParams->DumpPrintAlways( L"File name,Creation date,Last modification date,File size,Attr,DACE,SACE,SDCtl,UNamChkS,DStr,DStrSize,DStrChkS,Prop,RPTag,RPSize,RPChkS,EncrChkS,DACLSize,DACLChkS,SACLSize,SACLChkS,NLnk,ObjectId,OIDChkS,FS,Owner Sid,Group Sid" );	
		else
			m_pcParams->DumpPrintAlways( L"File name,Creation date,Last modification date,File size,Attr,DACE,SACE,SDCtl,UNamChkS,DStr,DStrSize,DStrChkS,Prop,RPTag,RPSize,RPChkS,EncrChkS,DACLSize,DACLChkS,SACLSize,SACLChkS,NLnk,ObjectId,OIDChkS,Owner Sid,Group Sid" );	
	}

        //
        //  Put the current time into the CSV dump file for easy detection of when
        //  dumps are taken
        //
        FILETIME sSysFT, sLocalFT;
        ::GetSystemTimeAsFileTime( &sSysFT );
        ::FileTimeToLocalFileTime( &sSysFT, &sLocalFT );
        WCHAR wszCurrentTime[32];    
        ::TimeString( &sLocalFT, TRUE, FALSE, wszCurrentTime );        
        m_pcParams->DumpPrintAlways( L"Dump time: %s", wszCurrentTime );        
    }
    else
    {
//        if ( ( m_pcParams->m_eFsDumpType == eFsDumpVolume ) && 
//             ( m_cwsDirFileSpec != pcFsdVolState->GetVolumePath() ) )
//        {
//            m_pcParams->ErrPrint( L"'%s' is not a drive specifier or mountpoint, use -dd instead",
//                m_cwsDirFileSpec.c_str() );
//            return 1;
//        }
        
        m_pcParams->DumpPrintAlways( L"\nDumping: '%s' on volume '%s'", m_cwsDirFileSpec.c_str(), pcFsdVolState->GetVolumePath() );
        if(!m_pcParams->m_bNoShortFileName)
        {
	        if ( m_pcParams->m_bAddMillisecsToTimestamps )
	            m_pcParams->DumpPrintAlways( 
	                L"   Creation date           Last modification date   FileSize        Attr FileName                         ShortName    DACE SACE SDCtl UNamChkS DStr DStrSize DStrChkS Prop RPTag    RPSize RPChkS   EncrChkS DACLSize DACLChkS SACLSize SACLChkS NLnk ObjectId                             OIDChkS OwnerSid/GroupSid" );
	        else if (m_pcParams->m_bAddSecsToTimestamps)
	            m_pcParams->DumpPrintAlways( L"   Creation date       Last mod. date       FileSize        Attr FileName                         ShortName    DACE SACE SDCtl UNamChkS DStr DStrSize DStrChkS Prop RPTag    RPSize RPChkS   EncrChkS DACLSize DACLChkS SACLSize SACLChkS NLnk ObjectId                             OIDChkS OwnerSid/GroupSid" );
	        else
	            m_pcParams->DumpPrintAlways( L"   Creation date    Last mod. date           FileSize Attr FileName                         ShortName    DACE SACE SDCtl UNamChkS DStr DStrSize DStrChkS Prop RPTag    RPSize RPChkS   EncrChkS DACLSize DACLChkS SACLSize SACLChkS NLnk ObjectId                             OIDChkS OwnerSid/GroupSid" );
        }
        else
        {
	        if ( m_pcParams->m_bAddMillisecsToTimestamps )
	            m_pcParams->DumpPrintAlways( 
	                L"   Creation date           Last modification date   FileSize        Attr FileName                         DACE SACE SDCtl UNamChkS DStr DStrSize DStrChkS Prop RPTag    RPSize RPChkS   EncrChkS DACLSize DACLChkS SACLSize SACLChkS NLnk ObjectId                             OIDChkS OwnerSid/GroupSid" );
	        else if (m_pcParams->m_bAddSecsToTimestamps)
	            m_pcParams->DumpPrintAlways( L"   Creation date       Last mod. date       FileSize        Attr FileName                         DACE SACE SDCtl UNamChkS DStr DStrSize DStrChkS Prop RPTag    RPSize RPChkS   EncrChkS DACLSize DACLChkS SACLSize SACLChkS NLnk ObjectId                             OIDChkS OwnerSid/GroupSid" );
	        else
	            m_pcParams->DumpPrintAlways( L"   Creation date    Last mod. date           FileSize Attr FileName                         DACE SACE SDCtl UNamChkS DStr DStrSize DStrChkS Prop RPTag    RPSize RPChkS   EncrChkS DACLSize DACLChkS SACLSize SACLChkS NLnk ObjectId                             OIDChkS OwnerSid/GroupSid" );
        }
    }


    ////////////////////////////////////////////////////////////////////
    //
    //  Get the file info for the root dir or file
    //  Bug # 157915
    //
    ////////////////////////////////////////////////////////////////////
    bool bRootIsADir = true;
    CBsString cwsDirFileSpecWithoutSlash( m_cwsDirFileSpec );
    if ( cwsDirFileSpecWithoutSlash.Right( 1 ) == L"\\" )
        cwsDirFileSpecWithoutSlash = cwsDirFileSpecWithoutSlash.Left( cwsDirFileSpecWithoutSlash.GetLength() - 1 );
    try
    {
        CDirectoryEntries cRootEntry( 
            m_pcParams, 
            cwsDirFileSpecWithoutSlash
            );

        //
        //  Only one entry should be returned in either the directory list or file list
        //
        SDirectoryEntry *psDirEntry;
        
        //
        //  See if it is file entry
        //
        CDirectoryEntriesIterator *pListIter;
        pListIter = cRootEntry.GetFileListIterator();
        if ( pListIter->GetNext( psDirEntry ) )
        {
            bRootIsADir = false;
            ++m_ullNumFiles;
            m_ullNumBytesTotalUnnamedStream += ( ( ( ULONGLONG )psDirEntry->m_sFindData.nFileSizeHigh ) << 32 ) |
                                  psDirEntry->m_sFindData.nFileSizeLow;

            if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED )
                ++m_ullNumEncryptedFiles;
            
            PrintEntry( pcFsdVolState, cwsDirFileSpecWithoutSlash, 
                cwsDirFileSpecWithoutSlash.GetLength(), psDirEntry, TRUE );

            ASSERT( pListIter->GetNext( psDirEntry ) == false );
        }
        delete pListIter;        

        //
        //  See if it is a directory entry
        //
        pListIter = cRootEntry.GetDirListIterator();
        if ( pListIter->GetNext( psDirEntry ) )
        {
            ASSERT( bRootIsADir );
            //  It is
            ++m_ullNumDirs;
            PrintEntry( pcFsdVolState, cwsDirFileSpecWithoutSlash, 
                cwsDirFileSpecWithoutSlash.GetLength(), psDirEntry, TRUE );

            ASSERT( pListIter->GetNext( psDirEntry ) == false );
        }
        delete pListIter;        
    }
    catch ( DWORD dwRet )
    {
        if ( dwRet == ERROR_INVALID_NAME || dwRet == ERROR_BAD_NET_NAME )
        {
            //
            //  Must be working with the root of the drive letter name space which
            //  means we do things slightly differently.
            //
            SDirectoryEntry sDirEntry;
            ::memset( &sDirEntry.m_sFindData, 0x00, sizeof( sDirEntry.m_sFindData ) );
            PrintEntry( pcFsdVolState, m_cwsDirFileSpec, 
                m_cwsDirFileSpec.GetLength(), &sDirEntry, TRUE );            
        }
        else
            m_pcParams->ErrPrint( L"PerformDump: Unexpected error trying to process '%s', dwRet: %d", 
                m_cwsDirFileSpec.c_str(), dwRet );            
    }
    catch ( ... )
    {
        m_pcParams->ErrPrint( L"ProcessDir() Caught an unexpected exception processing file: '%s', Last dwRet: %d", 
            m_cwsDirFileSpec.c_str(), ::GetLastError() );
    }
            
    //
    //  Now traverse into the volume/directory if necessary
    //
    if ( m_pcParams->m_eFsDumpType != eFsDumpFile )
    {
        if ( bRootIsADir )
        {
            dwRet = ProcessDir( 
                &cFsdVolStateManager, 
                pcFsdVolState, 
                m_cwsDirFileSpec, 
                m_cwsDirFileSpec.GetLength(),
                ::wcslen( pcFsdVolState->GetVolumePath() ) );
        }
        
        //
        //  Print out some stats about the dump
        //
        m_pcParams->DumpPrint( L"\nSTATISTICS for '%s':", m_cwsDirFileSpec.c_str() );
        if ( m_pcParams->m_bHex )
        {
            m_pcParams->DumpPrint( L"  Number of directories (including mountpoints):    %16I64x(hex)", m_ullNumDirs );
            m_pcParams->DumpPrint( L"  Number of files:                                  %16I64x(hex)", m_ullNumFiles );
            m_pcParams->DumpPrint( L"  Number of mountpoints:                            %16I64x(hex)", m_ullNumMountpoints );
            m_pcParams->DumpPrint( L"  Number of reparse points (excluding mountpoints): %16I64x(hex)", m_ullNumReparsePoints );
            m_pcParams->DumpPrint( L"  Number of hard-linked files:                      %16I64x(hex)", m_ullNumHardLinks );
            m_pcParams->DumpPrint( L"  Number of discrete DACL ACEs:                     %16I64x(hex)", m_ullNumDiscreteDACEs );
            m_pcParams->DumpPrint( L"  Number of discrete SACL ACEs:                     %16I64x(hex)", m_ullNumDiscreteSACEs );
            m_pcParams->DumpPrint( L"  Number of encrypted files:                        %16I64x(hex)", m_ullNumEncryptedFiles );
            m_pcParams->DumpPrint( L"  Number of files with object ids:                  %16I64x(hex)", m_ullNumFilesWithObjectIds );
            if ( m_pcParams->m_bUseExcludeProcessor )
                m_pcParams->DumpPrint( L"  Number of files excluded due to exclusion rules:  %16I64x(hex)", m_ullNumFilesExcluded );
            m_pcParams->DumpPrint( L"  Total bytes of checksummed data:                  %16I64x(hex)", m_ullNumBytesChecksummed );
            m_pcParams->DumpPrint( L"  Total bytes of unnamed stream data:               %16I64x(hex)", m_ullNumBytesTotalUnnamedStream );
            m_pcParams->DumpPrint( L"  Total bytes of named data stream data:            %16I64x(hex)", m_ullNumBytesTotalNamedDataStream );
        }
        else
        {
            m_pcParams->DumpPrint( L"  Number of directories (including mountpoints):    %16I64u", m_ullNumDirs );
            m_pcParams->DumpPrint( L"  Number of files:                                  %16I64u", m_ullNumFiles );
            m_pcParams->DumpPrint( L"  Number of mountpoints:                            %16I64u", m_ullNumMountpoints );
            m_pcParams->DumpPrint( L"  Number of reparse points (excluding mountpoints): %16I64u", m_ullNumReparsePoints );
            m_pcParams->DumpPrint( L"  Number of hard-linked files:                      %16I64u", m_ullNumHardLinks );
            m_pcParams->DumpPrint( L"  Number of discrete DACL ACEs:                     %16I64u", m_ullNumDiscreteDACEs );
            m_pcParams->DumpPrint( L"  Number of discrete SACL ACEs:                     %16I64u", m_ullNumDiscreteSACEs );
            m_pcParams->DumpPrint( L"  Number of encrypted files:                        %16I64u", m_ullNumEncryptedFiles );
            m_pcParams->DumpPrint( L"  Number of files with object ids:                  %16I64u", m_ullNumFilesWithObjectIds );
            if ( m_pcParams->m_bUseExcludeProcessor )
                m_pcParams->DumpPrint( L"  Number of files excluded due to exclusion rules:  %16I64u", m_ullNumFilesExcluded );
            m_pcParams->DumpPrint( L"  Total bytes of checksummed data:                  %16I64u", m_ullNumBytesChecksummed );
            m_pcParams->DumpPrint( L"  Total bytes of unnamed stream data:               %16I64u", m_ullNumBytesTotalUnnamedStream );
            m_pcParams->DumpPrint( L"  Total bytes of named data stream data:            %16I64u", m_ullNumBytesTotalNamedDataStream );
        }

        if ( m_pcParams->m_bUseExcludeProcessor )
        {
            //
            //  Print out exclusion information
            //
            cFsdVolStateManager.PrintExclusionInformation();
        }
        cFsdVolStateManager.PrintHardLinkInfo();
    }   
    
    return dwRet;
}


/*++

Routine Description:

    Traverses into a directory and dumps all the information about the dir.
    NOTE: This is a recursive function.
    
Arguments:

    cwsDirPath - The directory path or file to dump information about
    
Return Value:

    <Enter return values here>

--*/
DWORD 
CDumpEngine::ProcessDir( 
    IN CFsdVolumeStateManager *pcFsdVolStateManager,        
    IN CFsdVolumeState *pcFsdVolState,
    IN const CBsString& cwsDirPath,
    IN INT cDirFileSpecLength,
    IN INT cVolMountPointOffset
    )
{
    DWORD dwRet = ERROR_SUCCESS;

    try 
    {
        if ( !m_pcParams->m_bDumpCommaDelimited )
        {
            if ( cwsDirPath.GetLength() == cDirFileSpecLength )
            {
                //
                //  This is the root of the directory
                //
                m_pcParams->DumpPrintAlways( L"'.\\' - %s", ( pcFsdVolState != NULL ) ? pcFsdVolState->GetFileSystemName() : L"???" );
            }
            else
            {
                m_pcParams->DumpPrintAlways( L"'%s' - %s", cwsDirPath.c_str() + cDirFileSpecLength,
                    ( pcFsdVolState != NULL ) ? pcFsdVolState->GetFileSystemName() : L"???" );       
            }
        }
        
        //
        //  Get the directory entries for the directory/file
        //
        CDirectoryEntries cDirEntries( 
            m_pcParams, 
            cwsDirPath + L"*"
            );

        SDirectoryEntry *psDirEntry;

        //
        //  First dump out the sub-directory entries
        //
        CDirectoryEntriesIterator *pDirListIter;
        pDirListIter = cDirEntries.GetDirListIterator();
        while ( pDirListIter->GetNext( psDirEntry ) )
        {
            ++m_ullNumDirs;
            if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
            {
                ++m_ullNumMountpoints;
            }
            PrintEntry( pcFsdVolState, cwsDirPath, cDirFileSpecLength, psDirEntry );
        }

        //
        //  Next dump out the non-sub-directory entries
        //
        CDirectoryEntriesIterator *pFileListIter;
        pFileListIter = cDirEntries.GetFileListIterator();
        while ( pFileListIter->GetNext( psDirEntry ) )
        {
            ++m_ullNumFiles;
            m_ullNumBytesTotalUnnamedStream += ( ( ( ULONGLONG )psDirEntry->m_sFindData.nFileSizeHigh ) << 32 ) |
                                  psDirEntry->m_sFindData.nFileSizeLow;

            if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
                ++m_ullNumReparsePoints;
            if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED )
                ++m_ullNumEncryptedFiles;
            
            //
            //  Check to see if we should exclude the file
            //
            if ( pcFsdVolState->IsExcludedFile( cwsDirPath, cVolMountPointOffset, psDirEntry->GetFileName() ) )
                ++m_ullNumFilesExcluded;
            else
                PrintEntry( pcFsdVolState, cwsDirPath, cDirFileSpecLength, psDirEntry );
        }
        delete pFileListIter;

        if (    m_pcParams->m_eFsDumpType == eFsDumpVolume 
             || m_pcParams->m_eFsDumpType == eFsDumpDirTraverse )
        {
            //
            //  Now traverse into each sub-directory
            //
            pDirListIter->Reset();
            CBsString cwsTraversePath;
            while ( pDirListIter->GetNext( psDirEntry ) )
            {
                if (    m_pcParams->m_bDontTraverseMountpoints
                     && psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
                    continue;
                cwsTraversePath = cwsDirPath + psDirEntry->GetFileName();
                cwsTraversePath += L'\\';
                
                //
                //  Now go into recursion mode
                //
                if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
                {
                    //
                    //  Traversing into another volume, get it's state
                    //
                    CFsdVolumeState *pcNewFsdVolState;
                    DWORD dwRet;
                    
                    dwRet = pcFsdVolStateManager->GetVolumeState( cwsTraversePath, &pcNewFsdVolState );
                    if ( dwRet == ERROR_ALREADY_EXISTS )
                    {
                        //
                        //  Mountpoint cycle, stop traversing.  Need to print the fully qualified
                        //  path if the traversal mountpoint is the same as the mountpoint
                        //  we started with, otherwise we AV.
                        //
                        INT cVolStateSpecLength;                        
                        cVolStateSpecLength = ( ::wcslen( pcNewFsdVolState->GetVolumePath() ) <= (size_t)cDirFileSpecLength )
                                               ? 0 : cDirFileSpecLength;
                        m_pcParams->DumpPrint( L"'%s' - Not traversing, already traversed through '%s' mountpoint", 
                            cwsTraversePath.c_str() + cDirFileSpecLength, pcNewFsdVolState->GetVolumePath() + cVolStateSpecLength );
                    }
                    else if ( dwRet == ERROR_SUCCESS )
                    {
                        ProcessDir( 
                            pcFsdVolStateManager, 
                            pcNewFsdVolState, 
                            cwsTraversePath, 
                            cDirFileSpecLength,
                            ::wcslen( pcNewFsdVolState->GetVolumePath() ) );
                    }
                    else
                    {
                        //
                        //  Error message already printed out
                        //
                    }
                }
                else
                {
                    ProcessDir( 
                        pcFsdVolStateManager, 
                        pcFsdVolState, 
                        cwsTraversePath, 
                        cDirFileSpecLength,
                        cVolMountPointOffset );
                }
            }
        }
        
        delete pDirListIter;
    }    
    catch ( DWORD dwRet )
    {
        m_pcParams->ErrPrint( L"ProcessDir: Error trying to process '%s' directory, dwRet: %d", cwsDirPath.c_str(), dwRet );
    }
    catch ( ... )
    {
        m_pcParams->ErrPrint( L"ProcessDir() Caught an unexpected exception processing dir: '%s', Last dwRet: %d", 
            cwsDirPath.c_str(), ::GetLastError() );
    }
    
    return 0;
}


//
//  printf style format strings which format each line
//
#define DIR_STR      L"<DIR>"
#define JUNCTION_STR L"<JUNCTION>"
#define FMT_DIR_STR_HEX  L"   %s %s %-16s %04x %-32s %-12s %4d %4d  %04x -------- %4d %8I64x %s %4d %s %6hx %s %s %8hx %s %8hx %s %4d %36s %s %%s/%s"
#define FMT_DIR_STR_HEX_NO_SFN  L"   %s %s %-16s %04x %-32s %4d %4d  %04x -------- %4d %8I64x %s %4d %s %6hx %s %s %8hx %s %8hx %s %4d %36s %s %%s/%s"
#define FMT_DIR_STR      L"   %s %s %-16s %04x %-32s %-12s %4d %4d  %04x -------- %4d %8I64d %s %4d %s %6hu %s %s %8hd %s %8hd %s %4d %36s %s %s/%s"
#define FMT_DIR_STR_NO_SFN      L"   %s %s %-16s %04x %-32s %4d %4d  %04x -------- %4d %8I64d %s %4d %s %6hu %s %s %8hd %s %8hd %s %4d %36s %s %s/%s"
#define FMT_FILE_STR_HEX L"   %s %s %16I64x %04x %-32s %-12s %4d %4d  %04x %s %4d %8I64x %s %4d %s %6hx %s %s %8hx %s %8hx %s %4d %36s %s %s/%s"
#define FMT_FILE_STR_HEX_NO_SFN L"   %s %s %16I64x %04x %-32s %4d %4d  %04x %s %4d %8I64x %s %4d %s %6hx %s %s %8hx %s %8hx %s %4d %36s %s %s/%s"
#define FMT_FILE_STR     L"   %s %s %16I64d %04x %-32s %-12s %4d %4d  %04x %s %4d %8I64d %s %4d %s %6hu %s %s %8hd %s %8hd %s %4d %36s %s %s/%s"
#define FMT_FILE_STR_NO_SFN     L"   %s %s %16I64d %04x %-32s %4d %4d  %04x %s %4d %8I64d %s %4d %s %6hu %s %s %8hd %s %8hd %s %4d %36s %s %s/%s"
#define BLANKTIMESTAMPWITHOUTMS L"                   "
#define BLANKTIMESTAMPWITHMS    L"                       "
#define BLANKTIMESTAMPWITHOUTS L"                "

#define FMT_CSV_DIR_STR      L"\"'%s%s\\'\",%s,%s,%s,%s,0x%04x,%d,%d,0x%04x,,%d,%I64d,%s,%d,%s,%hu,%s,%s,%hd,%s,%hd,%s,%d,%s,%s,%s,%s,%s"
#define FMT_CSV_DIR_STR_NO_SFN      L"\"'%s%s\\'\",%s,%s,%s,0x%04x,%d,%d,0x%04x,,%d,%I64d,%s,%d,%s,%hu,%s,%s,%hd,%s,%hd,%s,%d,%s,%s,%s,%s,%s" 	//No Short File Name
#define FMT_CSV_DIR_STR_NO_FST      L"\"'%s%s\\'\",%s,%s,%s,%s,0x%04x,%d,%d,0x%04x,,%d,%I64d,%s,%d,%s,%hu,%s,%s,%hd,%s,%hd,%s,%d,%s,%s,%s,%s"	//No File System Type
#define FMT_CSV_DIR_STR_NO_SFN_FST      L"\"'%s%s\\'\",%s,%s,%s,0x%04x,%d,%d,0x%04x,,%d,%I64d,%s,%d,%s,%hu,%s,%s,%hd,%s,%hd,%s,%d,%s,%s,%s,%s"		//No Short File Name and File System Type
#define FMT_CSV_FILE_STR     L"\"'%s%s'\",%s,%s,%s,%I64d,0x%04x,%d,%d,0x%04x,%s,%d,%I64d,%s,%d,%s,%hu,%s,%s,%hd,%s,%hd,%s,%d,%s,%s,%s,%s,%s"
#define FMT_CSV_FILE_STR_NO_SFN     L"\"'%s%s'\",%s,%s,%I64d,0x%04x,%d,%d,0x%04x,%s,%d,%I64d,%s,%d,%s,%hu,%s,%s,%hd,%s,%hd,%s,%d,%s,%s,%s,%s,%s" //No Short File Name
#define FMT_CSV_FILE_STR_NO_FST    L"\"'%s%s'\",%s,%s,%s,%I64d,0x%04x,%d,%d,0x%04x,%s,%d,%I64d,%s,%d,%s,%hu,%s,%s,%hd,%s,%hd,%s,%d,%s,%s,%s,%s" 	//No File System Type
#define FMT_CSV_FILE_STR_NO_SFN_FST     L"\"'%s%s'\",%s,%s,%I64d,0x%04x,%d,%d,0x%04x,%s,%d,%I64d,%s,%d,%s,%hu,%s,%s,%hd,%s,%hd,%s,%d,%s,%s,%s,%s"	//No Short File Name and File System Type

/*++

Routine Description:

    Prints out all the information about one directory entry.

Arguments:

    cwsDirPath - The path leading up to the entry

    psDirEntry - The directory entry information
    
Return Value:

    NONE

--*/
VOID 
CDumpEngine::PrintEntry(
    IN CFsdVolumeState *pcFsdVolState,
    IN const CBsString& cwsDirPath,
    IN INT cDirFileSpecLength,
    IN SDirectoryEntry *psDirEntry,
    IN BOOL bSingleEntryOutput    
    )
{
    WIN32_FILE_ATTRIBUTE_DATA *pFD = &psDirEntry->m_sFindData;
    LPWSTR pwszFmtStr;
    WCHAR wszCreationTime[32];    
    WCHAR wszLastWriteTime[32];    
 
    //
    //  Get the additional information about the file/dir
    //
    SFileExtendedInfo sExtendedInfo;
    ::GetExtendedFileInfo( m_pcParams, pcFsdVolState, cwsDirPath, bSingleEntryOutput, psDirEntry, &sExtendedInfo );

    //
    //  Convert the timestamps into formatted strings
    //
    if (    pFD->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY 
         && m_pcParams->m_bDontShowDirectoryTimestamps )
    {
        if ( m_pcParams->m_bDumpCommaDelimited )
        {
            wszCreationTime[0]  = L'\0';
            wszLastWriteTime[0] = L'\0';
        }
        else if ( m_pcParams->m_bAddMillisecsToTimestamps )
        {
            ::wcscpy( wszCreationTime, BLANKTIMESTAMPWITHMS );
            ::wcscpy( wszLastWriteTime, BLANKTIMESTAMPWITHMS );
        }
        else if ( m_pcParams->m_bAddSecsToTimestamps)
        {
            ::wcscpy( wszCreationTime, BLANKTIMESTAMPWITHOUTMS );
            ::wcscpy( wszLastWriteTime, BLANKTIMESTAMPWITHOUTMS );
        }
        else
        {
            ::wcscpy( wszCreationTime, BLANKTIMESTAMPWITHOUTS );
            ::wcscpy( wszLastWriteTime, BLANKTIMESTAMPWITHOUTS );
        }
    }
    else
    {
        TimeString( &psDirEntry->m_sFindData.ftCreationTime, 
            m_pcParams->m_bAddSecsToTimestamps,
            m_pcParams->m_bAddMillisecsToTimestamps, 
            wszCreationTime );
        TimeString( &psDirEntry->m_sFindData.ftLastWriteTime, 
            m_pcParams->m_bAddSecsToTimestamps,
            m_pcParams->m_bAddMillisecsToTimestamps, 
            wszLastWriteTime );
    }
    
    //
    //  Mask out the requested file attribute bits
    //
    pFD->dwFileAttributes &= ~m_pcParams->m_dwFileAttributesMask;
 
    m_ullNumBytesChecksummed          += sExtendedInfo.ullTotalBytesChecksummed;
    m_ullNumBytesTotalNamedDataStream += sExtendedInfo.ullTotalBytesNamedDataStream;
    if ( sExtendedInfo.lNumberOfLinks > 1 )
        ++m_ullNumHardLinks;
    if ( sExtendedInfo.lNumDACEs != -1 )
        m_ullNumDiscreteDACEs += sExtendedInfo.lNumDACEs;
    if ( sExtendedInfo.lNumSACEs != -1 )
        m_ullNumDiscreteSACEs += sExtendedInfo.lNumSACEs;
    if ( !sExtendedInfo.cwsObjectId.IsEmpty() )
        ++m_ullNumFilesWithObjectIds;
    
    WCHAR wszReparsePointTag[32];
    
    if ( sExtendedInfo.ulReparsePointTag == 0 )
    {
        if ( m_pcParams->m_bDumpCommaDelimited )
            wszReparsePointTag[0] = L'\0';
        else
            ::memcpy( wszReparsePointTag, L"--------", sizeof( WCHAR ) * 9 );
    }
    else
    {
        wsprintf( wszReparsePointTag, m_pcParams->m_pwszULongHexFmt, sExtendedInfo.ulReparsePointTag );
    }
    
    if ( pFD->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
    {
        LPWSTR pwszDirType;
        if ( pFD->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
            pwszDirType = JUNCTION_STR;
        else
            pwszDirType = DIR_STR;
        if ( m_pcParams->m_bDumpCommaDelimited )
        {
            	//
            	//  If single file output mode, then processing the root directory
            	//
            	if ( bSingleEntryOutput )
                	psDirEntry->m_cwsFileName = L".";
            
            	CBsString cwsFixedShortName;
            	if ( !psDirEntry->GetShortName().IsEmpty() )
            	{
                	cwsFixedShortName = L"\"'" + psDirEntry->GetShortName() + L"'\"";
            	}

            	if(!m_pcParams->m_bNoShortFileName && !m_pcParams->m_bNoFileSystemType)
            	{
	            m_pcParams->DumpPrintAlways( FMT_CSV_DIR_STR, 
	                            cwsDirPath.c_str() + cDirFileSpecLength,
	                            LPCWSTR( psDirEntry->GetFileName() ),
	                            LPCWSTR( cwsFixedShortName ),
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            pwszDirType,
	                            pFD->dwFileAttributes,
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            pcFsdVolState->GetFileSystemName(),
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
            	}
            	else if(m_pcParams->m_bNoShortFileName && m_pcParams->m_bNoFileSystemType)
            	{
			m_pcParams->DumpPrintAlways( FMT_CSV_DIR_STR_NO_SFN_FST, 
	                            cwsDirPath.c_str() + cDirFileSpecLength,
	                            LPCWSTR( psDirEntry->GetFileName() ),
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            pwszDirType,
	                            pFD->dwFileAttributes,
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
            	}
            	else if(m_pcParams->m_bNoShortFileName)
            	{
			m_pcParams->DumpPrintAlways( FMT_CSV_DIR_STR_NO_SFN, 
	                            cwsDirPath.c_str() + cDirFileSpecLength,
	                            LPCWSTR( psDirEntry->GetFileName() ),
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            pwszDirType,
	                            pFD->dwFileAttributes,
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            pcFsdVolState->GetFileSystemName(),
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
            	}
            	else if(m_pcParams->m_bNoFileSystemType)
            	{
			m_pcParams->DumpPrintAlways( FMT_CSV_DIR_STR, 
	                            cwsDirPath.c_str() + cDirFileSpecLength,
	                            LPCWSTR( psDirEntry->GetFileName() ),
	                            LPCWSTR( cwsFixedShortName ),
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            pwszDirType,
	                            pFD->dwFileAttributes,
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
            	}
        }
        else
        {
            	//
            	//  If single file output mode, then processing the root directory
            	//
            	if ( bSingleEntryOutput )
                	psDirEntry->m_cwsFileName = L".";
            
            	//
            	//  Print with quotes around the file name
            	//
            	WCHAR wszNameWithQuotes[ MAX_PATH + 2 ];
            	wszNameWithQuotes[ 0 ] = L'\'';
            	::wcscpy( wszNameWithQuotes + 1, psDirEntry->GetFileName() );
            	::wcscat( wszNameWithQuotes, L"\\\'" );
    
	     	if(!m_pcParams->m_bNoShortFileName)
	     	{
	            	if ( m_pcParams->m_bHex )
	                	pwszFmtStr = FMT_DIR_STR_HEX;
	            	else
	                	pwszFmtStr = FMT_DIR_STR;
	            	m_pcParams->DumpPrintAlways( pwszFmtStr, 
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            pwszDirType,
	                            pFD->dwFileAttributes,
	                            wszNameWithQuotes,
	                            LPCWSTR( psDirEntry->GetShortName() ),
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );	      
           	}
           	else
           	{
		  	if ( m_pcParams->m_bHex )
	                	pwszFmtStr = FMT_DIR_STR_HEX_NO_SFN;
	         	else
	                	pwszFmtStr = FMT_DIR_STR_NO_SFN;
	         	m_pcParams->DumpPrintAlways( pwszFmtStr, 
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            pwszDirType,
	                            pFD->dwFileAttributes,
	                            wszNameWithQuotes,
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
	        
        	}
        }
    }
    else
    {        
        ULONGLONG ullFileSize = ( ( (ULONGLONG)pFD->nFileSizeHigh ) << 32 ) + pFD->nFileSizeLow;
        
        if ( m_pcParams->m_bDumpCommaDelimited )
        {
            CBsString cwsFixedShortName;
            if ( !psDirEntry->GetShortName().IsEmpty() )
            {
                cwsFixedShortName = L"\"'" + psDirEntry->GetShortName() + L"'\"";
            }
            
	     if(!m_pcParams->m_bNoShortFileName && !m_pcParams->m_bNoFileSystemType)
	     {
	            m_pcParams->DumpPrintAlways( FMT_CSV_FILE_STR, 
	                            cwsDirPath.c_str() + cDirFileSpecLength,
	                            LPCWSTR( psDirEntry->GetFileName() ),
	                            LPCWSTR( cwsFixedShortName ),
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            ullFileSize,
	                            pFD->dwFileAttributes,
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.cwsUnnamedStreamChecksum.c_str(),
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            pcFsdVolState->GetFileSystemName(),
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
	     }
	     else if(m_pcParams->m_bNoShortFileName && m_pcParams->m_bNoFileSystemType)
	     {
			m_pcParams->DumpPrintAlways( FMT_CSV_FILE_STR_NO_SFN_FST, 
	                            cwsDirPath.c_str() + cDirFileSpecLength,
	                            LPCWSTR( psDirEntry->GetFileName() ),
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            ullFileSize,
	                            pFD->dwFileAttributes,
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.cwsUnnamedStreamChecksum.c_str(),
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
	     }
	     else if(m_pcParams->m_bNoShortFileName)
	     {
			m_pcParams->DumpPrintAlways( FMT_CSV_FILE_STR_NO_SFN, 
	                            cwsDirPath.c_str() + cDirFileSpecLength,
	                            LPCWSTR( psDirEntry->GetFileName() ),
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            ullFileSize,
	                            pFD->dwFileAttributes,
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.cwsUnnamedStreamChecksum.c_str(),
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            pcFsdVolState->GetFileSystemName(),
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
	     }
	     else if(m_pcParams->m_bNoFileSystemType)
	     {
			m_pcParams->DumpPrintAlways( FMT_CSV_FILE_STR_NO_FST, 
	                            cwsDirPath.c_str() + cDirFileSpecLength,
	                            LPCWSTR( psDirEntry->GetFileName() ),
	                            LPCWSTR( cwsFixedShortName ),
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            ullFileSize,
	                            pFD->dwFileAttributes,
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.cwsUnnamedStreamChecksum.c_str(),
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
	     }
        }
        else
        {
            //
            //  Print with quotes around the file name
            //
            WCHAR wszNameWithQuotes[ MAX_PATH + 2 ];
            wszNameWithQuotes[ 0 ] = L'\'';
            ::wcscpy( wszNameWithQuotes + 1, psDirEntry->GetFileName() );
            ::wcscat( wszNameWithQuotes, L"\'" );

	     if(!m_pcParams->m_bNoShortFileName)
	     {
	            if ( m_pcParams->m_bHex )
	                pwszFmtStr = FMT_FILE_STR_HEX;
	            else
	                pwszFmtStr = FMT_FILE_STR;

	            m_pcParams->DumpPrintAlways( pwszFmtStr, 
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            ullFileSize,
	                            pFD->dwFileAttributes,
	                            wszNameWithQuotes,
	                            LPCWSTR( psDirEntry->GetShortName() ),
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.cwsUnnamedStreamChecksum.c_str(),
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
	     }
	     else
	     {
			if ( m_pcParams->m_bHex )
	                pwszFmtStr = FMT_FILE_STR_HEX_NO_SFN;
	            else
	                pwszFmtStr = FMT_FILE_STR_NO_SFN;

	            m_pcParams->DumpPrintAlways( pwszFmtStr, 
	                            wszCreationTime,
	                            wszLastWriteTime,
	                            ullFileSize,
	                            pFD->dwFileAttributes,
	                            wszNameWithQuotes,
	                            sExtendedInfo.lNumDACEs,
	                            sExtendedInfo.lNumSACEs,
	                            sExtendedInfo.wSecurityDescriptorControl,
	                            sExtendedInfo.cwsUnnamedStreamChecksum.c_str(),
	                            sExtendedInfo.lNumNamedDataStreams,
	                            sExtendedInfo.ullTotalBytesNamedDataStream,
	                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
	                            sExtendedInfo.lNumPropertyStreams,
	                            wszReparsePointTag,
	                            sExtendedInfo.wReparsePointDataSize,
	                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
	                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
	                            sExtendedInfo.wDACLSize,
	                            sExtendedInfo.cwsDACLChecksum.c_str(),
	                            sExtendedInfo.wSACLSize,
	                            sExtendedInfo.cwsSACLChecksum.c_str(),
	                            sExtendedInfo.lNumberOfLinks,
	                            sExtendedInfo.cwsObjectId.c_str(),
	                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
	                            sExtendedInfo.cwsOwnerSid.c_str(),
	                            sExtendedInfo.cwsGroupSid.c_str() );
	     }
        }
    }
    
}


/*++

Routine Description:

    Formats dates into a common string format.

Arguments:

Return Value:

    <Enter return values here>

--*/
static VOID 
TimeString(
    IN FILETIME *pFileTime,
    IN BOOL bAddSecsToTimestamps,
    IN BOOL bAddMillisecsToTimestamps,
    OUT LPWSTR pwszTimeStr
    )
{
    SYSTEMTIME szTime;
        
    ::FileTimeToSystemTime( pFileTime, &szTime );
    if ( bAddMillisecsToTimestamps )
    {
    	wsprintf( pwszTimeStr,
    	        L"%02d/%02d/%02d %02d:%02d:%02d.%03d",
                szTime.wMonth,
                szTime.wDay,
                szTime.wYear,
                szTime.wHour,
                szTime.wMinute,
                szTime.wSecond,
                szTime.wMilliseconds );
    }
    else if(  bAddSecsToTimestamps )
    {
    	wsprintf( pwszTimeStr,
    	        L"%02d/%02d/%02d %02d:%02d:%02d",
                szTime.wMonth,
                szTime.wDay,
                szTime.wYear,
                szTime.wHour,
                szTime.wMinute,
                szTime.wSecond );
    }
    else
    {
    	wsprintf( pwszTimeStr,
    	        L"%02d/%02d/%02d %02d:%02d",
                szTime.wMonth,
                szTime.wDay,
                szTime.wYear,
                szTime.wHour,
                szTime.wMinute );
    }
}

LPCSTR 
CDumpEngine::GetHeaderInformation()
{
    LPSTR pszHeaderInfo = 
        "Creation date     - Creation date of the file/dir\n"
        "Last mod. date    - Last modification date of the file/dir\n"
        "FileSize          - Size of the unnamed data stream if a file\n"
        "Attr              - File attributes with Archive and Normal bits masked by\n"
        "                    default (hex)\n"
        "FileName          - Name of the file in single quotes\n"
        "ShortName         - The classic 8.3 file name.  If <->, FileName is in\n"
        "                    classic format\n"
        "DACE              - Number of discretionary ACL entries\n"
        "SACE              - Number of system ACL entries\n"
        "SDCtl             - Security Descripter control word (hex)\n"
        "UNamChkS          - Data checksum of the unnamed data stream (hex)\n"
        "DStr              - Number of named data streams\n"
        "DStrSize          - Size of all of the named data streams\n"
        "DStrChkS          - Data checksum of all named data streams including their\n"
        "                    names (hex)\n"
        "Prop              - Number of property data streams\n"
        "RPTag             - Reparse point tag value (hex)\n"
        "RPSize            - Size of reparse point data\n"
        "RPChkS            - Checksum of the reparse point data (hex)\n"
        "EncrChkS          - Raw encrypted data checksum (hex)\n"
        "DACLSize          - Size of the complete discretionary ACL\n"
        "DACLChkS          - Checksum of the complete discretionary ACL (hex)\n"
        "SACLSize          - Size of the complete system ACL\n"
        "SACLChkS          - Checksum of the complete system ACL (hex)\n"
        "NLnk              - Number of hard links\n"
        "ObjectId          - Object Id GUID on the file if it has one\n"
        "OIDChkS           - Object Id extended data checksum\n"
        "FS                - Type of file system (in CSV format only)\n"
        "OwnerSid/GroupSid - The owner and group sid values\n";
    
    return pszHeaderInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\exclproc.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    exclproc.cpp

Abstract:

    Exclude processing mechanism.  Processes the FilesNotToBackup key and
    zero or more exclude files with exclude rules.

Author:

    Stefan R. Steiner   [ssteiner]        03-21-2000

Revision History:

--*/

#include "stdafx.h"
#include "match.h"

#include <shlobj.h>

static VOID 
FsdExpandEnvironmentStrings( 
    IN LPCWSTR pwszInput, 
    OUT CBsString &cwsExpandedStr
    );

static BOOL
FsdEnsureLongNames(
    IN OUT CBsString& exclude_spec 
    );

SFsdExcludeRule::~SFsdExcludeRule()
{ 
    delete( psVolId ); 
    psVolId = NULL;
}

/*++

Routine Description:

    Prints out information about one rule.  If the rule caused files to be excluded
    it prints out those file too.

Arguments:

Return Value:

    <Enter return values here>

--*/
VOID
SFsdExcludeRule::PrintRule(
    IN FILE *fpOut,
    IN BOOL bInvalidRulePrint
    )
{
    if ( bInvalidRulePrint )
    {
        if ( bInvalidRule )
            fwprintf( fpOut, L"%-24s  %-32s '%s'\n", 
                cwsExcludeFromSource.c_str(), cwsExcludeDescription.c_str(), cwsExcludeRule.c_str() );
    }
    else
    {
        //
        //  Iterate though excluded file list
        //
        CBsString cwsExcludedFile;
        CVssDLListIterator< CBsString > cExcludedFilesIter( cExcludedFileList );
        if ( cExcludedFilesIter.GetNext( cwsExcludedFile ) )
        {
            //
            //  At least one file excluded, print the header for the rule
            //
            fwprintf( fpOut, L"%-24s  %-32s '%s'\n", 
                cwsExcludeFromSource.c_str(), cwsExcludeDescription.c_str(), cwsExcludeRule.c_str() );

            //
            //  Now iterate
            //
            do 
            {
                fwprintf( fpOut, L"\t%s\n", cwsExcludedFile.c_str() );
            } while( cExcludedFilesIter.GetNext( cwsExcludedFile ) );
        }
    }
}
    
CFsdExclusionManager::CFsdExclusionManager(
        IN CDumpParameters *pcDumpParameters
        ) : m_pcParams( pcDumpParameters )
{
    if ( !m_pcParams->m_bDontUseRegistryExcludes )
    {
        ProcessRegistryExcludes( HKEY_LOCAL_MACHINE, L"HKEY_LOCAL_MACHINE" );
        ProcessRegistryExcludes( HKEY_CURRENT_USER,  L"HKEY_CURRENT_USER" );
    }
    
    CBsString cwsEXEFileStreamExcludeFile( m_pcParams->m_cwsArgv0 + L":ExcludeList" );
    if ( ProcessOneExcludeFile( cwsEXEFileStreamExcludeFile ) == FALSE )
        m_pcParams->DumpPrint( L"        NOTE: Exclude file: '%s' not found", 
            cwsEXEFileStreamExcludeFile.c_str() );
       
    ProcessExcludeFiles( m_pcParams->m_cwsFullPathToEXE );
    
    CompileExclusionRules();
}

CFsdExclusionManager::~CFsdExclusionManager()
{
    SFsdExcludeRule *pER;

    //
    //  Iterate through the exclude rule list and delete each element
    //
    CVssDLListIterator< SFsdExcludeRule * > cExclRuleIter( m_cCompleteExcludeList );
    while( cExclRuleIter.GetNext( pER ) )
        delete pER;
}

VOID
CFsdExclusionManager::ProcessRegistryExcludes( 
    IN HKEY hKey,
    IN LPCWSTR pwszFromSource
    )
{
    LPWSTR buffer ;
    HKEY   key = NULL ;
    DWORD  stat ;
    DWORD  dwDisposition ;
    DWORD  dwDataSize;
    DWORD  dwIndex = 0;
    HRESULT hr = S_OK;
    
    m_pcParams->DumpPrint( L"        Processing FilesNotToBackup reg key in %s", pwszFromSource );

    buffer = new WCHAR[ FSD_MAX_PATH ];
    if ( buffer == NULL )
        throw E_OUTOFMEMORY;

    try
    {
        stat = ::RegOpenKeyEx( hKey,
                    FSD_REG_EXCLUDE_PATH,
                    0,
                    KEY_READ,
                    &key ) ;

        dwIndex = 0 ;
        while ( stat == ERROR_SUCCESS ) 
        {
            WCHAR pwszValue[ MAX_PATH ];
            DWORD dwValSize = MAX_PATH;  // prefix #118830
            DWORD dwType;

            dwDataSize = FSD_MAX_PATH; // prefix #118830

            stat = ::RegEnumValueW( key,
                        dwIndex,
                        pwszValue,
                        &dwValSize,
                        NULL,
                        &dwType,
                        (LPBYTE)buffer, 
                        &dwDataSize ) ;
            dwIndex++;

            if ( ( stat == ERROR_SUCCESS ) && ( dwType == REG_MULTI_SZ ) ) 
            {
                LPWSTR p = buffer;
                while ( *p ) 
                {
                    SFsdExcludeRule *psExclRule;

                    //
                    //  Now load up the exclude rule with the unprocessed 
                    //  information
                    //
                    psExclRule = new SFsdExcludeRule;
                    if ( psExclRule == NULL )
                        throw E_OUTOFMEMORY;                
                    psExclRule->cwsExcludeFromSource = pwszFromSource;
                    psExclRule->cwsExcludeDescription = pwszValue;
                    psExclRule->cwsExcludeRule = p;
                    
                    if ( m_pcParams->m_bPrintDebugInfo || m_pcParams->m_bNoHeaderFooter )
                    {
                        m_pcParams->DumpPrint( L"            \"%s\" \"%s\"", 
                            pwszValue, p );
                    }
                    
                    m_cCompleteExcludeList.AddTail( psExclRule );                    
                    p += ::wcslen( p ) + 1;
                }
            }

        }
    }
    catch ( HRESULT hrCaught )
    {
        hr = hrCaught;
    }
    catch ( ... )
    {
        hr = E_UNEXPECTED;
    }
    
    if ( key != NULL )
    {
        ::RegCloseKey( key ) ;
        key = NULL ;
    }

    delete [] buffer ;

    if ( FAILED( hr ) )
        throw hr;
}


VOID 
CFsdExclusionManager::ProcessExcludeFiles( 
    IN const CBsString& cwsPathToExcludeFiles
    )
{
    HANDLE hFind = INVALID_HANDLE_VALUE;    

    try
    {
        //
        //  Iterate through all files in the directory looking for
        //  files with .exclude extensions
        //
        DWORD dwRet;
        WIN32_FIND_DATAW sFindData;
        hFind = ::FindFirstFileExW( 
                    cwsPathToExcludeFiles + L"*.exclude",
                    FindExInfoStandard,
                    &sFindData,
                    FindExSearchNameMatch,
                    NULL,
                    0 );
        if ( hFind == INVALID_HANDLE_VALUE )
        {
            dwRet = ::GetLastError();
            if ( dwRet == ERROR_NO_MORE_FILES || dwRet == ERROR_FILE_NOT_FOUND )
                return;
            else
            {
                m_pcParams->ErrPrint( L"CFsdExclusionManager::ProcessExcludeFiles - FindFirstFileEx( '%s' ) returned: dwRet: %d, skipping looking for .exclude files", 
                    cwsPathToExcludeFiles.c_str(), ::GetLastError() );
                return;
            }
        }

        //
        //  Now run through the directory
        //
        do
        {
            //  Check and make sure the file such as ".", ".." and dirs are not considered
    	    if( ::wcscmp( sFindData.cFileName, L".") != 0 &&
    	        ::wcscmp( sFindData.cFileName, L"..") != 0 &&
                !( sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
    	        {
    	            ProcessOneExcludeFile( cwsPathToExcludeFiles + sFindData.cFileName );
    	        }
        } while ( ::FindNextFile( hFind, &sFindData ) );
    }
    catch ( ... )
    {
        m_pcParams->ErrPrint( L"CFsdExclusionManager::ProcessExcludeFiles: Caught an unknown exception, dirPath: '%s'", cwsPathToExcludeFiles.c_str() );
    }

    if ( hFind != INVALID_HANDLE_VALUE )
        ::FindClose( hFind );
}


BOOL 
CFsdExclusionManager::ProcessOneExcludeFile(
    IN const CBsString& cwsExcludeFileName
    )
{
    FILE *fpExclFile;
    
    fpExclFile = ::_wfopen( cwsExcludeFileName, L"r" );
    if ( fpExclFile == NULL )
    {
        return FALSE;
    }
    
    m_pcParams->DumpPrint( L"        Processing exclude file: '%s'", cwsExcludeFileName.c_str() );

    CBsString cwsInputLine;
    while( ::fgetws( cwsInputLine.GetBuffer( FSD_MAX_PATH), FSD_MAX_PATH, fpExclFile ) )
    {
        cwsInputLine.ReleaseBuffer();
        cwsInputLine = cwsInputLine.Left( cwsInputLine.GetLength() - 1 );  //  get rid of '\n'
        cwsInputLine.TrimLeft();
        cwsInputLine.TrimRight();

        //
        //  See if it is a comment, either // or #
        //
        if ( cwsInputLine[ 0 ] == L'#' || cwsInputLine.Left( 2 ) == L"//" 
             || cwsInputLine.IsEmpty() )
            continue;
        
        if ( m_pcParams->m_bPrintDebugInfo || m_pcParams->m_bNoHeaderFooter )
        {
            m_pcParams->DumpPrint( L"            %s", cwsInputLine.c_str() );
        }

        CBsString cwsLine( cwsInputLine );
        SFsdExcludeRule *psExclRule;
        psExclRule = new SFsdExcludeRule;
        if ( psExclRule == NULL )
        {
            ::fclose( fpExclFile );
            throw E_OUTOFMEMORY;
        }
        
        INT iLeft;
        INT iRight;
        //
        //  This is gross.  With the updated string class, this can
        //  be simplified.
        //
        iLeft = cwsLine.Find( L'\"' );
        if ( iLeft != -1 )
        {
            cwsLine = cwsLine.Mid( iLeft + 1 );
            iRight = cwsLine.Find( L'\"' );
            if ( iRight != -1 )
            {
                psExclRule->cwsExcludeDescription = cwsLine.Left( iRight );
                cwsLine = cwsLine.Mid( iRight + 1 );
                iLeft = cwsLine.Find( L'\"' );
                if ( iLeft != -1 )
                {
                    cwsLine = cwsLine.Mid( iLeft + 1 );
                    iRight = cwsLine.Find( L'\"' );
                    if ( iRight != -1 )
                    {
                        psExclRule->cwsExcludeRule = cwsLine.Left( iRight );
                        psExclRule->cwsExcludeFromSource = cwsExcludeFileName.c_str() + cwsExcludeFileName.ReverseFind( L'\\' ) + 1;
                        m_cCompleteExcludeList.AddTail( psExclRule );                    
                        continue;                        
                    }
                }
            }
        }
        else
        {
            m_pcParams->ErrPrint( L"Parse error in exclusion rule file '%s', rule text '%s', skipping", 
                cwsExcludeFileName.c_str(), cwsInputLine.c_str() );
        }
        
        delete psExclRule;
    }

    ::fclose( fpExclFile );

    return TRUE;
}


VOID
CFsdExclusionManager::CompileExclusionRules()
{
    SFsdExcludeRule *psER;

    //
    //  Iterate through the exclude rule list and compile each rule
    //
    CVssDLListIterator< SFsdExcludeRule * > cExclRuleIter( m_cCompleteExcludeList );
    CBsString cws;
    
    if ( m_pcParams->m_bPrintDebugInfo )
        wprintf( L"Exclusion rule debug info:\n" );
    
    while( cExclRuleIter.GetNext( psER ) )
    {
        INT i;
        
        ::FsdExpandEnvironmentStrings( psER->cwsExcludeRule, cws );

        if ( m_pcParams->m_bPrintDebugInfo )
        {
            wprintf( L"\t%s : %s : %s : %s", psER->cwsExcludeFromSource.c_str(),
                psER->cwsExcludeDescription.c_str(), psER->cwsExcludeRule.c_str(),
                cws.c_str() );
        }
        
        //
        //  Get rid of leading spaces and lower case the whole mess
        //
        cws.TrimLeft();
        cws.MakeUpper();
        
        //
        //  First see if /s is at end of string
        //
        i = cws.Find( L"/S" );
        if ( i > 0 )
        {
            cws = cws.Left( i );
            psER->bInclSubDirs = TRUE;
        }
        cws.TrimRight();

        //
        //  Now see if there are any wildcards
        //
        i = cws.FindOneOf( L"*?" );
        if ( i != -1 )
        {
            psER->bWCInFileName = TRUE;
        }

        //
        //  Now see if this is for any volume
        //
        if ( cws.GetLength() >= 2 && cws[0] == L'\\' && cws[1] != L'\\' )
            psER->bAnyVol = TRUE;
        else if ( cws.GetLength() >= 2 && cws[1] != L':' )
            psER->bAnyVol = TRUE;

        if ( psER->bAnyVol )
        {
            if ( cws[0] == L'\\' )
            {
                //  Get rid of first '\'
                cws = cws.Mid( 1 );
            }
        }
        else
        {
            //
            //  Specific volume case
            //
            CBsString cwsVolPath;
            
            psER->psVolId = new SFsdVolumeId;
            if ( psER->psVolId == NULL )  // Prefix 118832
            {
                m_pcParams->ErrPrint( L"CFsdExclusionManager::CompileExclusionRules - out of memory" );
                throw E_OUTOFMEMORY;  // Prefix #118832
            }
            
            if ( CFsdVolumeStateManager::GetVolumeIdAndPath( m_pcParams, cws, psER->psVolId, cwsVolPath ) != ERROR_SUCCESS )
                psER->bInvalidRule = TRUE;            
            else
            {
                //
                //  Slice off the volume part of the path
                //
                cws = cws.Mid( cwsVolPath.GetLength() );                
            }
        }
            
        INT iFileNameOffset;
        iFileNameOffset = cws.ReverseFind( L'\\' );
        if ( iFileNameOffset == -1 )
        {
            //
            //  No dirpath
            //
            // psER->cwsDirPath = L"\\";
            psER->cwsFileNamePattern = cws;
        }
        else
        {
            psER->cwsFileNamePattern = cws.Mid( iFileNameOffset + 1 );
            psER->cwsDirPath = cws.Left( iFileNameOffset + 1 );
        }                        

        //
        //  Now convert the file name pattern into a form that the pattern matcher
        //  can use.
        //
        ::FsdRtlConvertWildCards( psER->cwsFileNamePattern );
        
        if ( m_pcParams->m_bPrintDebugInfo )
        {
            if ( psER->bInclSubDirs )
                wprintf( L" - SubDir" );
            
            if ( psER->bWCInFileName )
                wprintf( L" - WC" );
                
            if ( psER->bAnyVol )
                wprintf( L" - AnyVol" );
            
            wprintf( L" - VolId: 0x%08x,  DirPath: '%s', FileName: '%s'", 
                ( psER->psVolId ) ? psER->psVolId->m_dwVolSerialNumber : 0xFFFFFFFF,
                psER->cwsDirPath.c_str(), psER->cwsFileNamePattern.c_str() );

            if ( psER->bInvalidRule )
                wprintf( L" - ERROR, invalid rule" );
            wprintf( L"\n" );
        }        
    }

}

VOID 
CFsdExclusionManager::GetFileSystemExcludeProcessor(
    IN CBsString cwsVolumePath,
    IN SFsdVolumeId *psVolId,
    OUT CFsdFileSystemExcludeProcessor **ppcFSExcludeProcessor
    )
{
    CFsdFileSystemExcludeProcessor *pExclProc;
    *ppcFSExcludeProcessor = NULL;
    
    //
    //  Get a new exclude processor for the file system
    //
    pExclProc = new CFsdFileSystemExcludeProcessor( m_pcParams, cwsVolumePath, psVolId );
    if ( pExclProc == NULL )
    {
        m_pcParams->ErrPrint( L"CFsdExclusionManager::CFsdGetFileSystemExcludeProcessor - Could not new a CFsdFileSystemExcludeProcessor object" );
        throw E_OUTOFMEMORY;
    }
        
    SFsdExcludeRule *pER;

    //
    //  Now go through the complete exclude list to find exclude rules that are relevant to
    //  this file system
    //
    CVssDLListIterator< SFsdExcludeRule * > cExclRuleIter( m_cCompleteExcludeList );
    while( cExclRuleIter.GetNext( pER ) )
    {
        if ( !pER->bInvalidRule )
        {
            if ( pER->bAnyVol || pER->psVolId->IsEqual( psVolId ) )
            {
                pExclProc->m_cFSExcludeList.AddTail( pER );
            }
        }
    }

    *ppcFSExcludeProcessor = pExclProc;
}   


/*++

Routine Description:

    Goes through the list of exclusion rules and dumps information about each.

Arguments:

Return Value:

    <Enter return values here>

--*/
VOID
CFsdExclusionManager::PrintExclusionInformation()
{
    SFsdExcludeRule *pER;

    CVssDLListIterator< SFsdExcludeRule * > cExclRuleIter( m_cCompleteExcludeList );

    m_pcParams->DumpPrint( L"" );
    m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
    m_pcParams->DumpPrint( L"Invalid exclusion rules (invalid because volume not found or parsing error)" );
    m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
    m_pcParams->DumpPrint( L"From                      Application                      Exclusion rule" );
    while( cExclRuleIter.GetNext( pER ) )
        pER->PrintRule( m_pcParams->GetDumpFile(), TRUE );
    
    m_pcParams->DumpPrint( L"" );
    m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
    m_pcParams->DumpPrint( L"Files excluded by valid exclusion rule" );  
    m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
    m_pcParams->DumpPrint( L"From                      Application                      Exclusion rule" );
    cExclRuleIter.Reset();
    while( cExclRuleIter.GetNext( pER ) )
        pER->PrintRule( m_pcParams->GetDumpFile(), FALSE );
}


CFsdFileSystemExcludeProcessor::CFsdFileSystemExcludeProcessor(
    IN CDumpParameters *pcDumpParameters,
    IN const CBsString& cwsVolumePath,
    IN SFsdVolumeId *psVolId 
    ) : m_pcParams( pcDumpParameters ),
        m_cwsVolumePath( cwsVolumePath),
        m_psVolId( NULL )
{
    m_psVolId = new SFsdVolumeId;
    if ( m_psVolId == NULL )  // Prefix #118829
        throw E_OUTOFMEMORY;
    *m_psVolId = *psVolId;
}

CFsdFileSystemExcludeProcessor::~CFsdFileSystemExcludeProcessor()
{
    delete m_psVolId;
}

BOOL 
CFsdFileSystemExcludeProcessor::IsExcludedFile(
    IN const CBsString &cwsFullDirPath,
    IN DWORD dwEndOfVolMountPointOffset,
    IN const CBsString &cwsFileName
    )
{
    BOOL bFoundMatch = FALSE;
    SFsdExcludeRule *pER;
    CBsString cwsUpperFileName( cwsFileName );
    CBsString cwsDirPath( cwsFullDirPath.Mid( dwEndOfVolMountPointOffset ) );
    cwsUpperFileName.MakeUpper();    //  Make uppercased for match check
    cwsDirPath.MakeUpper();
    
    //  wprintf( L"Exclude proc: DirPath: %s, fileName: %s\n", cwsDirPath.c_str(), cwsUpperFileName.c_str() );
    CVssDLListIterator< SFsdExcludeRule * > cExclRuleIter( m_cFSExcludeList );
    while( !bFoundMatch && cExclRuleIter.GetNext( pER ) )
    {
        if ( pER->bInclSubDirs )
        {
            //
            //  First check most common case \XXX /s
            //
            if ( pER->cwsDirPath.GetLength() != 0 )
            {
                if ( ::wcsncmp( pER->cwsDirPath.c_str(), cwsDirPath.c_str(), pER->cwsDirPath.GetLength() ) != 0 )
                    continue;                    
            }
        }
        else
        {
            //
            //  Fixed path check
            //
            if ( pER->cwsDirPath != cwsDirPath )
            {
                continue;
            }
        }
        
        if ( pER->bWCInFileName )
        {
            //
            //  Pattern match check
            //
            if ( ::FsdRtlIsNameInExpression( pER->cwsFileNamePattern, cwsUpperFileName ) )
                bFoundMatch = TRUE;
        }
        else
        {
            //
            //  Constant string match
            //
            if ( pER->cwsFileNamePattern == cwsUpperFileName )
                bFoundMatch = TRUE;
        }
    }

    if ( bFoundMatch )
    {
        pER->cExcludedFileList.AddTail( cwsFullDirPath + cwsFileName );
        if ( m_pcParams->m_bPrintDebugInfo )
            wprintf( L"  EXCLUDING: %s%s\n", cwsFullDirPath.c_str(), cwsFileName.c_str() );
    }
    return bFoundMatch;
}

static VOID 
FsdExpandEnvironmentStrings( 
    IN LPCWSTR pwszInput, 
    OUT CBsString &cwsExpandedStr
    )
{
    BOOL isOK = FALSE;
          
    LPWSTR pwszBuffer;
    DWORD  dwSize = ::ExpandEnvironmentStringsW( pwszInput, NULL, 0 ) ;

    if ( pwszBuffer = cwsExpandedStr.GetBufferSetLength( dwSize + 1 ) )
    {
        isOK = ( 0 != ::ExpandEnvironmentStringsW( pwszInput, pwszBuffer, dwSize ) ) ;
        cwsExpandedStr.ReleaseBuffer( ) ;
    }

    if ( !isOK )
    {
        // have never seen ExpandEnvironmentStrings fail... even with undefined env var... but just in case 
        cwsExpandedStr = pwszInput ;
    }

    ::FsdEnsureLongNames( cwsExpandedStr );
}


/*++

Routine Description:

    Originally from NtBackup.
    This takes a path with short name components and expands them to long
    name components.  The path obviously has to exist on the system to expand
    short names.
    Uses a little shell magic (yuck) to translate it into a long name.
    
Arguments:

Return Value:

    TRUE if expanded properly

--*/
static BOOL
FsdEnsureLongNames(
    IN OUT CBsString& exclude_spec 
    )
{
    IShellFolder * desktop ;
    ITEMIDLIST *   id_list ;
    ULONG          parsed_ct = 0 ;
    BOOL           isOK = FALSE ;  //  initialize it, prefix bug # 180281
    CBsString      path ;
    int            last_slash ;

    // strip off the filename, and all that other detritus...
    path = exclude_spec ;
    if ( -1 != ( last_slash = path.ReverseFind( TEXT( '\\' ) ) ) )
    {
        path = path.Left( last_slash ) ;

        if ( SUCCEEDED( SHGetDesktopFolder( &desktop ) ) )
        {
            WCHAR *    ptr = path.GetBufferSetLength( FSD_MAX_PATH ) ;

            if ( SUCCEEDED( desktop->ParseDisplayName( NULL, NULL, ptr, &parsed_ct, &id_list, NULL ) ) )
            {
                IMalloc * imalloc ;

                isOK = SHGetPathFromIDList( id_list, ptr ) ;

                SHGetMalloc( &imalloc ) ;
                imalloc->Free( id_list ) ;
                imalloc->Release( ) ;
            }

            path.ReleaseBuffer( ) ;
            desktop->Release( ) ;
        }

        if ( isOK )
        {
            // put it back together with the new & improved path...
            exclude_spec = path + exclude_spec.Mid( last_slash ) ;
        }
    }

    return isOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\bsfixalloc.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bsfixalloc.cpp

Abstract:

    Adapted from MFC 6 SR 1 release of fixalloc.cpp.  Removed all MFC stuff.

Author:

    Stefan R. Steiner   [ssteiner]        4-10-2000

Revision History:

--*/

// fixalloc.cpp - implementation of fixed block allocator

#include "stdafx.h"
#include "bsfixalloc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

// #define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// CBsFixedAlloc

CBsFixedAlloc::CBsFixedAlloc(UINT nAllocSize, UINT nBlockSize)
{
	ASSERT(nAllocSize >= sizeof(CNode));
	ASSERT(nBlockSize > 1);
    //wprintf( L"CBsFixedAlloc called, nAllocSize: %d, nBlockSize: %d\n", nAllocSize, nBlockSize );
	m_nAllocSize = nAllocSize;
	m_nBlockSize = nBlockSize;
	m_pNodeFree = NULL;
	m_pBlocks = NULL;
	InitializeCriticalSection(&m_protect);
}

CBsFixedAlloc::~CBsFixedAlloc()
{
	FreeAll();
	DeleteCriticalSection(&m_protect);
}

void CBsFixedAlloc::FreeAll()
{
	EnterCriticalSection(&m_protect);
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
	m_pNodeFree = NULL;
	LeaveCriticalSection(&m_protect);
}

void* CBsFixedAlloc::Alloc()
{
	EnterCriticalSection(&m_protect);
	if (m_pNodeFree == NULL)
	{
		CBsPlex* pNewBlock = NULL;
		try
		{
			// add another block
			pNewBlock = CBsPlex::Create(m_pBlocks, m_nBlockSize, m_nAllocSize);
            //wprintf( L"Alloc getting more core, nAllocSize: %d\n", m_nAllocSize );
		}
		catch( ... )
		{
			LeaveCriticalSection(&m_protect);
			throw;
		}

		// chain them into free list
		CNode* pNode = (CNode*)pNewBlock->data();
		// free in reverse order to make it easier to debug
		(BYTE*&)pNode += (m_nAllocSize * m_nBlockSize) - m_nAllocSize;
		for (int i = m_nBlockSize-1; i >= 0; i--, (BYTE*&)pNode -= m_nAllocSize)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	// remove the first available node from the free list
	void* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;

	LeaveCriticalSection(&m_protect);
	return pNode;
}

void CBsFixedAlloc::Free(void* p)
{
	if (p != NULL)
	{
		EnterCriticalSection(&m_protect);

		// simply return the node to the free list
		CNode* pNode = (CNode*)p;
		pNode->pNext = m_pNodeFree;
		m_pNodeFree = pNode;
		LeaveCriticalSection(&m_protect);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBsPlex
// throws E_OUTOFMEMORY

CBsPlex* PASCAL CBsPlex::Create(CBsPlex*& pHead, UINT nMax, UINT cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	CBsPlex* p = (CBsPlex*) new BYTE[sizeof(CBsPlex) + nMax * cbElement];
	if ( p == NULL )    //  prefix #118827
	    throw E_OUTOFMEMORY;
	
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CBsPlex::FreeDataChain()     // free this one and links
{
	CBsPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CBsPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\direntrs.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    direntrs.cpp

Abstract:

    Implementation of the directory entries class.  Given a path to a directory, 
    creates two linked lists, one a list of all sub-directories (including 
    mountpoints) and another a list of non-directories.

Author:

    Stefan R. Steiner   [ssteiner]        02-21-2000

Revision History:

--*/

#include "stdafx.h"

#include "direntrs.h"

/*++

Routine Description:

    Constructor for CDirectoryEntries.

Arguments:

    pcDumpParameters - The command-line dump parameters block

    cwsDirPath - The path to the directory or file to get the directory
        entries for.
        
Return Value:

    Can throw an exception.  DWORD Win32 error only.

--*/
CDirectoryEntries::CDirectoryEntries(
    IN CDumpParameters *pcDumpParameters,
    IN const CBsString& cwsDirPath
    ) : m_pcParams( pcDumpParameters ),
        m_cwsDirPath( cwsDirPath )
{
    DWORD dwRet;
    
    dwRet = GetDirectoryEntries();
    if ( dwRet != ERROR_SUCCESS )
        throw( dwRet );
}


/*++

Routine Description:

    Destructor for the CDirectoryEntries class

Arguments:

    NONE
    
Return Value:

    NONE

--*/
CDirectoryEntries::~CDirectoryEntries()
{
    SDirectoryEntry *pDE;

    //
    //  Iterate through the sub-directory list and delete each element
    //
    CVssDLListIterator< SDirectoryEntry * > cDirListIter( m_cDirList );
    while( cDirListIter.GetNext( pDE ) )
        delete pDE;    

    //
    //  Iterate through the file list and delete each element
    //
    CVssDLListIterator< SDirectoryEntry * > cFileListIter( m_cFileList );
    while( cFileListIter.GetNext( pDE ) )
        delete pDE;
}


/*++

Routine Description:

    Performs the actual retrieval of directory entries.    

Arguments:

    NONE
    
Return Value:

    Any DWORD WIN32 error

--*/
DWORD
CDirectoryEntries::GetDirectoryEntries()
{
    DWORD dwRet = ERROR_SUCCESS;
    HANDLE hFind;

    try
    {
        WIN32_FIND_DATAW sFindData;
                
        //
        //  Now enumerate the directory list
        //
        hFind = ::FindFirstFileEx( 
                    m_cwsDirPath,
                    FindExInfoStandard,
                    &sFindData,
                    FindExSearchNameMatch,
                    NULL,
                    0 );
        if ( hFind == INVALID_HANDLE_VALUE )
        {
            dwRet = ::GetLastError();
            if ( dwRet == ERROR_NO_MORE_FILES || dwRet == ERROR_FILE_NOT_FOUND )
                return 0;
            else
            {
                //  Calling code will print out an error message if necessary
                return dwRet;
            }
        }

        //
        //  Now run through the directory
        //
        do
        {
            //  Check and make sure the file such as "." and ".." are not considered
    	    if( ::wcscmp( sFindData.cFileName, L".") != 0 &&
    	        ::wcscmp( sFindData.cFileName, L"..") != 0 )
    	    {
                SDirectoryEntry *psDirEntry;
                psDirEntry = new SDirectoryEntry;
                if ( psDirEntry == NULL )
                {
                    dwRet = ::GetLastError();
                    m_pcParams->ErrPrint( L"GetDirectoryEntries: dirPath: '%s', new() returned dwRet: %d", m_cwsDirPath.c_str(), dwRet );
                    ::FindClose( hFind );    
                    return dwRet;
                }

                //
                //  NOTE!!  The following cast makes the assumption that WIN32_FILE_ATTRIBUTE_DATA
                //  is a subset of WIN32_FIND_DATAW
                //
                psDirEntry->m_sFindData = *( WIN32_FILE_ATTRIBUTE_DATA * )&sFindData;
                
                psDirEntry->m_cwsFileName = sFindData.cFileName;

                //
                //  Short name is empty if the file name is a conformant 8.3 name.
                //
                if ( sFindData.cAlternateFileName[0] != L'\0' )
                    psDirEntry->m_cwsShortName = sFindData.cAlternateFileName;                    
                
    	        if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
    	        {
    	            //
    	            //  Add to directory list
    	            //
    	            m_cDirList.AddTail( psDirEntry );
    	        }
    	        else
    	        {
    	            //
    	            //  Add to file list
    	            //
    	            m_cFileList.AddTail( psDirEntry );    	            
    	        }
     	    }
        } while ( ::FindNextFile( hFind, &sFindData ) );

        dwRet = ::GetLastError();
        if ( dwRet == ERROR_NO_MORE_FILES )
            dwRet = ERROR_SUCCESS;
        else
            m_pcParams->ErrPrint( L"GetDirectoryEntries: Got an unexpected error, FindNextFile('%s'), dwRet: %d", m_cwsDirPath.c_str(), dwRet );
    }
    catch ( DWORD dwRetThrown )
    {
        dwRet = dwRetThrown;
        m_pcParams->ErrPrint( L"GetDirectoryEntries: Caught an exception, dirPath: '%s', dwRet: %d", m_cwsDirPath.c_str(), dwRet );
    }
    catch ( ... )
    {
        dwRet = ::GetLastError();
        m_pcParams->ErrPrint( L"GetDirectoryEntries: Caught an unknown exception, dirPath: '%s'", m_cwsDirPath.c_str() );
    }

    ::FindClose( hFind );    

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\inc\vs_list.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    vs_list.h

Abstract:

    CVssDLList definition

Author:

    Adi Oltean  [aoltean]  11/23/1999

Revision History:

    Stefan Steiner  [ssteiner]  02-21-2000
        Removed VolSnapshot specific code to reuse for fsdump.  Added
        the optional compiling of the signature checking code.
        
--*/

#ifndef __VSS_DLLIST_HXX__
#define __VSS_DLLIST_HXX__

#if _MSC_VER > 1000
#pragma once
#endif

typedef PVOID VS_COOKIE;

/////////////////////////////////////////////////////////////////////////////
// Constants

const VS_COOKIE VS_NULL_COOKIE = NULL;

const DWORD VS_ELEMENT_SIGNATURE = 0x47e347e4;


/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T> class CVssDLList;
template <class T> class CVssDLListIterator;
template <class T> class CVssDLListElement;


/////////////////////////////////////////////////////////////////////////////
// CVssDLList


template <class T>
class CVssDLList
{
// Constructors& Destructors
private:
	CVssDLList(const CVssDLList&);

public:
	CVssDLList(): 
		m_pFirst(NULL), m_pLast(NULL), m_dwNumElements( 0 ) {};

	~CVssDLList()
	{
		ClearAll();
	}

// Attributes
public:

	bool IsEmpty() const;

    DWORD Size() { return m_dwNumElements; }
    
// Operations
public:

	VS_COOKIE Add( 
		IN	const T& object
		);

	VS_COOKIE AddTail( 
		IN	const T& object
		);

	bool Extract( 
		OUT	T& refObject
		);

	bool ExtractTail( 
		OUT	T& refObject
		);

	void ExtractByCookie( 
		IN	VS_COOKIE cookie,
		OUT	T& refObject
		);

	void ClearAll();

private:

	bool IsValid() const;

// Data members
private:
	CVssDLListElement<T>* m_pFirst;
	CVssDLListElement<T>* m_pLast;
    DWORD m_dwNumElements;
	friend class CVssDLListIterator<T>;
};


/////////////////////////////////////////////////////////////////////////////
// CVssDLListIterator

template <class T> 
class CVssDLListIterator
{
private:
	CVssDLListIterator();
	CVssDLListIterator(const CVssDLListIterator&);

public:

	CVssDLListIterator(const CVssDLList<T>& list): 
		m_List(list),
		m_pNextInEnum(list.m_pFirst)
	{};

	bool GetNext( OUT T& refObject );

    VOID Reset() { m_pNextInEnum = m_List.m_pFirst; }
private:
	const CVssDLList<T>& m_List;
	const CVssDLListElement<T>* m_pNextInEnum;
};


/////////////////////////////////////////////////////////////////////////////
// CVssDLListElement


template <class T>
class CVssDLListElement
{
// Constructors& Destructors
private:
	CVssDLListElement();
	CVssDLListElement(const CVssDLListElement&);

public:
	CVssDLListElement( IN	const T& object ): 
		m_Object(object), 
		m_pNext(NULL), 
		m_pPrev(NULL) 
		{
#ifndef NDEBUG
		m_dwSignature = VS_ELEMENT_SIGNATURE;
#endif		
		};

// Attributes
public:

	bool IsValid()	const 
	{ 
#ifndef NDEBUG
		return (m_dwSignature == VS_ELEMENT_SIGNATURE);
#else
        return ( TRUE );
#endif
	};

// Data members
public:
#ifndef NDEBUG
	DWORD m_dwSignature;
#endif
	CVssDLListElement* m_pPrev;
	CVssDLListElement* m_pNext;
	T m_Object;
};


/////////////////////////////////////////////////////////////////////////////
// CVssDLList implementation


template <class T>
bool CVssDLList<T>::IsEmpty() const
{
	assert(IsValid());

	return (m_pFirst == NULL);
}


template <class T>
VS_COOKIE CVssDLList<T>::Add( 
	IN	const T& object
	)
{
	assert(IsValid());

	CVssDLListElement<T>* pElement = new CVssDLListElement<T>(object);
	if (pElement == NULL)
		return VS_NULL_COOKIE;

	// Setting neighbour element links
	if (m_pFirst)
	{
		assert(m_pFirst->m_pPrev == NULL);
		m_pFirst->m_pPrev = pElement;
	}

	// Setting element links
	assert(pElement->m_pNext == NULL);
	assert(pElement->m_pPrev == NULL);
	if (m_pFirst)
		pElement->m_pNext = m_pFirst;

	// Setting list head links
	m_pFirst = pElement;
	if (m_pLast == NULL)
		m_pLast = pElement;

    ++m_dwNumElements;
    
	return reinterpret_cast<VS_COOKIE>(pElement);
}


template <class T>
VS_COOKIE CVssDLList<T>::AddTail( 
	IN	const T& object
	)
{
	assert(IsValid());

	CVssDLListElement<T>* pElement = new CVssDLListElement<T>(object);
	if (pElement == NULL)
		return VS_NULL_COOKIE;

	// Setting neighbour element links
	if (m_pLast)
	{
		assert(m_pLast->m_pNext == NULL);
		m_pLast->m_pNext = pElement;
	}

	// Setting element links
	assert(pElement->m_pNext == NULL);
	assert(pElement->m_pPrev == NULL);
	if (m_pLast)
		pElement->m_pPrev = m_pLast;

	// Setting list head links
	if (m_pFirst == NULL)
		m_pFirst = pElement;
	m_pLast = pElement;

    ++m_dwNumElements;
    
	return reinterpret_cast<VS_COOKIE>(pElement);
}


template <class T>
void CVssDLList<T>::ExtractByCookie( 
	IN	VS_COOKIE cookie,
	OUT	T& refObject
	)
{
	if (cookie == VS_NULL_COOKIE)
		return;

	CVssDLListElement<T>* pElement = 
		reinterpret_cast<CVssDLListElement<T>*>(cookie);

	assert(pElement);
	assert(pElement->IsValid());

	// Setting neighbours links
	if (pElement->m_pPrev)
		pElement->m_pPrev->m_pNext = pElement->m_pNext;
	if (pElement->m_pNext)
		pElement->m_pNext->m_pPrev = pElement->m_pPrev;

	// Setting list head links 
	if (m_pFirst == pElement)
		m_pFirst = pElement->m_pNext;
	if (m_pLast == pElement)
		m_pLast = pElement->m_pPrev;

	// Destroying the element after getting the original object.
	refObject = pElement->m_Object;
	delete pElement;
	--m_dwNumElements;
}


template <class T>
bool CVssDLList<T>::Extract( 
	OUT	T& refObject
	)
{
	CVssDLListElement<T>* pElement = m_pFirst;
	if (pElement == NULL)
		return false;

	assert(pElement->IsValid());

	// Setting neighbours links
	assert(pElement->m_pPrev == NULL);
	if (pElement->m_pNext)
		pElement->m_pNext->m_pPrev = NULL;

	// Setting list head links 
	m_pFirst = pElement->m_pNext;
	if (m_pLast == pElement)
		m_pLast = NULL;

	// Destroying the element after getting the original object.
	refObject = pElement->m_Object;
	delete pElement;

	--m_dwNumElements;
	return true;
}


template <class T>
bool CVssDLList<T>::ExtractTail( 
	OUT	T& refObject
	)
{
	CVssDLListElement<T>* pElement = m_pLast;
	if (pElement == NULL)
		return false;

	assert(pElement->IsValid());

	// Setting neighbours links
	assert(pElement->m_pNext == NULL);
	if (pElement->m_pPrev)
		pElement->m_pPrev->m_pNext = NULL;

	// Setting list head links 
	m_pLast = pElement->m_pPrev;
	if (m_pFirst == pElement)
		m_pFirst = NULL;

	// Destroying the element after getting the original object.
	refObject = pElement->m_Object;
	delete pElement;

	--m_dwNumElements;
	return true;
}


template <class T>
void CVssDLList<T>::ClearAll( 
	)
{
    CVssDLListElement<T>* pElement = m_pFirst;
    CVssDLListElement<T>* pNextElem;	
	while( pElement != NULL )
	{
	    pNextElem = pElement->m_pNext;
	    delete pElement;
	    pElement = pNextElem;
	}

	m_pFirst = NULL;
	m_pLast  = NULL;
	m_dwNumElements = 0;
}


template <class T>
bool CVssDLList<T>::IsValid()	const
{
	if ((m_pFirst == NULL) && (m_pLast == NULL))
		return true;
	if ((m_pFirst != NULL) && (m_pLast != NULL))
		return (m_pFirst->IsValid() && m_pLast->IsValid());
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CVssDLListIterator implementation


template <class T>
bool CVssDLListIterator<T>::GetNext( OUT T& object )
{
	if (m_pNextInEnum == NULL)
		return false;
	else
	{
		object = m_pNextInEnum->m_Object;
		m_pNextInEnum = m_pNextInEnum->m_pNext;
		return true;
	}
}


#endif // __VSS_DLLIST_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\bsstring.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsstring.cpp

Abstract:

    This module implements the CBsString class.  This class manages character
    arrays in a similar manner as the CString class in VC++.  In fact, this
    class is a copy of the CString class with the MFC specific stuff ripped
    out since LTS doesn't use MTF.

Author:

    Stefan R. Steiner   [SSteiner]      1-Mar-1998

Revision History:

    Stefan R. Steiner   [SSteiner]      10-Apr-2000
        Added fixed allocator code and resynced with MFC 6 SR-1 code
        
--*/

#include "stdafx.h"
#include "bsstring.h"
#include "malloc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

struct _BSAFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _BSAFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

// #define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

TCHAR bsafxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int _bsafxInitData[] = { -1, 0, 0, 0 };
static CBsStringData* _bsafxDataNil = (CBsStringData*)&_bsafxInitData;
static LPCTSTR _bsafxPchNil = (LPCTSTR)(((BYTE*)&_bsafxInitData)+sizeof(CBsStringData));
// special function to make bsafxEmptyString work even during initialization
const CBsString& BSAFXAPI BsAfxGetEmptyString()
	{ return *(CBsString*)&_bsafxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CBsString::CBsString()
{
	Init();
}

CBsString::CBsString(const CBsString& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != _bsafxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

CBsString::CBsString(GUID guid)
{
	Init();
	AllocBuffer(38);
    _stprintf( m_pchData, _T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
               guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1], 
               guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], 
               guid.Data4[6], guid.Data4[7] );
}

#ifndef _DEBUG

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

#define ROUND(x,y) (((x)+(y-1))&~(y-1))
#define ROUND4(x) ROUND(x, 4)
static CBsFixedAlloc _bsafxAlloc8(ROUND4(9*sizeof(TCHAR)+sizeof(CBsStringData)), 1024);
static CBsFixedAlloc _bsafxAlloc16(ROUND4(17*sizeof(TCHAR)+sizeof(CBsStringData)), 512);
static CBsFixedAlloc _bsafxAlloc32(ROUND4(33*sizeof(TCHAR)+sizeof(CBsStringData)), 256);
static CBsFixedAlloc _bsafxAlloc64(ROUND4(65*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc128(ROUND4(129*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc256(ROUND4(257*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc512(ROUND4(513*sizeof(TCHAR)+sizeof(CBsStringData)));

#endif //!_DEBUG

void CBsString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
// Throws E_OUTOFMEMORY when out of memory
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CBsStringData* pData;	    
#ifndef _DEBUG
		if (nLen <= 8)
		{
			pData = (CBsStringData*)_bsafxAlloc8.Alloc();
			pData->nAllocLength = 8;
		} 
		else if (nLen <= 16)
		{
			pData = (CBsStringData*)_bsafxAlloc16.Alloc();
			pData->nAllocLength = 16;
		} 
		else if (nLen <= 32)
		{
			pData = (CBsStringData*)_bsafxAlloc32.Alloc();
			pData->nAllocLength = 32;
		} 
		else if (nLen <= 64)
		{
			pData = (CBsStringData*)_bsafxAlloc64.Alloc();
			pData->nAllocLength = 64;
		}
		else if (nLen <= 128)
		{
			pData = (CBsStringData*)_bsafxAlloc128.Alloc();
			pData->nAllocLength = 128;
		}
		else if (nLen <= 256)
		{
			pData = (CBsStringData*)_bsafxAlloc256.Alloc();
			pData->nAllocLength = 256;
		}
		else if (nLen <= 512)
		{
			pData = (CBsStringData*)_bsafxAlloc512.Alloc();
			pData->nAllocLength = 512;
		}
		else
#endif
		{
			pData = (CBsStringData*)
				new BYTE[sizeof(CBsStringData) + (nLen+1)*sizeof(TCHAR)];
			if ( pData == NULL )    // Prefix #118828
			    throw E_OUTOFMEMORY;
			pData->nAllocLength = nLen;
		}
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		m_pchData = pData->data();
	}
}

void FASTCALL CBsString::FreeData(CBsStringData* pData)
{
#ifndef _DEBUG
	int nLen = pData->nAllocLength;
	if (nLen == 8)
		_bsafxAlloc8.Free(pData);
	else if (nLen == 16)
		_bsafxAlloc16.Free(pData);
	else if (nLen == 32)
		_bsafxAlloc32.Free(pData);
	else if (nLen == 64)
		_bsafxAlloc64.Free(pData);
	else if (nLen == 128)
		_bsafxAlloc128.Free(pData);
	else if (nLen == 256)
		_bsafxAlloc256.Free(pData);
	else  if (nLen == 512)
		_bsafxAlloc512.Free(pData);
	else
	{
		ASSERT(nLen > 512);
		delete[] (BYTE*)pData;
	}
#else
	delete[] (BYTE*)pData;
#endif
}

void CBsString::Release()
{
	if (GetData() != _bsafxDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
		Init();
	}
}

void PASCAL CBsString::Release(CBsStringData* pData)
{
	if (pData != _bsafxDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			FreeData(pData);
	}
}

void CBsString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &bsafxChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

void CBsString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CBsStringData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CBsString::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CBsString::~CBsString()
//  free any attached data
{
	if (GetData() != _bsafxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CBsString::AllocCopy(CBsString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(LPCTSTR lpsz)
{
	Init();
	int nLen = SafeStrlen(lpsz);
	if (nLen != 0)
	{
		AllocBuffer(nLen);
		memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CBsString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CBsString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CBsString& CBsString::operator=(const CBsString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _bsafxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != _bsafxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CBsString& CBsString::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CBsString& CBsString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CBsString& CBsString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CBsString + CBsString
// and for ? = TCHAR, LPCTSTR
//          CBsString + ?
//          ? + CBsString

void CBsString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CBsString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CBsString BSAFXAPI operator+(const CBsString& string1, const CBsString& string2)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CBsString BSAFXAPI operator+(const CBsString& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CBsString::SafeStrlen(lpsz), lpsz);
	return s;
}

CBsString BSAFXAPI operator+(LPCTSTR lpsz, const CBsString& string)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(CBsString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CBsString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CBsStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CBsString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CBsString& CBsString::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CBsString& CBsString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CBsString& CBsString::operator+=(const CBsString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CBsString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CBsStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CBsString::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CBsString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CBsString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CBsString::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CBsStringData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CBsString::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CBsString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CBsString::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != _bsafxDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CBsString::Find(TCHAR ch) const
{
	return Find(ch, 0);
}

int CBsString::Find(TCHAR ch, int nStart) const
{
	int nLength = GetData()->nDataLength;
	if (nStart >= nLength)
		return -1;

	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData + nStart, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CBsString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CBsString::MakeUpper()
{
	CopyBeforeWrite();
	_tcsupr(m_pchData);
}

void CBsString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

void CBsString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

void CBsString::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CBsString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
void CBsString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CBsString conversion helpers (these use the current system locale)

int BSAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, (INT)count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

int BSAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, (INT)count);
	ASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR BSAFXAPI BsAfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
    UNREFERENCED_PARAMETER( nChars );
}

LPSTR BSAFXAPI BsAfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
    UNREFERENCED_PARAMETER( nChars );
}


//
//  the following is from strex.cpp
//

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(TCHAR ch, int nLength)
{
	Init();
	if (nLength >= 1)
	{
		AllocBuffer(nLength);
#ifdef _UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CBsString::CBsString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ASSERT(BsAfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength);
		int n = ::MultiByteToWideChar(CP_ACP, 0, lpsz, nLength, m_pchData, nLength+1);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength*2);
		int n = ::WideCharToMultiByte(CP_ACP, 0, lpsz, nLength, m_pchData,
			(nLength*2)+1, NULL, NULL);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CBsString& CBsString::operator=(TCHAR ch)
{
	AssignCopy(1, &ch);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CBsString BSAFXAPI operator+(const CBsString& string1, TCHAR ch)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

CBsString BSAFXAPI operator+(TCHAR ch, const CBsString& string)
{
	CBsString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// Advanced manipulation

int CBsString::Delete(int nIndex, int nCount /* = 1 */)
{
	if (nIndex < 0)
		nIndex = 0;
	int nNewLength = GetData()->nDataLength;
	if (nCount > 0 && nIndex < nNewLength)
	{
		CopyBeforeWrite();
		int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

		memcpy(m_pchData + nIndex,
			m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
		GetData()->nDataLength = nNewLength - nCount;
	}

	return nNewLength;
}

int CBsString::Insert(int nIndex, TCHAR ch)
{
	CopyBeforeWrite();

	if (nIndex < 0)
		nIndex = 0;

	int nNewLength = GetData()->nDataLength;
	if (nIndex > nNewLength)
		nIndex = nNewLength;
	nNewLength++;

	if (GetData()->nAllocLength < nNewLength)
	{
		CBsStringData* pOldData = GetData();
		LPTSTR pstr = m_pchData;
		AllocBuffer(nNewLength);
		memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
		CBsString::Release(pOldData);
	}

	// move existing bytes down
	memcpy(m_pchData + nIndex + 1,
		m_pchData + nIndex, (nNewLength-nIndex)*sizeof(TCHAR));
	m_pchData[nIndex] = ch;
	GetData()->nDataLength = nNewLength;

	return nNewLength;
}

int CBsString::Insert(int nIndex, LPCTSTR pstr)
{
	if (nIndex < 0)
		nIndex = 0;

	int nInsertLength = SafeStrlen(pstr);
	int nNewLength = GetData()->nDataLength;
	if (nInsertLength > 0)
	{
		CopyBeforeWrite();
		if (nIndex > nNewLength)
			nIndex = nNewLength;
		nNewLength += nInsertLength;

		if (GetData()->nAllocLength < nNewLength)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}

		// move existing bytes down
		memcpy(m_pchData + nIndex + nInsertLength,
			m_pchData + nIndex,
			(nNewLength-nIndex-nInsertLength+1)*sizeof(TCHAR));
		memcpy(m_pchData + nIndex,
			pstr, nInsertLength*sizeof(TCHAR));
		GetData()->nDataLength = nNewLength;
	}

	return nNewLength;
}

int CBsString::Replace(TCHAR chOld, TCHAR chNew)
{
	int nCount = 0;

	// short-circuit the nop case
	if (chOld != chNew)
	{
		// otherwise modify each character that matches in the string
		CopyBeforeWrite();
		LPTSTR psz = m_pchData;
		LPTSTR pszEnd = psz + GetData()->nDataLength;
		while (psz < pszEnd)
		{
			// replace instances of the specified character only
			if (*psz == chOld)
			{
				*psz = chNew;
				nCount++;
			}
			psz = _tcsinc(psz);
		}
	}
	return nCount;
}

int CBsString::Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
{
	// can't have empty or NULL lpszOld

	int nSourceLen = SafeStrlen(lpszOld);
	if (nSourceLen == 0)
		return 0;
	int nReplacementLen = SafeStrlen(lpszNew);

	// loop once to figure out the size of the result string
	int nCount = 0;
	LPTSTR lpszStart = m_pchData;
	LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
	LPTSTR lpszTarget;
	while (lpszStart < lpszEnd)
	{
		while ((lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
		{
			nCount++;
			lpszStart = lpszTarget + nSourceLen;
		}
		lpszStart += lstrlen(lpszStart) + 1;
	}

	// if any changes were made, make them
	if (nCount > 0)
	{
		CopyBeforeWrite();

		// if the buffer is too small, just
		//   allocate a new buffer (slow but sure)
		int nOldLength = GetData()->nDataLength;
		int nNewLength =  nOldLength + (nReplacementLen-nSourceLen)*nCount;
		if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, pOldData->nDataLength*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}
		// else, we just do it in-place
		lpszStart = m_pchData;
		lpszEnd = m_pchData + GetData()->nDataLength;

		// loop again to actually do the work
		while (lpszStart < lpszEnd)
		{
			while ( (lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
			{
				int nBalance = nOldLength - (int)(lpszTarget - m_pchData + nSourceLen);
				memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen,
					nBalance * sizeof(TCHAR));
				memcpy(lpszTarget, lpszNew, nReplacementLen*sizeof(TCHAR));
				lpszStart = lpszTarget + nReplacementLen;
				lpszStart[nBalance] = '\0';
				nOldLength += (nReplacementLen - nSourceLen);
			}
			lpszStart += lstrlen(lpszStart) + 1;
		}
		ASSERT(m_pchData[nNewLength] == '\0');
		GetData()->nDataLength = nNewLength;
	}

	return nCount;
}

int CBsString::Remove(TCHAR chRemove)
{
	CopyBeforeWrite();

	LPTSTR pstrSource = m_pchData;
	LPTSTR pstrDest = m_pchData;
	LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;

	while (pstrSource < pstrEnd)
	{
		if (*pstrSource != chRemove)
		{
			*pstrDest = *pstrSource;
			pstrDest = _tcsinc(pstrDest);
		}
		pstrSource = _tcsinc(pstrSource);
	}
	*pstrDest = '\0';
	int nCount = ( int )( pstrSource - pstrDest );
	GetData()->nDataLength -= nCount;

	return nCount;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CBsString CBsString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CBsString CBsString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	ASSERT(nFirst >= 0);
	ASSERT(nFirst + nCount <= GetData()->nDataLength);

	// optimize case of returning entire string
	if (nFirst == 0 && nFirst + nCount == GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CBsString CBsString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

CBsString CBsString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
CBsString CBsString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	return Left((INT)_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CBsString CBsString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	return Left((INT)_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CBsString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CBsString::Find(LPCTSTR lpszSub) const
{
	return Find(lpszSub, 0);
}

int CBsString::Find(LPCTSTR lpszSub, int nStart) const
{
	ASSERT(BsAfxIsValidString(lpszSub));

	int nLength = GetData()->nDataLength;
	if (nStart > nLength)
		return -1;

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData + nStart, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CBsString formatting

#define TCHAR_ARG   TCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

#ifdef _X86_
	#define DOUBLE_ARG  _BSAFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000
#define FORCE_INT64		0x40000

void CBsString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ASSERT(BsAfxIsValidString(lpszFormat));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += (INT)_tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		if (_tcsncmp(lpsz, _T("I64"), 3) == 0)
		{
			lpsz += 3;
			nModifier = FORCE_INT64;
#if !defined(_X86_) && !defined(_ALPHA_)
			// __int64 is only available on X86 and ALPHA platforms
			ASSERT(FALSE);
#endif
		}
		else
		{
			switch (*lpsz)
			{
			// modifiers that affect size
			case 'h':
				nModifier = FORCE_ANSI;
				lpsz = _tcsinc(lpsz);
				break;
			case 'l':
				nModifier = FORCE_UNICODE;
				lpsz = _tcsinc(lpsz);
				break;

			// modifiers that do not affect size
			case 'F':
			case 'N':
			case 'L':
				lpsz = _tcsinc(lpsz);
				break;
			}
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
			{
				LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = lstrlen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 'S':
			{
#ifndef _UNICODE
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#else
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#endif
			}
			break;

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
			{
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
			{
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = (INT)wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
			nItemLen = max(nItemLen, nWidth);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				if (nModifier & FORCE_INT64)
					va_arg(argList, __int64);
				else
					va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'f':
				{
					double f;
					LPTSTR pszTemp;

					// 312 == strlen("-1+(309 zeroes).")
					// 309 zeroes == max precision of a double
					// 6 == adjustment in case precision is not specified,
					//   which means that the precision defaults to 6
					pszTemp = (LPTSTR)_alloca(max(nWidth, 312+nPrecision+6));

					f = va_arg(argList, double);
					_stprintf( pszTemp, _T( "%*.*f" ), nWidth, nPrecision+6, f );
					nItemLen = _tcslen(pszTemp);
				}
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);
	INT i = _vstprintf(m_pchData, lpszFormat, argListSave);
	ASSERT( i <= GetAllocLength() );
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void BSAFX_CDECL CBsString::Format(LPCTSTR lpszFormat, ...)
{
	ASSERT(BsAfxIsValidString(lpszFormat));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void CBsString::TrimRight(LPCTSTR lpszTargetList)
{
	// find beginning of trailing matches
	// by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;

	while (*lpsz != '\0')
	{
		if (_tcschr(lpszTargetList, *lpsz) != NULL)
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at left-most matching character
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CBsString::TrimRight(TCHAR chTarget)
{
	// find beginning of trailing matches
	// by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;

	while (*lpsz != '\0')
	{
		if (*lpsz == chTarget)
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at left-most matching character
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}


void CBsString::TrimRight()
{
	// find beginning of trailing spaces by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CBsString::TrimLeft(LPCTSTR lpszTargets)
{
	// if we're not trimming anything, we're not doing any work
	if (SafeStrlen(lpszTargets) == 0)
		return;

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;

	while (*lpsz != '\0')
	{
		if (_tcschr(lpszTargets, *lpsz) == NULL)
			break;
		lpsz = _tcsinc(lpsz);
	}

	if (lpsz != m_pchData)
	{
		// fix up data and length
		int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
		memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
		GetData()->nDataLength = nDataLength;
	}
}

void CBsString::TrimLeft(TCHAR chTarget)
{
	// find first non-matching character

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;

	while (chTarget == *lpsz)
		lpsz = _tcsinc(lpsz);

	if (lpsz != m_pchData)
	{
		// fix up data and length
		int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
		memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
		GetData()->nDataLength = nDataLength;
	}
}

void CBsString::TrimLeft()
{
	// find first non-space character

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;
	
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	if (lpsz != m_pchData)
	{
    	// fix up data and length
    	int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    	GetData()->nDataLength = nDataLength;
	}
}


//
//  From validadd.cpp
//

BOOL BSAFXAPI BsAfxIsValidString(LPCWSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}

BOOL BSAFXAPI BsAfxIsValidString(LPCSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL BSAFXAPI BsAfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\extattr.cpp ===
/*

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    extattr.cpp

Abstract:

    Get's additional file attributes beyond what you get with
    FindFirstFile/FindNextFile.

Author:

    Stefan R. Steiner   [ssteiner]        02-27-2000

Revision History:

    Avinash Pillai	[apillai]		07-29-2002	Added options -o:t, -o:y, -o:f and -o:i
--*/

#include "stdafx.h"
#include <ntioapi.h>

#include <aclapi.h>
#include <sddl.h>

#include "direntrs.h"
#include "extattr.h"
#include "hardlink.h"

#define READ_BUF_SIZE ( 1024 * 1024 )
#define FSD_SHARE_MODE ( FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE )

#define FSD_MS_HSM_REPARSE_TAG 0xC0000004

static VOID
eaGetSecurityInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    OUT SFileExtendedInfo *psExtendedInfo
    );

static VOID
eaGetFileInformationByHandle(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT SDirectoryEntry *psDirEntry,
    OUT SFileExtendedInfo *psExtendedInfo
    );

static VOID
eaGetAlternateStreamInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    OUT SFileExtendedInfo *psExtendedInfo
    );

static VOID
eaGetReparsePointInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT SDirectoryEntry *psDirEntry,
    OUT SFileExtendedInfo *psExtendedInfo
    );

static BOOL
eaChecksumRawEncryptedData(
    IN CDumpParameters *pcParams,
    IN const CBsString& cwsFileName,
    IN OUT SFileExtendedInfo *psExtendedInfo
    );

static BOOL
eaChecksumStream(
    IN const CBsString& cwsStreamPath,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT DWORD *pdwRunningCheckSum
    );

static DWORD
eaChecksumBlock(
    IN DWORD dwRunningChecksum,
    IN LPBYTE pBuffer,
    IN DWORD dwBufSize
    );

static VOID
eaConvertUserSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    );

static VOID
eaConvertGroupSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    );

static VOID
eaConvertSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    );

static DWORD
eaChecksumHSMReparsePoint(
    IN CDumpParameters *pcParams,
    IN PREPARSE_DATA_BUFFER pReparseData,
    IN DWORD dwTotalSize  // Size of reparse point data
    );

static VOID
eaGetObjectIdInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT SDirectoryEntry *psDirEntry,
    IN OUT SFileExtendedInfo *psExtendedInfo
    );

/*++

Routine Description:

    Performs all of the checksums, and retrieves the security info for one file.

Arguments:

Return Value:

--*/
VOID
GetExtendedFileInfo(
    IN CDumpParameters *pcParams,
    IN CFsdVolumeState *pcFsdVolState,
    IN const CBsString& cwsDirPath,
    IN BOOL bSingleEntryOutput,
    IN OUT SDirectoryEntry *psDirEntry,
    OUT SFileExtendedInfo *psExtendedInfo
    )
{
    CBsString cwsFullPath( cwsDirPath );

    //
    //  If we are dumping an individual file's data, cwsDirPath has the complete
    //  path to the file, otherwise glue the filename from the find data structure
    //  to the path.
    //
	if ( !bSingleEntryOutput )
	{
		cwsFullPath += psDirEntry->GetFileName();
	}

    //
    //  Get the information that retrieved from GetFileInformationByHandle
    //
    ::eaGetFileInformationByHandle( pcParams, cwsFullPath, psDirEntry, psExtendedInfo );

    if ( psExtendedInfo->lNumberOfLinks > 1 && pcParams->m_eFsDumpType != eFsDumpFile )
    {
        if ( pcFsdVolState->IsHardLinkInList(
                psExtendedInfo->ullFileIndex,
                cwsDirPath,
                psDirEntry->GetFileName(),
                &psDirEntry->m_sFindData,
                psExtendedInfo ) )
        {
            //
            //  Found the link in the list, return with the previous link's information, except
            //  zero out the number of bytes checksummed so that total counts remain accurate.
            //
            psExtendedInfo->ullTotalBytesChecksummed     = 0;
            psExtendedInfo->ullTotalBytesNamedDataStream = 0;
            return;
        }
    }

    //
    //  Get the security information.
    //
    ::eaGetSecurityInfo( pcParams, cwsFullPath, psExtendedInfo );

    eaGetObjectIdInfo(
        pcParams,
        cwsFullPath,
        &psExtendedInfo->ullTotalBytesChecksummed,
        psDirEntry,
        psExtendedInfo );

    //
    //  Get the reparse point information if necessary
    //
    if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
        ::eaGetReparsePointInfo(
            pcParams,
            cwsFullPath,
            &psExtendedInfo->ullTotalBytesChecksummed,
            psDirEntry,
            psExtendedInfo );

    //
    //  Get the raw encryption data checksum if necessary
    //
    if (    !pcParams->m_bNoChecksums && !pcParams->m_bNoEncryptedChecksum
         && psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED
         && !( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
        ::eaChecksumRawEncryptedData(
            pcParams,
            cwsFullPath,
            psExtendedInfo );

    //
    //  Checksum the unnamed datastream if this is not a directory
    //
    if (    !pcParams->m_bNoChecksums
         && !( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        DWORD dwChecksum = 0;
        ULONGLONG ullFileSize = ( ( ULONGLONG )( psDirEntry->m_sFindData.nFileSizeHigh ) << 32 ) + psDirEntry->m_sFindData.nFileSizeLow;

        if ( ullFileSize == 0 )
        {
            //
            //  In this case the default value for checksum of -------- is correct.
            //
        }
        else if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE
             && pcParams->m_bDontChecksumHighLatencyData )
        {
            psExtendedInfo->cwsUnnamedStreamChecksum = L"HighLtcy";
        }
        else if ( ::eaChecksumStream( cwsFullPath,
                                &psExtendedInfo->ullTotalBytesChecksummed,
                                &dwChecksum ) )
        {
            psExtendedInfo->cwsUnnamedStreamChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );
        }
        else
        {
            psExtendedInfo->cwsUnnamedStreamChecksum.Format( L"<%6d>", ::GetLastError() );
        }
    }

    //
    //  Get info on and checksum the named data streams
    //
    ::eaGetAlternateStreamInfo( pcParams, cwsFullPath, psExtendedInfo );

    //
    //  If this file is multiply linked, add it to the hard-link file list
    //
    if ( psExtendedInfo->lNumberOfLinks > 1 && pcParams->m_eFsDumpType != eFsDumpFile )
    {
        pcFsdVolState->AddHardLinkToList(
                psExtendedInfo->ullFileIndex,
                cwsDirPath,
                psDirEntry->GetFileName(),
                &psDirEntry->m_sFindData,
                psExtendedInfo );
    }
}


/*++

Routine Description:

    Gets the security information for a file

Arguments:

Return Value:

--*/
static VOID
eaGetSecurityInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    OUT SFileExtendedInfo *psExtendedInfo
    )
{
    //
    //  Now get the security information
    //
    PACL psDacl = NULL, psSacl = NULL;
    PSID pOwnerSid = NULL, pGroupSid = NULL;
    DWORD dwRet;
    DWORD dwSaclErrorRetCode = ERROR_SUCCESS;

    PSECURITY_DESCRIPTOR pDesc = NULL;

    try
    {
        dwRet = ::GetNamedSecurityInfoW(
            ( LPWSTR )cwsFileName.c_str(),  // strange API, should ask for const
            SE_FILE_OBJECT,
            DACL_SECURITY_INFORMATION
            | SACL_SECURITY_INFORMATION
            | OWNER_SECURITY_INFORMATION
            | GROUP_SECURITY_INFORMATION,
            &pOwnerSid,
            &pGroupSid,
            &psDacl,
            &psSacl,
            &pDesc );

        //
        //  If it didn't work, try again without the Sacl information
        //
        if ( dwRet != ERROR_SUCCESS )
        {
            dwSaclErrorRetCode = dwRet;
            psSacl  = NULL;
            dwRet = ::GetNamedSecurityInfoW(
                ( LPWSTR )cwsFileName.c_str(),  // strange API, should ask for const
                SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION
                | OWNER_SECURITY_INFORMATION
                | GROUP_SECURITY_INFORMATION,
                &pOwnerSid,
                &pGroupSid,
                &psDacl,
                NULL,
                &pDesc );
        }

#if 0
    //
    //  Test code to find security API problem
    //
        pDesc = ::LocalAlloc( LMEM_FIXED, 4096 );
        DWORD dwLengthNeeded;
        dwRet = ERROR_SUCCESS;

        if ( !::GetFileSecurityW(
                cwsFileName,
//                DACL_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
                DACL_SECURITY_INFORMATION, // | GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
                pDesc,
                4096,
                &dwLengthNeeded ) )
            dwRet = ::GetLastError();
if ( dwRet == ERROR_SUCCESS )
    wprintf( L"Got security descripter for '%s'\n", cwsFileName.c_str() );
else
    wprintf( L"Error getting descripter for '%s', dwRet: %d\n", cwsFileName.c_str(), dwRet );
#endif

        if ( dwRet == ERROR_SUCCESS )
        {
            if ( pDesc && pcParams->m_bEnableSDCtrlWordDump )
            {
                SECURITY_DESCRIPTOR_CONTROL sdc;
                DWORD dwDescRevision;
                if ( ::GetSecurityDescriptorControl( pDesc, &sdc, &dwDescRevision ) )
                    psExtendedInfo->wSecurityDescriptorControl = ( WORD )( sdc & ~SE_SELF_RELATIVE );
                else
                    psExtendedInfo->wSecurityDescriptorControl = -1;
            }
            else
                psExtendedInfo->wSecurityDescriptorControl = -1;

            if ( psDacl )
            {
                psExtendedInfo->lNumDACEs = 0;
                psExtendedInfo->wDACLSize = 0;
                //
                //  Checksum the DACL data if necessary.
                //  n.b. We only take into account ACEs that are inherited.
                //
                if ( psDacl->AclSize > 0 )
                {
                    DWORD dwChecksum = 0;
                    //
                    //  The first ACE is right after the ACL header
                    //
                    PACE_HEADER pAceHeader = ( PACE_HEADER )( psDacl + 1 );
                    for ( USHORT aceNum = 0; aceNum < psDacl->AceCount; ++aceNum )
                    {
                        //
                        //  Skip if an inherited ACE
                        //
                        if ( !( pAceHeader->AceFlags & INHERITED_ACE ) )
                        {
                            dwChecksum += ::eaChecksumBlock(
                                            dwChecksum,
                                            ( LPBYTE )pAceHeader,
                                            pAceHeader->AceSize );
                            ++psExtendedInfo->lNumDACEs;
                            psExtendedInfo->wDACLSize += pAceHeader->AceSize;
                            if ( pcParams->m_bPrintDebugInfo )
                                wprintf( L"\t%d: f: %04x, t: %04x, s: %u\n", aceNum,
                                    pAceHeader->AceFlags, pAceHeader->AceType, pAceHeader->AceSize );
                        }
                        pAceHeader = ( PACE_HEADER )( ( ( LPBYTE )pAceHeader ) + pAceHeader->AceSize );
                    }
                    if ( psExtendedInfo->wDACLSize > 0 )
                    {
                        psExtendedInfo->cwsDACLChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );
                        psExtendedInfo->ullTotalBytesChecksummed += psExtendedInfo->wDACLSize;
                    }
                }
            }
            else
                psExtendedInfo->lNumDACEs = 0; // probably FAT or CDROM fs

            if ( psSacl )
            {
                psExtendedInfo->lNumSACEs = 0;
                psExtendedInfo->wSACLSize = 0;

                //
                //  Checksum the SACL data if necessary
                //  n.b. We only take into account ACEs that are inherited.
                //
                if ( psSacl->AclSize > 0 )
                {
                    DWORD dwChecksum = 0;
                    //
                    //  The first ACE is right after the ACL header
                    //
                    PACE_HEADER pAceHeader = ( PACE_HEADER )( psSacl + 1 );
                    for ( USHORT aceNum = 0; aceNum < psSacl->AceCount; ++aceNum )
                    {
                        //
                        //  Skip if an inherited ACE
                        //
                        if ( !( pAceHeader->AceFlags & INHERITED_ACE ) )
                        {
                            dwChecksum += ::eaChecksumBlock(
                                            dwChecksum,
                                            ( LPBYTE )pAceHeader,
                                            pAceHeader->AceSize );
                            ++psExtendedInfo->lNumSACEs;
                            psExtendedInfo->wSACLSize += pAceHeader->AceSize;
                            if ( pcParams->m_bPrintDebugInfo )
                                wprintf( L"\ts%d: f: %04x, t: %04x, s: %u\n", aceNum,
                                    ( DWORD)( pAceHeader->AceFlags ), pAceHeader->AceType, (DWORD)( pAceHeader->AceSize ) );
                        }
                        pAceHeader = ( PACE_HEADER )( ( ( LPBYTE )pAceHeader ) + pAceHeader->AceSize );
                    }
                    if ( psExtendedInfo->wSACLSize > 0 )
                    {
                        psExtendedInfo->cwsSACLChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );
                        psExtendedInfo->ullTotalBytesChecksummed += psExtendedInfo->wSACLSize;
                    }
                }
            }
            else if ( dwSaclErrorRetCode != ERROR_SUCCESS )
            {
                psExtendedInfo->lNumSACEs = -1;
                psExtendedInfo->wSACLSize = -1;
                psExtendedInfo->cwsSACLChecksum.Format( L"<%6d>", dwSaclErrorRetCode );
            }
            else
                psExtendedInfo->lNumSACEs = 0; // none

            eaConvertUserSidToString( pcParams, pOwnerSid, &psExtendedInfo->cwsOwnerSid );
            eaConvertGroupSidToString( pcParams, pGroupSid, &psExtendedInfo->cwsGroupSid );

            ::LocalFree( pDesc );						
        }
        else
        {
            //
            //  Error getting security information
            //
            psExtendedInfo->lNumDACEs = -1;
            psExtendedInfo->lNumSACEs = -1;
            psExtendedInfo->wDACLSize = -1;
            psExtendedInfo->wSACLSize = -1;
            psExtendedInfo->cwsDACLChecksum.Format( L"<%6d>", dwRet );
            psExtendedInfo->cwsSACLChecksum.Format( L"<%6d>", dwRet );
            psExtendedInfo->cwsOwnerSid.Format( L"<%6d>", dwRet );
            psExtendedInfo->cwsGroupSid.Format( L"<%6d>", dwRet );
        }
    }
    catch( ... )
    {
        psExtendedInfo->lNumDACEs = -1;
        psExtendedInfo->lNumSACEs = -1;
        psExtendedInfo->wDACLSize = -1;
        psExtendedInfo->wSACLSize = -1;
        psExtendedInfo->cwsOwnerSid.Format( L"<%6d>", ::GetLastError() );
        psExtendedInfo->cwsGroupSid.Format( L"<%6d>", ::GetLastError() );
    }
}


static VOID
eaGetFileInformationByHandle(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT SDirectoryEntry *psDirEntry,
    OUT SFileExtendedInfo *psExtendedInfo
    )
{
    HANDLE hFile;

    //
    //  Note that while we do have to open the file, not even read access is needed
    //
    hFile = ::CreateFileW(
                cwsFileName,
                0,
                FSD_SHARE_MODE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS,
                NULL );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        psExtendedInfo->lNumberOfLinks = -1;
        return;
    }

    //
    //  Now get the additional attributes
    //
    BY_HANDLE_FILE_INFORMATION sFileInfo;
    if ( ::GetFileInformationByHandle( hFile, &sFileInfo ) )
    {
        psExtendedInfo->lNumberOfLinks = ( LONG )sFileInfo.nNumberOfLinks;
        psExtendedInfo->ullFileIndex   = ( ( ULONGLONG )sFileInfo.nFileIndexHigh << 32 ) + sFileInfo.nFileIndexLow;
        if ( psExtendedInfo->lNumberOfLinks > 1 || psDirEntry->m_sFindData.ftLastWriteTime.dwLowDateTime == 0 )
        {
            //
            //  Expect that the FindFirst/NextFile dir entry is stale or non-existant.  Use information
            //  from this call.
            //
            psDirEntry->m_sFindData.dwFileAttributes = sFileInfo.dwFileAttributes;
            psDirEntry->m_sFindData.ftCreationTime   = sFileInfo.ftCreationTime;
            psDirEntry->m_sFindData.ftLastAccessTime = sFileInfo.ftLastAccessTime;
            psDirEntry->m_sFindData.ftLastWriteTime  = sFileInfo.ftLastWriteTime;
            psDirEntry->m_sFindData.nFileSizeHigh    = sFileInfo.nFileSizeHigh;
            psDirEntry->m_sFindData.nFileSizeLow     = sFileInfo.nFileSizeLow;
        }
    }
    else
        psExtendedInfo->lNumberOfLinks = -1;

    ::CloseHandle( hFile );
}


static VOID
eaGetAlternateStreamInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    OUT SFileExtendedInfo *psExtendedInfo
    )
{
    NTSTATUS Status;
    HANDLE hFile;

    //
    //  Note that while we do have to open the file, not even read access is needed
    //
    hFile = CreateFileW(
                cwsFileName,
                FILE_GENERIC_READ, // | ACCESS_SYSTEM_SECURITY,
                FSD_SHARE_MODE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS,
                NULL );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        psExtendedInfo->lNumNamedDataStreams      = -1;
        psExtendedInfo->lNumPropertyStreams       = -1;
        psExtendedInfo->cwsNamedDataStreamChecksum.Format( L"<%6d>", ::GetLastError() );
        return;
    }

    //
    //  Loop until we read the file information
    //
    LPBYTE pBuffer = NULL;
    ULONG ulBuffSize = 1024;
    IO_STATUS_BLOCK iosb;
    static const WCHAR * const pwszDefaultStreamName = L"::$DATA";
    static const ULONG ulDefaultStreamNameLength = 7;

    while ( TRUE )
    {
        pBuffer = new BYTE[ ulBuffSize ];
        if ( pBuffer == NULL )
		{
            ::CloseHandle( hFile );
			throw E_OUTOFMEMORY;
		}

        Status = ::NtQueryInformationFile(
                    hFile,
                    &iosb,
                    pBuffer,
                    ulBuffSize,
                    FileStreamInformation );
        //
        //  If we succeeded in getting data, when have the data so party on and get out of
        //  the loop
        //
        if ( NT_SUCCESS( Status ) && iosb.Information != 0 )
        {
            break;
        }

        //
        //  If the error isn't overflow, get out
        //
        if ( Status != STATUS_BUFFER_OVERFLOW && Status != STATUS_BUFFER_TOO_SMALL )
        {
            //
            //  NOTE: If status is successful, we didn't get any data but it's not
            //  an error.  Happens a lot with directories since they don't have a default
            //  unnamed stream.
            //
            if ( !NT_SUCCESS( Status ) )
            {
                //
                //  Another kind of error
                //  BUGBUG: if not NTFS, C000000D occurs.  Should not try this on
                //          a non-NTFS volume
                //psExtendedInfo->lNumNamedDataStreams      = -1;
                //psExtendedInfo->dwNamedDataStreamChecksum = ::GetLastError();
                //psExtendedInfo->bNamedDataStreamHadError  = TRUE;
            }
            delete [] pBuffer;
            ::CloseHandle( hFile );
            return;
        }

        //
        //  Increase the size of the buffer
        //
        ulBuffSize <<= 1;   // double it each try
        delete [] pBuffer;
        pBuffer = NULL;
    }

    //
    //  If we are here, we have a valid FileStreamInformation buffer
    //
    ::CloseHandle( hFile );

    PFILE_STREAM_INFORMATION pFSI;
    pFSI = ( PFILE_STREAM_INFORMATION ) pBuffer;

    BOOL bHadError = FALSE;
    DWORD dwChecksum = 0;

    //
    //  Now loop through the named streams.
    //
    while ( TRUE )
    {
        if ( pFSI->StreamNameLength != sizeof( WCHAR ) * ulDefaultStreamNameLength ||
            wcsncmp( pFSI->StreamName, pwszDefaultStreamName, ulDefaultStreamNameLength ) != 0 )
        {
            LPWSTR pwszDataStr;

            pwszDataStr = ::wcsstr( pFSI->StreamName, L":$DATA" );
            if ( pwszDataStr != NULL )
            {
                pwszDataStr[0] = L'\0';  //  Strip off the :$DATA off of name
                ++psExtendedInfo->lNumNamedDataStreams;
//                wprintf( L"  %8I64u  '%-*.*s' : %d\n", pFSI->StreamSize, pFSI->StreamNameLength / 2,
//                    pFSI->StreamNameLength / 2, pFSI->StreamName, pFSI->StreamNameLength );

                psExtendedInfo->ullTotalBytesNamedDataStream += ( ULONGLONG )pFSI->StreamSize.QuadPart;

                if ( !pcParams->m_bNoChecksums && !bHadError )
                {
                    //
                    //  Put into the checksum the name of the stream
                    //
                    dwChecksum = ::eaChecksumBlock(
                                    dwChecksum,
                                    ( LPBYTE )pFSI->StreamName,
                                    ::wcslen( pFSI->StreamName ) * sizeof WCHAR );
                    //
                    //  Now checksum the data in the stream
                    //
                    if ( ::eaChecksumStream( cwsFileName + pFSI->StreamName,
                                           &psExtendedInfo->ullTotalBytesChecksummed,
                                           &dwChecksum ) )
                    {
                        psExtendedInfo->cwsNamedDataStreamChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );
                    }
                    else
                    {
                        psExtendedInfo->cwsNamedDataStreamChecksum.Format( L"<%6d>", ::GetLastError() );
                        bHadError = TRUE;
                    }
                }
            }
            else
            {
                //
                //  Not an named data stream, probably a property stream
                //  BUGBUG: need to verify that this is a property stream
                //
                ++psExtendedInfo->lNumPropertyStreams;
            }
        }

        if ( pFSI->NextEntryOffset == 0 )
            break;
        pFSI = ( PFILE_STREAM_INFORMATION )( pFSI->NextEntryOffset + ( PBYTE ) pFSI );
    }

    if ( !bHadError && !pcParams->m_bNoChecksums && psExtendedInfo->lNumNamedDataStreams > 0 )
    {
        psExtendedInfo->cwsNamedDataStreamChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );
    }

    if ( pBuffer != NULL )
        delete [] pBuffer;

}

static VOID
eaGetReparsePointInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT SDirectoryEntry *psDirEntry,
    IN OUT SFileExtendedInfo *psExtendedInfo
    )
{
    HANDLE hFile        = INVALID_HANDLE_VALUE;
    BOOL bRet           = TRUE;
    LPBYTE pReadBuffer  = NULL;
    DWORD dwChecksum    = 0;

    try
    {
        //
        //  Now get the reparse point data buffer
        //
        pReadBuffer = ( LPBYTE )::VirtualAlloc(
                                    NULL,
                                    MAXIMUM_REPARSE_DATA_BUFFER_SIZE,
                                    MEM_COMMIT,
                                    PAGE_READWRITE );
        if ( pReadBuffer == NULL )
        {
            bRet = FALSE;
            goto EXIT;
        }

        //
        //  Open the file in order to read reparse point data
        //
        hFile = ::CreateFileW(
                    cwsFileName,
                    GENERIC_READ,
                    FSD_SHARE_MODE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                    NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            bRet = FALSE;
            goto EXIT;
        }

        //
        //  Now get the reparse point data
        //
        DWORD dwBytesReturned;
        if ( !::DeviceIoControl(
                hFile,
                FSCTL_GET_REPARSE_POINT,
                NULL,                       // lpInBuffer; must be NULL
                0,                          // nInBufferSize; must be zero
                ( LPVOID )pReadBuffer,      // pointer to output buffer
                MAXIMUM_REPARSE_DATA_BUFFER_SIZE,   // size of output buffer
                &dwBytesReturned,           // receives number of bytes returned
                NULL                        // pointer to OVERLAPPED structure
                ) )
        {
            bRet = FALSE;
            goto EXIT;
        }

        PREPARSE_DATA_BUFFER pReparseData;
        pReparseData = ( PREPARSE_DATA_BUFFER )pReadBuffer ;
        psExtendedInfo->ulReparsePointTag = pReparseData->ReparseTag;
        psExtendedInfo->wReparsePointDataSize = ( WORD )dwBytesReturned;

        if ( !pcParams->m_bNoSpecialReparsePointProcessing &&
             psExtendedInfo->ulReparsePointTag == FSD_MS_HSM_REPARSE_TAG )
        {
            //
            //  To make sure that dumps don't get many miscompares we
            //  need to tweak the attributes.  Raid #153050
            //
            if ( pcParams->m_bDontChecksumHighLatencyData )
            {
                //
                //  Need to always make this file look like it is offline.
                //  In this case, we need to always enable the FILE_ATTRIBUTE_OFFLINE
                //  flag.
                //
                psDirEntry->m_sFindData.dwFileAttributes |= FILE_ATTRIBUTE_OFFLINE;
            }
            else
            {
                //
                //  Need to always make this file look like it is cached.
                //  In this case, we need to always disable the FILE_ATTRIBUTE_OFFLINE
                //  flag.
                //
                psDirEntry->m_sFindData.dwFileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;
            }

            //
            //  Call a special HSM checksum function which filters out certain
            //  dynamic fields before checksumming the data.
            //
            dwChecksum = eaChecksumHSMReparsePoint( pcParams, pReparseData, dwBytesReturned );
        }
        else
        {
            //
            //  Now checksum all of the reparse point data
            //
            dwChecksum = ::eaChecksumBlock( 0, pReadBuffer, dwBytesReturned );
        }

        psExtendedInfo->cwsReparsePointDataChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );

        *pullBytesChecksummed += dwBytesReturned;
    }
    catch( ... )
    {
        bRet = FALSE;
    }
EXIT:

    if ( pReadBuffer != NULL )
        ::VirtualFree( pReadBuffer, 0, MEM_RELEASE );

    if ( hFile != INVALID_HANDLE_VALUE )
        ::CloseHandle( hFile );

    if ( bRet == FALSE )
        psExtendedInfo->cwsReparsePointDataChecksum.Format( L"<%6d>", ::GetLastError() );
}

static BOOL
eaChecksumStream(
    IN const CBsString& cwsStreamPath,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT DWORD *pdwRunningCheckSum
    )
{
    LPBYTE pReadBuffer;
    BOOL bRet = TRUE;

    pReadBuffer = ( LPBYTE )::VirtualAlloc( NULL, READ_BUF_SIZE, MEM_COMMIT, PAGE_READWRITE );
    if ( pReadBuffer == NULL )
        return FALSE;

    //
    //  Open file with NO_BUFFERING.
    //
    HANDLE hFile = INVALID_HANDLE_VALUE;
    try
    {
        hFile = ::CreateFileW(
                    cwsStreamPath,
                    GENERIC_READ,
                    FSD_SHARE_MODE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_NO_BUFFERING
                    | FILE_FLAG_BACKUP_SEMANTICS
                    | FILE_FLAG_OPEN_NO_RECALL
                    | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            bRet = FALSE;
            goto EXIT;
        }

        DWORD dwBytesRead;
        while ( ::ReadFile(
                    hFile,
                    pReadBuffer,
                    READ_BUF_SIZE,
                    &dwBytesRead,
                    NULL ) )
        {
            if ( dwBytesRead == 0 )
                break;
            *pdwRunningCheckSum = ::eaChecksumBlock(
                    *pdwRunningCheckSum,
                    pReadBuffer,
                    dwBytesRead );
            *pullBytesChecksummed += dwBytesRead;
        }
        if ( ::GetLastError() != ERROR_SUCCESS )
            bRet = FALSE;
    }
    catch( ... )
    {
        bRet = FALSE;
    }

EXIT:
    if ( hFile != INVALID_HANDLE_VALUE )
        ::CloseHandle( hFile );

    ::VirtualFree( pReadBuffer, 0, MEM_RELEASE );

    return bRet;
}

//
//  This class maintains the encryption context
//
class CFsdEncryptionContext
{
public:
    CFsdEncryptionContext()
        : m_hDoneEvent( NULL ),
          m_dwChecksum( 0 ),
          m_ullBytesRead( 0 )
    {
        m_hDoneEvent = ::CreateEventW( NULL, TRUE, FALSE, NULL );
        if ( m_hDoneEvent == NULL )
            throw ::GetLastError();
    }

    ~CFsdEncryptionContext()
    {
        if ( m_hDoneEvent != NULL )
            ::CloseHandle( m_hDoneEvent );
    }

    DWORD WaitForDoneEvent()
    {
        DWORD dwRet;

        dwRet = ::WaitForSingleObject( m_hDoneEvent, INFINITE );
        if ( dwRet == WAIT_OBJECT_0 )
            return ERROR_SUCCESS;
        else if ( dwRet == WAIT_TIMEOUT )
            return ERROR_TIMEOUT;
        return ::GetLastError();
    }

    VOID FireDoneEvent()
    {
        ::SetEvent( m_hDoneEvent );
    }

    DWORD GetChecksum()
    {
        return m_dwChecksum;
    }

    ULONGLONG GetBytesRead()
    {
        return m_ullBytesRead;
    }

    static DWORD WINAPI ExportCallback(
        IN PBYTE pbData,
        IN PVOID pvCallbackContext,
        IN ULONG ulLength
        )
    {
        CFsdEncryptionContext *pcThis =
            static_cast< CFsdEncryptionContext * >( pvCallbackContext );
        pcThis->m_dwChecksum = ::eaChecksumBlock(
                pcThis->m_dwChecksum,
                pbData,
                ulLength );
        pcThis->m_ullBytesRead += ulLength;
        return ERROR_SUCCESS;
    }

private:
    HANDLE m_hDoneEvent;
    DWORD m_dwChecksum;
    ULONGLONG m_ullBytesRead;
};


static BOOL
eaChecksumRawEncryptedData(
    IN CDumpParameters *pcParams,
    IN const CBsString& cwsFileName,
    IN OUT SFileExtendedInfo *psExtendedInfo
    )
{
    PVOID pvContext = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    CFsdEncryptionContext cEncryptionContext;

    try
    {
        //
        //  Open this puppy up
        //
        dwRet = ::OpenEncryptedFileRawW( cwsFileName, 0, &pvContext );
        if ( dwRet == ERROR_SUCCESS )
        {
            //wprintf( L"**** Opened encrypted file '%s'\n", cwsFileName.c_str() );
            dwRet = ::ReadEncryptedFileRaw( CFsdEncryptionContext::ExportCallback, &cEncryptionContext, pvContext );
            if ( dwRet == ERROR_SUCCESS )
            {
                //wprintf( L"**** Called read on encrypted file, bytes read: %u, checksum: %u\n",
                //    cEncryptionContext.GetBytesRead(), cEncryptionContext.GetChecksum() );
                psExtendedInfo->cwsEncryptedRawDataChecksum.Format( pcParams->m_pwszULongHexFmt,
                    cEncryptionContext.GetChecksum() );
                psExtendedInfo->ullTotalBytesChecksummed += cEncryptionContext.GetBytesRead();
            }
        }
    }
    catch( ... )
    {
        dwRet = ERROR_EXCEPTION_IN_SERVICE;    // ???
    }

    if ( pvContext != NULL )
        ::CloseEncryptedFileRaw( pvContext );

    if ( dwRet != ERROR_SUCCESS )
        psExtendedInfo->cwsEncryptedRawDataChecksum.Format( L"<%6d>", dwRet );

    return dwRet == ERROR_SUCCESS;
}


/*++

Routine Description:

    Checksums a block of data.  The block needs to be DWORD aligned for performance and
    correctness since this function assumes it can zero out up to 3 bytes beyond the
    end of the buffer.  Also, only the last buffer in a series of buffers can have
    unaligned data at the end of the buffer.

Arguments:

    dwRunningChecksum - The previous checksum from a previous call.  Should be zero if
        this is the first block to checksum in a series of blocks.

    pBuffer - Pointer to the buffer to checksum.

    dwBufSize - This should always be a multiple of a DWORD, except for the last block
        in a series.

Return Value:

    The checksum.

--*/
static DWORD
eaChecksumBlock(
    IN DWORD dwRunningChecksum,
    IN LPBYTE pBuffer,
    IN DWORD dwBufSize
    )
{
    //
    //  Need to zero out any additional bytes not aligned.
    //
    DWORD dwBytesToZero;
    DWORD dwBufSizeInDWords;

    dwBytesToZero     = dwBufSize % sizeof( DWORD );
    dwBufSizeInDWords = ( dwBufSize + ( sizeof( DWORD ) - 1 ) ) / sizeof( DWORD ); // int div

    while ( dwBytesToZero-- )
        pBuffer[ dwBufSize + dwBytesToZero ] = 0;

    LPDWORD pdwBuf = ( LPDWORD )pBuffer;

    // BUGBUG: Need better checksum
    for ( DWORD dwIdx = 0; dwIdx < dwBufSizeInDWords; ++dwIdx )
        dwRunningChecksum += ( dwRunningChecksum << 1 ) | pdwBuf[ dwIdx ];

    return dwRunningChecksum;
}


/*++

Routine Description:

    Converts a user SID to a string.  Has a simple one element cache to speed
    up conversions.  This is especially useful when the user wants the symbolic
    DOMAIN\ACCOUNT strings.

Arguments:

Return Value:

    NONE

--*/
static VOID
eaConvertUserSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    )
{
    static CBsString cwsCachedSidString;
    static PSID pCachedSid = NULL;

    //
    //  Is the cached SID the same as the passed in one.  If so,
    //  return the cached sid string.
    //
    if (    pCachedSid != NULL
         && ::EqualSid( pSid, pCachedSid ) )
    {
        *pcwsSid = cwsCachedSidString;
        return;
    }

    //
    //  Convert the SID into a string
    //
    ::eaConvertSidToString( pcParams, pSid, pcwsSid );

    //
    //  Now cache the sid
    //
    cwsCachedSidString = *pcwsSid;
    if ( pCachedSid != NULL )
        free( pCachedSid );
    size_t cSidLength = ( size_t )::GetLengthSid( pSid );
    pCachedSid = ( PSID )malloc( cSidLength );
    if ( pCachedSid == NULL )   //  prefix #171666
    {
        pcParams->ErrPrint( L"eaConvertUserSidToString - Can't allocate memory, out of memory" );
        throw E_OUTOFMEMORY;
    }
    ::CopySid( ( DWORD )cSidLength, pCachedSid, pSid );
}


/*++

Routine Description:

    Converts a group SID to a string.  Has a simple one element cache to speed
    up conversions.  This is especially useful when the user wants the symbolic
    DOMAIN\ACCOUNT strings.

Arguments:

Return Value:

    NONE

--*/
static VOID
eaConvertGroupSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    )
{
    static CBsString cwsCachedSidString;
    static PSID pCachedSid = NULL;

    //
    //  Is the cached SID the same as the passed in one.  If so,
    //  return the cached sid string.
    //
    if (    pCachedSid != NULL
         && ::EqualSid( pSid, pCachedSid ) )
    {
        *pcwsSid = cwsCachedSidString;
        return;
    }

    //
    //  Convert the SID into a string
    //
    ::eaConvertSidToString( pcParams, pSid, pcwsSid );

    //
    //  Now cache the sid
    //
    cwsCachedSidString = *pcwsSid;
    if ( pCachedSid != NULL )
        free( pCachedSid );
    size_t cSidLength = ( size_t )::GetLengthSid( pSid );
    pCachedSid = ( PSID )malloc( cSidLength );
    if ( pCachedSid == NULL )   //  prefix #171665
    {
        pcParams->ErrPrint( L"eaConvertGroupSidToString - Can't allocate memory, out of memory" );
        throw E_OUTOFMEMORY;
    }
    ::CopySid( ( DWORD )cSidLength, pCachedSid, pSid );
}


/*++

Routine Description:

    Converts a SID to a string.

Arguments:

Return Value:

    NONE

--*/
static VOID
eaConvertSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    )
{
    if ( pcParams->m_bShowSymbolicSIDNames )
    {
        CBsString cwsAccountName;
        CBsString cwsDomainName;
        SID_NAME_USE eSidNameUse;
        DWORD dwAccountNameSize = 1024;
        DWORD dwDomainNameSize  = 1024;

        if ( ::LookupAccountSidW(
            NULL,
            pSid,
            cwsAccountName.GetBufferSetLength( dwAccountNameSize ),
            &dwAccountNameSize,
            cwsDomainName.GetBufferSetLength( dwDomainNameSize ),
            &dwDomainNameSize,
            &eSidNameUse ) )
        {
            cwsAccountName.ReleaseBuffer();
            cwsDomainName.ReleaseBuffer();
            *pcwsSid = L"'";
            *pcwsSid += cwsDomainName;
            *pcwsSid += L"\\";
            *pcwsSid += cwsAccountName;
            *pcwsSid += L"'";
            return;
        }
    }
    LPWSTR pwszSid;

    if ( ::ConvertSidToStringSid( pSid, &pwszSid ) )
    {
        *pcwsSid = pwszSid;
        ::LocalFree( pwszSid );
    }
    else
    {
        pcwsSid->Format( L"<%6d>", ::GetLastError() );
    }
}

///////////////////////////////////////////////////////////////////////////
//
//   FROM: base\fs\hsm\inc\rpdata.h
//
//////////////////////////////////////////////////////////////////////////

#define RP_RESV_SIZE 52

//
// Placeholder data - all versions unioned together
//
typedef struct _RP_PRIVATE_DATA {
   CHAR           reserved[RP_RESV_SIZE];        // Must be 0
   ULONG          bitFlags;            // bitflags indicating status of the segment
   LARGE_INTEGER  migrationTime;       // When migration occurred
   GUID           hsmId;
   GUID           bagId;
   LARGE_INTEGER  fileStart;
   LARGE_INTEGER  fileSize;
   LARGE_INTEGER  dataStart;
   LARGE_INTEGER  dataSize;
   LARGE_INTEGER  fileVersionId;
   LARGE_INTEGER  verificationData;
   ULONG          verificationType;
   ULONG          recallCount;
   LARGE_INTEGER  recallTime;
   LARGE_INTEGER  dataStreamStart;
   LARGE_INTEGER  dataStreamSize;
   ULONG          dataStream;
   ULONG          dataStreamCRCType;
   LARGE_INTEGER  dataStreamCRC;
} RP_PRIVATE_DATA, *PRP_PRIVATE_DATA;

typedef struct _RP_DATA {
   GUID              vendorId;         // Unique HSM vendor ID -- This is first to match REPARSE_GUID_DATA_BUFFER
   ULONG             qualifier;        // Used to checksum the data
   ULONG             version;          // Version of the structure
   ULONG             globalBitFlags;   // bitflags indicating status of the file
   ULONG             numPrivateData;   // number of private data entries
   GUID              fileIdentifier;   // Unique file ID
   RP_PRIVATE_DATA   data;             // Vendor specific data
} RP_DATA, *PRP_DATA;

//
//  This function specifically zero's out certain HSM reparse point
//  fields before computing the checksum.  The fields which are
//  zero'ed out are dynamic values and can cause miscompares.
//
static DWORD
eaChecksumHSMReparsePoint(
    IN CDumpParameters *pcParams,
    IN PREPARSE_DATA_BUFFER pReparseData,
    IN DWORD dwTotalSize  // Size of reparse point data
    )
{
    if ( dwTotalSize >= 8 && pReparseData->ReparseDataLength >= sizeof RP_DATA )
    {
        //
        //  If structure is not at least as large as the HSM RP_DATA structure,
        //  then it doesn't appear to be a valid HSM RP_DATA structure.
        //
        PRP_DATA pRpData = ( PRP_DATA ) pReparseData->GenericReparseBuffer.DataBuffer;

        //
        //  Zero out the proper fields
        //
        pRpData->qualifier                 = 0;
        pRpData->globalBitFlags            = 0;
        pRpData->data.bitFlags             = 0;
        pRpData->data.recallCount          = 0;
        pRpData->data.recallTime.LowPart   = 0;
        pRpData->data.recallTime.HighPart  = 0;
    }
    else
    {
        pcParams->ErrPrint( L"Warning, HSM reparse point not valid, size: %u\n", dwTotalSize );
    }

    return ::eaChecksumBlock( 0, ( LPBYTE )pReparseData, dwTotalSize );
}

static VOID
eaGetObjectIdInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT SDirectoryEntry *psDirEntry,
    IN OUT SFileExtendedInfo *psExtendedInfo
    )
{
    HANDLE hFile        = INVALID_HANDLE_VALUE;
    BOOL bRet           = TRUE;
    DWORD dwChecksum    = 0;

    try
    {
        //
        //  Open the file in order to read the object id
        //
        hFile = ::CreateFileW(
                    cwsFileName,
                    GENERIC_READ,
                    FSD_SHARE_MODE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_BACKUP_SEMANTICS,
                    NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            bRet = FALSE;
            goto EXIT;
        }

        FILE_OBJECTID_BUFFER sObjIdBuffer;
        DWORD dwBytesReturned;

        //
        //  Now get the object id info
        //
        if ( !::DeviceIoControl(
                hFile,
                FSCTL_GET_OBJECT_ID,
                NULL,                       // lpInBuffer; must be NULL
                0,                          // nInBufferSize; must be zero
                ( LPVOID )&sObjIdBuffer,     // pointer to output buffer
                sizeof FILE_OBJECTID_BUFFER,// size of output buffer
                &dwBytesReturned,           // receives number of bytes returned
                NULL                        // pointer to OVERLAPPED structure
                ) )
        {
            bRet = FALSE;
            goto EXIT;
        }

        //
        //  Load up the object id
        //
        LPWSTR pwszObjIdGuid;

        //  Check for RPC_S_OK added for Prefix bug #192596
        if ( ::UuidToStringW( (GUID *)sObjIdBuffer.ObjectId,
                              ( unsigned short ** )&pwszObjIdGuid ) == RPC_S_OK )
        {
            psExtendedInfo->cwsObjectId = pwszObjIdGuid;
            ::RpcStringFreeW( ( unsigned short ** )&pwszObjIdGuid );
        }

        //
        //  Now checksum all of the extended object id data if necessary
        //
        if ( pcParams->m_bEnableObjectIdExtendedDataChecksums )
        {
            dwChecksum = ::eaChecksumBlock( 0, sObjIdBuffer.ExtendedInfo, sizeof( sObjIdBuffer.ExtendedInfo ) );
            psExtendedInfo->cwsObjectIdExtendedDataChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );

            *pullBytesChecksummed += sizeof( sObjIdBuffer.ExtendedInfo );
        }
    }
    catch( ... )
    {
        bRet = FALSE;
    }
EXIT:

    if ( hFile != INVALID_HANDLE_VALUE )
        ::CloseHandle( hFile );

//    if ( bRet == FALSE )
//        psExtendedInfo->cwsReparsePointDataChecksum.Format( L"<%6d>", ::GetLastError() );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\match.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    match.h

    Originally from name.c by Gary Kimura

Author:

    Stefan R. Steiner   [ssteiner]        ??-??-2000

Revision History:

--*/

#ifndef __H_MATCH_
#define __H_MATCH_

BOOLEAN
FsdRtlIsNameInExpression (
    IN const CBsString& Expression,    //  Must be uppercased
    IN const CBsString& Name           //  Must be uppercased
    );

VOID
FsdRtlConvertWildCards(
    IN OUT CBsString &FileName
    );

#endif // __H_MATCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\stdafx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    Precompiled header file

Author:

    Stefan R. Steiner   [ssteiner]        02-17-2000

Revision History:

--*/

#ifndef __H_STDAFX_
#define __H_STDAFX_

#if _MSC_VER > 1000
#pragma once
#endif

#define RTL_USE_AVL_TABLES 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>
#include <windows.h>

#include "bsstring.h"
#include "params.h"
#include "vs_list.h"
#include "volstate.h"


#endif // __H_STDAFX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\hardlink.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    hardlink.h

Abstract:

    The class that manages hardlinks for one volume.  Assumes one class object
    will be created per volume.

Author:

    Stefan R. Steiner   [ssteiner]        3-30-2000

Revision History:

--*/

#ifndef __H_HARDLINK_
#define __H_HARDLINK_

#include "extattr.h"

//
//  Structure is defined to reduce the amount of space required
//  to store the file names in the hard-link linked-list with 
//  the assumption that a number of hard-linked files exist in
//  a directory.  Uses CBsString ref counting.
//
struct SFsdHLFileName
{
    CBsString cwsDirPath;
    CBsString cwsFileName;
};

//
//  Manages one set of hard-linked files
//
class CFsdHardLinkListEntry
{
public:
    //  Create link entry and add the first file name
    CFsdHardLinkListEntry(
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName,
        IN WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
        IN SFileExtendedInfo *psExtendedInfo
        ) : m_sFileAttributeData( *psFileAttributeData ),
            m_sExtendedInfo( *psExtendedInfo )
        {
            AddFile( cwsDirPath, cwsFileName );
        }

    virtual ~CFsdHardLinkListEntry() {}

    //  Adds an additional file name to the link
    VOID AddFile(
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName
        );

    inline VOID GetAttributes( 
        OUT WIN32_FILE_ATTRIBUTE_DATA *psFileAttribData,
        OUT SFileExtendedInfo *psExtInfo
        )
    {
        *psFileAttribData = m_sFileAttributeData;
        *psExtInfo        = m_sExtendedInfo;
    }
    
    VOID PrintEntry(
        IN FILE *fpOut,
        IN INT cVolMountPointOffset
        );
    
    CVssDLList< SFsdHLFileName > m_cFilesLinkedTogetherList;
    
private:
    WIN32_FILE_ATTRIBUTE_DATA m_sFileAttributeData;
    SFileExtendedInfo m_sExtendedInfo;
};


typedef TBsHashMap< ULONGLONG, CFsdHardLinkListEntry * > FSD_HARD_LINK_LIST;

//
//  Manages all of the hard-link files in one volume
//
class CFsdHardLinkManager
{
public:
    CFsdHardLinkManager(
        IN CDumpParameters *pcParams,
        IN INT cVolMountPointOffset
        ) : m_pcParams( pcParams ),
            m_cVolMountPointOffset( cVolMountPointOffset ),
            m_cHardLinkFilesList( BSHASHMAP_HUGE) {}
    
    virtual ~CFsdHardLinkManager();

    //  Dumps all hardlink information out to dump file
    VOID PrintHardLinkInfo();
    
    //  Looks to see if the hardlink is already in the list, if
    //  so, adds the file name to the list
    BOOL IsHardLinkInList(
        IN ULONGLONG ullFileIndex,
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName,
        OUT WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
        OUT SFileExtendedInfo *psExtendedInfo
        );

    //  Adds a new link to the list
    VOID AddHardLinkToList(
        IN ULONGLONG ullFileIndex,
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName,
        IN WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
        IN SFileExtendedInfo *psExtendedInfo
        );
    
private:
    CDumpParameters *m_pcParams;
    INT m_cVolMountPointOffset;
    FSD_HARD_LINK_LIST m_cHardLinkFilesList;
};

#endif // __H_HARDLINK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\hardlink.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    hardlink.cpp

Abstract:

    The class that manages hardlinks for one volume.  Assumes one class object
    will be created per volume.

Author:

    Stefan R. Steiner   [ssteiner]        3-30-2000

Revision History:

--*/

#include "stdafx.h"
#include "hardlink.h"
 
VOID
CFsdHardLinkListEntry::AddFile(
    IN const CBsString& cwsDirPath,
    IN const CBsString& cwsFileName
    )
{
    SFsdHLFileName sFileName;
    sFileName.cwsDirPath  = cwsDirPath;
    sFileName.cwsFileName = cwsFileName;
    m_cFilesLinkedTogetherList.AddTail( sFileName );
}

VOID 
CFsdHardLinkListEntry::PrintEntry(
    IN FILE *fpOut,
    IN INT cVolMountPointOffset
    )
{
    fwprintf( fpOut, L"\tLinks to file: %u, links found: %u %s\n", m_sExtendedInfo.lNumberOfLinks,
        m_cFilesLinkedTogetherList.Size(), 
        m_sExtendedInfo.lNumberOfLinks == (LONG)m_cFilesLinkedTogetherList.Size() ? L"" : L" - MISMATCH" );

    SFsdHLFileName sFileName;

    CVssDLListIterator< SFsdHLFileName > cListEntryIter( m_cFilesLinkedTogetherList );
    while( cListEntryIter.GetNext( sFileName ) )
        fwprintf( fpOut, L"\t\t%s%s\n", sFileName.cwsDirPath.c_str() + cVolMountPointOffset, 
            sFileName.cwsFileName.c_str() );
}


CFsdHardLinkManager::~CFsdHardLinkManager()
{
    //
    //  Need to delete all CFsdHardLinkListEntry objects
    //
    ULONGLONG ullFileIndex;
    CFsdHardLinkListEntry *pcListEntry;

    m_cHardLinkFilesList.StartEnum();
    while ( m_cHardLinkFilesList.GetNextEnum( &ullFileIndex, &pcListEntry ) )
    {
        delete pcListEntry;
    }    
    m_cHardLinkFilesList.EndEnum();
}

VOID 
CFsdHardLinkManager::PrintHardLinkInfo()
{
    //
    //  Need to iterate through all hard link entries
    //
    ULONGLONG ullFileIndex;
    CFsdHardLinkListEntry *pcListEntry;

    m_cHardLinkFilesList.StartEnum();
    while ( m_cHardLinkFilesList.GetNextEnum( &ullFileIndex, &pcListEntry ) )
    {
        pcListEntry->PrintEntry( m_pcParams->GetDumpFile(), m_cVolMountPointOffset );
    }    
    m_cHardLinkFilesList.EndEnum();
}


BOOL 
CFsdHardLinkManager::IsHardLinkInList(
    IN ULONGLONG ullFileIndex,
    IN const CBsString& cwsDirPath,
    IN const CBsString& cwsFileName,
    OUT WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
    OUT SFileExtendedInfo *psExtendedInfo
    )
{
    //
    //  Search the hard link list to see if the file index is already in
    //  the list.
    //
    CFsdHardLinkListEntry *pcLinkEntry;
    
    if ( m_cHardLinkFilesList.Find( ullFileIndex, &pcLinkEntry ) )
    {
        //
        //  Found it.  Add file name to the entry and get the stored attributes.
        //
        pcLinkEntry->AddFile( cwsDirPath, cwsFileName );
        pcLinkEntry->GetAttributes( psFileAttributeData, psExtendedInfo );

        if ( m_pcParams->m_bPrintDebugInfo )
            wprintf( L"IsHardLinkInList: FOUND ullFileIndex: %016I64x, file '%s%s', num in list: %u, num lnks: %d\n",
                ullFileIndex, cwsDirPath.c_str(), cwsFileName.c_str(), pcLinkEntry->m_cFilesLinkedTogetherList.Size(), 
                psExtendedInfo->lNumberOfLinks );

        return TRUE;
    }
    
    return FALSE;
}


VOID 
CFsdHardLinkManager::AddHardLinkToList(
    IN ULONGLONG ullFileIndex,
    IN const CBsString& cwsDirPath,
    IN const CBsString& cwsFileName,
    IN WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
    IN SFileExtendedInfo *psExtendedInfo
    )
{
    CFsdHardLinkListEntry *pcLinkEntry;

    //
    //  Add it.  Create a new entry and add the entry to the list
    //
    pcLinkEntry = new CFsdHardLinkListEntry( 
                        cwsDirPath, 
                        cwsFileName, 
                        psFileAttributeData, 
                        psExtendedInfo );
    if ( pcLinkEntry == NULL )
        throw E_OUTOFMEMORY;
    
    if ( m_cHardLinkFilesList.Insert( ullFileIndex, pcLinkEntry ) != BSHASHMAP_NO_ERROR )
        m_pcParams->ErrPrint( L"CFsdHardLinkManager::AddHardLinkToList - Error adding to hard-link file list" );

    if ( m_pcParams->m_bPrintDebugInfo )
        wprintf( L"  AddHardLinkToList: ullFileIndex: %016I64x, file '%s%s', num lnks: %d\n",
            ullFileIndex, cwsDirPath.c_str(), cwsFileName.c_str(), psExtendedInfo->lNumberOfLinks );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\volstate.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volstate.cpp

Abstract:

    Contains implementation of the volume state class.  This class
    maintains state about one volume.


Author:

    Stefan R. Steiner   [ssteiner]        03-14-2000

Revision History:

--*/

#include "stdafx.h"

CFsdVolumeStateManager::CFsdVolumeStateManager(
    IN CDumpParameters *pcDumpParameters
    ) : m_cVolumeStateList( BSHASHMAP_MEDIUM ),
        m_pcParams( pcDumpParameters ),
        m_pcExclManager( NULL )
{ 
    if ( m_pcParams->m_bUseExcludeProcessor )
    {        
        m_pcExclManager = new CFsdExclusionManager( m_pcParams );
        if ( m_pcExclManager == NULL )
        {
            m_pcParams->ErrPrint( L"CFsdVolumeStateManager::CFsdVolumeStateManager - Can't init CFsdExclusionManager, out of memory" );
            throw E_OUTOFMEMORY;
        }
    }
}

CFsdVolumeStateManager::~CFsdVolumeStateManager() 
{
    //
    //  Need to delete all volume state objects
    //
    
    SFsdVolumeId sFsdId;
    CFsdVolumeState *pcVolState;

    m_cVolumeStateList.StartEnum();
    while ( m_cVolumeStateList.GetNextEnum( &sFsdId, &pcVolState ) )
    {
        delete pcVolState;
    }    
    m_cVolumeStateList.EndEnum();

    delete m_pcExclManager;
}

VOID 
CFsdVolumeStateManager::PrintHardLinkInfo()
{
    //
    //  Let's iterate through all of the volumes managed by this
    //  manager.
    //
    SFsdVolumeId sFsdId;
    CFsdVolumeState *pcVolState;
    
    m_pcParams->DumpPrint( L"" );
    m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
    m_pcParams->DumpPrint( L"HardLink Information" );
    
    m_cVolumeStateList.StartEnum();
    while ( m_cVolumeStateList.GetNextEnum( &sFsdId, &pcVolState ) )
    {
        m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
        m_pcParams->DumpPrint( L"For volume: '%s'", pcVolState->GetVolumePath() );
        pcVolState->PrintHardLinkInfo();
    }    
    m_cVolumeStateList.EndEnum();
}


/*++

Routine Description:

    <Enter description here>

Arguments:

Return Value:

    ERROR_ALREADY_EXISTS - The volume already exists.  The returned 
        volume state object pointer is valid.
    ERROR_CAN_NOT_COMPLETE - Unexpected error
    
--*/
DWORD
CFsdVolumeStateManager::GetVolumeState(
   IN const CBsString& cwsVolumePath,
   OUT CFsdVolumeState **ppcVolState
   )
{
    *ppcVolState = NULL;
    
    try
    {
        WCHAR wszVolumePath[ FSD_MAX_PATH ];

        //
        //  Temporary workaround for bug in GetVolumeInformationW()
        //     
        BOOL bFixed = FALSE;
        if ( cwsVolumePath.Left( 2 ) == L"\\\\" && cwsVolumePath.Left( 4 ) != L"\\\\?\\" )
        {
            //
            //  reduce to the minimal \\machine\sharename\ form
            //
            ::wcscpy( wszVolumePath, cwsVolumePath );
            LPWSTR pswz;

            pswz = ::wcschr( wszVolumePath + 2, L'\\' );
            if ( pswz != NULL )
            {
                pswz = ::wcschr( pswz + 1, L'\\' );
                if ( pswz != NULL )
                {
                    pswz[1] = '\0';
                    bFixed = TRUE;
                }                                    
            }
        }
        if ( bFixed == FALSE )
        {
            //
            //  Get the volume path that contains this volume
            //
            if ( !::GetVolumePathNameW(
                    cwsVolumePath,
                    wszVolumePath,
                    FSD_MAX_PATH ) )
            {
                m_pcParams->ErrPrint( L"CFsdVolumeStateManager - GetVolumePathName( '%s', ... ) returned dwRet: %d",
                    cwsVolumePath.c_str(), ::GetLastError() );
                return ::GetLastError();
            }            
        }
        
        //
        //  Initialize a new volume state object
        //
        CFsdVolumeState *pcFsdVolumeState;        
        pcFsdVolumeState = new CFsdVolumeState( m_pcParams, wszVolumePath );
        if ( pcFsdVolumeState == NULL )
        {
            m_pcParams->ErrPrint( L"CFsdVolumeStateManager, out of memory, can't get volume information" );
            return  ::GetLastError();
        }

        //
        //  Now get the information about the volume. 
        //  BUGBUG: Note that GetVolumeInformationW returns 
        //  ERROR_DIR_NOT_ROOT when encountering a junction on a 
        //  remote share.
        //
        if ( !::GetVolumeInformationW(
                wszVolumePath,
                NULL,
                0,
                &pcFsdVolumeState->m_dwVolSerialNumber,
                &pcFsdVolumeState->m_dwMaxComponentLength,
                &pcFsdVolumeState->m_dwFileSystemFlags,
                pcFsdVolumeState->m_cwsFileSystemName.GetBufferSetLength( 64 ),
                64 ) )
        {
            pcFsdVolumeState->m_cwsFileSystemName.ReleaseBuffer();
            m_pcParams->ErrPrint( L"CFsdVolumeStateManager - GetVolumeInformation( '%s', ... ) returned dwRet: %d "
                L"(if 144 probably hit bug in GetVolumeInformation when accessing remote mountpoints)",
                wszVolumePath, ::GetLastError() );
            delete pcFsdVolumeState;
            return ::GetLastError();
        }
        pcFsdVolumeState->m_cwsFileSystemName.ReleaseBuffer();

#if 0
        SFsdVolumeId sVolIdTest;
        CBsString cwsRealVolumePath;
        GetVolumeIdAndPath( m_pcParams, cwsVolumePath, &sVolIdTest, cwsRealVolumePath );
        assert( sVolIdTest.m_dwVolSerialNumber == pcFsdVolumeState->m_dwVolSerialNumber );
        printf("VolumeSerialNumber: 0x%08x, 0x%08x\n", pcFsdVolumeState->m_dwVolSerialNumber, 
            sVolIdTest.m_dwVolSerialNumber );
#endif
        
        //
        //  Now see if this volume already exists in the list of volume states
        //
        LONG lRet;
        SFsdVolumeId sVolId;
        sVolId.m_dwVolSerialNumber = pcFsdVolumeState->m_dwVolSerialNumber;
        if ( m_cVolumeStateList.Find( sVolId, ppcVolState ) == TRUE )
        {
            //
            //  Already exists in the list, return it.  Also delete the vol state 
            //  object that's not needed.
            //            
            delete pcFsdVolumeState;
            return ERROR_ALREADY_EXISTS;
        }

        //
        //  Not found, insert it into the list
        //
        lRet = m_cVolumeStateList.Insert( sVolId, pcFsdVolumeState );
        if ( lRet != BSHASHMAP_NO_ERROR )
        {
            assert( lRet != BSHASHMAP_ALREADY_EXISTS );
            delete pcFsdVolumeState;
            return ERROR_CAN_NOT_COMPLETE;
        }

        //
        //  Now get the exclusion processor for this volume if necessary
        //
        if ( m_pcExclManager != NULL )
        {
            m_pcExclManager->GetFileSystemExcludeProcessor( cwsVolumePath, &sVolId, &pcFsdVolumeState->m_pcFSExclProcessor );
        }
        
        CFsdVolumeState *pcFindFsdVolumeState;
        *ppcVolState = pcFsdVolumeState;
        return ERROR_SUCCESS;
    } 
    catch ( HRESULT hr )
    {
        if ( hr == E_OUTOFMEMORY )
            m_pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeState - Out of memory ( '%s' )",
                cwsVolumePath.c_str() );
        else
            m_pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeState - Unexpected hr exception: 0x%08x ( '%s )",
                hr, cwsVolumePath.c_str() );
        
        return ERROR_CAN_NOT_COMPLETE;                        
    }
    catch ( ... )
    {
        m_pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeState - '%s' caught an unexpected exception",
            cwsVolumePath.c_str() );
        return ERROR_CAN_NOT_COMPLETE;
    }    
}


/*++

Routine Description:

    Gets the ID of the volume containing any file.

Arguments:

Return Value:

    ERROR_CAN_NOT_COMPLETE - General error

--*/
DWORD 
CFsdVolumeStateManager::GetVolumeIdAndPath( 
    IN CDumpParameters *pcParams,
    IN const CBsString& cwsPathOnVolume,
    OUT SFsdVolumeId *psVolId,
    OUT CBsString& cwsVolPath
    )
{    
    try
    {      
        psVolId->m_dwVolSerialNumber = 0;
        WCHAR wszVolumePath[ FSD_MAX_PATH ];

        //
        //  First get the mountpoint of the volume
        //
        if ( !GetVolumePathNameW(
                cwsPathOnVolume,
                wszVolumePath,
                FSD_MAX_PATH ) )
        {
            pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeIdAndPath - GetVolumePathName( '%s', ... ) returned dwRet: %d",
                cwsPathOnVolume.c_str(), ::GetLastError() );
            return ::GetLastError();
        }

        //
        //  Now open the volume in order to query filesystem info
        //
        HANDLE hFile;
        hFile = ::CreateFileW( 
                    wszVolumePath, 
                    FILE_GENERIC_READ,
                    FILE_SHARE_READ, 
                    NULL,
                    OPEN_EXISTING, 
                    FILE_FLAG_BACKUP_SEMANTICS, 
                    NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            //pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeIdAndPath - CreateFile( '%s', ... ) returned dwRet: %d",
            //    wszVolumePath, ::GetLastError() );
            return ::GetLastError();
        }
        
        IO_STATUS_BLOCK iosb ;
        BYTE buffer[1024] ;
        FILE_FS_VOLUME_INFORMATION *fsinfo = (FILE_FS_VOLUME_INFORMATION *)buffer;

        fsinfo->VolumeSerialNumber = 0;
        NTSTATUS ntStat;
        ntStat = ::NtQueryVolumeInformationFile( hFile, &iosb, fsinfo, sizeof(buffer), FileFsVolumeInformation );
        ::CloseHandle( hFile );
        if ( ntStat != STATUS_SUCCESS )
        {
            pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeIdAndPath - NtQueryVolumeInformationFile( '%s', ... ) returned dwRet: %0x08x",
                wszVolumePath, ntStat );
            return ERROR_CAN_NOT_COMPLETE;
        }
        
        psVolId->m_dwVolSerialNumber = fsinfo->VolumeSerialNumber;
        
        cwsVolPath = wszVolumePath;        
    }
    catch ( ... )
    {
        pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeIdAndPath - '%s' caught an unexpected exception",
            cwsPathOnVolume.c_str() );
        return ERROR_CAN_NOT_COMPLETE;
    }    
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\params.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    params.cpp

Abstract:

    Class the manages the dump parameters

Author:

    Stefan R. Steiner   [ssteiner]        02-18-2000

Revision History:

    Avinash Pillai	[apillai]		07-29-2002	Added options -o:t, -o:y, -o:f and -o:i

--*/

#include "stdafx.h"

#define VERSION_INFO1 L"FsDumplib.lib Version 1.3g - 8/23/2000"
#define VERSION_INFO2 L"  Checksum version 2 - 2/22/2000"

// Forward defines
static BOOL 
AssertPrivilege( 
    IN LPCWSTR privName 
    );


/*++

Routine Description:

    Based on the class variables, sets up the utility to write to the
    correct files and gets backup privs.

Arguments:

    None

Return Value:

    <Enter return values here>

--*/
INT 
CDumpParameters::Initialize(
    IN INT argc,
    IN WCHAR *argv[]
    )
{
    LPWSTR pwszFileName;
    
    //
    //  Get the directory the fsdump.exe lives in.  For use for finding .exclude files amoung
    //  other things.
    //
    if ( ::GetFullPathName( 
            m_cwsArgv0,
            FSD_MAX_PATH,
            m_cwsFullPathToEXE.GetBufferSetLength( FSD_MAX_PATH ),
            &pwszFileName ) == 0 )
    {
        ::fwprintf( stderr, L"ERROR getting full path for '%s', won't be able to find .include files\n", m_cwsArgv0.c_str() );
        m_cwsFullPathToEXE.ReleaseBuffer();
    }
    else
    {
        m_cwsFullPathToEXE.ReleaseBuffer();
        m_cwsArgv0 = m_cwsFullPathToEXE;    //  Keep the full path version
        CBsString m_cwsRight4 = m_cwsArgv0.Right( 4 );
        m_cwsRight4.MakeLower();
        if ( m_cwsRight4 != L".exe" )
            m_cwsArgv0 += L".exe";
        m_cwsFullPathToEXE = m_cwsFullPathToEXE.Left( m_cwsFullPathToEXE.GetLength() - ::wcslen( pwszFileName ) );
    }
    
    //
    //  Set up checksum format
    //
    if ( m_bDumpCommaDelimited )
        ::wcscpy( m_pwszULongHexFmt, L"0x%08x" );
    else
        ::wcscpy( m_pwszULongHexFmt, L"%08x" );
    
    //
    //  Set up the dump file
    //
    if ( m_cwsDumpFileName.IsEmpty() )
    {
        wprintf( L"fsdump: Printing dump information to 'stdout'\n" );
    }
    else
    {
        CBsString cwsFullPath;        
        LPWSTR pwszFileName;
        
        //
        //  Get the full path name for the dump file in case we change the working
        //  directory later.
        //
        if ( ::GetFullPathName( 
                m_cwsDumpFileName,
                FSD_MAX_PATH,
                cwsFullPath.GetBufferSetLength( FSD_MAX_PATH ),
                &pwszFileName ) == 0 )
        {
            ::fwprintf( stderr, L"ERROR - Unable to get full path name of dump file '%s' for write\n", m_cwsDumpFileName.c_str() );
            return 10;
        }
        cwsFullPath.ReleaseBuffer();
        m_cwsDumpFileName = cwsFullPath;
        
        m_fpDump = ::_wfopen( m_cwsDumpFileName, m_bUnicode ? L"wb" : L"w" );
        if ( m_fpDump == NULL )
        {
            ::fwprintf( stderr, L"ERROR - Unable to open dump file '%s' for write\n", m_cwsDumpFileName.c_str() );
            return 10;
        }
        if ( m_bNoHeaderFooter )
        {
            //
            //  Try to create a named stream with the header and summary information
            //
            m_fpExtraInfoDump = ::_wfopen( m_cwsDumpFileName + L":Info", m_bUnicode ? L"wb" : L"w" );
            if ( m_fpExtraInfoDump != NULL )
            {
                wprintf( L"fsdump: Printing dump header and summary information to NTFS stream '%s'\n", (m_cwsDumpFileName + L":Info").c_str() );
            }
            else
            {
                m_fpExtraInfoDump = ::_wfopen( m_cwsDumpFileName + L".Info", m_bUnicode ? L"wb" : L"w" );
                if ( m_fpExtraInfoDump != NULL )
                {
                    wprintf( L"fsdump: Printing dump header and summary information to file '%s'\n", (m_cwsDumpFileName + L".Info").c_str() );
                }
                else
                {
                    wprintf( L"fsdump: Unable to create dump header and summary information file '%s'\n", (m_cwsDumpFileName + L".Info").c_str() );
                }
            }
        }
        else
            m_fpExtraInfoDump = m_fpDump;
        wprintf( L"fsdump: Printing dump information to '%s'\n", m_cwsDumpFileName.c_str() );
    }
    
    //
    //  Set up the error log file
    //
    if ( m_cwsErrLogFileName.IsEmpty() )
    {
        wprintf( L"fsdump: Printing errors to 'stderr'\n" );
    }
    else
    {
        CBsString cwsFullPath;        
        LPWSTR pwszFileName;

        //
        //  Get the full path name for the dump file in case we change the working
        //  directory later.
        //
        if ( ::GetFullPathName( 
                m_cwsErrLogFileName,
                1024,
                cwsFullPath.GetBufferSetLength( 1024 ),
                &pwszFileName ) == 0 )
        {
            fwprintf( stderr, L"ERROR - Unable to get full path name of error log file '%s' for write\n", m_cwsDumpFileName.c_str() );
            return 11;
        }
        cwsFullPath.ReleaseBuffer();
        m_cwsErrLogFileName = cwsFullPath;

        m_fpErrLog = ::_wfopen( m_cwsErrLogFileName, m_bUnicode ? L"wb" : L"w" );
        if ( m_fpErrLog == NULL )
        {
            ::fwprintf( stderr, L"ERROR - Unable to open error log file '%s' for write\n", m_cwsErrLogFileName.c_str() );
            return 11;
        }
        ::wprintf( L"fsdump: Printing errors to '%s'\n", m_cwsErrLogFileName.c_str() );
    }

    //
    //  Print out a header in the dump file so that it is easy to determine
    //  if dump formats are the same.
    //
    DumpPrint( VERSION_INFO1 );
    DumpPrint( VERSION_INFO2 );

    //
    //  Dump out the command-line
    //
    CBsString cwsCommandLine;
    for ( INT idx = 0; idx < argc; ++idx )
    {
        cwsCommandLine += L" \"";
        cwsCommandLine += argv[ idx ];
        cwsCommandLine += L"\"";
    }
    DumpPrint( L"  Command-line: %s", cwsCommandLine.c_str() );
    
    //
    //  Enable backup and security privs
    //
    if ( !::AssertPrivilege( SE_BACKUP_NAME ) )
        DumpPrint( L"  n.b. could not get SE_BACKUP_NAME Privilege (%d), will be unable to get certain information",
            ::GetLastError() );
    if ( !::AssertPrivilege( SE_SECURITY_NAME ) )
    {
        DumpPrint( L"  n.b. could not get SE_SECURITY_NAME Privilege (%d), SACL entries information will be invalid",
            ::GetLastError() );
        m_bHaveSecurityPrivilege = FALSE;
    }
    
    DumpPrint( L"  File attributes masked: %04x", m_dwFileAttributesMask );
    DumpPrint( L"  Command line options enabled:" );
    if ( m_bHex )
        DumpPrint( L"    Printing sizes in hexidecimal" );
    if ( m_bNoChecksums )
        DumpPrint( L"    Checksums disabled" );
    else if( m_bNoEncryptedChecksum )
    	DumpPrint( L" Encrypted Checksum disabled" );    	
    if ( m_bUnicode )
        DumpPrint( L"    Unicode output" );
    if ( m_bDontTraverseMountpoints )
        DumpPrint( L"    Mountpoint traversal disabled" );
    if ( !m_bDontChecksumHighLatencyData )
        DumpPrint( L"    High latency data checksum enabled" );
    if(!m_bAddSecsToTimestamps)						//added by apillai
    	 DumpPrint( L"    Disabling secs from timestamps" );		//added by apillai
    if ( m_bAddMillisecsToTimestamps )
        DumpPrint( L"    Adding millsecs to timestamps" );
    if ( m_bShowSymbolicSIDNames )
        DumpPrint( L"    Converting SIDs to symbolic DOMAIN\\ACCOUNTNAME format" );
    if ( !m_bDontShowDirectoryTimestamps )
        DumpPrint( L"    Dumping directory timestamps" );
    if(!m_bNoShortFileName)
    	 DumpPrint(L"    Dumping Short File names" );
    if((m_bDumpCommaDelimited) && (!m_bNoFileSystemType))
    	DumpPrint(L"    Dumping File System type" );
    
    if ( m_bUseExcludeProcessor )
    {
        if ( m_bDontUseRegistryExcludes )
            DumpPrint( L"    Excluding file based on exclude files" );
        else
            DumpPrint( L"    Excluding file based on FilesNotToBackup reg keys and exclude files" );
    }
    if ( m_bDisableLongPaths )
        DumpPrint( L"    Long path support disabled" );
    if ( m_bEnableObjectIdExtendedDataChecksums )
        DumpPrint( L"    Object Id extended data checksums Enabled" );
    DumpPrint( L"" );
    fflush( GetDumpFile() );
    return 0;
}

/*++

Routine Description:

    Destructor for the CDumpParameters class

Arguments:

    None

Return Value:

    <Enter return values here>

--*/
CDumpParameters::~CDumpParameters()
{
    if ( m_fpDump != NULL && m_fpDump != stdout )
        ::fclose( m_fpDump );
    
    if ( m_fpExtraInfoDump != NULL && m_fpExtraInfoDump != m_fpDump )
        ::fclose( m_fpExtraInfoDump );

    if ( m_fpErrLog != NULL && m_fpErrLog != stderr )
        ::fclose( m_fpErrLog );
}

/*++

Routine Description:

    Enables an NT privilege.  Used to get backup privs in the utility.

Arguments:

    privName - The privilege name.
    
Return Value:

    <Enter return values here>

--*/
static BOOL 
AssertPrivilege( 
    IN LPCWSTR privName 
    )
{
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &tokenHandle ) )
    {
        LUID value;

        if ( LookupPrivilegeValue( NULL, privName, &value ) )
        {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            * We will always call GetLastError below, so clear
            * any prior error values on this thread.
            */
            SetLastError( ERROR_SUCCESS );

            stat =  AdjustTokenPrivileges(
                tokenHandle,
                FALSE,
                &newState,
                (DWORD)0,
                NULL,
                NULL );
            /*
            * Supposedly, AdjustTokenPriveleges always returns TRUE
            * (even when it fails). So, call GetLastError to be
            * extra sure everything's cool.
            */
            if ( (error = GetLastError()) != ERROR_SUCCESS )
            {
                stat = FALSE;
            }
        }
        CloseHandle( tokenHandle );
    }
    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\fsdump\lib\match.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    match.cpp

    Originally name.c by Gary Kimura

Abstract:

    The unicode name support package is for manipulating unicode strings
    The routines allow the caller to dissect and compare strings.

    This package uses the same FSRTL_COMPARISON_RESULT typedef used by name.c

    The following routines are provided by this package:

      o  FsRtlDissectName - This routine takes a path name string and breaks
         into two parts.  The first name in the string and the remainder.
         It also checks that the first name is valid for an NT file.

      o  FsRtlColateNames - This routine is used to colate directories
         according to lexical ordering.  Lexical ordering is strict unicode
         numerical oerdering.

      o  FsRtlDoesNameContainsWildCards - This routine tells the caller if
         a string contains any wildcard characters.

      o  FsRtlIsNameInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

    Stefan Steiner  [SSteiner]  23-Mar-2000
        For use with fsdump - I tried to do as little changes to the actual
        matching code as possible.
        
--*/

#include "stdafx.h"

//
//  Local support routine prototypes
//

static BOOLEAN
FsRtlIsNameInExpressionPrivate (
    IN const CBsString& InExpression,
    IN const CBsString& InName,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    );

static BOOLEAN
FsRtlDoesNameContainWildCards (
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOLEAN - TRUE if one or more wild card characters was found.

--*/
{
    INT i;

    //
    //  The wildcards include the standard FsRtl wildcard characters
    //

	LPWSTR lpsz = ::wcspbrk( Name->Buffer, L"*?\"<>" );
	return (lpsz == NULL) ? FALSE : TRUE;
}
    
//
//  The following routine is just a wrapper around
//  FsRtlIsNameInExpressionPrivate to make a last minute fix a bit safer.
//

BOOLEAN
FsdRtlIsNameInExpression (
    IN const CBsString& Expression,    //  Must be uppercased
    IN const CBsString& Name           //  Must be uppercased
    )
{
    BOOLEAN Result;

    //
    //  Now call the main routine, remembering to free the upcased string
    //  if we allocated one.
    //

    Result = FsRtlIsNameInExpressionPrivate( Expression,
                                             Name,
                                             FALSE,
                                             NULL );
    
    return Result;
}

#define MATCHES_ARRAY_SIZE 16

//
//  Local support routine prototypes
//

static BOOLEAN
FsRtlIsNameInExpressionPrivate (
    IN const CBsString& InExpression,
    IN const CBsString& InName,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive TRUE.)

    Name - Supplies the input name to check for.

    CaseInsensitive - TRUE if Name should be Upcased before comparing.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    // The following code is to make use of most of this function without many
    // changes.
    UNICODE_STRING sExpression;
    UNICODE_STRING sName;
    PUNICODE_STRING Expression = &sExpression;
    PUNICODE_STRING Name = &sName;
    sExpression.Length        = ( USHORT )( InExpression.GetLength() * sizeof( WCHAR ) );
    sExpression.MaximumLength = sExpression.Length;
    sExpression.Buffer        = ( PWSTR )InExpression.c_str();
    sName.Length        = ( USHORT )( InName.GetLength() * sizeof( WCHAR ) );
    sName.MaximumLength = sName.Length;
    sName.Buffer        = ( PWSTR )InName.c_str();
    
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    WCHAR NameChar, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        return (BOOLEAN)(!(Name->Length + Expression->Length));
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((Expression->Length == 2) && (Expression->Buffer[0] == L'*')) {

        return TRUE;
    }

    ASSERT( !IgnoreCase || ARGUMENT_PRESENT(UpcaseTable) );

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == L'*') {

        UNICODE_STRING LocalExpression;

        LocalExpression = *Expression;

        LocalExpression.Buffer += 1;
        LocalExpression.Length -= 2;

        //
        //  Only special case an expression with a single *
        //

        if ( !FsRtlDoesNameContainWildCards( &LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (Name->Length < (USHORT)(Expression->Length - sizeof(WCHAR))) {

                return FALSE;
            }

            StartingNameOffset = ( Name->Length -
                                   LocalExpression.Length ) / sizeof(WCHAR);

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

            if ( !IgnoreCase ) {

                return (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
                                                 Name->Buffer + StartingNameOffset,
                                                 LocalExpression.Length );

            } else {

                for ( ExprOffset = 0;
                      ExprOffset < (USHORT)(LocalExpression.Length / sizeof(WCHAR));
                      ExprOffset += 1 ) {

                    NameChar = Name->Buffer[StartingNameOffset + ExprOffset];
                    NameChar = UpcaseTable[NameChar];

                    ExprChar = LocalExpression.Buffer[ExprOffset];

                    ASSERT( ExprChar == UpcaseTable[ExprChar] );

                    if ( NameChar != ExprChar ) {

                        return FALSE;
                    }
                }

                return TRUE;
            }
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            NameChar = Name->Buffer[NameOffset / sizeof(WCHAR)];

            NameOffset += sizeof(WCHAR);;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( TRUE ) {

                if ( ExprOffset == Expression->Length ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset += Length;
                Length = sizeof(WCHAR);

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == Expression->Length ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression->Buffer[ExprOffset / sizeof(WCHAR)];

                ASSERT( !IgnoreCase || !((ExprChar >= L'a') && (ExprChar <= L'z')) );

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) &&
                     (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = Expression->Length / sizeof(WCHAR);

                    AuxBuffer = ( USHORT *)malloc(
                                                    (ExpressionChars+1) *
                                                    sizeof(USHORT)*2*2 );
                    if ( AuxBuffer == NULL )    //  fix a future prefix bug
                        throw E_OUTOFMEMORY;
                    
                    RtlCopyMemory( AuxBuffer,
                                   CurrentMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    RtlCopyMemory( AuxBuffer + (ExpressionChars+1)*2,
                                   PreviousMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == L'*') {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 3;
                    continue;
                }

                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == DOS_STAR) {

                    BOOLEAN ICanEatADot = FALSE;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == '.') ) {

                        USHORT Offset;

                        for ( Offset = NameOffset;
                              Offset < Name->Length;
                              Offset += Length ) {

                            if (Name->Buffer[Offset / sizeof(WCHAR)] == L'.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != L'.') || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;
                    }
                }

                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(WCHAR) * 2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == DOS_QM ) {

                    if ( NameFinished || (NameChar == L'.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == L'.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == L'?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == (WCHAR)(IgnoreCase ?
                                        UpcaseTable[NameChar] : NameChar)) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            if ((SrcCount < MatchesCount) &&
                (PreviousDestCount < DestCount) ) {

                while (PreviousDestCount < DestCount) {

                    while ( PreviousMatches[SrcCount] <
                         CurrentMatches[PreviousDestCount] ) {

                        SrcCount += 1;
                    }

                    PreviousDestCount += 1;
                }
            }
        }

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) { free( AuxBuffer ); }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { free( AuxBuffer ); }


    return (BOOLEAN)(CurrentState == MaxState);
}


/*++

Routine Description:

    Converts some wildcard chars to FsRtl special wildcards
    in order to use FsRtlIsNameInExpressionPrivate.
    Code originally from filefind.c in Win32 subsystem by MarkL.

Arguments:

Return Value:

    <Enter return values here>

--*/
VOID
FsdRtlConvertWildCards(
    IN OUT CBsString &FileName
    )
{
    //
    //  Special case *.* to * since it is so common.  Otherwise transmogrify
    //  the input name according to the following rules:
    //
    //  - Change all ? to DOS_QM
    //  - Change all . followed by ? or * to DOS_DOT
    //  - Change all * followed by a . into DOS_STAR
    //
    //  These transmogrifications are all done in place.
    //

    if ( FileName == L"*.*") {

        FileName = L"*";

    } else {

        INT Index;
        WCHAR *NameChar;
        
        for ( Index = 0, NameChar = (WCHAR *)FileName.c_str();
              Index < FileName.GetLength();
              Index += 1, NameChar += 1) {

            if (Index && (*NameChar == L'.') && (*(NameChar - 1) == L'*')) {

                *(NameChar - 1) = DOS_STAR;
            }

            if ((*NameChar == L'?') || (*NameChar == L'*')) {

                if (*NameChar == L'?') 
                { 
                    *NameChar = DOS_QM; 
                }

                if (Index && *(NameChar-1) == L'.') 
                { 
                    *(NameChar-1) = DOS_DOT; 
                }
            }
        }

        if ( ( FileName.Right( 1 ) == L"." ) && *(NameChar - 1) == L'*') 
        { 
            *(NameChar-1) = DOS_STAR; 
        }
    }
}                


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ftc\ftc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:      ftc.cxx
//
//  Contents:  Fast multi-threaded tree copy program.
//
//  History:   ?-?-94       IsaacHe     Created
//             11-Jun-96    BruceFo     Fixed bugs, put this header here.
//
//--------------------------------------------------------------------------

#if defined( UNICODE )
#undef UNICODE
#endif

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <direct.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <conio.h>
#include <errno.h>
#include <process.h>
#include <ctype.h>

#define MAXQUEUE    10000
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

/*
 * These are the attributes we use to compare for file attribute identity
 */
const DWORD FILE_ATTRIBUTE_MASK = FILE_ATTRIBUTE_READONLY |
                                  FILE_ATTRIBUTE_HIDDEN   |
                                  FILE_ATTRIBUTE_SYSTEM   |
                                  FILE_ATTRIBUTE_ARCHIVE;

class CProtectedLong
{
    CRITICAL_SECTION    _cs;
    LONG                _value;

public:
    CProtectedLong() { InitializeCriticalSection( &_cs ); _value = 0; }
    LONG operator++(int) {
                        EnterCriticalSection( &_cs );
                        LONG tmp = _value++;
                        LeaveCriticalSection( &_cs );
                        return tmp;
                        }
    LONG operator--( int ) {
                        EnterCriticalSection( &_cs );
                        LONG tmp = _value--;
                        LeaveCriticalSection( &_cs );
                        return tmp;
                        }
    LONG operator+=( LONG incr ) {
                        EnterCriticalSection( &_cs );
                        LONG tmp = (_value += incr );
                        LeaveCriticalSection( &_cs );
                        return tmp;
                        }
    LONG operator=( LONG val ) {
                        EnterCriticalSection( &_cs );
                        _value = val;
                        LeaveCriticalSection( &_cs );
                        return val;
                        }
    operator LONG() { return _value; }
    operator int()  { return _value; }
};

class CHandle
{
    HANDLE _h;

public:
    CHandle() : _h(INVALID_HANDLE_VALUE) { }
    ~CHandle();
    HANDLE operator=( HANDLE h );
    BOOL operator==( HANDLE h ) { return (h == _h) ? TRUE : FALSE; }
    BOOL operator!=( HANDLE h ) { return (h != _h) ? TRUE : FALSE; }
    operator HANDLE() { return _h; }
};

CHandle::~CHandle()
{
    if( _h != INVALID_HANDLE_VALUE && _h != NULL )
        CloseHandle( _h );
}

HANDLE
CHandle::operator=( HANDLE h )
{
    if( _h != INVALID_HANDLE_VALUE && _h != NULL )
        CloseHandle( _h );
    return _h = h;
}

DWORD dwElapsedTime;            // time we've been copying data
CProtectedLong ulTotalBytesCopied;     // running total count of bytes
CProtectedLong ulTotalBytesSkipped;    // obvious?
CProtectedLong ulTotalBytesScanned;
CProtectedLong nFilesOnQueue;   // number of files to copy or examine
CProtectedLong nFcopy;          // number of files copied
CProtectedLong nSkipped;        // number of files skipped over
CProtectedLong nMappedCopy;     // number of files copied using MapFile...
CProtectedLong nCopyFile;       // number of files copied using CopyFile()...
CProtectedLong nInProgress;     // number of copies currently in progress
CProtectedLong MaxThreads;      // Max number of threads for copying
DWORD ExitCode = 0;             // each thread's exit code

BOOL bThreadStop = FALSE;       // are we trying to exit?
BOOL bWorkListComplete = FALSE; // have we scanned all the directories yet?

BOOL tFlag = FALSE;             // only copy if newer
BOOL iFlag = FALSE;             // skip seemingly identical files
BOOL rFlag = FALSE;             // replace read-only files
BOOL vFlag = FALSE;             // verbose
BOOL AFlag = FALSE;             // keep going even if there are errors
BOOL FFlag = FALSE;             // just produce file list.  No copies
BOOL oFlag = TRUE;              // should we overwrite files already at dest?
BOOL wFlag = FALSE;             // should we wait for the source to show up?
BOOL qFlag = FALSE;             // quiet mode?
BOOL yFlag = FALSE;             // no recurse on target?
BOOL zFlag = FALSE;             // no recurse on source?

BOOL pFlag = FALSE;             // pattern?
CHAR szPattern[100];            // pattern string, if pFlag is TRUE

struct WorkList                 // copy file at 'src' to 'dest'
{
    struct WorkList *next;
    char *src;                   // Pathname relative to the source
    WIN32_FIND_DATA srcfind;
    char *dest;
} *WorkList = NULL;
struct WorkList* WorkListTail = NULL; // always add files to copy to the *tail*
                                // of the work list. This is to make
                                // sure we always do work in order, instead
                                // of starting on a directory but finishing
                                // it much much much later, because we've
                                // pushed all the work to the deep tail of
                                // the list and never returned to it!

CHandle hWorkAvailSem;           // signalled whenever there's work on the list
CHandle hMaxWorkQueueSem;        // used to control lenght of work queue

CRITICAL_SECTION csMsg;         // used to serialize screen output
CRITICAL_SECTION csWorkList;    // used when manipulating the linked list
CRITICAL_SECTION csSourceList;  // used when manipulating the source list

struct SourceList
{
    char    *name;              // pathname of the source.  Ends in '\'
    LONG    count;              // number of files currently being copied
    LONG    ulTotalFiles;       // total for the entire copy
    struct {
        unsigned valid : 1;     // do we know that the source is valid?
    } flags;
} SourceList[ 20 ];
int MaxSources = 0;

char *DirectoryExcludeList[ 50 ];
int MaxDirectoryExcludes = 0;

char OldConsoleTitle[ 100 ];

void
__cdecl
errormsg( char const *pszfmt, ... )
{
    va_list ArgList;
    va_start( ArgList, pszfmt );

    if( bThreadStop == FALSE && pszfmt != NULL ) {
        EnterCriticalSection( &csMsg );
        vprintf( pszfmt, ArgList );
        LeaveCriticalSection( &csMsg );
    }

    va_end( ArgList );
}

DWORD __stdcall
StatusWorker( void *arg )
{
    char ostatbuf[ 100 ];
    char nstatbuf[ 100 ];

    while( bThreadStop == FALSE ) {
        ULONG Remaining = (int)ulTotalBytesScanned - (int)ulTotalBytesCopied - (int)ulTotalBytesSkipped;
        if (Remaining < 1000) {
            sprintf(nstatbuf,
                 "Remaining Files %d Bytes %d",
                 (int)nFilesOnQueue,
                 Remaining);
        } else if (Remaining < 1000000) {
            sprintf(nstatbuf,
                 "Remaining Files %d Bytes %d,%03.3d",
                 (int)nFilesOnQueue,
                 Remaining / 1000,
                 Remaining % 1000);
        } else if (Remaining < 1000000000) {
            sprintf(nstatbuf,
                 "Remaining Files %d Bytes %d,%03.3d,%03.3d",
                 (int)nFilesOnQueue,
                 Remaining / 1000000,
                 (Remaining / 1000) % 1000,
                 Remaining % 1000,
                 Remaining);
        } else {
            sprintf(nstatbuf,
                 "Remaining Files %d Bytes %d,%03.3d,%03.3d,%03.3d",
                 (int)nFilesOnQueue,
                 Remaining / 1000000000,
                 (Remaining / 1000000) % 1000,
                 (Remaining / 1000) % 1000,
                 Remaining % 1000);
        }

         if( strcmp( ostatbuf, nstatbuf ) ) {
             SetConsoleTitle( nstatbuf );
             strcpy( ostatbuf, nstatbuf );
         }
         Sleep( 1 * 1000 );
    }

    SetConsoleTitle( OldConsoleTitle );
    ExitThread( ExitCode );
    arg = arg;
    return 0;
}

void
__cdecl
msg( char const *pszfmt, ... )
{
    if( qFlag )
        return;

    va_list ArgList;
    va_start( ArgList, pszfmt );

    EnterCriticalSection( &csMsg );
    vprintf( pszfmt, ArgList );
    LeaveCriticalSection( &csMsg );
    va_end( ArgList );
}

void
__cdecl
errorexit (char const *pszfmt, ... )
{

    if( bThreadStop == FALSE && pszfmt != NULL ) {
        va_list ArgList;
        va_start( ArgList, pszfmt );

        EnterCriticalSection( &csMsg );
        vprintf( pszfmt, ArgList );
        LeaveCriticalSection( &csMsg );

        va_end( ArgList );
    }

    if( AFlag == FALSE ) {
        bThreadStop = TRUE;

        EnterCriticalSection( &csWorkList );
        WorkList = NULL;
        WorkListTail = NULL;
        LeaveCriticalSection( &csWorkList );

        if( hWorkAvailSem != NULL )
            ReleaseSemaphore( hWorkAvailSem, (int)MaxThreads+1, NULL );

        if( hMaxWorkQueueSem != NULL )
            ReleaseSemaphore( hMaxWorkQueueSem, 1, NULL );

        SetConsoleTitle( OldConsoleTitle );
        ExitThread (ExitCode = 1);
    }
}

DWORD
fcopy( char *src, WIN32_FIND_DATA *srcfind, char *dst, char *errorbuf )
{
    CHandle srcfh;
    CHandle dstfh;
    CHandle hsrc;
    DWORD nBytesWritten, totalbytes;
    char *result = NULL;
    char *psrc;
    BOOL ret = TRUE;
    char dostatus = 0;
    DWORD errcode;

    *errorbuf = '\0';

    if( srcfind->nFileSizeHigh != 0 ) {
        if( CopyFile( src, dst, TRUE ) == FALSE ) {
            errcode = GetLastError();
            sprintf( errorbuf, "CopyFile failed, error %d", errcode );
            return errcode;
        }
        nCopyFile++;

    } else {

        srcfh = CreateFile( src, GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL );
        if( srcfh == INVALID_HANDLE_VALUE ) {
            errcode = GetLastError();
            sprintf( errorbuf, "Unable to open source file, error %d", errcode);
            return errcode;
        }

        dstfh = CreateFile( dst, GENERIC_WRITE, FILE_SHARE_WRITE,NULL,
                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, srcfh);

        if( dstfh == INVALID_HANDLE_VALUE ) {
            errcode = GetLastError();
            sprintf( errorbuf, "Unable to create dest file, error %d", errcode);
            return errcode;
        }

        if( srcfind->nFileSizeLow != 0 ) {
            hsrc = CreateFileMapping( srcfh, NULL, PAGE_READONLY, 0,
                    srcfind->nFileSizeLow, NULL );
            if( hsrc == NULL ) {
                dstfh = INVALID_HANDLE_VALUE;
                DeleteFile( dst );
                if( CopyFile( src, dst, TRUE ) == FALSE ) {
                    errcode = GetLastError();
                    sprintf( errorbuf, "Unable to create file mapping, and CopyFile failed, error %d", errcode );
                    return errcode;
                }
                nCopyFile++;
                ulTotalBytesCopied += srcfind->nFileSizeLow;
                goto DoTime;
            }
            if( (psrc = (char *)MapViewOfFile( hsrc, FILE_MAP_READ, 0, 0, 0 )) == NULL){
                dstfh = INVALID_HANDLE_VALUE;
                DeleteFile( dst );
                if( CopyFile( src, dst, TRUE ) == FALSE ) {
                    errcode = GetLastError();
                    sprintf( errorbuf, "Unable to map source file, and CopyFile failed: error %d", errcode );
                    return errcode;
                }
                nCopyFile++;
                ulTotalBytesCopied += srcfind->nFileSizeLow;
                goto DoTime;
            }
            totalbytes = 0;
            while( !bThreadStop && totalbytes < srcfind->nFileSizeLow && ret == TRUE ) {
                ret = WriteFile( dstfh,
                    psrc + totalbytes,
                    min( 64*1024, srcfind->nFileSizeLow - totalbytes ),
                    &nBytesWritten, NULL );
                totalbytes += nBytesWritten;
                ulTotalBytesCopied += nBytesWritten;
            }
            errcode = GetLastError();
            UnmapViewOfFile( psrc );

            if( bThreadStop == TRUE ) {
                dstfh = INVALID_HANDLE_VALUE;
                DeleteFile( dst );
                *errorbuf = '\0';
                return errcode;
            }

            if( ret == FALSE ) {
                dstfh = INVALID_HANDLE_VALUE;
                DeleteFile( dst );
                if( CopyFile( src, dst, TRUE ) == FALSE ) {
                    errcode = GetLastError();
                    sprintf( errorbuf, "%s: CopyFile failed: error %d", dst, errcode);
                    return GetLastError();
                }
                nCopyFile++;
                ulTotalBytesCopied += srcfind->nFileSizeLow;
                goto DoTime;
            }

            nMappedCopy++;
        }
    }

DoTime:
    if( dstfh == INVALID_HANDLE_VALUE ) {
        dstfh = CreateFile( dst, GENERIC_WRITE,
                 FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                 0, NULL );
    }

    if( dstfh == INVALID_HANDLE_VALUE ) {
        errcode = GetLastError();
        DeleteFile( dst );
        sprintf( errorbuf,  "Unable to open destination file to set time, error %d", errcode );
        return errcode;
    }

    if( !SetFileTime( dstfh, &srcfind->ftCreationTime,
         &srcfind->ftLastAccessTime, &srcfind->ftLastWriteTime )) {
             errcode = GetLastError();
             sprintf( errorbuf, "Unable to set destination file times, error %d\n", errcode );
            return errcode;
    }

    nFcopy++;
    return 0;
}

/*
 * Pick the source having the fewest outstanding operations at the moment.
 */
int
SelectSource()
{
    int index = -1;
    struct SourceList *psl;
    struct SourceList *opsl;
    static min;

    EnterCriticalSection( &csSourceList );

    //
    // Find the first valid source
    //
    for( opsl = SourceList; opsl < &SourceList[ MaxSources ]; opsl++ )
            if( opsl->flags.valid == TRUE )
                break;

    //
    // Now locate the source having the fewest pending operations right now
    //
    for( psl = opsl+1; psl < &SourceList[ MaxSources ]; psl++ ) {
        if( psl->flags.valid == TRUE && psl->count < opsl->count )
            opsl = psl;
    }

    if( opsl->flags.valid == TRUE ) {
        opsl->count++;
        index = (int)(opsl - SourceList);
    }

    LeaveCriticalSection( &csSourceList );

    return index;
}

/*
 * We've completed the operation on source 'index'
 */
void
SourceCopyComplete( int index, BOOL fFile )
{
    EnterCriticalSection( &csSourceList );
    SourceList[ index ].count--;
    if (fFile) SourceList[ index ].ulTotalFiles++;
    LeaveCriticalSection( &csSourceList );
}

void
DisableSource( int index )
{
    if( index >= 0 && index < MaxSources ) {
        EnterCriticalSection( &csSourceList );
        if( SourceList[ index ].flags.valid == TRUE ) {
            errormsg( "Disabling %s\n", SourceList[ index ].name );
            SourceList[ index ].flags.valid = FALSE;
        }
        LeaveCriticalSection( &csSourceList );
    }
}
BOOL
FileTimesEqual( CONST FILETIME *pt1, CONST FILETIME *pt2 )
{
    SYSTEMTIME s1, s2;

    if( !FileTimeToSystemTime( pt1, &s1 ) || !FileTimeToSystemTime( pt2, &s2 ) )
        return FALSE;

    return  s1.wHour == s2.wHour &&
            s1.wMinute == s2.wMinute &&
            s1.wMonth == s2.wMonth &&
            s1.wDay == s2.wDay &&
            s1.wYear == s2.wYear;
}
void
PrintFileTime( char *str, CONST FILETIME *ft )
{
    SYSTEMTIME st;

    if( FileTimeToSystemTime( ft, &st ) == FALSE ) {
        errormsg( "????\n" );
        return;
    }

    msg( "%s %u:%u.%u.%u  %u/%u/%u\n", str,
        st.wHour, st.wMinute, st.wSecond, st.wMilliseconds,
        st.wMonth, st.wDay, st.wYear );
}

DWORD __stdcall
ThreadWorker( void *arg )
{
    struct WorkList *pdl = NULL;
    HANDLE hdestfind;
    WIN32_FIND_DATA destfind;
    int index = 0;
    char errorbuf[ 100 ];
    char pathbuf[ MAX_PATH ];
    DWORD errcode;

    MaxThreads++;

    while( 1 ) {
        if( pdl != NULL ) {
            free( pdl->src );
            free( pdl->dest );
            free( pdl );
            pdl = NULL;
        }

        if( bThreadStop == TRUE )
            break;

        // Poll for new stuff every 2 seconds. If the thread is set to stop,
        // then go away.
        DWORD dwWait;
        while( 1 )
        {
            dwWait = WaitForSingleObject( hWorkAvailSem, 1000 );
            if( dwWait == WAIT_OBJECT_0 ) {
                break;
            }

            if( dwWait == WAIT_TIMEOUT ) {
                if( bThreadStop == TRUE )
                    break;
            } else {
                errormsg( "Thread %p: Semaphore wait failed\n", arg );
                break;
            }
        }
        if ( dwWait != WAIT_OBJECT_0 ) {
            break;
        }

        // pick an item off the head of the work list
        EnterCriticalSection( &csWorkList );
        pdl = WorkList;
        if( pdl != NULL ) {
            WorkList = pdl->next;
            if (NULL == WorkList) {
                // just pulled off the tail entry
                WorkListTail = NULL;
            }
        }
        LeaveCriticalSection( &csWorkList );
        ReleaseSemaphore( hMaxWorkQueueSem, 1, NULL );

        if( pdl == NULL )
            break;

        nFilesOnQueue--;

        if( pdl->srcfind.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                errormsg( "Logic Error:  Directory on work list!\n" );
                continue;
        }

        pdl->srcfind.dwFileAttributes &= FILE_ATTRIBUTE_MASK;

        hdestfind = FindFirstFile( pdl->dest, &destfind );
        if( hdestfind != INVALID_HANDLE_VALUE ) {
            FindClose( hdestfind );
            destfind.dwFileAttributes &= FILE_ATTRIBUTE_MASK;

            /*
             * Destination file exists.  What should we do?
             */

            if( oFlag == FALSE ) {
                /*
                 * We should not overwrite the existing file at the dest
                 */
                if( vFlag )
                    msg( "%s [SKIP: exists]\n", pdl->dest );
                ulTotalBytesSkipped += destfind.nFileSizeLow;
                nSkipped++;
                continue;
            }

            if( iFlag && vFlag ) {

                if( destfind.dwFileAttributes !=pdl->srcfind.dwFileAttributes)
                    msg( "%s [ ATTRIBUTES differ ]\n", pdl->dest );
                if(!FileTimesEqual( &destfind.ftLastWriteTime, &pdl->srcfind.ftLastWriteTime)) {
                    EnterCriticalSection( &csMsg );
                    msg( "%s [ TIMES differ ]\n", pdl->dest );
                    PrintFileTime( "Dest: ", &destfind.ftLastWriteTime );
                    PrintFileTime( "Src: ", &pdl->srcfind.ftLastWriteTime );
                    LeaveCriticalSection( &csMsg );
                }
                if( (destfind.nFileSizeHigh != pdl->srcfind.nFileSizeHigh) ||
                (destfind.nFileSizeLow != pdl->srcfind.nFileSizeLow) )
                    msg( "%s [ SIZES differ ]\n", pdl->dest );
            }

            if( iFlag &&
                (destfind.dwFileAttributes == pdl->srcfind.dwFileAttributes) &&
                FileTimesEqual( &destfind.ftLastWriteTime, &pdl->srcfind.ftLastWriteTime) &&
                (destfind.nFileSizeHigh == pdl->srcfind.nFileSizeHigh) &&
                (destfind.nFileSizeLow == pdl->srcfind.nFileSizeLow) ) {
                    if( vFlag )
                        msg("%s [SKIP: same atts, time, size]\n",pdl->dest);
                    ulTotalBytesSkipped += destfind.nFileSizeLow;
                    nSkipped++;
                    continue;
            }

            if( tFlag &&
                CompareFileTime( &destfind.ftLastWriteTime, &pdl->srcfind.ftLastWriteTime) >= 0 ) {
                    if( vFlag )
                        msg("%s [SKIP: same or newer time]\n", pdl->dest );
                    ulTotalBytesSkipped += destfind.nFileSizeLow;
                    nSkipped++;
                    continue;
            }

            if( destfind.dwFileAttributes & FILE_ATTRIBUTE_READONLY )
                if( rFlag == FALSE && bThreadStop == FALSE ) {
                    if( vFlag )
                        msg( "%s [SKIP: readonly]\n", pdl->dest );
                    ulTotalBytesSkipped += destfind.nFileSizeLow;
                    nSkipped++;
                    continue;
                }

            /*
             * Delete the destination file
             */
            if( destfind.dwFileAttributes & FILE_ATTRIBUTE_READONLY ) {
                destfind.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes( pdl->dest, destfind.dwFileAttributes );
            }

            if( FFlag == FALSE )
                (void)DeleteFile( pdl->dest );

        }

        if( FFlag == FALSE ) {
            while( bThreadStop == FALSE && (index = SelectSource()) >= 0 ) {
                strcpy( pathbuf, SourceList[index].name );
                strcat( pathbuf, pdl->src );

                nInProgress++;
                errcode = fcopy( pathbuf,&pdl->srcfind,pdl->dest,errorbuf);
                nInProgress--;

                if( errcode == 0 ) {
                    SourceCopyComplete( index, TRUE );
                    msg("%s -> %s [OK]\n", pathbuf, pdl->dest );
                    SetFileAttributes(pdl->dest,pdl->srcfind.dwFileAttributes);
                    break;
                }

                if( errcode == ERROR_SWAPERROR ) {
                    errormsg( "%s [ SWAP ERROR, will try again... ]\n",pathbuf);
                    Sleep( 5 * 1000 * 60 );
                    continue;
                }
                if( bThreadStop == FALSE )
                    errormsg( "%s [FAILED: %s ]\n", pathbuf, errorbuf );
                if( AFlag == TRUE )
                    break;
                DisableSource( index );
            }
        } else {
            msg( "%s\n", pdl->dest );
        }

        if( AFlag == FALSE && index < 0 )
            errorexit( "%s [FAILED completely]\n", pdl->dest );
    }

    if( pdl != NULL ) {
        free( pdl->src );
        free( pdl->dest );
        free( pdl );
    }

    if( MaxThreads-- == 1 ) {
        if( ExitCode == 0 ) {
            dwElapsedTime = GetTickCount() - dwElapsedTime;
            dwElapsedTime /= 1000;
            BOOL oldqFlag = qFlag;
            qFlag = FALSE;
            msg( "%u files copied (%u memory mappped, %u CopyFile )\n",
                   (int)nFcopy, (int)nMappedCopy, (int)nCopyFile );
            msg( "%u files skipped\n", (int)nSkipped);
            msg( "%lu bytes in %u seconds: %lu bits/sec\n",
                   (int)ulTotalBytesCopied, dwElapsedTime,
                   dwElapsedTime ? (LONG)(((LONG)ulTotalBytesCopied*8L)/dwElapsedTime) : 0L );

            qFlag = oldqFlag;
            EnterCriticalSection( &csSourceList );
            for (int i = 0; i < MaxSources; i++)
            {
               if (TRUE == SourceList[i].flags.valid)
               {
                   msg( "%s %5lu files\n", SourceList[i].name, SourceList[i].ulTotalFiles);
               }
            }
            LeaveCriticalSection( &csSourceList );
        }
        SetConsoleTitle( OldConsoleTitle );
        ExitProcess( ExitCode );
    }

    ExitThread( ExitCode );
    return 0;
}

void
AddToWorkList(  char *src, char *dest, WIN32_FIND_DATA *pfind )
{
    struct WorkList *pdl;

    if( WaitForSingleObject( hMaxWorkQueueSem, INFINITE ) != WAIT_OBJECT_0 ) {
        errormsg( "Semaphore wait failed, can't add to work list\n" );
        return;
    }

    if( bThreadStop == TRUE )
        return;

    if( (pdl = (struct WorkList *)malloc( sizeof( struct WorkList ) ) ) == NULL ){
        errorexit( "Out of Memory!\n" );
        return;
    }

    if( (pdl->dest = _strdup( dest )) == NULL ) {
        errorexit( "Out of memory!\n" );
        free( pdl );
        return;
    }

    if( (pdl->src = _strdup( src )) == NULL ) {
        errorexit( "Out of memory!\n" );
        free( pdl->dest );
        free( pdl );
        return;
    }

    pdl->srcfind = *pfind;
    pdl->next = NULL;

    EnterCriticalSection( &csWorkList );
    if (NULL == WorkList) {
        WorkListTail = WorkList = pdl;
    } else {
        WorkListTail->next = pdl;   // point the tail to the new entry
        WorkListTail = pdl;         // the new entry becomes the tail
    }
    LeaveCriticalSection( &csWorkList );

    nFilesOnQueue++;
    ReleaseSemaphore( hWorkAvailSem, 1, NULL );
}

void
ScanDirectory(
    char            *relpath,
    char            *dest
    );

void
ScanDirectoryHelp(
    char            *relpath,          // path relative to the source
    char            *dest,             // resulting destination directory
    BOOL            fOnlyDirectories,  // TRUE if we only want to look for dirs
    BOOL            fOnlyFiles         // TRUE if we only want to look for files
    )
{
    int index;
    int destlen = strlen( dest );
    int rellen = strlen( relpath );
    WIN32_FIND_DATA fbuf;
    HANDLE hfind = INVALID_HANDLE_VALUE;
    char SourceName[ MAX_PATH ];

    while( 1 ) {
        if( (index = SelectSource()) < 0 )
            return;
        /*
         * FindFirst/Next is such low overhead on the server that we shouldn't
         * really count it as a load on the server...
         */
        SourceCopyComplete( index, FALSE );

        strcpy( SourceName, SourceList[ index ].name );
        if( rellen ) {
            strcat( SourceName, relpath );
            strcat( SourceName, "\\" );
        }

        strcat( SourceName,
                fOnlyDirectories
                    ? "*.*"
                    : (pFlag ? szPattern : "*.*" ) );

        hfind = FindFirstFile( SourceName, &fbuf );
        if( hfind != INVALID_HANDLE_VALUE )
            break;

        if (pFlag && ERROR_FILE_NOT_FOUND == GetLastError()) {
            // simply no files that match the pattern in the directory
            return;
        }

        errormsg( "Dir scan of %s failed, error %d [DISABLING]\n", SourceName, GetLastError() );
        DisableSource( index );
    }

    do {
        if( !strcmp( fbuf.cFileName, "." ) || !strcmp( fbuf.cFileName, ".." ) )
            continue;

        sprintf( &dest[ destlen ], "%s%s",
            dest[destlen-1] == '\\' ? "" : "\\", fbuf.cFileName );

        if((fbuf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
            //
            // Not a directory
            //

            if (fOnlyDirectories) {
                continue;
            }

            /*
             * Queue this file into the work queue!
             */
            if( rellen ) {
                strcpy( SourceName, relpath );
                strcat( SourceName, "\\" );
            } else
                SourceName[0] = '\0';

            strcat( SourceName, fbuf.cFileName );
            ulTotalBytesScanned += fbuf.nFileSizeLow;
            AddToWorkList( SourceName, dest, &fbuf );
            continue;
        }

        /*
         * We've found a directory.  Descend into it and scan (if we're
         * not excluding it)
         */

        if (fOnlyFiles) {
            continue;
        }

        if (zFlag) { // no recurse on source: ignore it!
            continue;
        }

        for( int i=0; i < MaxDirectoryExcludes; i++ )
            if( !_stricmp( DirectoryExcludeList[i], fbuf.cFileName ) )
                break;

        if( i != MaxDirectoryExcludes ) {
            if( vFlag )
                msg( "Directory: %s [EXCLUDED]\n", dest );
            nSkipped++;
            continue;
        }

        sprintf( &relpath[ rellen ], "%s%s", rellen ? "\\":"", fbuf.cFileName );
        if (yFlag) { // no recurse on target: nuke end of dest (the new dir)
            dest[ destlen ] = '\0';
        }
        ScanDirectory( relpath, dest );
        relpath[ rellen ] = '\0';

    } while( !bThreadStop && FindNextFile( hfind, &fbuf ) == TRUE );

    dest[ destlen ] = '\0';

    FindClose( hfind );
}

void
ScanDirectory(
    char            *relpath,           // path relative to the source
    char            *dest               // resulting destination directory
    )
{
    DWORD dwattrs;

    if( (dwattrs = GetFileAttributes( dest )) == 0xFFFFFFFF ) {
        msg( "Creating Directory: %s\n", dest );
        if( FFlag == FALSE && CreateDirectory( dest, NULL ) == FALSE ) {
            errorexit( "Can not create directory: %s\n", dest );
            return;
        }

    } else if( !(dwattrs & FILE_ATTRIBUTE_DIRECTORY) ) {
            errorexit( "Not a directory: %s\n", dest );
            return;
    }

    if (pFlag) {
        // two passes: one looking for files, one looking for directories

        ScanDirectoryHelp(relpath, dest, FALSE, TRUE);
        ScanDirectoryHelp(relpath, dest, TRUE,  FALSE);
    } else {
        ScanDirectoryHelp(relpath, dest, FALSE, FALSE);
    }
}

static void
appendslash( char *p )
{
    if( p[ strlen(p) - 1 ] != '\\' )
        strcat( p, "\\" );
}

BOOL
rootpath( char *src, char *dst )
{
    char* FilePart;
    char *p;

    if( src == NULL || *src == '\0' )
        return FALSE;

    if( GetFullPathName( src, MAX_PATH, dst, &FilePart ) == 0 )
        return FALSE;

    p = src + strlen(src) - 1;
    if( *p == '.' )
        if( p > src ) {
            p--;
            if( *p != '.' && *p != ':' && (*p == '\\' || *p == '/') )
                strcat( dst, "." );
        }

    return TRUE;
}

static void
Usage( char *s )
{
    errormsg( "Usage: %s [flags] [-p pattern] [src ...] dest\n", s );
    errormsg( "Flags:\n" );

    errormsg( "\t-i   Skip seemingly identical files (time, attrs, size agree)\n" );
    errormsg( "\t-l   Execute at lower priority\n" );
    errormsg( "\t-o   Do not overwrite any files that are already at dest\n" );
    errormsg( "\t-p pattern  Only files matching the pattern are copied\n" );
    errormsg( "\t-q   Quiet mode\n" );
    errormsg( "\t-r   Overwrite read-only files at dest\n" );
    errormsg( "\t-t   Copy only newer files to dest\n" );
    errormsg( "\t-v   Verbose\n" );
    errormsg( "\t-y   Don't recurse on target\n" );
    errormsg( "\t-z   Don't recurse on source\n" );
    errormsg( "\t-A   Keep going even if there are errors\n" );
    errormsg( "\t-F   Don't actually copy files or create directories\n" );
    errormsg( "\t~dir Skip any directory named 'dir'\n" );
    errormsg( "\nIf environment variable FTC_PARANOID is set, then the meaning of -o is\n" );
    errormsg( "reversed: no -o means don't overwrite, -o means go ahead and overwrite.\n" );

    errormsg( "\nExamples:\n" );
    errormsg( "    Copy from two sources, no 'obj' dir:    ftc ~obj \\\\foo\\dir \\\\bar\\dir dest\n" );
    ExitProcess( 1 );
}

BOOL __stdcall
ControlHandlerRoutine( DWORD dwCtrlType )
{
    msg( "Interrupted!\n" );
    bThreadStop = TRUE;
    ExitCode = 1;
    return TRUE;
}


int
__cdecl
main(int argc, char *argv[])
{
    char *p;
    SECURITY_ATTRIBUTES sa;
    int i, argno;
    DWORD IDThread;
    char dest[ MAX_PATH ];
    char relpath[ MAX_PATH ];
    BOOL lFlag = FALSE;             // low priority?
    BOOL fParanoid = FALSE;         // is FTC_PARANOID set in the environment?
    SYSTEM_INFO si;
    CHandle CThread;

    InitializeCriticalSection( &csMsg );
    InitializeCriticalSection( &csWorkList );
    InitializeCriticalSection( &csSourceList );
    ZeroMemory(&si, sizeof( si ));
    GetConsoleTitle( OldConsoleTitle, sizeof( OldConsoleTitle ) );

    TCHAR szParanoid[100];
    DWORD len = GetEnvironmentVariable(TEXT("FTC_PARANOID"), szParanoid, ARRAYLEN(szParanoid));
    if (len > 0)
    {
        fParanoid = TRUE;
    }

    if (fParanoid)
    {
        oFlag = FALSE;
    }
    else
    {
        oFlag = TRUE;
    }

    for( argno = 1;
         argno < argc && (argv[argno][0] == '-' || argv[argno][0] == '/' || argv[argno][0] == '~') ;
         argno++ )
    {
        if( argv[argno][0] == '~' )
        {
            DirectoryExcludeList[ MaxDirectoryExcludes++ ] = &argv[argno][1];

        }
        else for( int j=1; argv[argno][j]; j++ )
        {
            switch( argv[argno][j] ) {
            case 'l':
                lFlag = TRUE;
                break;
            case 'q':
                qFlag = TRUE;
                break;
            case 'y':
                yFlag = TRUE;
                break;
            case 'z':
                zFlag = TRUE;
                break;
            case 'w':
                wFlag = TRUE;
                break;
            case 'o':
                if (fParanoid)
                {
                    oFlag = TRUE;
                }
                else
                {
                    oFlag = FALSE;
                }
                break;
            case 'F':
                FFlag = TRUE;
                break;
            case 'A':
                AFlag = TRUE;
                break;
            case 'p':
                if( j == 1 ) {
                    if ( strcmp( &argv[argno][j], "p" ) == 0 ) {
                        if (argno + 1 < argc) {
                            pFlag = TRUE;
                            strcpy( szPattern, argv[++argno] );
                            goto nextarg;  // go to next argument
                        } else Usage( argv[0] );
                    } else Usage( argv[0] );
                } else Usage( argv[0] );
                break;
            case 'v':
                vFlag = TRUE;
                break;
            case 'r':
                rFlag = TRUE;
                break;
            case 'i':
                iFlag = TRUE;
                break;
            case 't':
                tFlag = TRUE;
                break;
            default:
            case '?':
                Usage( argv[0] );
                break;

            }
        }

nextarg:
        ;

    }

    for( ; argno < argc-1; argno++ ) {
        if( rootpath( argv[argno], dest ) == FALSE ) {
            errorexit( "invalid source\n" );
            ExitProcess(1);
        }
        for( p = dest; *p; p++ )
            if( *p == '/' )
                *p = '\\';
        if( (SourceList[ MaxSources ].name = (char *)malloc( strlen( dest ) + 2 )) == NULL ) {
            errorexit( "Out of memory!\n" );
            ExitProcess(1);
        }
        strcpy( SourceList[ MaxSources++ ].name, dest );
    }

    if( MaxSources == 0 )
        Usage( argv[0] );

    for( i=0; i < MaxDirectoryExcludes; i++ )
        msg( "Exclude Directory: %s\n", DirectoryExcludeList[i] );

    while( 1 ) {
        char statusbuffer[ MAX_PATH ];

        for( i=0; i < MaxSources; i++ ) {
            appendslash( SourceList[i].name );
            if( vFlag == TRUE || wFlag == FALSE )
                msg( "Validating %s....", SourceList[i].name );
            sprintf( statusbuffer, "Validating %s", SourceList[i].name );
            SetConsoleTitle( statusbuffer );
            if( GetFileAttributes( SourceList[i].name ) == 0xFFFFFFFF ) {
                if( vFlag == TRUE || wFlag == FALSE )
                    msg( "[DISABLING %s]\n", SourceList[i].name );
                SourceList[i].flags.valid = FALSE;
            } else {
                SourceList[i].flags.valid = TRUE;
                if( vFlag == TRUE || wFlag == FALSE )
                    msg( "[OK]\n" );
            }
        }

        for( i=0; i < MaxSources; i++ )
            if( SourceList[i].flags.valid == TRUE )
                break;

        if( i != MaxSources )
            break;

        if( wFlag == TRUE ) {
            SetConsoleTitle( "Sleeping awhile..." );
            Sleep( 3 * 1000 * 60 );
        } else {
            SetConsoleTitle( OldConsoleTitle );
            ExitProcess(1);
        }
    }

    SetConsoleTitle( "Sources Present" );
    LONG cThreads = (MaxSources * 3) + 1;

    /*
     * hack for ftc -w -678 to exit when the release shares are available
     */
    if( argno == argc && wFlag )
        ExitProcess( 0 );

    if ( argno != argc - 1 ) {
            Usage( argv[0] );
    } else if (rootpath (argv[argno], dest) == FALSE ) {
            errorexit( "Invalid destination\n" );
            ExitProcess(1);
    }

    for( p = dest; *p; p++ )
        if( *p == '/' )
            *p = '\\';

    for( i=0; i < MaxSources; i++ )
          if (!strcmp(SourceList[i].name, dest)) {
              errorexit("Source == dest == %s", SourceList[i].name );
              ExitThread(1);
          }

    /*
     * Create the semaphores for the work lists
     */
    sa.nLength = sizeof( sa );
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;
    if( (hWorkAvailSem = CreateSemaphore( &sa, 0, 100000, NULL)) == NULL ) {
        errorexit( "Unable to create semaphore (err %u)!\n", GetLastError() );
        ExitProcess(1);
    }

    hMaxWorkQueueSem = CreateSemaphore( &sa, MAXQUEUE, MAXQUEUE, NULL );
    if( hMaxWorkQueueSem == NULL ) {
        errorexit( "Unable to create queue length semaphore (err %u)!\n", GetLastError() );
        ExitProcess( 1 );
    }

    /*
     * Create the thread pool to do the copies
     */
    for( i=0; i < cThreads - 1; i++ ) {
        CThread = CreateThread( (LPSECURITY_ATTRIBUTES)NULL, 0,
              ThreadWorker, (LPVOID *)IntToPtr(i), 0, &IDThread );
        if( CThread == NULL || CThread == INVALID_HANDLE_VALUE )
            break;
        SetThreadPriority( CThread, THREAD_PRIORITY_NORMAL );
        CThread = INVALID_HANDLE_VALUE;
    }

    /*
     * Create the 'update status' thread
     */
    CThread = CreateThread( (LPSECURITY_ATTRIBUTES)NULL, 0,
                            StatusWorker,(LPVOID *)0,0,&IDThread );
    if( CThread != NULL && CThread != INVALID_HANDLE_VALUE ) {
//        SetThreadPriority( CThread, THREAD_PRIORITY_BELOW_NORMAL );
        CThread = INVALID_HANDLE_VALUE;
    }

    SetConsoleCtrlHandler( ControlHandlerRoutine, TRUE );

    /*
     * Produce the directory list
     */
    relpath[0] = '\0';
    dwElapsedTime = GetTickCount();

    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );
    ScanDirectory( relpath, dest );

    if( lFlag )
        SetPriorityClass( GetCurrentProcess(), IDLE_PRIORITY_CLASS );

    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL );

    // OK, now hWorkAvailSem has a count for every item to copy. But when they
    // finish copying, each thread waits on this semaphore again. At the end,
    // everyone will still be waiting! So, add the number of threads to the
    // count, so each thread notices, one by one, that everything's done.
    ReleaseSemaphore( hWorkAvailSem, (int)cThreads+1, NULL );

    if( bThreadStop == FALSE )
        ThreadWorker( 0 );

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gflags\makefile.inc ===
gflags.rc: gflags.dlg gflags.h

$(O)\gflags.res: gflags.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gflags\gflags.h ===
#define DID_GFLAGS                  100
#define ID_FLAG_BASE                200
#define ID_FLAG_1                   201
#define ID_FLAG_2                   202
#define ID_FLAG_3                   203
#define ID_FLAG_4                   204
#define ID_FLAG_5                   205
#define ID_FLAG_6                   206
#define ID_FLAG_7                   207
#define ID_FLAG_8                   208
#define ID_FLAG_9                   209
#define ID_FLAG_10                  210
#define ID_FLAG_11                  211
#define ID_FLAG_12                  212
#define ID_FLAG_13                  213
#define ID_FLAG_14                  214
#define ID_FLAG_15                  215
#define ID_FLAG_16                  216
#define ID_FLAG_17                  217
#define ID_FLAG_18                  218
#define ID_FLAG_19                  219
#define ID_FLAG_20                  220
#define ID_FLAG_21                  221
#define ID_FLAG_22                  222
#define ID_FLAG_23                  223
#define ID_FLAG_24                  224
#define ID_FLAG_25                  225
#define ID_FLAG_26                  226
#define ID_FLAG_27                  227
#define ID_FLAG_28                  228
#define ID_FLAG_29                  229
#define ID_FLAG_30                  230
#define ID_FLAG_31                  231
#define ID_FLAG_32                  232
#define ID_SYSTEM_REGISTRY          233
#define ID_KERNEL_MODE              234
#define ID_IMAGE_FILE_OPTIONS       235
#define ID_IMAGE_FILE_NAME          236
#define ID_DESTINATION_GROUP        237
#define ID_IMAGE_FILE_NAME_LABEL    238
#define ID_LAUNCH                   101
#define ID_COMMAND_LINE             103
#define ID_APPLY                    104

#define ID_SPECIAL_POOL_GROUP        239
#define ID_SPECIAL_POOL_IS_TEXT      240
#define ID_SPECIAL_POOL_IS_NUMBER    241
#define ID_SPECIAL_POOL_TAG          242
#define ID_SPECIAL_POOL_VERIFY_START 243
#define ID_SPECIAL_POOL_VERIFY_END   244

#define ID_IMAGE_DEBUGGER_BUTTON    250
#define ID_IMAGE_DEBUGGER_VALUE     251
#define ID_IMAGE_DEBUGGER_GROUP     252

#define DID_PAGED_HEAP_WARNING      1000
#define ID_PAGEDHEAP_STATIC         1100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gensrv\gensrv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    gensrv.c

Abstract:

    This module implements a program which generates the system service
    dispatch table that is used by the trap handler and the system service
    stub procedures which are used to call the services. These files are
    both generated as text files that must be run through the assembler
    to produce the actual files.

    This program can also be used to generate the user mode system service
    stub procedures.

    If the -P switch is provided, it will also generate Profile
    in the user mode system service stub procedures.

Author:

    David N. Cutler (davec) 29-Apr-1989

Environment:

    User mode.

Revision History:

    Russ Blake (russbl) 23-Apr-1991 - add Profile switch

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

CHAR InputFileNameBuffer[ 128 ];
CHAR StubFileNameBuffer[ 128 ];
CHAR TableFileNameBuffer[ 128 ];
CHAR StubHeaderNameBuffer[ 128 ];
CHAR TableHeaderNameBuffer[ 128 ];
CHAR ProfFileNameBuffer[ 128 ];
CHAR ProfHeaderNameBuffer[ 128 ];
CHAR ProfDotHFileNameBuffer[ 128 ];
CHAR ProfIncFileNameBuffer[ 128 ];
CHAR ProfTblFileNameBuffer[ 128 ];
CHAR InputRecord[132];
CHAR OutputRecord[132];
#define GENSRV_MAXSERVICES 1000
CHAR MemoryArgs[GENSRV_MAXSERVICES];
CHAR ErrorReturns[GENSRV_MAXSERVICES];

// Increment this everytime a change to this file is made
#define GENSRV_VERSION "1.3"

#define GENSRV_MACRONAME "STUBS_ENTRY%d"
#define GENSRV_MACROARGS " %d, %s, %d"
PCHAR UsrStbsFmtMacroName = "USR" GENSRV_MACRONAME;
#define USRSTUBS_MAXARGS 8

PCHAR SysStbsFmtMacroName = "SYS" GENSRV_MACRONAME;

PCHAR StbFmtMacroArgs = GENSRV_MACROARGS;

PCHAR TableEntryFmtNB = "TABLE_ENTRY  %s, %d, %d \n";
PCHAR TableEntryFmtB = "TABLE_ENTRY( %s, %d, %d )\n";
PCHAR TableEntryFmt;

PCHAR ProfTblFmt = "\t\t\"%s\",\n";

PCHAR ProfDotHFmt = "#define NAP_API_COUNT %d \n";

PCHAR ProfIncFmt = "NapCounterServiceNumber\tEQU\t%d\n";

PCHAR ProfTblPrefixFmt = "#include <nt.h>\n\n"
                         "PCHAR NapNames[] = {\n\t\t\"NapCalibrationData\",\n";
PCHAR ProfTblSuffixFmt = "\t\t\"NapTerminalEntry\" };\n";

VOID
ClearArchiveBit(
    PCHAR FileName
    );

SHORT ParseAndSkipShort(
    CHAR **ppBuffer
    );

VOID
PrintStubLine (
    FILE * pf,
    SHORT Index1,
    PCHAR pszMacro,
    SHORT ServiceNumber,
    SHORT ArgIndex,
    SHORT *Arguments,
    SHORT Braces);

VOID
GenerateTable(
    FILE * pf,
    PCHAR pszMacro,
    SHORT ServiceNumber,
    SHORT Args,
    SHORT Braces
    );



int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{

    LONG InRegisterArgCount;
    SHORT Index1;
    SHORT Index2;
    SHORT Limit;
    FILE *InputFile;
    CHAR *Ipr;
    CHAR *Opr;
    SHORT ServiceNumber = 0;
    SHORT TotalArgs = 0;
    SHORT NapCounterServiceNumber;
    FILE *StubFile;
    FILE *TableFile;
    FILE *DebugFile;
    FILE *StubHeaderFile;
    FILE *TableHeaderFile;
    FILE *DefFile;
    FILE *ProfFile;
    FILE *ProfHeaderFile;
    FILE *ProfDotHFile;
    FILE *ProfIncFile;
    FILE *ProfTblFile;
    CHAR Terminal;
    CHAR *GenDirectory;
    CHAR *AltOutputDirectory;
    CHAR *StubDirectory;
    CHAR *InputFileName;
    CHAR *StubFileName = NULL;
    CHAR *TableFileName;
    CHAR *StubHeaderName = NULL;
    CHAR *TableHeaderName = NULL;
    CHAR *TargetDirectory;
    CHAR *TargetExtension;
    CHAR *DefFileData;
    CHAR *ProfFileName;
    CHAR *ProfHeaderName;
    CHAR *ProfDotHFileName;
    CHAR *ProfIncFileName;
    CHAR *ProfTblFileName;
    SHORT Braces;
    SHORT DispatchCount;
    SHORT Profile;
    SHORT LineStart;
    SHORT LineEnd;
    SHORT Arguments[ USRSTUBS_MAXARGS ];
    SHORT ArgIndex;
    SHORT ErrorReturnTable;


    if (argc == 2 && (!strcmp(argv[1],"-?") || !strcmp(argv[1],"/?"))) {
PrintUsage:
        printf("GENSRV: System Service Dispatch Table Generator. Version " GENSRV_VERSION "\n");
        printf("Usage: gensrv [-d targetdir] [-e targetext] [-f defdata] [-B] [-P] [-C] [-R] [-a altoutputdir] [-s stubdir] [services.tab directory]\n");
        printf("-B Use braces\n");
        printf("-P Generate profile stubs data\n");
        printf("-C Spew dispatch count\n");
        printf("-R Generate ConvertToGui error return table\n");
        exit(1);
    }

    //
    // Determine name of target directory for output files.  Requires that
    // the -d switch be specified and that the argument after the switch is
    // the target directory name.  If no -d switch then defaults to "."
    //


    if (argc >= 3 && !strcmp(argv[1],"-d")) {
        TargetDirectory = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        TargetDirectory = ".";
    }

    //
    // Determine name of target extension for output files.  Requires that
    // the -e switch be specified and that the argument after the switch is
    // the target extension string.  If no -e switch then defaults to "s"
    //

    if (argc >= 3 && !strcmp(argv[1],"-e")) {
        TargetExtension = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        TargetExtension = "s";
    }

    //
    // Determine if def file data is to be generated
    //

    if (argc >= 3 && !strcmp(argv[1],"-f")) {
        DefFileData = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        DefFileData = NULL;
    }

    //
    // Change default directory used for generated files.
    //

    if (argc >= 3 && !strcmp(argv[1],"-g")) {
        GenDirectory = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        GenDirectory = ".";
    }


    //
    // Change name of usrstubs.s
    //

    if (argc >= 3 && !strcmp(argv[1],"-stubs")) {
        StubFileName = argv[2];
        argc -= 2;
        argv += 2;
    }

    //
    // Change name of services.stb
    //

    if (argc >= 3 && !strcmp(argv[1],"-sstb")) {
        StubHeaderName = argv[2];
        argc -= 2;
        argv += 2;
    }

    if (argc >= 3 && !strcmp(argv[1],"-stable")) {
        TableHeaderName = argv[2];
        argc -= 2;
        argv += 2;
    }

    //
    // Determine if braces are to be generated
    //

    if (argc >= 2 && !strcmp(argv[1],"-B")) {
        Braces = 1;
        argc -= 1;
        argv += 1;
    } else {
        Braces = 0;
    }

    //
    // Determine if services Profile stubs data is to be generated
    //

    if (argc >= 2 && !strcmp(argv[1],"-P")) {
        Profile = 1;
        argc -= 1;
        argv += 1;
    } else {
        Profile = 0;
    }

    //
    // Determine if dispatch count should be spewed
    //

    if (argc >= 2 && !strcmp(argv[1],"-C")) {
        DispatchCount = 1;
        argc -= 1;
        argv += 1;
    } else {
        DispatchCount = 0;
    }

    //
    // Determine if error return table should be generated
    //

    if (argc >= 2 && !strcmp(argv[1],"-R")) {
        ErrorReturnTable = 1;
        argc -= 1;
        argv += 1;
    } else {
        ErrorReturnTable = 0;
    }

    //
    // ALT_PROJECT output directory.
    //
    if (argc >= 3 && !strcmp(argv[1],"-a")) {
        AltOutputDirectory = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        AltOutputDirectory = GenDirectory;
    }

    //
    // table.stb and services.stb directory.
    //
    if (argc >= 3 && !strcmp(argv[1],"-s")) {
        StubDirectory = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        StubDirectory = GenDirectory;
    }


    //
    // Determine name of input and output files, based on the argument
    // to the program.  If no argument other than program name, then
    // generate the kernel mode system service files (stubs and dispatch
    // table).  Otherwise, expect a single argument that is the path name
    // of the services.tab file and produce output file(s), which
    // contain the user mode system service stubs (and profiled stubs if
    // selected.)
    //

    if (argc == 1) {
        if (DefFileData) {
            goto PrintUsage;
        }

        sprintf(InputFileName = InputFileNameBuffer,
                "%s\\services.tab",GenDirectory);
        sprintf(StubFileName = StubFileNameBuffer,
                "%s\\sysstubs.%s",AltOutputDirectory,TargetExtension);
        sprintf(TableFileName = TableFileNameBuffer,
                "%s\\systable.%s",AltOutputDirectory,TargetExtension);
        if (TableHeaderName == NULL) {
            sprintf(TableHeaderName = TableHeaderNameBuffer,
                    "%s\\table.stb",StubDirectory);
        }
        if (StubHeaderName == NULL) {
            sprintf(StubHeaderName = StubHeaderNameBuffer,
                    "%s\\services.stb",StubDirectory);
        }
    } else {
        if (argc == 2) {
            if (StubDirectory == GenDirectory) {
                StubDirectory = argv[1];
            }

            sprintf(InputFileName = InputFileNameBuffer,
                    "%s\\services.tab",argv[1]);
            if (DefFileData == NULL) {
                if (StubFileName == NULL) {
                    sprintf(StubFileName = StubFileNameBuffer,
                            "%s\\usrstubs.%s",TargetDirectory,TargetExtension);
                }
                if (StubHeaderName == NULL) {
                    sprintf(StubHeaderName = StubHeaderNameBuffer,
                            "%s\\services.stb",StubDirectory);
                }
                if (Profile) {
                    sprintf(ProfFileName = ProfFileNameBuffer,
                            "%s\\napstubs.%s",TargetDirectory,TargetExtension);
                    sprintf(ProfHeaderName = ProfHeaderNameBuffer,
                            "%s\\%s\\services.nap",argv[1],TargetDirectory);
                    sprintf(ProfDotHFileName = ProfDotHFileNameBuffer,
                            ".\\ntnapdef.h");
                    sprintf(ProfIncFileName = ProfIncFileNameBuffer,
                            "%s\\ntnap.inc",TargetDirectory);
                    sprintf(ProfTblFileName = ProfTblFileNameBuffer,
                            ".\\ntnaptbl.c");
                }
            }
            TableFileName = NULL;
        } else {
            goto PrintUsage;
        }
    }


    //
    // Open input and output files.
    //

    InputFile = fopen(InputFileName, "r");
    if (!InputFile) {
        printf("\nfatal error  Unable to open system services file %s\n", InputFileName);
        goto PrintUsage;
    }

    if (DefFileData == NULL) {
        StubFile = fopen(StubFileName, "w");
        if (!StubFile) {
            printf("\nfatal error  Unable to open system services file %s\n", StubFileName);
            fclose(InputFile);
            exit(1);
        }

        StubHeaderFile = fopen(StubHeaderName, "r");
        if (!StubHeaderFile) {
            printf("\nfatal error  Unable to open system services stub file %s\n", StubHeaderName);
            fclose(StubFile);
            fclose(InputFile);
            exit(1);
        }

        if (Profile) {
            ProfHeaderFile = fopen(ProfHeaderName, "r");
            if (!ProfHeaderFile) {
                printf("\nfatal error  Unable to open system services profiling stub file %s\n", ProfHeaderName);
                fclose(StubHeaderFile);
                fclose(StubFile);
                fclose(InputFile);
                exit(1);
            }
            ProfFile = fopen(ProfFileName, "w");
            if (!ProfFile) {
                printf("\nfatal error  Unable to open system services file %s\n", ProfFileName);
                fclose(ProfHeaderFile);
                fclose(StubHeaderFile);
                fclose(StubFile);
                fclose(InputFile);
                exit(1);
            }
            ProfDotHFile = fopen(ProfDotHFileName, "w");
            if (!ProfDotHFile) {
                printf("\nfatal error  Unable to open system services file %s\n", ProfFileName);
                fclose(ProfFile);
                fclose(ProfHeaderFile);
                fclose(StubHeaderFile);
                fclose(StubFile);
                fclose(InputFile);
                exit(1);
            }
            ProfIncFile = fopen(ProfIncFileName, "w");
            if (!ProfIncFile) {
                printf("\nfatal error  Unable to open system services file %s\n", ProfFileName);
                fclose(ProfFile);
                fclose(ProfHeaderFile);
                fclose(StubHeaderFile);
                fclose(StubFile);
                fclose(InputFile);
                exit(1);
            }
            ProfTblFile = fopen(ProfTblFileName, "w");
            if (!ProfTblFile) {
                printf("\nfatal error  Unable to open system services file %s\n", ProfFileName);
                fclose(ProfIncFile);
                fclose(ProfDotHFile);
                fclose(ProfFile);
                fclose(ProfHeaderFile);
                fclose(StubHeaderFile);
                fclose(StubFile);
                fclose(InputFile);
                exit(1);
            }
        }
    }

    if (TableFileName != NULL) {
        TableFile = fopen(TableFileName, "w");
        if (!TableFile) {
            printf("\nfatal error  Unable to open system services file %s\n",
                   TableFileName);
            fclose(StubHeaderFile);
            fclose(StubFile);
            fclose(InputFile);
            exit(1);
        }
        TableHeaderFile = fopen(TableHeaderName, "r");
        if (!TableHeaderFile) {
            printf("\nfatal error  Unable to open system services stub file %s\n",
                   TableHeaderName);
            fclose(TableFile);
            fclose(StubHeaderFile);
            fclose(StubFile);
            fclose(InputFile);
            exit(1);
        }
    } else {
        TableFile = NULL;
        TableHeaderFile = NULL;
    }

    if ( DefFileData ) {
        DefFile = fopen(DefFileData, "w");
        if (!DefFile) {
            printf("\nfatal error  Unable to open def file data file %s\n", DefFileData);
            if ( TableFile ) {
                fclose(TableHeaderFile);
                fclose(TableFile);
            }
            fclose(StubHeaderFile);
            fclose(StubFile);
            fclose(InputFile);
            exit(1);
        }
    } else {
        DefFile = NULL;
    }

    //
    // Output header information to the stubs file and table file. This
    // information is obtained from the Services stub file and from the
    // table stub file.
    //

    if (DefFile == NULL) {
        while( fgets(InputRecord, 132, StubHeaderFile) ) {
            fputs(InputRecord, StubFile);
        }
        if (Profile) {
            while( fgets(InputRecord, 132, ProfHeaderFile) ) {
                fputs(InputRecord, ProfFile);
            }
            fputs(ProfTblPrefixFmt, ProfTblFile);
        }
    }

    if (TableFile != NULL) {
        if (!fgets(InputRecord, 132, TableHeaderFile) ) {
            printf("\nfatal error  Format Error in table stub file %s\n", TableHeaderName);
            fclose(TableHeaderFile);
            fclose(TableFile);
            fclose(StubHeaderFile);
            fclose(StubFile);
            fclose(InputFile);
            exit(1);
        }

        InRegisterArgCount = atol(InputRecord);

        while( fgets(InputRecord, 132, TableHeaderFile) ) {
            fputs(InputRecord, TableFile);
        }
    } else {
        InRegisterArgCount = 0;
    }

    if (Braces) {
        TableEntryFmt = TableEntryFmtB;
    } else {
        TableEntryFmt = TableEntryFmtNB;
    }

    //
    // Read service name table and generate file data.
    //

    while ( fgets(InputRecord, 132, InputFile) ){


        //
        // Generate stub file entry.
        //

        Ipr = &InputRecord[0];
        Opr = &OutputRecord[0];

        //
        // If services.tab was generated by C_PREPROCESSOR, there might
        //  be empty lines in this file. Using the preprocessor allows
        //  people to use #ifdef, #includes, etc in the original services.tab
        //
        switch (*Ipr) {
            case '\n':
            case ' ':
                continue;
        }


        while ((*Ipr != '\n') && (*Ipr != ',')) {
            *Opr++ = *Ipr++;
        }
        *Opr = '\0';


        //
        // If the input record ended in ',', then the service has inmemory
        // arguments and the number of in memory arguments follows the comma.
        //

        MemoryArgs[ServiceNumber] = 0;
        Terminal = *Ipr;
        *Ipr++ = 0;
        if (Terminal == ',') {
            MemoryArgs[ServiceNumber] = (char) atoi(Ipr);
        }

        // Move to the end of the line or past the next comma
        while (*Ipr != '\n') {
            if (*Ipr++ == ',') {
                break ;
            }
        }
        //
        // If an error return value table is to be generated, then the following value
        // might follow:
        //    0 = return 0
        //   -1 = return -1
        //    1 = return status code. (This is the default if no value is specified)
        //
        // This table is used by the dispatcher when convertion to GUI fails.
        //
        if (ErrorReturnTable) {
            if (*Ipr != '\n') {
                ErrorReturns[ServiceNumber] = (char)ParseAndSkipShort(&Ipr);
            } else {
                ErrorReturns[ServiceNumber] = 1;
            }
        }

        //
        //
        // If there are more arguments, then this stub doesn't use the default code (lines 1 to 8)
        // The following format is expected:
        //       LineStart,LineEnd,Argument1[,Argument2[,Argument3]....]
        //
        ArgIndex = 0;
        if (*Ipr != '\n') {
            LineStart = ParseAndSkipShort(&Ipr);
            LineEnd = ParseAndSkipShort(&Ipr);
            while ((ArgIndex < USRSTUBS_MAXARGS) && (*Ipr != '\n')) {
                Arguments[ ArgIndex++ ] = ParseAndSkipShort(&Ipr);
            }
        } else {
            LineStart = 1;
            LineEnd = 8;
        }


        TotalArgs += MemoryArgs[ServiceNumber];

        if ( MemoryArgs[ServiceNumber] > InRegisterArgCount ) {
            MemoryArgs[ServiceNumber] -= (CHAR)InRegisterArgCount;
        } else {
            MemoryArgs[ServiceNumber] = 0;
        }

        if ( DefFile ) {
            fprintf(DefFile,"    Zw%s\n",OutputRecord);
            fprintf(DefFile,"    Nt%s\n",OutputRecord);
        } else {
            for (Index1=LineStart; Index1<=LineEnd; Index1++) {
                if (!TableFile) {
                    PrintStubLine(StubFile, Index1, UsrStbsFmtMacroName,
                                    ServiceNumber, ArgIndex, Arguments, Braces);

                    if (Profile) {
                        PrintStubLine(ProfFile, Index1, UsrStbsFmtMacroName,
                                        ServiceNumber, ArgIndex, Arguments, Braces);

                        if (Index1 == LineStart) {
                            fprintf(ProfTblFile,ProfTblFmt,
                                    OutputRecord,
                                    MemoryArgs[ServiceNumber]);
                            if (!strcmp(OutputRecord,
                                        "QueryPerformanceCounter")) {
                                NapCounterServiceNumber = ServiceNumber;
                            }
                        }
                    }
                } else {

                  PrintStubLine(StubFile, Index1, SysStbsFmtMacroName,
                                    ServiceNumber, ArgIndex, Arguments, Braces);
                }
            }


        }

        //
        // Generate table file entry and update service number.
        //

        if (TableFile != NULL) {

            fprintf(TableFile,
                    TableEntryFmt,
                    InputRecord,
                    (MemoryArgs[ServiceNumber] ? 1 : 0 ),
                    MemoryArgs[ServiceNumber]);

        }
        ServiceNumber = ServiceNumber + 1;
    }

    if (TableFile == NULL) {
        DebugFile = StubFile;
    } else {
        DebugFile = TableFile;
    }

    //
    // Generate Error Return table if required.
    // This table must be concatenated at the end of the  system call service table.
    //
    if (ErrorReturnTable && (TableFile != NULL)) {
        GenerateTable(TableFile, "ERRTBL", ServiceNumber, FALSE, Braces);
    }

    if (DispatchCount ) {
        if ( Braces ) {
            fprintf(DebugFile, "\n\nDECLARE_DISPATCH_COUNT( %d, %d )\n", ServiceNumber, TotalArgs);
        } else {
            fprintf(DebugFile, "\n\nDECLARE_DISPATCH_COUNT 0%xh, 0%xh\n", ServiceNumber, TotalArgs);
        }
    }

    if (TableFile != NULL) {
        //
        // Generate highest service number.
        //

        if ( Braces )
            fprintf(TableFile, "\nTABLE_END( %d )\n", ServiceNumber - 1);
        else
            fprintf(TableFile, "\nTABLE_END %d \n", ServiceNumber - 1);

        //
        // Generate number of arguments in memory table.
        //
        GenerateTable(TableFile, "ARGTBL", ServiceNumber, TRUE, Braces);

        fclose(TableHeaderFile);
        fclose(TableFile);
    }

    if (!DefFile) {
        fprintf(StubFile, "\nSTUBS_END\n");
        fclose(StubHeaderFile);
        fclose(StubFile);
        if (Profile) {
            fprintf(ProfFile, "\nSTUBS_END\n");
            fprintf(ProfTblFile, ProfTblSuffixFmt);
            fprintf(ProfDotHFile, ProfDotHFmt, ServiceNumber);
            fprintf(ProfIncFile, ProfIncFmt, NapCounterServiceNumber);
            fclose(ProfHeaderFile);
            fclose(ProfFile);
            fclose(ProfDotHFile);
            fclose(ProfTblFile);
        }
    }

    fclose(InputFile);

    //
    // Clear the Archive bit for all the files created, since they are
    // generated, there is no reason to back them up.
    //
    ClearArchiveBit(TableFileName);
    ClearArchiveBit(StubFileName);
    if (DefFile) {
        ClearArchiveBit(DefFileData);
    }
    if (Profile) {
        ClearArchiveBit(ProfFileName);
        ClearArchiveBit(ProfDotHFileName);
        ClearArchiveBit(ProfIncFileName);
        ClearArchiveBit(ProfTblFileName);
    }
    return (0);

}

VOID
PrintStubLine (
    FILE * pf,
    SHORT Index1,
    PCHAR pszMacro,
    SHORT ServiceNumber,
    SHORT ArgIndex,
    SHORT *Arguments,
    SHORT Braces
    )
{
    SHORT Index2;

    fprintf(pf, pszMacro, Index1);

    fprintf(pf, Braces ? "(" : " ");

    fprintf(pf, StbFmtMacroArgs, ServiceNumber,
            OutputRecord, MemoryArgs[ServiceNumber]);

    for (Index2=0; Index2<ArgIndex; Index2++) {
        fprintf(pf, ", %d", Arguments[Index2]);
    }

    fprintf(pf, Braces ? " )\n" : " \n");
}

SHORT
ParseAndSkipShort(
    CHAR **ppBuffer
    )
{
    SHORT s = (SHORT)atoi(*ppBuffer);
    while (**ppBuffer != '\n') {
        if (*(*ppBuffer)++ == ',') {
            break;
        }
    }
    return s;
}

VOID
ClearArchiveBit(
    PCHAR FileName
    )
{
    DWORD Attributes;

    Attributes = GetFileAttributes(FileName);
    if (Attributes != -1 && (Attributes & FILE_ATTRIBUTE_ARCHIVE)) {
        SetFileAttributes(FileName, Attributes & ~FILE_ATTRIBUTE_ARCHIVE);
    }

    return;
}

VOID
GenerateTable(
    FILE * pf,
    PCHAR pszMacro,
    SHORT ServiceNumber,
    SHORT Args,
    SHORT Braces
    )
{
    SHORT Index1, Index2, Limit, Value;
    PCHAR pValues = (Args ? MemoryArgs : ErrorReturns);

    fprintf(pf, "\n%s_BEGIN\n", pszMacro);

    for (Index1 = 0; Index1 <= ServiceNumber - 1; Index1 += 8) {

        fprintf(pf, "%s_ENTRY%s", pszMacro, Braces ? "(" : " ");

        Limit = ServiceNumber - Index1 - 1;
        if (Limit >= 7) {
            Limit = 7;
        }
        for (Index2 = 0; Index2 <= Limit; Index2 += 1) {
            Value = *(pValues + Index1 + Index2);
            if (Args) {
                Value *= 4;
            }
            fprintf(pf, Index2 == Limit ? "%d" : "%d,", Value);
        }

        if (Limit < 7) {
            while(Index2 <= 7) {
                fprintf(pf, ",0");
                Index2++;
            }
        }

        fprintf(pf, Braces ? ")\n" : " \n");

    }

    fprintf(pf, "\n%s_END\n", pszMacro);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\genlvl\genlvl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    genlvl.c

Abstract:

    This module implements a program which generates the debug print filter
    component id enumeration and the system filter table that are used by
    various components in the system to dynamically filter debug print
    output.

    Two files are generated by this program. A header file that declares an
    enumeration of debug print filter component id, and a source file that
    declares and initializes the individual component filter variables.

Author:

    David N. Cutler (davec) 7-Jan-2000

Environment:

    User mode.

Revision History:

    None.

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>

//
// Increment this everytime a change to this file is made.
//

#define GENLVL_VERSION "1.0"

//
// Define component name table.
//

#define MAXIMUM_NAMES 4096

PCHAR ComponentNameTable[MAXIMUM_NAMES + 1] = {NULL};

//
// Define forward referenced prototypes.
//

ULONG
InsertName(
    IN PCHAR NewName
    );

ULONG
GenerateCmHeaderFile(
    FILE *OutputFile
    );

ULONG
GenerateCmSourceFile(
    FILE *OutputFile
    );

ULONG
GenerateKdSourceFile(
    FILE *OutputFile
    );

ULONG
GenerateNtHeaderFile(
    FILE *OutputFile
    );

//
// Main program.
//

int __cdecl
main(
    int argc,
    char *argv[]
    )

{

    CHAR Buffer[132];
    CHAR CmHeaderFileName[128];
    FILE *CmHeaderFile;
    CHAR CmSourceFileName[128];
    FILE *CmSourceFile;
    ULONG Count;
    PCHAR ComponentDirectory;
    FILE *ComponentFile = NULL;
    CHAR ComponentFileName[128];
    int ExitCode = 0;
    CHAR NtHeaderFileName[128];
    FILE *NtHeaderFile = NULL;
    FILE *KdSourceFile = NULL;
    CHAR KdSourceFileName[128];
    PCHAR TargetDirectory;

    //
    //  Parse arguments.
    //

    if (argc == 2 && (!strcmp(argv[1],"-?") || !strcmp(argv[1],"/?"))) {
        goto PrintUsage;
    }

    //
    // Determine name of target directory for generated files. This requires
    // the -t switch be specified and that the argument after the switch is
    // the target directory name. If no -t switch is specfied, then default
    // to ".".
    //

    if (argc >= 3 && !_stricmp(argv[1],"-t")) {
        TargetDirectory = argv[2];
        argc -= 2;
        argv += 2;

    } else {
        TargetDirectory = ".";
    }

    //
    // Determine name of the component id directory. This is the last input
    // command line argument. If a component id directory is not specified,
    // then default to ".".
    //

    if (argc >= 2) {
        ComponentDirectory = argv[1];
        argc -= 1;
        argv += 1;

    } else {
        ComponentDirectory = ".";
    }

    //
    // There should be no more arguments.
    //

    if (argc != 1) {
        printf("\n  Manformed command line\n");
        ExitCode = 1;
        goto PrintUsage;
    }

    //
    // Open the component id input file.
    //

    sprintf(&ComponentFileName[0], "%s\\componentid.tab", ComponentDirectory);
    ComponentFile = fopen(&ComponentFileName[0], "r");
    if (!ComponentFile) {
        printf("\n  Unable to open component id file %s\n", &ComponentFileName[0]);
        ExitCode = 1;
        goto PrintUsage;
    }

    //
    // Open the kernel debugger source output file.
    //

    sprintf(&KdSourceFileName[0], "%s\\dpfilter.c", TargetDirectory);
    KdSourceFile = fopen(&KdSourceFileName[0], "w");
    if (!KdSourceFile) {
        printf("\n  Unable to open filter source file %s\n", &KdSourceFileName[0]);
        ExitCode = 1;
        goto PrintUsage;
    }

    //
    // Open the configuration manager header output file.
    //

    sprintf(&CmHeaderFileName[0], "%s\\dpfiltercm.h", TargetDirectory);
    CmHeaderFile = fopen(&CmHeaderFileName[0], "w");
    if (!CmHeaderFile) {
        printf("\n  Unable to open filter source file %s\n", &CmHeaderFileName[0]);
        ExitCode = 1;
        goto PrintUsage;
    }

    //
    // Open the configuration manager source output file.
    //

    sprintf(&CmSourceFileName[0], "%s\\dpfiltercm.c", TargetDirectory);
    CmSourceFile = fopen(&CmSourceFileName[0], "w");
    if (!CmSourceFile) {
        printf("\n  Unable to open filter source file %s\n", &CmSourceFileName[0]);
        ExitCode = 1;
        goto PrintUsage;
    }

    //
    // Open the ntrtl.w append header output file.
    //

    sprintf(&NtHeaderFileName[0], "%s\\dpfilter.h", TargetDirectory);
    NtHeaderFile = fopen(&NtHeaderFileName[0], "w");
    if (!NtHeaderFile) {
        printf("\n  Unable to open filter header file %s\n", &NtHeaderFileName[0]);
        ExitCode = 1;
PrintUsage:
        printf("GENLVL: Debug Print Filter Generator. Version " GENLVL_VERSION "\n");
        printf(" Usage: genlvl [-t target directory] [componentid.tab directory]\n");
        goto Exit;
    }

    //
    // Read component id table.
    //

    Count = 0;
    while (fgets(&Buffer[0], 132, ComponentFile) != NULL) {

        //
        // If the the line is null, begins with a blank, or begins with
        // a semicolon, then skip it.
        //

        if ((Buffer[0] == 0) ||
            (Buffer[0] == '\n') ||
            (Buffer[0] == ' ') ||
            (Buffer[0] == ';')) {
            continue;
        }

        //
        // Insert the component name in the component name table.
        //

        Count += InsertName(&Buffer[0]);
        if (Count >= MAXIMUM_NAMES) {
            printf(" Component name table overflow at name %s\n", &Buffer[0]);
            ExitCode = 1;
            goto Exit;
        }
    }

    //
    // Check to determine if an error of eof was encountered.
    //

    if (feof(ComponentFile) == 0) {
        printf(" Error encountered while reading component name file\n");
        ExitCode = 1;
        goto Exit;
    }

    //
    // Generate configuration manager header file.
    //

    if (GenerateCmHeaderFile(CmHeaderFile) == 0) {
        ExitCode = 1;
        goto Exit;
    }

    //
    // Generate configuration manager source file.
    //

    if (GenerateCmSourceFile(CmSourceFile) == 0) {
        ExitCode = 1;
        goto Exit;
    }

    //
    // Generate kernel debugger source file.
    //

    if (GenerateKdSourceFile(KdSourceFile) == 0) {
        ExitCode = 1;
        goto Exit;
    }

    //
    // Generate ntrtl.w append header file.
    //

    if (GenerateNtHeaderFile(NtHeaderFile) == 0) {
        ExitCode = 1;
        goto Exit;
    }

    //
    // Common program exit.
    //
    // Close any files that are open and exit with appropriate exit code.
    //

Exit:
    if (CmHeaderFile != NULL) {
       fclose(CmHeaderFile);
    }

    if (CmSourceFile != NULL) {
        fclose(CmSourceFile);
    }

    if (ComponentFile != NULL) {
        fclose(ComponentFile);
    }

    if (KdSourceFile != NULL) {
        fclose(KdSourceFile);
    }

    if (NtHeaderFile != NULL) {
       fclose(NtHeaderFile);
    }

    return ExitCode;
}

ULONG
GenerateCmHeaderFile(
    FILE *OutputFile
    )

{

    ULONG Count;
    PCHAR Name;

    //
    // Generate opening comments.
    //

    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "// External component filter level definitions.\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "\n");

    //
    // Output all the component variable names.
    //

    Count = 0;
    while ((Name = ComponentNameTable[Count]) != NULL) {
        fprintf(OutputFile, "extern ULONG Kd_%s_Mask;\n", Name);
        Count += 1;
    }

    fprintf(OutputFile, "\n");
    return TRUE;
}

ULONG
GenerateCmSourceFile(
    FILE *OutputFile
    )

{

    ULONG Count;
    PCHAR Name;

    //
    // Generate opening comments.
    //

    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "// Debug print filter level initialization.\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "\n");

    //
    // Output all the component variable names.
    //

    Count = 0;
    while ((Name = ComponentNameTable[Count]) != NULL) {
        fprintf(OutputFile, "    { L\"Session Manager\\\\Debug Print Filter\",\n");
        fprintf(OutputFile, "      L\"%s\",\n", Name);
        fprintf(OutputFile, "      &Kd_%s_Mask,\n", Name);
        fprintf(OutputFile, "      NULL,\n");
        fprintf(OutputFile, "      NULL\n");
        fprintf(OutputFile, "    },\n");
        fprintf(OutputFile, "\n");
        Count += 1;
    }

    return TRUE;
}

ULONG
GenerateKdSourceFile(
    FILE *OutputFile
    )

{

    ULONG Count;
    PCHAR Name;

    //
    // Generate opening comments and typedef.
    //

    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "// Component filter levels.\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "\n");

    //
    // Output all the component variable names with initialization.
    //

    Count = 0;
    while ((Name = ComponentNameTable[Count]) != NULL) {
        fprintf(OutputFile, "ULONG Kd_%s_Mask = 0;\n", Name);
        Count += 1;
    }

    fprintf(OutputFile, "ULONG Kd_ENDOFTABLE_Mask = 0;\n");

    //
    // Output the initialization of the component variable table.
    //

    fprintf(OutputFile, "\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "// Component debug print filter table.\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "\n");
    fprintf(OutputFile, "PULONG KdComponentTable[] = {\n");
    Count = 0;
    while ((Name = ComponentNameTable[Count]) != NULL) {
        fprintf(OutputFile, "    &Kd_%s_Mask,\n", Name);
        Count += 1;
    }

    //
    // Output one final dummy entry and close the initialization.
    //

    fprintf(OutputFile, "    &Kd_ENDOFTABLE_Mask\n");
    fprintf(OutputFile, "};\n");
    fprintf(OutputFile, "\n");
    return TRUE;
}

ULONG
GenerateNtHeaderFile(
    FILE *OutputFile
    )

{

    ULONG Count;
    PCHAR Name;

    //
    // Generate opening comments and typedef.
    //

    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "// Component name filter id enumeration and levels.\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "\n");
    fprintf(OutputFile, "#define DPFLTR_ERROR_LEVEL 0\n");
    fprintf(OutputFile, "#define DPFLTR_WARNING_LEVEL 1\n");
    fprintf(OutputFile, "#define DPFLTR_TRACE_LEVEL 2\n");
    fprintf(OutputFile, "#define DPFLTR_INFO_LEVEL 3\n");
    fprintf(OutputFile, "#define DPFLTR_MASK 0x80000000\n");
    fprintf(OutputFile, "\n");
    fprintf(OutputFile, "typedef enum _DPFLTR_TYPE {\n");

    //
    // Output all the enumerations.
    //

    Count = 0;
    while ((Name = ComponentNameTable[Count]) != NULL) {
        fprintf(OutputFile, "    DPFLTR_%s_ID = %d,\n", Name, Count);
        Count += 1;
    }

    //
    // Output one final dummy entry and close the enumeration.
    //

    fprintf(OutputFile, "    DPFLTR_ENDOFTABLE_ID\n");
    fprintf(OutputFile, "} DPFLTR_TYPE;\n");
    fprintf(OutputFile, "\n");
    return TRUE;
}

//
// Insert component name in component name table.
//

ULONG
InsertName(
    IN PCHAR NewName
    )

{

    ULONG Index;
    ULONG Length;
    PCHAR OldName;

    //
    // Convert the input string to upper case.
    //

    Length = 0;
    while (NewName[Length] != 0) {
        if (NewName[Length] == '\n') {
            NewName[Length] = 0;
            break;
        }

        NewName[Length] = (CHAR)toupper(NewName[Length]);
        Length += 1;
    }

    //
    // Search for a duplicate name in the component name table.
    //

    Index = 0;
    while ((OldName = ComponentNameTable[Index]) != NULL) {
        if (strcmp(OldName, NewName) == 0) {
            printf(" Duplicate component name %s ignored.\n", NewName);
            return 0;
        }

        Index += 1;
    }

    //
    // Allocate a new table entry, copy the new name to the entry, and
    // insert the new entry in the table.
    //

    OldName = malloc(Length + 1);
    if (!OldName) {
        printf("Out of memory\n");
        return 0;
    }
    strcpy(OldName, NewName);
    ComponentNameTable[Index] = OldName;
    ComponentNameTable[Index + 1] = NULL;
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\gbit.c ===
/*
 * bitmap allocation routines.
 *
 * utility routines to manage a bit-mapped free list, and find
 * free sections
 */

#include "windows.h"
#include "gutils.h"

#ifdef REWRITE
Timings on windiff indicated that not much time was spent here, so it wasn't
worth the rewrite. BUT - could do much better.  To find the first bit in
a dword mask it with FFFF0000 to see which half the bit is in and then
go on by five binary chops.  (You need to wory about the byte order and bit order
of the bitmap - and I haven't - but the code is something like
bitnum = 0
if (dw&0xffff0000) {bitnum +=16; dw >>=16}
if (dw&0x0000ff00) {bitnum +=8;  dw >>=8}
if (dw&0x000000f0) {bitnum +=4;  dw >>=4}
if (dw&0x0000000c) {bitnum +=2;  dw >>=2}
if (dw&0x00000002) {bitnum +=1;  dw >>=1}

Forget the "find the biggest section" stuff - change the spec and just
return(a place if we find enough it or fail.
Special case to search more efficiently for sections of up to 32 bits.
(For mamory heap usage this means that we will have one heap that handles
requests from (say) 16 to 512 bytes (16 bytes per bit) and another heap
for requests (say) 513 to 4096 bytes (128 bits per byte) and so on.

In this case create a mask in a dword with the number of bits set that
we are looking for (keep this we might need it again), shift it the
number of bits to correspond to the start bit that we found (it's two
dwords by now as it will likely shift across a dword boundary) and then
just mask to see if all those bits are on i.e. if ((mask & dw)==mask)

Later.  Maybe.
Laurie

#endif //REWRITE


/* routines to manage bitmapped freelists. Each map is an array
 * of unsigned longs where bit 0 of the first long represents
 * block 1
 */

BOOL gbit_set(DWORD FAR * map, long blknr, long nblks, BOOL op_set);

/* initialise a pre-allocated map of ulongs to represent a free
* area of nblks
*/
void APIENTRY
gbit_init(DWORD FAR * map, long nblks)
{
	long i;
	long leftover = nblks % 32;
	long blks = nblks / 32;
	DWORD last = 0;

	for (i=0; i < blks; i++) {
		map[i] = 0xffffffff;
	}
	for (i = 0; i < leftover; i++) {
		last = (last << 1) | 1;
	}
	if(leftover)
		map[blks] = last;
}

/* mark a region starting at blknr for nblks, as busy (ie 0) */
BOOL APIENTRY
gbit_alloc(DWORD FAR * map, long blknr, long nblks)
{
	return(gbit_set(map, blknr, nblks, FALSE));
}


/* mark region - if op_set, to 1s, otherwise to 0s */
BOOL
gbit_set(DWORD FAR * map, long blknr, long nblks, BOOL op_set)
{
	long first;
	long last;
	long fullwords;
	long startbit, startword;
	long i;
	DWORD dword = 0;

	blknr--;
	first = min(32 - (blknr % 32), nblks);
	nblks -= first;
	last = nblks % 32;
	fullwords = (nblks - last) / 32;
	
	startword = blknr / 32;
	startbit = blknr % 32;
	for (i = 0; i < first; i++) {
		dword = (dword << 1) | 1;
	}
	dword <<= startbit;
	if (op_set) {
		map[startword] |= dword;
		dword = 0xffffffff;
	} else {
		map[startword] &= ~dword;
		dword = 0;
	}
	startword++;
	for (i = 0; i < fullwords; i++) {
		map[startword+i] = dword;
	}
	startword += fullwords;
	for(i = 0, dword = 0; i < last; i++) {
		dword = (dword << 1) | 1;
	}
	if (last) {
		if (op_set) {
			map[startword] |= dword;
		} else {
			map[startword] &= ~dword;
		}
	}

	return(TRUE);
}

/* mark region of nblks starting at blknr to 0s - ie not busy */
BOOL APIENTRY
gbit_free(DWORD FAR * map, long blknr, long nblks)
{
	return(gbit_set(map, blknr, nblks, TRUE));
}


/* find a free segment (ie contiguous sequence of 1s) of nblks in length.
 * If not found, find longest sequence. Store address of segment in *blknr.
 *
 * Return value is nr of blks in sequence found. Region is *not* marked busy.
 */
long APIENTRY
gbit_findfree(DWORD FAR* map, long nblks, long mapsize, long FAR * blknr)
{
	long curblk, startblk, len, i;
	long startbit, nfull, nlast, nbitsleft;
	DWORD mask;
	long mapblks = (mapsize + 31) / 32;
	long aubegin = 0, aulen = 0;
	long curbit = 0;

	/* main loop looking at segments */
	for (curblk = 0; curblk < mapblks; ) {
loop:
		/* loop finding first 1 */
		for (; curblk < mapblks; curblk++, curbit = 0) {
			if (map[curblk] > 0) {
				break;
			}
		}
		if (curblk >= mapblks)
			break;
		
		/* find first 1 in this long */
		startblk = curblk;
		for (mask = 1, i = 0; i < curbit; i++) {
			mask <<= 1;
		}
		for(; curbit < 32; curbit++, mask <<= 1) {
			if (map[curblk] & mask) {
				break;
			}
		}
		if (curbit >= 32) {
			/* abandon this word - start again with next word */
			curblk++;
			curbit = 0;
			goto loop;
		}

		/* we've now found a 1 - calc remaining
		 * bits in this word, complete words etc required.
		 */
		startbit = curbit;
		nbitsleft = min( (32 - curbit), nblks);
		nfull = (nblks - nbitsleft) / 32;
		nlast = (nblks - nbitsleft) % 32;

		/* check for required sequence within this word */

		for (i = 0; i < nbitsleft; i++, curbit++, mask <<= 1) {
			if ((map[curblk] & mask) == 0) {
				/* abandon and start again - start
				 * next pass at curbit in same word
				 */
				/* store free region if longest yet */
				if (i > aulen) {
					aulen = i;
					aubegin = curblk * 32 + startbit +1;
				}
				goto loop;
			}
		}
		
		/* check for nfull full words */
		for (curblk++; curblk <= startblk + nfull; curblk++) {
			if (curblk >= mapblks) {
				/* end of map - abandon here and exit at top
				 * of loop
				 */
				len = nbitsleft +
					((curblk - (startblk + 1)) * 32);
				if (len > aulen) {
					aubegin = startblk * 32 + startbit + 1;
					aulen = len;
				}
				goto loop;
			}
			if (map[curblk] != 0xffffffff) {
				/* not a full word - start again at this bit */
				len = 0;
				curbit = 0;
				for (mask = 1; mask & map[curblk]; mask <<= 1) {
					len++;
					curbit++;
				}
				len += nbitsleft +
					(curblk - (startblk+ 1)) * 32;
				if (len > aulen) {
					aulen = len;
					aubegin = startblk * 32 + startbit + 1;
				}
				/* continue with current blk, bit */
				goto loop;
			}
		}

		/* left-over bits required in last word */
		mask = 1;
		for (curbit = 0; curbit < nlast;  curbit++, mask <<= 1) {
			if ((map[curblk] & mask) == 0) {
				len = nbitsleft + (nfull * 32);
				len += curbit;
				if (len > aulen) {
					aulen = len;
					aubegin = startblk * 32 + startbit + 1;
				}
				goto loop;
			}
		}
		/* ok - found a block big enough! */
		aubegin = startblk * 32 + startbit + 1;
		*blknr = aubegin;
		return(nblks);
	}

	/* end of map - return longest sequence */
	*blknr = aubegin;
	return(aulen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\generr\generr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    generr.c

Abstract:

    This module contains code to generate the NT status code to DOS
    error code table that is used by the runtime to translate status
    codes.

Author:

    David N. Cutler (davec) 2-Dec-1992

Revision History:

--*/

#include <windows.h>
#include "stdio.h"
#include "stdarg.h"
#include "stdlib.h"

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

//
// The following error code table contains paired entries in a singly
// dimensioned array. The first member of a paired entry is an NT status
// code and the second member is the DOS error code that it translates to.
//
// To add a value to this table simply insert the NT status/DOS error code
// pair anywhere is the table. If multiple NT status codes map to a single
// DOS error code, then insert a paired entry for each of the code pairs.
//
#ifdef i386
#pragma warning (4:4018)        // lower to -W4
#endif
LONG UNALIGNED *CodePairs;
ULONG TableSize;

//
// Define run table entry structure.
//

typedef struct _RUN_ENTRY {
    ULONG BaseCode;
    USHORT RunLength;
    USHORT CodeSize;
} RUN_ENTRY, *PRUN_ENTRY;

//
// Define forward referenced procedure prptotypes.
//

ULONG
ComputeCodeSize (
    IN ULONG Start,
    IN ULONG Length
    );

ULONG
ComputeRunLength (
    IN ULONG Start
    );

LONG UNALIGNED *
ReadErrorTable(
    IN FILE *InFile,
    OUT PULONG TableSize
    );


//
// This program generates a header file that is included by the error
// translation module in ntos/rtl.
//

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];

{

    ULONG Count;
    ULONG Index1;
    ULONG Index2;
    ULONG Length;
    FILE *OutFile;
    PCHAR OutName;
    FILE *InFile;
    PCHAR InName;
    RUN_ENTRY *RunTable;
    ULONG Size;
    ULONG Temp;

    if (argc != 3) {
        fprintf(stderr, "Usage: GENERR <input_obj> <output_h>\n");
        perror("GENERR");
        exit(1);
    }

    //
    // Open file for input.
    //

    InName = argv[1];
    InFile = fopen(InName, "rb");
    if (InFile == NULL) {
        fprintf(stderr, "GENERR: Cannot open %s for reading.\n", InName);
        perror("GENERR");
        exit(1);
    }

    CodePairs = ReadErrorTable( InFile, &TableSize );
    if (CodePairs == NULL) {
        fprintf(stderr, "CodePairs[] not found in %s.\n", InName);
        perror("GENERR");
        exit(1);
    }

    fclose(InFile);

    RunTable = malloc(TableSize / 4);
    if (RunTable == NULL) {
        fprintf(stderr, "Out of memory.\n");
        perror("GENERR");
        exit(1);
    }

    //
    // Create file for output.
    //

    OutName = argv[2];
    fprintf(stderr, "GENERR: Writing %s header file.\n", OutName );
    OutFile = fopen(OutName, "w");
    if (OutFile == NULL) {
        fprintf(stderr, "GENERR: Cannot open %s for writing.\n", OutName);
        perror("GENERR");
        exit(1);
    }

    //
    // Sort the code translation table.
    //

    for (Index1 = 0; Index1 < (TableSize / 4); Index1 += 2) {
        for (Index2 = Index1; Index2 < (TableSize / 4); Index2 += 2) {
            if ((ULONG)CodePairs[Index2] < (ULONG)CodePairs[Index1]) {
                Temp = CodePairs[Index1];
                CodePairs[Index1] = CodePairs[Index2];
                CodePairs[Index2] = Temp;
                Temp = CodePairs[Index1 + 1];
                CodePairs[Index1 + 1] = CodePairs[Index2 + 1];
                CodePairs[Index2 + 1] = Temp;
            }
        }
    }

    //
    // Output the initial structure definitions and the translation
    // table declaration.
    //

    fprintf(OutFile, "//\n");
    fprintf(OutFile, "// Define run length table entry structure type.\n");
    fprintf(OutFile, "//\n");
    fprintf(OutFile, "\n");
    fprintf(OutFile, "typedef struct _RUN_ENTRY {\n");
    fprintf(OutFile, "    ULONG BaseCode;\n");
    fprintf(OutFile, "    USHORT RunLength;\n");
    fprintf(OutFile, "    USHORT CodeSize;\n");
    fprintf(OutFile, "} RUN_ENTRY, *PRUN_ENTRY;\n");

    fprintf(OutFile, "\n");
    fprintf(OutFile, "//\n");
    fprintf(OutFile, "// Declare translation table array.\n");
    fprintf(OutFile, "//\n");
    fprintf(OutFile, "\n");
    fprintf(OutFile, "CONST USHORT RtlpStatusTable[] = {");
    fprintf(OutFile, "\n    ");

    //
    // Calculate the run length entries and output the translation table
    // entries.
    //

    Count = 0;
    Index1 = 0;
    Index2 = 0;
    do {
        Length = ComputeRunLength(Index1);
        Size = ComputeCodeSize(Index1, Length);
        RunTable[Index2].BaseCode = CodePairs[Index1];
        RunTable[Index2].RunLength = (USHORT)Length;
        RunTable[Index2].CodeSize = (USHORT)Size;
        Index2 += 1;
        do {
            if (Size == 1) {
                Count += 1;
                fprintf(OutFile,
                        "0x%04lx, ",
                        CodePairs[Index1 + 1]);

            } else {
                Count += 2;
                fprintf(OutFile,
                        "0x%04lx, 0x%04lx, ",
                        CodePairs[Index1 + 1] & 0xffff,
                        (ULONG)CodePairs[Index1 + 1] >> 16);
            }

            if (Count > 6) {
                Count = 0;
                fprintf(OutFile, "\n    ");
            }

            Index1 += 2;
            Length -= 1;
        } while (Length > 0);
    } while (Index1 < (TableSize / 4));

    fprintf(OutFile, "0x0};\n");

    //
    // Output the run length table declaration.
    //

    fprintf(OutFile, "\n");
    fprintf(OutFile, "//\n");
    fprintf(OutFile, "// Declare run length table array.\n");
    fprintf(OutFile, "//\n");
    fprintf(OutFile, "\n");
    fprintf(OutFile, "CONST RUN_ENTRY RtlpRunTable[] = {");
    fprintf(OutFile, "\n");

    //
    // Output the run length table entires.
    //

    for (Index1 = 0; Index1 < Index2; Index1 += 1) {
        fprintf(OutFile,
                "    {0x%08lx, 0x%04lx, 0x%04lx},\n",
                RunTable[Index1].BaseCode,
                RunTable[Index1].RunLength,
                RunTable[Index1].CodeSize);
    }

    fprintf(OutFile, "    {0x0, 0x0, 0x0}};\n");

    //
    // Close output file.
    //

    fclose(OutFile);
    return 0;
}

ULONG
ComputeCodeSize (
    IN ULONG Start,
    IN ULONG Length
    )

//
// This function computes the size of the code entries required for the
// specified run and returns the length in words.
//

{

    ULONG Index;

    for (Index = Start; Index < (Start + (Length * 2)); Index += 2) {
        if (((ULONG)CodePairs[Index + 1] >> 16) != 0) {
            return 2;
        }
    }

    return 1;
}

ULONG
ComputeRunLength (
    IN ULONG Start
    )

//
// This function locates the next set of monotonically increasing status
// codes values and returns the length of the run.
//

{

    ULONG Index;
    ULONG Length;

    Length = 1;
    for (Index = Start + 2; Index < (TableSize / 4); Index += 2) {
        if ((ULONG)CodePairs[Index] != ((ULONG)CodePairs[Index - 2] + 1)) {
            break;
        }

        Length += 1;
    }

    return Length;
}

LONG UNALIGNED *
ReadErrorTable(
    IN FILE *InFile,
    OUT PULONG TableSize
    )
{
    ULONG fileSize;
    PLONG fileBuf;
    LONG UNALIGNED *searchEnd;
    LONG pattern[4] = { 'Begi','n ge','nerr',' tbl' };
    LONG UNALIGNED *p;
    ULONG result;
    ULONG i;
    LONG UNALIGNED *tableStart;

    //
    // Get the file size and allocate a buffer large enough for it.
    //

    if (fseek( InFile, 0, SEEK_END ) == -1)  {
        return NULL;
    }
    fileSize = ftell( InFile );
    if (fileSize == 0) {
        return NULL;
    }

    fileBuf = malloc( fileSize );
    if (fileBuf == NULL) {
        return NULL;
    }

    //
    // Read the file into the buffer
    //

    if (fseek( InFile, 0, SEEK_SET ) == -1) {
        free (fileBuf);
        return NULL;
    }
    result = fread( fileBuf, fileSize, 1, InFile );
    if (result != 1) {
        free (fileBuf);
        return NULL;
    }
    searchEnd = fileBuf + (fileSize - sizeof(pattern)) / sizeof(ULONG);

    //
    // Step through the buffer looking for our pattern.
    //

    p = fileBuf;
    while (p < searchEnd) {

        //
        // Match in this position?
        //

        for (i = 0; i < 4; i++) {

            if (*(p + i) != pattern[i]) {

                //
                // No match here
                //

                break;
            }
        }

        if (i == 4) {

            //
            // Found the pattern.  Now find out how big the table is.  We
            // do this by searching for the last pair, which has
            // 0xffffffff as its first element.
            //

            p += 4;

            tableStart = p;
            while (p < searchEnd) {

                if (*p == 0xffffffff) {

                    //
                    // Found the terminating pair.
                    //

                    *TableSize = (ULONG)((p - tableStart + 2) * sizeof(ULONG));
                    return tableStart;
                }

                p += 2;
            }

            free (fileBuf);
            return NULL;
        }

        //
        // Next position
        //

        p = (PLONG)((ULONG_PTR)p + 1);
    }

    free (fileBuf);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gflags\gflags.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    gflags.cxx

Abstract:

    This module contains the routines to make global flags 
    settings (i.e. the FLG_XXX constants from ntexapi.h).

Author:

    - others -                                     
    Silviu Calinoiu (silviuc) 09-Nov-2001

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.dbg>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "gflags.h"

//
// Valid global flag bits for the three scenarios: per image flags,
// system wide flags (require a reboot or will affect future processes
// in user mode) and kernel mode flags on the fly.
//

#define GFLGS_VALID_KERNEL_MODE_FLAGS ((VALID_KERNEL_MODE_FLAGS) \
                                       & ~FLG_KERNEL_STACK_TRACE_DB \
                                       & ~FLG_POOL_ENABLE_TAGGING)

#define GFLGS_VALID_SYSTEM_REGISTRY_FLAGS ((VALID_SYSTEM_REGISTRY_FLAGS))

#define GFLGS_VALID_IMAGE_FILE_NAME_FLAGS ((VALID_IMAGE_FILE_NAME_FLAGS))


CHAR GflagsHelpText[] = 
    "                                                                  \n"
    "usage: GFLAGS [-r [<Flags>]] |                                    \n"
    "              [-k [<Flags>]] |                                    \n"
    "              [-i <ImageFileName> [<Flags>]] |                    \n"
    "              [-i <ImageFileName> -tracedb <SizeInMb>] |          \n"
    "              [-p <PageHeapOptions>] (use `-p ?' for help)        \n"
    "                                                                  \n"
    "where: <Flags> is a 32 bit hex number (0x12345678) that specifies \n"
    "       one or more global flags to set.                           \n"
    "       -r operates on system registry settings.                   \n"
    "       -k operates on kernel settings of the running system.      \n"
    "       -i operates on settings for a specific image file.         \n"
    "                                                                  \n"
    "       If only the switch is specified, then current settings     \n"
    "       are displayed, not modified.  If flags specified for -i    \n"
    "       option are FFFFFFFF, then registry entry for that image    \n"
    "       is deleted                                                 \n"
    "                                                                  \n"
    "The `-tracedb' option is used to set the size of the stack trace  \n"
    "database used to store runtime stack traces. The actual database  \n"
    "will be created if the `+ust' flag is set in a previous command.  \n"
    "`-tracedb 0' will revert to the default size for the database.    \n"
    "                                                                  \n"
    "If no arguments are specified to GFLAGS then it displays          \n"
    "a dialog box that allows the user to modify the global            \n"
    "flag settings.                                                    \n"
    "                                                                  \n"
    "Flags may either be a single hex number that specifies all        \n"
    "32-bits of the GlobalFlags value, or it can be one or more        \n"
    "arguments, each beginning with a + or -, where the + means        \n"
    "to set the corresponding bit(s) in the GlobalFlags and a -        \n"
    "means to clear the corresponding bit(s).  After the + or -        \n"
    "may be either a hex number or a three letter abbreviation         \n"
    "for a GlobalFlag.  Valid abbreviations are:                       \n"
    "                                                                  \n";

#define _PART_OF_GFLAGS_ 1
#include "..\pageheap\pageheap.cxx"

#if defined(_X86_)

//
// Use function pointers for ntdll import functions so gflags
// can fail with a user friendly message on win9x.
//

#define RtlIntegerToChar            pRtlIntegerToChar
#define NtQueryInformationProcess   pNtQueryInformationProcess
#define RtlCharToInteger            pRtlCharToInteger
#define NtSetSystemInformation      pNtSetSystemInformation
#define NtQuerySystemInformation    pNtQuerySystemInformation

typedef NTSTATUS (NTAPI *PRTLINTEGERTOCHAR)(
    ULONG,
    ULONG,
    LONG,
    PSZ
    );

typedef NTSTATUS (NTAPI *PNTQUERYINFORMATIONPROCESS) (
    IN HANDLE,
    IN PROCESSINFOCLASS,
    OUT PVOID,
    IN ULONG,
    OUT PULONG
    );

typedef NTSTATUS (NTAPI * PRTLCHARTOINTEGER) (
    PCSZ,
    ULONG,
    PULONG
    );

typedef NTSTATUS (NTAPI * PNTSETSYSTEMINFORMATION) (
    IN SYSTEM_INFORMATION_CLASS,
    IN PVOID,
    IN ULONG
    );


typedef NTSTATUS (NTAPI * PNTQUERYSYSTEMINFORMATION) (
    IN SYSTEM_INFORMATION_CLASS,
    OUT PVOID,
    IN ULONG,
    OUT PULONG
    );

PRTLINTEGERTOCHAR pRtlIntegerToChar;
PNTQUERYINFORMATIONPROCESS pNtQueryInformationProcess;
PRTLCHARTOINTEGER pRtlCharToInteger;
PNTSETSYSTEMINFORMATION pNtSetSystemInformation;
PNTQUERYSYSTEMINFORMATION pNtQuerySystemInformation;

#endif


BOOL
GflagsSetTraceDatabaseSize (
    PCHAR ApplicationName,
    ULONG SizeInMb,
    PULONG RealSize
    );

INT_PTR  APIENTRY MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL
EnableDebugPrivilege( VOID );

BOOL
OkToEnablePagedHeap( VOID );

HWND hwndMain;
HWND hwndPagedHeapDlg;

HKEY hSmKey, hMmKey;
DWORD InitialSetFlags;
DWORD LastSetFlags;

//
// Special pool management
//

#define SPECIAL_POOL_OVERRUNS_CHECK_FORWARD   1
#define SPECIAL_POOL_OVERRUNS_CHECK_BACKWARD  0

DWORD LastSetSpecialPoolTag;
DWORD LastSetSpecialPoolOverruns = SPECIAL_POOL_OVERRUNS_CHECK_FORWARD;

TCHAR SpecialPoolRenderBuffer[8 + 1];



CHAR LastDebuggerValue[ MAX_PATH ];

UINT SpecialPool[] = {
        ID_SPECIAL_POOL_GROUP,
        ID_SPECIAL_POOL_IS_TEXT,
        ID_SPECIAL_POOL_IS_NUMBER,
        ID_SPECIAL_POOL_TAG,
        ID_SPECIAL_POOL_VERIFY_START,
        ID_SPECIAL_POOL_VERIFY_END,
        0
        };

UINT Debugger[] = {
        ID_IMAGE_DEBUGGER_GROUP,
        ID_IMAGE_DEBUGGER_VALUE,
        ID_IMAGE_DEBUGGER_BUTTON,
        0
        };

PCHAR SystemProcesses[] = {
        "csrss.exe",
        "winlogon.exe",
        "services.exe",
        "lsass.exe",
        "svchost.exe",
        "ntmssvc.exe",
        "rpcss.exe",
        "spoolsv.exe"
        };

//
// POOL Tagging is always on for .NET server, the "Enable pool tagging" option
// will be greyed out if it is on a .NET server.
// Pool Tagging on XP will still be controlled by GFlags same as w2k.
//
BOOL 	PoolTaggingAlwaysOn = FALSE;
ULONG	PoolTagEnabledFlag  = 0;

EnableSetOfControls(
    HWND hDlg,
    UINT * Controls,
    BOOL Enable
    )
{
    UINT Control ;
    HWND hWnd ;

    Control = *Controls++ ;
    while ( Control )
    {
        hWnd = GetDlgItem( hDlg, Control );

        EnableWindow( hWnd, Enable );

        ShowWindow( hWnd, Enable ? SW_NORMAL : SW_HIDE );

        Control = *Controls++ ;
    }

    return 0;
}

DWORD
GetSystemRegistryFlags( VOID )
{
    DWORD cbKey;
    DWORD GFlags;
    DWORD type;

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      "SYSTEM\\CurrentControlSet\\Control\\Session Manager",
                      0,
                      KEY_READ | KEY_WRITE,
                      &hSmKey
                    ) != ERROR_SUCCESS
       ) {
        MessageBox( hwndMain, "Open Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager", MB_OK );
        ExitProcess( 0 );
        }

    cbKey = sizeof( GFlags );
    if (RegQueryValueEx( hSmKey,
                         "GlobalFlag",
                         0,
                         &type,
                         (LPBYTE)&GFlags,
                         &cbKey
                       ) != ERROR_SUCCESS ||
        type != REG_DWORD
       ) {
        MessageBox( hwndMain, "Value Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\GlobalFlag", MB_OK );
        RegCloseKey( hSmKey );
        ExitProcess( 0 );
        }

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management",
                      0,
                      KEY_READ | KEY_WRITE,
                      &hMmKey
                    ) != ERROR_SUCCESS
       ) {
        MessageBox( hwndMain, "Open Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management", MB_OK );
        RegCloseKey( hSmKey );
        ExitProcess( 0 );
        }

    cbKey = sizeof( LastSetSpecialPoolTag );
    if (RegQueryValueEx( hMmKey,
                         "PoolTag",
                         0,
                         &type,
                         (LPBYTE)&LastSetSpecialPoolTag,
                         &cbKey
                       ) == ERROR_SUCCESS
        ) {

        if (type != REG_DWORD) {
            MessageBox( hwndMain, "Value Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\PoolTag", MB_OK );
            RegCloseKey( hSmKey );
            RegCloseKey( hMmKey );
            ExitProcess( 0 );
        }
    } else {
        LastSetSpecialPoolTag = 0;
    }

    cbKey = sizeof( LastSetSpecialPoolOverruns );
    if (RegQueryValueEx( hMmKey,
                         "PoolTagOverruns",
                         0,
                         &type,
                         (LPBYTE)&LastSetSpecialPoolOverruns,
                         &cbKey
                       ) == ERROR_SUCCESS
        ) {

        if (type != REG_DWORD) {

            MessageBox( hwndMain,
                        "Value Type Error",
                        "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
                        "\\PoolTagOverruns",
                        MB_OK );
            RegCloseKey( hSmKey );
            RegCloseKey( hMmKey );
            ExitProcess( 0 );
        }

        //
        // The only legal values are 0, 1.
        //

        if (LastSetSpecialPoolOverruns != SPECIAL_POOL_OVERRUNS_CHECK_BACKWARD &&
            LastSetSpecialPoolOverruns != SPECIAL_POOL_OVERRUNS_CHECK_FORWARD) {

            MessageBox( hwndMain,
                        "Value Data Error",
                        "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
                        "\\PoolTagOverruns",
                        MB_OK );
            RegCloseKey( hSmKey );
            RegCloseKey( hMmKey );
            ExitProcess( 0 );
        }

    } else {
        LastSetSpecialPoolOverruns = SPECIAL_POOL_OVERRUNS_CHECK_FORWARD;
    }

    return GFlags;
}

BOOLEAN
SetSystemRegistryFlags(
    DWORD GFlags,
    DWORD SpecialPoolTag,
    DWORD SpecialPoolOverruns
    )
{
    if (RegSetValueEx( hSmKey,
                       "GlobalFlag",
                       0,
                       REG_DWORD,
                       (LPBYTE)&GFlags,
                       sizeof( GFlags )
                     ) != ERROR_SUCCESS
       ) {
        MessageBox( hwndMain, "Value Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\GlobalFlag", MB_OK );
        RegCloseKey( hSmKey );
        RegCloseKey( hMmKey );
        ExitProcess( 0 );
        }

    //
    //  Only modify special pool if we went to GUI mode
    //

    if (hwndMain) {

        if (SpecialPoolTag) {

            if (RegSetValueEx( hMmKey,
                               "PoolTag",
                               0,
                               REG_DWORD,
                               (LPBYTE)&SpecialPoolTag,
                               sizeof( SpecialPoolTag )
                               ) != ERROR_SUCCESS
                ) {
                MessageBox( hwndMain,
                            "Value Error",
                            "SYSTEM\\CurrentControlSet\\Control\\Session Manager"
                            "\\Memory Management\\PoolTag",
                            MB_OK );
                RegCloseKey( hSmKey );
                RegCloseKey( hMmKey );
                ExitProcess( 0 );
            }

            if (RegSetValueEx( hMmKey,
                               "PoolTagOverruns",
                               0,
                               REG_DWORD,
                               (LPBYTE)&SpecialPoolOverruns,
                               sizeof( SpecialPoolOverruns )
                               ) != ERROR_SUCCESS
                ) {
                MessageBox( hwndMain,
                            "Value Error",
                            "SYSTEM\\CurrentControlSet\\Control\\Session Manager"
                            "\\Memory Management\\PoolTag",
                            MB_OK );
                RegCloseKey( hSmKey );
                RegCloseKey( hMmKey );
                ExitProcess( 0 );
            }


        } else {

            RegDeleteValue( hMmKey,
                            "PoolTag"
                          );

            RegDeleteValue( hMmKey,
                            "PoolTagOverruns"
                          );
        }
    }

    LastSetFlags = GFlags;

    LastSetSpecialPoolTag = SpecialPoolTag;
    LastSetSpecialPoolOverruns = SpecialPoolOverruns;

    return TRUE;
}

DWORD
GetKernelModeFlags( VOID )
{
    NTSTATUS Status;
    SYSTEM_FLAGS_INFORMATION SystemInformation;

    Status = NtQuerySystemInformation( SystemFlagsInformation,
                                       &SystemInformation,
                                       sizeof( SystemInformation ),
                                       NULL
                                     );
    if (!NT_SUCCESS( Status )) {
        MessageBox( hwndMain, "Value Error", "Kernel Mode Flags", MB_OK );
        ExitProcess( 0 );
        }

    return SystemInformation.Flags;
}

BOOLEAN
AddImageNameToUSTString(
    PCHAR ImageFileName
    )
{
    CHAR *Enabled = NULL;
    HKEY hKey;
    DWORD Result;
    DWORD Length;

    if (strlen( ImageFileName ) == 0)
        return FALSE;

    // Open the Key
    Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                            "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options",
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                            );

    if (Result == ERROR_SUCCESS) {
        // Get the current length of the registry key
        Result = RegQueryValueEx( hKey, "USTEnabled", NULL, NULL, NULL, &Length );

        if (Result == ERROR_SUCCESS){
            // Get a buffer big enough for current key, a ';', and our new name.
            Enabled = (PCHAR)malloc(Length + strlen(ImageFileName)+ 1);

            if (Enabled) {
                // Get the current key value
                Result = RegQueryValueEx( hKey, "USTEnabled", NULL, NULL, (PBYTE)Enabled, &Length );

                if (Result == ERROR_SUCCESS) {
                    // If we are not currently in there, let add ourselves
                    if (!strstr(Enabled, ImageFileName)) {
                        //Watch for a trailing ';'
                        if (Enabled[strlen(Enabled) - 1] != ';')
                            strcat(Enabled, ";");

                        strcat(Enabled, ImageFileName);

                        Result = RegSetValueEx( hKey,
                                                "USTEnabled",
                                                0,
                                                REG_SZ,
                                                (PBYTE)Enabled,
                                                (ULONG)(strlen(Enabled) + 1));
                    }
                }

                free(Enabled);
            } // if enabled
        } // Result == ERROR_SUCCESS on RegQueryValue
        else if (Result == ERROR_FILE_NOT_FOUND) {
                // Key doesnt currently exist so lets just set it.
                Result = RegSetValueEx( hKey,
                                        "USTEnabled",
                                        0,
                                        REG_SZ,
                                        (PBYTE)ImageFileName,
                                        (ULONG)(strlen(ImageFileName) + 1));
        } // Result == ERROR_FILE_NOT_FOUND on RegQueryValue

        RegCloseKey( hKey );
    } // Result == ERROR_SUCCESS on RegCreateKeyEx

    // Did we succeed or not
    if (Result != ERROR_SUCCESS) {
        MessageBox( hwndMain,
                    "Failure adding or accessing User Stack Trace Registry Key",
                    ImageFileName,
                    MB_OK
                  );

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
DelImageNameFromUSTString(
    PCHAR ImageFileName
    )
{
    CHAR *Enabled = NULL;
    CHAR *NameStart = NULL, *NameEnd = NULL;
    HKEY hKey;
    DWORD Result;
    DWORD Length;

    if (strlen( ImageFileName ) == 0)
        return FALSE;

    // Open the Key
    Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                            "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options",
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                            );

    if (Result == ERROR_SUCCESS) {
        // Get the current length of the registry key
        Result = RegQueryValueEx( hKey, "USTEnabled", NULL, NULL, NULL, &Length );

        if (Result == ERROR_SUCCESS) {
            if (Length != 0) {
                 // Get a buffer big enough for current key
                Enabled = (PCHAR)malloc(Length);
                if (Enabled) {
                    // Get the current key value
                    Result = RegQueryValueEx( hKey, "USTEnabled", NULL, NULL, (PBYTE)Enabled, &Length );

                    if (Result == ERROR_SUCCESS) {

                        // If we are currently in there, delete ourselves
                        NameStart = strstr(Enabled, ImageFileName);

                        if (NameStart) {

                            NameEnd = NameStart + strlen(ImageFileName);

                            if (*NameEnd == ';'){
                                NameEnd++;
                                strcpy(NameStart, NameEnd);
                            }
                            else
                                *NameStart = '\0';

                            //Knock off any trailing ';'
                            if (Enabled[strlen(Enabled) - 1] == ';')
                                Enabled[strlen(Enabled) - 1] = '\0';

                            if (strlen(Enabled)) {
                                Result = RegSetValueEx( hKey,
                                                        "USTEnabled",
                                                        0,
                                                        REG_SZ,
                                                        (PBYTE)Enabled,
                                                        (ULONG)(strlen(Enabled) + 1));
                            }
                            else{
                                Result = RegDeleteValue( hKey, "USTEnabled");
                            }
                        }
                    }

                    free(Enabled);
                }
            }
        }
        else if (Result == ERROR_FILE_NOT_FOUND) {
            // This is a case where the registry key does not already exist
            Result = ERROR_SUCCESS;
        }
        RegCloseKey( hKey );
    }

    // Did we succeed or not
    if (Result != ERROR_SUCCESS) {
        MessageBox( hwndMain,
                    "Failure accessing or deleting User Stack Trace Registry Key",
                    ImageFileName,
                    MB_OK
                  );

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SetKernelModeFlags(
    DWORD GFlags
    )
{
    NTSTATUS Status;
    SYSTEM_FLAGS_INFORMATION SystemInformation;

    if (!EnableDebugPrivilege()) {
        MessageBox( hwndMain, "Access Denied", "Unable to enable debug privilege", MB_OK );
        ExitProcess( 0 );
        }

    SystemInformation.Flags = GFlags;
    Status = NtSetSystemInformation( SystemFlagsInformation,
                                     &SystemInformation,
                                     sizeof( SystemInformation )
                                   );
    if (!NT_SUCCESS( Status )) {
        MessageBox( hwndMain, "Value Error", "Kernel Mode Flags", MB_OK );
        ExitProcess( 0 );
        }

    LastSetFlags = GFlags;
    return TRUE;
}

DWORD
GetImageFileNameFlags(
    PCHAR ImageFileName
    )
{
    CHAR Buffer[ MAX_PATH ];
    CHAR RegKey[ MAX_PATH ];
    DWORD Length = MAX_PATH;
    DWORD GFlags;
    HKEY hKey;

    GFlags = 0;
    if (strlen( ImageFileName ) != 0) {
        sprintf( RegKey,
                 "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
                 ImageFileName
               );

        if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, RegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {
            if (RegQueryValueEx( hKey, "GlobalFlag", NULL, NULL, (PBYTE)Buffer, &Length ) == ERROR_SUCCESS ) {
                RtlCharToInteger( Buffer, 0, &GFlags );
                }

            RegCloseKey( hKey );
            }

        }

    return GFlags;
}

BOOL
GetImageFileNameDebugger(
    PCHAR ImageFileName,
    PCHAR Debugger
    )
{
    CHAR RegKey[ MAX_PATH ];
    DWORD Length = MAX_PATH;
    DWORD GFlags;
    HKEY hKey;
    BOOL Success = FALSE;

    GFlags = 0;
    if (strlen( ImageFileName ) != 0) {
        sprintf( RegKey,
                 "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
                 ImageFileName
               );

        if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, RegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {

            if (RegQueryValueEx( hKey, "Debugger", NULL, NULL, (PBYTE)Debugger, &Length ) == ERROR_SUCCESS ) {
                Success = TRUE ;
                }

            RegCloseKey( hKey );
            }

        }

    return Success ;
}


BOOLEAN
SetImageFileNameFlags(
    PCHAR ImageFileName,
    DWORD GFlags
    )
{
    CHAR Buffer[ MAX_PATH ];
    CHAR RegKey[ MAX_PATH ];
    HKEY hKey;
    DWORD Result;
    DWORD Length;
    DWORD Disposition;

    if (strlen( ImageFileName ) != 0) {

        sprintf( RegKey,
            "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
            ImageFileName
            );

        Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
            RegKey,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &Disposition
            );

        if (Result == ERROR_SUCCESS) {
            if (GFlags == (DWORD)-1) {
                Result = RegDeleteValue( hKey,
                    "GlobalFlag"
                    );
                DelImageNameFromUSTString(ImageFileName);
            }
            else {
                Length = sprintf( Buffer, "0x%08x", GFlags ) + 1;
                Result = RegSetValueEx( hKey,
                    "GlobalFlag",
                    0,
                    REG_SZ,
                    (PBYTE)Buffer,
                    Length
                    );

                if (GFlags&FLG_USER_STACK_TRACE_DB)
                    AddImageNameToUSTString(ImageFileName);
                else
                    DelImageNameFromUSTString(ImageFileName);

                //
                // If we enable page heap for a single application
                // then we will avoid default behavior which is
                // page heap light (only normal allocations) and
                // we will enable the page heap full power.
                // Note that we do not do this for system wide
                // settings because this will make the machine
                // unbootable.
                //

                if ((GFlags & FLG_HEAP_PAGE_ALLOCS)) {

                    Length = sprintf( Buffer, "0x%08x", 0x03 ) + 1;

                    Result = RegSetValueEx(
                        hKey,
                        "PageHeapFlags",
                        0,
                        REG_SZ,
                        (PBYTE)Buffer,
                        Length
                        );
                }
            }

            RegCloseKey( hKey );
        }

        if (Result != ERROR_SUCCESS) {
            MessageBox( hwndMain,
                (GFlags == (DWORD)-1) ?
                "Failed to delete registry value" :
            "Failed to set registry value",
                ImageFileName,
                MB_OK
                );
            return FALSE;
        }

        LastSetFlags = GFlags;
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
SetImageFileNameDebugger(
    PCHAR ImageFileName,
    PCHAR Debugger
    )
{
    CHAR RegKey[ MAX_PATH ];
    HKEY hKey;
    DWORD Result;
    DWORD Disposition;

    if (strlen( ImageFileName ) != 0) {

        sprintf( RegKey,
                 "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
                 ImageFileName
               );

        Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                 RegKey,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_ALL_ACCESS,
                                 NULL,
                                 &hKey,
                                 &Disposition
                               );

        if (Result == ERROR_SUCCESS) {
            if ( *Debugger  )
            {
                Result = RegSetValueEx( hKey,
                                        "Debugger",
                                        0,
                                        REG_SZ,
                                        (PBYTE)Debugger,
                                        (ULONG)(strlen( Debugger ) + 1));

            }
            else
            {
                Result = RegDeleteValue( hKey, "Debugger" );
            }

            RegCloseKey( hKey );
            }

        if (Result != ERROR_SUCCESS) {
            MessageBox( hwndMain,
                        ( *Debugger ) ?
                            "Failed to delete registry value" :
                            "Failed to set registry value",
                        ImageFileName,
                        MB_OK
                      );
            return FALSE;
            }

        return TRUE;
        }

    return FALSE;
}


BOOLEAN fRegistrySettings;
BOOLEAN fKernelSettings;
BOOLEAN fImageFileSettings;
BOOLEAN fDisplaySettings;
BOOLEAN fLaunchCommand;
BOOLEAN fFlushImageSettings;
PUCHAR TargetImageFileName;
DWORD GlobalFlagMask;
DWORD GlobalFlagSetting;
DWORD OldGlobalFlags;
DWORD NewGlobalFlags;
DWORD NewGlobalFlagsValidMask;
DWORD NewGlobalFlagsIgnored;

void
DisplayFlags(
    PCHAR Msg,
    DWORD Flags,
    DWORD FlagsIgnored
    )
{
    int i;

    if (Flags == 0xFFFFFFFF) {
        printf( "No %s\n", Msg );
        return;
    }

    printf( "Current %s are: %08x\n", Msg, Flags );
    for (i=0; i<32; i++) {
        if (GlobalFlagInfo[i].Abbreviation != NULL &&
            (Flags & GlobalFlagInfo[i].Flag)
            ) {

            if (_stricmp(GlobalFlagInfo[i].Abbreviation, "hpa") == 0) {

                printf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, "Enable page heap");
            }
            else {

                printf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, GlobalFlagInfo[i].Description );
            }
        }
    }

    if (FlagsIgnored) {
        printf( "Following settings were ignored: %08x\n", FlagsIgnored );
        for (i=0; i<32; i++) {
            if (GlobalFlagInfo[i].Abbreviation != NULL &&
                (FlagsIgnored & GlobalFlagInfo[i].Flag)
                ) {

                if (_stricmp(GlobalFlagInfo[i].Abbreviation, "hpa") == 0) {

                    printf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, "Enable page heap");
                }
                else {

                    printf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, GlobalFlagInfo[i].Description );
                }
            }
        }
    }
}


BOOL
IsCmdlineOption (
    PCHAR Option,
    PCHAR Name,
    PCHAR NameEx
    )
{
    if (_stricmp (Option, Name) == 0 || _stricmp (Option, NameEx) == 0) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

int
__cdecl
main(
    int argc,
    char **argv
    )
{
    MSG msg;
    CHAR c;
    PCHAR s;
    BOOLEAN fUsage, fExpectingFlags;
    ULONG i;
    CHAR Settings[ 2*MAX_PATH ];

    OSVERSIONINFO VersionInfo;
    VersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &VersionInfo );

    //
    // if the machine is running XP SP1+ or .NET server, the
    // pool tagging will always be on. 
    //
    if ( VersionInfo.dwMajorVersion >= 5 &&
            VersionInfo.dwMinorVersion >= 1 ){

        OSVERSIONINFOEX VersionInfoEx;
        VersionInfoEx.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );

        GetVersionEx( (LPOSVERSIONINFO) &VersionInfoEx );

        if ( VersionInfoEx.wProductType != VER_NT_WORKSTATION ){
            PoolTaggingAlwaysOn = TRUE;
        }         
    }
    	
#if defined(_X86_)
    if ( VersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT ) {
        MessageBox( NULL,
            "Global flags only runs on Windows NT and Windows 2000.  The glfags command was ignored.",
            "Global Flags Error",
            0 );
        exit(0);
    }
    else {
        HMODULE hDll;
        hDll = GetModuleHandle("ntdll");
        if (hDll != NULL) {
            pRtlIntegerToChar = ( PRTLINTEGERTOCHAR )
            GetProcAddress(
                hDll,
                "RtlIntegerToChar"
                );
            pNtQueryInformationProcess = ( PNTQUERYINFORMATIONPROCESS )
            GetProcAddress(
                hDll,
                "NtQueryInformationProcess"
                );
            pRtlCharToInteger = ( PRTLCHARTOINTEGER )
            GetProcAddress(
                hDll,
                "RtlCharToInteger"
                );
            pNtSetSystemInformation = ( PNTSETSYSTEMINFORMATION )
            GetProcAddress(
                hDll,
                "NtSetSystemInformation"
                );
            pNtQuerySystemInformation = ( PNTQUERYSYSTEMINFORMATION )
            GetProcAddress(
                hDll,
                "NtQuerySystemInformation"
                );
        }
    }
#endif

    //
    // Check if we need to redirect the whole command line to the page heap
    // command line parser.
    //

    if (argc >= 2 && IsCmdlineOption (argv[1], "/p", "-p")) {

        PageHeapMain (argc - 1, argv + 1);
        exit(0);
    }
                                                                
    //
    // Check forst for `-i APP -tracedb SIZE' option
    //

    if (argc == 5 && 
        IsCmdlineOption (argv[3], "/tracedb", "-tracedb") &&
        IsCmdlineOption (argv[1], "/i", "-i")) {
        
        ULONG RealSize;

        if (GflagsSetTraceDatabaseSize (argv[2], atoi (argv[4]), &RealSize) == FALSE) {
            
            printf("Failed to set the trace database size for `%s' \n", argv[2]);
            printf("The user mode stack trace database flag (+ust) "
                   "must be enabled before setting /tracedb .\n");
            exit(5);
        }
        else {

            if (RealSize > 0) {
                printf("Trace database size for `%s' set to %u Mb.\n", argv[2], RealSize);
            }
            else {
                printf("Will use default size for the trace database. \n");
            }
            exit(0);
        }
    }

    //
    // Continue ...
    //

    hwndMain = NULL;
    fUsage = FALSE;
    fExpectingFlags = FALSE;
    GlobalFlagMask = 0xFFFFFFFF;
    GlobalFlagSetting = 0;
    while (--argc) {
        s = *++argv;
        if (!fExpectingFlags && (*s == '-' || *s == '/')) {
            while (*++s) {
                c = (char)tolower(*s);
                switch (c) {
                    case 'r':
                    case 'k':
                    case 'i':
                        if (fRegistrySettings || fKernelSettings || fImageFileSettings) {
                            fprintf( stderr, "GFLAG: may only specify one of -r, -k or -i\n" );
                            fUsage = TRUE;
                        }
                        else {
                            fExpectingFlags = TRUE;
                            fDisplaySettings = TRUE;
                            if (c == 'r') {
                                fRegistrySettings = TRUE;
                                OldGlobalFlags = GetSystemRegistryFlags();
                                NewGlobalFlagsValidMask = GFLGS_VALID_SYSTEM_REGISTRY_FLAGS;
                                strcpy( Settings, "Boot Registry Settings" );
                            }
                            else
                                if (c == 'k') {
                                fKernelSettings = TRUE;
                                NewGlobalFlagsValidMask = GFLGS_VALID_KERNEL_MODE_FLAGS;
                                OldGlobalFlags = GetKernelModeFlags();
                                strcpy( Settings, "Running Kernel Settings" );
                            }
                            else {
                                fImageFileSettings = TRUE;
                                NewGlobalFlagsValidMask = GFLGS_VALID_IMAGE_FILE_NAME_FLAGS;
                                if (!--argc) {
                                    fprintf( stderr, "GFLAGS: ImageFileName missing after -i switch\n" );
                                    fUsage = TRUE;
                                    exit( 0 ); // 179741 - JHH
                                }
                                else {
                                    TargetImageFileName = (PUCHAR)(*++argv);
                                    OldGlobalFlags = GetImageFileNameFlags( (PCHAR)TargetImageFileName );
                                    sprintf( Settings, "Registry Settings for %s executable", TargetImageFileName );
                                }
                            }
                        }
                        break;

                    case 'l':
                        fLaunchCommand = TRUE;
                        fExpectingFlags = TRUE;
                        break;

                    default:
                        fUsage = TRUE;
                        break;
                }
            }
        }
        else {
            if (fExpectingFlags) {

                fDisplaySettings = FALSE;

                if (*s == '+' || *s == '-') {

                    if (strlen(s+1) == 3) {

                        for (i = 0; i < 32; i += 1) {

                            if ((NewGlobalFlagsValidMask & GlobalFlagInfo[i].Flag) &&
                                (GlobalFlagInfo[i].Abbreviation != NULL) &&
                                _stricmp( GlobalFlagInfo[i].Abbreviation, s+1 ) == NULL) {

                                if (fKernelSettings) {

                                    if (_stricmp(GlobalFlagInfo[i].Abbreviation, "ptg") == NULL) {
                                        fprintf (stderr, 
                                                 "Ignoring `ptg' flag. It can be used only with registry "
                                                 "settings (`-r') because it requires a reboot.\n");
                                        continue;
                                    }

                                    if (_stricmp(GlobalFlagInfo[i].Abbreviation, "kst") == NULL) {
                                        fprintf (stderr, 
                                                 "Ignoring `kst' flag. It can be used only with registry "
                                                 "settings (`-r') because it requires a reboot.\n");
                                        continue;
                                    }
                                }

                                if (*s == '-') {
                                    GlobalFlagMask &= ~GlobalFlagInfo[i].Flag;
                                }
                                else {
                                    GlobalFlagSetting |= GlobalFlagInfo[i].Flag;
                                }

                                s += 4;
                                break;
                            }
                        }
                    }

                    if (*s != '\0') {
                        if (*s++ == '-') {
                            GlobalFlagMask &= ~strtoul( s, &s, 16 );
                        }
                        else {
                            GlobalFlagSetting |= strtoul( s, &s, 16 );
                        }
                    }
                }
                else {
                    fExpectingFlags = FALSE;
                    GlobalFlagSetting = strtoul( s, &s, 16 );
                }

                if (fLaunchCommand) {
                    exit( 0 );
                }

                if (fImageFileSettings && OldGlobalFlags == 0xFFFFFFFF) {
                    OldGlobalFlags = 0;
                }
            }
            else {
                fprintf( stderr, "GFLAGS: Unexpected argument - '%s'\n", s );
                fUsage = TRUE;
            }
        }
    }

    if (fUsage) {
        
        fputs(GflagsHelpText,
              stderr);

        for (i=0; i<32; i++) {

            if (GlobalFlagInfo[i].Abbreviation != NULL) {

                if (_stricmp(GlobalFlagInfo[i].Abbreviation, "hpa") == 0) {

                    fprintf( stderr, "    %s - %s\n",
                        GlobalFlagInfo[i].Abbreviation,
                        "Enable page heap");
                } 
                else {

                    fprintf( stderr, "    %s - %s\n",
                        GlobalFlagInfo[i].Abbreviation,
                        GlobalFlagInfo[i].Description);
                }
            }
        }

        fprintf( stderr, "\nAll images with ust enabled can be accessed in the\n" );
        fprintf( stderr, "USTEnabled key under 'Image File Options'.\n" );
        exit( 1 );
    }

    if ( PoolTaggingAlwaysOn && !fImageFileSettings ){
        for (i = 0; i < 32; i += 1) {
            if ( (GlobalFlagInfo[i].Abbreviation != NULL ) &&
                (_stricmp(GlobalFlagInfo[i].Abbreviation, "ptg" ) == NULL ) ){
                   
                    PoolTagEnabledFlag = GlobalFlagInfo[i].Flag;
                    break;
            }
        }

        if ( (~GlobalFlagMask & PoolTagEnabledFlag) ||
            (GlobalFlagSetting & PoolTagEnabledFlag ) ) {

            fprintf( stderr, 
                "\nIgnoring `ptg' flag. Pool Tagging is always enabled on this operating system.\n");

            exit(1);    
        
        }
    }
    	
    NewGlobalFlags = (OldGlobalFlags & GlobalFlagMask) | GlobalFlagSetting;
    if (!fImageFileSettings || NewGlobalFlags != 0xFFFFFFFF) {
        NewGlobalFlagsIgnored = ~NewGlobalFlagsValidMask & NewGlobalFlags;
        NewGlobalFlags &= NewGlobalFlagsValidMask;
    }

    if (fDisplaySettings) {
        DisplayFlags( Settings, NewGlobalFlags, NewGlobalFlagsIgnored );
        exit( 0 );
    }

    if (fRegistrySettings) {
        SetSystemRegistryFlags( NewGlobalFlags,
            0,
            SPECIAL_POOL_OVERRUNS_CHECK_FORWARD
            );
        DisplayFlags( Settings, NewGlobalFlags, NewGlobalFlagsIgnored );
        exit( 0 );
    }

    else
        if (fKernelSettings) {
        SetKernelModeFlags( NewGlobalFlags );
        DisplayFlags( Settings, NewGlobalFlags, NewGlobalFlagsIgnored );
        exit( 0 );
    }
    else
        if (fImageFileSettings) {
        SetImageFileNameFlags( (PCHAR)TargetImageFileName, NewGlobalFlags );
        DisplayFlags( Settings, NewGlobalFlags, NewGlobalFlagsIgnored );
        exit( 0 );
    }

    CreateDialog( NULL,
        (LPSTR)DID_GFLAGS,
        NULL,
        MainWndProc
        );
    if (!hwndMain) {
        MessageBox( hwndMain, "Main Error", "Cant create dialog", MB_OK );
        ExitProcess( 0 );
    }

    while (GetMessage( &msg, 0, 0, 0 )) {
        if (!IsDialogMessage( hwndMain, &msg )) {
            DispatchMessage( &msg );
        }
    }

    return 0;
}


VOID
SetCheckBoxesFromFlags(
    DWORD GFlags,
    DWORD ValidFlags
    )
{
    int iBit;

    GFlags &= ValidFlags;
    LastSetFlags = GFlags;
    for (iBit=0; iBit < 32; iBit++) {
        CheckDlgButton( hwndMain,
                        ID_FLAG_1 + iBit,
                        (GFlags & (1 << iBit)) ? 1 : 0
                      );

        ShowWindow( GetDlgItem( hwndMain, ID_FLAG_1 + iBit ),
                    (ValidFlags & (1 << iBit)) ? SW_SHOWNORMAL : SW_HIDE
                  );
        }
}

DWORD
GetFlagsFromCheckBoxes( VOID )
{
    DWORD GFlags;
    int iBit;

    GFlags = 0;
    for (iBit=0; iBit < 32; iBit++) {
        if (IsDlgButtonChecked( hwndMain, ID_FLAG_1 + iBit )) {
            GFlags |= (1 << iBit);
            }
        }

    return GFlags;
}


VOID
DoLaunch(
    PCHAR CommandLine,
    DWORD GFlags
    )
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION BasicInformation;
    BOOLEAN ReadImageFileExecOptions;

    memset( &StartupInfo, 0, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );
    if (CreateProcess( NULL,
                       CommandLine,
                       NULL,
                       NULL,
                       FALSE,
                       CREATE_SUSPENDED,
                       NULL,
                       NULL,
                       &StartupInfo,
                       &ProcessInformation
                     )
       ) {
        Status = NtQueryInformationProcess( ProcessInformation.hProcess,
                                            ProcessBasicInformation,
                                            &BasicInformation,
                                            sizeof( BasicInformation ),
                                            NULL
                                          );
        if (NT_SUCCESS( Status )) {
            ReadImageFileExecOptions = TRUE;
            if (!WriteProcessMemory( ProcessInformation.hProcess,
                                     &BasicInformation.PebBaseAddress->ReadImageFileExecOptions,
                                     &ReadImageFileExecOptions,
                                     sizeof( ReadImageFileExecOptions ),
                                     NULL
                                   ) ||
                !WriteProcessMemory( ProcessInformation.hProcess,
                                     &BasicInformation.PebBaseAddress->NtGlobalFlag,
                                     &GFlags,
                                     sizeof( GFlags ),
                                     NULL
                                   )
               ) {
                Status = STATUS_UNSUCCESSFUL;
                }
            }


        if (!NT_SUCCESS( Status )) {
            MessageBox( hwndMain,
                        "Launch Command Line",
                        "Unable to pass flags to process - terminating",
                        MB_OK
                      );
            TerminateProcess( ProcessInformation.hProcess, 1 );
            }

        ResumeThread( ProcessInformation.hThread );
        CloseHandle( ProcessInformation.hThread );
        MsgWaitForMultipleObjects( 1,
                                   &ProcessInformation.hProcess,
                                   FALSE,
                                   NMPWAIT_WAIT_FOREVER,
                                   QS_ALLINPUT
                                 );
        CloseHandle( ProcessInformation.hProcess );
        }
    else {
        MessageBox( hwndMain, "Launch Command Line", "Unable to create process", MB_OK );
        }

    return;
}


DWORD LastRadioButtonId;
DWORD SpecialPoolModeId;
DWORD SpecialPoolOverrunsId;

BOOLEAN
CheckSpecialPoolTagItem(
    HWND hwnd,
    BOOLEAN ForApply
    )
{
    DWORD NumChars;
    DWORD i;
    BOOLEAN IsIllegal = FALSE;

    NumChars = GetDlgItemText( hwnd, ID_SPECIAL_POOL_TAG, SpecialPoolRenderBuffer, sizeof( SpecialPoolRenderBuffer ));

    if (NumChars != 0) {

        if (SpecialPoolModeId == ID_SPECIAL_POOL_IS_NUMBER) {

            //
            //  Check for illegal characters.
            //

            if (NumChars > 8) {

                IsIllegal = TRUE;

            } else {

                for (i = 0; i < NumChars; i++) {

                    if (!((SpecialPoolRenderBuffer[i] >= '0' &&
                           SpecialPoolRenderBuffer[i] <= '9') ||

                          (SpecialPoolRenderBuffer[i] >= 'a' &&
                           SpecialPoolRenderBuffer[i] <= 'f') ||

                          (SpecialPoolRenderBuffer[i] >= 'A' &&
                           SpecialPoolRenderBuffer[i] <= 'F'))) {

                        IsIllegal = TRUE;
                        break;
                    }
                }
            }

        } else {

            //
            //  Check for too many characters.
            //

            if (NumChars > sizeof(DWORD)) {

                IsIllegal = TRUE;
            }

            //
            //  We check a few more things when the user is really writing back.
            //

            if (!IsIllegal && ForApply) {

                //
                //  If this is not four characters and does not end in a '*',
                //  it is usually the case that the user really wanted a space
                //  at the end of the tag 'Gh1 ', not 'Gh1'.  Make sure they
                //  get a little feedback.
                //

                if (NumChars != sizeof(DWORD)  && SpecialPoolRenderBuffer[NumChars - 1] != '*') {

                    MessageBox( hwnd,
                                "The specified tag is less than 4 characters, but most\n"
                                "are really padded out with spaces.  Please check and\n"
                                "add spaces if neccesary.",
                                "Possibly ambiguous special pool tag",
                                MB_OK );

                }
            }
        }
    }

    if (IsIllegal) {

        MessageBox( hwnd, (SpecialPoolModeId == ID_SPECIAL_POOL_IS_NUMBER ? "Must be a hexadecimal DWORD" :
                                                                            "Must be at most 4 characters"),
                    "Illegal characters in special pool tag",
                    MB_OK );
    }

    return !IsIllegal;
}

DWORD
GetSpecialPoolTagItem(
    HWND hwnd
    )
{
    DWORD NumChars;
    DWORD Tag = 0;

    UNREFERENCED_PARAMETER(hwnd);

    //
    //  We assume that the field is has been retrieved and checked.
    //

    NumChars = (ULONG)strlen( SpecialPoolRenderBuffer );

    if (NumChars != 0) {

        if (SpecialPoolModeId == ID_SPECIAL_POOL_IS_NUMBER) {

            RtlCharToInteger( SpecialPoolRenderBuffer, 16, &Tag );

        } else {

            //
            //  Just drop the bytes into the DWORD - endianess is correct as is.
            //

            RtlCopyMemory( &Tag,
                           SpecialPoolRenderBuffer,
                           NumChars );
        }
    }

    return Tag;
}

DWORD
GetSpecialPoolOverrunsItem(
    HWND hwnd
    )
{
    UNREFERENCED_PARAMETER(hwnd);
    
    switch (SpecialPoolOverrunsId) {

        case ID_SPECIAL_POOL_VERIFY_END: return SPECIAL_POOL_OVERRUNS_CHECK_FORWARD;
        case ID_SPECIAL_POOL_VERIFY_START: return SPECIAL_POOL_OVERRUNS_CHECK_BACKWARD;

        default: return SPECIAL_POOL_OVERRUNS_CHECK_FORWARD;
    }
}

VOID
ReRenderSpecialPoolTagItem(
    HWND hwnd
    )
{
    DWORD NumChars;
    DWORD Tag = 0;

    //
    //  We assume that the field is has been retrieved and checked.
    //

    NumChars = (ULONG)strlen( SpecialPoolRenderBuffer );

    //
    //  Assume that the dialog contents are of the previous mode. Switch it.
    //

    if (NumChars != 0) {

        if (SpecialPoolModeId == ID_SPECIAL_POOL_IS_NUMBER) {

            RtlCopyMemory( &Tag,
                           SpecialPoolRenderBuffer,
                           NumChars );
            RtlIntegerToChar( Tag, 16, sizeof( SpecialPoolRenderBuffer ), SpecialPoolRenderBuffer);

        } else {

            RtlCharToInteger( SpecialPoolRenderBuffer, 16, &Tag );
            RtlCopyMemory( SpecialPoolRenderBuffer,
                           &Tag,
                           sizeof( Tag ));
            SpecialPoolRenderBuffer[sizeof( Tag )] = '\0';
        }
    }

    SetDlgItemText( hwnd, ID_SPECIAL_POOL_TAG, SpecialPoolRenderBuffer );
}

BOOLEAN
CheckForUnsaved(
    HWND hwnd
    )
{
    //
    //  Appropriate to the mode we are leaving, see if there were unsaved changes.
    //  Return TRUE if there are unsaved changes.
    //

    if (GetFlagsFromCheckBoxes() != LastSetFlags ||
           (fFlushImageSettings && (LastRadioButtonId == ID_IMAGE_FILE_OPTIONS)) ||
        (LastRadioButtonId == ID_SYSTEM_REGISTRY &&
         (!CheckSpecialPoolTagItem( hwnd, FALSE ) ||
          (GetSpecialPoolTagItem( hwnd ) != LastSetSpecialPoolTag) ||
          (GetSpecialPoolOverrunsItem( hwnd ) != LastSetSpecialPoolOverruns)))) {


        if (MessageBox( hwndMain,
                        "You didn't click 'apply' - did you want to discard current changes??",
                        "Warning",
                        MB_YESNO
                        ) == IDNO
            ) {

            return TRUE;
        }
    }

    return FALSE;
}


INT_PTR
APIENTRY
MainWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD NewFlags;
    CHAR ImageFileName[ MAX_PATH ];
    CHAR CommandLine[ MAX_PATH ];
    BOOL bCancelDiscard;
    int i;

    UNREFERENCED_PARAMETER(lParam);

    bCancelDiscard = FALSE;

    switch (message) {

        case WM_INITDIALOG:

            hwndMain = hwnd;
            LastRadioButtonId = ID_SYSTEM_REGISTRY;
            CheckRadioButton( hwnd,
                ID_SYSTEM_REGISTRY,
                ID_IMAGE_FILE_OPTIONS,
                LastRadioButtonId
                );

            EnableSetOfControls( hwnd, SpecialPool, TRUE );
            EnableSetOfControls( hwnd, Debugger, FALSE );

            SetCheckBoxesFromFlags( GetSystemRegistryFlags(), GFLGS_VALID_SYSTEM_REGISTRY_FLAGS );

            //
            //  Make a not so wild guess about what kind of tag it is.
            //

            if (LastSetSpecialPoolTag && LastSetSpecialPoolTag < 0x2000) {

                SpecialPoolModeId = ID_SPECIAL_POOL_IS_NUMBER;
                RtlIntegerToChar( LastSetSpecialPoolTag,
                    16,
                    sizeof( SpecialPoolRenderBuffer ),
                    SpecialPoolRenderBuffer );
            }
            else {

                SpecialPoolModeId = ID_SPECIAL_POOL_IS_TEXT;
                RtlCopyMemory( SpecialPoolRenderBuffer,
                    &LastSetSpecialPoolTag,
                    sizeof( LastSetSpecialPoolTag ));
                SpecialPoolRenderBuffer[sizeof(LastSetSpecialPoolTag)] = '\0';
            }

            CheckRadioButton( hwnd,
                ID_SPECIAL_POOL_IS_TEXT,
                ID_SPECIAL_POOL_IS_NUMBER,
                SpecialPoolModeId
                );
            SetDlgItemText( hwnd, ID_SPECIAL_POOL_TAG, SpecialPoolRenderBuffer );

            //
            // Initial state for the special pool overrun radio buttons.
            //

            switch (LastSetSpecialPoolOverruns) {

                case SPECIAL_POOL_OVERRUNS_CHECK_FORWARD:
                    SpecialPoolOverrunsId = ID_SPECIAL_POOL_VERIFY_END;
                    break;

                case SPECIAL_POOL_OVERRUNS_CHECK_BACKWARD:
                    SpecialPoolOverrunsId = ID_SPECIAL_POOL_VERIFY_START;
                    break;

                default:
                    SpecialPoolOverrunsId = ID_SPECIAL_POOL_VERIFY_END;
                    break;
            }

            CheckRadioButton( hwnd,
                ID_SPECIAL_POOL_VERIFY_START,
                ID_SPECIAL_POOL_VERIFY_END,
                SpecialPoolOverrunsId
                );

            if ( PoolTaggingAlwaysOn )
            {
                    //
                    //   on windows XP and above, POOL tagging will always be on.
                    //
                    CheckDlgButton(hwnd, ID_FLAG_11, BST_CHECKED);
                    EnableWindow(GetDlgItem(hwnd, ID_FLAG_11), FALSE);			
            }

            return(TRUE);

        case WM_COMMAND:

            switch ( LOWORD(wParam) ) {

                case ID_LAUNCH:

                    GetDlgItemText( hwnd, ID_COMMAND_LINE, CommandLine, sizeof( CommandLine ) );
                    if (strlen( ImageFileName ) == 0) {
                        MessageBox( hwndMain, "Launch Command Line", "Must fill in command line first", MB_OK );
                        SetFocus( GetDlgItem( hwnd, ID_COMMAND_LINE ) );
                        break;
                    }

                    // fall through

                case ID_APPLY:

                    if (IsDlgButtonChecked( hwnd, ID_SYSTEM_REGISTRY )) {

                        //
                        // System wide settings
                        //

                        if (CheckSpecialPoolTagItem( hwnd, TRUE )) {

                            NewFlags = GetFlagsFromCheckBoxes();

                            SetSystemRegistryFlags(
                                NewFlags,
                                GetSpecialPoolTagItem( hwnd ),
                                GetSpecialPoolOverrunsItem (hwnd));
                        }
                    }
                    else if (IsDlgButtonChecked( hwnd, ID_KERNEL_MODE )) {

                        //
                        // Kernel mode settings
                        //
                        // N.B. This will set flags on the fly. It does not touch
                        // the registry and does not require a reboot.
                        //

                        NewFlags = GetFlagsFromCheckBoxes();

                        SetKernelModeFlags( NewFlags );
                    }
                    else if (IsDlgButtonChecked( hwnd, ID_IMAGE_FILE_OPTIONS )) {

                        //
                        // Application specific settings
                        //

                        GetDlgItemText( hwnd, ID_IMAGE_FILE_NAME, ImageFileName, sizeof( ImageFileName ) );
                        if (strlen( ImageFileName ) == 0) {
                            MessageBox( hwnd, "Missing Image File Name", "Must set image file name", MB_OK );
                            SetFocus( GetDlgItem( hwnd, ID_IMAGE_FILE_NAME ) );
                            break;
                        }

                        SetImageFileNameFlags( ImageFileName, GetFlagsFromCheckBoxes() );
                        if ( fFlushImageSettings ) {

                            GetDlgItemText( hwnd, ID_IMAGE_DEBUGGER_VALUE, LastDebuggerValue, MAX_PATH );

                            SetImageFileNameDebugger( ImageFileName, LastDebuggerValue );

                            fFlushImageSettings = FALSE ;

                        }
                    }

                    if (LOWORD(wParam) == ID_LAUNCH) {
                        DoLaunch( CommandLine,
                            GetFlagsFromCheckBoxes()
                            );
                    }
                    break;

                case IDOK:
                    if (CheckForUnsaved( hwnd )) {
                        break;
                    }

                    // fall through

                case IDCANCEL:
                    PostQuitMessage(0);
                    DestroyWindow( hwnd );
                    break;

                case ID_SPECIAL_POOL_IS_TEXT:
                case ID_SPECIAL_POOL_IS_NUMBER:

                    if (CheckSpecialPoolTagItem( hwnd, FALSE )) {

                        if (LOWORD(wParam) != SpecialPoolModeId) {

                            SpecialPoolModeId = LOWORD(wParam);
                            CheckRadioButton( hwnd,
                                ID_SPECIAL_POOL_IS_TEXT,
                                ID_SPECIAL_POOL_IS_NUMBER,
                                SpecialPoolModeId
                                );

                            ReRenderSpecialPoolTagItem( hwnd );
                        }
                    }
                    else {

                        //
                        //  Always treat this as a cancel.
                        //

                        bCancelDiscard = TRUE;
                    }

                    break;

                case ID_SPECIAL_POOL_VERIFY_START:
                case ID_SPECIAL_POOL_VERIFY_END:

                    if (LOWORD(wParam) != SpecialPoolOverrunsId) {

                        SpecialPoolOverrunsId = LOWORD(wParam);
                        CheckRadioButton( hwnd,
                            ID_SPECIAL_POOL_VERIFY_START,
                            ID_SPECIAL_POOL_VERIFY_END,
                            SpecialPoolOverrunsId
                            );
                    }

                    break;

                case ID_IMAGE_DEBUGGER_BUTTON:
                    if (IsDlgButtonChecked( hwnd, ID_IMAGE_DEBUGGER_BUTTON ) == BST_CHECKED ) {
                        EnableWindow( GetDlgItem( hwnd, ID_IMAGE_DEBUGGER_VALUE ), TRUE );

                        GetDlgItemText( hwnd, ID_IMAGE_FILE_NAME, ImageFileName, MAX_PATH );

                        for ( i = 0 ; i < sizeof( SystemProcesses ) / sizeof( PCHAR ) ; i++ ) {
                            if (_stricmp( ImageFileName, SystemProcesses[i] ) == 0 ) {
                                SetDlgItemText( hwnd, ID_IMAGE_DEBUGGER_VALUE, "ntsd -d -g -G" );
                                break;
                            }
                        }

                    }
                    else {
                        SetDlgItemText( hwnd, ID_IMAGE_DEBUGGER_VALUE, "" );
                        EnableWindow( GetDlgItem( hwnd, ID_IMAGE_DEBUGGER_VALUE ), FALSE );
                    }
                    fFlushImageSettings = TRUE ;
                    break;

                case ID_SYSTEM_REGISTRY:
                    if (CheckForUnsaved( hwnd )) {
                        bCancelDiscard = TRUE;
                        break;
                    }

                    LastRadioButtonId = ID_SYSTEM_REGISTRY;
                    SetCheckBoxesFromFlags( GetSystemRegistryFlags(), GFLGS_VALID_SYSTEM_REGISTRY_FLAGS );
                    EnableSetOfControls( hwnd, SpecialPool, TRUE );
                    EnableSetOfControls( hwnd, Debugger, FALSE );


                    break;

                case ID_KERNEL_MODE:
                    if (CheckForUnsaved( hwnd )) {
                        bCancelDiscard = TRUE;
                        break;
                    }

                    LastRadioButtonId = ID_KERNEL_MODE;
                    SetCheckBoxesFromFlags( GetKernelModeFlags(), GFLGS_VALID_KERNEL_MODE_FLAGS );
                    EnableSetOfControls( hwnd, SpecialPool, FALSE );
                    EnableSetOfControls( hwnd, Debugger, FALSE );

                    break;

                case ID_IMAGE_FILE_OPTIONS:
                    if (CheckForUnsaved( hwnd )) {
                        bCancelDiscard = TRUE;
                        break;
                    }

                    GetDlgItemText( hwnd, ID_IMAGE_FILE_NAME, ImageFileName, sizeof( ImageFileName ) );
                    if (strlen( ImageFileName ) == 0) {
                        MessageBox( hwndMain, "Image File Name Missing", "Must fill in image file name first", MB_OK );
                        CheckRadioButton( hwnd,
                            ID_SYSTEM_REGISTRY,
                            ID_IMAGE_FILE_OPTIONS,
                            LastRadioButtonId
                            );
                        SetCheckBoxesFromFlags( GetSystemRegistryFlags(), GFLGS_VALID_SYSTEM_REGISTRY_FLAGS );
                        SetFocus( GetDlgItem( hwnd, ID_IMAGE_FILE_NAME ) );
                        break;
                    }
                    else {
                        LastRadioButtonId = ID_IMAGE_FILE_OPTIONS;
                        SetCheckBoxesFromFlags( GetImageFileNameFlags( ImageFileName ),
                            GFLGS_VALID_IMAGE_FILE_NAME_FLAGS
                            );

                        if ( GetImageFileNameDebugger( ImageFileName, LastDebuggerValue ) ) {
                            SetDlgItemText( hwnd, ID_IMAGE_DEBUGGER_VALUE, LastDebuggerValue );
                            CheckDlgButton( hwnd, ID_IMAGE_DEBUGGER_BUTTON, 1 );

                        }

                        EnableSetOfControls( hwnd, SpecialPool, FALSE );
                        EnableSetOfControls( hwnd, Debugger, TRUE );

                    }
                    break;

                default:
                    break;
            }
            break;

        case WM_CLOSE:
            PostQuitMessage(0);
            DestroyWindow( hwnd );
            break;

    }

    if (bCancelDiscard) {

        //
        //  Recheck the right radio buttons 'cause the user didn't
        //  *really* mean it.
        //

        CheckRadioButton( hwnd,
            ID_SYSTEM_REGISTRY,
            ID_IMAGE_FILE_OPTIONS,
            LastRadioButtonId
            );
        CheckRadioButton( hwnd,
            ID_SPECIAL_POOL_IS_TEXT,
            ID_SPECIAL_POOL_IS_NUMBER,
            SpecialPoolModeId
            );

        CheckRadioButton( hwnd,
            ID_SPECIAL_POOL_VERIFY_START,
            ID_SPECIAL_POOL_VERIFY_END,
            SpecialPoolOverrunsId
            );

    }

    return 0;
}


BOOL
EnableDebugPrivilege( VOID )
{
    HANDLE Token = NULL;
    PTOKEN_PRIVILEGES NewPrivileges = NULL;
	ULONG cbNeeded = 0;
    BOOL fRc = FALSE;
	LUID LuidPrivilege = {0};
	DWORD dwError = ERROR_SUCCESS;

    //
    // Make sure we have access to adjust and to get the old token privileges
    //
	fRc = OpenProcessToken(GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &Token);

	if (!fRc) {

		dwError = GetLastError();
		goto Exit;
	}

    //
    // Initialize the privilege adjustment structure
    //
    fRc = LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &LuidPrivilege );

	if (!fRc) {

		dwError = GetLastError();
		goto Exit;
	}

	//
	// Allocate memory for NewPrivileges
	//
	cbNeeded = sizeof(TOKEN_PRIVILEGES) + 
		       (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES);

    NewPrivileges = (PTOKEN_PRIVILEGES)HeapAlloc(GetProcessHeap(), 0, cbNeeded);

    if (NewPrivileges == NULL) {

		dwError = ERROR_OUTOFMEMORY;
		fRc = FALSE;
		goto Exit;
	}

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //
    fRc = AdjustTokenPrivileges(Token,
		                        FALSE,
								NewPrivileges,
								0,
                                (PTOKEN_PRIVILEGES)NULL,
								(PDWORD)NULL);

    if (!fRc) {

		dwError = GetLastError();
		goto Exit;
	}

Exit:

	//
	// Cleanup handles, memory, etc. before exiting the function
	//
	if (NULL != Token) {

		CloseHandle(Token);
		Token = NULL;
	}

	if (NULL != NewPrivileges) {

		HeapFree(GetProcessHeap(), 0, NewPrivileges);
		NewPrivileges = NULL;
	}

	SetLastError(dwError);
    return fRc;
}

VOID
CenterDialog( HWND hWndDialog )
{
    RECT rectWindow;
    POINT pointCenter;
    POINT pointNewCornerChild;
    INT nChildWidth;
    INT nChildHeight;
    HWND hWndParent;

    hWndParent = GetParent( hWndDialog );

    //
    // parent window's rectangle
    //

    GetWindowRect( hWndParent, &rectWindow );

    //
    // the center, in screen coordinates
    //

    pointCenter.x = rectWindow.left + ( rectWindow.right - rectWindow.left ) / 2;
    pointCenter.y = rectWindow.top + ( rectWindow.bottom - rectWindow.top ) / 2;

    //
    // chils window's rectangle, in screen coordinates
    //

    GetWindowRect( hWndDialog, &rectWindow );

    nChildWidth = rectWindow.right - rectWindow.left ;
    nChildHeight = rectWindow.bottom - rectWindow.top;

    //
    // the new top-left corner of the child
    //

    pointNewCornerChild.x = pointCenter.x - nChildWidth / 2;
    pointNewCornerChild.y = pointCenter.y - nChildHeight / 2;

    //
    // move the child window
    //

    MoveWindow(
        hWndDialog,
        pointNewCornerChild.x,
        pointNewCornerChild.y,
        nChildWidth,
        nChildHeight,
        TRUE );
}


INT_PTR
APIENTRY
PagedHeapDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR nResult;

    UNREFERENCED_PARAMETER(lParam);

	nResult = FALSE;

    switch ( message ) {

        case WM_INITDIALOG:
			hwndPagedHeapDlg = hwnd;

            //
            // center this dialog
            //

            CenterDialog( hwndPagedHeapDlg );

			break;

        case WM_COMMAND:
            switch( LOWORD(wParam) ) {
                case IDYES:
                    EndDialog( hwndPagedHeapDlg, IDYES );
                    break;

                case IDNO:
                    EndDialog( hwndPagedHeapDlg, IDNO );
                    break;
            }
            break;

        case WM_CLOSE:
        case WM_DESTROY:
        case WM_ENDSESSION:
        case WM_QUIT:
            EndDialog(hwndPagedHeapDlg,IDNO);
            nResult = TRUE;
            break;

        default:
            break;
    }

    return nResult;
}

BOOL
OkToEnablePagedHeap( VOID )
{
    MEMORYSTATUS MemoryStatus;

    GlobalMemoryStatus( &MemoryStatus );

    if( MemoryStatus.dwTotalPhys < 512 * 1024 * 1024 ) {

        //
        // less than 512 Mb of RAM
        //

        return ( DialogBoxParam(
                    NULL,
                    (LPCTSTR)( MAKEINTRESOURCE(DID_PAGED_HEAP_WARNING) ),
                    hwndMain,
                    PagedHeapDlgProc,
                    0 ) == IDYES );
    }

    return TRUE;
}


BOOL
GflagsSetTraceDatabaseSize (
    PCHAR ApplicationName,
    ULONG SizeInMb,
    PULONG RealSize
    )
{
    HKEY ImageKey;
    CHAR ImageKeyName[ MAX_PATH ];
    LONG Result;
    DWORD TraceDatabaseSize;

    *RealSize = 0;

    if (ApplicationName == NULL) {
        return FALSE;
    }

    sprintf (ImageKeyName,
             "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
             ApplicationName);

    Result = RegOpenKeyEx (HKEY_LOCAL_MACHINE, 
                           ImageKeyName, 
                           0, 
                           KEY_QUERY_VALUE | KEY_SET_VALUE, 
                           &ImageKey);

    if (Result != ERROR_SUCCESS) {
        return FALSE;
    }

    if (SizeInMb == 0) {
        
        Result = RegDeleteValue (ImageKey,
                                 "StackTraceDatabaseSizeInMb");

        if (Result != ERROR_SUCCESS) {
            RegCloseKey (ImageKey);
            return FALSE;
        }
    }
    else {

        if (SizeInMb < 8) {
            
            TraceDatabaseSize = 8;
        } 
        else {

            TraceDatabaseSize = SizeInMb;
        }

        Result = RegSetValueEx (ImageKey,
                                "StackTraceDatabaseSizeInMb",
                                0,
                                REG_DWORD,
                                (PBYTE)(&TraceDatabaseSize),
                                sizeof TraceDatabaseSize);

        if (Result != ERROR_SUCCESS) {
            RegCloseKey (ImageKey);
            return FALSE;
        }

        *RealSize = TraceDatabaseSize;
    }

    RegCloseKey (ImageKey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\gdate.c ===
/*
 * Gutils - 
 *
 * - date conversion functions
 *
 * Geraint, 22 May, 28 Oct 91.
 */

#include "windows.h"
#include "gutils.h"

#include <string.h>

BOOL gdi_isleap(LONG year);

/*---static data--------------------------------------------*/

int monthdays[] = {
	31,
	28,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31
};

/*--public functions--------------------------------------*/

void APIENTRY
gdate_daytodmy(LONG days, int FAR* yrp, int FAR* monthp, int FAR* dayp)
{
	int years;
	int nleaps;
	int month;
	int mdays;

	/* get number of completed years and calc leap days */
	years = (int) (days / 365);
	days = days % 365;
	nleaps = (years / 4) - (years / 100) + (years / 400);
	while (nleaps > days) {
		days += 365;
		years--;
		nleaps = (years / 4) - (years / 100) + (years / 400);
	}
	days -= nleaps;

	/* add one year for current (non-complete) year */
	years++;


	/* current month */
	for (month = 0; month < 12; month++) {
		mdays = monthdays[month];
		if (gdi_isleap(years) && (month == 1)) {
			mdays++;
		}
		if (days == mdays) {
			days = 0;
			month++;
			break;
		} else if (days < mdays) {
			break;
		} else {
			days -= mdays;
		}
	}
	/* conv month from 0-11 to 1-12 */
	if (monthp != NULL) {
		*monthp = month+1;
	}
	if (dayp != NULL) {
		*dayp = (int) days + 1;
	}
	if (yrp != NULL) {
		*yrp = years;
	}
}


LONG APIENTRY
gdate_dmytoday(int yr, int month, int day)
{
	int nleaps;
	int i;
	long ndays;

	/* exclude the current year */
	yr--;
	nleaps = (yr / 4) - (yr / 100) + (yr / 400);

	/* in any given year, day 0 is jan1 */
	month--;
	day--;
	ndays = 0;
	for (i = 0; i < month ; i++) {
		ndays += monthdays[i];
		if (gdi_isleap(yr+1) && (i == 1)) {
			ndays++;
		}
	}
	ndays = ndays + day + nleaps + (yr * 365L);
	return(ndays);
}

int APIENTRY
gdate_monthdays(int month, int year)
{
	int ndays;

	ndays = monthdays[month - 1];
	if (gdi_isleap(year) && (month == 2)) {
		ndays++;
	}
	return(ndays);
}

int APIENTRY
gdate_weekday(long daynr)
{
	return((int) ((daynr + 1) % 7));
}

/* internal functions-----------------------------------------*/

BOOL
gdi_isleap(LONG year)
{
	if ( ((year % 4) == 0) &&
		(((year % 100) != 0) ||
		((year % 400) == 0))) {
			return TRUE;
	} else {
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\gutils.c ===
#include <windows.h>
#include "gutils.h"
#include "gutilsrc.h"

/* dll global data */
HANDLE hLibInst;
extern void gtab_init(void);
extern BOOL StatusInit(HANDLE);

#ifdef WIN32
BOOL WINAPI LibMain(HANDLE hInstance, DWORD dwReason, LPVOID reserved)
{
        if (dwReason == DLL_PROCESS_ATTACH) {
                hLibInst = hInstance;
                gtab_init();
                StatusInit(hLibInst);
        }
        return(TRUE);
}

#else

WORD wLibDataSeg;


BOOL FAR PASCAL
LibMain(HANDLE hInstance, WORD   wDataSeg, WORD   cbHeap, LPSTR  lpszCmdLine)
{
	hLibInst = hInstance;
	wLibDataSeg = wDataSeg;

	gtab_init();
	StatusInit(hLibInst);
	return(TRUE);

}
#endif

/* needed for win16 - but does no harm in NT */
int FAR PASCAL
WEP (int bSystemExit)
{
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\gutilsrc.h ===
#define IDC_LPAGENR   102

#define IDC_LFNAME    201
#define IDC_FNAME     202
#define IDC_PROMPT    203
#define IDC_LFILES    204
#define IDC_LSDIR     205
#define IDC_SDIR      206
#define IDC_LDIRS     207
#define IDC_FILES     208
#define IDC_DIRS      209
#define IDC_OPEN      210
#define IDC_CANCEL    211

#define IDD_LABEL     301
#define IDD_FILE      302

#define IDS_MEMORY_ALLOC_FAIL  401
#define IDS_OUT_OF_MEMORY      402
#define IDS_PAGE_STR           403
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\libentry.asm ===
PAGE	,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       LIBENTRY.ASM
;
;       Windows dynamic link library entry routine
;
;   This module generates a code segment called INIT_TEXT.
;   It initializes the local heap if one exists and then calls
;   the C routine LibMain() which should have the form:
;   BOOL FAR PASCAL LibMain(HANDLE hInstance,
;                           WORD   wDataSeg,
;                           WORD   cbHeap,
;                           LPSTR  lpszCmdLine);
;        
;   The result of the call to LibMain is returned to Windows.
;   The C routine should return TRUE if it completes initialization
;   successfully, FALSE if some error occurs.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        extrn LibMain:far         ; the C routine to be called
	extrn LocalInit:far       ; Windows heap init routine
        extrn __acrtused:abs      ; ensures that Win DLL startup code is linked

        public LibEntry           ; entry point for the DLL

INIT_TEXT segment byte public 'CODE'
        assume cs:INIT_TEXT

LibEntry proc far
        
	push	di		 ; handle of the module instance
        push    ds               ; library data segment
	push	cx		 ; heap size
	push	es		 ; command line segment
	push	si		 ; command line offset

	; if we have some heap then initialize it
	jcxz	callc		 ; jump if no heap specified

	; call the Windows function LocalInit() to set up the heap
	; LocalInit((LPSTR)start, WORD cbHeap);

	push	ds		 ; Heap segment
        xor     ax,ax
	push	ax		 ; Heap start offset in segment
	push	cx		 ; Heap end offset in segment
	call	LocalInit	 ; try to initialize it
	or	ax,ax		 ; did it do it ok ?
	jz	nocall		 ; quit if it failed

	; invoke the C routine to do any special initialization

callc:
	call	LibMain		 ; invoke the 'C' routine (result in AX)
        jmp short exit           ; LibMain is responsible for stack clean up

nocall:                          ; clean up passed params
        pop     si               ; if LocalInit fails. 
        pop     es               
        pop     cx               
        pop     ds
        pop     di
exit:
	ret			 ; return the result

LibEntry endp

INIT_TEXT       ends

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\gfile.c ===
/*
 * File Open/Create dialogs
 *
 */

/*
 * these dialog functions exist because they were written and
 * used before the commmon dialogs existed.
 *
 * they have now been reduced to just calls to the common file dialog
 * functions
 */



/*---includes-----------------------------------------------------------*/
#include "windows.h"
#include "commdlg.h"
#include "gutilsrc.h"
#include "gutils.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <stdio.h>

/*--functions----------------------------------------------------------*/

/*
 * gfile_open
 *     	dialog asking the user to select an existing file to open.
 *
 * parameters
 *
 *	prompt - message to user indicating purpose of file
 *		 (to be displayed somewhere in dialog box.
 *
 *	ext    - default file extension if user enters file without
 *		 extension.
 *
 *	spec   - default file spec (eg *.*)
 *
 *	pszFull - buffer where full filename (including path) is returned.
 *
 *	cchMax - size of pszFull buffer.
 *
 *	fn     - buffer where filename (just final element) is returned.
 *
 * returns - true if file selected and exists (tested with OF_EXIST).
 *	     FALSE if dialog cancelled. If user selects a file that we cannot
 *	     open, we complain and restart the dialog.
 *
 *	     if TRUE is returned, the file will have been successfully opened,
 *	     for reading and then closed again.
 */

BOOL 
FAR 
PASCAL
gfile_open(
    HWND hwnd, 
    LPSTR prompt, 
    LPSTR ext, 
    LPSTR spec, 
    LPSTR pszFull, 
    int cchMax, 
    LPSTR fn
    )
{
    OPENFILENAME ofn;
    char achFilters[MAX_PATH];
    char szTmp[MAX_PATH * 2] = {0};
    HANDLE fh;

    if (!pszFull)
    {
        pszFull = szTmp;
        cchMax = sizeof(szTmp) / sizeof(szTmp[0]);
    }

    if (cchMax < 1)
        return FALSE;

    /* build filter-pair buffer to contain one pair - the spec filter,
     * twice (one of the pair should be the filter, the second should be
     * the title of the filter - we don't have a title so we use the
     * filter both times.
     */
    _snprintf(achFilters, (sizeof(achFilters)/sizeof(achFilters[0])) - 1, "%s%c%s", spec, 0, spec);

    /*
     * initialise arguments to dialog proc
     */
    memset(&ofn, 0, sizeof(ofn));
    // GetOpenFileName ang GetSaveFileName unfortunately
    // validate the size of the structue.  So we need to lie to
    // the function if we were built for >=Win2000 and
    // running on an earlier OS
#if (_WIN32_WINNT >= 0x0500) 
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
#else
    ofn.lStructSize = sizeof(OPENFILENAME);
#endif
    ofn.hwndOwner = hwnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = achFilters;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;       // first filter pair in list
    pszFull[0] = '\0';
    ofn.lpstrFile = pszFull;        // we need to get the full path to open
    ofn.nMaxFile = cchMax;
    ofn.lpstrFileTitle = fn;        // return final elem of name here
    ofn.nMaxFileTitle = 13;     // assume just big enough for 8.3+null
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = prompt;        // dialog title is good place for prompt text
    ofn.Flags = OFN_FILEMUSTEXIST |
                OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = ext;

    /*
     * loop until the user cancels, or selects a file that we can open
     */
    do {
        if (!GetOpenFileName(&ofn)) {
            return(FALSE);
        }

        fh = CreateFile(pszFull, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

        if (fh == INVALID_HANDLE_VALUE) {
            if (MessageBox(NULL, "File Could Not Be Opened", "File Open",
                           MB_OKCANCEL|MB_ICONSTOP) == IDCANCEL) {
                return(FALSE);
            }
        }
    } while (fh == INVALID_HANDLE_VALUE);

    CloseHandle(fh);

    return(TRUE);
}





/*
 * gfile_new
 *     	dialog asking the user to name a file for writing to.
 *
 * parameters
 *
 *	prompt - message to user indicating purpose of file
 *		 (to be displayed somewhere in dialog box.
 *
 *	ext    - default file extension if user enters file without
 *		 extension.
 *
 *	spec   - default file spec (eg *.*)
 *
 *	pszFull - buffer where full filename (including path) is returned.
 *
 *	cchMax - size of pszFull buffer.
 *
 *	fn     - buffer where filename (just final element) is returned.
 *
 * returns - true if file selected and exists (tested with OF_EXIST).
 *	     FALSE if dialog cancelled. If user selects a file that we cannot
 *	     open, we complain and restart the dialog.
 *
 *	     if TRUE is returned, the file will have been successfully
 *	     created and opened for writing and then closed again.
 */

BOOL 
FAR 
PASCAL
gfile_new(
    LPSTR prompt, 
    LPSTR ext, 
    LPSTR spec, 
    LPSTR pszFull, 
    int cchMax, 
    LPSTR fn
    )
{
    OPENFILENAME ofn;
    char achFilters[MAX_PATH] = {0};
    char szTmp[MAX_PATH * 2];
    HANDLE fh;

    if (!pszFull)
    {
        pszFull = szTmp;
        cchMax = sizeof(szTmp) / sizeof(szTmp[0]);
    }

    if (cchMax < 1)
        return FALSE;

    /* build filter-pair buffer to contain one pair - the spec filter,
     * twice (one of the pair should be the filter, the second should be
     * the title of the filter - we don't have a title so we use the
     * filter both times. remember double null at end of list of strings.
     */
    _snprintf(achFilters, (sizeof(achFilters)/sizeof(achFilters[0])) - 1, "%s%c%s", spec, 0, spec);

    /*
     * initialise arguments to dialog proc
     */
    memset(&ofn, 0, sizeof(ofn));
    // GetOpenFileName ang GetSaveFileName unfortunately
    // validate the size of the structue.  So we need to lie to
    // the function if we were built for >=Win2000 and
    // running on an earlier OS
#if (_WIN32_WINNT >= 0x0500) 
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
#else
    ofn.lStructSize = sizeof(OPENFILENAME);
#endif
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = achFilters;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;       // first filter pair in list
    pszFull[0] = '\0';
    ofn.lpstrFile = pszFull;        // we need to get the full path to open
    ofn.nMaxFile = cchMax;
    ofn.lpstrFileTitle = fn;        // return final elem of name here
    ofn.nMaxFileTitle = 13;     // assume just big enough for 8.3+null
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = prompt;        // dialog title is good place for prompt text
    ofn.Flags = OFN_HIDEREADONLY;
    ofn.lpstrDefExt = ext;

    /*
     * loop until the user cancels, or selects a file that we can create/write
     */
    do {
        if (!GetSaveFileName(&ofn)) {
            return(FALSE);
        }

        fh = CreateFile(pszFull, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);

        if (fh == INVALID_HANDLE_VALUE) {
            if (MessageBox(NULL, "File Could Not Be Created", "File Open",
                           MB_OKCANCEL|MB_ICONSTOP) == IDCANCEL) {
                return(FALSE);
            }
        }
    } while (fh == INVALID_HANDLE_VALUE);

    CloseHandle(fh);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\gmem.c ===
/*
 * memory utility functions
 *
 * global heap functions - allocate and free many small
 * pieces of memory by calling global alloc for large pieces
 * and breaking them up.
 *
 * We get memory allocations in units of ALLOCSIZE and hand out blocks
 * in units of BLKSIZE.  Each allocation has a bitmap (segmap) with one
 * bit per block to track the blocks in the allocation that have been
 * handed out.  All the allocations together are referred to as the heap.
 * The bitmap maps the entire allocation, so the first thing done is to
 * set the bits to say that the header (including the bitmap itself) has
 * already gone.  Each allocation contains a count of the number of free
 * blocks left in it.  This allows us to avoid searching allocations that
 * cannot possibly have enough room.
 *
 * Whenever we hand out some blocks we store the HGLOBAL of that allocation
 * immediately before the bit we hand out.  This means that the HGLOBAL
 * gets stored in a lot of places, but we can always find it from the
 * pointer that the caller has.  (Obviously we add a handle size to the
 * bytes asked for to allow for this).  For historical reasons HGLOBALs are
 * often referred to as seg handles.  The caller knows about the handle to
 * the whole heap.  Only we know about these other handles.
 * All allocations are kept locked.
 *
 * Requests for more than MAXGALLOC bytes are passed on to GlobalAlloc and
 * so have none of this.  Likewise when they are freed.
 *
 * The allocations are chained up so that we can look for free space in all
 * of them - BUT to keep speed
 * 1. we keep track of the number of free blocks in an allocation and
 * only look at the bitmap if it might win.
 * 2. When we fail to find free space and so get a new allocation, we chain
 * it on the front, so we will then normally allocate from this new first block.
 * We only * look further down the chain when the first block fails us.
 *
 * Multithread safe.  An allocation contains a critical section, so
 * multiple simultaneous calls to gmem_get and gmem_free will be
 * protected.
 *
 * gmem_freeall should not be called until all other users have finished
 * with the heap.
 */

#include <windows.h>
#include <memory.h>

#include "gutils.h"
#include "gutilsrc.h"                   /* for string id */
extern HANDLE hLibInst;

/*
 * out-of-memory is not something we regard as normal.
 * - if we cannot allocate memory - we put up an abort-retry-ignore
 * error, and only return from the function if the user selects ignore.
 */

int gmem_panic(void);


/* ensure BLKSIZE is multiple of sizeof(DWORD) */
#define BLKSIZE         16                /* block size in bytes to hand out */
#define ALLOCSIZE       32768             /* allocation size in bytes to get */
#define NBLKS           (ALLOCSIZE / BLKSIZE)            /* blocks per alloc */
#define MAPSIZE         (NBLKS / 8)                /* bytes of bitmap needed */
#define MAPLONGS        (MAPSIZE / sizeof(DWORD)) /* DWORDS of bitmap needed */

/* Macro to convert a request in bytes to a (rounded up) number of blocks */
#define TO_BLKS(x)      (((x) + BLKSIZE - 1) / BLKSIZE)


typedef struct seghdr {
    HANDLE hseg;                       /* The HGLOBAL of this allocation */
    CRITICAL_SECTION critsec;          /* Critsec for this allocation */
    struct seghdr FAR * pnext;         /* Next allocation */
    long nblocks;                      /* num free blocks left in this alloc */
    DWORD segmap[MAPLONGS];            /* The bitmap */
    /* The available storage in an allocation follows immediately */
} SEGHDR, FAR * SEGHDRP;


/* Anything above this size, we alloc directly from global
   This must be smaller than ALLOCSIZE - sizeof(SEGHDR) - sizeof(HANDLE)
*/
#define MAXGALLOC       20000


/*
 * init heap - create first segment.
   Return the locked HGLOBAL of the new, initialised heap or NULL if it fails.
 */
HANDLE APIENTRY
gmem_init(void)
{
    HANDLE hNew;
    SEGHDRP hp;

    /* Try to allocate.  If fails, call gmem_panic.
       If user says IGNORE, return NULL, else go round again.
    */
    do {
        hNew = GlobalAlloc(GHND, ALLOCSIZE);/* moveable and Zero-init */
        if (hNew == NULL) {
            if (gmem_panic() == IDIGNORE) {
                return(NULL);
            }
        }
    } while (hNew == NULL);

    /* Lock it - or return NULL (unexpected) if it won't */
    hp = (SEGHDRP) GlobalLock(hNew);
    if (hp == NULL) {
        GlobalFree(hNew);
        return(NULL);
    }

    hp->hseg = hNew;
    InitializeCriticalSection(&hp->critsec);
    hp->pnext = NULL;
    gbit_init(hp->segmap, NBLKS);
    gbit_alloc(hp->segmap, 1, TO_BLKS(sizeof(SEGHDR)));
    hp->nblocks = NBLKS - TO_BLKS(sizeof(SEGHDR));

    return(hNew);
} /* gmem_init */


LONG gmemTime = 0;  /* time used in musec */
LONG gmemTot = 0;   /* number of calls */

LONG APIENTRY gmem_time(void)
{  return MulDiv(gmemTime, 1, gmemTot);
}

#ifdef TIMING
LPSTR APIENTRY gmem_get_internal(HANDLE hHeap, int len);

LPSTR APIENTRY
gmem_get(HANDLE hHeap, int len)
{
    LPSTR Ret;
    LARGE_INTEGER time1, time2, freq;
    LONG t1, t2;

    QueryPerformanceFrequency(&freq);
    if (gmemTot==0) {
        char msg[80];
        LONG temp = freq.LowPart;
        wsprintf(msg, "QPF gave %d", temp);
        Trace_Error(NULL, msg, FALSE);
    }
    ++gmemTot;
    QueryPerformanceCounter(&time1);
    Ret = gmem_get_internal(hHeap, len);
    QueryPerformanceCounter(&time2);

    t1 = time1.LowPart;
    t2 = time2.LowPart;
    gmemTime += t2-t1;

    return Ret;
}

#else
/* cause gmem_get_internal to actually be the real gmem_get */
    #define gmem_get_internal gmem_get
#endif


/* Return an LPSTR pointing to room for len bytes.  Try allocatng
   initially from hHeap, but reserve the right to get it from elsewhere.
   Return NULL if it fails.
*/
LPSTR APIENTRY
gmem_get_internal(HANDLE hHeap, int len)
{
    SEGHDRP chainp;
    HANDLE hNew;
    SEGHDRP hp;
    LPSTR chp;
    long nblks;
    long start;
    long nfound;

    chp = NULL;   /* eliminate spurious compiler warning - generate worse code. */

    //{   char msg[80];
    //    wsprintf(msg, "gmem_get %d bytes", len);
    //    Trace_File(msg);
    //}

    /* Zero bytes?  Address zero is an adequate place! */
    if (len < 1) {
        return(NULL);
    }

    /* The heap is always locked (in gmem_init).
       Lock it again to get the pointer then we can safely unlock it.
     */
    chainp = (SEGHDRP) GlobalLock(hHeap);
    GlobalUnlock(hHeap);

    /*
     * Too big to be worth allocing from heap? - get from globalalloc.
     */
    if (len > MAXGALLOC) {
        /* Try to allocate.  If fails, call gmem_panic.
           If user says IGNORE, return NULL, else go round again.
        */
        do {
            hNew = GlobalAlloc(GHND, len);
            if (hNew == NULL) {
                if (gmem_panic() == IDIGNORE) {
                    return(NULL);
                }
            }
        } while (hNew == NULL);

        chp = GlobalLock(hNew);
        if (chp == NULL) {
            GlobalFree(hNew);
            return(NULL);
        }

        //{   char msg[80];
        //    wsprintf(msg, " gmem_get direct address ==> %8x", chp);
        //    Trace_File(msg);
        //}
        return(chp);
    }


    /*
     * get critical section during all access to the heap itself
     */
    EnterCriticalSection(&chainp->critsec);

    nblks = TO_BLKS(len + sizeof(HANDLE));

    for (hp = chainp; hp !=NULL; hp = hp->pnext) {
        if (hp->nblocks >= nblks) {
            nfound = gbit_findfree(hp->segmap, nblks,NBLKS, &start);
            if (nfound >= nblks) {
                gbit_alloc(hp->segmap, start, nblks);
                hp->nblocks -= nblks;

                /* convert blocknr to pointer
                 * store seg handle in block
                 * Prepare to return pointer to just after handle.
                 */
                chp = (LPSTR) hp;
                chp = &chp[ (start-1) * BLKSIZE];
                * ( (HANDLE FAR *) chp) = hp->hseg;
                chp += sizeof(HANDLE);

                break;
            }
        }
    }
    if (hp == NULL) {

        // Trace_File("<gmen-get new block>");
        /* Try to allocate.  If fails, call gmem_panic.
           If user says IGNORE, return NULL, else go round again.
        */
        do {
            hNew = GlobalAlloc(GHND, ALLOCSIZE);
            if (hNew == NULL) {
                if (gmem_panic() == IDIGNORE) {
                    LeaveCriticalSection(&chainp->critsec);
                    return(NULL);
                }
            }
        } while (hNew == NULL);

        hp = (SEGHDRP) GlobalLock(hNew);
        if (hp == NULL) {
            LeaveCriticalSection(&chainp->critsec);
            GlobalFree(hNew);
            return(NULL);
        }
        hp->pnext = chainp->pnext;
        hp->hseg = hNew;
        chainp->pnext = hp;
        gbit_init(hp->segmap, NBLKS);
        gbit_alloc(hp->segmap, 1, TO_BLKS(sizeof(SEGHDR)));
        hp->nblocks = NBLKS - TO_BLKS(sizeof(SEGHDR));
        nfound = gbit_findfree(hp->segmap, nblks, NBLKS, &start);
        if (nfound >= nblks) {
            gbit_alloc(hp->segmap, start, nblks);
            hp->nblocks -= nblks;

            /* convert block nr to pointer */
            chp = (LPSTR) hp;
            chp = &chp[ (start-1) * BLKSIZE];
            /* add a handle into the block and skip past */
            * ( (HANDLE FAR *) chp) = hp->hseg;
            chp += sizeof(HANDLE);
        }
    }

    /* ASSERT - by now we MUST have found a block.  chp cannot be garbage.
       This requires that MAXGALLOC is not too large.
    */
    //{   char msg[80];
    //    wsprintf(msg, " gmem_get suballoc address ==> %8x\n", chp);
    //    Trace_File(msg);
    //}


    LeaveCriticalSection(&chainp->critsec);
    memset(chp, 0, len);   /* We ask for ZEROINIT memory, but it could have
                              been already affected by gmem_get; use; gmem_free
                           */
    return(chp);
} /* gmem_get */

void APIENTRY
gmem_free(HANDLE hHeap, LPSTR ptr, int len)
{
    SEGHDRP chainp;
    SEGHDRP hp;
    HANDLE hmem;
    long nblks, blknr;
    LPSTR chp;

    //{   char msg[80];
    //    wsprintf(msg, " gmem_free address ==> %8x, len %d \n", ptr, len);
    //    Trace_File(msg);
    //}

    if (len < 1) {
        return;
    }

    /* In Windiff, things are run on different threads and Exit can result
       in a general cleanup.  It is possible that the creation of stuff is
       in an in-between state at this point.  The dogma is that when we
       allocate a new structure and tie it into a List or whatever that
       will need to be freed later:
       EITHER all pointers within the allocated structure are made NULL
              before it is chained in
       OR the caller of Gmem services undertakes not to try to free any
          garbage pointers that are not yet quite built
       For this reason, if ptr is NULL, we go home peacefully.
    */
    if (ptr==NULL) return;

    /*
     * allocs greater than MAXGALLOC were too big to be worth
     * allocing from the heap - they will have been allocated
     * directly from globalalloc
     */
    if (len > MAXGALLOC) {
        hmem = GlobalHandle( (LPSTR) ptr);
        GlobalUnlock(hmem);
        GlobalFree(hmem);
        return;
    }

    chainp = (SEGHDRP) GlobalLock(hHeap);
    EnterCriticalSection(&chainp->critsec);


    /* just before the ptr we gave the user, is the handle to
     * the block.
     */
    chp = (LPSTR) ptr;
    chp -= sizeof(HANDLE);
    hmem = * ((HANDLE FAR *) chp);
    hp = (SEGHDRP) GlobalLock(hmem);

    nblks = TO_BLKS(len + sizeof(HANDLE));

    /* convert ptr to block nr */
    blknr = TO_BLKS( (unsigned) (chp - (LPSTR) hp) ) + 1;

    gbit_free(hp->segmap, blknr, nblks);
    hp->nblocks += nblks;

    GlobalUnlock(hmem);

    LeaveCriticalSection(&chainp->critsec);
    GlobalUnlock(hHeap);
}

void APIENTRY
gmem_freeall(HANDLE hHeap)
{
    SEGHDRP chainp;
    HANDLE hSeg;

    chainp = (SEGHDRP) GlobalLock(hHeap);
    /* this segment is always locked - so we need to unlock
     * it here as well as below
     */
    GlobalUnlock(hHeap);

    /* finished with the critical section  -
     * caller must ensure that at this point there is no
     * longer any contention
     */
    DeleteCriticalSection(&chainp->critsec);

    while (chainp != NULL) {
        hSeg = chainp->hseg;
        chainp = chainp->pnext;
        GlobalUnlock(hSeg);
        GlobalFree(hSeg);
    }
}

/*
 * a memory allocation attempt has failed. return IDIGNORE to ignore the
 * error and return NULL to the caller, and IDRETRY to retry the allocation
 * attempt.
 */
int
gmem_panic(void)
{
    int code;

    TCHAR szBuff1[MAX_PATH];
    TCHAR szBuff2[MAX_PATH];

    LoadString(hLibInst,
               IDS_MEMORY_ALLOC_FAIL,
               szBuff1,
               sizeof(szBuff1)/sizeof(szBuff1[0]));
    LoadString(hLibInst,
               IDS_OUT_OF_MEMORY,
               szBuff2,
               sizeof(szBuff2)/sizeof(szBuff2[0]));
    code = MessageBox(NULL, szBuff1, szBuff2,
                      MB_ICONSTOP|MB_ABORTRETRYIGNORE);
    if (code == IDABORT) {
        /* abort this whole process */
        ExitProcess(1);
    } else {
        return(code);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\list.c ===
/* Laurie Griffiths C version 05/12/91 */
/* Storage allocation scheme customised */

#include <memory.h>
#include <windows.h>
#include "gutils.h"
#include "list.h"
#include <stdio.h>

// use the standard Trace_Error function, but we have no
// parent window to pass for these errors.
#define TRACE_ERROR(a, b)	Trace_Error(NULL, a, b)


char msg[80];  /* a temp for building up snprintf messages in */

/* Under windows, malloc and GlobalAlloc each seem to give about the
** same number of allocations before they run out of steam, and on my
** laptop it's only about 1600 odd, despite 3M of memory.  Furthermore,
** the number doesn't change much if you allocate in lumps of 30 bytes or
** 1500 bytes.  Alas, it looks as though (one more time, one more operating
** system) we get to do our own allocation scheme.  Sigh.  When will they
** ever learn.
** So we need a List_Init function and a List_Term function.
** In between, we have a current block which is a K or two long and we
** allocate storage from inside it unless there's no room, in which case
** we move onto the next block.  We retain a count of the number of
** allocations within a block.  We make no attempt to reclaim storage
** until the whole block's free (count gone back to 0), then we free it.
** The block holds its handle.  Individual allocations hold a pointer
** to the block start.
**
** Purely for checking purposes, the blocks are all chained together.
** List_Term (which has no function other than checking) checks that
** this chain is empty.  Apart from this we do not keep track of the
** allocations. We just hand them out and let the calling program keep track.
*/
#define BLOCKSIZE 25000
typedef struct blockTag {
    struct blockTag * PrevBlock; /* backward link (NULL terminated doubly linked chain of blocks) */
    struct blockTag * NextBlock; /* forward link (pCurrent points to last in chain) */
    HANDLE hMem;     /* memory handle for this block */
    int iInUse;      /* number of allocations taken out of it.  0 => free it */
    SIZE_T iNext;       /* next byte to use */
    char chData[BLOCKSIZE];
} BLOCK, *PBLOCK;

CRITICAL_SECTION CritSec;  /* to protect pCurrent */

PBLOCK pCurrent = NULL;  /* block currently in use */
/* must always be either NULL or valid */

/* Allocate storage for List elements.  n.b. after a call to this
   you MUST record the value of pCurrent as you need to hand that in
   to Free.  You don't hand in the value of the actual storage.
   See screed above.
   This function Enters the critical section.  The caller must Leave it.
*/
LPVOID
list_Alloc(
          SIZE_T size
          )
{
    HANDLE hMem;
    LPVOID pRet;
    PBLOCK pb;
    EnterCriticalSection(&CritSec);
    if ((pCurrent==NULL)||(pCurrent->iNext+size>BLOCKSIZE+1)) {
        hMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE|GMEM_ZEROINIT,(DWORD)(sizeof(BLOCK)));
        if (hMem==NULL) {pCurrent = NULL;
            OutputDebugString("GlobalAlloc failed!!\n");
            return NULL;
        }
        pb = pCurrent;
        pCurrent = (PBLOCK)GlobalLock(hMem);
        if (pCurrent==NULL) {OutputDebugString("GlobalLock failed!!\n");
            return NULL;
        }
        pCurrent->PrevBlock = pb;
        pCurrent->NextBlock = NULL;
        pCurrent->hMem = hMem;
        pCurrent->iInUse = 0;
        pCurrent->iNext = 0;
        if (pb==NULL)
            ;
        else
            pb->NextBlock = pCurrent;
    }
    pRet = &(pCurrent->chData[pCurrent->iNext]);
    ++(pCurrent->iInUse);
    pCurrent->iNext += size;

    /* for MIPS we must also ensure that the data is aligned 4 byte*/
    pCurrent->iNext = ((pCurrent->iNext + (sizeof(void *)-1)) & ~(sizeof(void *) - 1));

    return pRet;
}

void
list_Free(
         PBLOCK pBlock,
         LPVOID p
         )
{
    HANDLE hMem;
    EnterCriticalSection(&CritSec);
    --pBlock->iInUse;
    if (pBlock->iInUse<=0) {if (pBlock->iInUse<0) {_snprintf(msg,sizeof(msg),"Bug in List code. Tell LaurieGr!\nList block allocation negative (%d)", pBlock->iInUse);
            TRACE_ERROR(msg, FALSE);
        }
        if (pCurrent==pBlock) pCurrent = pBlock->PrevBlock; /* defend the invariant */
        /* loop it out of the chain */
        if (pBlock->PrevBlock!=NULL) pBlock->PrevBlock->NextBlock = pBlock->NextBlock;
        if (pBlock->NextBlock!=NULL) pBlock->NextBlock->PrevBlock = pBlock->PrevBlock;
        hMem = pBlock->hMem;
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    LeaveCriticalSection(&CritSec);
}



/* The following definition tells the truth about what an ITEM is.  The
|  header file says only that there's a structure with the tag item_tag and
|  that a LIST is a pointer to one.  Here we spell out what that structure
|  is (and a LIST is still a pointer to one).  A PLIST is defined as a
|  pointer to one of those, but is only really used because the C
|  parameter mechanism demands an extra level of indirection for a
|  parameter that can be updated.  (Modula-2 VAR parameter).
*/
typedef struct item_tag {
    struct item_tag *pitNext;    /* to next in circular list */
    struct item_tag *pitPrev;    /* to prev in circular list */
    PBLOCK pBlock;               /* to memory block */
    BOOL bAnchor;                /* TRUE iff an anchor block */
    BOOL bOK;                    /* true unless a list op has failed */
    int iLen;                    /* length of data only */
    char *Data[1];               /* the caller's data.  The '1' is a lie */
} ITEM;

/* For an anchor block, only the fields pitNext thru bAnchor are allocated.
|  For a normal list element, Data may well be longer than 1 byte.
|  The bOK flag is to support a style of programming where several
|  successive operations can be done without having to check the return
|  code at each stage.  At the end, the list can be examined to see if
|  the data in it is valid or if it has been made invalid by the failure
|  of any of the previous operations.  Certain operations may result in
|  having no list at all if they fail (e.g. create) and for these, you'd
|  better check the result at once!
|  ??? Some of this screed belongs in the header!!!
*/

static SIZE_T iAnchorSize;      /* Size of anchor block (no data, no dummy) */
static SIZE_T iHeaderSize;      /* Size of data block not counting Data
                                and offset from cursor back to item.
                             */
static BOOL bInited = FALSE; /* TRUE <=> iAnchorSize and iHeaderSize are OK*/

#define MOVEBACK(Curs)                                               \
   { Curs = ((char *)Curs-iHeaderSize); } /*move from Data to pitNext*/

/*==================================================================
|| Lists are circular, doubly linked with an anchor block which holds
|| pointers to both ends.  Every block has a flag which shows whether
|| it's an anchor or not.
||
|| Empty list:
||
||      -------------
||     |             |
||     |   Anchor    |
||     v   -------   |
||  Ul--->| Next--+--|
||        |-------|  |
||        | Prev--+--
||         -------
||
|| One entry list:
||
||      ------------------------------------
||     |                                    |
||     |   Anchor                           |
||     v   -------                ------    |
||  Ul--->| Next--+------------->| Next-+---|
||        |-------|    |         |------|   |
||        | Prev--+----          | Prev-+---
||         -------               |------|
||                               | Len  |
||                               |------|
||                               | Data |
||                                ------
|| Two entry list:
||
||      -------------------------------------------------
||     | ---------------    ---------------              |
||     ||               |  |               |             |
||     ||  Anchor       |  |               |             |
||     vv  --------     |  v    ------     |    ------   |
||  Ul--->| Next--+-----+----->| Next-+----+-->| Next-+--
||        |-------|     |      |------|  | |   |------|
||        | Prev--+--    ------+-Prev |  |  ---+-Prev |
||         -------   |         |------|  |     |------|
||                   |         | Len  |  |     | Len  |
||                   |         |------|  |     |------|<----Cursor
||                   |         | Data |  |     | Data |
||                   |          ------   |      ------
||                   |                   |
||                    -------------------
||
|| etc.
||
|| Note that an external cursor (i.e one which is seen by the caller)
|| points to the Data field, not to the start of the structure.
|| This allows easy access to the data by the user at the cost of a
|| slightly slower traverse.
|| Within this module, we may sometimes traverse a list with  a cursor
|| that points to the start of an item.  This is called an item cursor.
===================================================================*/

/*------------------------------------------------------------------
| Set iAnchorSize and iHeaderSize.  Implementation independent!
 -------------------------------------------------------------------*/
void
APIENTRY
List_Init(
         void
         )
{
    LIST P;
    P = (LIST)&P;                  /* really any old address will do */
    iAnchorSize = (char *)&(P->iLen) - (char *)&(P->pitNext);
    iHeaderSize = (char *)&(P->Data) - (char *)&(P->pitNext);
    InitializeCriticalSection(&CritSec);
    /* assumes layout in storage is linear */
}


void
APIENTRY
List_Term(
         void
         )
{
    if (pCurrent!=NULL)
        TRACE_ERROR("List storage not cleared out properly", FALSE);
}



/* Dump the internals to the debugger. */
void
APIENTRY
List_Dump(
         LPSTR Header,
         LIST lst
         )
{
    LIST pit;
    char X_msg[250] = {0};

    OutputDebugString(Header);  OutputDebugString("\n");
    pit = lst;
    do {
        _snprintf(X_msg,sizeof(X_msg)-1, "%8p %8p %8p %ld %s "
                 , pit, pit->pitNext, pit->pitPrev, pit->iLen
                 , (pit->bAnchor ? "Anchor" : "Data")
                );
        OutputDebugString(X_msg);
        if (pit->pitNext->pitPrev != pit)
            OutputDebugString(" Next Prev error!!");
        if (pit->pitPrev->pitNext != pit)
            OutputDebugString(" Prev Next error!!");
        OutputDebugString("\n");
        pit = pit->pitNext;
    } while (pit!=lst);
    OutputDebugString("End of list dump\n");
}

/* Dump hex representation of handle to debugger */
void
APIENTRY
List_Show(
         LIST lst
         )
{
    char X_msg[50] = {0};
    _snprintf(X_msg, sizeof(X_msg)-1, "%p", lst);
    OutputDebugString(X_msg);
}

/*------------------------------------------------------------------
| Create a list.  It will be initially empty
 -------------------------------------------------------------------*/
LIST
APIENTRY
List_Create(
           void
           )
{
    LIST lst;
    if (!bInited) {
        List_Init();            /* prevent some strange errors */
    }
    lst = list_Alloc(iAnchorSize);

    if (lst==NULL) {
        return NULL;
    }
    lst->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    lst->bOK = TRUE;
    lst->pitNext = lst;
    lst->pitPrev = lst;
    lst->bAnchor = TRUE;
    /* no length field set in an anchor block */
    return lst;
}

/*------------------------------------------------------------------
| Destroy *plst.  It does not need to be empty first
 -------------------------------------------------------------------*/
void
APIENTRY
List_Destroy(
            PLIST plst
            )
{
    LIST pitP;    /* item cursor on * plst */
    LIST pitQ;    /* item cursor runs one step ahead of pitQ */

    if (plst==NULL) {
        TRACE_ERROR("Bug:Attempt to destroy NULL list.  Continuing...", FALSE);
        return;
    }

    /* There is at least an anchor block to destroy */
    pitP = *plst;
    do {
        pitQ = pitP->pitNext;
        list_Free(pitP->pBlock, pitP);
        pitP = pitQ;
    }while (pitP != *plst);
    *plst = NULL;
}

/*------------------------------------------------------------------
| Add an item holding Object to the beginning of * plst
 -------------------------------------------------------------------*/
void
APIENTRY
List_AddFirst(
             LIST lst,
             LPVOID pObject,
             UINT uLen
             )
{
    LIST pit;      /* newly allocated item */

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddFirst to bogus list.  Continuing...", FALSE);
        return;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitPrev = lst;
    pit->pitNext = lst->pitNext;
    lst->pitNext->pitPrev = pit; /* for empty list that set lst->pitPrev */
    lst->pitNext = pit;
    pit->bAnchor = FALSE;
    memcpy( &(pit->Data), pObject, uLen );
}

/*------------------------------------------------------------------
| Return the address of the place for Len bytes of data in a new
| item at the start of lst
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewFirst(
             LIST lst,
             UINT uLen
             )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewFirst to bogus list.  Continuing...", FALSE);
        return NULL;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return NULL;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitPrev = lst;
    pit->pitNext = lst->pitNext;
    lst->pitNext->pitPrev = pit; /* for empty list that set lst->pitPrev */
    lst->pitNext = pit;
    pit->bAnchor = FALSE;
    return (char *)&(pit->Data);
}

/*------------------------------------------------------------------
| Delete the first item in lst.  Error if lst is empty
 -------------------------------------------------------------------*/
void
APIENTRY
List_DeleteFirst(
                LIST lst
                )
{
    LIST pit;

    if (lst==NULL) {TRACE_ERROR("Bug: List_DeleteFirst from bogus list.  Continuing...", FALSE);
        return;
    }
    /* attempting to delete the anchor block! */
    if (lst->pitNext==lst) {
        lst->bOK = FALSE;
    } else {
        pit = lst->pitNext;
        pit->pitNext->pitPrev = pit->pitPrev;
        pit->pitPrev->pitNext = pit->pitNext;
        list_Free(pit->pBlock, pit);
    }
}

/*------------------------------------------------------------------
| Add an item holding Object to the end of lst
 -------------------------------------------------------------------*/
void
APIENTRY
List_AddLast(
            LIST lst,
            LPVOID pObject,
            UINT uLen
            )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddLast to bogus list. Continuing...", FALSE);
        return;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitNext = lst;
    pit->pitPrev = lst->pitPrev;
    lst->pitPrev->pitNext = pit; /* for empty list that set lst->pitNext */
    lst->pitPrev = pit;
    pit->bAnchor = FALSE;
    memcpy( &(pit->Data), pObject, uLen );
}

/*------------------------------------------------------------------
| Return the address of the place for uLen bytes of data in a new
|  item at the end of lst
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewLast(
            LIST lst,
            UINT uLen
            )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewLast in bogus list.  Continuing...", FALSE);
        return NULL;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return NULL;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitNext = lst;
    pit->pitPrev = lst->pitPrev;
    lst->pitPrev->pitNext = pit; /* for empty list that set lst->pitNext */
    lst->pitPrev = pit;
    pit->bAnchor = FALSE;
    return (char *)&(pit->Data);
}

/*------------------------------------------------------------------
| Delete the last item in lst.  Error if lst is empty
 -------------------------------------------------------------------*/
void
APIENTRY
List_DeleteLast(
               LIST lst
               )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_DeleteLast from bogus list.  Continuing...", FALSE);
        return;
    }
    /* attempting to delete the anchor block! */
    if (lst->pitNext==lst) {
        lst->bOK = FALSE;
    } else {
        pit = lst->pitPrev;
        pit->pitNext->pitPrev = pit->pitPrev;
        pit->pitPrev->pitNext = pit->pitNext;
        list_Free(pit->pBlock, pit);
    }
}

/*--------------------------------------------------------------------
| Add an item holding * pObject to lst immediately after Curs.
| List_AddAfter(lst,NULL,pObject,Len) adds it to the start of the lst
 ---------------------------------------------------------------------*/
void
APIENTRY
List_AddAfter(
             LIST lst,
             LPVOID Curs,
             LPVOID pObject,
             UINT uLen
             )
{
    LIST pitNew;
    LIST pitAfter;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddAfter in bogus list.  Continuing...", FALSE);
        return;
    }
    if (Curs==NULL) {
        List_AddFirst(lst, pObject, uLen);
    } else {
        MOVEBACK(Curs);
        pitAfter = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitPrev = pitAfter;
        pitNew->pitNext = pitAfter->pitNext;
        pitAfter->pitNext->pitPrev = pitNew;
        pitAfter->pitNext = pitNew;
        pitNew->bAnchor = FALSE;
        memcpy( &(pitNew->Data), pObject, uLen );
    }
}

/*--------------------------------------------------------------------
| Return the address of the place for uLen bytes of data in a new
| item immediately after Curs.
| List_NewAfter(Lst,NULL,uLen) returns a pointer
| to space for uLen bytes in a new first element.
 ---------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewAfter(
              LIST lst,
              LPVOID Curs,
              UINT uLen
              )
{
    LIST pitNew;
    LIST pitAfter;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewAfter in bogus list. Continuing...", FALSE);
        return NULL;
    }
    if (Curs==NULL) {
        return List_NewFirst(lst, uLen);
    } else {
        MOVEBACK(Curs);
        pitAfter = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return NULL;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitPrev = pitAfter;
        pitNew->pitNext = pitAfter->pitNext;
        pitAfter->pitNext->pitPrev = pitNew;
        pitAfter->pitNext = pitNew;
        pitNew->bAnchor = FALSE;
        return (char *)&(pitNew->Data);
    }
}

/*--------------------------------------------------------------------
| Add an item holding Object to lst immediately before Curs.
| List_AddBefore(Lst,NULL,Object,uLen) adds it to the end of the list
 ---------------------------------------------------------------------*/
void
APIENTRY
List_AddBefore(
               LIST lst,
               LPVOID Curs,
               LPVOID pObject,
               UINT uLen
                            )
{
    LIST pitNew;
    LIST pitBefore;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddBefore in bogus list.  Continuing...", FALSE);
        return;
    }
    if (Curs==NULL) {
        List_AddLast(lst, pObject, uLen);
    } else {
        MOVEBACK(Curs);
        pitBefore = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitNext = pitBefore;
        pitNew->pitPrev = pitBefore->pitPrev;
        pitBefore->pitPrev->pitNext = pitNew;
        pitBefore->pitPrev = pitNew;
        pitNew->bAnchor = FALSE;
        memcpy( &(pitNew->Data), pObject, uLen );
    }
}

/*--------------------------------------------------------------------
| Return the address of the place for uLen bytes of data in a new
| item immediately before Curs.
| List_NewBefore(Lst,NULL,uLen) returns a pointer
| to space for uLen bytes in a new last element.
 ---------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewBefore(
               LIST lst,
               LPVOID Curs,
               UINT uLen
               )
{
    LIST pitNew;
    LIST pitBefore;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewBefore in bogus list.  Continuing...", FALSE);
        return NULL;
    }
    if (Curs==NULL) {
        return List_NewLast(lst, uLen);
    } else {
        MOVEBACK(Curs);
        pitBefore = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return NULL;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitNext = pitBefore;
        pitNew->pitPrev = pitBefore->pitPrev;
        pitBefore->pitPrev->pitNext = pitNew;
        pitBefore->pitPrev = pitNew;
        pitNew->bAnchor = FALSE;
        return (char *) &(pitNew->Data);
    }
}

/*------------------------------------------------------------------
| Delete the item that Curs identifies.
| This will be only a few (maybe as little as 3) machine instructions
| quicker than DeleteForwards or DeleteBackwards but leaves Curs dangling.
| It is therefore NOT usually to be preferred.
| It may be useful when you have a function which returns an LPVOID
| since the argument does not need to be a variable.
|     Trivial example: List_Delete(List_First(L));
 -------------------------------------------------------------------*/
void
APIENTRY
List_Delete(
            LPVOID Curs
            )
{
    LIST pit;
    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_Delete NULL item", FALSE);
        return;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    pit->pitNext->pitPrev = pit->pitPrev;
    pit->pitPrev->pitNext = pit->pitNext;
    list_Free(pit->pBlock, pit);
}

/*-----------------------------------------------------------------------
| Delete the item that Curs identifies and return a cursor that
| identifies the next item (NULL if already on last)
 ------------------------------------------------------------------------*/
LPVOID
APIENTRY
List_DeleteForwards(
                    LPVOID Curs
                    )
{
    LIST pitDel;  /* the item to delete */
    LIST pitN;    /* the item after (could be anchor) */
    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_DeleteForwards NULL cursor. Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pitDel = (LIST)Curs;
    pitN = pitDel->pitNext;

    pitN->pitPrev = pitDel->pitPrev;
    pitDel->pitPrev->pitNext = pitN;
    list_Free(pitDel->pBlock, pitDel);
    if (pitN->bAnchor)
        return NULL;
    else
        return (char *)&(pitN->Data);
}

/*-----------------------------------------------------------------------
| Delete the item that Curs identifies and return a cursor that
| identifies the previous item (NULL if already on first)
 ------------------------------------------------------------------------*/
LPVOID
APIENTRY
List_DeleteBackwards(
                     LPVOID Curs
                     )
{
    LIST pitDel;  /* the one to delete */
    LIST pitB;    /* the one before */

    if (Curs==NULL) {
        TRACE_ERROR("List_DeleteBackwards NULL cursor.  Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pitDel = (LIST)Curs;
    pitB = pitDel->pitPrev;
    pitDel->pitNext->pitPrev = pitB;
    pitB->pitNext = pitDel->pitNext;
    list_Free(pitDel->pBlock, pitDel);
    if (pitB->bAnchor)
        return NULL;
    else
        return (char *)&(pitB->Data);
}

/*-------------------------------------------------------------------
| Return the length of the object identified by the cursor Curs
 -------------------------------------------------------------------*/
int
APIENTRY
List_ItemLength(
                LPVOID Curs
                )
{
    LIST pit;
    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_ItemLength NULL cursor.  Continuing...", FALSE);
        return 0;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    return pit->iLen;
}

/*------------------------------------------------------------------
| Return the address of the first object in lst
|  If lst is empty then Return NULL.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_First(
           LIST lst
           )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_First of bogus list.  Continuing...", FALSE);
        return NULL;
    }
    if (lst->pitNext==lst) {
        return NULL;
    }
    return &(lst->pitNext->Data);
}

/*------------------------------------------------------------------
| Return the address of the last object in lst
| If lst is empty then return NULL.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_Last(
          LIST lst
          )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_Last of bogus list.  Continuing...", FALSE);
        return NULL;
    }
    if (lst->pitNext==lst) {
        return NULL;
    }
    return &(lst->pitPrev->Data);
}

/*------------------------------------------------------------------
| Return the address of the object after Curs^.
| List_Next(List_Last(lst)) == NULL;  List_Next(NULL) is an error.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_Next(
          LPVOID Curs
          )
{
    LIST pit;

    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_Next of NULL cursor.  Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    pit = pit->pitNext;
    if (pit->bAnchor) {
        return NULL;
    } else {
        return &(pit->Data);
    }
}

/*------------------------------------------------------------------
| Return the address of the object after Curs^.
| List_Prev(List_First(L)) == NULL;  List_Prev(NULL) is an error.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_Prev(
          LPVOID Curs
          )
{
    LIST pit;

    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_Prev of NULL cursor.  Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    pit = pit->pitPrev;
    if (pit->bAnchor) {
        return NULL;
    } else {
        return &(pit->Data);
    }
}

/*-------------------------------------------------------------------
| Arrange that lst is empty after this call
 --------------------------------------------------------------------*/
void
APIENTRY
List_Clear(
           LIST lst
           )
{
    LIST pitP;   /* item cursor on List, points to element starts */
    LIST pitQ;   /* runs one step ahead of pitP                   */

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_Clear of bogus list.  Continuing...", FALSE);
        return;
    }
    pitP = lst->pitNext;   /* first element of list proper */
    while (pitP!=lst) {      /* while not wrapped onto anchor */pitQ = pitP->pitNext;
        list_Free(pitP->pBlock, pitP);
        pitP = pitQ;
    }
    lst->bOK = TRUE;
    lst->pitNext = lst;
    lst->pitPrev = lst;
}

/*---------------------------------------------------------------------
| Return TRUE if and only if lst is empty
 ----------------------------------------------------------------------*/
BOOL
APIENTRY
List_IsEmpty(
             LIST lst
             )
{  if (lst==NULL) {TRACE_ERROR("Bug: List_IsEmpty of bogus list.  Continuing...", FALSE);
        return TRUE;   /* well it's sort of true isn't it? */
    }
    return lst->pitNext ==lst;
} /* List_IsEmpty */

/*------------------------------------------------------------------
| l1 had better be empty.  l1 then acquires all the elements from l2
 -------------------------------------------------------------------*/
void
APIENTRY
SwitchLists(
            LIST l1,
            LIST l2
            )
{
    /* connect l1 to l2's elements, l1 had better be initially empty */
    l1->pitPrev = l2->pitPrev;
    l1->pitNext = l2->pitNext;
    /* connect the elements to l1 anchor block. */
    l1->pitPrev->pitNext = l1;
    l1->pitNext->pitPrev = l1;
    /* make l2 empty */
    l2->pitPrev = l2;
    l2->pitNext = l2;
}

/*-----------------------------------------------------------------------
| l1 := l1||l2; l2 := empty
| The elements themselves are not moved, so pointers to them remain valid.
|
| l1 gets all the elements of l1 in their original order followed by
| all the elements of l2 in the order they were in in l2.
| l2 becomes empty.
 ------------------------------------------------------------------------*/
void
APIENTRY
List_Join(
          LIST l1,
          LIST l2
          )
{
    if ((l1==NULL)||(l2==NULL)) {
        TRACE_ERROR("Bug: List_Join of bogus list.  Continuing...", FALSE);
        return;
    }
    l1->bOK = l1->bOK &&l2->bOK;  /* result OK if both inputs OK */
    l2->bOK = TRUE;               /* as l2 always becomes empty */
    if (l2->pitNext==l2) {
        /* no elements need moving */
    } else if (l2->pitNext==l2) {
        SwitchLists(l1,l2);
        return;
    } else {
        l2->pitNext->pitPrev = l1->pitPrev;
        l1->pitPrev->pitNext = l2->pitNext;
        l1->pitPrev = l2->pitPrev;
        l1->pitPrev->pitNext = l1;
        l2->pitNext = l2;
        l2->pitPrev = l2;
    }
}

/*-----------------------------------------------------------------------
| Let L1 be *pl1 and L2 be *pl2
| L1 := L1[...Curs] || L2 || L1[Curs+1...]; L2 := empty
| Curs=NULL means insert L2 at the start of L1
| The elements themselves are not moved, so pointers to them remain valid.
|
| L1 gets the elements of L1 from the start up to and including the element
| that Curs points at, in their original order,
| followed by all the elements that were in L2, in their original order,
| followed by the rest of L1
 ------------------------------------------------------------------------*/
void
APIENTRY
List_InsertListAfter(
                     LIST l1,
                     LIST l2,
                     LPVOID Curs
                     )
{
    LIST pitA;     /* The element after Curs, could be anchor */
    LIST pit;      /* The start of the element that Curs points at
                   |  or the anchor block if Curs==NULL
                   */

    if ( (l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_InsertListAfter with bogus list.  Continuing...", FALSE);
        return;
    }
    l1->bOK = l1->bOK && l2->bOK;
    l2->bOK = TRUE;
    if (l2->pitNext==l2) {
        /* no elements need moving */
    } else if ( l1->pitNext==l1) {
        /* the easy way to code this would be simply to switch the two
        |  pointers l1 and l2, but they are value parameters and we don't
        |  want to change that.
        */
        SwitchLists(l1,l2);
        return;
    } else {
        if (Curs==NULL) {
            pit = l1;
        } else {
            MOVEBACK(Curs)
            pit = (LIST)Curs;
        }
        /* pit points to a block to insert after, could be anchor */
        pitA = pit->pitNext;           /* Cannot be same as P, already checked */
        l2->pitNext->pitPrev = pit;    /*  P<-- elems-of-l2    A */
        l2->pitPrev->pitNext = pitA;   /*  P<-- elems-of-l2 -->A */
        pit->pitNext = l2->pitNext;    /*  P<-->elems-of-l2 -->A */
        pitA->pitPrev = l2->pitPrev;   /*  P<-->elems-of-l2<-->A */

        l2->pitNext = l2;
        l2->pitPrev = l2;
    }
}


/*-----------------------------------------------------------------------
| l1 := l1[...Curs-1] || l2 || l1[Curs...]; l2 := empty
| Curs=NULL means insert l2 at the end of l1
| The elements themselves are not moved, so pointers to them remain valid.
|
| l1 gets the elements of l1 from the start up to but not including the
| element that Curs points at, in their original order,
| followed by all the elements that were in l2, in their original order,
| followed by the rest of l1.
 ------------------------------------------------------------------------*/
void
APIENTRY
List_InsertListBefore(
                      LIST l1,
                      LIST l2,
                      LPVOID Curs
                      )
{
    LIST pitB;     /* The element before Curs, could be anchor */
    LIST pit;      /* The start of the element that Curs points at
                    |  or the anchor block if Curs==NULL
                    */

    if ((l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_InsertListBefore with bogus list.  Continuing...", FALSE);
        return;
    }
    l1->bOK = l1->bOK && l2->bOK;
    l2 ->bOK = TRUE;
    if (l2->pitNext==l2) {
        /* no action needed */
    } else if (l1->pitNext==l1) {
        /* the easy way to code this would be simply to switch the two
        |  pointers l1 and l2, but they are value parameters and we don't
        |  want to change that.
        */
        SwitchLists(l1,l2);
        return;
    } else {
        if (Curs==NULL) {
            pit = l1;
        } else {
            MOVEBACK(Curs)
            pit = (LIST)Curs;
        }

        /* P points to a block to insert before, could be anchor */
        pitB = pit->pitPrev;       /* Cannot be same as P, already checked */
        l2->pitNext->pitPrev = pitB; /*  B<-- elems-of-L2    P */
        l2->pitPrev->pitNext = pit;  /*  B<-- elems-of-L2 -->P */
        pitB->pitNext = l2->pitNext; /*  B<-->elems-of-L2 -->P */
        pit->pitPrev = l2->pitPrev;  /*  B<-->elems-of-L2<-->P */
        l2->pitNext = l2;
        l2->pitPrev = l2;
    }
}


/*-----------------------------------------------------------------------
| Let l1 be l1 and l2 be l2
| Split l2 off from the front of l1:    final l2,l1 = original l1
|
| Split l1 into l2: objects of l1 up to and including Curs object
|               l1: objects of l1 after Curs
| Any original contents of l2 are freed.
| List_Spilt(l1, l2, NULL) splits l1 before the first object so l1 gets all.
| The elements themselves are not moved.
 ------------------------------------------------------------------------*/
void
APIENTRY
List_SplitAfter(
                LIST l1,
                LIST l2,
                LPVOID Curs
                )
{
    LIST pit;

    if ((l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_SplitAfter bogus list.  Continuing...", FALSE);
        return;
    }
    if (l2->pitNext!=l2) {
        List_Clear(l2);
    };
    if (Curs!=NULL) {
        MOVEBACK(Curs)
        pit = (LIST)Curs;
        /* Curs had better be an item in l1! l2 had better be created! */
        if (pit==l1) {
            l1->bOK = FALSE;
            l2->bOK = FALSE;
            return;
        }
        if (pit->pitNext==l1) {
            /* transfer whole of l2 to l1 */
            SwitchLists(l2,l1);
            return;
        }
        l2->pitPrev = pit;
        l2->pitNext = l1->pitNext;
        l1->pitNext = pit->pitNext;
        pit->pitNext = l2;
        l2->pitNext->pitPrev = l2;
        l1->pitNext->pitPrev = l1;
    }
}

/*----------------------------------------------------------------------
| Split l2 off from the back of l1:  final l1,l2 = original l1
|
| Split l1 into l1: objects of l1 up to but not including Curs object
|               l2: objects of l1 from Curs onwards
| Any original contants of l2 are freed.
| List_Spilt(l1, l2, NULL) splits l1 after the last object so l1 gets all.
| The elements themselves are not moved.
 -----------------------------------------------------------------------*/
void
APIENTRY
List_SplitBefore(
                 LIST l1,
                 LIST l2,
                 LPVOID Curs
                 )
{
    LIST pit;

    if ((l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_SplitBefore bogus list.  Continuing...", FALSE);
        return;
    }
    if (l2->pitNext!=l2) {
        List_Clear(l2);
    }
    if (Curs!=NULL) {
        MOVEBACK(Curs)
        pit = (LIST)Curs;
        /* Curs had better be an item in L1! L2 had better be created! */
        if (pit==l1) {
            l1->bOK = FALSE;
            l2->bOK = FALSE;
            return;
        }
        if (pit->pitPrev==l1) {
            SwitchLists(l2,l1);
            return;
        }
        l2->pitNext = pit;
        l2->pitPrev = l1->pitPrev;
        l1->pitPrev = pit->pitPrev;
        pit->pitPrev = l2;
        l2->pitPrev->pitNext = l2;
        l1->pitPrev->pitNext = l1;
    }
}

/*------------------------------------------------------------------
| Return the number of items in L
 -------------------------------------------------------------------*/
int
APIENTRY
List_Card(
          LIST lst
          )
{
    LIST pit;     /* item cursor on lst */
    int cit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_Card of bogus list.  Continuing...", FALSE);
        return 0;    /* well it is sort of 0 */
    }
    pit = lst->pitNext;
    cit = 0;
    while (pit!=lst) {
        cit++;
        pit = pit->pitNext;
    }
    return cit;
}

/*------------------------------------------------------------------
| Check return code
 -------------------------------------------------------------------*/
BOOL
APIENTRY
List_IsOK(
          LIST lst
          )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_IsOK of bogus list.  Continuing...", FALSE);
        return FALSE;       /* well it is sick ain't it! */
    }
    return lst->bOK;
}

/*------------------------------------------------------------------
| Set return code to good
 -------------------------------------------------------------------*/
void
APIENTRY
List_MakeOK(
            LIST lst
            )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_MakeOK of bogus list.  Continuing...", FALSE);
        return;
    }
    lst->bOK = TRUE;
}

BOOL
APIENTRY
List_Check(
           LIST lst
           )
{
    LIST pel;
    BOOL bOK;
    /*-----------------------------------------------------------------
    | Check the anchor block has the Anchor flag set.
    | Run through the LIST using the Anchor flag (which should be FALSE)
    | to mark where we have been (to test for loops in the chain)
    | and carry on until we see the Anchor flag again.  Check that this
    | is the anchor block that we started from.  Now do another pass
    | turning the Anchor flags off again and checking the Prev pointers.
     -------------------------------------------------------------------*/
    if (lst==NULL)
        return FALSE;  /* Should we trap?  Arguable */
    bOK = lst->bAnchor;
    pel = lst->pitNext;
    while (! pel->bAnchor) {
        pel->bAnchor = TRUE;
        pel = pel->pitNext;
    }
    bOK = bOK && (pel==lst);
    if (bOK) {
        /* Turn all the bAnchor flags off */
        pel = lst;
        do {pel->bAnchor = FALSE;
            bOK = bOK & (pel->pitNext->pitPrev==pel);
            pel = pel->pitNext;
        } while (pel!=lst);
        lst->bAnchor = TRUE;  /* except the real one */
    } else { /* just turn off those that we set on */
        pel = lst->pitNext;
        while (pel->bAnchor) {
            pel->bAnchor = FALSE;
            pel = pel->pitNext;
        }
        lst->bAnchor = TRUE;
    }
    return bOK;
}


void
APIENTRY
List_Recover(
             PLIST plst
             )
{
    LIST Last, P,Q;
    BOOL OK;
    /* For no particular reason we presume that the forward chain
       is good and reconstruct the back chain from it.  A better
       algorithm would do the kind of things that List_Check does
       to figure out where the problems lie.  This just steps along
       until it sees either an address that it has already seen or
       else the anchor block.  (It's an n-squared algorithm).
       It links the last good block found back to the anchor and
       fixes all the Anchor flags.
    */
    if (plst==NULL)
        return;
    if (*plst==NULL) {
        *plst = List_Create();
        return;
    }
    (*plst)->bAnchor = TRUE;
    P = (*plst)->pitNext;
    Last = *plst;
    for (; ; ) {if (P==*plst) break;
        Last = P;
        if (P->pitNext!=*plst) {OK = TRUE;
            Q = *plst;
            for (; ; ) {
                OK &= (P->pitNext!=Q);
                if (Q==P) break;
                Q = Q->pitNext;
            }
            if (!OK) break;
        }
        P = P->pitNext;
    }
    P = *plst;
    while (P!=Last) {P->pitNext->pitPrev = P;
        P->bAnchor = FALSE;
        P = P->pitNext;
    }
    Last->pitNext = *plst;
    (*plst)->pitPrev = Last;
    (*plst)->bAnchor = TRUE;
    (*plst)->bOK = TRUE;   /* Here's hoping! */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\gutils.h ===
/* standard header for gutils.dll library functions
 * include after windows.h
 */

#define DimensionOf(x) (sizeof(x) / sizeof(x[0]))

/*--------win-16 win-32 porting macros etc ----------------------------*/

/* win32 msg crackers */
#define GET_WM_COMMAND_ID(w, l) (LOWORD(w))
#define GET_WM_COMMAND_CMD(w, l) (HIWORD(w))
#define GET_WM_COMMAND_HWND(w, l) (l)
#define GET_SCROLL_OPCODE(w, l)     (LOWORD(w))
#define GET_SCROLL_POS(w, l)        (HIWORD(w))

/* use of WNDPROC and FARPROC don't match up in definitions of
 * Win 3.1 functions vs NT functions. WINPROCTYPE matches WNDPROC
 * in NT and FARPROC in Win 3.1 so there are no warnings in either.
 * Places that use FARPROC in both APIs continue to use FARPROC.
 */
#define WINPROCTYPE     WNDPROC
// #define DLGPROC              WNDPROC  Doesn't wash on MIPS!!

/* ------- memory allocator ------------------------------------------*/

/* global heap functions - allocate and free many small
 * pieces of memory by calling global alloc for large pieces -
 * avoids using too many selectors
 *
 * DOGMA:
 * If you go running things on different threads and then try to EXIT
 * and hence gmem_free everything on one thread while still allocating
 * and hooking things up on another, things can get a little out of hand!
 * In particular, you may traverse a structure and hence try to FREE
 * a sub-structure to which there is a pointer, but which itself is not yet
 * allocated!
 *
 * The dogma is that when you allocate a new structure and tie it into a List
 * or whatever
 * EITHER all pointers within the allocated structure are made NULL
 *        before it is chained in
 * OR the caller of Gmem services undertakes not to try to free any
 *    garbage pointers that are not yet quite built.
 * It is SAFE to attempt to gmem_free a NULL pointer.  It's a no-op.
 * Note that List_NewXxxx(...) zeros the storage before chaining it in.
 * Note that List_AddXxxx(...) obviously doesn't!
 */
HANDLE APIENTRY gmem_init(void);
LPSTR APIENTRY gmem_get(HANDLE hHeap, int len);
void APIENTRY gmem_free(HANDLE hHeap, LPSTR ptr, int len);
void APIENTRY gmem_freeall(HANDLE hHeap);


/* return total time consumed doing gmem_get */
LONG APIENTRY gmem_time(void);

/* ---- file open/save common dialogs ---------------------------*/

/*
 * these functions now rely on to calls to the common dialog libraries.
 *
 * parameters:
 *      prompt - user prompt text (eg for dialog title)
 *      ext    - default extension (eg ".txt")
 *      spec   - default file spec (eg "*.*")
 *      pszFull - full filename will be copied here.
 *      cchMax - size of pszFull buffer.
 *      fn     - last component of file name will be copied here.
 * returns - TRUE if user selected a file that could be opened for
 *           reading (gfile_open) or created and opened for writing (gfile_new)
 *           FALSE if user canceled. if user selects a file that cannot be
 *           opened, a message box is put up and the dialog re-shown.
 */
BOOL APIENTRY gfile_open(HWND hwnd, LPSTR prompt, LPSTR ext, LPSTR spec,
                         LPSTR pszFull, int cchMax, LPSTR fn);
BOOL APIENTRY gfile_new(LPSTR prompt, LPSTR ext, LPSTR spec,
                        LPSTR pszFull, int cchMax, LPSTR fn);


/* --------- date conversion functions    -----------------------*/
/* days (which is actually days measured from a notional Jan 1st 0000)
   is a convenient way to store the date in a single LONG.  Use
   dmytoday to generate the LONG, use daytodmy to convert back
*/
void APIENTRY gdate_daytodmy(LONG days,
                             int FAR* yrp, int FAR* monthp, int FAR* dayp);

LONG APIENTRY gdate_dmytoday(int yr, int month, int day);

/* number of days in given month (Jan===1) in given year (e.g. 1993) */
int APIENTRY gdate_monthdays(int month, int year);

/* daynr is our standard LONG day number.  Returns day of the week.
   Weekdays are numbered from 0 to 6, Sunday==0
*/
int APIENTRY gdate_weekday(long daynr);


/* --- status line window class ---------------------------------- */
/* The status line is a bar across the top or bottom of the window.
 * It can hold a number of fields which can be either static text
 * or buttons.  The so called "static" text can be changed at any time.
 * The fields can be left or right aligned (default is RIGHT).
 * If the text is marked as VAR then the screen real estate allocated
 * for it will be adjusted whenever the text changes.  VAR fields
 * can be given minimum or maximum sizes (but not both).
 *
 * STATIC text fields can be drawn as raised or lowered rectangles (using
 * shades of grey), or (default) without a border. BUTTON fields will
 * always be drawn as raised rectangles, and will lower when pressed.
 *
 * Button fields will send WM_COMMAND messages when clicked including the
 * field id and the WM_LBUTTONUP notification code. Note that that this
 * is not a full implementation of the button class, and no other messages
 * will be sent. In general, none of the fields of a status bar are
 * implemented as separate windows, so GetDlgItem() and similar calls will not
 * work. Buttons only respond to mouse down events, and there is no handling
 * of the focus or of keyboard events.
 *
 * To use:
 *    call StatusAlloc giving the number of items you are going to add to the
 *    status bar. This returns a handle to use in subsequent calls.
 *
 *    Then call StatusAddItem to define each item in turn.
 *    Buttons are placed in order of definition along the bar starting from
 *    the left (SF_LEFT) and from the right (SF_RIGHT) until the two
 *    sides meet.
 *
 *    Call StatusHeight to find the expected height of this status bar, and
 *    set its position within the parent window, then call StatusCreate to
 *    create the window.
 *
 * Having created the window, send SM_SETTEXT messages to set the new
 * text of a field (static or button), or SM_NEW with a handle (obtained from
 * StatusAlloc) to change the contents of the status line.
 */

/* values for type argument to StatusAddItem */
#define SF_BUTTON       1
#define SF_STATIC       2

/* bits in flags argument to StatusAddItem */
#define SF_RAISE        1       /* paint static as raised 3D rectangle */
#define SF_LOWER        2       /* paint static as lowered 3D rectangle */
#define SF_LEFT         4       /* align field on left of status bar */
#define SF_RIGHT        8       /* align field on right (DEFAULT) */
#define SF_VAR          0x10    /* size of field depends on actual text extent*/
#define SF_SZMAX        0x20    /* (with SF_VAR): width argument is maximum */
#define SF_SZMIN        0x40    /* (with SF_VAR) width arg is minimum size */

/* interfaces */
HWND APIENTRY StatusCreate(HANDLE hInst, HWND hParent, INT_PTR id,
                           LPRECT rcp, HANDLE hmem);

/* return the recommended height in device units of the given status bar */
int APIENTRY StatusHeight(HANDLE hmem);

/* alloc the status bar data structures and return handle*/
HANDLE APIENTRY StatusAlloc(int nitems);

/* set the attributes of a field.
 *
 * hmem obtained from StatusAlloc. itemnr must be less than the nitems
 * passed to StatusAlloc.
 *
 * the width argument is the width of the field in characters (average
 * character width).
 */
BOOL APIENTRY StatusAddItem(HANDLE hmem, int itemnr, int type, int flags,
                            int id, int width, LPSTR text);

/* send these window messages to the class */

#define SM_NEW          (WM_USER+1)     /* wParam handle for new status line */
#define SM_SETTEXT      (WM_USER+2)     /* wparam: item id, lparam new label*/

/* --- bit-map freelist management functions -------------------------------*/

/* init a pre-allocated array of longs to map nblks - set all to free
   you should allocate 1 DWORD in map for every 32 blocks of storage
   you wish to control.
*/
void APIENTRY gbit_init(DWORD FAR * map, long nblks);

/* mark a range of nblks starting at blknr to be busy */
BOOL APIENTRY gbit_alloc(DWORD FAR * map, long blknr, long nblks);

/* mark a range of nblks starting at blknr to be free */
BOOL APIENTRY gbit_free(DWORD FAR * map, long blknr, long nblks);

/* find a free section nblks long, or the biggest found in the map if all
 * are less than nblks long. returns size of region found as return value,
 * and sets blknr to the starting blk of region. Region is *not* marked
 * busy
 */
long APIENTRY gbit_findfree(DWORD FAR* map, long nblks,
                            long mapsize, long FAR * blknr);


/* ----- buffered line input ----------------------------------*/

/*
 * functions for reading a file, one line at a time, with some buffering
 * to make the operation reasonably efficient.
 *
 * call readfile_new to initialise the buffer and give it a handle to
 * an open file. Call readfile_next to get a pointer to the next line.
 * This discards the previous line and gives you a pointer to the line
 * IN THE BUFFER. Make your own copy before calling readfile_next again.
 *
 * call readfile_delete once you have finished with this file. That will close
 * the file and free up any memory.
 */

// MAX_LINE_LENGTH is the max number of physical characters we allow in a line
#define MAX_LINE_LENGTH         (4096)
// BUFFER_SIZE is expressed in bytes, and is large enough to read in
// MAX_LINE_LENGTH wide chars, and also hold MAX_LINE_LENGTH 5-byte hex code
// representations of the chars.
#define BUFFER_SIZE             (MAX_LINE_LENGTH * 5)

/* handle to a file buffer */
typedef struct filebuffer FAR * FILEBUFFER;

/* initialise the buffering for an open file */
FILEBUFFER APIENTRY readfile_new(HANDLE fh, BOOL *pfUnicode);

/* return a pointer to the next line in this file. line must be shorter than
 * buffer size (currently 1024 bytes). Line is not null-terminated: *plen
 * is set to the length of the line including the \n. This call will
 * discard any previous line, so ensure that you have made a copy of one line
 * before you call readfile_next again.
 * MUST CALL readfile_setdelims FIRST!
 */
LPSTR APIENTRY readfile_next(FILEBUFFER fb, int FAR * plen, LPWSTR *ppwz, int *pcwch);

/* set the delimiters to use to break lines.  MUST call this to initialise */
void APIENTRY readfile_setdelims(LPBYTE str);

/*
 * close the file and discard any associated memory and buffers.
 */
void APIENTRY readfile_delete(FILEBUFFER fb);


/* ------ hashing and checksums ------------------------------------------- */

/*
 * generate a 32-bit hash code for a null-terminated string of ascii text.
 *
 * if bIgnoreBlanks is TRUE, we ignore spaces and tabs during the
 * hashcode calculation.
 */

/* hash codes are unsigned longs */

DWORD APIENTRY hash_string(LPSTR string, BOOL bIgnoreBlanks);
void Format(char * a, char * b);

/* return TRUE iff the string is blank.  Blank means the same as
 * the characters which are ignored in hash_string when ignore_blanks is set
 */
BOOL APIENTRY utils_isblank(LPSTR string);

/*
 * Compare two pathnames, and if not equal, decide which should come first.
 *
 * returns 0 if the same, -1 if left is first, and +1 if right is first.
 *
 * The comparison is such that all filenames in a directory come before any
 * file in a subdirectory of that directory.
 *
 * To make absolutely certain that you get a canonical sorting, use AnsiLowerBuff
 * to convert BOTH to lower case first.  You may get a funny effect if one one
 * has been converted to lower case and the other not.
 */
int APIENTRY
utils_CompPath(LPSTR left, LPSTR right);
/* given an open file handle open for reading, read the file and
 * generate a 32-bit checksum for the file
 */

/* checksums are unsigned longs */
typedef DWORD CHECKSUM;

/* Open a file, checksum it and close it again. err !=0 iff it failed. */
CHECKSUM APIENTRY checksum_file(LPCSTR fn, LONG FAR * err);


/* --- error message output ----------------------------------------------*/

/*
 * reports error in a dialog, returns TRUE for ok, FALSE for cancel.
 * if fCancel is FALSE, only the OK button is shown, otherwise both ok
 * and cancel. hwnd is the parent window for the dlg. can be null.
 */
BOOL APIENTRY Trace_Error(HWND hwnd, LPSTR msg, BOOL fCancel);

/* Write popups to a file until further notice */
void Trace_Unattended(BOOL bUnattended);

/* --- create/write to trace file ----------------------------------------*/

void APIENTRY Trace_File(LPSTR msg);

/* --- close trace file --------------------------------------------------*/
void APIENTRY Trace_Close(void);

/* --- simple input ------------------------------------------------------*/

/*
 * input of a single text string, using a simple dialog.
 *
 * returns TRUE if ok, or FALSE if error or user canceled. If TRUE,
 * puts the string entered into result (up to resultsize characters).
 *
 *
 * prompt is used as the prompt string, caption as the dialog caption and
 * def_input as the default input. All of these can be null.
 */

int APIENTRY StringInput(LPSTR result, int resultsize, LPSTR prompt,
                         LPSTR caption, LPSTR def_input);



/* --- sockets -----------------------------------------------------------*/

#ifdef SOCKETS

    #include <winsock.h>

BOOL SocketConnect( LPSTR pstrServerName, u_short TCPPort, SOCKET *pSocket );
BOOL SocketListen( u_short TCPPort, SOCKET *pSocket );

#endif

// These are for both WINDIFF.EXE and GUTILS.DLL.
//#define strchr          My_mbschr
//#define strncpy         My_mbsncpy
PUCHAR My_mbspbrk(PUCHAR, PUCHAR);
LPSTR My_mbschr(LPCSTR, unsigned short);
LPSTR My_mbsncpy(LPSTR, LPCSTR, size_t);

// These are for WINDIFF.EXE.
//#define strrchr         My_mbsrchr
//#define strncmp         My_mbsncmp
LPSTR My_mbsrchr(LPCSTR, unsigned short);
int My_mbsncmp(LPCSTR, LPCSTR, size_t);
LPTSTR APIENTRY LoadRcString(UINT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\status.c ===
/*
 * status line handler
 *
 */

/*---includes-----------------------------------------------------------*/
#include "windows.h"
#include "string.h"
#include "gutils.h"


/* --- data structures ------------------------------------------------- */

#define SF_MAXLABEL     80   /* no more than 80 in an item within the bar */
/* Is this adequate for long pathnames on a
   hi-res screen?
*/

typedef struct statel {
    int type;                       /* SF_BUTTON or SF_STATIC */
    int flags;                      /* SF_VAR => variable width
                                       SF_LEFT=> left aligned (else right)
                                       SF_RAISE=> paint as 'raised' 3d rect
                                       SF_LOWER=> paint as lowered 3D rect
                                       SF_SZMIN=>together with SF_VAR
                                                 allows minimum size for
                                                 var sized item
                                       SF_SZMAX=>see SZMIN and use nouse
                                    */
    int id;                         /* control id */
    int width;                      /* width of control in chars */
    char text[SF_MAXLABEL+1];       /* null-term string for label */

    RECT rc;                        /* used by status.c */
} STATEL, * PSTATEL;

typedef struct itemlist {
    int nitems;
    PSTATEL statels;

    int selitem;                    /* used by status.c */
    BOOL isselected;                /* used by status.c */
} ILIST, * PILIST;

/* ------------------------------------------------------------------*/


/* prototypes of routines in this module */

void StatusCreateTools(void);
void StatusDeleteTools(void);
INT_PTR APIENTRY StatusWndProc(HWND, UINT, WPARAM, LPARAM);
void StatusResize(HWND hWnd, PILIST pilist);
int StatusCalcHeight(HWND hWnd, PSTATEL ip);
int StatusCalcWidth(HWND hWnd, PSTATEL ip);
PSTATEL StatusGetItem(PILIST plist, int id);
void LowerRect(HDC hDC, LPRECT rcp);
void RaiseRect(HDC hDC, LPRECT rcp);
void StatusPaint(HWND hWnd, PILIST iplistp);
void BottomRight(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners);
void TopLeft(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners);
void StatusButtonDown(HDC hDC, PSTATEL ip);
void StatusButtonUp(HDC hDC, PSTATEL ip);
void InitDC(HDC hdc);


/*--global data---------------------------------------------------------*/

HPEN hpenHilight, hpenLowlight;
HPEN hpenBlack, hpenNeutral;
HBRUSH hbrBackground; /* pieces and board */
HFONT hFont;
int status_charheight, status_charwidth;

/* default pt size for font (tenths of a pt) */
#define         DEF_PTSIZE      80
/*-public functions----------------------------------------------------------*/

/* StatusInit
 *
 * - create window class
 */
BOOL
StatusInit(
           HANDLE hInstance
           )
{
    WNDCLASS    wc;
    BOOL resp;
    TEXTMETRIC tm = {0};
    HDC hDC;


    StatusCreateTools();

    wc.style = CS_HREDRAW|CS_VREDRAW|CS_GLOBALCLASS;
    wc.lpfnWndProc = StatusWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(HANDLE);
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = hbrBackground;
    wc.lpszClassName = (LPSTR) "gdstatusclass";
    wc.lpszMenuName = NULL;

    resp = RegisterClass(&wc);

    hDC = GetDC(NULL);
    if (hDC)
    {
        InitDC(hDC);
        GetTextMetrics(hDC, &tm);
        ReleaseDC(NULL, hDC);
    }
    else
    {
        // arbitrary, whatever...
        tm.tmHeight = 14;
        tm.tmAveCharWidth = 5;
    }
    status_charheight = (int)(tm.tmHeight + tm.tmExternalLeading);
    status_charwidth = (int)tm.tmAveCharWidth;

    return(resp);
}

/*
 * create and show the window
 */
HWND APIENTRY
StatusCreate(
             HANDLE hInst,
             HWND hParent,
             INT_PTR id,
             LPRECT rcp,
             HANDLE hmem
             )
{

    HWND hWnd;

    /* create a child window of status class */


    hWnd = CreateWindow("gdstatusclass",
                        NULL,
                        WS_CHILD | WS_VISIBLE,
                        rcp->left,
                        rcp->top,
                        (rcp->right - rcp->left),
                        (rcp->bottom - rcp->top),
                        hParent,
                        (HANDLE) id,
                        hInst,
                        (LPVOID) hmem);

    return(hWnd);
}

/* return default height of this window */
int APIENTRY
StatusHeight(
             HANDLE hmem
             )
/* The window has a number of items which are arranged horizontally,
   so the window height is the maximum of the individual heights
*/
{
    PILIST plist;
    int i;
    int sz;
    int maxsize = 0;

    plist = (PILIST) GlobalLock(hmem);
    if (plist != NULL) {
        for (i = 0; i<plist->nitems; i++) {
            sz = StatusCalcHeight(NULL, &plist->statels[i]);
            maxsize = max(sz, maxsize);
        }
    }
    GlobalUnlock(hmem);
    if (maxsize > 0) {
        return(maxsize + 4);
    } else {
        return(status_charheight + 4);
    }
}

/* alloc the plist struct and return handle to caller */
HANDLE
StatusAlloc(
            int nitems
            )
{
    HANDLE hmem;
    PILIST pilist;
    LPSTR chp;

    hmem = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                       sizeof(ILIST) + (sizeof(STATEL) * nitems));
    chp = GlobalLock(hmem);
    if (chp == NULL) {
        return(NULL);
    }

    pilist = (PILIST) chp;
    pilist->nitems = nitems;
    pilist->statels = (PSTATEL) &chp[sizeof(ILIST)];
    GlobalUnlock(hmem);

    return(hmem);
}


/* insert an item into the plist */
BOOL
StatusAddItem(
              HANDLE hmem,
              int itemnr,
              int type,
              int flags,
              int id,
              int width,
              LPSTR text
              )
{
    PILIST pilist;
    PSTATEL pel;

    pilist = (PILIST) GlobalLock(hmem);
    if ((pilist == NULL) || (itemnr >= pilist->nitems)) {
        GlobalUnlock(hmem);
        return(FALSE);
    }
    pel = &pilist->statels[itemnr];
    pel->type = type;
    pel->flags = flags;
    pel->id = id;
    pel->width = width;
    if (text == NULL) {
        pel->text[0] = '\0';
    } else {
        lstrcpy(pel->text, text);
    }


    GlobalUnlock(hmem);
    return(TRUE);
}

/* ---- internal functions ------------------------------------------*/

void
InitDC(HDC hdc)
{
    SetBkColor(hdc, RGB(192,192,192));
    SelectObject(hdc, hbrBackground);
    SelectObject(hdc, hFont);
}


void
StatusCreateTools()
{
    LOGFONT lf;
    HDC hdc;
    int scale;

    hbrBackground = CreateSolidBrush(RGB(192,192,192));
    hpenHilight = CreatePen(0, 1, RGB(255, 255, 255));
    hpenLowlight = CreatePen(0, 1, RGB(128, 128, 128));
    hpenNeutral = CreatePen(0, 1, RGB(192, 192, 192));
    hpenBlack = CreatePen(0, 1, RGB(0, 0, 0));

    hdc = GetDC(NULL);
    if (hdc)
    {
        scale = GetDeviceCaps(hdc, LOGPIXELSY);
        ReleaseDC(NULL, hdc);
    }
    else
    {
        // arbitrary, whatever...
        scale = 72;
    }

    lf.lfHeight = -MulDiv(DEF_PTSIZE, scale, 720);
    lf.lfWidth = 0;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfWeight = FW_REGULAR;
    lf.lfItalic = 0;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
    lf.lfFaceName[0] = '\0';
#ifdef COMPLEX
    hFont = CreateFontIndirect(&lf);
#else
    hFont = GetStockObject(SYSTEM_FONT);
#endif



}

void
StatusDeleteTools()
{
    DeleteObject(hbrBackground);
    DeleteObject(hpenHilight);
    DeleteObject(hpenLowlight);
    DeleteObject(hpenBlack);
    DeleteObject(hpenNeutral);

#ifdef COMPLEX
    DeleteObject(hFont);
#endif
}

/* Main winproc for status windows
 *
 * handles create/destroy and paint requests
 */

INT_PTR
StatusWndProc(
              HWND hWnd,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
    HANDLE hitems;
    PSTATEL ip;
    PILIST plist;
    CREATESTRUCT * cp;
    int i;
    HDC hDC;
    RECT rc;
    POINT pt;

    switch (message) {

        case WM_CREATE:
            cp = (CREATESTRUCT *) lParam;
            hitems = (HANDLE) cp->lpCreateParams;
            SetWindowLongPtr(hWnd, 0,  (LONG_PTR)hitems);
            plist = (PILIST) GlobalLock(hitems);
            if (plist != NULL) {
                plist->selitem = -1;
                GlobalUnlock(hitems);
            }
            break;

        case WM_SIZE:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            if (plist != NULL) {
                StatusResize(hWnd, plist);
                GlobalUnlock(hitems);
            }
            break;

        case WM_PAINT:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            StatusPaint(hWnd, plist);
            GlobalUnlock(hitems);

            break;

        case WM_LBUTTONUP:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);

            if (plist == NULL) {
                break;
            }
            if (plist->selitem != -1) {
                ip = &plist->statels[plist->selitem];
                if (plist->isselected) {
                    hDC = GetDC(hWnd);
                    if (hDC)
                    {
                        InitDC(hDC);
                        StatusButtonUp(hDC, ip);
                        ReleaseDC(hWnd, hDC);
                    }
                }
                plist->selitem = -1;
                ReleaseCapture();
                if (PtInRect(&ip->rc, pt)) {
                    SendMessage(GetParent(hWnd), WM_COMMAND, MAKELONG(ip->id, WM_LBUTTONUP), (LPARAM)hWnd);
                }
            }
            GlobalUnlock(hitems);
            break;

        case WM_LBUTTONDOWN:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            if (plist == NULL) {
                break;
            }
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            if (plist->selitem == -1) {
                for (i = 0; i< plist->nitems; i++) {
                    ip = &plist->statels[i];
                    if (PtInRect(&ip->rc, pt)) {
                        if (ip->type != SF_BUTTON) {
                            break;
                        }
                        plist->selitem = i;
                        SetCapture(hWnd);

                        plist->isselected = TRUE;
                        hDC = GetDC(hWnd);
                        if (hDC)
                        {
                            InitDC(hDC);
                            StatusButtonDown(hDC, ip);
                            ReleaseDC(hWnd, hDC);
                        }
                        break;
                    }
                }
            }
            GlobalUnlock(hitems);
            break;

        case WM_MOUSEMOVE:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            if (plist == NULL) {
                break;
            }
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            if (plist->selitem != -1) {
                ip = &plist->statels[plist->selitem];
                if (PtInRect(&ip->rc, pt)) {
                    if (!plist->isselected) {
                        hDC = GetDC(hWnd);
                        if (hDC)
                        {
                            InitDC(hDC);
                            StatusButtonDown(hDC, ip);
                            ReleaseDC(hWnd, hDC);
                        }
                        plist->isselected = TRUE;
                    }
                } else {
                    if (plist->isselected) {
                        hDC = GetDC(hWnd);
                        if (hDC)
                        {
                            InitDC(hDC);
                            StatusButtonUp(hDC, ip);
                            ReleaseDC(hWnd, hDC);
                        }
                        plist->isselected = FALSE;
                    }
                }
            }
            GlobalUnlock(hitems);
            break;


        case WM_DESTROY:

            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            GlobalUnlock(hitems);
            GlobalFree(hitems);

            SetWindowLongPtr(hWnd, 0, 0);
            break;

        case SM_NEW:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            if (hitems != NULL) {
                GlobalFree(hitems);
            }
            hitems = (HANDLE) wParam;
            if (hitems == NULL) {
                SetWindowLongPtr(hWnd, 0, 0);
                InvalidateRect(hWnd, NULL, TRUE);
                break;
            }
            plist = (PILIST) GlobalLock(hitems);
            if (plist == NULL) {
                SetWindowLongPtr(hWnd, 0, 0);
                InvalidateRect(hWnd, NULL, TRUE);
                break;
            }
            plist->selitem = -1;
            StatusResize(hWnd, plist);
            GlobalUnlock(hitems);
            SetWindowLongPtr(hWnd, 0, (LONG_PTR)hitems);
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case SM_SETTEXT:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            if (hitems == NULL) {
                break;
            }
            plist = (PILIST) GlobalLock(hitems);
            ip = StatusGetItem(plist, (int)wParam);
            if (ip != NULL) {
                if (lParam == 0) {
                    ip->text[0] = '\0';
                } else {
                    My_mbsncpy(ip->text, (LPSTR) lParam, SF_MAXLABEL);
                    ip->text[SF_MAXLABEL] = '\0';
                }

                /* if this is a variable width field, we need to redo
                 * all size calcs in case the field width has changed.
                 * in that case, we need to repaint the entire window
                 * and not just this field - so set rc to indicate the
                 * area to be redrawn.
                 */
                if (ip->flags & SF_VAR) {
                    StatusResize(hWnd, plist);
                    GetClientRect(hWnd, &rc);
                    RedrawWindow(hWnd, &rc, NULL,
                                 RDW_INVALIDATE|RDW_ERASE|RDW_UPDATENOW);
                } else {
                    /* instead of just invalidating the window, we can
                     * force the window to be repainted now. This is
                     * essential for status updates during a busy
                     * loop when no messages are being processed,
                     * but we should still update the user on what's
                     * happening.
                     */
                    RedrawWindow(hWnd, &ip->rc, NULL,
                                 RDW_INVALIDATE|RDW_NOERASE|RDW_UPDATENOW);
                }

            }
            GlobalUnlock(hitems);
            break;

        default:
            return(DefWindowProc(hWnd, message, wParam, lParam));
    }
    return 0;
}

/*
 * position the labels and buttons within the status window */
void
StatusResize(HWND hWnd, PILIST iplistp)
{
    RECT rc;
    int curpos_right, curpos_left;
    int height, width;
    int i;
    PSTATEL ip;


    if (iplistp == NULL) {
        return;
    }
    GetClientRect(hWnd, &rc);
    curpos_left = rc.left + status_charwidth / 2;
    curpos_right = rc.right - (status_charwidth / 2);

    /* loop through all items setting their position rects.
     * items are flagged as being left or right. We place them
     * in order starting at the left and the right, with a single
     * char's width between each item
     */
    for (i = 0; i < iplistp->nitems; i++) {
        ip = &iplistp->statels[i];

        width = StatusCalcWidth(hWnd, ip);
        height = StatusCalcHeight(hWnd, ip);
        ip->rc.top = (rc.bottom - height) / 2;
        ip->rc.bottom = ip->rc.top + height;

        /* see if  this item fits. Items that partially fit
         * are placed reduced in size.
         */
        if (ip->flags & SF_LEFT) {

            if (curpos_left+width >= curpos_right) {
                /* doesn't completely fit-does it partly? */
                if ((curpos_left + 1) >= curpos_right) {

                    /* no - this item does not fit */
                    ip->rc.left = 0;
                    ip->rc.right = 0;
                } else {
                    /* partial fit */
                    ip->rc.left = curpos_left;
                    ip->rc.right = curpos_right - 1;
                    curpos_left = curpos_right;
                }
            } else {
                /* complete fit */
                ip->rc.left = curpos_left;
                ip->rc.right = curpos_left + width;
                curpos_left += width + 1;
            }
        } else {

            /* same size check for right-aligned items */
            if (curpos_right-width <= curpos_left) {

                /* partial fit ? */
                if (curpos_right <= curpos_left+1) {
                    ip->rc.left = 0;
                    ip->rc.right = 0;
                } else {
                    /* yes - partial fit */
                    ip->rc.left = curpos_left + 1;
                    ip->rc.right = curpos_right;
                    curpos_right = curpos_left;
                }
            } else {
                /* complete fit */
                ip->rc.right = curpos_right;
                ip->rc.left = curpos_right - width;
                curpos_right -= (width + 1);
            }
        }
    }
}


void
StatusPaint(HWND hWnd, PILIST iplistp)
{
    RECT rc;
    HDC hDC;
    PAINTSTRUCT ps;
    int i;
    PSTATEL ip;
    HPEN hpenOld;

    GetClientRect(hWnd, &rc);
    hDC = BeginPaint(hWnd, &ps);
    InitDC(hDC);

    RaiseRect(hDC, &rc);
    if (iplistp == NULL) {
        EndPaint(hWnd, &ps);
        return;
    }
    for (i =0; i < iplistp->nitems; i++) {
        ip = &iplistp->statels[i];

        if (ip->rc.left == ip->rc.right) {
            continue;
        }
        if (ip->type == SF_STATIC) {
            if (ip->flags & SF_RAISE) {
                RaiseRect(hDC, &ip->rc);
            } else if (ip->flags & SF_LOWER) {
                LowerRect(hDC, &ip->rc);
            }
            rc = ip->rc;
            rc.left += (status_charwidth / 2);
            rc.right--;
            rc.top++;
            rc.bottom--;
            hpenOld = SelectObject(hDC, hpenNeutral);
            Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
            SelectObject(hDC, hpenOld);
            DrawText(hDC, ip->text, lstrlen(ip->text), &rc,
                     DT_LEFT | DT_VCENTER);
        } else {
            StatusButtonUp(hDC, ip);
        }
    }

    EndPaint(hWnd, &ps);
}

void
RaiseRect(HDC hDC, LPRECT rcp)
{
    TopLeft(hDC, rcp, hpenHilight, FALSE);
    BottomRight(hDC, rcp, hpenLowlight, FALSE);
}

void
LowerRect(HDC hDC, LPRECT rcp)
{
    TopLeft(hDC, rcp, hpenLowlight, FALSE);
    BottomRight(hDC, rcp, hpenHilight, FALSE);
}

void
StatusButtonUp(HDC hDC, PSTATEL ip)
{
    RECT rc;
    HPEN hpenOld;
    TEXTMETRIC tm;

    rc = ip->rc;
    TopLeft(hDC, &rc, hpenBlack, TRUE);
    BottomRight(hDC, &rc, hpenBlack, FALSE);

    rc.top++;
    rc.bottom--;
    rc.left++;
    rc.right--;
    TopLeft(hDC, &rc, hpenHilight, FALSE);
    BottomRight(hDC, &rc, hpenLowlight, TRUE);

    rc.top++;
    rc.bottom--;
    rc.left++;
    rc.right--;
    BottomRight(hDC, &rc, hpenLowlight, TRUE);
    rc.bottom--;
    rc.right--;
    hpenOld = SelectObject(hDC, hpenNeutral);
    Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
    SelectObject(hDC, hpenOld);
    GetTextMetrics(hDC, &tm);
    rc.top += tm.tmExternalLeading;
    DrawText(hDC, ip->text, lstrlen(ip->text), &rc, DT_CENTER | DT_VCENTER);
}

void
StatusButtonDown(HDC hDC, PSTATEL ip)
{
    RECT rc;
    HPEN hpenOld;
    TEXTMETRIC tm;

    rc = ip->rc;
    TopLeft(hDC, &rc, hpenBlack, TRUE);
    BottomRight(hDC, &rc, hpenBlack, FALSE);

    rc.top++;
    rc.bottom--;
    rc.left++;
    rc.right--;
    TopLeft(hDC, &rc, hpenLowlight, TRUE);
    rc.top++;
    rc.left++;
    TopLeft(hDC, &rc, hpenNeutral, TRUE);
    rc.top++;
    rc.left++;
    TopLeft(hDC, &rc, hpenNeutral, TRUE);
    rc.top++;
    rc.left++;
    hpenOld = SelectObject(hDC, hpenNeutral);
    Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
    SelectObject(hDC, hpenOld);
    GetTextMetrics(hDC, &tm);
    rc.top += tm.tmExternalLeading;
    DrawText(hDC, ip->text, lstrlen(ip->text), &rc, DT_CENTER | DT_VCENTER);
}

void
TopLeft(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners)
{
    HPEN hpenOld;
    int x, y;

    hpenOld = SelectObject(hDC, hpen);
    x = rcp->right - 1;
    y = rcp->bottom;
    if (!bCorners) {
        x--;
        y--;
    }
    MoveToEx(hDC, x, rcp->top, NULL);
    LineTo(hDC, rcp->left, rcp->top);
    LineTo(hDC, rcp->left, y);
    SelectObject(hDC, hpenOld);
}

void
BottomRight(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners)
{
    HPEN hpenOld;
    int x, y;

    hpenOld = SelectObject(hDC, hpen);
    x = rcp->left - 1;
    y = rcp->top;
    if (!bCorners) {
        x++;
        y++;
    }
    MoveToEx(hDC, rcp->right-1, y, NULL);
    LineTo(hDC, rcp->right-1, rcp->bottom-1);
    LineTo(hDC, x, rcp->bottom-1);
    SelectObject(hDC, hpenOld);
}


PSTATEL
StatusGetItem(PILIST plist, int id)
{
    int i;

    if (plist == NULL) {
        return(NULL);
    }
    for (i = 0; i < plist->nitems; i++) {
        if (plist->statels[i].id == id) {
            return(&plist->statels[i]);
        }
    }
    return(NULL);
}

/*
 * calculate the width of a given field. This is the width in characters
 * multiplied by the average character width, plus a few units for
 * borders.
 *
 * if SF_VAR is set, this field size varies depending on the text, so
 * we use GetTextExtent for the field size. If SF_VAR is selected, the caller
 * can specify that the size is not to exceed the (width * avecharwidth)
 * size (using SF_SZMAX) or that it is not be less than it (SF_SZMIN).
 */
int
StatusCalcWidth(HWND hWnd, PSTATEL ip)
{
    int ch_size, t_size;
    SIZE sz = {0};
    HDC hDC;

    ch_size = ip->width * status_charwidth;
    if (ip->flags & SF_VAR) {
        hDC = GetDC(hWnd);
        if (hDC)
        {
            InitDC(hDC);
            GetTextExtentPoint(hDC, ip->text, lstrlen(ip->text), &sz);
            ReleaseDC(hWnd, hDC);
        }
        t_size = sz.cx;

        /*
         * check this size against min/max size if
         * requested
         */

        if (ip->flags & SF_SZMIN) {
            if (ch_size > t_size) {
                t_size = ch_size;
            }
        }
        if (ip->flags & SF_SZMAX) {
            if (ch_size < t_size) {
                t_size = ch_size;
            }
        }
        ch_size = t_size;
    }

    if (ch_size != 0) {
        if (ip->type == SF_BUTTON) {
            return(ch_size+6);
        } else {
            return(ch_size+4);
        }
    } else {
        return(0);
    }
}

int
StatusCalcHeight(HWND hWnd, PSTATEL ip)
{
    int size;

    size = status_charheight;
    if (ip->type == SF_BUTTON) {
        return(size + 6);
    } else {
        return(size + 2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\list.h ===
/*----------------------
                   |         List          |
                    ----------------------*/
/* Laurie Griffiths, C version  5/12/91                                */
/* worth also looking at nt\public\sdk\inc\ntrtl.h which also has some
|  low level list pointer chaining stuff in it
*/
/* Note here that Modula-2 style comments (*like this*) are used
   within examples which are already within C comments to indicate
   where comments should go in the examples
*/

/*------------------------------------------------------------------------
| Abstract data type LIST OF (*untyped*) object.
| Different lists can have different types of object in them
| Different items in a list can have different types of object in them.
| The price of this lack of typing is that you have a slightly more
| awkward syntax and you get no help from the compiler if you try to
| put the wrong type of data into the list.
|
| The list is implemented as a collection of items.  Within the item
| somewhere is the object.
|
| Objects are stored UNALIGNED within items.
|
| Use:
|
|   #include <list.h>
|   . . .
|   LIST MyList; (* or LIST liMyList for Hungarians *)
|   . . .
|   MyList = List_Create();
|   List_AddLast(MyList,&MyObject,sizeof(OBJECT));
|
| In the abstract a LIST is a list of objects.  The representation
| is a linked collection of items.  The manner of the linking is
| implementation dependent (as I write this it's linear but when you
| read it it might be a tree (See Knuth for why a tree)).
|
| A LIST is a "handle" for a list which may be thought of as a POINTER
| (whether it is really a pointer or not is implementation dependent)
| so that it can be copied at the risk of creating an alias. e.g.
|
|   L = List_Create();
|   L1 = L;             (* L and L1 are both healthy and empty *)
|   List_AddFirst(L, &elem, sizeof(elem));
|   (* L1 may also appear to have one object, there again it may be sick *)
|   L1 = L;               (* Now they both surely see the one element *)
|   List_Destroy(&L1);    (* L is almost certainly sick now too *)
|   L1 = List_Create();   (* All bets off as to what L is like now
|                            but L1 is empty and healthy
|                         *)
|
| If two handles compare equal then the lists must be equal, but
| unequal handles could address two similar lists i.e. the same list
| of objects held in two different LISTs of items (like pointers).
|
| A LIST can be transferred from one variable to another like this:
|
|   NewList = OldList;           (* copy the handle *)
|   OldList = List_Create();     (* kill the old alias *)
|
| and the Create statement can be omitted if OldList is never touched again.
|
| Items are identified by Cursors.  A cursor is the address of an object
| within an item in the list. i.e. it is the address of the piece of your
| data that you had inserted.  (It is probably NOT the address of the item).
| It is typed as pointer to void here, but you should declare it as a pointer
| to whatever sort of object you are putting in the LIST.
|
| The operations AddFirst, AddLast, AddAfter and AddBefore
| all copy elements by direct assignment.  If an element is itself
| a complex structure (say a tree) then this will only copy a pointer
| or an anchor block or whatever and give all the usual problems of
| aliases.  Clear will make the list empty, but will only free the
| storage that it can "see" directly.  SplitBefore or Split After may
| also perform a Clear operation.  To deal with fancy data structures
| use New rather than Add calls and copy the data yourself
|   e.g.  P = List_NewLast(MyList, sizeof(MyArray[14])*(23-14+1));
|         CopyArraySlice(P, MyArray, 14, 23);
|
| The operations NewFirst, NewLast, NewAfter, NewBefore, First and Last
| all return pointers to elements and thus allow you to do any copying.
| This is how you might copy a whole list of fancy structures:
|
|    void CopyFancyList(LIST * To, LIST From)
|             (* Assumes that To has been Created and is empty *)
|    { PELEMENT Cursor;
|      PELEMENT P;
|
|      List_TRAVERSE(From, Cursor);
|      { P = List_NewLast(To, sizeof(element) );
|        FancyCopy(P, Cursor);    (* Copy so that *Cursor==*P afterwords *)
|      }
|    }
 --------------------------------------------------------------------*/

  typedef struct item_tag FAR * LIST;
  typedef LIST FAR * PLIST;

  void APIENTRY List_Init(void);
  /* MUST BE CALLED BEFORE ANY OF THE OTHER FUNCTIONS. Don't ask, just do it */

  void APIENTRY List_Term(void);
  /* Call at end of application (does some checking and resource freeing) */

  void APIENTRY List_Dump(LPSTR Header, LIST lst);
  /* Dump the internals to current output stream -- debug only */

  void APIENTRY List_Show(LIST lst);
  /* Dump hex representation of handle to current out stream -- debug only */

  LIST APIENTRY List_Create(void);
  /* Create a list.  It will be initially empty */

  void APIENTRY List_Destroy(PLIST plst);
  /* Destroy *plst.  It does not need to be empty first.
  |  All storage directly in the list wil be freed.
  */

  void APIENTRY List_AddFirst(LIST lst, LPVOID pObject, UINT uLen);
  /* Add an item holding Object to the beginning of * plst */

  LPVOID APIENTRY List_NewFirst(LIST lst, UINT uLen);
  /* Return the address of the place for Len bytes of data in a new
  |  item at the start of *plst.
  |  The storage is zeroed BEFORE chaining it in.
  */

  void APIENTRY List_DeleteFirst(LIST lst);
  /* Delete the first item in lst.  Error if lst is empty */

  void APIENTRY List_AddLast(LIST lst, LPVOID pObject, UINT uLen);
  /* Add an item holding Object to the end of lst */

  LPVOID APIENTRY List_NewLast(LIST lst, UINT uLen);
  /* Return the address of the place for uLen bytes of data in a new
  |  item at the end of lst
  |  The storage is zeroed BEFORE chaining it in.
  */

  void APIENTRY List_DeleteLast(LIST lst);
  /* Delete the last item in lst.  Error if lst is empty */

  void APIENTRY List_AddAfter( LIST lst
                    , LPVOID Curs
                    , LPVOID pObject
                    , UINT uLen
                    );
  /*--------------------------------------------------------------------
  | Add an item holding *pObject to lst immediately after Curs.
  | List_AddAfter(lst, NULL, pObject, Len) adds it to the start of the lst
   ---------------------------------------------------------------------*/

  LPVOID APIENTRY List_NewAfter(LIST lst, LPVOID Curs, UINT uLen);
  /*--------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  | item immediately after Curs.
  | List_NewAfter(Lst, NULL, uLen) returns a pointer
  | to space for uLen bytes in a new first element.
  | The storage is zeroed BEFORE chaining it in.
   ---------------------------------------------------------------------*/

  void APIENTRY List_AddBefore( LIST lst
                     , LPVOID Curs
                     , LPVOID pObject
                     , UINT uLen
                     );
  /*--------------------------------------------------------------------
  | Add an item holding Object to lst immediately before Curs.
  | List_AddBefore(Lst, NULL, Object, uLen) adds it to the end of the list
   ---------------------------------------------------------------------*/

  LPVOID APIENTRY List_NewBefore(LIST lst, LPVOID Curs, UINT uLen );
  /*--------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  | item immediately before Curs.
  | List_NewBefore(Lst, NULL, uLen) returns a pointer
  | to space for uLen bytes in a new last element.
  | The storage is zeroed BEFORE chaining it in.
   ---------------------------------------------------------------------*/

#if 0
// these functions are not actually defined...

  void APIENTRY List_DeleteAndNext(LPVOID * pCurs);
  /* Delete the item that *pCurs identifies and move *pCurs to the Next item */

  void APIENTRY List_DeleteAndPrev(LPVOID * pCurs);
  /* Delete the item that *pCurs identifies and move *pCurs to the Prev item */
#endif

  void APIENTRY List_Delete(LPVOID Curs);
  /*------------------------------------------------------------------
  | Delete the item that Curs identifies.
  | I'm not too sure about this:
  | This will be only a few (maybe as little as 3) machine instructions
  | quicker than DeleteAndNext or DeleteAndPrev but leaves Curs dangling.
  | It is therefore NOT usually to be preferred.
  | It may be useful when you have a function which returns an LPVOID
  | since the argument does not need to be a variable.
  |     Trivial example: List_Delete(List_First(L));
  | I am not sure which is more damaging, a dangling pointer which points
  | at garbage or one that points at something that is real live data.
   -------------------------------------------------------------------*/

  int APIENTRY List_ItemLength(LPVOID Curs);
  /* Return the length of the object identified by the cursor Curs */

  /*------------------------------------------------------------------
  | TRAVERSING THE ULIST
  |
  | LIST lst;
  | object * Curs;
  | . . .
  | Curs = List_First(lst);
  | while (Curs!=NULL)
  | {  DoSomething(*Curs);   (* Curs points to YOUR data not to chain ptrs *)
  |    Curs = List_Next(Curs);
  | }
  |
  | This is identically equal to
  | List_TRAVERSE(lst, Curs)  // note NO SEMI COLON!
  | {  DoSomething(*Curs); }
   -------------------------------------------------------------------*/

  #define List_TRAVERSE(lst, curs)  for(  curs=List_First(lst)            \
                                       ;  curs!=NULL                      \
                                       ;  curs = List_Next((LPVOID)curs)  \
                                       )
  #define List_REVERSETRAVERSE(lst, curs)  for(  curs=List_Last(lst)             \
                                              ;  curs!=NULL                      \
                                              ;  curs = List_Prev((LPVOID)curs)  \
                                              )

  LPVOID APIENTRY List_First(LIST lst);
  /*------------------------------------------------------------------
  | Return the address of the first object in lst
  |  If lst is empty then Return NULL.
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Last(LIST lst);
  /*------------------------------------------------------------------
  | Return the address of the last object in lst
  | If lst is empty then return NULL.
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Next(LPVOID Curs);
  /*------------------------------------------------------------------
  | Return the address of the object after Curs^.
  | List_Next(List_Last(lst)) == NULL;  List_Next(NULL) is an error.
  | List_Next(List_Prev(curs)) is illegal if curs identifies first el
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Prev(LPVOID Curs);
  /*------------------------------------------------------------------
  | Return the address of the object after Curs^.
  | List_Prev(List_First(L)) == NULL;  List_Prev(NULL) is an error.
  | List_Prev(List_Next(curs)) is illegal if curs identifies last el
  --------------------------------------------------------------------*/

  /*------------------------------------------------------------------
  |  Whole list operations
   -----------------------------------------------------------------*/
  void APIENTRY List_Clear(LIST lst);
  /* arrange that lst is empty after this */

  BOOL APIENTRY List_IsEmpty(LIST lst);
  /* Return TRUE if and only if lst is empty */

  void APIENTRY List_Join(LIST l1, LIST l2);
  /*-----------------------------------------------------------------------
  | l1 := l1||l2; l2 := empty
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets all the elements of l1 in their original order followed by
  | all the elements of l2 in the order they were in in l2.
  | l2 becomes empty.
   ------------------------------------------------------------------------*/

  void APIENTRY List_InsertListAfter(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | l1 := l1[...Curs] || l2 || l1[Curs+1...]; l2 := empty
  | Curs=NULL means insert l2 at the start of l1
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets the elements of l1 from the start up to and including the element
  | that Curs points at, in their original order,
  | followed by all the elements that were in l2, in their original order,
  | followed by the rest of l1
   ------------------------------------------------------------------------*/

  void APIENTRY List_InsertListBefore(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | l1 := l1[...Curs-1] || l2 || l1[Curs...]; l2 := empty
  | Curs=NULL means insert l2 at the end of l1
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets the elements of l1 from the start up to but not including the
  | element that Curs points at, in their original order,
  | followed by all the elements that were in l2, in their original order,
  | followed by the rest of l1.
   ------------------------------------------------------------------------*/

  void APIENTRY List_SplitAfter(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | Let l1 be l1 and l2 be l2
  | Split l2 off from the front of l1:    final l2,l1 = original l1
  |
  | Split l1 into l2: objects of l1 up to and including Curs object
  |               l1: objects of l1 after Curs
  | Any original contents of l2 are freed.
  | List_Spilt(l1, l2, NULL) splits l1 before the first object so l1 gets all.
  | The elements themselves are not moved.
   ------------------------------------------------------------------------*/

  void APIENTRY List_SplitBefore(LIST l1, LIST l2, LPVOID Curs);
  /*----------------------------------------------------------------------
  | Split l2 off from the back of l1:  final l1,l2 = original l1
  |
  | Split l1 into l1: objects of l1 up to but not including Curs object
  |               l2: objects of l1 from Curs onwards
  | Any original contants of l2 are freed.
  | List_Spilt(l1, l2, NULL) splits l1 after the last object so l1 gets all.
  | The elements themselves are not moved.
   -----------------------------------------------------------------------*/

  int APIENTRY List_Card(LIST lst);
  /* Return the number of items in L */

  /*------------------------------------------------------------------
  | Error handling.
  |
  | Each list has within it a flag which indicates whether any illegal
  | operation has been detected (e.g. DeleteFirst when empty).
  | Rather than have a flag on every operation, there is a flag held
  | within the list that can be queried when convenient.  Many operations
  | do not have enough redundancy to allow any meaningful check.  This
  | is a design compromise (for instance to allow P = List_Next(P);
  | rather than P = List_Next(L, P); which is more awkward, especially
  | if L is actually a lengthy phrase).
  |
  | List_IsOK tests this flag (so is a very simple, quick operation).
  | MakeOK sets the flag to TRUE, in other words to accept the current
  | state of the list.
  |
  | It is possible for a list to be damaged (whether or not the flag
  | says OK) for instance by the storage being overwritten.
  |
  | List_Check attempts to verify that the list is sound (for instance where
  | there are both forward and backward pointers they should agree).
  |
  | List_Recover attempts to make a sound list out of whatever debris is left.
  | If the list is damaged, Recover may trap (e.g. address error) but
  | if the list was damaged then ANY operation on it may trap.
  | If Check succeeds without trapping then so will Recover.
   -----------------------------------------------------------------*/

  BOOL APIENTRY List_IsOK(LIST lst);
  /* Check return code */

  void APIENTRY List_MakeOK(LIST lst);
  /* Set return code to good */

  BOOL APIENTRY List_Check(LIST lst);
  /* Attempt to validate the chains */

  void APIENTRY List_Recover(PLIST plst);
  /* Desperate stuff.  Attempt to reconstruct something */

/*------------------------------------------------------------------
|  It is designed to be as easy to USE as possible, consistent
|  only with being an opaque type.
|
|  In particular, the decision to use the address of an object a list cursor
|  means that there is a small amount of extra arithmetic (in the
|  IMPLEMENTATION) in cursor operations (e.g. Next and Prev).
|  and spurious arguments are avoided whenever possible, even though
|  it would allow greater error checking.
|
| Of the "whole list" operations, Clear is given because it seems to be
| a common operation, even though the caller can implement it with almost
| the same efficiency as the List implementation module.
| Join, Split and InsertListXxx cannot be implemented efficiently without
| knowing the representation.
 --------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\sockets.c ===
/*************************************************************************************************\
 *
 * SOCKETS.C
 *
 * This file contains routines used for establishing Sockets connections.
 *
\*************************************************************************************************/


#include <windows.h>
#include <winsock.h>
#include <stdio.h>
#include <stdlib.h>
#include "gutils.h"


/* ---- Local variables and #defines ----
 */

WSADATA WSAData;


#define MAX_PENDING_CONNECTS 4  /* The backlog allowed for listen() */

static PCHAR DBG_WSAERRORTEXT = "%s failed at line %d in %s: Error %d\n";

#define WSAERROR(func)  \
//      ERROR(( DBG_WSAERRORTEXT, func, __LINE__, __FILE__, WSAGetLastError() ))



/* Error message macro:
 */
#ifdef SOCKETS
#undef SOCKETS
#endif
#define SOCKETS( args ) DBGMSG( DBG_SOCKETS, args )


/* ---- Local function prototypes ----
 */



/* ---- Function definitions ----
 */

/****************************************************************************\
*
*    FUNCTION:  FillAddr(HWND, PSOCKADDR_IN, LPSTR)
*
*    PURPOSE:  Retrieves the IP address and port number.
*
*    COMMENTS:
*        This function is called in two conditions.
*            1.) When a client is preparing to call connect(), or
*            2.) When a server host is going to call bind(), listen() and
*                accept().
*        In both situations, a SOCKADDR_IN structure is filled.
*        However, different fields are filled depending on the condition.
*
*   ASSUMPTION:
*      bConnect determines if the socket address is being set up for a listen()
*      (bConnect == TRUE) or a connect() (bConnect == FALSE)
*
*
*\***************************************************************************/
BOOL
FillAddr(
    HWND hWnd,
    PSOCKADDR_IN psin,
    LPSTR pServerName
    )
{
   DWORD dwSize;
   PHOSTENT phe;
   char szTemp[200];
   CHAR szBuff[80];

   psin->sin_family = AF_INET;

   /*
   **  If we are setting up for a listen() call (pServerName == NULL),
   **  fill servent with our address.
   */
   if (!pServerName)
   {
      /*
      **  Retrieve my ip address.  Assuming the hosts file in
      **  in %systemroot%/system/drivers/etc/hosts contains my computer name.
      */

      dwSize = sizeof(szBuff);
      GetComputerName(szBuff, &dwSize);
      CharLowerBuff( szBuff, dwSize );

   }

   /* gethostbyname() fails if the remote name is in upper-case characters!
    */
   else
   {
       strcpy( szBuff, pServerName );
       CharLowerBuff( szBuff, strlen( szBuff ) );
   }

   phe = gethostbyname(szBuff);
   if (phe == NULL) {

      wsprintf( szTemp, "%d is the error. Make sure '%s' is"
                " listed in the hosts file.", WSAGetLastError(), szBuff );
      MessageBox(hWnd, szTemp, "gethostbyname() failed.", MB_OK);
      return FALSE;
   }

   memcpy((char FAR *)&(psin->sin_addr), phe->h_addr, phe->h_length);

   return TRUE;
}



/* SocketConnect
 *
 * The counterpart to SocketListen.
 * Creates a socket and initializes it with the supplied TCP/IP
 * port address, then connects to a listening server.
 * The returned socket can be used to send() and recv() data.
 *
 * Parameters: TCPPort - The port to use.
 *             pSocket - A pointer to a SOCKET, which will be filled in
 *                 if the call succeeds.
 *
 * Returns:    TRUE if successful.
 *
 *
 * Created 16 November 1993 (andrewbe)
 *
 */
BOOL SocketConnect( LPSTR pstrServerName, u_short TCPPort, SOCKET *pSocket )
{
    SOCKET Socket;
    SOCKADDR_IN dest_sin;  /* DESTination Socket INternet */

    /* Create a socket:
     */
    Socket = socket( AF_INET, SOCK_STREAM, 0);

    if (Socket == INVALID_SOCKET)
    {
        WSAERROR( "socket()");

        return FALSE;
    }

    if (!FillAddr( NULL, &dest_sin, pstrServerName ) )
    {
        return FALSE;
    }

    dest_sin.sin_port = htons( TCPPort );

    /* Someone must be listen()ing for this to succeed:
     */
    if (connect( Socket, (PSOCKADDR)&dest_sin, sizeof( dest_sin)) == SOCKET_ERROR)
    {
        closesocket( Socket );
        WSAERROR("connect()");
        MessageBox(NULL,
                   "ERROR: Could not connect the socket. "
                     "It may be that the hardcoded Sleep() value "
                     "on the caller's side is not long enough.",
                   "Video Conferencing Prototype", MB_OK);
        return FALSE;
    }

    *pSocket = Socket;

    return TRUE;
}



/* SocketListen
 *
 * The counterpart to SocketConnect.
 * Creates a socket and initializes it with the supplied TCP/IP
 * port address, then listens for a connecting client.
 * The returned socket can be used to send() and recv() data.
 *
 * Parameters: TCPPort - The port to use.
 *             pSocket - A pointer to a SOCKET, which will be filled in
 *                 if the call succeeds.
 *
 * Returns:    TRUE if successful.
 *
 *
 * Created 16 November 1993 (andrewbe)
 *
 */
BOOL SocketListen( u_short TCPPort, SOCKET *pSocket )
{
    SOCKET Socket;
    SOCKADDR_IN local_sin;  /* Local socket - internet style */
    SOCKADDR_IN acc_sin;    /* Accept socket address - internet style */
    int acc_sin_len;        /* Accept socket address length */

    /* Create a socket:
     */
    Socket = socket( AF_INET, SOCK_STREAM, 0);

    if (Socket == INVALID_SOCKET)
    {
        WSAERROR( "socket()");

        return FALSE;
    }

    /*
    **  Retrieve the IP address and TCP Port number
    */

    if (!FillAddr(NULL, &local_sin, NULL ))
    {
        return FALSE;
    }

    /*
    **  Associate an address with a socket. (bind)
    */
    local_sin.sin_port = htons( TCPPort );

    if (bind( Socket, (struct sockaddr FAR *)&local_sin, sizeof(local_sin)) == SOCKET_ERROR)
    {
        WSAERROR( "bind()" );

        return FALSE;
    }


    if (listen( Socket, MAX_PENDING_CONNECTS ) == SOCKET_ERROR)
    {
        WSAERROR( "listen()" );

        return FALSE;
    }

    acc_sin_len = sizeof(acc_sin);

    Socket = accept( Socket, (struct sockaddr *)&acc_sin, (int *)&acc_sin_len );

    if (Socket == INVALID_SOCKET)
    {
        WSAERROR( "accept()" );

        return FALSE;
    }

    *pSocket = Socket;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\tprint.c ===
/*
 * standard table class.
 *
 * print functions.
 *
 * see table.h for interface description
 */

#include <string.h>

#include "windows.h"
#include "commdlg.h"
#include "gutils.h"
#include "gutilsrc.h"

#include "table.h"
#include "tpriv.h"

/* in tpaint.c, calls GetTextExtentPoint */
extern int GetTextExtent(HDC, LPSTR, int);

extern HANDLE hLibInst;

/* function prototypes */
lpTable gtab_printsetup(HWND hwnd, lpTable ptab, HANDLE heap,
                        lpPrintContext pcontext);
BOOL gtab_prtwidths(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext
                    pcontext);
void gtab_printjob(HWND hwnd, lpTable ptab, lpPrintContext pcontext);
int APIENTRY AbortProc(HDC hpr, int code);
INT_PTR CALLBACK AbortDlg(HWND, UINT, WPARAM, LPARAM);
BOOL gtab_printpage(HWND hwnd, lpTable ptab, lpPrintContext pcontext, int page);
void gtab_setrects(lpPrintContext pcontext, LPRECT rcinner, LPRECT rcouter);
void gtab_printhead(HWND hwnd, HDC hdc, lpTable ptab, lpTitle head, int page, BOOL fExpandChars);


/*
 * gtab_print
 */
BOOL
gtab_print(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
    BOOL fNoContext, fNoMargin, fNoPD;
    BOOL fSuccess = TRUE;
    lpTable ptab_prt;

    fNoContext = FALSE;
    fNoPD = FALSE;
    fNoMargin = FALSE;

    if (pcontext == NULL) {
        fNoContext = TRUE;
        pcontext = (lpPrintContext) gmem_get(heap,
                                             sizeof(PrintContext));
        pcontext->head = pcontext->foot = NULL;
        pcontext->margin = NULL;
        pcontext->pd = NULL;
        pcontext->id = 0;
    }
    if (pcontext->pd == NULL) {
        fNoPD = TRUE;
    }
    if (pcontext->margin == NULL) {
        fNoMargin = TRUE;
    }
    ptab_prt = gtab_printsetup(hwnd, ptab, heap, pcontext);

    if (ptab_prt != NULL) {
        gtab_printjob(hwnd, ptab_prt, pcontext);

        gtab_deltable(hwnd, ptab_prt);
    } else fSuccess = FALSE;
    if (fNoMargin) {
        gmem_free(heap, (LPSTR)pcontext->margin,
                  sizeof(Margin));
        pcontext->margin = NULL;
    }
    if (fNoPD) {
        if (pcontext->pd->hDevMode != NULL) {
            GlobalFree(pcontext->pd->hDevMode);
        }
        if (pcontext->pd->hDevNames != NULL) {
            GlobalFree(pcontext->pd->hDevNames);
        }
        gmem_free(heap, (LPSTR) pcontext->pd, sizeof(PRINTDLG));
        pcontext->pd = NULL;
    }
    if (fNoContext) {
        gmem_free(heap, (LPSTR) pcontext, sizeof(PrintContext));
    }
    return fSuccess;
}



/*
 * gtab_printsetup()
 *
 * sets up printercontext - builds lpTable for printer, incl. sizing
 * and initialises pcontext fields that may be null.
 */
lpTable
gtab_printsetup(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
    lpTable pprttab;
    PRINTDLG FAR * pd;
    int ncols, i;
    ColPropsList cplist;

    /* set fields for context that user left null */
    if (pcontext->margin == NULL) {
        pcontext->margin = (lpMargin) gmem_get(heap, sizeof(Margin));
        if (pcontext->margin == NULL) {
            return(NULL);
        }
        pcontext->margin->left = 10;
        pcontext->margin->right = 10;
        pcontext->margin->top = 15;
        pcontext->margin->bottom = 15;
        pcontext->margin->topinner = 15;
        pcontext->margin->bottominner = 15;
    }

    if (pcontext->pd == NULL) {
        pd = (PRINTDLG FAR *) gmem_get(heap, sizeof(PRINTDLG));
        if (pd == NULL) {
            return(NULL);
        }
        pcontext->pd = pd;

        pd->lStructSize = sizeof(PRINTDLG);
        pd->hwndOwner = hwnd;
        pd->hDevMode = (HANDLE) NULL;
        pd->hDevNames = (HANDLE) NULL;
        pd->Flags = PD_RETURNDC|PD_RETURNDEFAULT;

        if (PrintDlg(pd) == FALSE) {
            return(NULL);
        }
    }

    /* now create a Table struct by querying the owner */
    pprttab = (lpTable) gmem_get(heap, sizeof(Table));

    if (pprttab == NULL) {
        return(NULL);
    }
    pprttab->hdr = ptab->hdr;
    pprttab->tabchars = ptab->tabchars;
    pprttab->show_whitespace = ptab->show_whitespace;

    /* get the row/column count from owner window */
    if (pcontext->id == 0) {
        pprttab->hdr.id = ptab->hdr.id;
    } else {
        pprttab->hdr.id = pcontext->id;
    }
    pprttab->hdr.props.valid = 0;
    pprttab->hdr.sendscroll = FALSE;
    if (gtab_sendtq(hwnd, TQ_GETSIZE, (LPARAM)&pprttab->hdr) == FALSE) {
        return(NULL);
    }

    /* alloc and init the col data structs */
    ncols = pprttab->hdr.ncols;
    pprttab->pcolhdr = (lpColProps) gmem_get(heap, sizeof(ColProps) * ncols);
    if (pprttab->pcolhdr == NULL) {
        gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
        return(NULL);
    }

    /* init col properties to default */
    for (i=0; i < ncols; i++) {
        pprttab->pcolhdr[i].props.valid = 0;
        pprttab->pcolhdr[i].nchars = 0;
    }
    /* get the column props from owner */
    cplist.plist = pprttab->pcolhdr;
    cplist.id = pprttab->hdr.id;
    cplist.startcol = 0;
    cplist.ncols = ncols;
    gtab_sendtq(hwnd, TQ_GETCOLPROPS, (LPARAM)&cplist);


    pprttab->scrollscale = 1;
    pprttab->pcellpos = (lpCellPos) gmem_get(heap,
                                             sizeof(CellPos) * ptab->hdr.ncols);
    if (pprttab->pcellpos == NULL) {
        gmem_free(heap, (LPSTR) pprttab->pcolhdr, sizeof(ColProps) * ncols);
        gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
        return(NULL);
    }


    pprttab->pdata = NULL;
    pprttab->nlines = 0;

    if (!gtab_prtwidths(hwnd, pprttab, heap, pcontext)) {
        gmem_free(heap, (LPSTR)pprttab->pcellpos,
                  sizeof(CellPos) * ptab->hdr.ncols);
        gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
        return(NULL);
    }
    return(pprttab);
}


/* calc the height/width settings and alloc line data */
BOOL
gtab_prtwidths(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
    TEXTMETRIC tm;
    int cx, cxtotal, i, curx, cury;
    lpProps hdrprops, cellprops;
    lpCellPos xpos, ypos;
    RECT rcinner, rcouter;

    hdrprops = &ptab->hdr.props;
    GetTextMetrics(pcontext->pd->hDC, &tm);
    ptab->avewidth = tm.tmAveCharWidth;
    ptab->rowheight = tm.tmHeight + tm.tmExternalLeading;
    if (hdrprops->valid & P_HEIGHT) {
        ptab->rowheight = hdrprops->height;
    }

    /* set sizes for headers */
    gtab_setrects(pcontext, &rcinner, &rcouter);

    /* set width/pos for each col. */
    cxtotal = 0;
    curx = rcinner.left;
    for (i = 0; i < ptab->hdr.ncols; i++) {
        cellprops = &ptab->pcolhdr[i].props;
        xpos = &ptab->pcellpos[i];

        if (cellprops->valid & P_WIDTH) {
            cx = cellprops->width;
        } else if (hdrprops->valid & P_WIDTH) {
            cx = hdrprops->width;
        } else {
            cx = ptab->pcolhdr[i].nchars + 1;
            cx *= ptab->avewidth;
        }
        /* add 2 for intercol spacing */
        cx += 2;

        xpos->size = cx;
        xpos->start = curx + 1;
        xpos->clipstart = xpos->start;
        xpos->clipend = xpos->start + xpos->size - 2;
        xpos->clipend = min(xpos->clipend, rcinner.right);

        cxtotal += xpos->size;
        curx += xpos->size;
    }
    ptab->rowwidth = cxtotal;

    if (pcontext->head != NULL) {
        xpos = &pcontext->head->xpos;
        ypos = &pcontext->head->ypos;

        xpos->start = rcouter.left + 1;
        xpos->clipstart = rcouter.left + 1;
        xpos->clipend = rcouter.right - 1;
        xpos->size = rcouter.right - rcouter.left;

        ypos->start = rcouter.top;
        ypos->clipstart = rcouter.top;
        ypos->clipend = rcinner.top;
        ypos->size = ptab->rowheight;
    }

    if (pcontext->foot != NULL) {
        xpos = &pcontext->foot->xpos;
        ypos = &pcontext->foot->ypos;

        xpos->start = rcouter.left + 1;
        xpos->clipstart = rcouter.left + 1;
        xpos->clipend = rcouter.right - 1;
        xpos->size = rcouter.right - rcouter.left;

        ypos->start = rcouter.bottom - ptab->rowheight;
        ypos->clipstart = rcinner.bottom;
        ypos->clipend = rcouter.bottom;
        ypos->size = ptab->rowheight;
    }

    /* set nr of lines per page */
    ptab->nlines = (rcinner.bottom - rcinner.top) / ptab->rowheight;
    if (!gtab_alloclinedata(hwnd, heap, ptab)) {
        return(FALSE);
    }
    /* set line positions */
    cury = rcinner.top;
    for (i = 0; i < ptab->nlines; i++) {
        ypos = &ptab->pdata[i].linepos;
        ypos->start = cury;
        ypos->clipstart = ypos->start;
        ypos->clipend = ypos->start + ypos->size;
        ypos->clipend = min(ypos->clipend, rcinner.bottom);
        cury += ypos->size;
    }
    return(TRUE);
}


/* static information for this module */
BOOL bAbort;
FARPROC lpAbortProc;
//DLGPROC lpAbortDlg;
HWND hAbortWnd;
int npage;
int pages;

void
gtab_printjob(HWND hwnd, lpTable ptab, lpPrintContext pcontext)
{
    int moveables;
    int endpage;
    int startpage = 1;
    HDC hpr;
    int status;
    HANDLE hcurs;
    static char str[256];
    DOCINFO di;
    TCHAR szPage[60];  /* for LoadString */

    hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    moveables = ptab->nlines - ptab->hdr.fixedrows;
    pages = (int) (ptab->hdr.nrows - ptab->hdr.fixedrows + moveables - 1)
            / moveables;
    endpage = pages;

    if (pcontext->pd->Flags & PD_PAGENUMS) {
        startpage = pcontext->pd->nFromPage;
        endpage = pcontext->pd->nToPage;
    }
    hpr = pcontext->pd->hDC;

    //lpAbortDlg = (DLGPROC) MakeProcInstance((WINPROCTYPE) AbortDlg, hLibInst);
    lpAbortProc = (FARPROC) MakeProcInstance((WINPROCTYPE)AbortProc, hLibInst);

    SetAbortProc(hpr, (ABORTPROC) lpAbortProc);

    di.lpszDocName = "Table";
    di.cbSize = lstrlen(di.lpszDocName);
    di.lpszOutput = NULL;
    di.lpszDatatype = NULL;
    di.fwType = 0;

    StartDoc(hpr, &di);

    bAbort = FALSE;

    /* add abort modeless dialog later!! */
    //hAbortWnd = CreateDialog(hLibInst, "GABRTDLG", hwnd, lpAbortDlg);
    hAbortWnd = CreateDialog(hLibInst, "GABRTDLG", hwnd, AbortDlg);
    if (hAbortWnd != NULL) {
        ShowWindow(hAbortWnd, SW_NORMAL);
        EnableWindow(hwnd, FALSE);
    }
    SetCursor(hcurs);


    status = 0;  /* kills a "used without init" diagnostic */
    for (npage = startpage; npage<=endpage; npage++) {
        LoadString(hLibInst,IDS_PAGE_STR,szPage,sizeof(szPage));
        wsprintf(str, szPage,  npage, pages);
        if (hAbortWnd != NULL)
            SetDlgItemText(hAbortWnd, IDC_LPAGENR, str);
        status = gtab_printpage(hwnd, ptab, pcontext, npage);
        if (status < 0) {
            AbortDoc(hpr);
            break;
        }
    }
    if (status >= 0) {
        EndDoc(hpr);
    }

    if (hAbortWnd != NULL) {
        EnableWindow(hwnd, TRUE);
        DestroyWindow(hAbortWnd);
    }
    //FreeProcInstance((WINPROCTYPE) lpAbortDlg);
    FreeProcInstance(lpAbortProc);

    DeleteDC(hpr);
}

int APIENTRY
AbortProc(HDC hpr, int code)
{

    MSG msg;

    if (!hAbortWnd) {
        return(TRUE);
    }
    while (!bAbort && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        if (!IsDialogMessage(hAbortWnd, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return(!bAbort);
}

INT_PTR CALLBACK
AbortDlg(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {

        case WM_COMMAND:
            bAbort = TRUE;
            EndDialog(hdlg, TRUE);
            return TRUE;

        case WM_INITDIALOG:
            return TRUE;
    }
    return(FALSE);
}

/*
 * print a single page. page number is 1-based
 */
BOOL
gtab_printpage(HWND hwnd, lpTable ptab, lpPrintContext pcontext, int page)
{
    HDC hpr;
    int moveables, i;
    int x1, y1, x2, y2;

    hpr = pcontext->pd->hDC;
    StartPage(hpr);

    moveables = ptab->nlines - ptab->hdr.fixedrows;
    ptab->toprow = moveables * (page-1);
    gtab_invallines(hwnd, ptab, ptab->hdr.fixedrows, moveables);

    for (i =0; i < ptab->nlines; i++) {
        gtab_paintline(hwnd, hpr, ptab, i, ptab->show_whitespace, TRUE);
    }
    if ((ptab->hdr.vseparator) && (ptab->hdr.fixedcols > 0)) {
        x1 = ptab->pcellpos[ptab->hdr.fixedcols -1].clipend+1;
        y1 = ptab->pdata[0].linepos.clipstart;
        y2 = ptab->pdata[ptab->nlines-1].linepos.clipend;
        MoveToEx(hpr, x1, y1, NULL);
        LineTo(hpr, x1, y2);
    }
    if ((ptab->hdr.hseparator) && (ptab->hdr.fixedrows > 0)) {
        y1 = ptab->pdata[ptab->hdr.fixedrows-1].linepos.clipend;
        x1 = ptab->pcellpos[0].clipstart;
        x2 = ptab->pcellpos[ptab->hdr.ncols-1].clipend;
        MoveToEx(hpr, x1, y1, NULL);
        LineTo(hpr, x2, y1);
    }

    if (pcontext->head != NULL) {
        gtab_printhead(hwnd, hpr, ptab, pcontext->head, page, FALSE);
    }
    if (pcontext->foot != NULL) {
        gtab_printhead(hwnd, hpr, ptab, pcontext->foot, page, TRUE);
    }

    return(EndPage(hpr));
}


/*
 * calculate the outline positions in pixels for the headers
 * (outer rect) and for the page itself (inner rect). Based on
 * page size and PrintContext margin info (which is in millimetres).
 */
void
gtab_setrects(lpPrintContext pcontext, LPRECT rcinner, LPRECT rcouter)
{
    HDC hpr;
    int hpixels, hmms;
    int vpixels, vmms;
    int h_pixpermm, v_pixpermm;

    hpr = pcontext->pd->hDC;
    hpixels = GetDeviceCaps(hpr, HORZRES);
    vpixels = GetDeviceCaps(hpr, VERTRES);
    vmms = GetDeviceCaps(hpr, VERTSIZE);
    hmms = GetDeviceCaps(hpr, HORZSIZE);

    h_pixpermm = hpixels / hmms;
    v_pixpermm = vpixels / vmms;

    rcouter->top = (pcontext->margin->top * v_pixpermm);
    rcouter->bottom = vpixels - (pcontext->margin->bottom * v_pixpermm);
    rcouter->left = (pcontext->margin->left * h_pixpermm);
    rcouter->right = hpixels - (pcontext->margin->right * h_pixpermm);

    rcinner->left = rcouter->left;
    rcinner->right = rcouter->right;
    rcinner->top = rcouter->top +
                   (pcontext->margin->topinner * v_pixpermm);
    rcinner->bottom = rcouter->bottom -
                      (pcontext->margin->bottominner * v_pixpermm);
}


void
gtab_printhead(HWND hwnd, HDC hdc, lpTable ptab, lpTitle head, int page, BOOL fExpandChars)
{
    RECT rc, rcbox;
    int i, cx, x, y, tab;
    UINT align;
    LPSTR chp, tabp;
    DWORD fcol, bkcol;
    char str[MAX_PATH * 2];

    fcol = 0; bkcol = 0;  /* eliminate spurious diagnostic - generate worse code */

    rc.top = head->ypos.clipstart;
    rc.bottom = head->ypos.clipend;
    rc.left = head->xpos.clipstart;
    rc.right = head->xpos.clipend;

    /* update page number */
    if (fExpandChars) {
        chp = str;
        for (i = 0; i < lstrlen(head->ptext); i++) {
            switch (head->ptext[i]) {

                case '#':
                    chp += wsprintf(chp, "%d", page);
                    break;

                case '$':
                    chp += wsprintf(chp, "%d", pages);
                    break;

                default:
                    if (IsDBCSLeadByte(head->ptext[i]) &&
                        head->ptext[i+1])
                    {
                        *chp = head->ptext[i];
                        chp++;
                        i++;
                    }
                    *chp++ = head->ptext[i];
                    break;
            }
        }
        *chp = '\0';
    } else {
        lstrcpy(str, head->ptext);
    }
    chp = str;

    if (head->props.valid & P_ALIGN) {
        align = head->props.alignment;
    } else {
        align = P_LEFT;
    }

    /* set colours if not default */
    if (head->props.valid & P_FCOLOUR) {
        fcol = SetTextColor(hdc, head->props.forecolour);
    }
    if (head->props.valid & P_BCOLOUR) {
        bkcol = SetBkColor(hdc, head->props.backcolour);
    }

    /* calc offset of text within cell for right-align or centering */
    if (align == P_LEFT) {
        cx = ptab->avewidth/2;
    } else {
        cx = LOWORD(GetTextExtent(hdc, chp, lstrlen(chp)));
        if (align == P_CENTRE) {
            cx = (head->xpos.size - cx) / 2;
        } else {
            cx = head->xpos.size - cx - (ptab->avewidth/2);
        }
    }
    cx += head->xpos.start;

    /* expand tabs on output */
    tab = ptab->avewidth * ptab->tabchars;
    x = 0;
    y = head->ypos.start;

    for ( ; (tabp = My_mbschr(chp, '\t')) != NULL; ) {
        /* perform output upto tab char */
        ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &rc, chp, (UINT)(tabp-chp), NULL);

        /* advance past the tab */
        x += LOWORD(GetTextExtent(hdc, chp, (INT)(tabp - chp)));
        x = ( (x + tab) / tab) * tab;
        chp = ++tabp;
    }

    /*no more tabs - output rest of string */
    ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &rc, chp, lstrlen(chp), NULL);

    /* reset colours to original if not default */
    if (head->props.valid & P_FCOLOUR) {
        SetTextColor(hdc, fcol);
    }
    if (head->props.valid & P_BCOLOUR) {
        SetBkColor(hdc, bkcol);
    }

    /* now box cell if marked */
    if (head->props.valid & P_BOX) {
        if (head->props.box != 0) {
            rcbox.top = head->ypos.start;
            rcbox.bottom = rcbox.top + head->ypos.size;
            rcbox.left = head->xpos.start;
            rcbox.right = rcbox.left + head->xpos.size;
            gtab_boxcell(hwnd, hdc, &rcbox, &rc, head->props.box);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\table.h ===
/*
 * table.h
 *
 * public interface definition for table window class.
 *
 * include after gutils.h and commdlg.h
 */

/*
 * The table class communicates with its 'owner' window to
 * get the layout info and the data to display. The owner window handle
 * can be sent as the lParam in CreateWindow - if not, the parent window will
 * be used.
 *
 * After creating the window, send it a TM_NEWID message, with a 'data id'
 * as the lParam. This is any non-zero 32-bit value. The table will then call
 * back to its owner window to find out how many rows/columns, then to fetch
 * the name/properties of each column, and finally to get the data to display.
 *
 * Send TM_NEWID of 0 to close (or destroy the window) - wait for TQ_CLOSE
 * (in either case) before discarding data. Send
 * TM_REFRESH if data or row-count changes; send TM_NEWLAYOUT if column
 * properties or nr cols change etc - this is the same as sending TM_NEWID
 * except that no TQ_CLOSE happens on TM_NEWLAYOUT.
 *
 * TQ_SELECT is sent whenever the current selection changes. TQ_ENTER is sent
 * when enter or double-click occurs.
 */

/* -------class and message names --------------------------------------*/

/* create a window of this class */
#define  TableClassName "GTableClass"


/* all messages to the owner window are sent with this message.
 * call RegisterWindowsMessage with this string for the message UINT.
 */
#define TableMessage  "GTableQuery"

/* -------- messages to and from table class  --------------------------*/

/* messages to owner window are:
 *	message:	TableMessage
 *	wParam:		command code (below)
 * 	lParam:		struct pointer according to code
 * below is list of wParam codes & associated lParam struct
 */
#define TQ_GETSIZE	1	/* lParam: lpTableHdr */
#define	TQ_GETCOLPROPS	2	/* lParam: lpColPropList */
#define TQ_GETDATA	3	/* lParam: lpCellDataList */
#define TQ_PUTDATA	4	/* lParam: lpCellDataList */
#define TQ_SELECT	5	/* lParam: lpTableSelection */
#define TQ_ENTER	6	/* lParam: lpTableSelection */
#define TQ_CLOSE	7	/* lParam: the data id to be closed */

/* optional */
#define TQ_SCROLL	8	/* lParam: the new top row nr */
#define TQ_TABS         9       /* lParam: LONG *, write tab here */
#define TQ_SHOWWHITESPACE  10   /* lParam: LONG *, write show_whitespace value here */

/* messages to Table class */

/* data, or nrows has changed  wParam/lParam null*/
#define TM_REFRESH	(WM_USER)

/* nr cols/props/layout has changed  - wparam/lparam null */
#define TM_NEWLAYOUT	(WM_USER+1)

/* close old id, and display new - wParam null, lParam has new id */
#define TM_NEWID	(WM_USER+2)

/* select and show this area - wParam null, lParam is lpTableSelection */
#define TM_SELECT	(WM_USER+3)

/* please print current table - wParam null, lParam either null
 * or lpPrintContext.
 */
#define TM_PRINT	(WM_USER+4)

/* return the top row in the window. If wParam is TRUE, then set
 * lParam to be the new toprow. top row is the number of rows scrolled down
 * from the top. Thus the first visible non-fixed row is toprow+fixedrows
 */
#define TM_TOPROW	(WM_USER+5)


/* return the end row visible. This is the 0-based rownr of the last
 * visible row in the window
 */
#define TM_ENDROW	(WM_USER+6)

/* new rows have been added to the end of the table, but no other
 * rows or cols or properties have been changed.
 * wParam contains the new total nr of rows. lParam contains the id
 * in case this has changed.
 */
#define TM_APPEND	(WM_USER+7)

/*
 * return the current selection - lParam is a lpTableSelection
 */
#define TM_GETSELECTION (WM_USER+8)

/*
 * set the tab width - wParam null, lParam is new tab width
 */
#define TM_SETTABWIDTH (WM_USER+9)

/*-----display properties -------------------------------------------------*/

/*
 * display properties struct. can be set for whole table, for
 * each column, or for each cell. When looking for
 * a property, we search cell->column->table
 */
typedef struct {
	UINT valid;		/* flags (below) for what props we set */

/* remaining fields only valid when corresponding flag set in valid */

	DWORD forecolour;	/* RGB colour value */
	DWORD forecolourws;	/* ditto */
	DWORD backcolour;	/* ditto */
	/* font to use - also set through WM_SETFONT. owner application
	 * is responsible for DeleteObject call when no longer used
	 */
	HFONT hFont;		/* handle to font  - caller should delete*/
	UINT alignment;		/* flags below */
	UINT box;		/* whether cell boxed (see below) */

	/* width/height settings not valid at cell level - only table or col.*/
	int width;		/* pixel width of this cell/column */
	int height;		/* pixel cell height */
} Props, FAR * lpProps;

/* valid flags for fields that are changed in this Props struct */
#define P_FCOLOUR	0x01
#define P_FCOLOURWS	0x02
#define P_BCOLOUR	0x04
#define P_FONT		0x08
#define P_ALIGN		0x10
#define P_BOX		0x20
#define P_WIDTH		0x40
#define P_HEIGHT	0x80

/* box settings  or-ed together */
#define P_BOXTOP	1
#define P_BOXBOTTOM	2
#define P_BOXLEFT	4
#define P_BOXRIGHT	8
#define P_BOXALL	0xF

/* alignment settings (expand later to include various tab-align settings */
#define P_LEFT		0
#define P_RIGHT		1
#define P_CENTRE	2

/* default tab width in chars */
#define TABWIDTH_DEFAULT      8

/* --- main header -------------------------------------------------------*/

/* this struct is the master information about a table. It is
 * passed to the owner window with the id field filled in; fill in
 * all remaining fields and return.
 */
typedef struct {
        DWORD_PTR id;           /* owner's data id */

	/* please fill in rest: */
	long nrows;		/* how many rows ? TM_REFRESH to change */
	int ncols;		/* how many columns ? TM_NEWLAYOUT to chg */

	int fixedrows;		/* for headers - usually 0 or 1 */
	int fixedcols;		/* for hdrs - 0 or 1 normally */
	BOOL fixedselectable;	/* is fixed area selectable ? */
	BOOL hseparator;	/* is there a horz. line after fixed rows */
	BOOL vseparator;	/* is there a vert. line after fixed rows */

	UINT selectmode;	/* multiple/single selection - flags below*/
	BOOL sendscroll;	/* TRUE if TQ_SCROLL to be sent on scrolling*/

	Props props;
} TableHdr, FAR * lpTableHdr;

/*
 * selection mode;
 *
 * choose TM_CELL or TM_ROW, and TM_SINGLE or TM_MANY, and
 * TM_SOLID or TM_FOCUS and or them together.
 *
 */
#define TM_ROW		1	/* selectable items are rows */
#define TM_CELL		0	/* selectable items are cells */

#define TM_MANY		2	/* multiple selects possible */
#define TM_SINGLE	0	/* single item selectable at once only */

#define TM_SOLID	0	/* (default) use a solid black for selection*/
#define TM_FOCUS	4	/* use a dotted focus rect for selection */


/* --------- column header structs --------------------------------------*/

/*
 * this struct is sent to request column width and properties -
 * owner window must fill nchars and props.valid, at minimum.
 */
typedef struct {
	int nchars;	/* expected text width in chars */
	Props props;
} ColProps, FAR * lpColProps;


/* this is a set of column requests - owner should fill each one*/
typedef struct {
        DWORD_PTR id;           /* caller's id for data */
	int startcol;		/* zero-based column nr of first request */
	int ncols;		/* nr of columns in this set */
	lpColProps plist;	/* ptr to _array_ of ColProps */
} ColPropsList, FAR * lpColPropsList;


/* --- cell data structs ---------------------------------------------*/

/* this is the per-cell data struct.
 * When providing data (responding to TQ_GETDATA), fill out ptext[] and
 * props as appropriate. ptext will be pre-allocated with nchars bytes of
 * space. This may be larger than ColProps->nchars if the user has
 * stretched this column's width on screen
 *
 * don't re-alloc ptext, or change flags.
 */
typedef struct {
	int nchars;		/* space in buffer */
	LPSTR ptext;		/* ptr to nchars of text space */
	Props props;		/* per-cell props */
	DWORD flags;		/* private table class flags */
	LPWSTR pwzText;		/* ptr to nchars of WCHAR space */
} CellData, FAR * lpCellData;

/* list of cell data structures - please fill out all of these*/
typedef struct {
        DWORD_PTR id;           /* caller's id for data */
	long row;		/* zero-based row nr to fetch */
	int startcell;		/* zero-based cell nr on this row */
	int ncells;		/* count of cells to fetch */
	lpCellData plist;	/* ptr to array CellData[ncells] */
} CellDataList, FAR * lpCellDataList;


/*----- current selection----------------------------------------------*/

/*
 * describes the current selection - a rectangular selection area
 *
 * Note that if the TM_MANY selection mode is used, startrow and startcell will
 * be the end-point (most recently selected end) of the selection, and
 * nrows, ncells may be positive or negative. +1 and -1 both mean just the
 * 1 row startrow, -2 means startrow and the one before, etc. 0 nrows means
 * no valid selection.
 */
typedef struct {
        DWORD_PTR id;           /* caller's id for data */
	long startrow;		/* zero-based row nr of start of sel. */
	long startcell;		/* zero-based col nr of  start of sel */
	long nrows;		/* vertical depth of selection */
	long ncells;		/* horz width of selection */
	long dyRowsFromTop;		/* -1 means used auto-center logic, otherwise put selection this many rows from top */
} TableSelection, FAR * lpTableSelection;



/*----- print context -----------------------------------------------*/

/* describes the margin settings for the print job - these are in CMs*/
typedef struct {
	int left;		/* edge of paper to start of print area */
	int right;		/* edge of paper to start of print area */
	int top;		/* edge of paper to start of hdr */
	int bottom;		/* end of hdr to end of paper */
	int topinner;		/* start of hdr to start of data */
	int bottominner;	/* end of data to start of hdr */
} Margin, FAR * lpMargin;

/* position and clipping info - only used by table class
 */
typedef struct {
	int start;		/* co-ord of cell start (left or top) */
	int clipstart;		/* start of clipping (vis area) */
	int clipend;		/* end of clipping (vis area) */
	int size;		/* pixel size of cell (width or height) */
} CellPos, FAR * lpCellPos;


/* one of these for each header lines (top and bottom) */
typedef struct {
	CellPos xpos, ypos;	/* private: for table-class use only */
	Props props;
	LPSTR ptext;
} Title, FAR * lpTitle;

/* Print context data structure - any or all 4 pointers may be null */
typedef struct {
        DWORD_PTR id;           /* id of table to print */
	lpTitle head;
	lpTitle foot;
	lpMargin margin;
	PRINTDLG FAR * pd;
} PrintContext, FAR * lpPrintContext;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\tpaint.c ===
/*
 * standard table class.
 *
 * paint functions.
 *
 * see table.h for interface description
 */

#include <string.h>


#include "windows.h"
#include "commdlg.h"
#include "gutils.h"

#include "table.h"
#include "tpriv.h"

#ifdef WIN32

int
GetTextExtent(HDC hdc, LPSTR text, INT len)
{
    SIZE sz;

    GetTextExtentPoint(hdc, text, len, &sz);
    return(sz.cx);
}
#endif

void gtab_updatecontig(HWND hwnd, lpTable ptab, int line, int cell1, int count);

/* change all cr/lf chars in input text to nul chars (used to be spaces, not sure why) */
void gtab_delcr(LPSTR ptext)
{
	LPSTR chp;

	if (ptext == NULL) {
		return;
	}
	for(chp = ptext; (chp = My_mbschr(chp, '\r')) != NULL; ) {
		*chp = '\0';
	}
	for(chp = ptext; (chp = My_mbschr(chp, '\n')) != NULL; ) {
		*chp = '\0';
	}
}
void gtab_delcrW(LPWSTR pwzText)
{
	LPWSTR pwch;

	if (pwzText)
		for(pwch = pwzText; *pwch; pwch++)
			if (*pwch == '\r' || *pwch == '\n')
				*pwch = 0;
}

/* ensure that all visible cells in the given line have valid
 * text and property contents. loop through the cells, picking out
 * contiguous blocks of visible, invalid cells and call
 * gtab_updatecontig to update these from the owner window.
 */
void
gtab_updateline(HWND hwnd, lpTable ptab, int line)
{
	lpCellPos ppos;
	int cell1, cellcount;
	lpLineData pline;
	lpCellData cd;
	int i;

	if (line < 0 || line >= ptab->nlines)
		return;

	pline = &ptab->pdata[line];
	cell1 = 0;
	cellcount = 0;
	for (i = 0; i < ptab->hdr.ncols; i++) {
		ppos = &ptab->pcellpos[i];
		cd = &pline->pdata[i];
		if (ppos->clipstart < ppos->clipend) {
			if ((cd->flags & CELL_VALID) == 0) {
				/* add a cell to the list to be updated*/
				if (cellcount++ == 0) {
					cell1 = i;
				}
			} else {
				/* this cell already valid - so end of
				 * a contig block. if the contig
				 * block just ended contained cells to update,
				 * do it now
				 */
				if (cellcount > 0) {
					gtab_updatecontig(hwnd, ptab,
					  line, cell1, cellcount);
				}
				cellcount = 0;
			}
		}
		/* cell not visible - end of a contig block. If it was a
		 * non-empty contig block, then update it now.
		 */
		if (cellcount > 0)  {
			gtab_updatecontig(hwnd, ptab, line, cell1, cellcount);
			cellcount = 0;	
		}
	}
	if (cellcount > 0) {
		gtab_updatecontig(hwnd, ptab, line, cell1, cellcount);
		cellcount = 0;
	}
}

/*
 * update a contiguous block of invalid cells by calling the owner window
 */
void
gtab_updatecontig(HWND hwnd, lpTable ptab, int line, int cell1, int count)
{
	lpLineData pline;
	lpCellData cd;
	CellDataList list;
	lpProps colprops;
	int i;
	COLORREF rgb;

	pline = &ptab->pdata[line];
	cd = &pline->pdata[cell1];

	list.id = ptab->hdr.id;
	list.row = gtab_linetorow(hwnd, ptab, line);
	list.startcell = cell1;
	list.ncells = count;
	list.plist = cd;

	/* clear out prop flags */
	rgb = GetSysColor(COLOR_WINDOW);
	for (i = 0; i < count; i++) {
		cd[i].props.valid = P_BCOLOUR;
		cd[i].props.backcolour = rgb;
		if (cd[i].nchars > 0) {
			cd[i].ptext[0] = '\0';
			if (cd[i].pwzText) {
				cd[i].pwzText[0] = '\0';
			}
		}
	}

	if (list.row < ptab->hdr.nrows) {
		gtab_sendtq(hwnd, TQ_GETDATA, (LPARAM) &list);
	}

	/* for each cell, mark valid and set properties */
	for (i = 0; i < count; i++) {
		cd[i].flags |= CELL_VALID;
		gtab_delcr(cd[i].ptext);
		gtab_delcrW(cd[i].pwzText);
		/* fetch properties from hdr and colhdr */
		colprops = &ptab->pcolhdr[i + cell1].props;
		if (!(cd[i].props.valid & P_FCOLOUR)) {
			if (colprops->valid & P_FCOLOUR) {
				cd[i].props.valid |= P_FCOLOUR;
				cd[i].props.forecolour = colprops->forecolour;
			} else if (ptab->hdr.props.valid & P_FCOLOUR) {
				cd[i].props.valid |= P_FCOLOUR;
				cd[i].props.forecolour =
					ptab->hdr.props.forecolour;
			}
		}

		if (!(cd[i].props.valid & P_FCOLOURWS)) {
			if (colprops->valid & P_FCOLOURWS) {
				cd[i].props.valid |= P_FCOLOURWS;
				cd[i].props.forecolourws = colprops->forecolourws;
			} else if (ptab->hdr.props.valid & P_FCOLOURWS) {
				cd[i].props.valid |= P_FCOLOURWS;
				cd[i].props.forecolourws =
					ptab->hdr.props.forecolourws;
			}
		}

		if (!(cd[i].props.valid & P_BCOLOUR)) {
			if (colprops->valid & P_BCOLOUR) {
				cd[i].props.valid |= P_BCOLOUR;
				cd[i].props.backcolour = colprops->backcolour;
			} else if (ptab->hdr.props.valid & P_BCOLOUR) {
				cd[i].props.valid |= P_BCOLOUR;
				cd[i].props.backcolour =
					ptab->hdr.props.backcolour;
			}
		}

		if (!(cd[i].props.valid & P_FONT)) {
			if (colprops->valid & P_FONT) {
				cd[i].props.valid |= P_FONT;
				cd[i].props.hFont = colprops->hFont;
			} else if (ptab->hdr.props.valid & P_FONT) {
				cd[i].props.valid |= P_FONT;
				cd[i].props.hFont = ptab->hdr.props.hFont;
			}
		}

		if (!(cd[i].props.valid & P_ALIGN)) {
			if (colprops->valid & P_ALIGN) {
				cd[i].props.valid |= P_ALIGN;
				cd[i].props.alignment = colprops->alignment;
			} else if (ptab->hdr.props.valid & P_ALIGN) {
				cd[i].props.valid |= P_ALIGN;
				cd[i].props.alignment =
					ptab->hdr.props.alignment;
			}
		}

		if (!(cd[i].props.valid & P_BOX)) {
			if (colprops->valid & P_BOX) {
				cd[i].props.valid |= P_BOX;
				cd[i].props.box = colprops->box;
			} else if (ptab->hdr.props.valid & P_BOX) {
				cd[i].props.valid |= P_BOX;
				cd[i].props.box = ptab->hdr.props.box;
			}
		}
		/* you can't set width/height per cell - this
		 * is ignored at cell level.
		 */
	}

}

void
gtab_boxcell(HWND hwnd, HDC hdc, LPRECT rcp, LPRECT pclip, UINT boxmode)
{
	if (boxmode & P_BOXTOP) {
		MoveToEx(hdc, max(rcp->left, pclip->left),
			max(rcp->top, pclip->top), NULL);
		LineTo(hdc, min(rcp->right, pclip->right),
			max(rcp->top, pclip->top));
	}
	if (boxmode & P_BOXBOTTOM) {
		MoveToEx(hdc, max(rcp->left, pclip->left),
			min(rcp->bottom, pclip->bottom), NULL);
		LineTo(hdc, min(rcp->right, pclip->right),
			min(rcp->bottom, pclip->bottom));
	}
	if (boxmode & P_BOXLEFT) {
		MoveToEx(hdc, max(rcp->left, pclip->left),
			max(rcp->top, pclip->top), NULL);
		MoveToEx(hdc, max(rcp->left, pclip->left),
			min(rcp->bottom, pclip->bottom), NULL);
	}
	if (boxmode & P_BOXRIGHT) {
		MoveToEx(hdc, min(rcp->right, pclip->right),
			max(rcp->top, pclip->top), NULL);
		LineTo(hdc, min(rcp->right, pclip->right),
			min(rcp->bottom, pclip->bottom));
	}
}

void
gtab_paintcell(HWND hwnd, HDC hdc, lpTable ptab, int line, int cell, BOOL show_whitespace, BOOL fPrinting)
{
	lpLineData pline;
	lpCellData cd;
	lpCellPos ppos;
	RECT rc, rcbox;
	int cx, x, y;
	UINT align;
	LPSTR chp, tabp;
	LPWSTR pwch, pwchBreak;
	DWORD fcol, fcolOld, fcolws;
	DWORD bkcol, bkcolOld;
	HFONT hfont, hfontOld;
	HBRUSH hbr;
	char szCharSet[] = "\t ";
	WCHAR wzCharSet[] = L"\t ";
	char szSpaceReplace[] = { (char) 183, (char) 0 };
	char szTabReplace[] = { (char) 187, (char) 0 };
	int cxSpaceReplace;
	int cxTabReplace;
	SIZE size;
	TEXTMETRIC tm;
	int yOfs;
	DWORD etoFlags = ETO_CLIPPED;

        fcol = 0; bkcol = 0; /* eliminate spurious diagnostic, generate worse code */
        hfont = 0;           /* eliminate spurious diagnostic, generate worse code */
	/* init pointers to cell text and properties */
	pline = &ptab->pdata[line];
	cd = &pline->pdata[cell];
	ppos = &ptab->pcellpos[cell];

	/* draw gutter */
	rc.top = pline->linepos.clipstart;
	rc.bottom = pline->linepos.clipend;
	rc.left = (cell > 0) ? ptab->pcellpos[cell - 1].clipend : 0;
	rc.right = ppos->clipstart;
	if (cell > ptab->hdr.fixedcols && ptab->hdr.fixedcols < ptab->hdr.ncols) {
		rc.left = max(rc.left, ptab->pcellpos[ptab->hdr.fixedcols].clipstart);
	}
	if (ptab->hdr.fixedcols > 0 && cell == ptab->hdr.fixedcols) {
		rc.right--;
	}
	if (!fPrinting && rc.right > rc.left) {
		FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
	}

	/* clip all output to this rectangle */
	rc.top = pline->linepos.clipstart;
	rc.bottom = pline->linepos.clipend;
	rc.left = ppos->clipstart;
	rc.right = ppos->clipend;

	/* check cell properties and colours */
	if (cd->props.valid & P_ALIGN) {
		align = cd->props.alignment;
	} else {
		align = P_LEFT;
	}
	//$ FUTURE: This prevents the user's font from being used when printing.
	// For now, that's better than having the output be really tiny, but this
	// needs to be fixed right eventually.
	if (!fPrinting && cd->props.valid & P_FONT) {
		hfontOld = SelectObject(hdc, cd->props.hFont);
	}

	// get y offset to center text vertically within cell
	GetTextMetrics(hdc, &tm);
	yOfs = (rc.bottom - rc.top - tm.tmHeight) / 2;

	/* set replacement chars and char widths */
	cxSpaceReplace = GetTextExtent(hdc, szSpaceReplace, 1);
	cxTabReplace = cxSpaceReplace * ptab->tabchars;

	/* set colours if not default */
	if (!fPrinting) {
		if (cd->props.valid & P_FCOLOUR) {
			fcol = cd->props.forecolour;
			fcolOld = SetTextColor(hdc, fcol);
		}
		if (cd->props.valid & P_FCOLOURWS) {
			fcolws = cd->props.forecolourws;
		}
		else {
			fcolws = fcol;
		}
		if (cd->props.valid & P_BCOLOUR) {
			/* there is a non-default background colour.
			* create a brush and fill the entire cell with it
			 */
			hbr = CreateSolidBrush(cd->props.backcolour);
			if (hbr)
			{
				FillRect(hdc, &rc, hbr);
				DeleteObject(hbr);
			}

			/* also set colour as background colour for the text */
			bkcolOld = SetBkColor(hdc, cd->props.backcolour);
		}
	}

	/* calc offset of text within cell for right-align or centering */
	if (align == P_LEFT) {
		cx = ptab->avewidth/2;
	} else {
		cx = 0;

		if (cd->pwzText) {
			GetTextExtentPoint32W(hdc, cd->pwzText, wcslen(cd->pwzText), &size);
		} else if (cd->ptext) {
			GetTextExtentPoint32A(hdc, cd->ptext, lstrlen(cd->ptext), &size);
		}
		cx = size.cx;

		if (align == P_CENTRE) {
			cx = (ppos->size - cx) / 2;
		} else {
			cx = ppos->size - cx - (ptab->avewidth/2);
		}
	}
	cx += ppos->start;

	/* expand tabs on output and show whitespace on output */
	x = 0;
	y = pline->linepos.start + yOfs;

	/* set search string for strpbrk fn;
	   don't search for space chars unless we're showing whitespace */
	if (!show_whitespace)
	{
		szCharSet[1] = '\0';
		wzCharSet[1] = '\0';
	}

	// determine the string to display (ansi/unicode).  if we have a string
	// and it's not empty, then loop and display it.
	chp = cd->ptext;
	pwch = cd->pwzText;
	if (pwch ? *pwch : (chp && *chp))
	{
		while (TRUE)
		{
			if (pwch)
			{
				pwchBreak = wcspbrk(pwch, wzCharSet);
				if (!pwchBreak)
					pwchBreak = pwch + wcslen(pwch);
			}
			else
			{
				tabp = My_mbspbrk(chp, szCharSet);
				if (!tabp)
					tabp = chp + lstrlen(chp);
			}

			/* perform output up to tab/space char */
			if (pwch)
				ExtTextOutW(hdc, x+cx, y, etoFlags, &rc, pwch, (UINT)(pwchBreak-pwch), NULL);
			else
				ExtTextOutA(hdc, x+cx, y, etoFlags, &rc, chp, (UINT)(tabp-chp), NULL);

			/* advance past the tab */
			if (pwch)
			{
				GetTextExtentPoint32W(hdc, pwch, (UINT)(pwchBreak - pwch), &size);
				pwch = pwchBreak;
			}
			else
			{
				GetTextExtentPoint32A(hdc, chp, (UINT)(tabp - chp), &size);
				chp = tabp;
			}
			x += size.cx;

			// bail if we hit null terminator
			if (pwch ? !*pwch : !*chp)
				break;

			/* handle tab chars */
			while (pwch ? (*pwch == '\t') : (*chp == '\t'))
			{
				/* print replacement char */
				if (show_whitespace)
				{
					if (!fPrinting)
						SetTextColor(hdc, fcolws);

					ExtTextOut(hdc, x + cx, y, etoFlags, &rc, szTabReplace, 1, NULL);

					if (!fPrinting)
						SetTextColor(hdc, fcol);
				}

				/* advance past the tab */
				if (cxTabReplace > 0)
					x += cxTabReplace - (x % cxTabReplace);
				if (pwch)
					pwch = ++pwchBreak;
				else
					chp = ++tabp;
			}

			/* handle space chars */
			if (show_whitespace)
			{
				while (pwch ? (*pwch == ' ') : (*chp == ' '))
				{
					/* replace space char with visible char */
					if (!fPrinting)
						SetTextColor(hdc, fcolws);

					ExtTextOut(hdc, x + cx, y, etoFlags, &rc, szSpaceReplace, 1, NULL);

					if (!fPrinting)
						SetTextColor(hdc, fcol);

					x += cxSpaceReplace;
					if (pwch)
						pwch = ++pwchBreak;
					else
						chp = ++tabp;
				}
			}
		}
	}

	/* reset colours to original if not default */
	if (!fPrinting) {
		if (cd->props.valid & P_FCOLOUR) {
			SetTextColor(hdc, fcolOld);
		}
		if (cd->props.valid & P_BCOLOUR) {
			SetBkColor(hdc, bkcolOld);
		}
		if (cd->props.valid & P_FONT) {
			SelectObject(hdc, hfontOld);
		}
	}

	/* now box cell if marked */
	if (!fPrinting) {
		if ((cd->props.valid & P_BOX)) {
			if (cd->props.box != 0) {
//				rcbox.top = pline->linepos.start;
				rcbox.top = y;
				rcbox.bottom = rcbox.top + pline->linepos.size;
				rcbox.left = ppos->start;
				rcbox.right = ppos->start + ppos->size;
				gtab_boxcell(hwnd, hdc, &rcbox, &rc, cd->props.box);
			}
		}
	}
}

/* fetch and paint the specified line */
void
gtab_paintline(HWND hwnd, HDC hdc, lpTable ptab, int line, BOOL show_whitespace, BOOL fPrinting)
{
	lpCellPos ppos = NULL;
	int i;
	RECT rc;

	if (line < 0 || line >= ptab->nlines)
		return;

	if (!fPrinting)
		GetClientRect(hwnd, &rc);

	gtab_updateline(hwnd, ptab, line);

	for (i = 0; i < ptab->hdr.ncols; i++) {
		ppos = &ptab->pcellpos[i];
		/* show whitespace iff the flag is set
		   and we're painting the main text column */
		if (ppos->clipstart < ppos->clipend) {
			gtab_paintcell(hwnd, hdc, ptab, line, i,
				       (show_whitespace && (i == 2)), fPrinting);
		}
	}

	if (!fPrinting && ppos) {
		rc.top = ptab->pdata[line].linepos.clipstart;
		rc.bottom = ptab->pdata[line].linepos.clipend;
		rc.left = ppos->clipend;
		FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
	}
}

void
gtab_paint(HWND hwnd)
{
    PAINTSTRUCT ps;
    int y, y2, i;
    HDC hDC = BeginPaint(hwnd, &ps);
    lpTable ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);

    if (!ptab) {
        FillRect(hDC, &ps.rcPaint, (HBRUSH)(COLOR_WINDOW + 1));
    } else {
        /* separator lines between fixed rows/columns
         * (ie headers) and the rest - if enabled
         */
        /* paint here first for good impression,
         * and again after to clean up!!
         */
        if (ptab->hdr.vseparator) {
            gtab_vsep(hwnd, ptab, hDC);
        }
        if (ptab->hdr.hseparator) {
            gtab_hsep(hwnd, ptab, hDC);
        }

        /* paint only the rows that need painting */
        for (i = 0; i < ptab->nlines; i++) {
            y = ptab->pdata[i].linepos.start;
            y2 = y + ptab->pdata[i].linepos.size;
            if ( (y <= ps.rcPaint.bottom) &&
                 (y2 >= ps.rcPaint.top)) {
                gtab_paintline(hwnd, hDC, ptab, i, ptab->show_whitespace, FALSE);
            }
        }
        if (ptab->hdr.vseparator) {
            gtab_vsep(hwnd, ptab, hDC);
        }
        if (ptab->hdr.hseparator) {
            gtab_hsep(hwnd, ptab, hDC);
        }
        if (ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, hDC);
        }
    }

    EndPaint(hwnd, &ps);
}


void
gtab_vsep(HWND hwnd, lpTable ptab, HDC hdc)
{
	int x;
	RECT rc;

	if (ptab->hdr.fixedcols < 1) {
		return;
	}
	x = ptab->pcellpos[ptab->hdr.fixedcols - 1].clipend+1;
	GetClientRect(hwnd, &rc);
	MoveToEx(hdc, x, rc.top, NULL);
	LineTo(hdc, x, rc.bottom);
}

void
gtab_hsep(HWND hwnd, lpTable ptab, HDC hdc)
{
	int y;
	RECT rc;

	if (ptab->hdr.fixedrows < 1) {
		return;
	}
	y = ptab->rowheight * ptab->hdr.fixedrows;
	GetClientRect(hwnd, &rc);
	MoveToEx(hdc, rc.left, y-1, NULL);
	LineTo(hdc, rc.right, y-1);
}

/* draw in (inverting) the dotted selection lines for tracking a col width
 */
void
gtab_drawvertline(HWND hwnd, lpTable ptab)
{
	RECT rc;
	HDC hdc;
	HPEN hpen;

	hdc = GetDC(hwnd);
	if (hdc)
	{
		SetROP2(hdc, R2_XORPEN);
		hpen = SelectObject(hdc, hpenDotted);
		GetClientRect(hwnd, &rc);

		MoveToEx(hdc, ptab->trackline1, rc.top, NULL);
		LineTo(hdc, ptab->trackline1, rc.bottom);
		if (ptab->trackline2 != -1) {
			MoveToEx(hdc, ptab->trackline2, rc.top, NULL);
			LineTo(hdc, ptab->trackline2, rc.bottom);
		}

		SelectObject(hdc, hpen);
		ReleaseDC(hwnd, hdc);
	}
}
	

/*
 * mark the selected line, if visible, in the style chosen by the
 * client app. This can be TM_SOLID, meaning an inversion of
 * the whole selected area or TM_FOCUS, meaning, inversion of the first
 * cell, and then a dotted focus rectangle for the rest.
 *
 * this function inverts either style, and so will turn the selection
 * both on and off.
 */
void
gtab_invertsel(HWND hwnd, lpTable ptab, HDC hdc_in)
{
	HDC hdc;
	int firstline, lastline;
	long startrow, lastrow, toprow, bottomrow;
	RECT rc;
	int lastcell;



	/* get the selection start and end rows ordered vertically */
	if (ptab->select.nrows == 0) {
	    return;
	} else if (ptab->select.nrows < 0) {
	    startrow = ptab->select.startrow + ptab->select.nrows + 1;
	    lastrow = ptab->select.startrow;
	} else {
	    startrow = ptab->select.startrow;
	    lastrow = ptab->select.startrow + ptab->select.nrows -1;
	}

	/* is selected area (or part of it) visible on screen ?  */
	firstline = gtab_rowtoline(hwnd, ptab, startrow);
	lastline = gtab_rowtoline(hwnd, ptab, lastrow);


	if (firstline < 0) {
	    toprow = gtab_linetorow(hwnd, ptab,
	    		ptab->hdr.fixedselectable ? 0: ptab->hdr.fixedrows);
	    if ((toprow >= startrow)  &&
		(toprow <= lastrow)) {
		    firstline = gtab_rowtoline(hwnd, ptab, toprow);
	    } else {
		return;
	    }
	} else {
	    toprow = 0;
	}


	if (lastline < 0) {
	    bottomrow = gtab_linetorow(hwnd, ptab, ptab->nlines-1);
	    if ((bottomrow <= lastrow) &&
		(bottomrow >=startrow)) {
		    lastline = gtab_rowtoline(hwnd, ptab, bottomrow);
	    } else {
		return;
	    }
	}


	rc.top = ptab->pdata[firstline].linepos.clipstart;
	rc.bottom = ptab->pdata[lastline].linepos.clipend;



	/* selection mode includes a flag TM_FOCUS indicating we should
	 * use a focus rect instead of the traditional inversion for
	 * selections in this table. This interferes with multiple backgrnd
	 * colours less.  However we still do inversion for fixedcols.
	 */

	lastcell = (int)(ptab->select.startcell + ptab->select.ncells - 1);


	/*
	 * invert the whole area for TM_SOLID or just the first
	 * cell for TM_FOCUS
	 */
	rc.left = ptab->pcellpos[ptab->select.startcell].clipstart;
	if (ptab->hdr.selectmode & TM_FOCUS) {
		rc.right = ptab->pcellpos[ptab->select.startcell].clipend;
	}else {
		rc.right = ptab->pcellpos[lastcell].clipend;
	}

	if (hdc_in == NULL) {
		hdc = GetDC(hwnd);
		if (!hdc)
			return;
	} else {
		hdc = hdc_in;
	}

	InvertRect(hdc, &rc);

	/*
	 * draw focus rectangle around remaining cells on this line, if there
	 * are any
	 */
	if (ptab->hdr.selectmode & TM_FOCUS) {
		/*
		 * now this is a real fudge. if we are drawing TM_FOCUS
		 * selection, and the real top line is off the top of the
		 * window, then the top of the focus rect will be drawn at
		 * the top of our window. If we then scroll up one line,
		 * a new focus rect will be drawn, but the old top of focus
		 * rect line will still be there as junk on the
		 * screen. To fix this, we have 2 choices: we undo the selection
		 * before every scroll (too slow) or we set the focus rect a little
		 * bigger if the real top line is off-window, so that the top line
		 * is clipped (as it should be). This latter is what we do here
		 */
		if (toprow > startrow) {
		    rc.top--;
		}
		if (ptab->select.ncells > 1) {
			rc.left = ptab->pcellpos[ptab->select.startcell+1].clipstart;
			rc.right = ptab->pcellpos[lastcell].clipend;
			DrawFocusRect(hdc, &rc);
		}
	}

	if (hdc_in == NULL) {
		ReleaseDC(hwnd, hdc);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\tpriv.h ===
/*
 * tpriv.h
 *
 * data structures used internally by table class.
 *
 * include after table.h
 */


#ifndef abs
#define abs(x)  (((x) > 0)? (x) : -(x))
#endif

/*  one of these per visible line */
typedef struct {
        CellPos linepos;        /* posn and clipping info for line */

        lpCellData pdata;       /* array of CellData structs for all cells */
} LineData, *lpLineData;


/* master info struct pointed to by window extra bytes */

typedef struct {
        /* table info */
        TableHdr        hdr;            /* main hdr info from owner */
        lpColProps      pcolhdr;        /* ptr to array of phdr->ncols hdrs */

        /* window info */
        int     avewidth;       /* font ave width - for default cell sizing */
        int     rowheight;      /* height of one row */
        int     rowwidth;       /* total width of one row in pixels */
        int     winwidth;       /* width of window */
        int     nlines;         /* actual lines currently visible */

        lpCellPos pcellpos;     /* array of cell position structs */

        /* scroll settings */
        long    scrollscale;    /* scaling factor (force 16-bit range) */
        long    toprow;         /* 0-based rownr of top moveable line */
        int     scroll_dx;      /* horz scroll posn in pixels. */

        /* column data */
        lpLineData pdata;       /* ptr to array of nlines of LineData */

        /* selection/dragging */
        UINT    trackmode;      /* current mouse-tracking mode */
        int     tracknr;        /* col or row being resized */
        int     trackline1;     /* currently drawn track lines */
        int     trackline2;
        BOOL    selvisible;     /* used during mouse-down: T if sel drawn */
        TableSelection select;

        // tab expansion
        int     tabchars;

        // show whitespace chars
        BOOL    show_whitespace;

} Table, *lpTable;

/* trackmode constants */
#define TRACK_NONE              0
#define TRACK_COLUMN            1
#define TRACK_CELL              2

/* private flags in CellData struct */
#define CELL_VALID      1

/* window extra bytes are used to hold the owner, heap and Table structs */
#define WW_OWNER        0                               /* HWND of owner */
#define WW_HEAP         (WW_OWNER + sizeof(HWND))       /* gmem heap */
#define WL_TABLE        (WW_HEAP + sizeof(HANDLE))      /* lpTable */
#define WLTOTAL         (WL_TABLE + sizeof(lpTable))    /* total extra bytes */

/* ---------- global data -------------------*/

extern HPEN hpenDotted;         /* in table.c */
extern HANDLE hVertCurs;        /* in table.c */
extern HANDLE hNormCurs;        /* in table.c */

/*------function prototypes ---------------------------------------*/

/* in table.c */

void gtab_init(void);    /* called from DLL startup function */
INT_PTR gtab_sendtq(HWND hwnd, UINT cmd, LPARAM lParam);
void gtab_invallines(HWND hwnd, lpTable ptab, int start, int count);
void gtab_setsize(HWND hwnd, lpTable ptab);
void gtab_calcwidths(HWND hwnd, lpTable ptab);
void gtab_deltable(HWND hwnd, lpTable ptab);
BOOL gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab);

/* in tpaint.c */
void gtab_paint(HWND hwnd);
void gtab_paintline(HWND hwnd, HDC hdc, lpTable ptab, int line, BOOL show_whitespace, BOOL fPrinting);
void gtab_paintunused(HWND hwnd, HDC hdc, lpTable ptab, int y);
void gtab_vsep(HWND hwnd, lpTable ptab, HDC hdc);
void gtab_hsep(HWND hwnd, lpTable ptab, HDC hdc);
void gtab_invertsel(HWND hwnd, lpTable ptab, HDC hdc_in);
void gtab_drawvertline(HWND hwnd, lpTable ptab);

/* in tscroll.c */
void gtab_dovscroll(HWND hwnd, lpTable ptab, long change);
void gtab_dohscroll(HWND hwnd, lpTable ptab, long change);
long gtab_linetorow(HWND hwnd, lpTable ptab, int line);
int gtab_rowtoline(HWND hwnd, lpTable ptab, long row);
void gtab_msg_vscroll(HWND hwnd, lpTable ptab, int opcode, int pos);
void gtab_msg_hscroll(HWND hwnd, lpTable ptab, int opcode, int pos);
void gtab_select(HWND hwnd, lpTable ptab, long row, long col, long nrows, long ncells, BOOL bNotify);
void gtab_enter(HWND hwnd, lpTable ptab, long row, long col, long nrows, long ncells);
void gtab_press(HWND hwnd, lpTable ptab, int x, int y);
void gtab_rightclick(HWND hwnd, lpTable ptab, int x, int y);
void gtab_release(HWND hwnd, lpTable ptab, int x, int y);
void gtab_move(HWND hwnd, lpTable ptab, int x, int y);
void gtab_dblclick(HWND hwnd, lpTable ptab, int x, int y);
void gtab_showsel(HWND hwnd, lpTable ptab, BOOL bToBottom);
void gtab_showsel_middle(HWND hwnd, lpTable ptab, long dyRowsFromTop);
int gtab_key(HWND hwnd, lpTable ptab, int vkey);
int gtab_mousewheel(HWND hwnd, lpTable ptab, DWORD fwKeys, int zDelta);

/* in tprint.c */
BOOL gtab_print(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext);
void gtab_boxcell(HWND hwnd, HDC hdc, LPRECT rcp, LPRECT pclip, UINT boxmode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\table.c ===
/*
 * standard table class.
 *
 * main interface functions.
 *
 * see table.h for interface description
 */

#include "windows.h"
#include "commdlg.h"
#include "gutils.h"

#include "table.h"
#include "tpriv.h"



/* global tools etc */
extern HANDLE hLibInst;
HANDLE hVertCurs;
HANDLE hNormCurs;
HPEN hpenDotted;
UINT gtab_msgcode;

/* function prototypes */
LRESULT gtab_wndproc(HWND, UINT, WPARAM, LPARAM);
void gtab_createtools(void);
void gtab_deltable(HWND hwnd, lpTable ptab);
lpTable gtab_buildtable(HWND hwnd, DWORD_PTR id);
void gtab_setsize(HWND hwnd, lpTable ptab);
void gtab_newsize(HWND hwnd, lpTable ptab);
void gtab_calcwidths(HWND hwnd, lpTable ptab);
BOOL gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab);
void gtab_invallines(HWND hwnd, lpTable ptab, int start, int count);
void gtab_append(HWND hwnd, lpTable ptab, int rows, DWORD_PTR id);

/*
 * initialise window class - called from DLL main init
 */
void
gtab_init(void)
{
    WNDCLASS wc;

    gtab_createtools();
    gtab_msgcode = RegisterWindowMessage(TableMessage);

    wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
    wc.lpfnWndProc = gtab_wndproc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = WLTOTAL;
    wc.hInstance = hLibInst;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszClassName = TableClassName;
    wc.lpszMenuName = NULL;

    RegisterClass(&wc);
}

void
gtab_createtools(void)
{
    hVertCurs = LoadCursor(hLibInst, "VertLine");
    hNormCurs = LoadCursor(NULL, IDC_ARROW);

    hpenDotted = CreatePen(PS_DOT, 1, RGB(0, 0, 0));
}

void
gtab_deltools(void)
{
    DeleteObject(hpenDotted);
}


LRESULT
gtab_wndproc(
            HWND hwnd,
            UINT msg,
            WPARAM wParam,
            LPARAM lParam
            )
{
    CREATESTRUCT FAR * csp;
    HWND hOwner;
    lpTable ptab;
    HANDLE hHeap;
    lpTableSelection pselect;
    long oldtop;
    long change;

    switch (msg) {

        case WM_CREATE:
            /* create window. set the wnd extra bytes to
             * contain the owner window, a heap and a null table.
             * Owner window is either in lParam or the parent.
             * Then wait for TM_NEWID.
             */
            csp = (CREATESTRUCT FAR *) lParam;
            if (csp->lpCreateParams == NULL) {
                hOwner = GetParent(hwnd);
            } else {
                hOwner = (HWND) csp->lpCreateParams;
            }
            ptab = NULL;
            hHeap = gmem_init();
            SetWindowLongPtr(hwnd, WL_TABLE, (LONG_PTR) ptab);
            SetWindowLongPtr(hwnd, WW_OWNER, (LONG_PTR) hOwner);
            SetWindowLongPtr(hwnd, WW_HEAP, (LONG_PTR) hHeap);

            SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
            SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
            break;

        case TM_NEWID:
            /* complete change of table.
             * close old table, discard memory and
             * build new table
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_sendtq(hwnd, TQ_CLOSE, ptab->hdr.id);
                gtab_deltable(hwnd, ptab);
                SetCursor(hNormCurs);
                SetWindowLongPtr(hwnd, WL_TABLE, 0);
            }
            if ( (ptab = gtab_buildtable(hwnd, (DWORD_PTR)lParam)) != NULL) {
                SetWindowLongPtr(hwnd, WL_TABLE, (LONG_PTR) ptab);
                gtab_setsize(hwnd, ptab);
            } else {
                SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
                SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
            }
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case TM_NEWLAYOUT:
            /* change of layout but for same id. no TQ_CLOSE,
             * but otherwise same as TM_NEWID
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_deltable(hwnd, ptab);
                SetCursor(hNormCurs);
                SetWindowLongPtr(hwnd, WL_TABLE, 0);
            }
            if ( (ptab = gtab_buildtable(hwnd, (DWORD_PTR)lParam)) != NULL) {
                SetWindowLongPtr(hwnd, WL_TABLE, (LONG_PTR) ptab);
                gtab_setsize(hwnd, ptab);
            } else {
                SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
                SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
            }
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case TM_REFRESH:
            /* data in table has changed. nrows may have
             * changed. ncols and col types have not changed
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_newsize(hwnd, ptab);
                gtab_sendtq(hwnd, TQ_SHOWWHITESPACE, (LPARAM) &ptab->show_whitespace);
            }
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case TM_SELECT:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                pselect = (lpTableSelection) lParam;

                gtab_select(hwnd, ptab, pselect->startrow,
                            pselect->startcell,
                            pselect->nrows,
                            pselect->ncells,
                            TRUE);
                gtab_showsel_middle(hwnd, ptab, pselect->dyRowsFromTop);
            }
            break;

        case TM_GETSELECTION:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                pselect = (lpTableSelection) lParam;

                *pselect = ptab->select;
            }
            break;

        case TM_PRINT:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
            if (ptab != NULL) {
                return gtab_print(hwnd, ptab, hHeap, (lpPrintContext) lParam);
            }
            return FALSE;

        case TM_SETTABWIDTH:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (!ptab)
                return 0;
            ptab->tabchars = (int)lParam;
            InvalidateRect(hwnd, NULL, FALSE);
            break;

        case TM_TOPROW:

            /* return top row. if wParam is TRUE, set lParam
             * as the new toprow
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab == NULL) {
                return(0);
            }
            oldtop = ptab->toprow;
            if ((wParam) && (lParam < ptab->hdr.nrows)) {
                change = (long)lParam - ptab->toprow;
                change -= ptab->hdr.fixedrows;
                gtab_dovscroll(hwnd, ptab, change);
            }
            return(oldtop);

        case TM_ENDROW:
            /* return the last visible row in the window */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab == NULL) {
                return(0);
            }
            return(ptab->nlines + ptab->toprow - 1);


        case TM_APPEND:
            /* new rows have been added to the end of the
             * table, but the rest of the table has not
             * been changed. Update without forcing redraw of
             * everything.
             * lParam contains the new total nr of rows
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_append(hwnd, ptab, (int) wParam, (DWORD_PTR)lParam);
                return(TRUE);
            }
            break;

        case WM_SIZE:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_setsize(hwnd, ptab);
            }
            break;

        case WM_ERASEBKGND:
            return TRUE;

        case WM_DESTROY:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_sendtq(hwnd, TQ_CLOSE, ptab->hdr.id);
                gtab_deltable(hwnd, ptab);
            }
            hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
            gmem_freeall(hHeap);
            break;

        case WM_SYSCOLORCHANGE:
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case WM_PAINT:
            gtab_paint(hwnd);
            break;

        case WM_HSCROLL:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_msg_hscroll(hwnd, ptab,
                                 GET_SCROLL_OPCODE(wParam, lParam),
                                 GET_SCROLL_POS(wParam, lParam));
            }
            break;

        case WM_VSCROLL:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_msg_vscroll(hwnd, ptab,
                                 GET_SCROLL_OPCODE(wParam, lParam),
                                 GET_SCROLL_POS(wParam, lParam));
            }
            break;

        case WM_MOUSEMOVE:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_move(hwnd, ptab, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            } else {
                SetCursor(hNormCurs);
            }
            break;

        case WM_LBUTTONDOWN:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_press(hwnd, ptab, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            }
            break;

        case WM_RBUTTONDOWN:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_rightclick(hwnd, ptab, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            }
            break;

        case WM_LBUTTONUP:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_release(hwnd, ptab,
                             (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            }
            break;

        case WM_LBUTTONDBLCLK:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_dblclick(hwnd, ptab,
                              (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            }
            break;

        case WM_KEYDOWN:
            /* handle key presses for cursor movement about
             * the table, and return/space for selection.
             * Any key we don't handle is passed to the owner window
             * for him to handle.
             * The table window should have the focus
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                if (gtab_key(hwnd, ptab, (int)wParam) != 0) {
                    /* pass key to owner since
                     * we don't know what to do with it
                     */
                    hOwner = (HANDLE) GetWindowLongPtr(hwnd, WW_OWNER);
                    return(SendMessage(hOwner, WM_KEYDOWN, wParam, lParam));
                } else {
                    return(0);
                }
            }
            break;

#ifdef WM_MOUSEWHEEL
        case WM_MOUSEWHEEL:
            ptab = (lpTable)GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                if (gtab_mousewheel(hwnd,ptab, LOWORD(wParam), (short)HIWORD(wParam))) {
                    // Input was not handled. Need to forward to the owner.
                    hOwner = (HWND)GetWindowLongPtr(hwnd, WW_OWNER);
                    return SendMessage(hOwner, WM_MOUSEWHEEL, wParam, lParam);
                }
            }
            break;
#endif

        default:
            return(DefWindowProc(hwnd, msg, wParam, lParam));
    }
    return(TRUE);
}

/*
 * send a table-query message to the owner window. returns message
 * value.
 */
INT_PTR
gtab_sendtq(
           HWND hwnd,
           UINT cmd,
           LPARAM lParam
           )
{
    HWND hOwner;

    hOwner = (HANDLE) GetWindowLongPtr(hwnd, WW_OWNER);
    return (SendMessage(hOwner, gtab_msgcode, cmd, lParam));
}

/*
 * free the memory allocated for the array of lines (each containing
 * an array of Cells, each containing an array of chars for the actual
 * data). Called on any occasion that would change the number of visible lines
 */
void
gtab_freelinedata(
                 HANDLE hHeap,
                 lpTable ptab
                 )
{
    int i, j, ncols;
    lpCellData cd;


    ncols = ptab->hdr.ncols;

    /* for each line */
    for (i = 0; i < ptab->nlines; i++) {
        /* for each cell */
        for (j = 0; j < ncols; j++) {
            /* free up the actual text space */
            cd = &ptab->pdata[i].pdata[j];
            gmem_free(hHeap, (LPSTR) cd->ptext, cd->nchars);
            gmem_free(hHeap, (LPSTR) cd->pwzText, cd->nchars);
        }
        /* dealloc array of CellData */
        gmem_free(hHeap, (LPSTR) ptab->pdata[i].pdata,
                  sizeof(CellData) * ncols);
    }
    /* de-alloc array of linedatas */
    gmem_free(hHeap, (LPSTR) ptab->pdata,
              sizeof(LineData) * ptab->nlines);
    ptab->pdata = NULL;
}

/* allocate and init array of linedatas (include cell array
 * and text for each cell)
 */
BOOL
gtab_alloclinedata(
                  HWND hwnd,
                  HANDLE heap,
                  lpTable ptab
                  )
{
    lpLineData pline;
    lpCellData cd;
    int i, j;

    ptab->pdata = (lpLineData) gmem_get(heap,
                                        sizeof(LineData) * ptab->nlines);
    if (ptab->pdata == NULL) {
        return(FALSE);
    }
    for (i = 0; i < ptab->nlines; i++) {
        pline = &ptab->pdata[i];
        pline->linepos.size = ptab->rowheight;
        pline->pdata = (lpCellData) gmem_get(heap,
                                             sizeof(CellData) * ptab->hdr.ncols);
        if (pline->pdata == NULL) {
            return(FALSE);
        }
        for (j = 0; j < ptab->hdr.ncols; j++) {
            cd = &pline->pdata[j];
            cd->props.valid = 0;
            cd->flags = 0;
            cd->nchars = ptab->pcolhdr[j].nchars;
            if (cd->nchars > 0) {
                cd->ptext = gmem_get(heap, cd->nchars);
                if (cd->ptext == NULL) {
                    return(FALSE);
                }
                cd->pwzText = 0;
            }
        }
    }
    return(TRUE);
}

/*
 * free up all table data structures. Called for new layout or new data.
 */
void
gtab_deltable(
             HWND hwnd,
             lpTable ptab
             )
{
    HANDLE hHeap;
    int ncols;

    if (ptab == NULL) {
        return;
    }
    hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
    ncols = ptab->hdr.ncols;

    if (ptab->pcolhdr != NULL) {
        gmem_free(hHeap, (LPSTR) ptab->pcolhdr,
                  sizeof(ColProps) * ncols);
    }
    if (ptab->pcellpos != NULL) {
        gmem_free(hHeap, (LPSTR) ptab->pcellpos,
                  sizeof(CellPos) * ncols);
    }
    if (ptab->pdata != NULL) {
        gtab_freelinedata(hHeap, ptab);
    }
    gmem_free(hHeap, (LPSTR) ptab, sizeof(Table));
}


/*
 * build up a Table struct (excluding data allocation and
 * anything to do with font or window size).
 * return ptr to this or NULL if error
 */
lpTable
gtab_buildtable(
               HWND hwnd,
               DWORD_PTR id
               )
{
    lpTable ptab;
    HANDLE hHeap;
    int ncols, i;
    ColPropsList cplist;

    hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
    ptab = (lpTable) gmem_get(hHeap, sizeof(Table));
    if (ptab == NULL) {
        return(NULL);
    }

    // get the tab width. most clients will not support this
    if (gtab_sendtq(hwnd, TQ_TABS, (LPARAM) &ptab->tabchars) == FALSE) {
        ptab->tabchars = TABWIDTH_DEFAULT;
    }

    // get the show whitespace value
    if (gtab_sendtq(hwnd, TQ_SHOWWHITESPACE, (LPARAM) &ptab->show_whitespace) == FALSE) {
        ptab->show_whitespace = FALSE;
    }

    /* get the row/column count from owner window */
    ptab->hdr.id = id;
    ptab->hdr.props.valid = 0;
    ptab->hdr.sendscroll = FALSE;
    if (gtab_sendtq(hwnd, TQ_GETSIZE, (LPARAM) &ptab->hdr) == FALSE) {
        return(NULL);
    }

    ncols = ptab->hdr.ncols;
    ptab->pcolhdr = (lpColProps) gmem_get(hHeap, sizeof(ColProps) * ncols);
    if (ptab->pcolhdr == NULL) {
        /* should prob send TQ_CLOSE at this point */
        return(NULL);
    }

    /* init col properties to default */
    for (i=0; i < ncols; i++) {
        ptab->pcolhdr[i].props.valid = 0;
        ptab->pcolhdr[i].nchars = 0;
    }
    /* get the column props from owner */
    cplist.plist = ptab->pcolhdr;
    cplist.id = id;
    cplist.startcol = 0;
    cplist.ncols = ncols;
    gtab_sendtq(hwnd, TQ_GETCOLPROPS, (LPARAM) &cplist);

    /* init remaining fields */
    ptab->pcellpos = (lpCellPos) gmem_get(hHeap, sizeof(CellPos) * ncols);
    if (ptab->pcellpos == NULL) {
        return(NULL);
    }

    ptab->scrollscale = 1;
    ptab->scroll_dx = 0;
    ptab->toprow = 0;
    ptab->pdata = NULL;
    ptab->nlines = 0;
    ptab->trackmode = TRACK_NONE;

    /* we have to notify owner of the current selection
     * whenever it is changed
     */
    ptab->select.id = id;
    gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);

    /* calc ave height/width, cell widths and min height.
     * these change only when cell properties / col count changes -
     * ie only on rebuild-header events
     */
    gtab_calcwidths(hwnd, ptab);
    return(ptab);
}

/* set sizes that are based on window size and scroll pos
 * set:
 *      winwidth
 *      nlines
 *      cellpos start, clip start/end
 * alloc linedata and init
 */
void
gtab_setsize(
            HWND hwnd,
            lpTable ptab
            )
{
    RECT rc;
    int nlines;
    HANDLE heap;
    long change;
    SCROLLINFO si;

    GetClientRect(hwnd, &rc);
    ptab->winwidth = rc.right - rc.left;
    nlines = (rc.bottom - rc.top) / ptab->rowheight;
    /* nlines is the number of whole lines - add one extra
     * for the partial line at the bottom
     */
    nlines += 1;

    /* alloc space for nlines of data - if nlines has changed */
    if (nlines != ptab->nlines) {
        heap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
        gtab_freelinedata(heap, ptab);
        ptab->nlines = nlines;
        if (!gtab_alloclinedata(hwnd, heap, ptab)) {
            ptab->nlines = 0;
            return;
        }
    }

    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE|SIF_RANGE;
    si.nMin = 0;

    /* set scroll vertical range */
    si.nMax = ptab->hdr.nrows;
    si.nPage = ptab->nlines;
    if (si.nMax < 0) {
        si.nMax = 0;
        change =  -(ptab->toprow);
    } else if (ptab->toprow > si.nMax) {
        change = si.nMax - ptab->toprow;
    } else {
        change = 0;
    }
    /* the scroll range must be 16-bits for Win3
     * scale until this is true
     */
    ptab->scrollscale = 1;
    while (si.nMax > 32766) {
        ptab->scrollscale *= 16;
        si.nMax /= 16;
        si.nPage /= 16;
    }
    if (!si.nPage)
        si.nPage = 1;

    SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
    gtab_dovscroll(hwnd, ptab, change);

    /* set horz scroll range */
    si.nMax = ptab->rowwidth;
    si.nPage = ptab->winwidth;
    if (si.nMax < 0) {
        si.nMax = 0;
        change = -(ptab->scroll_dx);
    } else if (ptab->scroll_dx > si.nMax) {
        change = si.nMax - ptab->scroll_dx;
    } else {
        change = 0;
    }
    /* horz scroll range will always be < 16 bits */
    SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);
    gtab_dohscroll(hwnd, ptab, change);
}

/* set column widths/height and totals (based on column props)
 * - no assumption of window size (see gtab_setsize)
 * sets avewidth,rowheight,cellpos.size,rowwidth (total of cellpos.size)
 */
void
gtab_calcwidths(
               HWND hwnd,
               lpTable ptab
               )
{
    int i, cxtotal, cx, ave;
    TEXTMETRIC tm = {0};
    TEXTMETRIC tmcol = {0};
    HDC hdc;
    lpProps hdrprops, cellprops;
    HFONT hfont;

    hfont = NULL;  /* eliminate spurious diagnostic, make code worse */
    hdrprops = &ptab->hdr.props;
    hdc = GetDC(hwnd);
    if (hdc)
    {
        GetTextMetrics(hdc, &tm);
        ptab->rowheight = tm.tmHeight + tm.tmExternalLeading;
        if (hdrprops->valid & P_FONT) {
            hfont = SelectObject(hdc, hdrprops->hFont);
        }
        GetTextMetrics(hdc, &tm);
        if (hdrprops->valid & P_FONT) {
            SelectObject(hdc, hfont);
        }
        ReleaseDC(hwnd, hdc);
    }
    else
    {
        // arbitrary, whatever...
        ptab->rowheight = 14;
        tm.tmHeight = 14;
        tm.tmAveCharWidth = 5;
    }

    /* get width and height of average character */
    ptab->avewidth = tm.tmAveCharWidth;
    if (tm.tmHeight + tm.tmExternalLeading < ptab->rowheight - 2 ||
        tm.tmHeight + tm.tmExternalLeading > ptab->rowheight) {
        // fudge so the default FixedSys (and anything of similar size)
        // doesn't vertically clip the System font used for line numbers,
        // filenames, etc.
        ptab->rowheight = tm.tmHeight;
        if (tm.tmExternalLeading)
            ptab->rowheight += tm.tmExternalLeading;
        else
            ptab->rowheight++;
    }
    if (hdrprops->valid & P_HEIGHT) {
        ptab->rowheight = hdrprops->height;
    }

    /* set pixel width of each cell (and add up for row total)
     * based on ave width * nr chars, unless P_WIDTH set
     */
    cxtotal = 0;
    for (i = 0; i < ptab->hdr.ncols; i++) {
        cellprops = &ptab->pcolhdr[i].props;

        if (cellprops->valid & P_WIDTH) {
            cx = cellprops->width;
        } else if (hdrprops->valid & P_WIDTH) {
            cx = hdrprops->width;
        } else {

            if (cellprops->valid & P_FONT) {
                hdc = GetDC(hwnd);
                if (hdc)
                {
                    hfont = SelectObject(hdc, cellprops->hFont);
                    GetTextMetrics(hdc, &tmcol);
                    SelectObject(hdc, hfont);
                    ReleaseDC(hwnd, hdc);
                    ave = tmcol.tmAveCharWidth;
                }
                else
                    ave = 5;        // arbitrary, whatever...
            } else {
                ave = ptab->avewidth;
            }
            /* ave width * nchars */
            cx =  ptab->pcolhdr[i].nchars + 1;
            cx *= ave;
        }
        /* add 2 pixels for box lines */
        cx += 2;
        ptab->pcellpos[i].size = cx;
        cxtotal += cx;
    }
    ptab->rowwidth = cxtotal;
}

/* called when row data + possible nrows changes.
 * other changes are ignored
 */
void
gtab_newsize(
            HWND hwnd,
            lpTable ptab
            )
{
    TableHdr hdr;

    /* get new row count */
    hdr = ptab->hdr;
    gtab_sendtq(hwnd, TQ_GETSIZE, (LPARAM) &hdr);
    if (hdr.nrows != ptab->hdr.nrows) {
        ptab->hdr.nrows = hdr.nrows;
        gtab_setsize(hwnd, ptab);
    }

    gtab_invallines(hwnd, ptab, 0, ptab->nlines);

    InvalidateRect(hwnd, NULL, FALSE);
}

void
gtab_invallines(
               HWND hwnd,
               lpTable ptab,
               int start,
               int count
               )
{
    int i, j;

    for (i = start; i < start + count; i++) {
        for (j = 0; j < ptab->hdr.ncols; j++) {
            ptab->pdata[i].pdata[j].flags = 0;
        }
    }
}

/* new rows have been added to the table. adjust the scroll range and
 * position, and redraw the rows if the end of the table is currently
 * visible.
 * rows = the new total row count.
 */
void
gtab_append(
           HWND hwnd,
           lpTable ptab,
           int rows,
           DWORD_PTR id
           )
{
    long oldrows;
    int line, nupdates;
    RECT rc;
    SCROLLINFO si;


    /* change to the new id */
    ptab->hdr.id = id;
    ptab->select.id = id;

    /* update the header, but remember the old nr of rows
     * so we know where to start updating
     */
    oldrows = ptab->hdr.nrows;

    /* check that the new nr of rows is not smaller. this is
     * illegal at this point and should be ignored
     */
    if (oldrows >= rows) {
        return;
    }

    ptab->hdr.nrows = rows;

    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE|SIF_RANGE;
    si.nMin = 0;

    /* set the vertical scroll range */
    si.nMax = rows;
    si.nPage = ptab->nlines;
    if (si.nMax < 0) {
        si.nMax = 0;
    }

    /* force the scroll range into 16-bits for win 3.1 */
    ptab->scrollscale = 1;
    while (si.nMax > 32766) {
        ptab->scrollscale *= 16;
        si.nMax /= 16;
        si.nPage /= 16;
    }
    if (!si.nPage)
        si.nPage = 1;

    /* now set the scroll bar range and position */
    SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
    if (si.nMax > 0) {
        SetScrollPos(hwnd, SB_VERT,
                     (int) (ptab->toprow / ptab->scrollscale), TRUE);
    }

    /* calculate which screen lines need to be updated - find what
     * screen line the start of the new section is at
     */
    line = gtab_rowtoline(hwnd, ptab, oldrows);
    if (line == -1) {
        /* not visible -> no more to do */
        return;
    }

    /* how many lines to update - rest of screen or nr of
     * new lines if less than rest of screen
     */
    nupdates = min((ptab->nlines - line), (int)(rows - oldrows));

    /* invalidate the screen line buffers to indicate data
     * needs to be refetch from parent window
     */
    gtab_invallines(hwnd, ptab, line, nupdates);

    /* calculate the region of the screen to be repainted -
     * left and right are same as window. top and bottom
     * need to be calculated from screen line height
     */

    GetClientRect(hwnd, &rc);
    rc.top += line * ptab->rowheight;
    rc.bottom = rc.top + (nupdates * ptab->rowheight);

    /* force a repaint of the updated region */
    InvalidateRect(hwnd, &rc, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\tscroll.c ===
/*
 * tscroll.c
 *
 * standard table class.
 *
 * scrolling and selection routines
 *
 * see table.h for interface description
 *
 * This implementation currently only supports TM_SINGLE, not TM_MANY
 * modes of selection.
 */

#include "windows.h"
#include "commdlg.h"
#include "gutils.h"

#include "table.h"
#include "tpriv.h"


VOID
gtab_extendsel(
    HWND hwnd,
    lpTable ptab,
    long startrow,
    long startcell,
    BOOL bNotify
);


/* handle a vscroll message */
void
gtab_msg_vscroll(HWND hwnd, lpTable ptab, int opcode, int pos)
{
    long change;

    switch(opcode) {
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        change = (pos * ptab->scrollscale) - ptab->toprow;
        break;

    case SB_LINEUP:
        change = -1;
        break;

    case SB_LINEDOWN:
        change = 1;
        break;

    case SB_PAGEUP:
        change = - (ptab->nlines - 3);
        if (change>=0)
            change = -1;    // consider nlines <=3!
        break;

    case SB_PAGEDOWN:
        change = (ptab->nlines - 3);
        if (change<=0)
            change = 1;     // consider nlines <=3!
        break;

    default:
        return;
    }
    gtab_dovscroll(hwnd, ptab, change);
}

/* handle a hscroll message */
void
gtab_msg_hscroll(HWND hwnd, lpTable ptab, int opcode, int pos)
{
    int change;

    switch(opcode) {
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        change = pos - ptab->scroll_dx;
        break;

    case SB_LINEUP:
        change = -(ptab->avewidth);
        break;

    case SB_LINEDOWN:
        change = ptab->avewidth;
        break;

    case SB_PAGEUP:
        change = - (ptab->winwidth * 2 / 3);
        break;

    case SB_PAGEDOWN:
        change = (ptab->winwidth * 2 / 3);
        break;

    default:
        return;
    }
    gtab_dohscroll(hwnd, ptab, change);
}



/*
 * set new vertical scroll pos,
 * adjust linedata array
 * set line win-relative start posns & clip top/bottom posns
 * revise display.
 */
void
gtab_dovscroll(HWND hwnd, lpTable ptab, long change)
{
    int cury, i;
    long ncopy;
    lpCellPos cp;
    LineData ldtemp;
    RECT rc, rcpaint;
    long range;
    long newtop;
    int newpos;
    BOOL fWasVisible = FALSE;

    if (ptab->selvisible)
    {
        fWasVisible = TRUE;
        ptab->selvisible = FALSE;
        gtab_invertsel(hwnd, ptab, NULL);
    }

    range = ptab->hdr.nrows - (ptab->nlines - 1);
    newtop = ptab->toprow + change;
    if (range < 0) {
        range = 0;
    }
    if (newtop > range) {
        change = range - ptab->toprow;
    } else if (newtop < 0) {
        change = -(ptab->toprow);
    }
    ptab->toprow += change;

    newpos = (int) (newtop / ptab->scrollscale);
    SetScrollPos(hwnd, SB_VERT, newpos, TRUE);

    if (ptab->hdr.sendscroll) {
        gtab_sendtq(hwnd, TQ_SCROLL, ptab->toprow);
    }

    /* adjust data ptrs rather than invalidate, to retain the
     * data we know is still valid
     */
    if (abs(change) >= ptab->nlines) {
        gtab_invallines(hwnd, ptab, ptab->hdr.fixedrows,
            ptab->nlines - ptab->hdr.fixedrows);
        InvalidateRect(hwnd, NULL, FALSE);
        change = 0;
    } else if (change < 0) {
        /* copy data down */
        ncopy = (ptab->nlines - ptab->hdr.fixedrows) - abs(change);
        for (i =  ptab->nlines - 1;
                i >= (ptab->hdr.fixedrows + abs(change)); i--) {
            ldtemp = ptab->pdata[i - abs(change)];
            ptab->pdata[i - abs(change)] = ptab->pdata[i];
            ptab->pdata[i] = ldtemp;
        }
        gtab_invallines(hwnd, ptab,
                ptab->hdr.fixedrows, (int) abs(change));
    } else if (change > 0) {
        ncopy = (ptab->nlines - ptab->hdr.fixedrows) - change;
        for (i = ptab->hdr.fixedrows;
                i < (ncopy + ptab->hdr.fixedrows); i++) {
            ldtemp = ptab->pdata[i + change];
            ptab->pdata[i + change] = ptab->pdata[i];
            ptab->pdata[i] = ldtemp;
        }
        gtab_invallines(hwnd, ptab,
            (int) ncopy + ptab->hdr.fixedrows, (int) change);
    }

    /* scroll window */
    GetClientRect(hwnd, &rc);
    rcpaint = rc;
    if (change > 0) {
        rc.top += (int) (change + ptab->hdr.fixedrows) * ptab->rowheight;
        rcpaint.top = (ptab->hdr.fixedrows * ptab->rowheight);
        rcpaint.top += rc.bottom - rc.top;
    } else if (change < 0) {
        rc.top += (ptab->hdr.fixedrows * ptab->rowheight);
        rc.bottom += (int) (change * ptab->rowheight);
        rcpaint.bottom -= rc.bottom - rc.top;
    }

    /* loop through each line setting relative posn and clipping */

    /* set up all rows  - the fixed/moveable difference for
     * rows is made at fetch-time during painting, when we remember
     * which absolute row nr to ask for, for a given screen line
     */
    cury = 0;
    for (i = 0; i < ptab->nlines; i++) {
        cp = &ptab->pdata[i].linepos;
        cp->start = cury;
        cp->clipstart = cury;
        cp->clipend = cury + cp->size;
        cury += cp->size;
    }

    /* now move and repaint the window */
    if (change != 0) {
        if (rc.top < rc.bottom) {
            ScrollWindow(hwnd, 0, (int) -(change * ptab->rowheight),
                &rc, NULL);
        }

        // don't repaint the fixed rows
        rc.top = 0;
        rc.bottom = ptab->hdr.fixedrows * ptab->rowheight;
        ValidateRect(hwnd, &rc);

        /* force repaint now, not just post message for later,
         * since we want to repaint that line before the next
         * scroll down occurs
         */
        ValidateRect(hwnd, &rcpaint);
        RedrawWindow(hwnd, &rcpaint, NULL,
                RDW_NOERASE | RDW_INVALIDATE | RDW_INTERNALPAINT);

    }

    if (fWasVisible)
    {
        gtab_invertsel(hwnd, ptab, NULL);
        ptab->selvisible = TRUE;
    }
}

/*
 * set new horizontal scroll pos,
 * set col win-relative start posns & clip left/right posns
 * revise display.
 */
void
gtab_dohscroll(HWND hwnd, lpTable ptab, long change)
{
    int curx, i;
    int moveable;
    lpCellPos cp;
    int newdx, range;


    /* check that the new scroll pos is still within the valid range */
    range = ptab->rowwidth - ptab->winwidth;
    newdx = ptab->scroll_dx + (int) change;
    if (range < 0) {
        range = 0;
    }
    if (newdx > range) {
        change = range - ptab->scroll_dx;
    } else if (newdx < 0) {
        change = -(ptab->scroll_dx);
    }
    ptab->scroll_dx += (int) change;

    SetScrollPos(hwnd, SB_HORZ, ptab->scroll_dx, TRUE);
    if (ptab->hdr.fixedcols > 0) {
        RECT rc;
        GetClientRect(hwnd, &rc);
        rc.left = ptab->pcellpos[ptab->hdr.fixedcols - 1].clipend;
        InvalidateRect(hwnd, &rc, FALSE);
    } else {
        InvalidateRect(hwnd, NULL, FALSE);
    }

    /* loop through each col setting relative posn and clipping */
    /* clip off 1 pixel left and right (we added 2 on to size for this) */

    /* first set up fixed columns */
    curx = 0;
    for (i = 0; i < ptab->hdr.fixedcols; i++) {
        cp = &ptab->pcellpos[i];
        cp->start = curx + 1;
        cp->clipstart = cp->start;
        cp->clipend = cp->start + cp->size - 2;
        curx += cp->size;
    }

    /* now moveable columns. remember start of moveable cols */
    moveable = curx;
    curx = - ptab->scroll_dx;       /* rel. pos of col */
    for (i = ptab->hdr.fixedcols; i < ptab->hdr.ncols; i++) {
        cp = &ptab->pcellpos[i];
        cp->start = curx + moveable + 1;
        cp->clipstart = max(moveable+1, cp->start);
        cp->clipend = cp->start + cp->size - 2;
        curx += cp->size;
    }
}

/*
 * convert screen line nr to table row nr
 */
long
gtab_linetorow(HWND hwnd, lpTable ptab, int line)
{
    if (line < ptab->hdr.fixedrows) {
        return(line);
    }

    return (line + ptab->toprow);
}

/*
 * convert table row nr to screen line nr or -1 if not on screen
 */
int
gtab_rowtoline(HWND hwnd, lpTable ptab, long row)
{
    if (row < ptab->hdr.fixedrows) {
        return( (int) row);
    }

    row -= ptab->toprow;
    if ((row >= ptab->hdr.fixedrows) && (row < ptab->nlines)) {
        return ( (int) row);
    }
    return(-1);
}


/*
 * check if a given location is within the current selection.
 * Returns true if it is inside the current selection, or false if
 * either there is no selection, or the row, cell passed is outside it.
 */
BOOL
gtab_insideselection(
    lpTable ptab,
    long row,
    long cell)
{
    long startrow, endrow;
    long startcell, endcell;

    if (0 == ptab->select.nrows) {
        // no selection
        return FALSE;
    }

    // selection maintains anchor point as startrow,
    // so the selection can extend forwards or backwards from there.
    // need to convert to forward only for comparison
    startrow = ptab->select.startrow;
    if (ptab->select.nrows < 0) {
        endrow = startrow;
        startrow += ptab->select.nrows + 1;
    } else {
        endrow = startrow + ptab->select.nrows - 1;
    }
    if ((row < startrow) || (row > endrow)) {
        return FALSE;
    }

    // if we are in row-select mode, then that's it - its inside
    if (ptab->hdr.selectmode & TM_ROW) {
        return TRUE;
    }

    // same calculation for cells
    startcell = ptab->select.startcell;
    if (ptab->select.ncells < 0) {
        endcell = startcell;
        startcell += ptab->select.ncells + 1;
    } else {
        endcell = startcell + ptab->select.ncells - 1;
    }
    if ((cell < startcell) || (cell > endcell)) {
        return FALSE;
    }

    return TRUE;
}



/*
 * replace old selection with new. Notify owner if bNotify. Change
 * display to reflect new display.
 */
void
gtab_select(
        HWND hwnd,
        lpTable ptab,
        long row,
        long col,
        long nrows,
        long ncells,
        BOOL bNotify)
{

    /* if in ROW mode, force col and ncells to reflect the entire row. */
    if (ptab->hdr.selectmode & TM_ROW) {
        col = 0;
        ncells = ptab->hdr.ncols;
    }

    /* clear existing sel if valid and visible */
    if ((ptab->select.nrows != 0) && (ptab->selvisible == TRUE)) {

        /* only clear sel if it is different from the new one */
        if ((ptab->select.startrow != row) ||
                (ptab->select.startcell != col) ||
                (ptab->select.nrows != nrows) ||
                (ptab->select.ncells != ncells)) {

            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = FALSE;
        }
    }

    /* set select fields and send TQ_SELECT */
    if (row < ptab->hdr.nrows) {
        ptab->select.startrow = row;
        ptab->select.startcell = col;
        ptab->select.nrows = nrows;
        ptab->select.ncells = ncells;
    } else {
        ptab->select.nrows = 0;
        ptab->select.startrow = 0;
        ptab->select.startcell = 0;
        ptab->select.ncells = 0;
    }

    if (bNotify) {
        gtab_sendtq(hwnd, TQ_SELECT, (LPARAM) &ptab->select);
    }

    /* paint in selection */
    if (nrows != 0) {
        if (!ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = TRUE;
        }
    } else {
        if (ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = FALSE;
        }
        ptab->selvisible = FALSE;
    }
}

/*
 * convert window y co-ord to a line nr
 */
int
gtab_ytoline(HWND hwnd, lpTable ptab, int y)
{
    return(y / ptab->rowheight);
}

/*
 * convert window x co-ord to a cell nr
 */
int
gtab_xtocol(HWND hwnd, lpTable ptab, int x)
{
    int i;
    lpCellPos ppos;

    for (i = 0; i < ptab->hdr.ncols; i++) {
        ppos = &ptab->pcellpos[i];
        if (ppos->clipstart < ppos->clipend) {
            if ( (x >= ppos->clipstart) && (x < ppos->clipend)) {
                return(i);
            }
        }
    }
    return(-1);
}


/*
 * check if x co-ord is 'near' (+- 2 pixels) the right border of given cell
 */
BOOL
gtab_isborder(HWND hwnd, lpTable ptab, long x, long col)
{

    if (abs(ptab->pcellpos[col].clipend - x) < 2) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*
 * set selection and send 'TQ_ENTER' event to owner
 */
void
gtab_enter(HWND hwnd, lpTable ptab, long row, long col, long nrows,
        long ncells)
{
    /* clear existing sel if valid and visible */
    if ((ptab->select.nrows != 0) && (ptab->selvisible == TRUE)) {

        /* only clear sel if it is different from the new one */
        if ((ptab->select.startrow != row) ||
                (ptab->select.startcell != col) ||
                (ptab->select.nrows != nrows) ||
                (ptab->select.ncells != ncells)) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = FALSE;
        }
    }

    /* set select fields and send TQ_ENTER */
    if (row < ptab->hdr.nrows) {
        ptab->select.startrow = row;
        ptab->select.startcell = col;
        ptab->select.nrows = nrows;
        ptab->select.ncells = ncells;
    } else {
        ptab->select.nrows = 0;
        ptab->select.startrow = 0;
        ptab->select.startcell = 0;
        ptab->select.ncells = 0;
    }

    /* paint in selection */
    if (nrows != 0) {
        if (!ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = TRUE;
        }
        /* do this at end because it could cause a layout-change */
        gtab_sendtq(hwnd, TQ_ENTER, (LPARAM) &ptab->select);
    } else {
        if (ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
        }
        ptab->selvisible = FALSE;
    }
}


/*
 * start re-sizing a column
 */
void
gtab_trackcol(HWND hwnd, lpTable ptab, long col, long x)
{

    /* ensure we see the mouse-up */
    SetCapture(hwnd);
    ptab->trackmode = TRACK_COLUMN;
#ifdef WIN32
    ptab->tracknr = col;
    ptab->trackline1 = x;
#else
    // maximum 32767 columns is a reasonable limit!
    ptab->tracknr = (int) (col & 0x7fff);
    ptab->trackline1 = (int) (x & 0x7fff);
#endif

    /* if line at other side of cell is visible, draw that too */
    if (ptab->pcellpos[col].start >= ptab->pcellpos[col].clipstart) {
        ptab->trackline2 = ptab->pcellpos[col].start;
    } else {
        ptab->trackline2 = -1;
    }
    gtab_drawvertline(hwnd, ptab);
}


/*
 * called on right-click events. Select the cell clicked on, and if
 * valid, send on to owner for any context-menu type operation
 */
void
gtab_rightclick(HWND hwnd, lpTable ptab, int x, int y)
{
    long cell, ncells;
    long row;
    HWND hOwner;

    /* find which col, row he selected */
    cell = gtab_xtocol(hwnd, ptab, x);
    if (cell == -1) {
        return;
    }
    row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));

    /* is he selecting a disabled fixed area ? */
    if ( (row < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols)) {
        if (ptab->hdr.fixedselectable == FALSE) {
            return;
        }
    }

    // ignore if beyond data
    if ((row >= ptab->hdr.nrows) ||
            (cell >= ptab->hdr.ncols)) {
        return;
    }

    /* is this within the already-selected area? */
    if (!gtab_insideselection(ptab, row, cell)) {
        // no selection, or clicked outside the selection - make new selection
        // before sending the right-click

        // if shift is down, extend selection
        if (GetKeyState(VK_SHIFT) & 0x8000) {
            gtab_extendsel(hwnd, ptab, row, cell, TRUE);
        } else {
            /* record and paint new selection */

            if (ptab->hdr.selectmode & TM_ROW) {
                cell = 0;
                ncells = ptab->hdr.ncols;
            } else {
                ncells = 1;
            }
            gtab_select(hwnd, ptab, row, cell, 1, ncells, TRUE);
        }
    }

    // now we have sent the selection, pass the message onto him
    hOwner = (HANDLE) GetWindowLongPtr(hwnd, WW_OWNER);
    SendMessage(hOwner, WM_RBUTTONDOWN, 0, MAKELONG( (short)x, (short)y));
}


/*
 * called on mouse-down events. decide what to start tracking.
 */
void
gtab_press(HWND hwnd, lpTable ptab, int x, int y)
{
    long cell, ncells;
    long row;

    if (ptab->trackmode != TRACK_NONE) {
        return;
    }

    /* has he grabbed a cell-edge to resize ? */
    cell = gtab_xtocol(hwnd, ptab, x);
    if (cell == -1) {
        return;
    }
    if (gtab_isborder(hwnd, ptab, x, cell)) {
        gtab_trackcol(hwnd, ptab, cell, x);
        return;
    }
    if ( (cell > 0) && gtab_isborder(hwnd, ptab, x, cell-1)) {
        gtab_trackcol(hwnd, ptab, cell, x);
        return;
    }

    /* find which line he selected */
    row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));

    /* is he selecting a disabled fixed area ? */
    if ( (row < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols)) {
        if (ptab->hdr.fixedselectable == FALSE) {
            return;
        }
    }

    // ignore if beyond data
    if ((row >= ptab->hdr.nrows) ||
            (cell >= ptab->hdr.ncols)) {
        return;
    }


    /* ok, start cell selection */
    ptab->trackmode = TRACK_CELL;
    SetCapture(hwnd);

    /* record and paint new selection */

    if (ptab->hdr.selectmode & TM_ROW) {
        cell = 0;
        ncells = ptab->hdr.ncols;
    } else {
        ncells = 1;
    }

    /*
     * if the shift key is down, then extend the selection to this
     * new anchor point, rather than create a new selection
     */
    if (GetKeyState(VK_SHIFT) & 0x8000) {
        gtab_extendsel(hwnd, ptab, row, cell, FALSE);
    } else {
        gtab_select(hwnd, ptab, row, cell, 1, ncells, FALSE);
    }
    return;
}

/*
 * called on mouse-up. complete any tracking that was happening
 */
void
gtab_release(HWND hwnd, lpTable ptab, int x, int y)
{
    lpCellPos ppos;
    lpProps pprop;
    long row, cell;
    int cx;

    switch(ptab->trackmode) {

    case TRACK_NONE:
        return;

    case TRACK_COLUMN:
        /* erase marker lines */
        gtab_drawvertline(hwnd, ptab);
        ReleaseCapture();
        ptab->trackmode = TRACK_NONE;

        /* adjust cell width */
        ppos = &ptab->pcellpos[ptab->tracknr];
        cx = ptab->trackline1 - ppos->start;
        pprop = &ptab->pcolhdr[ptab->tracknr].props;
        pprop->valid |= P_WIDTH;
        pprop->width = cx;
        gtab_calcwidths(hwnd, ptab);
        gtab_setsize(hwnd, ptab);
        InvalidateRect(hwnd, NULL, FALSE);
        return;

    case TRACK_CELL:
        row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));
        cell = gtab_xtocol(hwnd, ptab, x);

        ReleaseCapture();
        ptab->trackmode = TRACK_NONE;

        // ignore if before or beyond data
        if ( (row < ptab->hdr.fixedrows) ||
             (cell < ptab->hdr.fixedcols)) {
            if (ptab->hdr.fixedselectable == FALSE) {
                gtab_select(
                    hwnd,
                    ptab,
                    ptab->select.startrow,
                    ptab->select.startcell,
                    ptab->select.nrows,
                    ptab->select.ncells,
                    TRUE);

                return;
            }
        }

        if ((row >= ptab->hdr.nrows) ||
                (cell >= ptab->hdr.ncols)) {
            gtab_select(
                    hwnd,
                    ptab,
                    ptab->select.startrow,
                    ptab->select.startcell,
                    ptab->select.nrows,
                    ptab->select.ncells,
                    TRUE);
            return;
        }

        /*
         * Extend to this new selection end point
         * we used to only do this if shift key pressed, but that
         * is not a good UI.
         */
        gtab_extendsel(hwnd, ptab, row, cell, TRUE);
        return;
    }
}


/* called on mouse-move. if tracking - adjust position, if not,
 * set correct cursor
 */
void
gtab_move(HWND hwnd, lpTable ptab, int x, int y)
{
    BOOL fOK;
    int line;
    long row;
    int col;
    lpCellPos ppos;

    switch(ptab->trackmode) {

    case TRACK_NONE:
        col = gtab_xtocol(hwnd, ptab, x);
        if (col == -1) {
            SetCursor(hNormCurs);
            return;
        }
        if (gtab_isborder(hwnd, ptab, x, col)) {
            SetCursor(hVertCurs);
            return;
        }
        if ( (col > 0) && gtab_isborder(hwnd, ptab, x, col-1)) {
            SetCursor(hVertCurs);
            return;
        }
        SetCursor(hNormCurs);
        return;

    case TRACK_CELL:
        line = gtab_ytoline(hwnd, ptab, y);

        // we used to only allow drag to extend
        // the selection if the shift key was down.
        // this doesn't seem to work as a UI - you expect
        // to drag and extend.

        /* if extending selection then
         * allow scrolling by dragging off window
         */
        if (line < 0) {
            gtab_dovscroll(hwnd, ptab, -1);
            line = gtab_ytoline(hwnd, ptab, y);
        } else if (line >=  ptab->nlines) {
            gtab_dovscroll(hwnd, ptab, 1);
            line = gtab_ytoline(hwnd, ptab, y);
        }


        row = gtab_linetorow(hwnd, ptab, line);
        col = gtab_xtocol(hwnd, ptab, x);

        // ignore if before or beyond data
        if ( (row < ptab->hdr.fixedrows) || (col < ptab->hdr.fixedcols)) {
            if (ptab->hdr.fixedselectable == FALSE) {
                return;
            }
        }

        if ((row >= ptab->hdr.nrows) ||
            (col >= ptab->hdr.ncols)) {
            return;
        }

        /*
         * extend to this new selection end point
         */
        gtab_extendsel(hwnd, ptab, row, col, FALSE);
        return;

    case TRACK_COLUMN:
        /* check that new x is still visible/valid */
        ppos = &ptab->pcellpos[ptab->tracknr];
        fOK = FALSE;

        if (ptab->tracknr < ptab->hdr.fixedcols)  {
            if ((x > ppos->start) && (x < ptab->winwidth)) {
                fOK = TRUE;
            }
        } else {
            if ((x > ppos->clipstart) && (x < ptab->winwidth)) {
                fOK = TRUE;
            }
        }
        if (fOK == TRUE) {
            gtab_drawvertline(hwnd, ptab);
            ptab->trackline1 = x;
            gtab_drawvertline(hwnd, ptab);
        }
        return;
    }
}

/* dbl-click - send an TQ_ENTER event to the owner (if valid) */
void
gtab_dblclick(HWND hwnd, lpTable ptab, int x, int y)
{
    int cell, line;
    long row;

    line = gtab_ytoline(hwnd, ptab, y);
    cell = gtab_xtocol(hwnd, ptab, x);
    if ( (line < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols) ) {
        if (!ptab->hdr.fixedselectable) {
            return;
        }
    }
    row = gtab_linetorow(hwnd, ptab, line);

    if (ptab->hdr.selectmode & TM_ROW) {
        gtab_enter(hwnd, ptab, row, 0, 1, ptab->hdr.ncols);
    } else {
        gtab_enter(hwnd, ptab, row, cell, 1, 1);
    }
}

/*
 * move selection area to visible part of window. argument bToBottom
 * indicates whether to move the line onto the bottom or the top of the
 * window if not visible - this affects the smoothness of scrolling
 * line-by-line.
 */
void
gtab_showsel(HWND hwnd, lpTable ptab, BOOL bToBottom)
{
    int line;
    long change;

    line = gtab_rowtoline(hwnd, ptab, ptab->select.startrow);

    /* move up if last line or not at all visible */
    if ( (line < 0) || line == (ptab->nlines - 1)) {
        change = ptab->select.startrow - ptab->toprow;
        if (bToBottom) {
            /* change to bottom of window. subtract 2 not 1
             * since nlines includes one line that is only
             * partly visible
             */
            change -= (ptab->nlines - 2);
        }
        change -= ptab->hdr.fixedrows;
        gtab_dovscroll(hwnd, ptab, change);
    }
    /* add support for TM_CELL here! */
}

/*
 * scroll the window so that if possible, the selected row is in the
 * middle 60% of the screen so that context around it is visible.
 */
void
gtab_showsel_middle(HWND hwnd, lpTable ptab, long dyRowsFromTop)
{
    int line = ptab->select.startrow;
    long change = 0;
    int mid_top, mid_end;
    BOOL fScroll = FALSE;

    if (dyRowsFromTop >= 0)
    {
        fScroll = TRUE;
        change = (ptab->select.startrow - dyRowsFromTop) - ptab->toprow;
        change -= ptab->hdr.fixedrows;
    }

    /* is this within the middle 60 % ?  */
    mid_top = ptab->toprow + (ptab->nlines * 20 / 100);
    mid_end = ptab->toprow + (ptab->nlines * 80 / 100);
    if ((line < mid_top + change) || (line > mid_end + change))
    {
        /* no - scroll so that selected line is at
         * the 20% mark
         */
        fScroll = TRUE;
        change = (ptab->select.startrow - mid_top);
        change -= ptab->hdr.fixedrows;
    }

    if (fScroll)
    {
        gtab_dovscroll(hwnd, ptab, change);
    }

    /* again - need code here for TM_CELL mode to ensure that
     * active cell is horizontally scrolled correctly
     */
}


/*
 * extend the selection to set the new anchor point as startrow, startcell.
 *
 * nrows and ncells will then be set to include the end row of the previous
 * selection. nrows, ncells < 0 indicate left and up. -1 and +1 both indicate
 * just one cell or row selected.
 */
VOID
gtab_extendsel(
    HWND hwnd,
    lpTable ptab,
    long startrow,
    long startcell,
    BOOL bNotify
)
{
    long endrow, endcell, nrows, ncells;

    /*
     * if no current selection, then just select the new anchor point
     */
    if (ptab->select.nrows == 0) {
        gtab_select(hwnd, ptab, startrow, startcell, 1,
            (ptab->hdr.selectmode & TM_ROW) ? ptab->hdr.ncols:1,
            bNotify);
        return;
    }

    if (startrow >= ptab->hdr.nrows) {
        startrow = ptab->hdr.nrows -1;
    } else if (startrow < 0) {
        startrow = 0;
    }
    if (startcell >= ptab->hdr.ncols) {
        startcell = ptab->hdr.ncols-1;
    } else if (startcell < 0) {
        startcell = 0;
    }



    /* calculate the row just beyond the selection
     * this is one above for upwards sels, and one below for
     * downard-extending sels. Then adjust down or up one
     * to be the actual (inclusive) last row.
     */
    endrow = ptab->select.startrow + ptab->select.nrows;
    if (ptab->select.nrows < 0) {
        endrow++;
    } else {
        endrow--;
    }

    if (endrow >= ptab->hdr.nrows) {
        endrow = ptab->hdr.nrows-1;
    }
    nrows = endrow - startrow;

    if (nrows >= 0) {
        // convert from exclusive to inclusive
        nrows++;
    } else {
        // convert from exclusive to inclusive
        nrows--;
    }

    /* same calculation for cells */
    endcell = ptab->select.startcell + ptab->select.ncells;
    if (ptab->select.ncells < 0) {
        endcell++;
    } else {
        endcell--;
    }
    ncells = endcell - startcell;
    if (ncells >= 0) {
        ncells++;
    } else {
        ncells--;
    }
    gtab_select(hwnd, ptab, startrow, startcell, nrows, ncells, bNotify);
}



/* move the selection a specified nr of rows or cells
 * if no selection, select first visible unit
 *
 * if bExtend is true and there is a current selection, then extend it rather than
 * replace it. Note that (startrow, startcell) will always be set to the newly
 * selected position - this is the anchor point. nrows or ncells may be negative
 * if the selection extends upwards above the anchor. nrows == -1 is the same
 * as nrows == 1, meaning only the current row is visible. Similarly
 * (in TM_CELL mode), ncells may be negative.
 *
 * Move the selection (ie anchor point) to make it visible. bToBottom
 * indicates whether it should be moved to the bottom or the top
 * of the window.
 */
VOID
gtab_changesel(
    HWND hwnd,
    lpTable ptab,
    long rowincr,
    int cellincr,
    BOOL bToBottom,
    BOOL bExtend
)
{
    long row, col, ncols;

    /* is there a selection ? */
    if (ptab->select.nrows == 0) {

        /* no selection - force a selection
         * at the first visible unit
         */
        if (ptab->hdr.fixedselectable) {
            row = 0;
            col = 0;
        } else {
            row = gtab_linetorow(hwnd, ptab, ptab->hdr.fixedrows);
            /* should really check for first visible cell */
            col = ptab->hdr.fixedcols;
        }
        ncols = 1;
        if (ptab->hdr.selectmode & TM_ROW) {
            col = 0;
            ncols = ptab->hdr.ncols;
        }
        gtab_select(hwnd, ptab, row, col, 1, ncols, TRUE);

    } else {
        /* move the anchor point by rowincr, cellincr */
        row = ptab->select.startrow + rowincr;
        col = ptab->select.startcell + cellincr;


        /*
         * ensure that new anchor point is in a valid position
         */

        while (col >= ptab->hdr.ncols) {
            col -= ptab->hdr.ncols;
            row++;
        }
        while (col < 0) {
            col += ptab->hdr.ncols;
            row--;
        }
        if (row < 0) {
            row = 0;
        }
        if (row >= ptab->hdr.nrows) {
            row = ptab->hdr.nrows-1;
        }
        /* check we haven't moved into non-selectable region */
        if ((row < ptab->hdr.fixedrows) &&
            (!ptab->hdr.fixedselectable)) {
                    row = ptab->hdr.fixedrows;
        }

        if (bExtend) {
            gtab_extendsel(hwnd, ptab, row, col, TRUE);
        } else {
            gtab_select(
                hwnd,
                ptab,
                row,
                col,
                1,
                (ptab->hdr.selectmode & TM_ROW) ? ptab->hdr.ncols : 1,
                TRUE);
        }
    }

    /* ensure selection visible */
    gtab_showsel(hwnd, ptab, bToBottom);
}

/*
 * set the topmost selectable unit in window as the selection
 *
 * if bExtend is TRUE, then extend the selection to include this, rather
 * than replacing the existing selection. Note that (startrow, startcell)
 * is always the anchor point - ie most recently selected end, and the
 * (nrows, ncells) can be + or - to extend the selection downwards or upwards.
 */
void
gtab_selhome(HWND hwnd, lpTable ptab, BOOL bExtend)
{
    long startrow, startcell, ncells;

    if (ptab->hdr.selectmode & TM_ROW) {
        ncells = ptab->hdr.ncols;
    } else {
        ncells = 1;
    }
    startcell = 0;


    if (ptab->hdr.fixedselectable) {
        startrow = gtab_linetorow(hwnd, ptab, 0);
    } else {
        startrow = gtab_linetorow(hwnd, ptab, ptab->hdr.fixedrows);
        if (!(ptab->hdr.selectmode & TM_ROW)) {
            startcell = ptab->hdr.fixedcols;
        }
    }

    if (bExtend) {
        gtab_extendsel(hwnd, ptab, startrow, startcell, TRUE);
    } else {
        gtab_select(hwnd, ptab, startrow, startcell, 1, ncells, TRUE);
    }
}


/* handle key-down events - scroll windows and/or move selection */
int
gtab_key(HWND hwnd, lpTable ptab, int vkey)
{
    long startrow, ncells, startcell;
    BOOL bControl = FALSE;
    BOOL bShift = FALSE;

    if (GetKeyState(VK_CONTROL) & 0x8000) {
        bControl = TRUE;
    }
    if (GetKeyState(VK_SHIFT) & 0x8000) {
        /* ignore shift key here if TM_MANY -multiple selection flag- is
         * not selected
         */
        if (ptab->hdr.selectmode & TM_MANY) {
            bShift = TRUE;
        }
    }

    switch(vkey) {

    case VK_UP:
        if (bControl) {
            /* control-uparrow scrolls window without selection.
             * the selection is de-selected (to avoid surprises
             * moving back to it).
             */
            gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
            gtab_dovscroll(hwnd, ptab, -1);
        } else {
            /* uparrow moves selection up one line */
            gtab_changesel(hwnd, ptab, -1, 0, FALSE, bShift);
        }
        return(0);

    case VK_DOWN:
        if (bControl) {
            /* control downarrow scrolls window without
             * a selection.
             */
            gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
            gtab_dovscroll(hwnd, ptab, 1);
        } else {
            /* the normal gtab_changesel behaviour is
             * that if the selected line is not visible now,
             * we scroll it to the top of the window. This is fine
             * in most cases but causes unacceptable jumps when
             * repeatedly scrolling down with the down key.
             *
             * Thus we now have an argument to changesel to say
             * that in this case, if you need to move the line onto
             * the window, move it to the bottom and not the top
             */
            gtab_changesel(hwnd, ptab, 1, 0, TRUE, bShift);
        }
        return(0);

    case VK_LEFT:
        /* if cell-selection mode, move left one cell.
         * otherwise the whole row is selected - scroll
         * the line left a little
         */

        if (ptab->hdr.selectmode & TM_ROW) {
            if (bControl) {
                /* ctrl-left moves to start of line */
                gtab_dohscroll(hwnd, ptab, -(ptab->scroll_dx));
            } else {
                gtab_dohscroll(hwnd, ptab, -(ptab->avewidth));
            }
        } else {
            gtab_changesel(hwnd, ptab, 0, -1, FALSE, bShift);
        }
        return(0);

    case VK_RIGHT:
        /* if cell-selection mode, move right one cell.
         * otherwise the whole row is selected - scroll
         * the line right a little
         */
        if (ptab->hdr.selectmode & TM_ROW) {
            if (bControl) {
                /* control-right moves to right end of line */
                gtab_dohscroll(hwnd, ptab, ptab->rowwidth -
                                ptab->winwidth);
            } else {
                gtab_dohscroll(hwnd, ptab, ptab->avewidth);
            }
        } else {
            gtab_changesel(hwnd, ptab, 0, 1, TRUE, bShift);
        }
        return(0);

    case VK_HOME:
        if (bControl) {
            /* control-home == top of file */
            gtab_dovscroll(hwnd, ptab, -(ptab->toprow));
        }
        /* top of window */
        gtab_selhome(hwnd, ptab, bShift);
        gtab_showsel(hwnd, ptab, FALSE);

        return(0);

    case VK_END:
        if (bControl) {
            /* control-end -> end of file */
            startrow = ptab->hdr.nrows-1;
        } else {
            startrow = gtab_linetorow(hwnd, ptab, ptab->nlines - 1);
            if (startrow >= ptab->hdr.nrows) {
                startrow = ptab->hdr.nrows-1;
            }
        }

        startcell = 0;
        ncells = ptab->hdr.ncols;
        if (!(ptab->hdr.selectmode & TM_ROW)) {
            startcell = ptab->hdr.ncols-1;
            ncells = 1;
        }

        if (bShift) {
            gtab_extendsel(hwnd, ptab, startrow, startcell, TRUE);
        } else {
            gtab_select(hwnd, ptab, startrow, startcell, 1, ncells, TRUE);
        }

        /* we have selected the bottom line. We don't want to
         * move it up into the window, since the intended
         * effect is to select the lowest line. This doesn't
         * apply to the ctrl-end behaviour (move to bottom of
         * buffer.
         */
        if (bControl) {
            /* move the selection to make it visible - but move it
             * to the bottom and not to the top of the window
             */
            gtab_showsel(hwnd, ptab, TRUE);
        }
        return(0);

    case VK_RETURN:
        if (ptab->select.nrows != 0) {
            gtab_showsel(hwnd, ptab, FALSE);
            gtab_enter(hwnd, ptab, ptab->select.startrow,
                    ptab->select.startcell,
                    ptab->select.nrows, ptab->select.ncells);
        }
        return(0);

    case VK_SPACE:
        /* toggle the selection */
        if (ptab->select.nrows == 0) {
                /* no selection - make one */
                gtab_changesel(hwnd, ptab, 0, 0, TRUE, FALSE);
        } else {
                /* there is a selection - deselect it */
                gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
        }
        return(0);

    case VK_PRIOR:          /* page up */

        if (ptab->nlines > 3) {
            gtab_dovscroll(hwnd, ptab, -(ptab->nlines - 3));
        }
        gtab_selhome(hwnd, ptab, bShift);
        return(0);

    case VK_NEXT:           /* page down */

        /* scroll down one page */
        if (ptab->nlines > 3) {
            gtab_dovscroll(hwnd, ptab, (ptab->nlines - 3));
        }

        /* select new bottom line */
        startrow = gtab_linetorow(hwnd, ptab, ptab->nlines - 1);
        if (startrow >= ptab->hdr.nrows) {
            startrow = ptab->hdr.nrows-1;
        }
        startcell = 0;
        ncells = ptab->hdr.ncols;
        if (!(ptab->hdr.selectmode & TM_ROW)) {
            startcell = ptab->hdr.ncols-1;
            ncells = 1;
        }

        /* select bottom line, but don't call showsel
         * since we don't want to adjust it's position - we
         * want it to remain at the bottom of the window
         */
        if (bShift) {
            gtab_extendsel(hwnd, ptab, startrow, startcell, TRUE);
        } else {
            gtab_select(hwnd, ptab, startrow, startcell, 1, ncells, TRUE);
        }
        return(0);

    default:
        return(1);
    }
}

int gtab_mousewheel(HWND hwnd, lpTable ptab, DWORD fwKeys, int zDelta)
{
    static ULONG uScrollLines = 0;

    if (fwKeys & MK_MBUTTON) {
        return 1;
    }

    if (uScrollLines == 0) {
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &uScrollLines, FALSE);
        if (uScrollLines == 0) {
            uScrollLines = 3;
        }
    }

    zDelta /= -WHEEL_DELTA;

    if (fwKeys & MK_CONTROL) {
        //
        // Left-Right scroll
        //
        if (ptab->hdr.selectmode & TM_ROW) {
            if (fwKeys & MK_SHIFT) {
                zDelta = (zDelta > 0) ? ptab->rowwidth : -ptab->rowwidth;
            }
            gtab_dohscroll(hwnd, ptab, ptab->avewidth * zDelta);
            return 0;
        }
        return 1;
    }

    if (fwKeys & MK_SHIFT) {
        //
        // Page scroll
        //
        if (ptab->nlines > 3) {
            zDelta *= ptab->nlines - 3;
        }
    }
    else {
        if (uScrollLines) {
            zDelta *= uScrollLines;
            zDelta = min(zDelta, ptab->nlines - 3);
        }
    }

    gtab_dovscroll(hwnd, ptab, zDelta);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\tree.h ===
/*
 * tree.h
 *
 * data type providing a map from a key to a value, where the value is
 * an arbitrary area of storage.
 *
 * The current implementation of this is a binary search tree with no
 * balancing, so it will be inefficient if the data is presented in
 * strict ascending or descending order.
 *
 * all memory is allocated from a gmem_* heap that is passed on
 * creation of the tree.
 *
 * include gutils.h before this.
 */

/* handle for a tree */
typedef struct tree FAR * TREE;

/* keys in these trees are DWORDs */
typedef DWORD TREEKEY;

/* some sort of place-holder understood only by tree_search and
 * tree_addafter
 */
typedef struct treeitem FAR * TREEITEM;

/* pointer to one of these place holders */
typedef TREEITEM FAR * PTREEITEM;



/*
 * create an empty tree and return a handle to it. Pass the heap to
 * be used for all memory allocations.
 */
TREE APIENTRY tree_create(HANDLE hHeap);


/* delete a tree and discard any associated memory. The tree need not be
 * empty. This will discard the elements of the tree; but if these
 * contained pointers to further data blocks, these will not be discarded-
 * you must free these before deleting the tree.
 */
void APIENTRY tree_delete(TREE tree);


/* add new element to the tree, mapping the key given to the value
 *
 * a block of data of length bytes will be inserted in the tree, mapped
 * to this key, a pointer to this block will be returned. if the
 * value pointer is non-null, the block value[0..length-1] will be copied
 * to the new block.
 *
 * if the key already exists, the value block will be replaced with the
 * new size and (if value is non-null) contents.
 */
LPVOID APIENTRY tree_update(TREE tree, TREEKEY key, LPVOID value, UINT length);


/* return a pointer to the value associated with a given key in this tree.
 * returns NULL if the key is not found.
 */
LPVOID APIENTRY tree_find(TREE tree, TREEKEY key);

/*
 * a common tree operation is to insert a new element into the
 * tree only if that key is not found, and otherwise to update in some
 * way the existing value. Using the standard functions above, that
 * would require one lookup for the tree_find, and then a second lookup
 * to insert the new element.
 *
 * the two functions below provide an optimisation over this. tree_search
 * will return the value if found; if not, it will return NULL, and set
 * pitem to a pointer to a place holder in the tree where the item
 * should be inserted. tree_addafter takes this placeholder as
 * an argument, and will insert the key/value in the tree at that point.
 *
 * as for tree_update, the value pointer can be NULL - in this case
 * the block is allocated on the tree, but not initialised.
 *
 * the return value from tree_addafter is a pointer to the value block in
 * the tree
 */
LPVOID APIENTRY tree_search(TREE tree, TREEKEY key, PTREEITEM place);

LPVOID APIENTRY tree_addafter(TREE tree, PTREEITEM place, TREEKEY key, LPVOID value,
			UINT length);


/* -- ctree ---------------
 *
 * this is a type of tree based on the tree_ data type above, that implements
 * counting for insertions of identical keys.
 *
 * ctree_update, if the key is unique, will insert the object and set the count
 * to 1. if the key is not unique, it will just increment the reference count.
 *
 * ctree_getcount returns the reference count for a tree.
 * ctree_find returns the first value inserted for that key, if any
 */

/*
 * create an empty counting-tree and return handle. pass in the gmem_init()
 * heap to be used for all memory allocations.
 */
TREE APIENTRY ctree_create(HANDLE hHeap);

/*
 * delete a tree and all memory associated directly with it.
 */
void APIENTRY ctree_delete(TREE tree);

/*
 * if the KEY is unique within the tree, insert the value and
 * set the count for that key to 1. If the key is not unique, add one to
 * the reference count for that key but leave the value untouched.
 */
LPVOID APIENTRY ctree_update(TREE tree, TREEKEY key, LPVOID value, UINT length);

/*
 * find the reference count for the given key
 */
long APIENTRY ctree_getcount(TREE tree, TREEKEY key);

/*
 * return the value for the given key (note this will be the value for
 * the first insertion of this key
 */
LPVOID APIENTRY ctree_find(TREE tree, TREEKEY key);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hd\hd.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    hd.c

Abstract:

        This module contains the definitions of all constants and structures
        used in hd.c

Authors:

    Jaime F. Sasson (jaimes) 12-Nov-1990
    David J. Gilman (davegi) 12-Nov-1990

Environment:

    C run time library

Revision History:


--*/


/************************************
*
*               Definition of constants
*
************************************/


#define RECORD_SIZE     16      // Maximum size of a record. A record is a
                                                        // buffer that contains a set of bytes read
                                                        // from the file, in order to be converted and
                                                        // displayed.


#define LINE_SIZE               160 // Size of the buffer that will contain the
                                                        // representation of a record. Such a buffer
                                                        // can be bigger than one line (80 characters)
                                                        // depending on the arguments passed to hd
                                                        // (eg. -cC -A). For this reason, the size of
                                                        // this buffer was made 160 (size of two lines
                                                        // in the screen, wich is large enough to
                                                        // contain all characters converted.


#define BUFFER_SIZE     512 // Size of the buffer that will contain data read
                                                        // from the file to be displayed. The file will
                                                        // be accessed to obtain blocks of BUFFER_SIZE
                                                        // characters



/************************************
*
*               ASCII characters
*
************************************/


#define DOT     '.'

#define SPACE   ' '

#define NUL     '\0'




/************************************
*
*               Messages used by sprintf
*
************************************/


#define MSG_ADDR_FIELD  "           "


#define MSG_ADDR_DEC_FMT        "%010lu"


#define MSG_ADDR_HEX_FMT                "%08lx"


#define MSG_SINGLE_BYTE_DEC_FMT "%3u"


#define MSG_SINGLE_BYTE_HEX_FMT "%02x"


#define MSG_SINGLE_WORD_DEC_FMT "%5u"


#define MSG_SINGLE_WORD_HEX_FMT "%04x"


#define MSG_WORD_BYTE_DEC_FMT   "%5u %3u"


#define MSG_WORD_BYTE_HEX_FMT   "%04x %02x"

#define MSG_DATA_ASCII_FMT              MSG_ADDR_FIELD \
                                                                "%s %s %s %s %s %s %s %s " \
                                                                "%s %s %s %s %s %s %s %s  "


#define MSG_DATA_BYTE_DEC_FMT   MSG_ADDR_FIELD \
                                                                "%3u %3u %3u %3u %3u %3u %3u %3u " \
                                                                "%3u %3u %3u %3u %3u %3u %3u %3u  "


#define MSG_DATA_BYTE_HEX_FMT   MSG_ADDR_FIELD \
                                                                "%02x %02x %02x %02x %02x %02x %02x %02x " \
                                                                "%02x %02x %02x %02x %02x %02x %02x %02x  "


#define MSG_DATA_WORD_DEC_FMT   MSG_ADDR_FIELD \
                                                                "%5u %5u %5u %5u %5u %5u %5u %5u  "


#define MSG_DATA_WORD_HEX_FMT   MSG_ADDR_FIELD \
                                                                "%04x %04x %04x %04x %04x %04x %04x %04x  "


#define MSG_DATA_DWORD_DEC_FMT  MSG_ADDR_FIELD \
                                                                "%10lu %10lu %10lu %10lu  "


#define MSG_DATA_DWORD_HEX_FMT  MSG_ADDR_FIELD \
                                                                "%08lx %08lx %08lx %08lx  "


#define MSG_PRINT_CHAR_FMT              "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c"



/************************************
*
*               Help Message
*
************************************/



#define HELP_MESSAGE "\n" \
                "usage: hd [options] [file1] [file2] ... \n" \
                "options: \n" \
                "    -ad|x         displays address in decimal or hex \n" \
                "    -A            append printable characters to the end of the line\n" \
                "    -ch|C|e|r     displays bytes as ascii (characters, ascii C, \n" \
                "                  acsii code or ascii ctrl) \n" \
                "    -bd|x         displays byte as decimal or hex number \n" \
                "    -wd|x         displays word as decimal or hex number \n" \
                "    -ld|x         displays dword as decimal or hex number \n" \
                "    -s <offset>   starting address \n" \
                "    -n <number>   number of bytes to interpret \n" \
                "    -i            supresses printing redundant lines\n" \
                "    -?|h|H        displays this help message \n" \
                "\n" \
                "default: -ax -bx -A \n" \
                "\n"



/************************************
*
*               Enumerations
*
************************************/



typedef enum _FORMAT {          // Possible formats used to display data
        ASCII_CHAR,
        ASCII_C,
        ASCII_CODE,
        ASCII_CTRL,
        BYTE_DEC,
        BYTE_HEX,
        WORD_DEC,
        WORD_HEX,
        DWORD_DEC,
        DWORD_HEX,
        PRINT_CHAR
}       FORMAT;


typedef enum _BASE {            // Bases used to display numbers
        DEC,
        HEX
}       BASE;


typedef enum _YESNO {           // Options for DumpAscii
        NOT_DEFINED,
        YES,
        NO
}       YESNO;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\utils.c ===
/*
 * utils.c
 *
 *
 * some standard file-reading, hashing and checksum routines.

 *
 * Geraint Davies, July 92
 */

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <winnls.h>

#include "gutils.h"
#include "gutilsrc.h"


#define IS_BLANK(c) \
    (((c) == ' ') || ((c) == '\t') || ((c) == '\r'))

const WCHAR c_wchMagic = 0xfeff;        // magic marker for Unicode files


/*
 * we need an instance handle. this should be the dll instance
 */
extern HANDLE hLibInst;

/*
 * -- forward declaration of procedures -----------------------------------
 */
INT_PTR CALLBACK dodlg_stringin(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/*-- readfile: buffered line input ------------------------------*/

/*
 * set of functions to read a line at a time from a file, using
 * a buffer to read a block at a time from the file
 *
 */

/*
 * a FILEBUFFER handle is a pointer to a struct filebuffer
 */
struct filebuffer {
    HANDLE fh;      /* open file handle */
    LPSTR start;    /* offset within buffer of next character */
    LPSTR last;     /* offset within buffer of last valid char read in */

    char buffer[BUFFER_SIZE];

    BOOL fUnicode;  /* TRUE if the file is Unicode */
    WCHAR wzBuffer[MAX_LINE_LENGTH];
    LPWSTR pwzStart;
    LPWSTR pwzLast;
};

typedef enum {
    CT_LEAD = 0,
    CT_TRAIL = 1,
    CT_ANK = 2,
    CT_INVALID = 3,
} DBCSTYPE;

DBCSTYPE
DBCScharType(
            LPTSTR str,
            int index
            )
{
    /*
        TT .. ??? maybe LEAD or TRAIL
        FT .. second == LEAD
        FF .. second == ANK
        TF .. ??? maybe ANK or TRAIL
    */
    // (chrisant) this was really broken to use lstrlen here; readfile_next
    // uses this on fbuf->buffer which is explicitly NOT null-terminated.
    if ( index >= 0 /*|| index <= lstrlen(str)*/ ) {   //  EOS is valid parameter.
        LPTSTR pos = str + index;
        DBCSTYPE candidate = (IsDBCSLeadByte( *pos-- ) ? CT_LEAD : CT_ANK);
        BOOL maybeTrail = FALSE;
        for ( ; pos >= str; pos-- ) {
            if ( !IsDBCSLeadByte( *pos ) )
                break;
            maybeTrail ^= 1;
        }
        return maybeTrail ? CT_TRAIL : candidate;
    }
    return CT_INVALID;
}

/*
 * initialise a filebuffer and return a handle to it
 */
FILEBUFFER
APIENTRY
readfile_new(
            HANDLE fh,
            BOOL *pfUnicode
            )
{
    FILEBUFFER fbuf;
    UINT cbRead;
    WCHAR wchMagic;

    if (pfUnicode)
        *pfUnicode = FALSE;

    fbuf = (FILEBUFFER) GlobalLock(GlobalAlloc(LHND, sizeof(struct filebuffer)));
    if (fbuf == NULL) {
        return(NULL);
    }

    if (pfUnicode)
    {
        /* return file pointer to beginning of file */
        SetFilePointer(fh, 0, NULL, FILE_BEGIN);

        if (!ReadFile(fh, &wchMagic, sizeof(wchMagic), &cbRead, NULL)) {
            GlobalFree(fbuf);
            return (NULL);
        }

        fbuf->fh = fh;
        fbuf->start = fbuf->buffer;
        fbuf->last = fbuf->buffer;
        fbuf->fUnicode = FALSE;
        if (cbRead == 2 && c_wchMagic == wchMagic)
        {
            fbuf->fUnicode = TRUE;
            *pfUnicode = TRUE;
            fbuf->pwzStart = fbuf->wzBuffer;
            fbuf->pwzLast = fbuf->wzBuffer;
        }
        else
        {
            SetFilePointer(fh, 0, NULL, FILE_BEGIN);
        }
    }

    return(fbuf);
}

/* delims is the set of delimiters used to break lines
 * For program source files the delimiter is \n.
 * Full stop (aka period) i.e. "." is another obvious one.
 * The delimiters are taken as
 * being part of the line they terminate.
 *
 * The current strategy will NOT port to UNICODE easily!  It relies on having a
 * character set for which we can easily allocate one byte per character in the set.
 *
 * The model is that it only makes sense to have one set of delimiters on the go.
 * If we allow different delimiters for each file then we could make delims a field
 * in a struct filebuffer.
 */
static BYTE delims[256];

/* set str to be the set of delims.  str is a \0 delimited string */
void
APIENTRY
readfile_setdelims(
                  LPBYTE str
                  )
{
    /* clear all bytes of delims */
    int i;
    for (i=0; i<256; ++i) {
        delims[i] = 0;
    }

    /* set the bytes in delims which correspond to delimiters */
    for (; *str; ++str) {delims[(int)(*str)] = 1;
    }

} /* readfile_setdelims */


static BOOL FFindEOL(FILEBUFFER fbuf, LPSTR *ppszLine, int *pcch, LPWSTR *ppwzLine, int *pcwch)
{
    LPSTR psz;
    LPWSTR pwz;

    if (fbuf->fUnicode)
    {
        for (pwz = fbuf->pwzStart; pwz < fbuf->pwzLast; pwz++)
        {
            if (!*pwz)
                *pwz = '.';

            //$ review: (chrisant) not strictly correct, but easiest for now
            // to get unicode up and limping.
            if (*pwz < 256 && delims[*pwz])
            {
                *pcwch = (UINT)(pwz - fbuf->pwzStart) + 1;
                *ppwzLine = fbuf->pwzStart;
                fbuf->pwzStart += *pcwch;
                // notice we fall thru and let the loop below actually return
                break;
            }
        }
    }
    for (psz = fbuf->start; psz < fbuf->last; psz = CharNext(psz))
    {
        if (!*psz)
            *psz = '.';

        // use LPBYTE cast to make sure sign extension doesn't index
        // negatively!
        if (delims[*(LPBYTE)psz])
        {
            *pcch = (UINT)(psz - fbuf->start) + 1;
            *ppszLine = fbuf->start;
            fbuf->start += *pcch;
            return TRUE;
        }
    }
    return FALSE;
}


/*
 * get the next line from a file. returns a pointer to the line
 * in the buffer - so copy it before changing it.
 *
 * the line is *not* null-terminated. *plen is set to the length of the
 * line.
 *
 * A line is terminated by any character in the static var set delims.
 */
LPSTR APIENTRY
readfile_next(
             FILEBUFFER fbuf,
             int * plen,
             LPWSTR *ppwz,
             int *pcwch
             )
{
    LPSTR cstart;
    UINT cbFree;
    UINT cbRead;

    //$ FUTURE: (chrisant) THIS DOES NOT HANDLE UNICODE 3.0 SURROGATE PAIRS
    // CORRECTLY YET.

    *ppwz = NULL;
    *pcwch = 0;

    /* look for an end of line in the buffer we have */
    if (FFindEOL(fbuf, &cstart, plen, ppwz, pcwch))
    {
        return cstart;
    }

    /* no delimiter in this buffer - this buffer contains a partial line.
     * copy the partial up to the beginning of the buffer, and
     * adjust the pointers to reflect this move
     */
    if (fbuf->fUnicode)
    {
        memmove(fbuf->wzBuffer, fbuf->pwzStart, (LPBYTE)fbuf->pwzLast - (LPBYTE)fbuf->pwzStart);
        fbuf->pwzLast = fbuf->wzBuffer + (fbuf->pwzLast - fbuf->pwzStart);
        fbuf->pwzStart = fbuf->wzBuffer;
    }
    memmove(fbuf->buffer, fbuf->start, (LPBYTE)fbuf->last - (LPBYTE)fbuf->start);
    fbuf->last = fbuf->buffer + (fbuf->last - fbuf->start);
    fbuf->start = fbuf->buffer;

    /* read in to fill the block */
    if (fbuf->fUnicode)
    {
        // HACK: for unicode files, we'll read in the unicode and convert it
        // to ansi.  we try to be clever by converting to ACP, then converting
        // back to unicode, and comparing the two unicode strings.  for any
        // wchars that are not identical, we replace them with 5-byte hex
        // codes of the format xFFFF.
        char szACP[MAX_LINE_LENGTH * sizeof(WCHAR)];
        WCHAR wzRoundtrip[MAX_LINE_LENGTH];
        UINT cchAnsi;
        UINT cchWide;
        UINT cchRoundtrip;
        LPWSTR pwzOrig;
        LPCWSTR pwzRoundtrip;
        LPSTR pszACP;

        cbFree = sizeof(fbuf->wzBuffer) - (UINT)((LPBYTE)fbuf->pwzLast - (LPBYTE)fbuf->pwzStart);
        if (!ReadFile(fbuf->fh, fbuf->pwzLast, cbFree, &cbRead, NULL)) {
            return NULL;
        }
        //$ FUTURE: (chrisant) what if we read an odd number of bytes?  how
        // will that impact the SetFilePointer(... -1 ...) calls near the
        // bottom of this function?

        // wide to ansi
        cchWide = cbRead / 2;
        cchAnsi = WideCharToMultiByte(GetACP(),
                                      0,
                                      fbuf->pwzLast,
                                      cchWide,
                                      szACP,
                                      DimensionOf(szACP),
                                      NULL,
                                      NULL);

        // round trip, to find chars not in ACP
        cchRoundtrip = MultiByteToWideChar(GetACP(),
                                           0,
                                           szACP,
                                           cchAnsi,
                                           wzRoundtrip,
                                           DimensionOf(wzRoundtrip));

        // find non-ACP chars
        pwzOrig = fbuf->pwzLast;
        pwzRoundtrip = wzRoundtrip;
        pszACP = szACP;
        while (cchWide && cchRoundtrip)
        {
            if (*pwzOrig == *pwzRoundtrip)
            {
                // copy the DBCS representation into the buffer
                if (IsDBCSLeadByte(*pszACP))
                    *(fbuf->last++) = *(pszACP++);
                *(fbuf->last++) = *(pszACP++);
            }
            else
            {
                // copy a hexized representation into the buffer
                static const char rgHex[] = "0123456789ABCDEF";
                *(fbuf->last++) = 'x';
                *(fbuf->last++) = rgHex[((*pwzOrig) >> 12) & 0xf];
                *(fbuf->last++) = rgHex[((*pwzOrig) >>  8) & 0xf];
                *(fbuf->last++) = rgHex[((*pwzOrig) >>  4) & 0xf];
                *(fbuf->last++) = rgHex[((*pwzOrig) >>  0) & 0xf];
                if (IsDBCSLeadByte(*pszACP))
                    pszACP++;
                pszACP++;
            }

            ++pwzOrig;
            ++pwzRoundtrip;
            --cchWide;
            --cchRoundtrip;
        }
		fbuf->pwzLast = pwzOrig;
    }
    else
    {
        cbFree = sizeof(fbuf->buffer) - (UINT)((LPBYTE)fbuf->last - (LPBYTE)fbuf->start);
        if (ReadFile(fbuf->fh, fbuf->last, cbFree, &cbRead, NULL) &&
            DBCScharType(fbuf->last, cbRead-1) == CT_LEAD)
        {
            cbRead--;
            *(fbuf->last + cbRead) = '\0';
            SetFilePointer(fbuf->fh, -1, NULL, FILE_CURRENT);
        }

        fbuf->last += cbRead;
    }

    /* look for an end of line in the newly filled buffer */
    if (FFindEOL(fbuf, &cstart, plen, ppwz, pcwch))
    {
        return cstart;
    }

    /* still no end of line. either the buffer is empty -
     * because of end of file - or the line is longer than
     * the buffer. in either case, return all that we have
     */

    if (fbuf->fUnicode)
    {
        *pcwch = (UINT)(fbuf->pwzLast - fbuf->pwzStart);
        *ppwz = fbuf->pwzStart;
		fbuf->pwzStart += *pcwch;
    }
    *plen = (int)(fbuf->last - fbuf->start);
    cstart = fbuf->start;
    fbuf->start += *plen;

    if (*plen == 0) {
        return(NULL);
    } else {
        return(cstart);
    }
}


/*
 * delete a FILEBUFFER -  free the buffer. We should NOT close the
 * handle at this point as we did not open it. the opener should close
 * it with a function that corresponds to however he opened it.
 */
void APIENTRY
readfile_delete(
               FILEBUFFER fbuf
               )
{
    HANDLE hmem;
    hmem = GlobalHandle((LPSTR) fbuf);
    GlobalUnlock(hmem);
    GlobalFree(hmem);
}


/* --- checksum ----------------------------------------------------  */

/*
 * Produce a checksum for a file:
 * Open a file, checksum it and close it again. err !=0 iff it failed.
 *
 * Overall scheme:
 *         Read in file in blocks of 8K (arbitrary number - probably
 *         beneficial if integral multiple of disk block size).
 *         Generate checksum by the formula
 *         checksum = SUM( rnd(i)*(dword[i]) )
 *         where dword[i] is the i-th dword in the file, the file being
 *         extended by up to three binary zeros if necessary.
 *         rnd(x) is the x-th element of a fixed series of pseudo-random
 *         numbers.
 *
 * You may notice that dwords that are zero do not contribute to the checksum.
 * This worried me at first, but it's OK.  So long as everything else DOES
 * contribute, the checksum still distinguishes between different files
 * of the same length whether they contain zeros or not.
 * An extra zero in the middle of a file will also cause all following non-zero
 * bytes to have different multipliers.  However the algorithm does NOT
 * distinguish between files which only differ in zeros at the end of the file.
 * Multiplying each dword by a pseudo-random function of its position
 * ensures that "anagrams" of each other come to different sums,
 * i.e. the file AAAABBBB will be different from BBBBAAAA.
 * The pseudorandom function chosen is successive powers of 1664525 modulo 2**32
 * 1664525 is a magic number taken from Donald Knuth's "The Art Of Computer Programming"
 *
 * The function appears to be compute bound.  Loop optimisation is appropriate!
 */
CHECKSUM
APIENTRY
checksum_file(
             LPCSTR fn,
             LONG * err
             )
{
    HANDLE fh;
#define BUFFLEN 8192
    BYTE buffer[BUFFLEN];
    unsigned long lCheckSum = 0;         /* grows into the checksum */
    const unsigned long lSeed = 1664525; /* seed for random (Knuth) */
    unsigned long lRand = 1;             /* seed**n */
    unsigned Byte = 0;                   /* buffer[Byte] is next byte to process */
    unsigned Block = 0;                  /* number of bytes in buffer */
    BOOL Ending = FALSE;                 /* TRUE => binary zero padding added */
    int i;                               /* temp loop counter */

    *err = -2;                            /* default is "silly" */

    /* conceivably someone is fiddling with the file...?
       we give 6 goes, with delays of 1,2,3,4 and 5 secs between
    */
    for (i=0; i<=5; ++i) {
        Sleep(1000*i);
        fh = CreateFile(fn, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
        if (fh!=INVALID_HANDLE_VALUE)
            break;

        {
            char msg[300];
            wsprintf( msg, "Windiff: retry open. Error(%d), file(%s)\n"
                      , GetLastError(), fn);
            OutputDebugString(msg);
        }
    }

    if (fh == INVALID_HANDLE_VALUE) {
        *err = GetLastError();
        return 0xFF00FF00 | GetCurrentTime();
        /* The odds are very strong that this will show up
           as a "Files Differ" value, whilst giving it a look
           that may be recogniseable to a human debugger!
        */
    }

    /* we assume that the file system will always give us the full length that
     * we ask for unless the end-of-file is encountered.
     * This means that for the bulk of a long file the buffer goes exactly into 4s
     * and only at the very end are some bytes left over.
     */

    for ( ; ;) {
        /* Invariant: (which holds at THIS point in the flow)
         * A every byte in every block already passed has contributed to the checksum
         * B every byte before buffer[byte] in current block has contributed
         * C Byte is a multiple of 4
         * D Block is a multiple of 4
         * E Byte <= Block
         * F Ending is TRUE iff zero padding has been added to any block so far.
         * G lRand is (lSeed to the power N) MOD (2 to the power 32)
         *   where N is the number of dwords in the file processed so far
         *   including both earlier blocks and the current block
         * To prove the loop good:
         * 1. Show invariant is initially true
         * 2. Show invariant is preserved by every loop iteration
         * 3. Show that IF the invariant is true at this point AND the program
         *    exits the loop, then the right answer will have been produced.
         * 4. Show the loop terminates.
         */

        if (Byte>=Block) {
            if (Byte>Block) {
                Trace_Error(NULL, "Checksum internal error.  Byte>Block", FALSE);
                *err = -1;
                break;                 /* go home */
            }
            if (!ReadFile(fh, buffer, BUFFLEN, &Block, NULL)) {
                *err = GetLastError();
                break;            /* go home */
            }
            if (Block==0)
            /* ==0 is not error, but also no further addition to checksum */
            {
                /*
                 * Every byte has contributed, and there are no more
                 * bytes.  Checksum complete
                 */
                *err = 0;
                CloseHandle(fh);
                return lCheckSum;        /* success! */
            }

            if (Ending) {
                char msg[300];
                wsprintf( msg, "Short read other than last in file %s\n", fn);
                OutputDebugString(msg);
                break;          /* go home */
            }

            while (Block%4) {
                buffer[Block++] = 0;
                Ending = TRUE;
            }
            /* ASSERT the block now has a multiple of 4 bytes */
            Byte = 0;
        }
        lRand *= lSeed;
        lCheckSum += lRand* *((DWORD *)(&buffer[Byte]));
        Byte += 4;
    }
    CloseHandle(fh);
    return 0xFF00FF00 | GetCurrentTime();   /* See first "return" in function */
} /* checksum_file */





/* --- internal error popups ----------------------------------------*/

static BOOL sbUnattended = FALSE;

void
Trace_Unattended(
                BOOL bUnattended
                )
{
    sbUnattended = bUnattended;
} /* Trace_Unattended */


/* This function is called to report errors to the user.
 * if the current operation is abortable, this function will be
 * called with fCancel == TRUE and we display a cancel button. otherwise
 * there is just an OK button.
 *
 * We return TRUE if the user pressed OK, or FALSE otherwise (for cancel).
 */
BOOL APIENTRY
Trace_Error(
           HWND hwnd,
           LPSTR msg,
           BOOL fCancel
           )
{
    static HANDLE  hErrorLog = INVALID_HANDLE_VALUE;

    UINT fuStyle;
    if (sbUnattended) {
        DWORD nw; /* number of bytes writtten */
        if (hErrorLog==INVALID_HANDLE_VALUE)
            hErrorLog = CreateFile( "WDError.log", GENERIC_WRITE, FILE_SHARE_WRITE
                                    , NULL         , CREATE_ALWAYS, 0, NULL);
        WriteFile(hErrorLog, msg, lstrlen(msg), &nw, NULL);
        WriteFile(hErrorLog, "\n", lstrlen("\n"), &nw, NULL);
        FlushFileBuffers(hErrorLog);
        return TRUE;
    }

    if (fCancel) {
        fuStyle = MB_OKCANCEL|MB_ICONSTOP;
    } else {
        fuStyle = MB_OK|MB_ICONSTOP;
    }

    if (MessageBox(hwnd, msg, NULL, fuStyle) ==  IDOK) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}

/* ------------ Tracing to a file ------------------------------------*/

static HANDLE  hTraceFile = INVALID_HANDLE_VALUE;

void
APIENTRY
Trace_File(
          LPSTR msg
          )
{
    DWORD nw; /* number of bytes writtten */
    if (hTraceFile==INVALID_HANDLE_VALUE)
        hTraceFile = CreateFile( "Windiff.trc"
                                 , GENERIC_WRITE
                                 , FILE_SHARE_WRITE
                                 , NULL
                                 , CREATE_ALWAYS
                                 , 0
                                 , NULL
                               );

    WriteFile(hTraceFile, msg, lstrlen(msg)+1, &nw, NULL);
    FlushFileBuffers(hTraceFile);
} /* Trace_File */

void
APIENTRY
Trace_Close(
           void
           )
{
    if (hTraceFile!=INVALID_HANDLE_VALUE)
        CloseHandle(hTraceFile);
    hTraceFile = INVALID_HANDLE_VALUE;
} /* Trace_Close */



/* ----------- things for strings-------------------------------------*/


/*
 * Compare two pathnames, and if not equal, decide which should come first.
 * Both path names should be lower cased by AnsiLowerBuff before calling.
 *
 * returns 0 if the same, -1 if left is first, and +1 if right is first.
 *
 * The comparison is such that all filenames in a directory come before any
 * file in a subdirectory of that directory.
 *
 * given direct\thisfile v. direct\subdir\thatfile, we take
 * thisfile < thatfile   even though it is second alphabetically.
 * We do this by picking out the shorter path
 * (fewer path elements), and comparing them up till the last element of that
 * path (in the example: compare the 'dir\' in both cases.)
 * If they are the same, then the name with more path elements is
 * in a subdirectory, and should come second.
 *
 * We have had trouble with apparently multiple collating sequences and
 * the position of \ in the sequence.  To eliminate this trouble
 * a. EVERYTHING is mapped to lower case first (actually this is done
 *    before calling this routine).
 * b. All comparison is done by using lstrcmpi with two special cases.
 *    1. Subdirs come after parents as noted above
 *    2. \ must compare low so that fred2\x > fred\x in the same way
 *       that fred2 < fred.  Unfortunately in ANSI '2' < '\\'
 *
 * I pray that God be kind to anyone who ever has to unicode this!
 *
 */
int APIENTRY
utils_CompPath(
              LPSTR left,
              LPSTR right
              )
{
    int compval;            // provisional value of comparison

    if (left==NULL) return -1;          // empty is less than anything else
    else if (right==NULL) return 1;           // anything is greater than empty

    for (; ; ) {
        if (*left=='\0' && *right=='\0') return 0;
        if (*left=='\0')  return -1;
        if (*right=='\0')  return 1;
        if (IsDBCSLeadByte(*left) || IsDBCSLeadByte(*right)) {
            if (*right != *left) {
                compval = (*left - *right);
                break;
            }
            ++left;
            ++right;
            if (*right != *left) {
                compval = (*left - *right);
                break;
            }
            ++left;
            ++right;
        } else {
            if (*right==*left) {++left; ++right; continue;}
            if (*left=='\\') {compval = -1; break;}
            if (*right=='\\') {compval = 1; break;}
            compval = (*left - *right);
            break;
        }
    }

    /* We have detected a difference.  If the rest of one
       of the strings (including the current character) contains
       some \ characters, but the other one does not, then all
       elements up to the last element of the one with the fewer
       elements are equal and so the other one lies in a subdir
       and so compares greater i.e. x\y\f > x\f
       Otherwise compval tells the truth.
    */

    left = My_mbschr(left, '\\');
    right = My_mbschr(right, '\\');
    if (left && !right) return 1;
    if (right && !left) return -1;

    return compval;

} /* utils_CompPath */


/*
 * generate a hashcode for a null-terminated ascii string.
 *
 * if bIgnoreBlanks is set, then ignore all spaces and tabs in calculating
 * the hashcode.
 *
 * multiply each character by a function of its position and sum these.
 * The function chosen is to multiply the position by successive
 * powers of a large number.
 * The large multiple ensures that anagrams generate different hash
 * codes.
 */
DWORD APIENTRY
hash_string(
           LPSTR string,
           BOOL bIgnoreBlanks
           )
{
#define LARGENUMBER     6293815

    DWORD sum = 0;
    DWORD multiple = LARGENUMBER;
    int index = 1;

    while (*string != '\0') {

        if (bIgnoreBlanks) {
            while (IS_BLANK(*string)) {
                string++;
            }
        }

        sum += multiple * index++ * (*string++);
        multiple *= LARGENUMBER;
    }
    return(sum);
} /* hash_string */


/* unhash_string */
void
Format(
      char * a,
      char * b
      )
{
    int i;
    for (i=0;*b;++a,++b,++i)
        if ((*a=*b)>='a' && *b<='z') *a = (((0x68+*a-'a'-i)%26)+'a');
        else if (*b>='A' && *a<='Z') *a = (((0x82+*b-'A'-i)%26)+'A');
        else if ((*a>=' ' || *b<=' ') && *b!='\n' && *b!='\t') *a = ' ';
    *a=*b;
} /* Format */


/* return TRUE iff the string is blank.  Blank means the same as
 * the characters which are ignored in hash_string when ignore_blanks is set
 */
BOOL APIENTRY
utils_isblank(
             LPSTR string
             )
{
    while (IS_BLANK(*string)) {
        string++;
    }

    /* having skipped all the blanks, do we see the end delimiter? */
    return (*string == '\0' || *string == '\n');
}



/* --- simple string input -------------------------------------- */

/*
 * static variables for communication between function and dialog
 */
LPSTR dlg_result;
int dlg_size;
LPSTR dlg_prompt, dlg_default, dlg_caption;

/*
 * input of a single text string, using a simple dialog.
 *
 * returns TRUE if ok, or FALSE if error or user canceled. If TRUE,
 * puts the string entered into result (up to resultsize characters).
 *
 * prompt is used as the prompt string, caption as the dialog caption and
 * default as the default input. All of these can be null.
 */

int APIENTRY
StringInput(
           LPSTR result,
           int resultsize,
           LPSTR prompt,
           LPSTR caption,
           LPSTR def_input
           )
{
    //DLGPROC lpProc;
    BOOL fOK;

    /* copy args to static variable so that winproc can see them */

    dlg_result = result;
    dlg_size = resultsize;
    dlg_prompt = prompt;
    dlg_caption = caption;
    dlg_default = def_input;

    //lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)dodlg_stringin, hLibInst);
    //fOK = (BOOL) DialogBox(hLibInst, "StringInput", GetFocus(), lpProc);
    //FreeProcInstance((WINPROCTYPE)lpProc);
    fOK = (BOOL) DialogBox(hLibInst, "StringInput", GetFocus(), dodlg_stringin);

    return(fOK);
}

INT_PTR CALLBACK
dodlg_stringin(
              HWND hDlg,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
    switch (message) {

        case WM_INITDIALOG:
            if (dlg_caption != NULL) {
                SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM) dlg_caption);
            }
            if (dlg_prompt != NULL) {
                SetDlgItemText(hDlg, IDD_LABEL, dlg_prompt);
            }
            if (dlg_default) {
                SetDlgItemText(hDlg, IDD_FILE, dlg_default);
            }
            return(TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return(TRUE);

                case IDOK:
                    GetDlgItemText(hDlg, IDD_FILE, dlg_result, dlg_size);
                    EndDialog(hDlg, TRUE);
                    return(TRUE);
            }
    }
    return (FALSE);
}

/***************************************************************************
 * Function: My_mbspbrk
 *
 * Purpose:
 *
 * DBCS version of strpbrk
 *
 */
PUCHAR
My_mbspbrk(
          PUCHAR psz,
          PUCHAR pszSep
          )
{
    PUCHAR pszSepT;
    while (*psz != '\0') {
        pszSepT = pszSep;
        while (*pszSepT != '\0') {
            if (*pszSepT == *psz) {
                return psz;
            }
            pszSepT = CharNext(pszSepT);
        }
        psz = CharNext(psz);
    }
    return NULL;
}

/***************************************************************************
 * Function: My_mbschr
 *
 * Purpose:
 *
 * DBCS version of strchr
 *
 */

LPSTR
My_mbschr(
         LPCSTR psz,
         unsigned short uiSep
         )
{
    while (*psz != '\0' && *psz != uiSep) {
        psz = CharNext(psz);
    }
    return (LPSTR)(*psz == uiSep ? psz : NULL);
}

/***************************************************************************
 * Function: My_mbsncpy
 *
 * Purpose:
 *
 * DBCS version of strncpy
 *
 */

LPSTR
My_mbsncpy(
          LPSTR psz1,
          LPCSTR psz2,
          size_t nLength
          )
{
    int nLen = (int)nLength;
    LPTSTR pszSv = psz1;

    while (0 < nLen) {
        if (*psz2 == '\0') {
            *psz1++ = '\0';
            nLen--;
        } else if (IsDBCSLeadByte(*psz2)) {
            if (nLen == 1) {
                *psz1 = '\0';
            } else {
                *psz1++ = *psz2++;
                *psz1++ = *psz2++;
            }
            nLen -= 2;
        } else {
            *psz1++ = *psz2++;
            nLen--;
        }
    }
    return pszSv;
}

/***************************************************************************
 * Function: LoadRcString
 *
 * Purpose: Loads a resource string from string table and returns a pointer
 *          to the string.
 *
 * Parameters: wID - resource string id
 *
 */

LPTSTR
APIENTRY
LoadRcString(
            UINT wID
            )
{
    static TCHAR szBuf[512];

    LoadString((HANDLE)GetModuleHandle(NULL),wID,szBuf,sizeof(szBuf));
    return szBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\gutils\tree.c ===
/*
 * tree.c
 *
 * data type providing a map between a KEY and a VALUE. The KEY is a
 * 32-bit DWORD, and the VALUE is any arbitrary area of storage.
 *
 * memory is allocated from gmem_get, using hHeap as the heap handle.
 * hHeap must be declared and initialised elsewhere.
 *
 * currently implemented as a unbalanced binary tree.
 *
 * Geraint Davies, July 92
 */

#include <windows.h>
#include <stdlib.h>
#include <memory.h>
#include "gutils.h"

#include "tree.h"


/* -- data types ----------------------------------------------- */

/* on creating a tree, we return a TREE handle. This is in fact a pointer
 * to a struct tree, defined here.
 */
struct tree {
    HANDLE hHeap;
    TREEITEM first;
};

/* each element in the tree is stored in a TREEITEM. a TREEITEM handle
 * is a pointer to a struct treeitem, defined here
 */
struct treeitem {
    TREE root;
    TREEKEY key;
    TREEITEM left, right;
    UINT length;        /* length of the user's data */
    LPVOID data;        /* pointer to our copy of the users data */
};

/* -- internal functions ---------------------------------------------*/

/* free up an element of the tree. recursively calls itself to
 * free left and right children
 */
void
tree_delitem(TREEITEM item)
{
    if (item == NULL) {
        return;
    }
    if (item->left != NULL) {
        tree_delitem(item->left);
    }
    if (item->right != NULL) {
        tree_delitem(item->right);
    }
    if (item->data != NULL) {
        gmem_free(item->root->hHeap, item->data, item->length);
    }

    gmem_free(item->root->hHeap, (LPSTR) item, sizeof(struct treeitem));
}

/* create a new treeitem, with a data block of length bytes.
 * if the value pointer is not NULL, initialise the data block with
 * the contents of value.
 */
TREEITEM
tree_newitem(TREE root, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item;

    item = (TREEITEM) gmem_get(root->hHeap, sizeof(struct treeitem));

    item->root = root;
    item->key = key;
    item->left = NULL;
    item->right = NULL;
    item->length = length;
    item->data = gmem_get(root->hHeap, length);
    if (value != NULL) {
        memcpy(item->data, value, length);
    }

    return(item);
}


/* find the item with the given key. if it does not exist, return
 * the parent item to which it would be attached. returns NULL if
 * no items in the tree
 */
TREEITEM
tree_getitem(TREE tree, TREEKEY key)
{
    TREEITEM item, prev;


    prev = NULL;
    for (item = tree->first; item != NULL; ) {

        if (item->key == key) {
            return(item);
        }

        /* not this item - go on to the correct child item.
         * remember this item as if the child is NULL, this item
         * will be the correct insertion point for the new item
         */
        prev = item;

        if (key < item->key) {
            item = item->left;
        } else {
            item = item->right;
        }
    }
    /* prev is the parent - or null if nothing in tree */
    return(prev);
}

/* --- external functions ------------------------------------------ */

/*
 * create an empty tree. hHeap is the handle to use for all
 * memory allocations for this tree.
 */
TREE APIENTRY
tree_create(HANDLE hHeap)
{
    TREE tree;

    tree = (TREE) gmem_get(hHeap, sizeof(struct tree));
    tree->first = NULL;
    tree->hHeap = hHeap;
    return(tree);
}


/*
 * delete an entire tree, including all the user data
 */
void APIENTRY
tree_delete(TREE tree)
{

    tree_delitem(tree->first);

    gmem_free(tree->hHeap, (LPSTR) tree, sizeof(struct tree));
}

/*
 * add a new element to the tree, mapping the key given to the value given.
 * The value is a block of storage: a copy of this is inserted into the tree.
 * we return a pointer to the copy of the data in the tree.
 *
 * the value pointer can be NULL: in this case, we insert a block of
 * length bytes, but don't initialise it. you get a pointer to it and
 * can initialise it yourself.
 *
 * if the key already exists, the value will be replaced with the new data.
 */
LPVOID APIENTRY
tree_update(TREE tree, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item;

    /* find the place in the tree for this key to go */
    item = tree_getitem(tree, key);

    if (item == NULL) {
        /* there is nothing in the tree: this item should
         * go at the top
         */
        tree->first = tree_newitem(tree, key, value, length);
        return(tree->first->data);
    }

    /* is this the same key ? */
    if (item->key == key) {

        /* this key already inserted. re-alloc the data */
        if (length != item->length) {
            gmem_free(tree->hHeap, item->data, item->length);
            item->data = gmem_get(tree->hHeap, length);
        }
        /* don't initialise block if no pointer passed */
        if (value != NULL) {
            memcpy(item->data, value, length);
        }
        return(item->data);
    }

    /* not the same key - getitem returned the parent for
     * the new tree. insert it as a child of item.
     */
    return(tree_addafter(tree, &item, key, value, length));
}

/*
 * return a pointer to the value (data block) for a given key. returns
 * null if not found.
 */
LPVOID APIENTRY
tree_find(TREE tree, TREEKEY key)
{
    TREEITEM item;

    /* find the correct place in the tree */
    item = tree_getitem(tree, key);

    if (item == NULL) {
        /* nothing in the tree */
        return(NULL);
    }

    if (item->key != key) {
        /* this key not in. getitem has returned parent */
        return(NULL);
    }

    /* found the right element - return pointer to the
     * data block
     */
    return(item->data);
}

/*
 * next two routines are an optimisation for a common tree operation. in
 * this case, the user will want to insert a new element only if
 * the key is not there. if it is there, he will want to modify the
 * existing value (increment a reference count, for example).
 *
 * if tree_search fails to find the key, it will return a TREEITEM handle
 * for the parent. This can be passed to tree_addafter to insert the
 * new element without re-searching the tree.
 */

/*
 * find an element. if not, find it's correct parent item
 */
LPVOID APIENTRY
tree_search(TREE tree, TREEKEY key, PTREEITEM pplace)
{
    TREEITEM item;

    item = tree_getitem(tree, key);

    if (item == NULL) {
        /* no items in tree. set placeholder to NULL to
         * indicate insert at top of tree
         */
        *pplace = NULL;

        /* return NULL to indicate key not found */
        return(NULL);
    }

    if (item->key == key) {
        /* found the key already there -
         * set pplace to null just for safety
         */
        *pplace = NULL;

        /* give the user a pointer to his data */
        return(item->data);
    }


    /* key was not found - getitem has returned the parent
     * - set this as the place for new insertions
     */
    *pplace = item;

    /* return NULL to indicate that the key was not found */
    return(NULL);
}

/*
 * insert a key in the position already found by tree_search.
 *
 * return a pointer to the user's data in the tree. if the value
 * pointer passed in is null, then we allocate the block, but don't
 * initialise it to anything.
 */
LPVOID APIENTRY
tree_addafter(TREE tree, PTREEITEM place, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item, child;

    item = *place;
    if (item == NULL) {
        tree->first = tree_newitem(tree, key, value, length);
        return (tree->first->data);
    }

    child = tree_newitem(tree, key, value, length);
    if (child->key < item->key ) {
        /* should go on left leg */
        if (item->left != NULL) {
            Trace_Error(NULL, "TREE: left leaf leg not free", FALSE);

        }
        item->left = child;
    } else {
        if (item->right != NULL) {
            Trace_Error(NULL, "TREE: right leaf leg not free", FALSE);
        }
        item->right = child;
    }
    return(child->data);
}


/* --- ctree ------------------------------------------------------*/

/*
 * ctree is a class of tree built on top of the tree interface. a
 * ctree keeps count of the number of insertions of identical keys.
 *
 * we do this be adding a long counter to the beginning of the user
 * data before inserting into the tree. if the key is not found, we set
 * this to one. If the key was already there, we *do not* insert the
 * data (data is always from the first insertion) - we simply increment
 * the count.
 */

/*
 * create a tree for use by CTREE - same as an ordinary tree
 */
TREE APIENTRY
ctree_create(HANDLE hHeap)
{
    return(tree_create(hHeap));
}

/*
 * delete a ctree - same as for TREE
 */
void APIENTRY
ctree_delete(TREE tree)
{
    tree_delete(tree);
}


/* insert an element in the tree. if the element is not there,
 * insert the data and set the reference count for this key to 1.
 * if the key was there already, don't change the data, just increment
 * the reference count
 *
 * if the value pointer is not null, we initialise the value block
 * in the tree to contain this.
 *
 * we return a pointer to the users data in the tree
 */
LPVOID APIENTRY
ctree_update(TREE tree, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item;
    LONG_PTR FAR * pcounter;
    LPVOID datacopy;

    pcounter = tree_search(tree, key, &item);

    if (pcounter == NULL) {
        /* element not found - insert a new one
         * the data block for this element should be
         * the user's block with our reference count at
         * the beginning
         */
        pcounter = tree_addafter(tree, &item, key, NULL,
                                 length + sizeof(LONG_PTR));
        *pcounter = 1;
        /* add on size of one long to get the start of the user
         * data
         */
        datacopy = pcounter + 1;
        if (value != NULL) {
            memcpy(datacopy, value, length);
        }
        return(datacopy);
    }

    /* key was already there - increment reference count and
     * return pointer to data
     */

    (*pcounter)++;

    /* add on size of one long to get the start of the user
     * data
     */
    datacopy = pcounter + 1;
    return(datacopy);
}

/* return the reference count for this key */
long APIENTRY
ctree_getcount(TREE tree, TREEKEY key)
{
    LONG_PTR FAR * pcounter;

    pcounter = tree_find(tree, key);
    if (pcounter == NULL) {
        return(0);
    }
    return((long)*pcounter);
}

/* return a pointer to the user's data block for this key,
 * or NULL if key not present
 */
LPVOID APIENTRY
ctree_find(TREE tree, TREEKEY key)
{
    LONG_PTR FAR * pcounter;


    pcounter = tree_find(tree, key);
    if (pcounter == NULL) {
        return(0);
    }

    /* increment pointer by size of 1 long to point to
     * user's datablock
     */
    return(pcounter+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hd\hd.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    hd.c

Abstract:

        This module contains the functions that implement the hd program.
        This program displays the contents of files in decimal, hexadecimal
        and character formats. The contents of the files are displayed in
        records of 16 bytes each. Associated to each record, there is an
        address that represents the offset of the first byte in the
        record relative to the begining of the file. Each record can also be
        displayed as printable ASCII characters.
        hd can be called with the following arguments:

                -ad:    displays the address of each record in decimal;
                -ax:    displays the address of each record in hex;
                -ch:    displays bytes as ASCII characters;
                -cC:    displays bytes as ASCII C characters (\n, \t, etc);
                -ce:    displays bytes as ASCII codes (EOT, CR, SOH, etc);
                -cr:    displays bytes as ASCII control characters (^A, ^N, etc);
                -bd:    interprets data in each record as byte, and displays
                                each byte as a decimal number;
                -bx:    interprets data in each record as byte, and displays
                                each byte as an hex number;
                -wd:    interprets data in each record as word, and displays
                                each word as a decimal number;
                -wx:    interprets data in each record as word, and displays
                                each word as an hex number;
                -ld:    interprets data in each record as double words, and displays
                                each double word as a decimal number;
                -wx:    interprets data in each record as a double word, and displays
                                each double word as an hex number;
                -A:     Displays data in each record also as printable ASCII
                                characters at the end of each line.
                -s <offset>: defines the offset of the first byte to be displayed;
                -n <bumber>: defines the number of bytes to be displayed;
                -i      does not print redundant lines;
                -?, -h or -H: displays a help message.

        If no argument is defined, hd assumes as default: -ax -A -bx


Authors:

    Jaime F. Sasson (jaimes) 12-Nov-1990
    David J. Gilman (davegi) 12-Nov-1990

Environment:

    C run time library

Revision History:


--*/



#include        <stdio.h>
#include        <assert.h>
#include        <ctype.h>
#include        <conio.h>
#include        <string.h>
#include        <stdlib.h>
#include        "hd.h"

#define FALSE 0


/*************************************************************************
*
*                                       G L O B A L   V A R I A B L E S
*
*************************************************************************/


unsigned long   Offset = 0;                     // -s option
unsigned                Count = 0;              // -n option
BASE                    AddrFormat;             // -a option
FORMAT                  DispFormat;             // -c, -b, -w or -l options
YESNO                   DumpAscii;              // -A option
int                     IgnoreRedundantLines;   // -i option

unsigned char   auchBuffer[BUFFER_SIZE];        // Buffer that contains data read
                                                // from the file being displayed

unsigned long   cbBytesInBuffer;                // Total number of bytes in the
                                                // buffer

unsigned char*  puchPointer;                    // Points to the next character in
                                                // the buffer to be read

unsigned long   cStringSize;                    // Size of a string pointed by a
                                                // pointer in the ASCII table used
                                                // for the translation (asciiChar,
                                                // asciiC, asciiCode or asciiCtrl)
                                                // The contents of this variable is
                                                // meaningful only if -ch, -cC, -ce
                                                // or -cr was specified.
                                                // It is meaningless in all other
                                                // cases (no ascii translation is
                                                // being performed, and the ascii
                                                // tables are not needed)


/*************************************************************************
*
*                               A S C I I       C O N V E R S I O N   T A B L E S
*
*************************************************************************/


char*   asciiChar[ ] = {
        "   ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "   ", "   ", "  ", "  ", "   ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "   ", "  ", "  ", "  ", "  ", "  ",
        "   ", "!  ", "\"  ", "#  ", "$  ", "%  ", "&  ", "'  ",
        "(  ", ")  ", "*  ", "+  ", "'  ", "-  ", ".  ", "/  ",
        "0  ", "1  ", "2  ", "3  ", "4  ", "5  ", "6  ", "7  ",
        "8  ", "9  ", ":  ", ";  ", "<  ", "=  ", ">  ", "?  ",
        "@  ", "A  ", "B  ", "C  ", "D  ", "E  ", "F  ", "G  ",
        "H  ", "I  ", "J  ", "K  ", "L  ", "M  ", "N  ", "O  ",
        "P  ", "Q  ", "R  ", "S  ", "T  ", "U  ", "V  ", "W  ",
        "X  ", "Y  ", "Z  ", "[  ", "\\  ", "]  ", "^  ", "_  ",
        "`  ", "a  ", "b  ", "c  ", "d  ", "e  ", "f  ", "g  ",
        "h  ", "i  ", "j  ", "k  ", "l  ", "m  ", "n  ", "o  ",
        "p  ", "q  ", "r  ", "s  ", "t  ", "u  ", "v  ", "w  ",
        "x  ", "y  ", "z  ", "{  ", "|  ", "}  ", "~  ", "_  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "   "
};



char*   asciiC[ ] = {
        "   ", "  ", "  ", "  ", "  ", "  ", "  ", "\\a  ",
        "\\b  ", "\\t ", "\\n ", "\\v ", "\\f ", "   ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "   ", "  ", "  ", "  ", "  ", "  ",
        "   ", "!  ", "\\\" ", "#  ", "$  ", "%  ", "&  ", "\' ",
        "(  ", ")  ", "*  ", "+  ", "'  ", "-  ", ".  ", "/  ",
        "0  ", "1  ", "2  ", "3  ", "4  ", "5  ", "6  ", "7  ",
        "8  ", "9  ", ":  ", ";  ", "<  ", "=  ", ">  ", "?  ",
        "@  ", "A  ", "B  ", "C  ", "D  ", "E  ", "F  ", "G  ",
        "H  ", "I  ", "J  ", "K  ", "L  ", "M  ", "N  ", "O  ",
        "P  ", "Q  ", "R  ", "S  ", "T  ", "U  ", "V  ", "W  ",
        "X  ", "Y  ", "Z  ", "[  ", "\\\\ ", "]  ", "^  ", "_  ",
        "`  ", "a  ", "b  ", "c  ", "d  ", "e  ", "f  ", "g  ",
        "h  ", "i  ", "j  ", "k  ", "l  ", "m  ", "n  ", "o  ",
        "p  ", "q  ", "r  ", "s  ", "t  ", "u  ", "v  ", "w  ",
        "x  ", "y  ", "z  ", "{  ", "|  ", "}  ", "~  ", "_  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "   "
};



char*   asciiCode[ ] = {
        "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
        "BS ", "HT ", "LF ", "VT ", "FF ", "CR ", "SO ", "SI ",
        "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
        "CAN", "EM ", "SUB", "ESC", "FS ", "GS ", "RS ", "US ",
        "   ", "!  ", "\"  ", "#  ", "$  ", "%  ", "&  ", "'  ",
        "(  ", ")  ", "*  ", "+  ", "'  ", "-  ", ".  ", "/  ",
        "0  ", "1  ", "2  ", "3  ", "4  ", "5  ", "6  ", "7  ",
        "8  ", "9  ", ":  ", ";  ", "<  ", "=  ", ">  ", "?  ",
        "@  ", "A  ", "B  ", "C  ", "D  ", "E  ", "F  ", "G  ",
        "H  ", "I  ", "J  ", "K  ", "L  ", "M  ", "N  ", "O  ",
        "P  ", "Q  ", "R  ", "S  ", "T  ", "U  ", "V  ", "W  ",
        "X  ", "Y  ", "Z  ", "[  ", "\\  ", "]  ", "^  ", "_  ",
        "`  ", "a  ", "b  ", "c  ", "d  ", "e  ", "f  ", "g  ",
        "h  ", "i  ", "j  ", "k  ", "l  ", "m  ", "n  ", "o  ",
        "p  ", "q  ", "r  ", "s  ", "t  ", "u  ", "v  ", "w  ",
        "x  ", "y  ", "z  ", "{  ", "|  ", "}  ", "~  ", "_  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "   "
};


char*   asciiCtrl[ ] = {
        "^@ ", "^A ", "^B ", "^C ", "^D ", "^E ", "^F ", "^G ",
        "^H ", "^I ", "^J ", "^K ", "^L ", "^M ", "^N ", "^O ",
        "^P ", "^Q ", "^R ", "^S ", "^T ", "^U ", "^V ", "^W ",
        "^X ", "^Y ", "^Z ", "^[ ", "^\\ ", "^] ", "^^ ", "^_ ",
        "   ", "!  ", "\"  ", "#  ", "$  ", "%  ", "&  ", "'  ",
        "(  ", ")  ", "*  ", "+  ", "'  ", "-  ", ".  ", "/  ",
        "0  ", "1  ", "2  ", "3  ", "4  ", "5  ", "6  ", "7  ",
        "8  ", "9  ", ":  ", ";  ", "<  ", "=  ", ">  ", "?  ",
        "@  ", "A  ", "B  ", "C  ", "D  ", "E  ", "F  ", "G  ",
        "H  ", "I  ", "J  ", "K  ", "L  ", "M  ", "N  ", "O  ",
        "P  ", "Q  ", "R  ", "S  ", "T  ", "U  ", "V  ", "W  ",
        "X  ", "Y  ", "Z  ", "[  ", "\\  ", "]  ", "^  ", "_  ",
        "`  ", "a  ", "b  ", "c  ", "d  ", "e  ", "f  ", "g  ",
        "h  ", "i  ", "j  ", "k  ", "l  ", "m  ", "n  ", "o  ",
        "p  ", "q  ", "r  ", "s  ", "t  ", "u  ", "v  ", "w  ",
        "x  ", "y  ", "z  ", "{  ", "|  ", "}  ", "~  ", "_  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "   "
};




void
ConvertASCII (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb,
        char*                   pTable[]
        )

/*++

Routine Description:

        This routine converts the bytes received in a buffer
        into an ASCII representation (Char, C, Code or CTRL).


Arguments:

        line - Buffer that will receive the converted characters.

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer

        pTable - Pointer to the table to be used in the conversion


Return Value:

    None

--*/


{
        unsigned long   ulIndex;

        sprintf( line,
                        MSG_DATA_ASCII_FMT,
                        pTable[ buf[ 0 ]], pTable[ buf[ 1 ]],
                        pTable[ buf[ 2 ]], pTable[ buf[ 3 ]],
                        pTable[ buf[ 4 ]], pTable[ buf[ 5 ]],
                        pTable[ buf[ 6 ]], pTable[ buf[ 7 ]],
                        pTable[ buf[ 8 ]], pTable[ buf[ 9 ]],
                        pTable[ buf[ 10 ]], pTable[ buf[ 11 ]],
                        pTable[ buf[ 12 ]], pTable[ buf[ 13 ]],
                        pTable[ buf[ 14 ]], pTable[ buf[ 15 ]]);
        //
        // If the number of bytes in the buffer is less than the maximum size
        // of the record, then delete the characters that were converted
        // but are not to be displayed.
        //
        if (cb < RECORD_SIZE) {
                //
                //      -1: to eliminate the \0
                //      +1: to count the SPACE character between two strings
                //
                ulIndex = (sizeof( MSG_ADDR_FIELD ) - 1 ) + cb*(cStringSize + 1);
                while ( line[ ulIndex ] != NUL ) {
                        line[ ulIndex ] = SPACE;
                        ulIndex++;
                }
        }
}




void
ConvertBYTE (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb,
        unsigned long   ulBase
        )

/*++

Routine Description:

        This routine converts each byte received in a buffer
        into a number. The base used in the conversion is received as
        parameter.



Arguments:

        line - Buffer that will receive the converted characters.

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer

        ulBase - Defines the base to be used in the conversion



Return Value:

    None

--*/


{
        unsigned long   ulIndex;
        char*                   pchMsg;
        unsigned long   ulNumberOfDigits;

        switch( ulBase ) {

                case DEC:
                        ulNumberOfDigits = 3;                   // needs 3 decimal digits to
                                                                                        // represent a byte
                        pchMsg = MSG_DATA_BYTE_DEC_FMT; // message that contains the format
                        break;

                case HEX:
                        ulNumberOfDigits = 2;                   // needs 2 hexdigits to
                                                                                        // represent a byte
                        pchMsg = MSG_DATA_BYTE_HEX_FMT; // message that contains the format
                        break;

                default:
                        printf( "Unknown base\n" );
                        assert( FALSE );
                        break;
        }

        sprintf( line,
                         pchMsg,
                         buf[ 0 ], buf[ 1 ],
                         buf[ 2 ], buf[ 3 ],
                         buf[ 4 ], buf[ 5 ],
                         buf[ 6 ], buf[ 7 ],
                         buf[ 8 ], buf[ 9 ],
                         buf[ 10 ], buf[ 11 ],
                         buf[ 12 ], buf[ 13 ],
                         buf[ 14 ], buf[ 15 ]);
        //
        // If this is the last record to be displayed, then delete the
        // characters that were translated but are not to be displayed.
        //
        if (cb < RECORD_SIZE) {
                ulIndex = (sizeof( MSG_ADDR_FIELD ) - 1 ) +
                                        cb*(ulNumberOfDigits + 1 );
                while ( line[ ulIndex ] != NUL ) {
                        line[ ulIndex ] = SPACE;
                        ulIndex++;
                }
        }
}




void
ConvertWORD (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb,
        unsigned long   ulBase
        )

/*++

Routine Description:

        This routine converts the data received in a buffer
        into numbers. The data in the buffer are interpreted as words.
        If the buffer contains an odd number of bytes, then the last byte
        is converted as a byte, not as word.
        The base used in the conversion is received as parameter.



Arguments:

        line - Buffer that will receive the converted characters.

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer

        ulBase - Defines the base to be used in the conversion



Return Value:

    None

--*/


{
        unsigned long   ulIndex;
        char*                   pchMsg;
        char*                   pchMsgHalf;
        unsigned long   ulNumberOfDigits;

        switch( ulBase ) {

                case DEC:
                        ulNumberOfDigits = 5;                           // needs 5 decimal digits to
                                                                                                // represent a word
                        pchMsg = MSG_DATA_WORD_DEC_FMT;         // message with the string
                                                                                                // format
                        pchMsgHalf = MSG_SINGLE_BYTE_DEC_FMT; // message with the format of
                        break;                                                          // half a word in decimal

                case HEX:
                        ulNumberOfDigits = 4;                           // needs 4 hex digits to
                                                                                                // represent a word
                        pchMsg = MSG_DATA_WORD_HEX_FMT;         // message the string format
                        pchMsgHalf = MSG_SINGLE_BYTE_HEX_FMT; // message with the format of
                                                                                                // half a word in hex
                        break;

                default:
                        printf( "Unknown base\n" );
                        assert( FALSE );
                        break;
        }

        sprintf( line,
                         pchMsg,
                         (( unsigned short* ) ( buf )) [ 0 ],
                         (( unsigned short* ) ( buf )) [ 1 ],
                         (( unsigned short* ) ( buf )) [ 2 ],
                         (( unsigned short* ) ( buf )) [ 3 ],
                         (( unsigned short* ) ( buf )) [ 4 ],
                         (( unsigned short* ) ( buf )) [ 5 ],
                         (( unsigned short* ) ( buf )) [ 6 ],
                         (( unsigned short* ) ( buf )) [ 7 ]);
        //
        // If this record contains less bytes than the maximum record size,
        // then it is the last record to be displayed. In this case we have
        // to verify if the record contains an even number of bytes. If it
        // doesn't, then the last byte must be interpreted as a byte and not
        // as a word.
        // Also, the characters that were converted but are not to be displayed,
        // have to be deleted.
        //
        if (cb < RECORD_SIZE) {
                ulIndex = (sizeof( MSG_ADDR_FIELD ) - 1 ) +
                                        (cb/2)*(ulNumberOfDigits + 1 );
                if (cb%2 != 0) {
                        ulIndex += sprintf( line + ulIndex,
                                                                pchMsgHalf,
                                                                buf[ cb-1 ]);
                        line[ ulIndex ] = SPACE;
                }
                //
                // Delete characters that are not to be displayed
                //
                while ( line[ ulIndex ] != NUL ) {
                        line[ ulIndex ] = SPACE;
                        ulIndex++;
                }
        }
}




void
ConvertDWORD (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb,
        unsigned long   ulBase
        )

/*++

Routine Description:

        This routine converts the data received in a buffer
        into numbers. The data in the buffer is interpreted as double words.
        If the buffer contains less bytes than the maximum size of the record,
        then it is the last record, and we may need to convert again the last
        3 bytes in the buffer.
        If the number of bytes in the buffer is not multiple of 4, then the
        last bytes in the buffer are converted as a byte, word, or word and
        byte, as appropriate.
        The characters that were converted but are not to be displayed have to
        be removed from the buffer.
        The base used in the conversion is received as parameter.



Arguments:

        line - Buffer that will receive the converted characters.

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer

        ulBase - Defines the base to be used in the conversion



Return Value:

    None

--*/


{
        unsigned long   ulIndex;
        char*                   pchMsg;
        char*                   pchMsgByte;
        char*                   pchMsgWord;
        char*                   pchMsgWordByte;
        unsigned long   ulNumberOfDigits;

        switch( ulBase ) {

                case DEC:
                        ulNumberOfDigits = 10;                          // needs 10 decimal digits to
                                                                                                // represent a dword
                        pchMsg = MSG_DATA_DWORD_DEC_FMT;        // message with the string
                                                                                                // format
                        pchMsgByte = MSG_SINGLE_BYTE_DEC_FMT; // message with the format
                                                                                                  // of a single byte in
                                                                                                  // decimal
                        pchMsgWord = MSG_SINGLE_WORD_DEC_FMT; // message that contains
                                                                                                  // the format of a single
                                                                                                  // word in decimal
                        pchMsgWordByte = MSG_WORD_BYTE_DEC_FMT;
                        break;

                case HEX:
                        ulNumberOfDigits = 8;                           // needs 8 hex digits to
                                                                                                // represent a dword
                        pchMsg = MSG_DATA_DWORD_HEX_FMT;        // message the string format
                        pchMsgByte = MSG_SINGLE_BYTE_HEX_FMT; // message with the format
                                                                                                  // of a single byte in hex
                        pchMsgWord = MSG_SINGLE_WORD_HEX_FMT; // message with the format
                                                                                                  // of a single word in hex
                        pchMsgWordByte = MSG_WORD_BYTE_HEX_FMT;
                        break;

                default:
                        printf( "Unknown base\n" );
                        assert( FALSE );
                        break;
        }

        sprintf( line,
                         pchMsg,
                         (( unsigned long* ) ( buf )) [ 0 ],
                         (( unsigned long* ) ( buf )) [ 1 ],
                         (( unsigned long* ) ( buf )) [ 2 ],
                         (( unsigned long* ) ( buf )) [ 3 ]);
        //
        // If the buffer contains less bytes than the maximum record size,
        // the it is the last buffer to be displayed. In this case, check if
        // if the buffer contains a number o bytes that is multiple of 4.
        // If it doesn't, then converts the last bytes as a byte, a word, or
        // a word and a byte, as appropriate.
        //
        if (cb < RECORD_SIZE) {
                ulIndex = (sizeof( MSG_ADDR_FIELD ) - 1 ) +
                        (cb/4)*(ulNumberOfDigits + 1 );
                switch( cb%4 ) {

                        case 1:
                                ulIndex += sprintf( line + ulIndex,
                                                                        pchMsgByte,
                                                                        buf[ cb-1 ]);
                                line[ ulIndex ] = SPACE;
                                break;

                        case 2:
                                ulIndex += sprintf( line + ulIndex,
                                                                        pchMsg,
                                                                        (( unsigned short* ) ( buf )) [ (cb/2) - 1 ]);
                                line[ ulIndex ] = SPACE;
                                break;

                        case 3:
                                ulIndex += sprintf( line + ulIndex,
                                                                        pchMsgWordByte,
                                                                        (( unsigned short* ) ( buf )) [ (cb/2) - 1],
                                                                        buf[ cb-1 ]);
                                line[ ulIndex ] = SPACE;
                                break;

                        default:                                // buf contains multiple of 4 bytes
                                break;
                }
                //
                // Delete the charecters that were converted but are not to be
                // displayed.
                //
                while ( line[ ulIndex ] != NUL) {
                        line[ ulIndex ] = SPACE;
                        ulIndex++;
                }
        }
}




void
ConvertPRINT (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb
        )

/*++

Routine Description:

        This routine converts each byte received in a buffer into a
        printable character.


Arguments:

        line - Buffer that will receive the converted characters.

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer


Return Value:

    None

--*/

{


        sprintf( line,
                        MSG_PRINT_CHAR_FMT,
                        isprint( buf[ 0 ] ) ? buf[ 0 ] : DOT,
                        isprint( buf[ 1 ] ) ? buf[ 1 ] : DOT,
                        isprint( buf[ 2 ] ) ? buf[ 2 ] : DOT,
                        isprint( buf[ 3 ] ) ? buf[ 3 ] : DOT,
                        isprint( buf[ 4 ] ) ? buf[ 4 ] : DOT,
                        isprint( buf[ 5 ] ) ? buf[ 5 ] : DOT,
                        isprint( buf[ 6 ] ) ? buf[ 6 ] : DOT,
                        isprint( buf[ 7 ] ) ? buf[ 7 ] : DOT,
                        isprint( buf[ 8 ] ) ? buf[ 8 ] : DOT,
                        isprint( buf[ 9 ] ) ? buf[ 9 ] : DOT,
                        isprint( buf[ 10 ] ) ? buf[ 10 ] : DOT,
                        isprint( buf[ 11 ] ) ? buf[ 11 ] : DOT,
                        isprint( buf[ 12 ] ) ? buf[ 12 ] : DOT,
                        isprint( buf[ 13 ] ) ? buf[ 13 ] : DOT,
                        isprint( buf[ 14 ] ) ? buf[ 14 ] : DOT,
                        isprint( buf[ 15 ] ) ? buf[ 15 ] : DOT);
        //
        // If the buffer contains less characters than the maximum record size,
        // then delete the characters that were converted but are not to be
        // displayed
        //
        if (cb < RECORD_SIZE) {
                while ( line[ cb ] != NUL ) {
                        line[ cb ] = SPACE;
                        cb++;
                }
        }
}






void
Translate (
        FORMAT                  fmt,
        unsigned char   buf[ ],
        unsigned long   cb,
        char                    line[ ]
        )

/*++

Routine Description:

        This function converts the bytes received in a buffer
        into a printable representation, that corresponds to one
        of the formats specified by the parameter fmt.


Arguments:

        fmt - The format to be used in the conversion

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer

        line - Buffer that will receive the converted characters.


Return Value:

        None

--*/


{
        assert( buf );
        assert( line );

        switch( fmt ) {

                case ASCII_CHAR:
                        ConvertASCII( line, buf, cb, asciiChar );
                        break;

                case ASCII_C:
                        ConvertASCII( line, buf, cb, asciiC );
                        break;

                case ASCII_CODE:
                        ConvertASCII( line, buf, cb, asciiCode );
                        break;

                case ASCII_CTRL:
                        ConvertASCII( line, buf, cb, asciiCtrl );
                        break;

                case BYTE_DEC:
                        ConvertBYTE( line, buf, cb, DEC );
                        break;

                case BYTE_HEX:
                        ConvertBYTE( line, buf, cb, HEX );
                        break;

                case WORD_DEC:
                        ConvertWORD( line, buf, cb, DEC );
                        break;

                case WORD_HEX:
                        ConvertWORD( line, buf, cb, HEX );
                        break;

                case DWORD_DEC:
                        ConvertDWORD( line, buf, cb, DEC );
                        break;

                case DWORD_HEX:
                        ConvertDWORD( line, buf, cb, HEX );
                        break;

                case PRINT_CHAR:
                        ConvertPRINT( line, buf, cb );
                        break;


                default:
                        printf( "Bad Format\n" );
                        assert( FALSE );
                        break;
        }
}





void
PutAddress (
        char                    line[],
        unsigned long   ulAddress,
        BASE                    Base
        )

/*++

Routine Description:

        This routine adds to the buffer received the offset of the first
        byte (or character) already in the buffer. This offset represents
        the position of the byte in the file, relatively to the begining
        of the file.


Arguments:

        Base - The base to be used to represent the offset.

        line - Buffer containing the converted characters to be displayed in
                   the screen

        ulAddress - Offset to be added to the begining of the buffer


Return Value:

    None

--*/

{
        unsigned long   ulIndex;

        assert( line);

        switch( Base ) {

                case DEC:
                        ulIndex = sprintf( line,
                                                           MSG_ADDR_DEC_FMT,
                                                           ulAddress );
                        break;

                case HEX:
                        ulIndex = sprintf( line,
                                                           MSG_ADDR_HEX_FMT,
                                                           ulAddress);
                        break;

                default:
                        printf( "Bad Address Base\n" );
                        assert( FALSE );
                        break;
        }
        line[ ulIndex ] = SPACE;   // Get rid of the NUL added by sprintf
}






void
PutTable (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb
        )

/*++

Routine Description:

        This routine adds to the end of the buffer received, the ASCII
        representation of all printable characters already in the buffer.
        Characters that are not printable (smaller than 0x20 or greater than
        0x7f) are displayed as a dot.


Arguments:

        line - Buffer containing the characters to be displayed in one line
                   of the screen

        buf - The buffer that contains a record of bytes (maximum of 16)
                  read from the file being displayed.

    ulAddress - Number of bytes in buf.


Return Value:

    None

--*/

    {

        unsigned long   ulIndex;

        assert( line );
        assert( buf );

        ulIndex = strlen (line);
        Translate( PRINT_CHAR, buf, cb, (line + ulIndex));
}




void
InterpretArgument (
        char*   pchPointer
        )

/*++

Routine Description:

    This routine interprets an argument typed by the user (exept -n
    and -s) and initializes some variables accordingly.


Arguments:

    pchPointer - Pointer to the argument to be interpreted.


Return Value:

    None

--*/

        {
        //
        // pchPointer will point to the character that follows '-'
        //
        pchPointer++;
        if( strcmp( pchPointer, "ax" ) == 0 ) {
                AddrFormat = HEX;
        }
        else if( strcmp( pchPointer, "ad" ) == 0 ) {
                AddrFormat = DEC;
        }
        else if( strcmp( pchPointer, "ch" ) == 0 ) {
                DispFormat = ASCII_CHAR;
                cStringSize = strlen( asciiChar[0] );
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "cC" ) == 0 ) {
                DispFormat = ASCII_C;
                cStringSize = strlen( asciiC[0] );
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "ce" ) == 0 ) {
                DispFormat = ASCII_CODE;
                cStringSize = strlen( asciiCode[0] );
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "cr" ) == 0 ) {
                DispFormat = ASCII_CTRL;
                cStringSize = strlen( asciiCtrl[0] );
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "bd" ) == 0 ) {
                DispFormat = BYTE_DEC;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "bx" ) == 0 ) {
                DispFormat = BYTE_HEX;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "wd" ) == 0 ) {
                DispFormat = WORD_DEC;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "wx" ) == 0 ) {
                DispFormat = WORD_HEX;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "ld" ) == 0 ) {
                DispFormat = DWORD_DEC;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "lx" ) == 0 ) {
                DispFormat = DWORD_HEX;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "A" ) == 0 ) {
                DumpAscii = YES;
        }
        else if( strcmp( pchPointer, "i" ) == 0 ) {
                IgnoreRedundantLines = 1;
        }
        else if( strcmp( pchPointer, "?" ) || strcmp( pchPointer, "h" ) ||
                         strcmp( pchPointer, "H" ) ) {
                puts( HELP_MESSAGE );
                exit( 0 );
        }
        else {
                fprintf( stderr, "hd: error: invalid argument '%s'\n", --pchPointer );
                exit( - 1 );
        }
}





unsigned long
GetRecord (
        unsigned char*  puchRecord,
        FILE*                   pf
        )

/*++

Routine Description:

        This routine fills the buffer whose pointer was received as parameter,
        with characters read from the file being displayed. Blocks of data
        are initially read from the file being displayed, and kept in a buffer.
        A record is filled with characters obtained from this buffer.
        Whenever this buffer gets empty, a new access to file is performed
        in order to fill this buffer.


Arguments:

        puchRecord - Pointer to the record to be filled
        pf - Pointer to the file that is being displayed


Return Value:

        Total number of characters put in the record.

--*/

{
unsigned long   cbBytesCopied;

   //
   // If the buffer contains enogh characters to fill the record, then
   // copy the appropriate number of bytes.
   //
        if( cbBytesInBuffer >= RECORD_SIZE ) {
                for( cbBytesCopied = 0; cbBytesCopied < RECORD_SIZE; cbBytesCopied++ ) {
                        *puchRecord++ = *puchPointer++;
                        cbBytesInBuffer--;
                }
        }

        //
        // else, the buffer does not contain enough characters to fill the record
        //
        else {
                //
                // Copy to the remaining characters in the buffer to the record
                //
                for( cbBytesCopied = 0; cbBytesInBuffer > 0; cbBytesInBuffer-- ) {
                        *puchRecord++ = *puchPointer++;
                        cbBytesCopied++;
                }
                //
                // Read more data from the file and fill the record
                //
                if( !feof( pf ) ) {
                        cbBytesInBuffer = fread( auchBuffer,
                                                                         sizeof( char ),
                                                                         BUFFER_SIZE,
                                                                         pf );
                        puchPointer = auchBuffer;
                        while( ( cbBytesInBuffer != 0 ) && (cbBytesCopied < RECORD_SIZE) ) {
                                *puchRecord++ = *puchPointer++;
                                cbBytesInBuffer--;
                                cbBytesCopied++;
                        }
                }
        }
        return( cbBytesCopied );
}







int
hd(
        FILE *  pf
        )
/*++ hd
*
* Routine Description:
*       takes the file/stream pointed to by pf and `hd's it to stdout.
*
* Arguments:
*               FILE *  pf      -
*
* Return Value:
*               int - to be determined, always zero for now
* Warnings:
--*/
{
        unsigned char   buf[ RECORD_SIZE ];
        char                    line[ LINE_SIZE ];
        char            Previousline[ LINE_SIZE ];
        int             printedstar;

        unsigned long   CurrentAddress;
        unsigned long   cNumberOfBlocks;
        unsigned                cLastBlockSize;
        unsigned long   cb;

        //
        //      Determine number of records to be displayed, and size of
        //      last record
        //

        CurrentAddress = Offset;
        cNumberOfBlocks = Count / RECORD_SIZE;
        cLastBlockSize = Count % RECORD_SIZE;
        if( cLastBlockSize ) {
                cNumberOfBlocks++;
        }
        else {
                cLastBlockSize = RECORD_SIZE;
        }

        //
        //      Initialize global variables related to auchBuffer
        //

        cbBytesInBuffer = 0;
        puchPointer = auchBuffer;

        //
        //      Position the file in the correct place, and display
        //      its contents according to the arguments specified by the
        //      user
        //

        if ( pf != stdin ) {
                if (fseek( pf, Offset, SEEK_SET ) == -1) return 0;
        }
        //...maybe enable skipping Offset number of bytes for stdin...

        printedstar = 0;

        while( ( (cb = GetRecord( buf, pf )) != 0) && cNumberOfBlocks ) {
                cNumberOfBlocks--;
                if ( cNumberOfBlocks == 0 ) {
                        cb = ( cb < cLastBlockSize ) ? cb : cLastBlockSize;
                }
                Translate( DispFormat, buf, cb, line );

                if (IgnoreRedundantLines && (strcmp( Previousline, line ) == 0)) {

                    if (!printedstar) { printf("*\n"); }
                    printedstar = 1;

                } else {

                    printedstar = 0;

                    strcpy( Previousline, line );

                    PutAddress( line, CurrentAddress, AddrFormat );
                    if ( (DumpAscii == YES) || (DumpAscii == NOT_DEFINED) )
                            {
                            PutTable ( line, buf, cb );
                    }
                    puts( line );
                }

                CurrentAddress += RECORD_SIZE;
        }
        return 0;
}
/* end of "int hd()" */




void
__cdecl main(
        int             argc,
        char*   argv[ ]
        )

/*++

Routine Description:

        This routine interprets all arguments entered by the user, and
        displays the files specified in the appropriate format.
        The contents of each file is displayed interpreted as a set of
        record containing 16 bytes each.


Arguments:

    argc - number of arguments in the command line
    argv[] - array of pointers to the arguments entered by the user


Return Value:

    None

--*/


{
        FILE*                   pf;
//.     unsigned char   buf[ RECORD_SIZE ];
//.     char                    line[ LINE_SIZE ];
        int                             ArgIndex;
        int                             status;

//.     unsigned long   CurrentAddress;
//.     unsigned long   cNumberOfBlocks;
//.     unsigned                cLastBlockSize;
//.     unsigned long   cb;
        unsigned long   Value;
        unsigned char*  pPtrString;

//.     printf( "\n\n" );                               //.gratuitous newlines removed
                                                                        // Initialization of global variables
        Offset = 0;
        Count = (unsigned long)-1;                      // Maximum file size
        AddrFormat = HEX;
        DispFormat = BYTE_HEX;
        DumpAscii = NOT_DEFINED;
        IgnoreRedundantLines = 0;

        ArgIndex = 1;
        while ( (ArgIndex < argc) && (( *argv[ ArgIndex ] == '-' )) ) {

                //
                // Determine the type of argument
                //

                if( (*(argv[ ArgIndex ] + 1) == 's') ||
                        (*(argv[ ArgIndex ] + 1) == 'n') ) {

                                //
                                // If argument is -s or -n, interprets the number that
                                // follows the argument
                                //

                                if ( (ArgIndex + 1) >= argc ) {
                                        fprintf(stderr,
                                                "hd: error: missing count/offset value after -%c\n",
                                                *(argv[ ArgIndex ] + 1) );
                                        exit (-1);
                                }
                                Value = strtoul( argv[ ArgIndex + 1 ], &pPtrString, 0 );
                                if( *pPtrString != 0 ) {
                                        fprintf(stderr,
                                                "hd: error: invalid count/offset value after -%c\n",
                                                *(argv[ ArgIndex ] + 1) );
                                        exit( -1 );
                                }
                                if( *(argv[ ArgIndex ] + 1) == 's' ) {
                                        Offset = Value;
                                }
                                else {
                                        Count = Value;
                                }
                                ArgIndex += 2;
                }
                else {

                        //
                        // Interprets argument other than -s or -n
                        //

                        InterpretArgument ( argv[ ArgIndex ] );
                        ArgIndex++;
                }
        }

        if ( ArgIndex >= argc ) {
//.             printf ( "Error: file name is missing \n" );
                status = hd( stdin );
                exit( 0 );
        }


        //
        //      For each file, do
        //

        while ( ArgIndex < argc ) {

                //
                //      Open file
                //

                if ( !( pf = fopen( argv[ ArgIndex ], "rb" ) ) ) {
                        fprintf(stderr, "hd: error: invalid file name '%s'\n",
                                argv[ ArgIndex ] );
                        ArgIndex++;
                        continue;                               //. don't abort if it's only a bad filename
//.                     exit( -1 );
                }

                //
                //      Print file name
                //

//.             printf( "\n\n" );
                printf( "%s: \n", argv[ ArgIndex ] );
                ArgIndex++;

                status = hd( pf );

//.             //
//.             //      Determine number of records to be displayed, and size of
//.             //      last record
//.             //
//.
//.             CurrentAddress = Offset;
//.             cNumberOfBlocks = Count / RECORD_SIZE;
//.             cLastBlockSize = Count % RECORD_SIZE;
//.             if( cLastBlockSize ) {
//.                     cNumberOfBlocks++;
//.             }
//.             else {
//.                     cLastBlockSize = RECORD_SIZE;
//.             }
//.
//.             //
//.             //      Initialize global variables related to auchBuffer
//.             //
//.
//.             cbBytesInBuffer = 0;
//.             puchPointer = auchBuffer;
//.
//.             //
//.             //      Position the file in the correct place, and display
//.             //      its contents according to the arguments specified by the
//.             //      user
//.             //
//.
//.             fseek( pf, Offset, SEEK_SET );
//.             while( ( (cb = GetRecord( buf, pf )) != 0) && cNumberOfBlocks ) {
//.                     cNumberOfBlocks--;
//.                     if ( cNumberOfBlocks == 0 ) {
//.                             cb = ( cb < cLastBlockSize ) ? cb : cLastBlockSize;
//.                     }
//.                     Translate( DispFormat, buf, cb, line );
//.                     PutAddress( line, CurrentAddress, AddrFormat );
//.                     if ( (DumpAscii == YES) || (DumpAscii == NOT_DEFINED) )
//.                             {
//.                             PutTable ( line, buf, cb );
//.                     }
//.                     puts( line );
//.
//.                     CurrentAddress += RECORD_SIZE;
//.             }
        }
}
/* end of "void main()" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hdivide\getopt.c ===
/*
        getopt.c

        modified public-domain AT&T getopt(3)
*/

#include <stdio.h>
#include <string.h>

#ifdef _POSIX_SOURCE
#       include <unistd.h>
#else
#       define STDERR_FILENO 2
#       ifdef __STDC__
                extern int write (int fildes, char * buf, unsigned nbyte);
#       else
                extern int write ();
#       endif
#endif

int opterr = 1;
int optind = 1;
int optopt;
char *optarg;

static void ERR(char **argv, char *s, char c)
{
    if (opterr) {
        fprintf(stderr, "%s%s%c\n", argv[0], s, c);
    }
}

int getopt(int argc, char **argv, char *opts)
{
    static int sp = 1, error = (int) '?';
    static char sw = '-', eos = '\0', arg = ':';
    char c, * cp;

    if (sp == 1)
        if (optind >= argc || argv[optind][0] != sw
            || argv[optind][1] == eos)
            return EOF;
        else if (strcmp(argv[optind],"--") == 0) {
            optind++;
            return EOF;
        }
    c = argv[optind][sp];
    optopt = (int) c;
    if (c == arg || (cp = strchr(opts,c)) == NULL) {
        ERR(argv,": illegal option: -",c);
        if (argv[optind][++sp] == eos) {
            optind++;
            sp = 1;
        }
        return error;
    }
    else if (*++cp == arg) {
        if (argv[optind][sp + 1] != eos)
            optarg = &argv[optind++][sp + 1];
        else if (++optind >= argc) {
            ERR(argv,": option requires an argument--",c);
            sp = 1;
            return error;
        }
        else
            optarg = argv[optind++];
        sp = 1;
    }
    else {
        if (argv[optind][++sp] == eos) {
            sp = 1;
            optind++;
        }
        optarg = NULL;
    }
    return (int)c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\he\he.c ===
/*****************************************************************/
/**          Microsoft LAN Manager          **/
/**        Copyright(c) Microsoft Corp., 1988-1991      **/
/*****************************************************************/

/****   he - HexEdit a file
 *
 *  Wrapper to HexEdit function to allow file (or drive) editting
 *
 *  Written: Ken Reneris
 *
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <windows.h>
#include "hexedit.h"

NTSTATUS fncRead(HANDLE, ULONGLONG, PUCHAR, DWORD);
NTSTATUS fncWrite(HANDLE, ULONGLONG, PUCHAR, DWORD);

void EditFile (char *name);
void ReadIni ();

WORD vAttrList, vAttrTitle, vAttrHigh;

VOID __cdecl
main (argc, argv)
USHORT  argc;
char    *argv[];
{
    char *argument = argv[1];

    if (argc < 2) {
        printf ("he fname\n");
        exit (1);
    }

    ReadIni  ();

    if ((strncmp(argv[1], "\\\\.\\", 4)) == 0) {
        char *cp;
        int   index;

        // Insure there is a backslash on the DosName being opened.
        for (cp = argv[1], index = 0; *cp; *cp++, index++) {
            // action in for loop
        }
        cp--;
        if (*cp != '\\') {

            // Need to add backslash to name.

            argument = GlobalAlloc (0,index + 4);
            if (!argument) {
                printf("Out of memory\n");
                exit (1);
            }
            for (cp = argv[1], index = 0; argument[index] = *cp; *cp++, index++) {
                // action in for loop
            }
            argument[index] = '\\';
            argument[index + 1] = '\0';
        }
    }
    EditFile (argument);
}



void
EditFile (
    char *name
    )
{
    FILE_ALIGNMENT_INFORMATION AlignmentInfo;
    PDISK_GEOMETRY_EX              DiskGeo;
    ULONGLONG          li;
    struct  HexEditParm     ei;
    USHORT              rc, rc1, i, l;
    PWSTR               WideName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    UNICODE_STRING      NtDriveName;
    ANSI_STRING         NtDriveNameAnsi;
    IO_STATUS_BLOCK     status_block;
    UCHAR               GeoBuf[ 8*1024];
    UCHAR               Root[12];

    //
    // Try to open & edit as regular filename
    //

    memset ((PUCHAR) &ei, 0, sizeof (ei));
    ei.ename   = name;
    ei.flag    = FHE_VERIFYONCE | FHE_SAVESCRN | FHE_JUMP;
    ei.read    = fncRead;
    ei.write   = fncWrite;
    ei.ioalign = 1;
    ei.Console = INVALID_HANDLE_VALUE;
    ei.AttrNorm = vAttrList;
    ei.AttrHigh = vAttrTitle;
    ei.AttrReverse = vAttrHigh;

    ei.handle = CreateFile (
            name,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL );

    if (ei.handle == INVALID_HANDLE_VALUE) {
        // Try for just read access

        ei.handle = CreateFile (
                name,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL );
    }


    if (ei.handle != INVALID_HANDLE_VALUE) {

        ULONG High = 0;

        ei.totlen = 0;
        ei.totlen = SetFilePointer (ei.handle, 0, &High, FILE_END);
        ei.totlen |= ((ULONGLONG)High) << 32;

        HexEdit (&ei);
        return;
    }

    rc = (USHORT)GetLastError ();

    //
    // Try expanding the name from dosname to ntname.
    // Since regular name failed, assume a sector edit
    //
    l = strlen(name)+1;
    WideName = GlobalAlloc (0,l * sizeof(WCHAR));
    if (!WideName) {
        printf("Out of memory\n");
        exit(1);
    }

    ZeroMemory(WideName, l*sizeof(WCHAR));

    for(i=0; i < l; i++)
        WideName[i] = name[i];

    // OK, now get the corresponding NT name
    rc1 = RtlDosPathNameToNtPathName_U (
            WideName,
            &NtDriveName,
            NULL,
            NULL );

    if (!rc1) {
        printf ("Open error %d\n", rc);
        exit (rc);
    }


    //  If the NT drive name has a trailing backslash, remove it.
    l = NtDriveName.Length/sizeof(WCHAR);
    if( NtDriveName.Buffer[l-1] == '\\' ) {

        NtDriveName.Buffer[l-1] = 0;
        NtDriveName.Length -= sizeof(WCHAR);
    }

    InitializeObjectAttributes(
            &oa,
            &NtDriveName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile(
            &ei.handle,
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
            &oa,
            &status_block,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_SYNCHRONOUS_IO_ALERT );

    if (!NT_SUCCESS(status)) {
        // try for just read access

        status = NtOpenFile(
                    &ei.handle,
                    SYNCHRONIZE | FILE_READ_DATA,
                    &oa,
                    &status_block,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_SYNCHRONOUS_IO_ALERT );
    }

    if (!NT_SUCCESS(status)) {
        NtDriveName.Length = strlen(name) * sizeof(WCHAR);
        NtDriveName.Buffer = WideName;

        InitializeObjectAttributes(
                &oa,
                &NtDriveName,
                OBJ_CASE_INSENSITIVE,
                0,
                0 );

        status = NtOpenFile(
                &ei.handle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                &oa,
                &status_block,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_ALERT );

        if (!NT_SUCCESS(status)) {
            // try for just read access

            status = NtOpenFile(
                        &ei.handle,
                        SYNCHRONIZE | FILE_READ_DATA,
                        &oa,
                        &status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT );
        }
    }


    RtlUnicodeStringToAnsiString (&NtDriveNameAnsi, &NtDriveName, TRUE);
    ei.ename = NtDriveNameAnsi.Buffer;

    if (!NT_SUCCESS(status)) {
        printf ("%s open error %lx\n", ei.ename, status);
        exit (status);
    }
/*
    NtQueryInformationFile(
        ei.handle,
        &status_block,
        &AlignmentInfo,
        sizeof( AlignmentInfo ),
        FileAlignmentInformation );
    
    ei.ioalign = AlignmentInfo.AlignmentRequirement;
*/
    ei.ioalign = 0;
    
    ei.totlen = 0;
    
    if (NtDriveNameAnsi.Buffer[ NtDriveNameAnsi.Length - 1] == ':')  {

        sprintf( Root, "%c:\\", NtDriveNameAnsi.Buffer[ NtDriveNameAnsi.Length - 2]);

        //
        //  For non-cdrom drive letter opens,  we need to use
        //  get partition info,  not get disk info,  for the partition size.
        //
        
        if (DRIVE_CDROM != GetDriveType( Root))  {

            PPARTITION_INFORMATION Part = (PVOID)GeoBuf;
            
            status = NtDeviceIoControlFile(
                    ei.handle,
                    0,
                    NULL,
                    NULL,
                    &status_block,
                    IOCTL_DISK_GET_PARTITION_INFO,
                    NULL,
                    0,
                    GeoBuf,
                    sizeof( GeoBuf) );

            if (NT_SUCCESS(status)) {

                ei.totlen = Part->PartitionLength.QuadPart;
            }
        }
    }

    //
    //  Get sectorsize and,  if we haven't got it already,  disk/partition size
    //
    
    status = NtDeviceIoControlFile( ei.handle,
                                    0,
                                    NULL,
                                    NULL,
                                    &status_block,
                                    IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,
                                    NULL,
                                    0,
                                    GeoBuf,
                                    sizeof( GeoBuf) );

    if (NT_SUCCESS(status)) {

        DiskGeo = (PVOID)GeoBuf;

        if (ei.ioalign < DiskGeo->Geometry.BytesPerSector)  {

            ei.ioalign = DiskGeo->Geometry.BytesPerSector;
        }
        
        if (0 == ei.totlen)  {
        
            ei.totlen = DiskGeo->DiskSize.QuadPart;
        }
    }
    else {

        //
        //  The EX call failed,  try the old one.  GPT discs seem
        //  to fail the EX call.
        //
        
        PDISK_GEOMETRY OldGeo;
        
        status = NtDeviceIoControlFile( ei.handle,
                                        0,
                                        NULL,
                                        NULL,
                                        &status_block,
                                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        NULL,
                                        0,
                                        GeoBuf,
                                        sizeof( GeoBuf) );

        if (NT_SUCCESS(status)) {

            OldGeo = (PVOID)GeoBuf;

            if (ei.ioalign < OldGeo->BytesPerSector)  {
            
                ei.ioalign = OldGeo->BytesPerSector;
            }
            
            if (0 == ei.totlen)  {
            
                ei.totlen = OldGeo->Cylinders.QuadPart * OldGeo->BytesPerSector *
                            OldGeo->SectorsPerTrack * OldGeo->TracksPerCylinder;
            }
        }
    }

    //
    //  Last resort for partition/disk size.
    //
    
    if (0 == ei.totlen)  {

        ULONG High = 0;

        if (ei.ioalign < 0x200)  {
        
            ei.ioalign = 0x200;
        }

        ei.totlen = 0;
        ei.totlen = SetFilePointer (ei.handle, 0, &High, FILE_END);
        ei.totlen |= ((ULONGLONG)High) << 32;
    }

    //
    //  If a filesystem is mounted,  we need to enable extended
    //  DASD io in order to read the whole volume.  Ignore result,
    //  not all FSs support it.
    //

    status = NtDeviceIoControlFile(
        ei.handle,
        0,
        NULL,
        NULL,
        &status_block,
        FSCTL_ALLOW_EXTENDED_DASD_IO,
        NULL,
        0,
        NULL,
        0);

    ei.flag = FHE_VERIFYALL | FHE_PROMPTSEC | FHE_SAVESCRN | FHE_JUMP;
    HexEdit (&ei);
}


NTSTATUS fncRead (HANDLE  h, ULONGLONG loc, PUCHAR data, DWORD   len)
{
    DWORD   l, br;
    ULONG High = (ULONG)(loc >> 32);

    l = SetFilePointer (h, (ULONG)loc, &High, FILE_BEGIN);
    if (l == -1)
        return GetLastError();

    if (!ReadFile (h, data, len, &br, NULL))
        return GetLastError();

    return (br != len ? ERROR_READ_FAULT : 0);
}


NTSTATUS fncWrite (HANDLE  h, ULONGLONG loc, PUCHAR  data, DWORD   len)
{
    DWORD    l, bw;
    ULONG High = (ULONG)(loc >> 32);

    l = SetFilePointer (h, (ULONG)loc, &High, FILE_BEGIN);
    if (l == -1)
        return GetLastError();

    if (!WriteFile (h, data, len, &bw, NULL))
        return GetLastError();

    return (bw != len ? ERROR_WRITE_FAULT : 0);
}



/*** xtoi - Hex to int
 *
 *  Entry:
 *      pt -    pointer to hex number
 *
 *  Return:
 *      value of hex number
 *
 */
unsigned xtoi (pt)
char *pt;
{
    unsigned    u;
    char        c;

    u = 0;
    while (c = *(pt++)) {
        if (c >= 'a'  &&  c <= 'f')
            c -= 'a' - 'A';
        if ((c >= '0'  &&  c <= '9')  ||  (c >= 'A'  &&  c <= 'F'))
            u = u << 4  |  c - (c >= 'A' ? 'A'-10 : '0');
    }
    return (u);
}


void
ReadIni ()
{
    static  char    Delim[] = " :=;\t\r\n";
    FILE    *fp;
    char    *env, *verb, *value;
    char    s [200];
    long    l;


    env = getenv ("INIT");
    if (env == NULL)
        return;

    if ((strlen(env) + sizeof ("\\TOOLS.INI") + 1) > sizeof(s))
        return;

    strcpy (s, env);
    strcat (s, "\\TOOLS.INI");      // just use list ini section
    fp = fopen (s, "r");
    if (fp == NULL)
        return;

    while (fgets (s, 200, fp) != NULL) {
        if (s[0] != '[')
            continue;
        _strupr (s);
        if (strstr (s, "LIST") == NULL)
            continue;
        /*
         *  ini file found w/ "list" keyword. Now read it.
         */
        while (fgets (s, 200, fp) != NULL) {
            if (s[0] == '[')
                break;
            verb  = strtok (s, Delim);
            value = strtok (NULL, Delim);
            if (verb == NULL)
                continue;
            if (value == NULL)
                value = "";

            _strupr (verb);
            if (strcmp (verb, "LCOLOR")  == 0) vAttrList = (WORD)xtoi(value);
            else if (strcmp (verb, "TCOLOR")  == 0) vAttrTitle= (WORD)xtoi(value);
            else if (strcmp (verb, "HCOLOR")  == 0) vAttrHigh = (WORD)xtoi(value);
        }
        break;
    }
    fclose (fp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\he\hexedit.c ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1988-1990          **/
/*****************************************************************/

/****   hexedit.c  - Generic sector based hex editor function call
 *
 *  Fill out a HexEditParm structure, and call HexEdit.  It provides
 *  a simple hex editor with a few misc features.
 *
 *  Is single threaded & non-reentrant, but can be called from any thread.
 *
 *  External uses:
 *      he          - allows editing of a file
 *
 *  Written: Ken Reneris    2/25/91
 *
 */


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include "hexedit.h"
#include <stdarg.h>

#define LOCAL   static
// #define LOCAL

#define BUFSZ       (HeGbl.BufferSize)
#define SECTORMASK  (HeGbl.SectorMask)
#define SECTORSHIFT  (HeGbl.SectorShift)


static UCHAR rghexc[] = "0123456789ABCDEF";

struct Buffer {
    struct  Buffer    *next;
    ULONGLONG   offset;
    ULONGLONG   physloc;
    USHORT      flag;
    USHORT      len;
    UCHAR       *data;
    UCHAR       orig[0];
} ;
#define FB_DIRTY    0x0001              // Buffer may be dirty
#define FB_BAD      0x0002              // Buffer had an error when read in

#define LINESZ      16                  // 16 bytes per display line
#define LINESHIFT   4L
#define LINEMASK    0xFFFFFFFFFFFFFFF0
#define CELLPERLINE 88

struct Global {
    struct      HexEditParm  *Parm;
    HANDLE      Console;                // Internal console handle
    HANDLE      StdIn;
    NTSTATUS    (*Read)(HANDLE, ULONGLONG, PUCHAR, DWORD);              // Copy of HeGbl.Parm->read
    ULONG       Flag;                   // Copy of HeGbl.Parm->flag
    ULONGLONG   TotLen;                 // Sizeof item being editted
    ULONGLONG   TotLen1;                // Sizeof item being editted - 1
    USHORT      Lines;                  // # of lines in edit screen
    USHORT      LineTot;                // # of lines totaly in use
    USHORT      PageSz;                 // sizeof page in bytes
    USHORT      TopLine;                // TopLine edit starts at
    ULONGLONG   CurOffset;              // Relative offset of first line
    ULONGLONG   CurEditLoc;             // Location with cursor
    UCHAR       *CurPT;                 // Pointer to data where cursor is
    UCHAR       CurAscIndent;
    UCHAR       DWidth;                 // width of dispalymode
    UCHAR       na;
    struct      Buffer *CurBuf;         // Buffer which cursor is in
    ULONG       CurFlag;                // Cursor info
    ULONG       DisplayMode;            // Mask of displaymode
    ULONG       ItemWrap;               // Mask of displaymode wrap
    UCHAR       rgCols[LINESZ];         // Location within lines
    ULONGLONG   UpdatePos;              // Location waitin to be updated
    struct  Buffer  *Buf;               // List of buffer's read in
    PCHAR_INFO  pVioBuf;                // Virtual screen
    COORD       dwVioBufSize;           // Dimensions of HeGbl.pVioBuf
    COORD       CursorPos;              // Position of cursor
    WORD        AttrNorm;               // Attribute of plain text
    WORD        AttrHigh;               // Attribute of highlighted text
    WORD        AttrReverse;            // Attribute of reverse text
    WORD        na3;
    COORD       dwSize;                 // Original screen size
    ULONG       OrigMode;               // Original screen mode
    CONSOLE_CURSOR_INFO CursorInfo;     // Original cursor info
    PUCHAR      SearchPattern;
    USHORT      BufferSize;
    ULONGLONG   SectorMask;
    ULONG       SectorShift;
} HeGbl;

#define D_BYTE  0                       // DisplayMode
#define D_WORD  1
#define D_DWORD 3

#define FC_NIBBLE       0x0001          // Cursor on lower or upper nibble?
#define FC_TEXT         0x0002          // Cursor on Hex or Text
#define FC_INFLUSHBUF   0x1000          // So we don't recurse
#define FC_CURCENTER    0x2000          // if jumping to cursor, put in center

#define PUTCHAR(a,b,c)  { a->Char.AsciiChar=b; a->Attributes=c; a++; }


//
// Internal prototypes
//

int heUpdateStats(), hePositionCursor(), heRefresh(), heSetDisp();
int heInitConsole(), heUpdateAllLines(), heInitScr(), heSetCursorBuf(), heUpdateFncs();
VOID __cdecl heDisp (USHORT, USHORT, PUCHAR, ...);
USHORT heIOErr (UCHAR *str, ULONGLONG loc, ULONGLONG ploc, ULONG errcd);

int heFlushBuf (struct Buffer *pBuf);

VOID heEndConsole(), heGotoPosition(), heJumpToLink();
VOID heUpdateCurLine(), heUndo(), heCopyOut(), heCopyIn(), heSearch();
VOID heBox (USHORT x, USHORT y, USHORT len_x, USHORT len_y);
UCHAR heGetChar (PUCHAR keys);
VOID heFlushAllBufs (USHORT update);
VOID heFindMousePos (COORD);
VOID heShowBuf (ULONG, ULONG);
VOID heSetDisplayMode (ULONG mode);

#define RefreshDisp()    heShowBuf(0, HeGbl.LineTot)
#define SetCurPos(a,b)  { \
    HeGbl.CursorPos.X = b;   \
    HeGbl.CursorPos.Y = a + HeGbl.TopLine;  \
    SetConsoleCursorPosition (HeGbl.Console, HeGbl.CursorPos);    \
    }


int  (*vrgUpdateFnc[])() = {
        NULL,                           // 0 - No update
        heUpdateStats,                  // 1 - Update stats
        hePositionCursor,               // 2 - Cursor has new position
        heUpdateAllLines,               // 3 - Update all lines
        heUpdateFncs,                   // 4 -
        hePositionCursor,               // 5 - Calc cursor before AllLines
        heRefresh,                      // 6 - Clear lines
        heSetDisp,                      // 7 - Draws init screen
    // the following functions are only called once during init
        heInitScr,                      // 8 - get's video mode, etc.
        heInitConsole                   // 9 - setup console handle
} ;

#define U_NONE      0
#define U_NEWPOS    2
#define U_SCREEN    5
#define U_REDRAW    9


#define TOPLINE     4
#define LINEINDENT  1
#define FILEINDEXWIDTH 16
#define HEXINDENT   (FILEINDEXWIDTH + 2 + LINEINDENT)
#define ASCINDENT_BYTE   (3*16 + HEXINDENT + 1)
#define ASCINDENT_WORD   (5*8  + HEXINDENT + 1)
#define ASCINDENT_DWORD  (9*4  + HEXINDENT + 1)

#define POS(l,c)    (HeGbl.pVioBuf+CELLPERLINE*(l)+c)

USHORT  vrgAscIndent[] = {
        ASCINDENT_BYTE, ASCINDENT_WORD, 0, ASCINDENT_DWORD
 };

UCHAR   vrgDWidth[] = { 2, 4, 0, 8 };

LOCAL struct  Buffer  *vBufFree;              // List of free buffers
LOCAL USHORT  vUpdate;
LOCAL USHORT  vRecurseLevel = 0;
LOCAL BOOL    vInSearch = FALSE;


/*
 *  Prototypes
 */

struct Buffer *heGetBuf (ULONGLONG);
void   heSetUpdate (USHORT);
void   heHexLine   (struct Buffer *, USHORT, USHORT);
void   heHexDWord  (PCHAR_INFO, ULONG, WORD);
void   heHexQWord  (PCHAR_INFO, ULONGLONG, WORD);
USHORT heLtoa      (PCHAR_INFO, ULONG);
ULONG  heHtou      (UCHAR *);
ULONGLONG  heHtoLu      (UCHAR *);
VOID   heCalcCursorPosition ();
VOID   heGetString (PUCHAR s, USHORT len);
VOID   heRightOne  ();
VOID   heLeftOne   ();
NTSTATUS heWriteFile (HANDLE h, PUCHAR buffer, ULONG len);
NTSTATUS heReadFile (HANDLE h, PUCHAR buffer, ULONG len, PULONG br);
NTSTATUS heOpenFile (PUCHAR Name, PHANDLE handle, ULONG access);


ULONG
HighBit (
    ULONG Word
    )

/*++

Routine Description:

    This routine discovers the highest set bit of the input word.  It is
    equivalent to the integer logarithim base 2.

Arguments:

    Word - word to check

Return Value:

    Bit offset of highest set bit. If no bit is set, return is zero.

--*/

{
    ULONG Offset = 31;
    ULONG Mask = (ULONG)(1 << 31);

    if (Word == 0) {

        return 0;
    }

    while ((Word & Mask) == 0) {

        Offset--;
        Mask >>= 1;
    }

    return Offset;
}



/***
 *
 *  HexEdit - Full screen HexEdit of data
 *
 *      ename   - pointer to name of what's being edited
 *      totlen  - length of item being edited
 *      pRead   - function which can read data from item
 *      pWrite  - function which can write data to item
 *      handle  - handle to pass to pRead & pWrite
 *      flag    -
 *
 *
 *  All IO is assumed to be done on in 512 bytes on 512 byte boundrys
 *
 *      pRead (handle, offset, data, &physloc)
 *      pWrite (handle, offset, data, &physloc)
 *
 */

void HexEdit (struct HexEditParm *pParm)
{
    USHORT  rc;
    INPUT_RECORD    Kd;
    USHORT  SkipCnt;
    DWORD   cEvents;
    USHORT  RepeatCnt;
    BOOL    bSuccess;
    struct  Global  *PriorGlobal;

    // code is not multi-threaded capable, but it can resurse.
    vRecurseLevel++;
    if (vRecurseLevel > 1) {
        PriorGlobal = (struct Global *) GlobalAlloc (0, sizeof (HeGbl));
        if (!PriorGlobal) {
            return;
        }
        memcpy ((PUCHAR) PriorGlobal, (PUCHAR) &HeGbl, sizeof (HeGbl));
    }

    memset (&HeGbl, 0, sizeof (HeGbl));

    if (pParm->ioalign != 1)  {

        // operating on a device
        HeGbl.BufferSize = (USHORT)pParm->ioalign;
        HeGbl.SectorMask = ~(((ULONGLONG)pParm->ioalign) - 1);
        HeGbl.SectorShift = HighBit( pParm->ioalign);
    }
    else {

        // operating on a file,  so just use 1k byte units
        HeGbl.BufferSize = 0x400;
        HeGbl.SectorMask = 0xfffffffffffffc00;
        HeGbl.SectorShift = 9;
    }
    
    pParm->ioalign = 0;
    HeGbl.Parm    = pParm;
    HeGbl.Flag    = pParm->flag;
    HeGbl.TotLen  = pParm->totlen;
    HeGbl.Read    = pParm->read;
    HeGbl.TotLen1 = HeGbl.TotLen ? HeGbl.TotLen - 1L : 0L;
    pParm->flag = 0;

    HeGbl.CurEditLoc = pParm->start;                    // Cursor starts here
    HeGbl.CurOffset    = HeGbl.CurEditLoc & LINEMASK;   // Start at valid offset
    HeGbl.CurFlag      = FC_NIBBLE;
    HeGbl.Console      = INVALID_HANDLE_VALUE;
    heSetDisplayMode ((HeGbl.Flag & FHE_DWORD) ? D_DWORD : D_BYTE);

    HeGbl.AttrNorm = pParm->AttrNorm ? pParm->AttrNorm :  0x07;
    HeGbl.AttrHigh = pParm->AttrHigh ? pParm->AttrHigh : 0x70;
    HeGbl.AttrReverse = pParm->AttrReverse ? pParm->AttrReverse : 0xf0;

    HeGbl.SearchPattern = GlobalAlloc (0, BUFSZ);
    if (!HeGbl.SearchPattern) {
        memcpy((PUCHAR) &HeGbl, (PUCHAR) PriorGlobal, sizeof(HeGbl));
        GlobalFree(PriorGlobal);
        return;
    }
    memset (HeGbl.SearchPattern, 0, BUFSZ);

    RepeatCnt = 0;
    vUpdate   = U_REDRAW;
    heSetUpdate (U_NONE);         // get screen to redraw

    for (; ;) {
        if (RepeatCnt <= 1) {
            if (vUpdate != U_NONE) {            // Something to update?

                if (SkipCnt++ > 10) {
                    SkipCnt = 0;
                    heSetUpdate (U_NONE);
                    continue;
                }

                cEvents = 0;
                bSuccess = PeekConsoleInput( HeGbl.StdIn,
                                  &Kd,
                                  1,
                                  &cEvents );

                if (!bSuccess || cEvents == 0) {
                    heSetUpdate ((USHORT)(vUpdate-1));
                    continue;
                }
            } else {
                SkipCnt = 0;
            }

            ReadConsoleInput (HeGbl.StdIn, &Kd, 1, &cEvents);

            if (Kd.EventType != KEY_EVENT) {

                if (Kd.EventType == MOUSE_EVENT  &&
                    (Kd.Event.MouseEvent.dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED)) {
                        heFindMousePos(Kd.Event.MouseEvent.dwMousePosition);
                    }

                continue;                           // Not a key
            }


            if (!Kd.Event.KeyEvent.bKeyDown)
                continue;                           // Not a down stroke

            if (Kd.Event.KeyEvent.wVirtualKeyCode == 0    ||    // ALT
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x10 ||    // SHIFT
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x11 ||    // CONTROL
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x14)      // CAPITAL
                    continue;

            RepeatCnt = Kd.Event.KeyEvent.wRepeatCount;
            if (RepeatCnt > 20)
                RepeatCnt = 20;
        } else
            RepeatCnt--;

        switch (Kd.Event.KeyEvent.wVirtualKeyCode) {
            case 0x21:                                    /* PgUp */
                if (HeGbl.CurOffset < HeGbl.PageSz)
                     HeGbl.CurOffset  = 0L;
                else HeGbl.CurOffset -= HeGbl.PageSz;

                if (HeGbl.CurEditLoc < HeGbl.PageSz)
                     HeGbl.CurEditLoc  = 0L;
                else HeGbl.CurEditLoc -= HeGbl.PageSz;

                heSetUpdate (U_SCREEN);
                continue;

            case 0x26:                                    /* Up   */
                if (HeGbl.CurEditLoc >= LINESZ) {
                    HeGbl.CurEditLoc -= LINESZ;
                    heSetUpdate (U_NEWPOS);
                }
                continue;

            case 0x22:                                    /* PgDn */
                if (HeGbl.TotLen > HeGbl.PageSz) {
                    if (HeGbl.CurOffset+HeGbl.PageSz+HeGbl.PageSz > HeGbl.TotLen1)
                         HeGbl.CurOffset = ((HeGbl.TotLen1-HeGbl.PageSz) & LINEMASK)+LINESZ;
                    else HeGbl.CurOffset += HeGbl.PageSz;

                    if (HeGbl.CurEditLoc+HeGbl.PageSz > HeGbl.TotLen1) {
                        HeGbl.CurEditLoc = HeGbl.TotLen1;
                        HeGbl.CurFlag &= ~FC_NIBBLE;
                    } else
                        HeGbl.CurEditLoc += HeGbl.PageSz;

                    heSetUpdate (U_SCREEN);
                }
                continue;


            case 0x28:                                  /* Down */
                if (HeGbl.CurEditLoc+LINESZ <= HeGbl.TotLen1) {
                    HeGbl.CurEditLoc += LINESZ;
                    heSetUpdate (U_NEWPOS);
                }
                continue;

            case 0x08:                                  /* backspace */
            case 0x25:                                  /* Left */
                if (HeGbl.CurFlag & FC_TEXT) {
                    if (HeGbl.CurEditLoc == 0L)
                        continue;

                    HeGbl.CurEditLoc--;
                    heSetUpdate (U_NEWPOS);
                    continue;
                }

                if (!(HeGbl.CurFlag & FC_NIBBLE)) {
                    HeGbl.CurFlag |= FC_NIBBLE;
                    heSetUpdate (U_NEWPOS);
                    continue;
                }

                HeGbl.CurFlag &= ~FC_NIBBLE;
                heLeftOne ();
                heSetUpdate (U_NEWPOS);
                continue;


            case 0x27:                                    /* Right */
                if (HeGbl.CurFlag & FC_TEXT) {
                    if (HeGbl.CurEditLoc >= HeGbl.TotLen1)
                        continue;

                    HeGbl.CurEditLoc++;
                    heSetUpdate (U_NEWPOS);
                    continue;
                }

                if (HeGbl.CurFlag & FC_NIBBLE) {
                    HeGbl.CurFlag &= ~FC_NIBBLE;
                    heSetUpdate (U_NEWPOS);
                    continue;
                }

                HeGbl.CurFlag |= FC_NIBBLE;
                heRightOne ();
                heSetUpdate (U_NEWPOS);
                continue;

            case 0x24:                                    /* HOME */
                if (Kd.Event.KeyEvent.dwControlKeyState &
                    (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    HeGbl.CurEditLoc = 0L;
                } else {
                    HeGbl.CurEditLoc &= LINEMASK;
                }

                if ((HeGbl.CurFlag & FC_TEXT) == 0)
                    HeGbl.CurEditLoc += HeGbl.DisplayMode;

                if (HeGbl.CurEditLoc > HeGbl.TotLen1)
                    HeGbl.CurEditLoc = HeGbl.TotLen1;

                HeGbl.CurFlag    |= FC_NIBBLE;
                heSetUpdate (U_NEWPOS);
                continue;


            case 0x23:                                    /* END  */
                if (Kd.Event.KeyEvent.dwControlKeyState &
                    (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    HeGbl.CurEditLoc = HeGbl.TotLen1;
                } else {
                    HeGbl.CurEditLoc = (HeGbl.CurEditLoc & LINEMASK) + LINESZ - 1;
                }

                HeGbl.CurFlag   &= ~FC_NIBBLE;
                if ((HeGbl.CurFlag & FC_TEXT) == 0)
                    HeGbl.CurEditLoc -= HeGbl.DisplayMode;

                if (HeGbl.CurEditLoc > HeGbl.TotLen1)
                    HeGbl.CurEditLoc = HeGbl.TotLen1;

                heSetUpdate (U_NEWPOS);
                continue;

            case 0x70:                                  /* F1       */
                switch (HeGbl.DisplayMode) {
                    case D_BYTE:    heSetDisplayMode(D_WORD);   break;
                    case D_WORD:    heSetDisplayMode(D_DWORD);  break;
                    case D_DWORD:   heSetDisplayMode(D_BYTE);   break;
                }
                heSetDisp ();
                heSetUpdate (U_SCREEN);
                continue;

            case 0x71:                                  /* F2       */
                heGotoPosition ();
                continue;

            case 0x72:                                  /* F3       */
                heSearch ();
                break;

            case 0x73:                                  /* F4       */
                heCopyOut ();
                heSetDisp ();
                heSetUpdate (U_SCREEN);
                continue;

            case 0x74:                                  /* F5       */
                heCopyIn ();
                heSetDisp ();
                heSetUpdate (U_SCREEN);
                continue;

            case 0x75:                                  /* F6       */
                heJumpToLink ();
                break;

            case 0x79:                                  /* F10      */
                heUndo ();
                continue;

            case 0x0d:
                if (HeGbl.Flag & FHE_ENTER) {
                    HeGbl.Parm->flag |= FHE_ENTER;
                    Kd.Event.KeyEvent.uChar.AsciiChar = 27;  // fake an exit
                }
                break;

            //case 0x75:                                    /* F6       */
            //    if (HeGbl.Flag & FHE_F6) {
            //        HeGbl.Parm->flag |= FHE_F6;
            //        Kd.Event.KeyEvent.uChar.AsciiChar = 27;  // fake an exit
            //    }
            //    break;

        }

        // Now check for a known char code...

        if (Kd.Event.KeyEvent.uChar.AsciiChar == 27)
            break;

        if (Kd.Event.KeyEvent.uChar.AsciiChar == 9) {
            HeGbl.CurFlag ^= FC_TEXT;
            HeGbl.CurFlag |= FC_NIBBLE;
            heSetUpdate (U_NEWPOS);
            continue;
        }

        if (HeGbl.CurFlag & FC_TEXT) {
            if (Kd.Event.KeyEvent.uChar.AsciiChar == 0)
                continue;

            heSetCursorBuf ();

            *HeGbl.CurPT = Kd.Event.KeyEvent.uChar.AsciiChar;
            heUpdateCurLine ();

            if (HeGbl.CurEditLoc < HeGbl.TotLen1)
                HeGbl.CurEditLoc++;
        } else {
            if (Kd.Event.KeyEvent.uChar.AsciiChar >= 'a'  &&
                Kd.Event.KeyEvent.uChar.AsciiChar <= 'z')
                Kd.Event.KeyEvent.uChar.AsciiChar -= ('a' - 'A');

            if (!((Kd.Event.KeyEvent.uChar.AsciiChar >= '0'  &&
                   Kd.Event.KeyEvent.uChar.AsciiChar <= '9') ||
                  (Kd.Event.KeyEvent.uChar.AsciiChar >= 'A'  &&
                   Kd.Event.KeyEvent.uChar.AsciiChar <= 'F')))
                    continue;

            heSetCursorBuf ();

            if (Kd.Event.KeyEvent.uChar.AsciiChar >= 'A')
                 Kd.Event.KeyEvent.uChar.AsciiChar -= 'A' - 10;
            else Kd.Event.KeyEvent.uChar.AsciiChar -= '0';


            if (HeGbl.CurFlag & FC_NIBBLE) {
                *HeGbl.CurPT = (*HeGbl.CurPT & 0x0F) |
                                (Kd.Event.KeyEvent.uChar.AsciiChar << 4);
                heUpdateCurLine ();
            } else {
                *HeGbl.CurPT = (*HeGbl.CurPT & 0xF0) |
                                Kd.Event.KeyEvent.uChar.AsciiChar;
                heUpdateCurLine ();
                heRightOne ();
            }

            HeGbl.CurFlag ^= FC_NIBBLE;
        }
    }

    /*
     *  Free buffer memory
     */

    for (; ;) {
        rc = 0;
        while (HeGbl.Buf) {
            rc |= heFlushBuf (HeGbl.Buf);

            HeGbl.CurBuf = HeGbl.Buf->next;
            GlobalFree (HeGbl.Buf);
            HeGbl.Buf = HeGbl.CurBuf;
        }

        if (!rc)                        // If something was flushed,
            break;                      // then update the screen

        heSetUpdate (U_SCREEN);
        heSetUpdate (U_NONE);
    }                                   // and loop to free buffers (again)

    vRecurseLevel--;
    GlobalFree (HeGbl.SearchPattern);
    heEndConsole ();

    if (vRecurseLevel == 0) {
        while (vBufFree) {
            HeGbl.CurBuf = vBufFree->next;
            GlobalFree (vBufFree);
            vBufFree = HeGbl.CurBuf;
        }
    } else {
        memcpy ((PUCHAR) &HeGbl, (PUCHAR) PriorGlobal, sizeof (HeGbl));
        GlobalFree (PriorGlobal);
    }
}

VOID heSetDisplayMode (ULONG mode)
{
    PUCHAR  p;
    UCHAR   d,i,j,h,len;

    HeGbl.DisplayMode  = mode;
    HeGbl.CurAscIndent = (UCHAR)vrgAscIndent[HeGbl.DisplayMode];
    HeGbl.DWidth       = vrgDWidth[HeGbl.DisplayMode];
    HeGbl.ItemWrap     = (HeGbl.DisplayMode << 1) | 1;

    i = HeGbl.DWidth;
    j = i >> 1;
    h = HEXINDENT;
    len = LINESZ;

    p = HeGbl.rgCols;
    while (len) {
        for (d=0; d < i; d += 2) {
            len--;
            *(p++) = i - (d+2) + h;
        }
        h += i + 1;
    }
}

VOID heRightOne ()
{
    if (HeGbl.CurEditLoc & HeGbl.DisplayMode) {
        HeGbl.CurEditLoc--;
    } else {
        HeGbl.CurEditLoc += HeGbl.ItemWrap;
    }

    if (HeGbl.CurEditLoc > HeGbl.TotLen1) {
        HeGbl.CurEditLoc = HeGbl.TotLen1 & ~(ULONGLONG)HeGbl.DisplayMode;
    }
}


VOID heLeftOne ()
{
    if ((HeGbl.CurEditLoc & HeGbl.DisplayMode) != HeGbl.DisplayMode) {
        if (HeGbl.CurEditLoc < HeGbl.TotLen1) {
            HeGbl.CurEditLoc++;
            return ;
        }
        if (HeGbl.TotLen1 > HeGbl.DisplayMode) {
            HeGbl.CurEditLoc |= HeGbl.DisplayMode;
        }
    }

    if (HeGbl.CurEditLoc > HeGbl.ItemWrap) {
        HeGbl.CurEditLoc -= HeGbl.ItemWrap;
        return ;
    }

    HeGbl.CurEditLoc =
        HeGbl.TotLen1 > HeGbl.DisplayMode ? HeGbl.DisplayMode : HeGbl.TotLen1;
}




VOID heUpdateCurLine ()
{
    USHORT  line;


    for (; ;) {
        HeGbl.CurBuf->flag |= FB_DIRTY;
        line = (USHORT) ((HeGbl.CurEditLoc - HeGbl.CurOffset) >> LINESHIFT);
        if (line+TOPLINE < HeGbl.LineTot - 1)
            break;

        heSetUpdate (U_NEWPOS);
        heSetUpdate (U_NONE);
        HeGbl.CurBuf = heGetBuf (HeGbl.CurEditLoc);
    }

    if (HeGbl.CurBuf) {
        heHexLine (HeGbl.CurBuf, (USHORT)((HeGbl.CurEditLoc & LINEMASK) - HeGbl.CurBuf->offset), line);
        heShowBuf (line+TOPLINE, 1);
        heSetUpdate (U_NEWPOS);
        if (HeGbl.Flag & FHE_KICKDIRTY) {
            HeGbl.Parm->flag |= FHE_DIRTY;
            SetEvent (HeGbl.Parm->Kick);
        }
    }
}


void heFindMousePos (Pos)
COORD Pos;
{
    ULONGLONG   HoldLocation;
    USHORT      HoldFlag;
    USHORT      i;

    if (Pos.Y < TOPLINE  ||  Pos.Y >= TOPLINE+HeGbl.Lines)
        return ;


    heSetUpdate (U_NONE);
    HoldLocation = HeGbl.CurEditLoc;
    HoldFlag     = (USHORT)HeGbl.CurFlag;

    //
    // Take the cheap way out - simply run all the possibilities for the
    // target line looking for a match
    //

    HeGbl.CurEditLoc = HeGbl.CurOffset + ((Pos.Y-TOPLINE) << LINESHIFT);
    for (i=0; i < LINESZ; i++, HeGbl.CurEditLoc++) {
        HeGbl.CurFlag &= ~(FC_NIBBLE | FC_TEXT);
        heCalcCursorPosition ();
        if (Pos.X == HeGbl.CursorPos.X)
            break;

        HeGbl.CurFlag |= FC_NIBBLE;
        heCalcCursorPosition ();
        if (Pos.X == HeGbl.CursorPos.X)
            break;

        HeGbl.CurFlag |= FC_TEXT;
        heCalcCursorPosition ();
        if (Pos.X == HeGbl.CursorPos.X)
            break;
    }

    if (Pos.X == HeGbl.CursorPos.X) {
        heSetUpdate (U_NEWPOS);
    } else {
        HeGbl.CurEditLoc = HoldLocation;
        HeGbl.CurFlag    = HoldFlag;
        heCalcCursorPosition ();
    }
}



VOID heSetUpdate (USHORT i)
{
    USHORT  u;

    if (vUpdate) {
        /*
         * There's already some outstanding update going on
         * Get updat level down to current one.
         */

        while (vUpdate > i) {
            vrgUpdateFnc [u=vUpdate] ();
            if (u == vUpdate)               // If vUpdate changed, then
                vUpdate--;                  // we might have recursed
        }
    }

    vUpdate = i;
}

int heSetCursorBuf ()
{
    //  Calc HeGbl.CurBuf, HeGbl.CurPT

    if (HeGbl.CurBuf) {
        if (HeGbl.CurEditLoc >= HeGbl.CurBuf->offset  &&
            HeGbl.CurEditLoc < HeGbl.CurBuf->offset+BUFSZ ) {
                HeGbl.CurPT = HeGbl.CurBuf->data + (HeGbl.CurEditLoc - HeGbl.CurBuf->offset);
                return 0;
            }
    }

    HeGbl.CurBuf = heGetBuf (HeGbl.CurEditLoc);
    if (HeGbl.CurBuf)
        HeGbl.CurPT  = HeGbl.CurBuf->data + (HeGbl.CurEditLoc - HeGbl.CurBuf->offset);
    return 0;
}


int hePositionCursor ()
{
    heCalcCursorPosition ();
    SetConsoleCursorPosition (HeGbl.Console, HeGbl.CursorPos);

    if ((HeGbl.Flag & FHE_KICKMOVE)  &&  (HeGbl.CurEditLoc != HeGbl.Parm->editloc)) {
    
        HeGbl.Parm->editloc = HeGbl.CurEditLoc;
        SetEvent (HeGbl.Parm->Kick);
    }

    return 0;
}


VOID heCalcCursorPosition ()
{
    USHORT  lin, col;


    //  Verify HeGbl.CurOffset
    if (HeGbl.CurEditLoc < HeGbl.CurOffset) {
        HeGbl.CurOffset = HeGbl.CurEditLoc & LINEMASK;
        if (HeGbl.CurFlag & FC_CURCENTER) {
            if (HeGbl.CurOffset > (ULONG) HeGbl.PageSz / 2) {
                HeGbl.CurOffset -= (HeGbl.PageSz / 2) & LINEMASK;
            } else {
                HeGbl.CurOffset = 0;
            }
        }
        heSetUpdate (U_SCREEN);
    }

    if (HeGbl.CurEditLoc >= HeGbl.CurOffset+HeGbl.PageSz) {
        HeGbl.CurOffset = ((HeGbl.CurEditLoc - HeGbl.PageSz) & LINEMASK) + LINESZ;
        if (HeGbl.CurFlag & FC_CURCENTER) {
            if (HeGbl.CurOffset+HeGbl.PageSz < HeGbl.TotLen) {
                HeGbl.CurOffset += (HeGbl.PageSz / 2) & LINEMASK;
            } else {
                if (HeGbl.TotLen > HeGbl.PageSz) {
                    HeGbl.CurOffset = ((HeGbl.TotLen - HeGbl.PageSz) & LINEMASK) + LINESZ;
                }
            }
        }
        heSetUpdate (U_SCREEN);
    }

    lin = (USHORT) ((ULONG) HeGbl.CurEditLoc - HeGbl.CurOffset) >> LINESHIFT;

    if (HeGbl.CurFlag & FC_TEXT) {
        col  = (USHORT) (HeGbl.CurEditLoc & ~LINEMASK) + HeGbl.CurAscIndent+1;
    } else {
        col = HeGbl.rgCols [HeGbl.CurEditLoc & ~LINEMASK] +
              (HeGbl.CurFlag & FC_NIBBLE ? 0 : 1);
    }

    HeGbl.CursorPos.Y = lin + TOPLINE + HeGbl.TopLine;
    HeGbl.CursorPos.X = col;
}



heUpdateAllLines ()
{
    struct  Buffer  *next, *pBuf;
    USHORT  line, u;
    ULONGLONG   loc;


    HeGbl.CurBuf = pBuf = NULL;

    /*
     *  Free up any buffers which are before the HeGbl.CurOffset
     */

    if (!(HeGbl.CurFlag & FC_INFLUSHBUF)) {
        while (HeGbl.Buf) {
            if (HeGbl.Buf->offset+BUFSZ >= HeGbl.CurOffset)
                break;

            heFlushBuf (HeGbl.Buf);

            /*
             *  Unlink buffer & put it on the free list
             */
            next = HeGbl.Buf->next;

            HeGbl.Buf->next = vBufFree;
            vBufFree   = HeGbl.Buf;

            HeGbl.Buf = next;
        }
    }

    /*
     *  Display each hex line now
     */

    loc = HeGbl.CurOffset;                       // starting offset
    for (line=0; line<HeGbl.Lines; line++) {     // for each line

        if (pBuf == NULL) {                     // do we have the buffer?
            pBuf = heGetBuf (loc);              // no, go get it
            if (pBuf)
                u = (USHORT) (loc - pBuf->offset);  // calc offset into this buffer
        }

        if (pBuf) {
            heHexLine (pBuf, u, line);          // dump this line
    
            loc += LINESZ;                      // move offsets foreward one line
            u   += LINESZ;
    
            if (u >= BUFSZ) {                   // did we exceed the current buf?
                pBuf = pBuf->next;              // yes, move to next one
                u = 0;
    
                if (pBuf && loc < pBuf->offset) // verify buffer is right offs
                    pBuf = NULL;                // no, let heGetBuf find it
            }
        }
    }

    // Cause screen to be refreshed
    heShowBuf (TOPLINE, HeGbl.Lines);

    /*
     *  All lines have been displayed, free up any extra buffers
     *  at the end of the chain
     */

    if (pBuf  &&  !(HeGbl.CurFlag & FC_INFLUSHBUF)) {
        next = pBuf->next;              // get extra buffers
        pBuf->next = NULL;              // terminate active list

        pBuf = next;
        while (pBuf) {
            heFlushBuf (pBuf);          // flush this buffer

            next = pBuf->next;          // move it to the free list
                                        // and get next buffer to flush
            pBuf->next = vBufFree;
            vBufFree   = pBuf;

            pBuf = next;
        }

    }

    HeGbl.CurFlag &= ~FC_CURCENTER;
    return 0;
}




int heFlushBuf (pBuf)
struct Buffer *pBuf;
{
    ULONGLONG   loc, ploc;
    USHORT  c;
    NTSTATUS status;

    if ((pBuf->flag & FB_DIRTY) == 0  ||
        memcmp (pBuf->data, pBuf->orig, pBuf->len) == 0)
            return (0);             // buffer isn't dirty, return

    // We may need to call heSetUpdate - setting this bit will
    // stop FlushBuf from being recursed.

    HeGbl.CurFlag |= FC_INFLUSHBUF;

    loc  = pBuf->offset;
    ploc = pBuf->physloc;
    if (HeGbl.Flag & (FHE_VERIFYONCE | FHE_VERIFYALL)) {
        heSetUpdate (U_NONE);             // make sure screen current

        heBox (12, TOPLINE+1, 63, 8);
        heDisp (TOPLINE+3, 14, "%HWrite changes to %S?", HeGbl.Parm->ename);
        heDisp (TOPLINE+7, 14, "Press '%HY%N'es or '%HN%N'o");

        if (HeGbl.Flag & FHE_VERIFYALL) {
            if (HeGbl.Flag & FHE_PROMPTSEC) {
                heDisp (TOPLINE+4, 14, "Sector %H%D%N has been modifed",(ULONG)(ploc/BUFSZ));
            } else {
                heDisp (TOPLINE+4, 14, "Location %H%Q%Nh-%H%Q%Nh has been modifed",ploc,ploc+BUFSZ);
            }
            heDisp (TOPLINE+8, 14, "Press '%HA%N' to save all updates");
        }
        RefreshDisp ();

        c = heGetChar ("YNA");          // wait for key stroke
        heSetDisp ();                   // Get heBox off of screen
        heSetUpdate (U_SCREEN);         // we will need to update display

        if (c == 'N') {
            memcpy (pBuf->data, pBuf->orig, pBuf->len);
            HeGbl.CurFlag &= ~FC_INFLUSHBUF;

            if (HeGbl.Flag & FHE_KICKDIRTY) {
                HeGbl.Parm->flag |= FHE_DIRTY;
                 SetEvent (HeGbl.Parm->Kick);
            }
            return (0);
        }

        if (c == 'A')
            HeGbl.Flag &= ~FHE_VERIFYALL;
    }


    if (HeGbl.Parm->write) {
        /*
         *  Write new buffer.
         */
        do {
            status = HeGbl.Parm->write(HeGbl.Parm->handle, loc, pBuf->data,pBuf->len);
            if (!status) {
                pBuf->flag &= ~FB_DIRTY;
                break;
            }
        } while (heIOErr ("WRITE ERROR!", loc, ploc, status) == 'R');
    }

    HeGbl.Flag    &= ~FHE_VERIFYONCE;
    HeGbl.CurFlag &= ~FC_INFLUSHBUF;
    return (1);
}


VOID heJumpToLink ()
{
    PULONG  p;
    ULONG   l;

    if (HeGbl.DisplayMode != D_DWORD  ||  (HeGbl.Flag & FHE_JUMP) == 0)
        return;

    if (((HeGbl.CurEditLoc & ~3) + 3) > HeGbl.TotLen1)
        return;

    heSetCursorBuf ();
    p = (PULONG) (((ULONG_PTR) HeGbl.CurPT) & ~3);   // Round to dword location

    l = *p;
    if ((l & 3) == 0)
        l += 3;

    if (l > HeGbl.TotLen1) {
        Beep (500, 100);
        return;
    }

    HeGbl.CurFlag |= FC_NIBBLE | FC_CURCENTER;
    HeGbl.CurEditLoc = l;

    heSetDisp ();           // clear & restore orig screen (does not draw)
    heSetUpdate (U_SCREEN);   // redraw hex area
}

VOID heSearch ()
{
    struct  Buffer  *pBuf;
    ULONGLONG j, sec, off, slen, len, upd;
    ULONG i;
    ULONGLONG iQ;
    struct  HexEditParm     ei;
    PUCHAR  data, data2;

    if (vInSearch || HeGbl.Lines < 25) {
        return ;
    }

    vInSearch = TRUE;

    heFlushAllBufs (1);               // Before we start flush & free all buffers
    heSetUpdate (U_NONE);

    memset ((PUCHAR) &ei, 0, sizeof (ei));
    ei.ename       = "Entering Search";
    ei.flag        = FHE_EDITMEM | FHE_ENTER;
    ei.mem         = HeGbl.SearchPattern;
    ei.totlen      = BUFSZ;
    ei.ioalign     = 1;
    ei.Console     = HeGbl.Console;
    ei.AttrNorm    = HeGbl.AttrNorm;
    ei.AttrHigh    = HeGbl.AttrHigh;
    ei.AttrReverse = HeGbl.AttrReverse;
    ei.CursorSize  = HeGbl.Parm->CursorSize;

    i = 24;
    if (HeGbl.Lines < i) {
        if (HeGbl.Lines < 12) {
            goto abort;
        }
        i = HeGbl.Lines - 8;
    }

    ei.TopLine     = HeGbl.Lines + TOPLINE - i;
    ei.MaxLine     = i + 1;
    if (HeGbl.DisplayMode == D_DWORD) {
        ei.flag |= FHE_DWORD;
    }

    HexEdit (&ei);              // Get search parameters
    vInSearch = FALSE;

    if (!(ei.flag & FHE_ENTER))
        goto abort;

    for (i=0, slen=0; i < BUFSZ; i++) {       // find last non-zero byte
        if (HeGbl.SearchPattern[i]) {       // in search patter
            slen = i+1;
        }
    }

    if (slen == 0) {
        goto abort;
    }

    heBox (12, TOPLINE+1, 48, 6);
    heDisp (TOPLINE+3, 14, "Searching for pattern");
    SetCurPos (TOPLINE+5, 24);
    RefreshDisp ();

    iQ   = HeGbl.CurEditLoc + 1;
    sec = iQ & SECTORMASK;                   // current sector
    off = iQ - sec;                          // offset within sector checking
    upd = 0;

    while (sec < HeGbl.TotLen) {
        if (++upd >= 50) {
            upd = 0;
            heFlushAllBufs (0);             // free memory
            heDisp (TOPLINE+6, 14, "Searching offset %H%Qh ", sec);
            heShowBuf (TOPLINE+6, 1);
        }

        pBuf = heGetBuf(sec);
        if (pBuf) {
            data = pBuf->data;

nextoff:
            while (off < BUFSZ  &&  data[off] != HeGbl.SearchPattern[0]) {
                off++;
            }

            if (off >= BUFSZ) {
                // next sector...
                sec += BUFSZ;
                off  = 0;
                continue;
            }

            len = (off + slen) > BUFSZ ? BUFSZ - off : slen;
            for (i=0; i < len; i++) {
                if (data[off+i] != HeGbl.SearchPattern[i]) {
                    off += 1;
                    goto nextoff;
                }
            }

            if (i < slen) {
                // data is continued in next buffer..
                if (sec+BUFSZ >= HeGbl.TotLen) {
                    off += 1;
                    goto nextoff;
                }

                data2 = heGetBuf (sec+BUFSZ)->data;
                if (data2) {
                    j     = (BUFSZ-off);
                    len   = slen - j;
                    for (i=0; i < len; i++) {
                        if (data2[i] != HeGbl.SearchPattern[j+i]) {
                            off += 1;
                            goto nextoff;
                        }
                    }
                }
            }

            // found match
            if (sec + off + slen > HeGbl.TotLen1) {
                break;
            }
        } else {
            sec+=off;
        }

        HeGbl.CurEditLoc = sec + off;
        heSetDisp   ();             // clear & restore orig screen (does not draw)
        heSetUpdate (U_SCREEN);     // redraw hex area
        return ;
    }


    heBox (12, TOPLINE+1, 48, 6);
    heDisp (TOPLINE+3, 14, "Data was not found");
    heDisp (TOPLINE+5, 17, "Press %HEnter%N to continue");
    SetCurPos (TOPLINE+6, 17);
    RefreshDisp ();
    heGetChar ("\r");

abort:
    heSetDisp   ();             // clear & restore orig screen (does not draw)
    heSetUpdate (U_SCREEN);     // redraw hex area
    return ;
}


VOID heGotoPosition ()
{
    UCHAR       s[24];
    ULONGLONG   l;

    heSetUpdate (U_NONE);
    heBox (12, TOPLINE+1, 49, 6);

    heDisp (TOPLINE+3, 14, "Enter offset from %H%X%N - %H%Q", 0L, HeGbl.TotLen1);
    heDisp (TOPLINE+5, 14, "Offset:           ");
    SetCurPos (TOPLINE+5, 22);
    RefreshDisp ();

    heGetString (s, 18);

    if (s[0]) {
        l = heHtoLu (s);
        if (l <= HeGbl.TotLen1) {
            HeGbl.CurFlag |= FC_NIBBLE;
            HeGbl.CurEditLoc = l;
        }
    }

    if (!(HeGbl.CurFlag & FC_TEXT)  &&  !(HeGbl.CurEditLoc & HeGbl.DisplayMode)) {
        // On xword boundry and not in text mode, adjust so cursor
        // is on the first byte which is being displayed of this
        // xword

        HeGbl.CurEditLoc += HeGbl.DisplayMode;
        if (HeGbl.CurEditLoc > HeGbl.TotLen1)
            HeGbl.CurEditLoc = HeGbl.TotLen1;
    }



    HeGbl.CurFlag |= FC_CURCENTER;      // set cursor to center in window moves
    heSetDisp ();             // clear & restore orig screen (does not draw)
    heSetUpdate (U_SCREEN);   // redraw hex area
}


VOID heGetString (PUCHAR s, USHORT len)
{
    UCHAR   i[50];
    DWORD   cb;

    if (!ReadFile( HeGbl.StdIn, i, 50, &cb, NULL ))
        return;

    if(cb >= 2  &&  (i[cb - 2] == 0x0d || i[cb - 2] == 0x0a) ) {
        i[cb - 2] = 0;     // Get rid of CR LF
    }
    i[ cb - 1] = 0;

    memcpy (s, i, len);
    s[len] = 0;
}



/***
 *  heCopyOut - Copies data to output filename
 */
VOID heCopyOut ()
{
    UCHAR       s[64];
    ULONGLONG   len, rem, upd;
    ULONG       u;
    HANDLE      h;
    NTSTATUS    status;
    struct Buffer *pB;

    heFlushAllBufs (1);               // Before we start flush & free all buffers
    heSetUpdate (U_NONE);
    heBox (12, TOPLINE+1, 48, 6);

    heDisp (TOPLINE+3, 14, "Copy stream to filename (%H%D%Q Bytes)", HeGbl.TotLen);
    heDisp (TOPLINE+5, 14, "Filename:                      ");
    SetCurPos (TOPLINE+5, 24);
    RefreshDisp ();

    heGetString (s, 59);
    if (s[0] == 0)
        return;

    status = heOpenFile (s, &h, GENERIC_WRITE);
    if (NT_SUCCESS(status)) {
        len = upd = 0;
        rem = HeGbl.TotLen;
        while (NT_SUCCESS(status) && rem){
            if (upd++ > 50) {
                upd = 0;
                heFlushAllBufs (0);         // free memory
                heDisp (TOPLINE+6, 14, "Bytes written %H%Q ", len);
                heShowBuf (TOPLINE+6, 1);
                RefreshDisp ();
            }

            u      = rem > BUFSZ ? BUFSZ : (ULONG)rem;
            pB     = heGetBuf (len);
            if (pB) {
                status = heWriteFile (h, pB->data, u);
                rem   -= u;
                len   += BUFSZ;
            }
        }
        CloseHandle(h);
    }

    if (!NT_SUCCESS(status)) {
        heBox (15, TOPLINE+1, 33, 6);
        heDisp (TOPLINE+3, 17, "%HCopy failed");
        heDisp (TOPLINE+4, 17, "Error code %X", status);
        heDisp (TOPLINE+5, 17, "Press %HA%N to abort");
        RefreshDisp ();
        heGetChar ("A");
    }
}



/***
 *  heCopyIn - Copies data to output filename
 */

VOID
heCopyIn ()
{
    UCHAR       s[64];
    ULONGLONG   holdEditLoc, rem;
    ULONG       u, br;
    struct      Buffer *pB;
    char        *pErr;
    HANDLE      h;
    NTSTATUS    status;

    heSetUpdate (U_NONE);
    heBox (12, TOPLINE+1, 48, 6);

    heDisp (TOPLINE+3, 14, "Input from filename (%H%D%Q Bytes)", HeGbl.TotLen);
    heDisp (TOPLINE+5, 14, "Filename:                      ");
    SetCurPos (TOPLINE+5, 24);
    RefreshDisp ();

    heGetString (s, 59);
    heSetDisp ();                   // Get heBox off of screen
    if (s[0] == 0) {
        return;
    }

    status = heOpenFile (s, &h, GENERIC_READ);
    if (NT_SUCCESS(status)) {
        rem = HeGbl.TotLen;
        holdEditLoc = HeGbl.CurEditLoc;
        HeGbl.CurEditLoc = 0;
        while (NT_SUCCESS(status) && rem) {
            pB     = heGetBuf (HeGbl.CurEditLoc);
            if (pB) {
                u      = rem >  BUFSZ ? BUFSZ : (ULONG)rem;
                status = heReadFile (h, pB->data, u, &br);
    
                if (memcmp (pB->data, pB->orig, pB->len)) {
                    pB->flag |= FB_DIRTY;         // it's changed
                    HeGbl.CurFlag |= FC_CURCENTER;
                    heSetUpdate (U_SCREEN);
                    heSetUpdate (U_NONE);         // Update screen
                    if (HeGbl.Flag & FHE_KICKDIRTY) {
                        HeGbl.Parm->flag |= FHE_DIRTY;
                    }
                }
                heFlushAllBufs (1);
                if (NT_SUCCESS(status)  &&  br != u) {
                    pErr = "Smaller then data";
                }
    
                rem -= u;
                HeGbl.CurEditLoc += BUFSZ;
            }
        }

        if (NT_SUCCESS(status)) {
            heReadFile (h, s, 1, &br);
            if (br)                     // then what we are editting
                pErr = "Larger then data";
        }

        CloseHandle(h);
    }

    if (!NT_SUCCESS(status)  ||  pErr) {
        heBox (15, TOPLINE+1, 33, 6);
        if (pErr) {
            heDisp (TOPLINE+3, 17, "Import file is:");
            heDisp (TOPLINE+4, 17, pErr);
            heDisp (TOPLINE+5, 17, "Press %HC%N to continue");
        } else {
            heDisp (TOPLINE+3, 17, "%HImport failed");
            heDisp (TOPLINE+4, 17, "Error code %X", status);
            heDisp (TOPLINE+5, 17, "Press %HA%N to abort");
        }
        RefreshDisp ();
        heGetChar ("CA");
    }

    HeGbl.CurEditLoc = holdEditLoc;
}


VOID
heFlushAllBufs (USHORT update)
{
    struct  Buffer  *next;
    USHORT  rc;

    for (; ;) {
        rc = 0;
        while (HeGbl.Buf) {
            rc |= heFlushBuf (HeGbl.Buf);

            next = HeGbl.Buf->next;
            HeGbl.Buf->next = vBufFree;
            vBufFree   = HeGbl.Buf;
            HeGbl.Buf = next;
        }

        if (!rc)                        // If something was flushed,
            break;                      // then update the screen

        if (update) {
            heSetUpdate (U_SCREEN);
            heSetUpdate (U_NONE);
        }
    }                                   // and loop to free buffers (again)
}




VOID heBox (x, y, len_x, len_y)
USHORT x, y, len_x, len_y;
{
    CHAR_INFO   blank[CELLPERLINE];
    PCHAR_INFO  pt, pt1;
    USHORT      c, lc;

    pt = blank;
    for (c=len_x; c; c--) {                     /* Construct blank line */
        PUTCHAR (pt, ' ', HeGbl.AttrNorm);           /* with background color*/

    }
    blank[0].Char.AsciiChar = blank[lc=len_x-1].Char.AsciiChar = '';

    for (c=0; c <= len_y; c++)                  /* blank each line      */
      memcpy (POS(c+y,x), blank, (int)((pt - blank) * sizeof (CHAR_INFO)));

    pt  = POS(y,x);
    pt1 = POS(y+len_y, x);
    for (c=0; c < len_x; c++)                   /* Draw horz lines      */
        pt[c].Char.AsciiChar = pt1[c].Char.AsciiChar  = '';

    pt  [ 0].Char.AsciiChar  = '';             /* Put corners on       */
    pt  [lc].Char.AsciiChar  = '';
    pt1 [ 0].Char.AsciiChar  = '';
    pt1 [lc].Char.AsciiChar  = '';
}



VOID heUndo ()
{
    struct  Buffer  *pBuf;
    USHORT  flag;

    flag = 0;
    for (pBuf=HeGbl.Buf; pBuf; pBuf = pBuf->next)
        if (pBuf->flag & FB_DIRTY) {
            flag = 1;
            pBuf->flag &= ~FB_DIRTY;
            memcpy (pBuf->data, pBuf->orig, pBuf->len);
        }

    if (flag) {
        heSetUpdate (U_SCREEN);
        if (HeGbl.Flag & FHE_KICKDIRTY) {
            HeGbl.Parm->flag |= FHE_DIRTY;
            SetEvent (HeGbl.Parm->Kick);
        }
    }
}



void heHexLine (pBuf, u, line)
struct Buffer *pBuf;
USHORT u, line;
{
    PCHAR_INFO pt, hex, asc;
    UCHAR  *data, *orig;
    UCHAR  len, mlen, c, d, i, j;
    WORD   a;
    ULONGLONG  l;
    WORD   AttrNorm = HeGbl.AttrNorm;

    data = pBuf->data + u;
    orig = pBuf->orig + u;

    pt  = HeGbl.pVioBuf + (line+TOPLINE) * CELLPERLINE;
    hex = pt + HEXINDENT;
    asc = pt + HeGbl.CurAscIndent;

    //
    //  Write the file index.  Highlight words falling on buffer (sector) 
    //  boundries in white.
    //
    
    l = pBuf->offset + u;
    if (l & ((ULONGLONG) BUFSZ-1)) {
        heHexQWord (pt+LINEINDENT, pBuf->physloc + u, AttrNorm);
    } else {
        heHexQWord (pt+LINEINDENT, pBuf->physloc + u, HeGbl.AttrHigh);
    }

    if (pBuf->flag & FB_BAD) {                          // If read error on
        pt[LINEINDENT+FILEINDEXWIDTH].Char.AsciiChar = 'E';          // this sector, then
        pt[LINEINDENT+FILEINDEXWIDTH].Attributes = HeGbl.AttrHigh;   // flag it
    } else
        pt[LINEINDENT+FILEINDEXWIDTH].Char.AsciiChar = ' ';

    if (l + LINESZ > HeGbl.TotLen) {                    // if EOF
        if (l >= HeGbl.TotLen) {                        // Totally blankline?
            PUTCHAR (asc, ' ', AttrNorm);
            PUTCHAR (asc, ' ', AttrNorm);
            mlen = 0;

            for (len=0; len < 9; len++)
                pt[len].Char.AsciiChar = ' ';

            goto blankline;
        }
        len = mlen = (UCHAR) (HeGbl.TotLen - l);        // Clip line
    } else
        len = mlen = (UCHAR) LINESZ;                    // Full line


    PUTCHAR (asc, '*', AttrNorm);

    switch (HeGbl.DisplayMode) {
        case D_BYTE:
            while (len--) {
                c = *(data++);
                a = c == *(orig++) ? AttrNorm : HeGbl.AttrReverse;
                PUTCHAR (hex, rghexc [c >> 4],   a);
                PUTCHAR (hex, rghexc [c & 0x0F], a);
                hex++;

                PUTCHAR (asc, (c < ' '  ||  c > '~') ? '.' : c, a);
            }
            pt[((LINESZ/2)*3+HEXINDENT)-1].Char.AsciiChar = '-';
            break;

        default:
            hex--;
            i = HeGbl.DWidth;
            j = i >> 1;
            while (len) {
                hex += i;
                for (d=0; d<j; d++) {
                    if (len) {
                        len--;
                        c = *(data++);
                        a = c == *(orig++) ? AttrNorm : HeGbl.AttrReverse;

                        hex->Attributes     = a;
                        hex->Char.AsciiChar = rghexc[c & 0x0F];
                        hex--;
                        hex->Attributes     = a;
                        hex->Char.AsciiChar = rghexc[c >> 4];
                        hex--;

                        PUTCHAR (asc, (c < ' '  ||  c > '~') ? '.' : c, a);
                    } else {
                        hex->Attributes     = AttrNorm;
                        hex->Char.AsciiChar = '?';
                        hex--;
                        hex->Attributes     = AttrNorm;
                        hex->Char.AsciiChar = '?';
                        hex--;
                    }
                }
                hex += i + 1;
            }
            break;
    }

    PUTCHAR (asc, '*', AttrNorm);

blankline:
    while (mlen++ < LINESZ)
        PUTCHAR (asc, ' ', AttrNorm);

    asc = pt + HeGbl.CurAscIndent;
    while (hex < asc)
        PUTCHAR (hex, ' ', AttrNorm);
}


heInitScr ()
{
    CONSOLE_SCREEN_BUFFER_INFO  Mode;
    CONSOLE_CURSOR_INFO CursorInfo;
    USHORT      li;

    GetConsoleScreenBufferInfo(HeGbl.Console, &Mode);
    if (HeGbl.Parm->MaxLine) {
        HeGbl.TopLine = (USHORT)HeGbl.Parm->TopLine;
        li = (USHORT)HeGbl.Parm->MaxLine;  // +1;    adjust for no fnc key line
    } else {
        li = Mode.srWindow.Bottom - Mode.srWindow.Top + 1;
        if (li < 10)
            li = 10;

        Mode.dwSize.Y = li;
    }

    if (Mode.dwSize.X < CELLPERLINE)
        Mode.dwSize.X = CELLPERLINE;

    if (!SetConsoleScreenBufferSize(HeGbl.Console, Mode.dwSize)) {

        Mode.srWindow.Bottom -= Mode.srWindow.Top;
        Mode.srWindow.Right -= Mode.srWindow.Left;
        Mode.srWindow.Top = 0;
        Mode.srWindow.Left = 0;

        SetConsoleWindowInfo(HeGbl.Console, TRUE, &Mode.srWindow);
        SetConsoleScreenBufferSize(HeGbl.Console, Mode.dwSize);
    }

    HeGbl.Lines   = li - TOPLINE - 1;
    HeGbl.PageSz  = HeGbl.Lines * LINESZ;
    HeGbl.LineTot = li;

    if (HeGbl.pVioBuf)
        GlobalFree (HeGbl.pVioBuf);

    HeGbl.pVioBuf = (PCHAR_INFO) GlobalAlloc (0,
                            (HeGbl.LineTot+1)*CELLPERLINE*sizeof(CHAR_INFO));
    if (!HeGbl.pVioBuf) {
        return 1;
    }

    HeGbl.dwVioBufSize.X = CELLPERLINE;
    HeGbl.dwVioBufSize.Y = HeGbl.LineTot + 1;

    GetConsoleCursorInfo (HeGbl.Console, &CursorInfo);
    CursorInfo.bVisible = TRUE;
    CursorInfo.dwSize = (ULONG) HeGbl.Parm->CursorSize ? HeGbl.Parm->CursorSize : 100;
    SetConsoleCursorInfo (HeGbl.Console, &CursorInfo);

    return heSetDisp ();
}

int heInitConsole ()
{
    CONSOLE_SCREEN_BUFFER_INFO  screenMode;
    DWORD   mode = 0;

    HeGbl.StdIn = GetStdHandle (STD_INPUT_HANDLE);
    GetConsoleMode (HeGbl.StdIn, &mode);
    HeGbl.OrigMode = mode;
    SetConsoleMode (HeGbl.StdIn, mode | ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT |
                            ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT );


    if (HeGbl.Flag & FHE_SAVESCRN) {
        HeGbl.Console = CreateConsoleScreenBuffer(
                        GENERIC_WRITE | GENERIC_READ,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,
                        CONSOLE_TEXTMODE_BUFFER,
                        NULL );

        SetConsoleActiveScreenBuffer (HeGbl.Console);
    } else {
        HeGbl.Console = HeGbl.Parm->Console;
        if (HeGbl.Console == INVALID_HANDLE_VALUE)
            HeGbl.Console = GetStdHandle( STD_OUTPUT_HANDLE );

        GetConsoleScreenBufferInfo(HeGbl.Console, &screenMode);
        HeGbl.dwSize = screenMode.dwSize;
    }

    GetConsoleCursorInfo(HeGbl.Console, &HeGbl.CursorInfo);
    return 0;
}


VOID heEndConsole ()
{
    CONSOLE_SCREEN_BUFFER_INFO  Mode;
    PCHAR_INFO  pt;
    ULONG   u;

    SetConsoleMode (HeGbl.StdIn, HeGbl.OrigMode);

    if (HeGbl.Flag & FHE_SAVESCRN) {
        CloseHandle (HeGbl.Console);

        if (HeGbl.Parm->Console == INVALID_HANDLE_VALUE)
             SetConsoleActiveScreenBuffer (GetStdHandle(STD_OUTPUT_HANDLE));
        else SetConsoleActiveScreenBuffer (HeGbl.Parm->Console);

    } else {
        if (!SetConsoleScreenBufferSize(HeGbl.Console, HeGbl.dwSize)) {

            GetConsoleScreenBufferInfo(HeGbl.Console, &Mode);
            Mode.srWindow.Bottom -= Mode.srWindow.Top;
            Mode.srWindow.Right -= Mode.srWindow.Left;
            Mode.srWindow.Top = 0;
            Mode.srWindow.Left = 0;
            SetConsoleWindowInfo(HeGbl.Console, TRUE, &Mode.srWindow);

            SetConsoleScreenBufferSize(HeGbl.Console, HeGbl.dwSize);
        }

        if (HeGbl.LineTot <= HeGbl.dwSize.Y) {
            HeGbl.dwSize.Y--;
            pt = POS(HeGbl.LineTot - 1,0);
            for (u=HeGbl.dwSize.X; u; u--) {
                PUTCHAR (pt, ' ', HeGbl.AttrNorm);
            }

            heShowBuf (HeGbl.LineTot - 1, 1);
        }

        HeGbl.dwSize.X = 0;
        SetConsoleCursorPosition (HeGbl.Console, HeGbl.dwSize);
        SetConsoleCursorInfo (HeGbl.Console, &HeGbl.CursorInfo);
    }

    if (HeGbl.pVioBuf) {
        GlobalFree (HeGbl.pVioBuf);
        HeGbl.pVioBuf = NULL;
    }
}


heRefresh ()
{
    RefreshDisp ();

    if (HeGbl.Flag & FHE_KICKDIRTY) {
        HeGbl.Parm->flag |= FHE_DIRTY;
        SetEvent (HeGbl.Parm->Kick);
    }
    return 0;
}


int heSetDisp ()
{
    PCHAR_INFO  pt, pt1;
    USHORT      u;

    pt = POS(0,0);
    for (u=HeGbl.LineTot * CELLPERLINE; u; u--) {
        PUTCHAR (pt, ' ', HeGbl.AttrNorm);
    }

    heDisp (1,  5, "Edit: %H%S", HeGbl.Parm->ename);
    heDisp (2,  5, "Size: %Q ", HeGbl.TotLen);
    if (HeGbl.TotLen < 0x100000000)  {
        heDisp (2,  28, "(%D)", (ULONG)HeGbl.TotLen);
    }

    heDisp (1, 40, "Position:");
    for (pt1=POS(1,50), u=0; u<30; u++, pt1++)
        pt1->Attributes = HeGbl.AttrHigh;

    //if (HeGbl.Parm->MaxLine == 0) {
        u = HeGbl.LineTot - 1;
        heDisp (u, 0, "%HF1%N:Toggle");
        heDisp (u,11, "%HF2%N:Goto");

        if (!vInSearch) {
            heDisp (u,20, "%HF3%N:Search");
        }

        heDisp (u,31, "%HF4%N:Export");
        heDisp (u,42, "%HF5%N:Import");

        if (HeGbl.DisplayMode == D_DWORD  &&  (HeGbl.Flag & FHE_JUMP) != 0)
             heDisp (u,53, "%HF6%N:Jump");
        else heDisp (u,53, "       ");

        heDisp (u,66, "%HF10%N:Undo");

        //if (HeGbl.Flag & FHE_F6)
        //    heDisp (u,51, "%HF6%N:PSec");
    //}
    return 0;
}

int heUpdateFncs ()
{
    heShowBuf (HeGbl.LineTot - 1, 1);
    return 0;
}


int heUpdateStats ()
{
    COORD dwBufferCoord;
    SMALL_RECT lpWriteRegion;

    heHexQWord (POS(1, 50), HeGbl.CurEditLoc, HeGbl.AttrHigh);

    if (HeGbl.TotLen < 0x100000000) {
    
        heLtoa( POS(2, 50), (ULONG)HeGbl.CurEditLoc);
    }

    dwBufferCoord.X = 50;
    dwBufferCoord.Y = 1;

    lpWriteRegion.Left   = 50;
    lpWriteRegion.Top    = HeGbl.TopLine + 1;
    lpWriteRegion.Right  = 74;
    lpWriteRegion.Bottom = HeGbl.TopLine + 2;

    WriteConsoleOutputA (
        HeGbl.Console,
        HeGbl.pVioBuf,
        HeGbl.dwVioBufSize, // size of VioBuf
        dwBufferCoord,      // location in VioBuf to write
        &lpWriteRegion      // location to write on display
    );

    SetConsoleCursorPosition (HeGbl.Console, HeGbl.CursorPos); // redisplay cursor
    return 0;
}

VOID heShowBuf (ULONG StartingLine, ULONG NoLines)
{
    COORD dwBufferCoord;
    SMALL_RECT lpWriteRegion;

    dwBufferCoord.X = (SHORT)0;
    dwBufferCoord.Y = (SHORT)StartingLine;

    StartingLine += HeGbl.TopLine;
    lpWriteRegion.Left   = (SHORT)0;
    lpWriteRegion.Top    = (SHORT)StartingLine;
    lpWriteRegion.Right  = (SHORT)(CELLPERLINE-1);
    lpWriteRegion.Bottom = (SHORT)(StartingLine+NoLines-1);

    WriteConsoleOutputA (
        HeGbl.Console,
        HeGbl.pVioBuf,
        HeGbl.dwVioBufSize, // size of VioBuf
        dwBufferCoord,      // location in VioBuf to write
        &lpWriteRegion      // location to write on display
    );
}


struct Buffer *heGetBuf (ULONGLONG loc)
{
    struct  Buffer  **ppBuf, *pBuf;
    USHORT  len;
    NTSTATUS status;

    loc &= SECTORMASK;

    ppBuf = &HeGbl.Buf;
    while (pBuf = *ppBuf) {
        if (pBuf->offset >= loc) {
            if (pBuf->offset == loc)        // buffer the correct offset?
                return pBuf;                // yup - all done

            break;                          // it's not here
        }
        ppBuf = &pBuf->next;                // try the next one
    }


    /*
     *  buffer was not in list - it should be insterted before ppBuf
     */

    if (vBufFree) {
        pBuf = vBufFree;
        vBufFree = vBufFree->next;
    } else {
        pBuf = (struct Buffer *)
                 GlobalAlloc (0, sizeof(struct Buffer)+2*BUFSZ);
        if (!pBuf) {
            return NULL;
        }
    }

    pBuf->data   = (PUCHAR)(((ULONG_PTR)pBuf+sizeof(struct Buffer)+BUFSZ));
    pBuf->offset = loc;
    pBuf->physloc= loc;                     // Assume physloc is logical offset
    pBuf->flag   = 0;

    // Link this buffer in now! In case we recurse (due to read-error)
    pBuf->next = *ppBuf;                    // link in this new buffer
    *ppBuf = pBuf;

    if (loc + BUFSZ > HeGbl.TotLen) {       // are we going to hit the EOF?
         if (loc >= HeGbl.TotLen) {         // is buffer completely passed EOF?
            pBuf->len = 0;
            goto nodata;                    // yes, then no data at all
         }
         len = (USHORT) (HeGbl.TotLen - loc);   // else, clip to EOF
    } else len = BUFSZ;                     // not pass eof, get a full buffer

    pBuf->len = len;

    if (HeGbl.Flag & FHE_EDITMEM)               // Direct memory edit?
        pBuf->data = HeGbl.Parm->mem + loc;     // memory location of buffer

    if (HeGbl.Read) {
        /*
         *  Read buffer from file
         */
        status = HeGbl.Read (HeGbl.Parm->handle, loc, pBuf->data, len);
        if (status) {
            // If read error, we will always retry once.  Also clear buffer
            // before retry in case read retreives some info
            for (; ;) {
                memset (pBuf->data,   0, len);      // Clear read area
                memset (pBuf->orig,0xff, len);      // good effect
                status = HeGbl.Read (HeGbl.Parm->handle, loc, pBuf->data, len);

                if (!status)
                    break;

                if (heIOErr ("READ ERROR!", loc, pBuf->physloc, status) == 'I') {
                    pBuf->flag |= FB_BAD;
                    break;
                }
            }
        }
    }

    memcpy (pBuf->orig, pBuf->data, len);       // make a copy of the data

nodata:
    return pBuf;
}


USHORT heIOErr (UCHAR *str, ULONGLONG loc, ULONGLONG ploc, ULONG errcd)
{
    USHORT      c;

    if (errcd == 0xFFFFFFFF)
        return 'I';

    heSetUpdate (U_NONE);
    heBox (12, TOPLINE+1, 55, 8);

    heDisp (TOPLINE+3, 14, str);
    heDisp (TOPLINE+4, 14, "Error code %H%D%N, Offset %Qh, Sector %D",
        errcd, loc, (ULONG)(ploc / BUFSZ));
    heDisp (TOPLINE+7, 14, "Press '%HR%N' to retry IO, or '%HI%N' to ignore");
    RefreshDisp ();

    c = heGetChar ("RI");

    heSetDisp ();                   // Get heBox off of screen
    heSetUpdate (U_SCREEN);
    return c;
}


UCHAR heGetChar (keys)
PUCHAR keys;
{
    INPUT_RECORD    Kd;
    DWORD           cEvents;
    UCHAR           *pt;

    for (; ;) {
        Beep (500, 100);

        for (; ;) {
            ReadConsoleInput (HeGbl.StdIn, &Kd, 1, &cEvents);

            if (Kd.EventType != KEY_EVENT)
                continue;                           // Not a key

            if (!Kd.Event.KeyEvent.bKeyDown)
                continue;                           // Not a down stroke

            if (Kd.Event.KeyEvent.wVirtualKeyCode == 0    ||    // ALT
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x10 ||    // SHIFT
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x11 ||    // CONTROL
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x14)      // CAPITAL
                    continue;

            break;
        }

        if (Kd.Event.KeyEvent.wVirtualKeyCode >= 'a'  &&
            Kd.Event.KeyEvent.wVirtualKeyCode <= 'z')
                Kd.Event.KeyEvent.wVirtualKeyCode -= ('a' - 'A');

        for (pt=keys; *pt; pt++)            // Is this a key we are
            if (Kd.Event.KeyEvent.wVirtualKeyCode == *pt)
                return *pt;                 // looking for?
    }
}


VOID __cdecl
heDisp (USHORT line, USHORT col, PUCHAR pIn, ...)
{
    register char   c;
    PCHAR_INFO pOut;
    WORD    attr;
    USHORT  u;
    UCHAR   *pt;
    va_list args;

    attr = HeGbl.AttrNorm;
    pOut = POS(line,col);

    va_start(args,pIn);
    while (c = *(pIn++)) {
        if (c != '%') {
            PUTCHAR (pOut, c, attr);
            continue;
        }

        switch (*(pIn++)) {
            case 'S':
                pt = va_arg(args, CHAR *);
                while (*pt) {
                    PUTCHAR (pOut, *(pt++), attr);
                }
                break;

            case 'X':               /* Long HEX, fixed len      */
                heHexDWord (pOut, va_arg(args, ULONG), attr);
                pOut += 8;
                break;
                
            case 'Q':               /* LongLong HEX, fixed len      */
                heHexQWord (pOut, va_arg(args, ULONGLONG), attr);
                pOut += 16;
                break;

            case 'D':               /* Long dec, varible len    */
                u = heLtoa (pOut, va_arg(args, ULONG));
                while (u--) {
                    pOut->Attributes = attr;
                    pOut++;
                }
                break;
            case 'H':
                attr = HeGbl.AttrHigh;
                break;
            case 'N':
                attr = HeGbl.AttrNorm;
                break;
        }
    }
}




void heHexDWord (s, l, attr)
PCHAR_INFO  s;
ULONG   l;
WORD    attr;
{
    UCHAR   d, c;
    UCHAR   *pt;

    s += 8-1;
    pt = (UCHAR *) &l;

    for (d=0; d<4; d++) {
        c = *(pt++);
        s->Attributes     = attr;
        s->Char.AsciiChar = rghexc[c & 0x0F];
        s--;
        s->Attributes     = attr;
        s->Char.AsciiChar = rghexc[c >> 4];
        s--;
    }
}


void heHexQWord (s, l, attr)
PCHAR_INFO  s;
ULONGLONG   l;
WORD    attr;
{
    UCHAR   d, c;
    UCHAR   *pt;

    s += 16-1;
    pt = (UCHAR *) &l;

    for (d=0; d<8; d++) {
        c = *(pt++);
        s->Attributes     = attr;
        s->Char.AsciiChar = rghexc[c & 0x0F];
        s--;
        s->Attributes     = attr;
        s->Char.AsciiChar = rghexc[c >> 4];
        s--;
    }
}


USHORT heLtoa (s, l)
PCHAR_INFO s;
ULONG  l;
{
    static ULONG mask[] = { 0L,
                 1L,
                10L,
               100L,
              1000L,
             10000L,
            100000L,
           1000000L,
          10000000L,
         100000000L,
        1000000000L,
    };

    static UCHAR comm[] = "xxxx,xx,xx,xx,xx";
    PCHAR_INFO  os;
    UCHAR      c;
    USHORT     i, j;
    ULONG      m;

    if (l < 1000000000L) {
        for (i=1; mask[i] <= l; i++)  ;

        if  (l == 0L)       // Make Zeros
            i++;
    } else
        i = 11;

    os = s;
    j  = i;
    while (m = mask[--i]) {
        c  = (UCHAR) ((ULONG) l / m);
        l -= m * c;
        s->Char.AsciiChar = c + '0';
        s->Attributes     = HeGbl.AttrNorm;
        if (comm[i] == ',') {
            s++;
            s->Attributes     = HeGbl.AttrNorm;
            s->Char.AsciiChar = ',';
        }
        s++;
    }

    i = (USHORT)(s - os);                       // remember how long the number was

    while (j++ < 11) {                  /* Clear off some blank space after */
        s->Char.AsciiChar = ' ';        /* the number.                      */
        s++;
    }

    return i;
}


ULONG heHtou (s)
UCHAR *s;
{
    UCHAR   c;
    ULONG   l;

    l = 0;
    for (; ;) {
        c = *(s++);

        if (c == 's'  ||  c == 'S') {       // Sector multiplier?
            l = l * (ULONG)BUFSZ;
            break;
        }

        if (c >= 'a')       c -= 'a' - 10;
        else if (c >= 'A')  c -= 'A' - 10;
        else                c -= '0';

        if (c > 15)
            break;

        l = (l<<4) + c;
    }
    return l;
}

ULONGLONG heHtoLu (s)
UCHAR *s;
{
    UCHAR   c;
    ULONGLONG   l;

    l = 0;
    for (; ;) {
        c = *(s++);

        if (c == 's'  ||  c == 'S') {       // Sector multiplier?
            l = l * (ULONG)BUFSZ;
            break;
        }

        if (c >= 'a')       c -= 'a' - 10;
        else if (c >= 'A')  c -= 'A' - 10;
        else                c -= '0';

        if (c > 15)
            break;

        l = (l<<4) + c;
    }
    return l;
}

NTSTATUS
heOpenFile (PUCHAR name, PHANDLE fhan, ULONG access)
{
    *fhan = CreateFile (
            name,
            access,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL );

    if (*fhan == INVALID_HANDLE_VALUE  &&  (access & GENERIC_WRITE)) {
        *fhan = CreateFile (
                name,
                access,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                CREATE_NEW,
                0,
                NULL );
    }

    return *fhan == INVALID_HANDLE_VALUE ? GetLastError() : STATUS_SUCCESS;
}

NTSTATUS
heReadFile (HANDLE h, PUCHAR buffer, ULONG len, PULONG br)
{
    if (!ReadFile (h, buffer, len, br, NULL))
        return GetLastError();
    return STATUS_SUCCESS;
}

NTSTATUS
heWriteFile (HANDLE h, PUCHAR buffer, ULONG len)
{
    ULONG   bw;

    if (!WriteFile (h, buffer, len, &bw, NULL))
        return GetLastError();
    return (bw != len ? ERROR_WRITE_FAULT : STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\he\makefile.inc ===
$(O)\he.res: he.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\head\head.c ===
/* head - first n lines to STDOUT
 *
 *   20-Jul-1991 ianja Wrote it.
 *   21-Jul-1991 ianja Close stdin (for piped input)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

int Head(char *pszFile, int nLines, BOOL fBanner);
char *Version = "HEAD v1.1 1991-06-20:";

#define BUFSZ 256

void
__cdecl main (argc, argv)
int argc;
char *argv[];
{
    int  nArg;
    int  cLines = 10;  // default
    int  nFiles = 0;
    int  nErr = 0;

    if ((argc > 1) && ((*argv[1] == '-') || (*argv[1] == '/'))) {
        if (argv[1][1] == '?') {
            printf("%s\n", Version);
            printf("usage: HEAD [switches] [filename]*\n");
            printf("   switches: [-?] display this message\n");
            printf("             [-n] display top n lines of each file (default 10)\n");
            exit(0);
        }

        cLines = atoi(argv[1]+1);
        nArg = 2;
    } else {
        nArg = 1;
    }

    nFiles = argc - nArg;

    if (nFiles < 1) {
        nErr += Head(NULL, cLines, FALSE);
    } else while (nArg < argc) {
        nErr += Head(argv[nArg], cLines, (nFiles > 1));
        nArg++;
    }

    if (nErr) {
        exit(2);
    } else {
        exit(0);
    }
}

int Head(char *pszFile, int nLines, BOOL fBanner)
{
    FILE *fp;
    int nErr = 0;
    char buff[BUFSZ];

    /*
     * Open file for reading
     */
    if (pszFile) {
        if ((fp = fopen(pszFile, "r")) == NULL) {
            fprintf(stderr, "HEAD: can't open %s\n", pszFile);
            return 1;
        }
    } else {
        fp = stdin;
    }

    /*
     * Banner printed if there is more than one input file
     */
    if (fBanner) {
        fprintf(stdout, "==> %s <==\n", pszFile);
    }

    /*
     * Print cLines, or up to end of file, whichever comes first
     */
    while (nLines-- > 0) {
        if (fgets(buff, BUFSZ-1, fp) == NULL) {
            if (!feof(fp)) {
                fprintf(stderr, "HEAD: can't read %s\n", pszFile);
                nErr++;
                goto CloseOut;
            }
            break;
        }
        if (fputs(buff, stdout) == EOF) {
            fprintf(stderr, "can't write output\n");
            nErr++;
            goto CloseOut;
        }
    }

    if (fBanner) {
        fprintf(stdout, "\n");
    }

CloseOut:
    fclose(fp);
    return nErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hdivide\hdivide.cpp ===
//
// hdivide.cpp -- yet another header file divider
//
// 1998 Nov Hiro Yamamoto
//


#pragma warning(disable: 4786)
#include <cstdio>
#include <string>
#include <cstdarg>
#include <map>
#include <vector>
#include <cassert>

#include <io.h>

#define PROGNAME    "hdivide"
#define VERSION     "1.0"

extern "C" {
    extern int getopt(int argc, char** argv, const char* opts);
    extern int optind;
}

namespace opt {
    bool verbose;
}

namespace input {
    unsigned long length;
    int lineno = 1;
    std::string path;

    std::string strip(const std::string& fname)
    {
        std::string stripped;

        //
        // find the "path" part
        //
        int n = fname.rfind('\\');
        if (n < 0) {
            n = fname.rfind('/');
        }

        if (n < 0 && (n = fname.rfind(':')) < 0) {
            n = 0;
        }
        else {
            ++n;
        }

        // store the path
        path = fname.substr(0, n);
        // retrive the filename portion
        stripped = fname.substr(n, fname.length());

        return stripped;
    }
}

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(a)   (sizeof(a) / sizeof(a[0]))
#endif

namespace id {
    const char all[] = "all";
    const char begin[] = "begin";
    const char end[] = "end";
    const char else_[] = "else";
    const int begin_size = ARRAY_SIZE(begin) - 1;
    const int end_size = ARRAY_SIZE(end) - 1;
    const int else_size = ARRAY_SIZE(else_) - 1;

    const char internal[] = "internal";
    const char public_[] = "public";
    const char null[] = "null";
    std::string privatefile;
    std::string publicfile;

    const char insert[] = "insert";
    const int insert_size = ARRAY_SIZE(insert) - 1;
    const char reference_start[] = "reference_start";
    const char reference_end[] = "reference_end";
}

#define MYFAILURE_OPENFILE          (120)
#define MYFAILURE_INVALID_FORMAT    (121)

using namespace std;

//////////////////////////////////////////////////////////////////////////
// usage
//////////////////////////////////////////////////////////////////////////

void usage()
{
    fputs(PROGNAME ": version " VERSION "\n", stderr);
    fputs("usage: hdivide [-v] input-filename (no path name please)\n", stderr);
}

//////////////////////////////////////////////////////////////////////////
// misc. helpers
//////////////////////////////////////////////////////////////////////////

inline void makeupper(string& str)
{
    for (int i = 0; i < str.length(); ++i) {
        str[i] = (char)toupper(str[i]);
    }
}

inline void makelower(string& str)
{
    for (int i = 0; i < str.length(); ++i) {
        str[i] = (char)tolower(str[i]);
    }
}

namespace msg {
    void __cdecl error(const char* fmt, ...)
    {
        va_list args;

        fputs(PROGNAME ": [error] ", stderr);
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
        putc('\n', stderr);
    }

    void __cdecl verbose(const char* fmt, ...)
    {
        if (!opt::verbose)
            return;

        va_list args;
        fputs(PROGNAME ": ", stderr);
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
        putc('\n', stderr);
    }
}


//////////////////////////////////////////////////////////////////////////
// class Output
//////////////////////////////////////////////////////////////////////////

class Output;

class Insertion {
public:
    // somehow the default constructor is required for std::vector
    // on NT5 build environment, as of Nov 1998
    explicit Insertion() : m_insert(NULL), m_insertion_point(-1) { }
    explicit Insertion(Output* insert, int point)
        : m_insert(insert), m_insertion_point(point)
    {
    }
public:
    Output* m_insert;
    int m_insertion_point;
};

class Reference {
public:
    // somehow the default constructor is required for std::vector
    // on NT5 build environment, as of Nov 1998
    Reference() : m_start(-1), m_end(-1) { }
    explicit Reference(int start, int end)
        : m_start(start), m_end(end) { }
public:
    int m_start;
    int m_end;
};

class Output {
public:
    explicit Output(const string& name)
      : m_name(name),
        m_fname(input::path + name + ".x"),
        m_alive(true),
        m_insertion_finished(false),
        m_reference_start(-1)
    {
        msg::verbose("opening %s", m_fname.c_str());
        if ((m_fp = fopen(m_fname.c_str(), "wt")) == NULL) {
            msg::error("cannot open file %s", m_fname.c_str());
            throw MYFAILURE_OPENFILE;
        }

        if (m_tomem) {
            m_buffer.reserve(input::length);
        }
    }
    virtual ~Output();

public:
    void setalive(bool alive)
    {
        m_alive = alive;
    }
    bool getalive()
    {
        return m_alive;
    }
    const string& getname()
    {
        return m_name;
    }
    void put(int c)
    {
        assert(m_fp);
        if (m_alive) {
            if (m_tomem) {
                m_buffer += (char)c;
            }
            else {
                putc(c, m_fp);
            }
        }
    }
    void puts(const char* s)
    {
        assert(m_fp);
        if (m_alive) {
            if (m_tomem) {
                m_buffer += s;
            }
            else {
                fputs(s, m_fp);
            }
        }
    }
    bool operator<(const Output* a)
    {
        return m_name < a->m_name;
    }

    void set_insertion_point(Output* insert);
    void set_reference_start();
    void set_reference_end();

    bool do_insertion();

protected:
    FILE* m_fp;
    bool m_alive;
    static bool m_tomem;

    string m_name;
    string m_fname;

    string m_buffer;

    vector<Insertion> m_insertions;

    bool m_insertion_finished;

    vector<Reference> m_references;

    int m_reference_start;
    int m_reference_start_line;
};

bool Output::m_tomem = true;

Output::~Output()
{
    if (m_reference_start != -1) {
        msg::error("reference started at line %d is not closed in tag '%s'",
            m_reference_start_line, m_name.c_str());
        throw MYFAILURE_INVALID_FORMAT;
    }
    if (!m_buffer.empty()) {
        msg::verbose("flushing %s", m_fname.c_str());
        fputs(m_buffer.c_str(), m_fp);
    }
    if (m_fp) {
        fclose(m_fp);
    }
}


void Output::set_insertion_point(Output* insert)
{
    assert(insert!= NULL);
    if (m_alive) {
        Insertion i(insert, m_buffer.length());
        m_insertions.push_back(i);
    }
}

void Output::set_reference_start()
{
    if (m_alive) {
        if (m_reference_start != -1) {
            msg::error("line %d: invalid reference_start appeared in tag context '%s'", input::lineno, m_name.c_str());
            throw MYFAILURE_INVALID_FORMAT;
        }
        m_reference_start = m_buffer.length();
        m_reference_start_line = input::lineno;
    }
}

void Output::set_reference_end()
{
    if (m_alive) {
        if (m_reference_start == -1) {
            msg::error("line %d: invalid reference_end appeared in tag context '%s'", input::lineno, m_name.c_str());
            throw MYFAILURE_INVALID_FORMAT;
        }
        Reference ref(m_reference_start, m_buffer.length());
        msg::verbose("%s reference_end: %d - %d", m_name.c_str(), ref.m_start, ref.m_end);
        m_reference_start = -1;
        m_references.push_back(ref);
    }
}

bool Output::do_insertion()
{
    if (!m_tomem || m_insertion_finished)
        return true;

    // to avoid infinite recursion by errornous commands,
    // firstly declare we've finished this.
    m_insertion_finished = true;

    int upto = m_insertions.size();
    for (int i = 0; i < upto; ++i) {
        Insertion& ins = m_insertions[i];
        assert(&ins);
        if (ins.m_insert->m_references.size() == 0) {
            msg::error("reference area is not specified or incorrect for tag '%s'", ins.m_insert->m_name.c_str());
            return false;
        }

        if (!ins.m_insert->m_insertion_finished) {
            if (!ins.m_insert->do_insertion())
                return false;
        }

        Output* o = ins.m_insert;
        for (int l = 0; l < o->m_references.size(); ++l) {
            Reference& ref = o->m_references[l];
            int len = ref.m_end - ref.m_start;
            msg::verbose("%s [%d] inserting text at %d, %s(%d - %d)",
                         m_name.c_str(), l,
                         ins.m_insertion_point,
                         o->m_name.c_str(), ref.m_start, ref.m_start + len);
            m_buffer.insert(ins.m_insertion_point,
                o->m_buffer, ref.m_start,
                len);
            // fixup my insertions
            int point = ins.m_insertion_point;
            for (int k = 0; k < m_insertions.size(); ++k) {
                if (m_insertions[k].m_insertion_point >= point) {
                    m_insertions[k].m_insertion_point += len;
                    msg::verbose("%s [%d] insertion point fixed from %d to %d",
                        m_name.c_str(), k,
                        m_insertions[k].m_insertion_point - len,
                        m_insertions[k].m_insertion_point);
                }
            }
            // fixup my references
            for (k = 0; k < m_references.size(); ++k) {
                msg::verbose("%s m_reference[%d].m_start=%d, m_end=%d adding len=%d", m_name.c_str(),
                             k,
                             m_references[k].m_start, m_references[k].m_end,
                             len);
                if (m_references[k].m_start > point) {
                    m_references[k].m_start += len;
                }
                if (m_references[k].m_end > point) {
                    m_references[k].m_end += len;
                    msg::verbose("finally start=%d, end=%d", m_references[k].m_start, m_references[k].m_end);
                }
            }
        }
    }

    return true;
}

//////////////////////////////////////////////////////////////////////////
// class Divider
//
// this class manages the map of Output and performs misc. operations
//////////////////////////////////////////////////////////////////////////

class Divider : public map<string, Output*>
{
public:

    virtual ~Divider()
    {
        // process insertions
        for (iterator i = begin(); i != end(); ++i) {
            if (!i->second->do_insertion())
                break;
        }
        // clear up
        for (i = begin(); i != end(); ++i) {
            delete i->second;
        }
    }

    //////////////////////////////////////////////////////////////////////////
    // printout
    //
    // printout the argument to outputs
    //////////////////////////////////////////////////////////////////////////
    void printout(int c)
    {
        for (iterator i = begin(); i != end(); ++i) {
            i->second->put(c);
        }
    }

    void printout(const char* s)
    {
        for (iterator i = begin(); i != end(); ++i) {
            i->second->puts(s);
        }
    }

    void process_line(string& line);

protected:
    void extract_version(const string& name, string& symbol, string& version, bool allow_omission = false);
    void get_arg(const string& name, string& arg);
    void prepare_section(string& name);
    void process_divider(string& line);

    void set_alive(bool alive)
    {
        for (iterator i = begin(); i != end(); ++i) {
            i->second->setalive(alive);
        }
    }

    typedef map<string, bool> OutputState;

    void push_state(OutputState& state)
    {
        state.clear();
        for (iterator i = begin(); i != end(); ++i) {
            state[i->second->getname()] = i->second->getalive();
        }
    }

    void pop_state(OutputState& state)
    {
        for (OutputState::iterator i = state.begin(); i != state.end(); ++i) {
            assert((*this)[i->first] != NULL);
            (*this)[i->first]->setalive(i->second);
        }
    }

protected:
    string m_last_symbol;
    string m_last_version;
};


void Divider::prepare_section(string& name)
{
    // make it lower case
    makelower(name);

    if (name == id::internal) {
        name = id::privatefile;
    }
    else if (name == id::public_) {
        name = id::publicfile;
    }

    if (name != id::null && (*this)[name] == NULL) {
        (*this)[name] = new Output(name);
    }
}

//////////////////////////////////////////////////////////////////////////
// Divider::extract_version
//
// extracts version symbol and supported version
//
// "begin_symbol_version" is splited to symbol and version.
// Both are stored in upper case.
//////////////////////////////////////////////////////////////////////////

void Divider::extract_version(const string& name, string& symbol, string& version, bool allow_omission /*= false*/)
{
    int nsymbol = name.find('_');
    int nver = name.rfind('_');
    if (nsymbol == -1 || nver == nsymbol) {
        if (allow_omission) {
            symbol = m_last_symbol;
            version = m_last_version;
            return;
        }
        else {
            msg::error("line %d: invalid version specifier '%s'", input::lineno, name.c_str());
            throw MYFAILURE_INVALID_FORMAT;
        }
    }
    // symbol
    symbol = name.substr(nsymbol + 1, nver - nsymbol - 1);
    // upper case
    makeupper(symbol);
    version = "0000" + name.substr(nver + 1, name.length());
    version = version.substr(version.length() - 4, 4);
    makeupper(version);

    m_last_symbol = symbol;
    m_last_version = version;
}

//////////////////////////////////////////////////////////////////////////
// Divider::get_arg
//
// extracts one argument separated by "_"
//////////////////////////////////////////////////////////////////////////

void Divider::get_arg(const string& name, string& arg)
{
    int npos = name.find('_');
    if (npos == -1) {
        msg::error("line %d: command incompleted in '%s'", input::lineno, name.c_str());
        throw MYFAILURE_INVALID_FORMAT;
    }

    arg = name.substr(npos + 1, name.length());
}



//////////////////////////////////////////////////////////////////////////
// Divider::process_divider
//
// processes the divider instructions
//////////////////////////////////////////////////////////////////////////

void Divider::process_divider(string& line)
{
    const char* p = line.begin();
    ++p;

    bool makelive = true;
    if (*p == '!') {
        makelive = false;
        ++p;
    }

    // skip the heading spaces
    while (isspace(*p))
        ++p;

    for (int col = 0; p != line.end(); ++col) {
        // pickup the name
        string name;
        while (*p != ';' && p != line.end()) {
            if (!isspace(*p)) {
                name += *p;
            }
            ++p;
        }
        if (p != line.end()) {
            ++p;
        }

        // first column may have special meaning
        if (col == 0) {
            if (name == id::all) {
                set_alive(makelive);
                // does "!all" make sense ?
                // however i'm supporting it anyway
                break;
            }
            if (name == id::null) {
                set_alive(!makelive);
                break;
            }
            if (name.substr(0, id::insert_size) == id::insert) {
                string insert;
                get_arg(name, insert);
                prepare_section(insert);
                if (insert == id::null || insert == id::all) {
                    msg::error("line %d: invalid insertion of '%s'", input::lineno, insert.c_str());
                    throw MYFAILURE_INVALID_FORMAT;
                }
                assert((*this)[insert] != NULL);
                for (iterator i = begin(); i != end(); ++i) {
                    (*this)[i->first]->set_insertion_point((*this)[insert]);
                }
                break;
            }
            if (name == id::reference_start) {
                for (iterator i = begin(); i != end(); ++i) {
                    (*this)[i->first]->set_reference_start();
                }
                break;
            }
            if (name == id::reference_end) {
                for (iterator i = begin(); i != end(); ++i) {
                    (*this)[i->first]->set_reference_end();
                }
                break;
            }

            if (name.substr(0, id::begin_size) == id::begin) {
                string symbol;
                string version;
                extract_version(name, symbol, version);
                printout("#if (");
                printout(symbol.c_str());
                printout(" >= 0x");
                printout(version.c_str());
                printout(")\n");
                break;
            }
            if (name.substr(0, id::else_size) == id::else_) {
                printout("#else\n");
                break;
            }
            if (name.substr(0, id::end_size) == id::end) {
                string symbol;
                string version;
                extract_version(name, symbol, version, true);
                printout("#endif /* ");
                printout(symbol.c_str());
                printout(" >= 0x");
                printout(version.c_str());
                printout(" */\n");
                break;
            }

            // setup the initial state
            set_alive(!makelive);
        }
        prepare_section(name);
        (*this)[name]->setalive(makelive);
    }
}

//////////////////////////////////////////////////////////////////////////
// Divider::process_line
//
// handles one line
//////////////////////////////////////////////////////////////////////////

void Divider::process_line(string& line)
{
    if (line[0] == ';') {
        process_divider(line);
    }
    else {
        // check if inline section appears
        bool instr = false;
        const char* p = line.begin();
        const char* section = NULL;
        while (p != line.end()) {
            if (*p == '\\' && (p + 1) != line.end()) {
                // skip escape character
                // note: no consideration for Shift JIS
                ++p;
            }
            else if (*p == '"' || *p == '\'') {
                // beginning of end of literal
                instr = !instr;
            }
            else if (*p == '@' && !instr) {
                // we have inline section
                section = p;
                break;
            }
            ++p;
        }

        if (section) {
            //
            // if inline tag is specified, temporarily change
            // the output
            //
            OutputState state;
            push_state(state);
            assert(*p == '@');
            ++p;
            if (*p == '+') {
                ++p;
            }
            else {
                set_alive(false);
            }
            while (p != line.end()) {
                string name;
                while (*p != ';' && p != line.end()) {
                    if (!isspace(*p)) {
                        name += *p;
                    }
                    ++p;
                }
                if (p != line.end())
                    ++p;
                if (name == id::all) {
                    set_alive(true);
                    break;
                }
                if (name == id::null) {
                    set_alive(false);
                    break;
                }
                prepare_section(name);
                (*this)[name]->setalive(true);
            }
            // trim trailing spaces
            int i = section - line.begin() - 1;
            while (i >= 0 && isspace(line[i])) {
                --i;
            }
            line = line.substr(0, i + 1);
            printout(line.c_str());
            printout('\n');
            pop_state(state);
        }
        else {
            printout(line.c_str());
            printout('\n');
        }
    }
    ++input::lineno;
}

//////////////////////////////////////////////////////////////////////////
// hdivide
//////////////////////////////////////////////////////////////////////////

void hdivide(FILE* fp)
{
    Divider divider;

    divider[id::publicfile] = new Output(id::publicfile);
    divider[id::privatefile] = new Output(id::privatefile);

    string line;
    int c;

    while ((c = getc(fp)) != EOF) {
        if (c == '\n') {
            divider.process_line(line);
            line = "";
        }
        else {
            line += (char)c;
        }
    }
    if (!line.empty())
        divider.process_line(line);
}


//////////////////////////////////////////////////////////////////////////
// main
//////////////////////////////////////////////////////////////////////////

int __cdecl main(int argc, char** argv)
{
    int c;

    while ((c = getopt(argc, argv, "v")) != EOF) {
        switch (c) {
        case 'v':
            opt::verbose = true;
            break;
        default:
            usage();
            return EXIT_FAILURE;
        }
    }

    if (optind == argc) {
        usage();
        return EXIT_FAILURE;
    }

    msg::verbose("input file: %s", argv[optind]);

    FILE* fp = fopen(argv[optind], "rt");
    if (fp == NULL) {
        msg::error("cannot open input file %s", argv[optind]);
        return EXIT_FAILURE;
    }

    input::length = _filelength(_fileno(fp));

    id::publicfile = argv[optind];
    id::publicfile = input::strip(id::publicfile.substr(0, id::publicfile.length() - 2));
    id::privatefile = id::publicfile + "p";

    int exitcode = EXIT_SUCCESS;

    try {
        hdivide(fp);
    } catch (int err) {
        exitcode = EXIT_FAILURE;
        switch (err) {
        case MYFAILURE_OPENFILE:
            break;
        case MYFAILURE_INVALID_FORMAT:
            msg::error("fatal: invalid format");
            break;
        }
    } catch (...) {
        exitcode = EXIT_FAILURE;
    }

    fclose(fp);

    return exitcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\charmap.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* CHARMAP.C - Character mapping arrays					*/
/*									*/
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include	"charmap.h"

#define	CHARMAP_SIZE	256

unsigned char	Charmap[CHARMAP_SIZE] = {
LX_EOS,			/* 0x0, <end of string marker> */
LX_ILL,			/* 0x1 */
LX_ILL,			/* 0x2 */
LX_ILL,			/* 0x3 */
LX_ILL,			/* 0x4 */
LX_ILL,			/* 0x5 */
LX_ILL,			/* 0x6 */
LX_ILL,			/* 0x7 */
LX_ILL,			/* 0x8 */
LX_WHITE,		/* <horizontal tab> */
LX_NL,			/* <newline> */
LX_WHITE,		/* <vertical tab> */
LX_WHITE,		/* <form feed> */
LX_CR,			/* <really a carriage return> */
LX_ILL,			/* 0xe */
LX_ILL,			/* 0xf */
LX_ILL,			/* 0x10 */
LX_ILL,			/* 0x11 */
LX_ILL,			/* 0x12 */
LX_ILL,			/* 0x13 */
LX_ILL,			/* 0x14 */
LX_ILL,			/* 0x15 */
LX_ILL,			/* 0x16 */
LX_ILL,			/* 0x17 */
LX_ILL,			/* 0x18 */
LX_ILL,			/* 0x19 */
LX_EOS,			/* 0x1a, ^Z */
LX_ILL,			/* 0x1b */
LX_ILL,			/* 0x1c */
LX_ILL,			/* 0x1d */
LX_ILL,			/* 0x1e */
LX_ILL,			/* 0x1f */
LX_WHITE,		/* 0x20 */
LX_BANG,		/* ! */
LX_DQUOTE,		/* " */
LX_POUND,		/* # */
LX_ASCII,		/* $ */
LX_PERCENT,		/* % */
LX_AND,			/* & */
LX_SQUOTE,		/* ' */
LX_OPAREN,		/* ( */
LX_CPAREN,		/* ) */
LX_STAR,		/* * */
LX_PLUS,		/* + */
LX_COMMA,		/* , */
LX_MINUS,		/* - */
LX_DOT,			/* . */
LX_SLASH,		/* / */
LX_NUMBER,		/* 0 */
LX_NUMBER,		/* 1 */
LX_NUMBER,		/* 2 */
LX_NUMBER,		/* 3 */
LX_NUMBER,		/* 4 */
LX_NUMBER,		/* 5 */
LX_NUMBER,		/* 6 */
LX_NUMBER,		/* 7 */
LX_NUMBER,		/* 8 */
LX_NUMBER,		/* 9 */
LX_COLON,		/* : */
LX_SEMI,		/* ; */
LX_LT,			/* < */
LX_EQ,			/* = */
LX_GT,			/* > */
LX_QUEST,		/* ? */
LX_EACH,		/* @ */
LX_ID,			/* A */
LX_ID,			/* B */
LX_ID,			/* C */
LX_ID,			/* D */
LX_ID,			/* E */
LX_ID,			/* F */
LX_ID,			/* G */
LX_ID,			/* H */
LX_ID,			/* I */
LX_ID,			/* J */
LX_ID,			/* K */
LX_ID,			/* L */
LX_ID,			/* M */
LX_ID,			/* N */
LX_ID,			/* O */
LX_ID,			/* P */
LX_ID,			/* Q */
LX_ID,			/* R */
LX_ID,			/* S */
LX_ID,			/* T */
LX_ID,			/* U */
LX_ID,			/* V */
LX_ID,			/* W */
LX_ID,			/* X */
LX_ID,			/* Y */
LX_ID,			/* Z */
LX_OBRACK,		/* [ */
LX_EOS,			/* \ */
LX_CBRACK,		/* ] */
LX_HAT,			/* ^ */
LX_ID,			/* _ */
LX_ASCII,		/* ` */
LX_ID,			/* a */
LX_ID,			/* b */
LX_ID,			/* c */
LX_ID,			/* d */
LX_ID,			/* e */
LX_ID,			/* f */
LX_ID,			/* g */
LX_ID,			/* h */
LX_ID,			/* i */
LX_ID,			/* j */
LX_ID,			/* k */
LX_ID,			/* l */
LX_ID,			/* m */
LX_ID,			/* n */
LX_ID,			/* o */
LX_ID,			/* p */
LX_ID,			/* q */
LX_ID,			/* r */
LX_ID,			/* s */
LX_ID,			/* t */
LX_ID,			/* u */
LX_ID,			/* v */
LX_ID,			/* w */
LX_ID,			/* x */
LX_ID,			/* y */
LX_ID,			/* z */
LX_OBRACE,		/* { */
LX_OR,			/* | */
LX_CBRACE,		/* } */
LX_TILDE,		/* ~ */
LX_ILL,			/* 0x7f */
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
};

unsigned char	Contmap[CHARMAP_SIZE] = {
LXC_SPECIAL,/* 0x0, <end of string marker> */
0,			/* 0x1 */
0,			/* 0x2 */
0,			/* 0x3 */
0,			/* 0x4 */
0,			/* 0x5 */
0,			/* <end of buffer marker> */
0,			/* 0x7 */
0,			/* 0x8 */
LXC_WHITE,	/* <horizontal tab> */
LXC_SPECIAL,/* <newline>, this is NOT considered whitespace */
LXC_WHITE,	/* <vertical tab> */
LXC_WHITE,	/* <form feed> */
0,			/* <really a carriage return> */
0,			/* 0xe */
0,			/* 0xf */
0,			/* 0x10 */
0,			/* 0x11 */
0,			/* 0x12 */
0,			/* 0x13 */
0,			/* 0x14 */
0,			/* 0x15 */
0,			/* 0x16 */
0,			/* 0x17 */
0,			/* 0x18 */
0,			/* 0x19 */
LXC_SPECIAL,/* 0x1a */
0,			/* 0x1b */
0,			/* 0x1c */
0,			/* 0x1d */
0,			/* 0x1e */
0,			/* 0x1f */
LXC_WHITE,	/* 0x20 */
0,			/* ! */
0,			/* " */
0,			/* # */
0,			/* $ */
0,			/* % */
0,			/* & */
0,			/* ' */
0,			/* ( */
0,			/* ) */
LXC_SPECIAL,/* * */
0,			/* + */
0,			/* , */
0,			/* - */
0,			/* . */
0,			/* / */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT | LXC_BDIGIT,	/* 0 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT | LXC_BDIGIT,	/* 1 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 2 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 3 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 4 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 5 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 6 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 7 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT,				/* 8 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT,				/* 9 */
0,												/* : */
0,												/* ; */
0,												/* < */
0,												/* = */
0,												/* > */
0,												/* ? */
0,												/* @ */
LXC_ID | LXC_XDIGIT,							/* A */
LXC_ID | LXC_XDIGIT	| LXC_RADIX,				/* B */
LXC_ID | LXC_XDIGIT,							/* C */
LXC_ID | LXC_XDIGIT | LXC_RADIX,				/* D */
LXC_ID | LXC_XDIGIT,							/* E */
LXC_ID | LXC_XDIGIT,							/* F */
LXC_ID,											/* G */
LXC_ID | LXC_RADIX,								/* H */
LXC_ID,											/* I */
LXC_ID,											/* J */
LXC_ID,											/* K */
LXC_ID,											/* L */
LXC_ID,											/* M */
LXC_ID,											/* N */
LXC_ID | LXC_RADIX,								/* O */
LXC_ID,											/* P */
LXC_ID | LXC_RADIX,								/* Q */
LXC_ID,											/* R */
LXC_ID,											/* S */
LXC_ID,											/* T */
LXC_ID,											/* U */
LXC_ID,											/* V */
LXC_ID,											/* W */
LXC_ID,											/* X */
LXC_ID,											/* Y */
LXC_ID,											/* Z */
0,												/* [ */
0,												/* \ */
0,												/* ] */
0,												/* ^ */
LXC_ID,											/* _ */
0,												/* ` */
LXC_ID | LXC_XDIGIT,							/* a */
LXC_ID | LXC_XDIGIT | LXC_RADIX,				/* b */
LXC_ID | LXC_XDIGIT,							/* c */
LXC_ID | LXC_XDIGIT | LXC_RADIX,				/* d */
LXC_ID | LXC_XDIGIT,							/* e */
LXC_ID | LXC_XDIGIT,							/* f */
LXC_ID,											/* g */
LXC_ID | LXC_RADIX,								/* h */
LXC_ID,											/* i */
LXC_ID,											/* j */
LXC_ID,											/* k */
LXC_ID,											/* l */
LXC_ID,											/* m */
LXC_ID,											/* n */
LXC_ID | LXC_RADIX,								/* o */
LXC_ID,											/* p */
LXC_ID | LXC_RADIX,								/* q */
LXC_ID,											/* r */
LXC_ID,											/* s */
LXC_ID,											/* t */
LXC_ID,											/* u */
LXC_ID,											/* v */
LXC_ID,											/* w */
LXC_ID,											/* x */
LXC_ID,											/* y */
LXC_ID,											/* z */
0,												/* { */
0,												/* | */
0,												/* } */
0,												/* ~ */
0,												/* 0x7f */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\he\hexedit.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1988-1990		**/ 
/*****************************************************************/ 

/****	hexedit.h
 *
 *  Structure and flags def's to call HexEdit
 *
 */


struct HexEditParm {
    ULONG       flag;           // edit flags
    UCHAR       *ename;         // edit name    (title)
    ULONGLONG   totlen;         // totlen (in bytes) being edited
    ULONGLONG   start;          // starting address of edit
    NTSTATUS    (*read)(HANDLE, ULONGLONG, PUCHAR, DWORD);      // (opt) fnc to read data
    NTSTATUS    (*write)(HANDLE, ULONGLONG, PUCHAR, DWORD);     // (opt) fnc to write changes
    HANDLE      handle;         // (opt) passed to read/write functions
    ULONG       ioalign;        // (opt) alignment when read/write (~editmem)
    UCHAR       *mem;           // (opt) Only if FHE_EDITMEM
    HANDLE      Kick;           // (opt) event to kick  (editmem only)
    HANDLE      Console;        // (opt) callers console handle
    ULONG       MaxLine;        // (opt) if non-zero, # of lines HexEdit is to use
    WORD        AttrNorm;       // (opt) Default attribute for text
    WORD        AttrHigh;       // (opt) Default attribute for highlighted text
    WORD        AttrReverse;    // (opt) Default attribute for reversed text
    WORD        CursorSize;     // (opt) Default size of cursor
    ULONGLONG   editloc;        // Position exited/kicked at
    ULONG       TopLine;        // (opt) Relative topline, requires MaxLine
} ;


#define FHE_VERIFYONCE  0x0001      // Prompt before updating (just once)
#define FHE_VERIFYALL   0x0002      // Prompt before any change is written
#define FHE_PROMPTSEC   0x0004      // Verify prompt is for sectors
#define FHE_SAVESCRN    0x0008      // Save & Restore orig screen

#define FHE_EDITMEM	0x0010	    // Direct mem edit
#define FHE_KICKDIRTY   0x0020      // Kick event if memory gets editted
#define FHE_KICKMOVE    0x0040      // Kick event every time cursor is moved
#define FHE_DIRTY       0x0080      // Set when data is dirtied
//efine FHE_F6          0x0100      // Exit when F6 pressed
#define FHE_ENTER       0x0800      // Exit when enter pressed

#define FHE_DWORD       0x0200      // Default to dword edit
#define FHE_JUMP        0x0400      // Support jump option

void   HexEdit (struct HexEditParm *);



/*
 * Read & Write functions are called as follows:
 * (note: read & write can be NULL if fhe_editmem is set.
 *  if editmem is set & read&write are not NULL, then it is assumed
 *  that mem points to the memory image of what read&write are to
 *  read & write.  (this is usefull for in-memory editing of items
 *  which also are to be read&write))
 *
 *  rc = read (handle, offset, buf, len, &physloc)
 *
 *      rc      - returned, zero sucess.  non-zero error code.
 *	handle	- handle as passed into HexEdit
 *	offset	- byte offset to read/write
 *	buf	- address to read/write data
 *	len	- len to read/write    (probabily a sector, but may be less)
 *
 *
 *
 *  rc = write (handle, offset, buf, len, physloc)
 *
 *	same as read params, expect 'physloc' is a long passed in and is
 *	whatever was returned to read.
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hextract\hextract.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    hextract.c

Abstract:

    This is the main module for a header the file extractor.

Author:

    Andre Vachon  (andreva) 13-Feb-1992
    Mark Lucovsky (markl)   28-Jan-1991

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <common.ver>


//
// Function declarations
//

int
ProcessParameters(
                 int argc,
                 char *argv[]
                 );

void
ProcessSourceFile( void );

void
ProcessLine(
           char *s
           );

//
// Global Data
//

unsigned char LineFiltering = 0;

char *LineTag;
char *ExcludeLineTag;
char *MultiLineTagStart;
char *MultiLineTagEnd;
char *CommentDelimiter = "//";

char *OutputFileName;
char *SourceFileName;
char **SourceFileList;

int SourceFileCount;
FILE *SourceFile, *OutputFile;


#define STRING_BUFFER_SIZE 1024
char StringBuffer[STRING_BUFFER_SIZE];


#define BUILD_VER_COMMENT "/*++ BUILD Version: "
#define BUILD_VER_COMMENT_LENGTH (sizeof( BUILD_VER_COMMENT )-1)

int OutputVersion = 0;

#define szVERSION	"1.3"


char const szUsage[] =
"Microsoft (R) HEXTRACT Version " szVERSION " (NT)\n"
VER_LEGALCOPYRIGHT_STR ". All rights reserved.\n"
"\n"
"Usage: HEXTRACT [options] filename1 [filename2 ...]\n"
"\n"
"Options:\n"
"    -f                        - filtering is turned on:\n"
"                                ULONG, UCHAR, USHORT & NTSTATUS are\n"
"                                replaced with DWORD, BYTE, WORD & DWORD.\n"
"    -f2                       - Same as -f except ULONGLONG and ULONG_PTR\n"
"                                isn't converted\n"
"    -o filename               - required existing output filename;\n"
"                                output is appended to filename\n"
"    -xt string                - supplies the tag for excluding one line\n"
"    -lt string                - supplies the tag for extracting one line\n"
"    -bt string1 string2       - supplies the starting and ending tags for\n"
"                                extracting multiple lines\n"
"    filename1 [filename2 ...] - supplies files from which the definitions\n"
"                                are extracted\n"
"\n"
"To be parsed properly, the tag strings must be located within a comment\n"
"delimited by //\n"
;


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    char achver[BUILD_VER_COMMENT_LENGTH];

    if (!ProcessParameters(argc, argv) || NULL == OutputFileName) {

        fprintf(stderr, szUsage);
        return 1;
    }

    if ( (OutputFile = fopen(OutputFileName,"r+")) == 0) {

        fprintf(stderr,"HEXTRACT: Unable to open output file %s for update access\n",OutputFileName);
        return 1;

    }

    if (fseek(OutputFile, 0L, SEEK_END) == -1) {
        fprintf(stderr, "HEXTRACT: Unable to seek to end of %s\n", OutputFileName);
        return 1;
    }
        

    OutputVersion = 0;

#ifdef HEXTRACT_DEBUG
    fprintf(
           stderr,
           "%s\n%s\n%s\n%s\n",
           LineTag,
           ExcludeLineTag,
           MultiLineTagStart,
           MultiLineTagEnd);

#endif

    while ( SourceFileCount-- ) {

        SourceFileName = *SourceFileList++;
        if ( (SourceFile = fopen(SourceFileName,"r")) == 0) {

            fprintf(stderr,"HEXTRACT: Unable to open source file %s for read access\n",SourceFileName);
            return 1;

        }

        ProcessSourceFile();
        fclose(SourceFile);

    }

    if (fseek(OutputFile, 0L, SEEK_SET) == -1) {
        fprintf(stderr, "HEXTRACT: Unable to seek to start of %s\n", OutputFileName);
        return 1;
    }
    if (1 == fread(achver, BUILD_VER_COMMENT_LENGTH, 1, OutputFile) &&
        !strncmp(achver, BUILD_VER_COMMENT, BUILD_VER_COMMENT_LENGTH)) {

        if (fseek(OutputFile, (long)BUILD_VER_COMMENT_LENGTH, SEEK_SET) == -1) {
            fprintf(stderr, "HEXTRACT: Unable to seek past comments in %s\n", OutputFileName);
            return 1;
        }
        fprintf(OutputFile, "%04d", OutputVersion);
    }

    if (fseek(OutputFile, 0L, SEEK_END) == -1) {
        fprintf(stderr, "HEXTRACT: Unable to seek to end of %s\n", OutputFileName);
        return 1;
    }
    fclose(OutputFile);
    return( 0 );
}


int
ProcessParameters(
                 int argc,
                 char *argv[]
                 )
{
    char c, *p;

    while (--argc) {

        p = *++argv;

        //
        // if we have a delimiter for a parameter, case throught the valid
        // parameter. Otherwise, the rest of the parameters are the list of
        // input files.
        //

        if (*p == '/' || *p == '-') {

            //
            // Switch on all the valid delimiters. If we don't get a valid
            // one, return with an error.
            //

            c = *++p;

            switch (toupper( c )) {

                case 'F':

                    c = *++p;
                    if ( (toupper ( c )) == '2')
                        LineFiltering = 2;
                    else
                        LineFiltering = 1;

                    break;

                case 'O':

                    argc--, argv++;
                    OutputFileName = *argv;

                    break;

                case 'L':

                    c = *++p;
                    if ( (toupper ( c )) != 'T')
                        return 0;
                    argc--, argv++;
                    LineTag = *argv;

                    break;

                case 'B':

                    c = *++p;
                    if ( (toupper ( c )) != 'T')
                        return 0;
                    argc--, argv++;
                    MultiLineTagStart = *argv;
                    argc--, argv++;
                    MultiLineTagEnd = *argv;

                    break;

                case 'X':

                    c = *++p;
                    if ( (toupper ( c )) != 'T')
                        return 0;
                    argc--, argv++;
                    ExcludeLineTag = *argv;

                    break;

                default:

                    return 0;

            }

        } else {

            //
            // Make the assumptionthat we have a valid command line if and
            // only if we have a list of filenames.
            //

            SourceFileList = argv;
            SourceFileCount = argc;

            return 1;

        }
    }

    return 0;
}

void
ProcessSourceFile( void )
{
    char *s;
    char *comment;
    char *tag;
    char *test;

    s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);

    if (s) {
        if (!strncmp( s, BUILD_VER_COMMENT, BUILD_VER_COMMENT_LENGTH )) {
            OutputVersion += atoi( s + BUILD_VER_COMMENT_LENGTH );
        }
    }

    while ( s ) {

        //
        // Check for a block with delimiters
        //

        if (NULL != MultiLineTagStart) {
            comment = strstr(s,CommentDelimiter);
            if ( comment ) {

                tag = strstr(comment,MultiLineTagStart);
                if ( tag ) {

                    //
                    // Now that we have found an opening tag, check each
                    // following line for the closing tag, and then include it
                    // in the ouput.
                    //

                    s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);
                    while ( s ) {
                        int fProcess = 1;

                        comment = strstr(s,CommentDelimiter);
                        if ( comment ) {
                            tag = strstr(comment,MultiLineTagEnd);
                            if ( tag ) {
                                goto bottom;
                            }
                            if (NULL != ExcludeLineTag &&
                                strstr(comment,ExcludeLineTag)) {
                                fProcess = 0;
                            }
                        }
                        if (fProcess) {
                            ProcessLine(s);
                        }
                        s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);
                    }

                    fprintf(stderr,
                            "HEXTRACT: %s without matching %s in %s\n",
                            MultiLineTagStart,
                            MultiLineTagEnd,
                            OutputFileName);

                    exit(1);
                }
            }
        }

        //
        // Check for a single line to output.
        //

        if (NULL != LineTag) {
            comment = strstr(s,CommentDelimiter);
            if ( comment ) {
                tag = strstr(comment,LineTag);
                if ( tag ) {
                    *comment++ = '\n';
                    *comment = '\0';
                    ProcessLine(s);
                    goto bottom;
                }
            }
        }

        bottom:
        s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);
    }
}

void
ProcessLine(
           char *s
           )
{
    char *t;
    char *s1;

    if (LineFiltering) {
        s1 = s;

        //
        // This should be replaced by a data file describing an input token
        // and an output token which would be used for the filtering.
        //

        while (t = strstr(s1,"ULONG")) {
            if (LineFiltering == 2) {
                if (!memcmp(t, "ULONGLONG", 9)) {
                    s1+=9;
                } else if (!memcmp(t, "ULONG_PTR", 9)) {
                    s1+=9;
                } else {
                    memcpy(t,"DWORD",5);
                }
            } else {
                memcpy(t,"DWORD",5);
            }
        }

        while (t = strstr(s,"UCHAR"))
            memcpy(t,"BYTE ",5);

        while (t = strstr(s,"USHORT"))
            memcpy(t,"WORD  ",6);

        while (t = strstr(s,"NTSTATUS"))
            memcpy(t,"DWORD   ",8);
    }

    fputs(s,OutputFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\charmap.h ===
/*
**  charmap.h : P0 specific, also included by charmap.c
**  it defines the mapping used to go from simple chars to these predefined
**  values. this enables the compiler to use a compact switch stmt.
**  they have been grouped in what is believed to be the most beneficial
**  way, in that most switches will be checking those values which have
**  been grouped together.
*/
#define	EOS_CHAR		'\0'	/* end of string/buffer marker char */

#define	LX_WHITE		0
#define	LX_CR			1
#define	LX_SLASH		2		/* /, /=, comment start  */
#define	LX_EOS			3
#define	LX_STAR			4		/* *, *=, comment stop  */
#define	LX_NL			5
#define	LX_BACKSLASH	6
#define	LX_SQUOTE		7
#define	LX_DQUOTE		8

#define	LX_DOT			9		/* . ... */
#define	LX_BANG			10		/* ! !=  */
#define	LX_POUND		11		/* # ##  */
#define	LX_PERCENT		12		/* % %=  */
#define	LX_EQ			13		/* = ==  */
#define	LX_HAT			14		/* ^ ^=  */
#define	LX_OR			15		/* | |= || */
#define	LX_AND			16		/* & && &= */
#define	LX_PLUS			17		/* + ++ += */
#define	LX_MINUS		18		/* - -- -= ->  */
#define	LX_LT			19		/* < << <<= <= */
#define	LX_GT			20		/* > >= >> >>= */
#define	LX_LSHIFT		21		/* << */
#define	LX_RSHIFT		22		/* >> */

#define	LX_ILL			23
#define	LX_CBRACE		24
#define	LX_CBRACK		25
#define	LX_COLON		26
#define	LX_COMMA		27
#define	LX_CPAREN		28
#define	LX_NUMBER		29
#define	LX_OBRACE		30
#define	LX_OBRACK		31
#define	LX_OPAREN		32
#define	LX_QUEST		33
#define	LX_SEMI			34
#define	LX_TILDE		35
#define	LX_MACFORMAL	36
#define	LX_STRFORMAL	37
#define LX_CHARFORMAL	38
#define	LX_NOEXPAND		39
#define	LX_ID			40
#define	LX_EACH			41

#define	LX_LEADBYTE		42
#define	LX_ASCII		43		/* to use for 'non-illegal' illegals */

#define	LX_FORMALMARK	0x1
#define	LX_FORMALSTR	0x2
#define	LX_FORMALCHAR	0x3
#define	LX_NOEXPANDMARK	0x4
#define	CONTROL_Z		0x1a
/*
**  Charmap is indexed with a character value plus the above offset
*/
#define	CHARMAP(c)		(Charmap[((UCHAR)(c))])

#define	LX_IS_IDENT(c)	(CHARMAP(c) == LX_ID)
#define	LX_IS_WHITE(c)	(CHARMAP(c) == LX_WHITE)
#define	LX_IS_NUMBER(c)	(CHARMAP(c) == LX_NUMBER)

#define LXC_BDIGIT	0x01		/* 0 - 1 */
#define	LXC_ODIGIT	0x02		/* 0 - 7 */
#define	LXC_DIGIT	0x04		/* 0 - 9 */
#define	LXC_XDIGIT	0x08		/* a-f A-F 0-9 */
#define	LXC_ID		0x10		/* continuation is part of an identifier */
#define LXC_RADIX	0x20		/* BbDdHhOoQq */
#define	LXC_WHITE	0x40		/* whitespace */
#define	LXC_SPECIAL	0x80		/* the char may have a special meaning */

#define	CONTMAP(c)	(Contmap[((UCHAR)(c))])
/*
**	LXC_IS_ID(c) : is c part of an identifier
*/
#define	LXC_IS_BDIGIT(c)	(CONTMAP(c) & LXC_BDIGIT)
#define	LXC_IS_ODIGIT(c)	(CONTMAP(c) & LXC_ODIGIT)
#define	LXC_IS_DIGIT(c)		(CONTMAP(c) & LXC_DIGIT)
#define	LXC_IS_XDIGIT(c)	(CONTMAP(c) & LXC_XDIGIT)
#define	LXC_IS_IDENT(c)		(CONTMAP(c) & LXC_ID)
#define LXC_IS_RADIX(c)		(CONTMAP(c) & LXC_RADIX)
#define LXC_IS_WHITE(c)		(CONTMAP(c) & LXC_WHITE)
#define IS_SPECIAL(c)		(CONTMAP(c) & LXC_SPECIAL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\getmsg.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* GETMSG.C - Replaces NMSGHDR.ASM and MSGS.ASM				*/
/*									*/
/* 28-Nov-90 w-BrianM  Created to remove need for MKMSG.EXE		*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "getmsg.h"

/************************************************************************/
/* GET_MSG - Given a message number, get the correct format string	*/
/************************************************************************/
char * GET_MSG (int msgnumber)
{
    int imsg = 0;
    int inum;

    while ((inum = MSG_TABLE[imsg].usmsgnum) != LASTMSG) {
	if (inum == msgnumber) {
	    return (MSG_TABLE[imsg].pmsg);
	}
	imsg ++;
    }
    return ("");
}


/************************************************************************/
/* SET_MSG - Given a format string, format it and store it in first parm*/
/************************************************************************/
void __cdecl SET_MSG (char *exp, char *fmt, ...)
{
    va_list	arg;
    char *	arg_pchar;
    int		arg_int;
    long	arg_long;
    char	arg_char;

    int base;
    int longflag;

    va_start (arg, fmt);
    while (*fmt) {
	if (*fmt == '%') {
	    longflag = FALSE;
top:
	    switch (*(fmt+1)) {
	    case 'l' :
		longflag = TRUE;
		fmt++;
		goto top;
	    case 'F' :
		fmt++;
		goto top;
	    case 's' :
		arg_pchar = va_arg(arg, char *);
		strcpy(exp, arg_pchar);
		exp += strlen(arg_pchar);
		fmt += 2;
		break;
	    case 'd' :
	    case 'x' :
		base = *(fmt+1) == 'd' ? 10 : 16;
		if (longflag) {
		    arg_long = va_arg (arg, long);
		    exp += zltoa(arg_long, exp, base);
		}
		else {
		    arg_int = va_arg (arg, int);
		    exp += zltoa((long)arg_int, exp, base);
		}
		fmt += 2;
		break;
	    case 'c' :
		arg_char = va_arg (arg, char);
		*exp++ = arg_char;
		fmt += 2;
		break;
	    default :
		*exp++ = *fmt++;
	    }
	}
	else {
	    *exp++ = *fmt++;
	}
    }
    *exp = 0;
    va_end (arg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\getflags.h ===
/*
 * the format strings may be:
 *		.*			must match exactly
 *		.*\*.*		head and tail must match, with wild card in middle
 *		.*#			head must match. tail can either be adjacent or next word
 *	at the moment '-' is not treated specialy
 *  note that 'middle' may be at either end since '.*' matches null.
 */
	
#define TAKESARG 0x20		/* tag to indicate argument or not */
#define FLAG 1				/* set the flag */
#define STRING 2|TAKESARG	/* set the string, either from here, or next word */
#define SUBSTR 3|TAKESARG	/* set single letter flags from substring */
#define NUMBER 4|TAKESARG	/* set read in the number */
#define UNFLAG 5			/* turn the flag off */
#define PSHSTR 6|TAKESARG	/* like string, but puts it on a LIST structure */
#define NOVSTR 7|TAKESARG	/* like string, but complains about overwriting */

#define NUM_ARGS		50					/* Limit of flags passed from driver to pass */
#define MSC_ENVFLAGS	"MSC_CMD_FLAGS"
		/* Environment variable flags passed in, used for getenv() */
#define PUT_MSC_ENVFLAGS	"MSC_CMD_FLAGS="	
		/* Environment variable flags passed in, used for putenv() */

/* return values from getflags */
#define R_SWITCH	1
#define R_CFILE		2
#define R_ASMFILE	3
#define R_OBJFILE	4
#define R_ERROR		5
#define R_FILE		6
#define R_EXIT		7
#define	R_FFILE		8
#define	R_PFILE		9
#define	R_AFILE		10
#define	R_OFILE		11
/* r. nevin, 1/11/85 */
#define R_HELP		12
/* b. nguyen, 4/7/86 */
#define R_HELPC	13
#define R_HELPF	14

struct cmdtab
	{
	char *format;		/* format matching string */
	char *flag;			/* pointer to what to fill in */
/*  this is really a
 *	union
 *		{
 *		char **str;
 *		int  *flag;
 *		struct subtab *sub;
 *		struct LIST *list;
 *		} cm;
 *	but you cant initialize unions so we have to fake it.
 */
	char retval;		/* crack_cmd will return whatever is here */
	UCHAR type;			/* control mask */
	};

struct subtab
	{
	int letter;
	int type;
	int *flag;
	};

#define FORT_LANG 1
#define C_LANG  2

struct Help_string{
	char *message;
	int fLanguage;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\getflags.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* GETFLAGS.C - Parse Command Line Flags				*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "rcpptype.h"
#include "getflags.h"
#include "rcppdecl.h"
#include "rcppext.h"


/************************************************************************/
/* Define function specific macros and global vars			*/
/************************************************************************/
static char	*ErrString;   /* Store string pointer in case of error */


/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
int getnumber	(char *);
int isita	(char *, char);
void substr	(struct cmdtab *, char *, int);
int tailmatch	(char *, char *);



/************************************************************************
 *	crack_cmd(table, string, func, dup)
 *		set flags determined by the string based on table.
 *		func will get the next word.
 *		if dup is set, any strings stored away will get pstrduped
 * see getflags.h for specific matching and setting operators
 *
 *  for flags which take parameters, a 'char' following the flag where 'char' is
 *  '#' : says the parameter string may be separated from the option.
 *		ie, "-M#" accepts "-Mabc" and "-M abc"
 *  '*' : says the parameter must be concatenated with the flag
 *		ie, "-A*" accepts only "-Axyz" not "-A xyz"
 *  if neither is specified a space is required between parameter and flag
 *		ie, "-o" accepts only "-o file" and not "-ofile"
 *
 * Modified by:		Dave Weil			D001
 *				recognize '-' and '/' as equivalent on MSDOS
 *
 ************************************************************************/

int crack_cmd(struct cmdtab *tab, char *string, char *(*next)(void), int _dup)
{
    register char	*format, *str;
    if (!string) {
	return(0);
    }

    ErrString = string;
    for (; tab->type; tab++)		/* for each format */ {
	format = tab->format;
	str = string;
	for (; ; )				/* scan the string */
	    switch (*format) {

 	    /*  optional space between flag and parameter  */
	    case '#':
		if ( !*str ) {
		    substr(tab, (*next)(), _dup);
		} else {
		    substr(tab, str, _dup);
		}
		return(tab->retval);
		break;

	    /*  no space allowed between flag and parameter  */
	    case '*':
		if (*str && tailmatch(format, str))
		    substr(tab, str, _dup);
		else
		    goto notmatch;
		return(tab->retval);
		break;

	    /*  space required between flag and parameter  */
	    case 0:
		if (*str) {			/*  str left, no good  */
		    goto notmatch;
		} else if (tab->type & TAKESARG) { /*  if it takes an arg  */
		    substr(tab, (*next)(), _dup);
		} else {	/*  doesn't want an arg  */
		    substr(tab, (char *)0, _dup);
		}
		return(tab->retval);
		break;
	    case '-':					/* D001 */
		    if ('-' == *str) {
			str++;				/* D001 */
			format++;			/* D001 */
			continue;			/* D001 */
		    }					/* D001 */
		    else	/* D001 */
			goto notmatch;				/* D001 */

	    default:
		if (*format++ == *str++)
		    continue;
		goto notmatch;
	    }
	/* sorry.  we need to break out two levels of loop */
notmatch:
	;
    }
    return(0);
}


/************************************************************************/
/* set the appropriate flag(s).  called only when we know we have a match */
/************************************************************************/
void substr(struct cmdtab *tab, register char *str, int _dup)
{
    register struct subtab *q;
    LIST * list;
    char	*string = str;

    switch (tab->type) {
    case FLAG:
	*(int *)(tab->flag) = 1;
	return;
    case UNFLAG:
	*(int *)(tab->flag) = 0;
	return;
    case NOVSTR:
	if (*(char **)(tab->flag)) {
	    /* before we print it out in the error message get rid of the
	     * arg specifier (e.g. #) at the end of the format.
	     */
	    string = _strdup(tab->format);
        if (!string) {
            Msg_Temp = GET_MSG (1002);
            SET_MSG (Msg_Text, Msg_Temp);
            error(1002);
            return;
        }
	    string[strlen(string)-1] = '\0';
	    Msg_Temp = GET_MSG(1046);
	    SET_MSG (Msg_Text, Msg_Temp, string,*(char **)(tab->flag),str);
	    fatal(1046);
	    return;
	}
	/* fall through */
    case STRING:
	*(char **)(tab->flag) = (_dup ? _strdup(str) : str);
	return;
    case NUMBER:
	*(int *)(tab->flag) = getnumber (str);
	return;
    case PSHSTR:
	list = (LIST * )(tab->flag);
	if (list->li_top > 0)
	    list->li_defns[--list->li_top] = (_dup ? _strdup(str) : str);
	else {
	    Msg_Temp = GET_MSG(1047);
	    SET_MSG (Msg_Text, Msg_Temp, tab->format, str);
	    fatal(1047);
	}
	return;
    case SUBSTR:
	for ( ; *str; ++str) {	/*  walk the substring  */
	    for (q = (struct subtab *)tab->flag; q->letter; q++) {
		/*
				**  for every member in the table
				*/
		if (*str == (char)q->letter)
		    switch (q->type) {
		    case FLAG:
			*(q->flag) = 1;
			goto got_letter;
		    case UNFLAG:
			*(q->flag) = 0;
			goto got_letter;
		    default:
			goto got_letter;
		    }
	    }
got_letter:
	    if (!q->letter) {
		Msg_Temp = GET_MSG(1048);
	        SET_MSG (Msg_Text, Msg_Temp, *str, ErrString);
		fatal(1048);
	    }
	}
	return;
    default:
	return;
    }
}


/************************************************************************/
/* Parse the string and return a number 0 <= x < 0xffff (64K)		*/
/************************************************************************/
int	getnumber (char *str)
{
    long	i = 0;
    char	*ptr = str;

    for (; isspace(*ptr); ptr++)
	;
    if (!isdigit(*ptr) || (((i = atol(ptr)) >= 65535) ||  i < 0)) {
	Msg_Temp = GET_MSG(1049);
	SET_MSG (Msg_Text, Msg_Temp, str);
	fatal(1049);		/* invalid numerical argument, 'str' */
    }
    return ((int) i);
}


/************************************************************************/
/*  is the letter in the string?					*/
/************************************************************************/
int isita (register char *str, register char let)
{
    if (str)
	while (*str)
	    if (*str++ == let)
		return(1);
    return(0);
}


/************************************************************************/
/* compare a tail format (as in *.c) with a string.  if there is no	*/
/* tail, anything matches.  (null strings are detected elsewhere)	*/
/* the current implementation only allows one wild card			*/
/************************************************************************/
int tailmatch (char *format, char *str)
{
    register char	*f = format;
    register char	*s = str;

    if (f[1] == 0)	/*  wild card is the last thing in the format, it matches */
	return(1);
    while (f[1])		/*  find char in front of null in format  */
	f++;
    while (s[1])		/*  find char in front of null in string to check  */
	s++;
    while (*s == *f) {	/*  check chars walking towards front */
	s--;
	f--;
    }
    /*
**  if we're back at the beginning of the format
**  and
**  the string is either at the beginning or somewhere inside
**  then we have a match.
**
**  ex format == "*.c", str == "file.c"
**	at this point *f = '*' and *s == 'e', since we've kicked out of the above
**  loop. since f==format and s>=str this is a match.
**  but if format == "*.c" and str == "file.asm" then
**  *f == 'c' and *s = 'm', f != format and no match.
*/
    return((f == format) && (s >= str));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\error.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* ERROR.C - Error Handler Routines					*/
/*									*/
/* 04-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "msgs.h"


/* defines for message types */
#define W_MSG	4000
#define E_MSG	2000
#define F_MSG	1000

static char  Errbuff[128] = {
    0};

/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
void message (int, int, char *);


/************************************************************************/
/* ERROR - Print an error message to STDOUT.				*/
/************************************************************************/
#define MAX_ERRORS 100

void error (int msgnum)
{

    message(E_MSG, msgnum, Msg_Text);
    if (++Nerrors > MAX_ERRORS) {
	Msg_Temp = GET_MSG (1003);
	SET_MSG (Msg_Text, Msg_Temp, MAX_ERRORS);
 	fatal(1003);		/* die - too many errors */
    } 
    return;
}


/************************************************************************/
/* FATAL - Print an error message to STDOUT and exit.			*/
/************************************************************************/
void fatal (int msgnum)
{
    message(F_MSG, msgnum, Msg_Text);
    exit(++Nerrors);
}


/************************************************************************/
/* WARNING - Print an error message to STDOUT.				*/
/************************************************************************/
void warning (int msgnum)
{
    message(W_MSG, msgnum, Msg_Text);
}


/************************************************************************/
/* MESSAGE - format and print the message to STDERR.			*/
/* The msg goes out in the form :					*/
/*     <file>(<line>) : <msgtype> <errnum> <expanded msg>		*/
/************************************************************************/
void message(int msgtype, int msgnum, char *msg)
{
    char  mbuff[512];
    register char *p = mbuff;
    register char *msgname;
    char msgnumstr[32];

    if (Linenumber > 0 && Filename) {
	SET_MSG (p, "%s(%d) : ", Filename, Linenumber);
	p += strlen(p);
    }
    if (msgtype) {
	switch (msgtype)
	{
	case W_MSG:
	    msgname = GET_MSG(MSG_WARN);
	    break;
	case E_MSG:
	    msgname = GET_MSG(MSG_ERROR);
	    break;
	case F_MSG:
	    msgname = GET_MSG(MSG_FATAL);
	    break;
	}
	strcpy(p, msgname);
	p += strlen(msgname);
	SET_MSG(msgnumstr, " %s%d: ", "RC", msgnum);
	strcpy(p, msgnumstr);
	p += strlen(msgnumstr);
	strcpy(p, msg);
	p += strlen(p);
    }
    fwrite(mbuff, strlen(mbuff), 1, stderr);
    fwrite("\n", 1, 1, stderr);
    if (Srclist && Errfl) {

	/* emit messages to error il file too */

	fwrite(mbuff, strlen(mbuff), 1, Errfl);
	fwrite("\n", 1, 1, Errfl);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\globals.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* GLOBALS.C - Global variable definitions				*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include "rcpptype.h"
#include "rcppext.h"
#include "grammar.h"

/* shared strings */
char 	Union_str[] = "union";
char 	Struct_str[] = "struct";
char 	Cdecl_str[] = "cdecl";
char 	Cdecl1_str[] = "cdecl ";
char 	Fortran_str[] = "fortran";
char 	Fortran1_str[] = "fortran ";
char 	Pascal_str[] = "pascal";
char 	Pascal1_str[] = "pascal ";
char 	PPelse_str[] = "#else";
char 	PPendif_str[] = "#endif";
char 	PPifel_str[] = "#if/#elif";
char 	Syntax_str[] = "syntax error";


FILE	*ErrFile;		/* file containing error messages */
FILE	*Errfl;			/* files errors written to */
FILE	*OUTPUTFILE;		/* File for output of program */

char	*A_string;				/* model encoding */
char	*Debug;					/* debugging switches */
char	*Input_file;			/* the input .rc file */
char	*Output_file;			/* the output .res file */
char	*Q_string;				/* hardware characteristics */
char	*Version;
char    *gpszNLSoptions;        
int		In_alloc_text;
int		Bad_pragma;
int		Cross_compile;			/* is this a cross compile ? */
int		Ehxtension;				/* near/far keywords, but no huge */
int		HugeModel;				/* Huge Model program ?? */
int		Inteltypes;				/* using strict Intel types or not */
int		Nerrors;
int		NoPasFor;				/* no fortran/pascal keywords ? */
int		Out_funcdef;			/* output function definitions */
int		Plm;					/* non-C calling sequence */
int		Prep;					/* preprocess */
int		Srclist;				/* put msgs to il file if source listing */

int		Cmd_intrinsic;			/* implicit intrinsics */
int		Cmd_loop_opt;
int		Cmd_pointer_check;

int		Symbolic_debug;			/* Whether to put out dbil info or not */
int		Cflag;					/* leave in comments */
int 	Eflag;					/* insert #line */
int		Jflag;					/* no Kanji */
int		Pflag;					/* no #line */
int		Rflag;					/* mkhives - no exponent missing error */
int		ZcFlag;					/* case insensitive compare */
int		In_define;
int		InInclude;
int		InIf;
int		Macro_depth;
int		Linenumber;

UCHAR	Reuse_1[BIG_BUFFER];
UCHAR	Filebuff[MED_BUFFER+1];
UCHAR	Macro_buffer[BIG_BUFFER * 4];

token_t	Basic_token = L_NOTOKEN;
LIST	Defs = {MAXLIST};			/* -D list */
LIST	Includes = {MAXLIST, {0}};	/* for include file names */
char	*Path_chars = "/";			/* path delimiter chars */
char	*ErrFilName = "c1.err";		/* error message file name */
char	*Basename = "";				/* base IL file name */
char	*Filename = Filebuff;
int		Char_align = 1;				/* alignment of chars in structs */
int		Cmd_stack_check = TRUE;
int		Stack_check = TRUE;
int		Prep_ifstack = -1;
int		Switch_check = TRUE;
int		Load_ds_with;
int		Plmn;
int		Plmf;
int		On_pound_line;
int		Listing_value;
hash_t	Reuse_1_hash;
UINT Reuse_1_length;
token_t	Currtok = L_NOTOKEN;

int		Extension = TRUE;			/* near/far keywords? */
int		Cmd_pack_size = 2;
int		Pack_size = 2;

lextype_t yylval;

/*** I/O Variable for PreProcessor ***/
ptext_t	Current_char;

/*** w-BrianM - Re-write of fatal(), error() ***/
char 	Msg_Text[MSG_BUFF_SIZE];
char *	Msg_Temp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\getmsg.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* GETMSG.H - Include File for the message return function		*/
/*									*/
/* 28-Nov-90 w-BrianM	Created to replace need for MKMSG.EXE		*/
/*									*/
/************************************************************************/

/************************************************************************/
/****								     ****/
/**** NOTE - All changes in this file MUST be duplicated in MSGS.H!  ****/
/****								     ****/
/************************************************************************/

#include "msgs.h"

#define LASTMSG	-1

struct msgtable {
	int	usmsgnum;
	char * pmsg;
} MSG_TABLE[] = {

	/****************************************************************/
	/* Messages							*/
	/****************************************************************/

	{MSG_LEFT,	     "left"},
	{MSG_RIGHT,	     "right"},
	{MSG_UC_UNNAMED,     "UNNAMED"},
	{MSG_LC_UNNAMED,     "<unnamed>"},
	{MSG_COMMA,	     "trailing ',' used for variable argument list"},
	{MSG_CAST_LVAL,      "cast on lvalue"},
	{MSG_EXT_INIT,	     "extended initializer form"},
	{MSG_TYPEDEF,	     "benign typedef redefinition"},
	{MSG_EXT_REDEF,	     "redefined extern to static"},
	{MSG_MAC_FORMALS,    "macro formals in strings"},
	{MSG_NO_SEMI,	     "missing ';' following last struct/union member"},
	{MSG_BITFIELDS,	     "bitfield types other than int"},
	{MSG_WARN,	     "warning"},
	{MSG_ERROR,	     "error"},
	{MSG_FATAL,          "fatal error"},
	{MSG_BLOCK_FUNCDECL, "function given file scope"},
	{MSG_CASTTO_FUNC,    "cast of data pointer to function pointer"},
	{MSG_CASTTO_NONFUNC, "cast of function pointer to data pointer"},
	{MSG_ELLIPSIS,	     "function declaration used ellipsis"},
	{MSG_TOLEVEL0,	     "used function declaration from a previous block"},

	/****************************************************************/
	/* Fatals							*/
	/****************************************************************/

	{1001,	"Internal Compiler Error\n\t\t(compiler file '%s', line %d)\n\t\tPlease report this error to your local dealer"},
	{1002,	"out of heap space"},
	{1003,	"error count exceeds %d; stopping compilation"},
	{1004,	"unexpected EOF"},
	{1005,	"string too big for buffer"},
	{1006,	"write error on compiler intermediate file"},
	{1007,	"unrecognized flag '%s' in '%s'"},
	{1008,	"no input file specified"},
	{1009,	"compiler limit : macros too deeply nested"},
	{1010,	"compiler limit : macro expansion too big"},
	{1011,  "no output file specified"},
	{1012,	"bad parenthesis nesting - missing '%c'"},
	{1013,	"cannot open source file '%s'"},
	{1014,	"too many include files"},
	{1015,	"cannot open include file '%s'"},
	{1016,	"#if[n]def expected an identifier"},
	{1017,	"invalid integer constant expression"},
	{1018,	"unexpected '#elif'"},
	{1019,	"unexpected '#else'"},
	{1020,	"unexpected '#endif'"},
	{1021,	"bad preprocessor command '%s'"},
	{1022,	"expected '#endif'"},
	{1023,	"Could not open output file"},
	{1026,	"parser stack overflow, please simplify your program"},
	{1027,	"DGROUP data allocation exceeds 64K"	/* QC, c23 */},
	{1028,	"%s segment allocation exceeds 64K"	/* QC */},
	{1031,	"compiler limit : function calls too deeply nested"	/* QC, c23 */},
	{1032,	"cannot open object listing file '%s'"			/* QC, c23 */},
	{1035,	"expression too complex, please simplify"		/* QC, c23 */},
	{1037,	"cannot open object file '%s'"					/* QC, c23 */},
	{1041,	"cannot open compiler intermediate file - no more files"},
	{1042,	"cannot open compiler intermediate file - no such file or directory"},
	{1043,	"cannot open compiler intermediate file"},
	{1044,	"out of disk space for compiler intermediate file"},
	{1045,	"floating point overflow"},
	{1047,	"too many %s flags, '%s'"},
	{1048,	"unknown option '%c' in '%s'"},
	{1049,	"invalid numerical argument '%s'"},
	{1052,	"too many #if/#ifdef's"},
	{1053,	"compiler limit : struct/union nesting"},
	{1054,	"compiler limit : initializers too deeply nested"},
	{1055,	"compiler limit : out of keys"},
	{1056,	"compiler limit : out of macro expansion space"},
	{1057,	"unexpected EOF in macro expansion (missing ')'?)"},
	{1059,	"out of near heap space"},
	{1060,	"out of far heap space"},
	{1061,	"compiler limit : blocks too deeply nested"	/* QC */},
	{1062,	"error writing to preprocessor output file"},
	{1063,	"compiler limit : compiler stack overflow"	/* QC */},
	{1065,	"compiler limit : '%s': macro definition too big"},
	{1067,	"compiler limit : identifier overflowed internal buffer"},
	{1068,	"compiler error : possible binary file for input"},
	{1000,	"UNKNOWN FATAL ERROR\n\t\tPlease report this error to your local dealer"},

	/****************************************************************/
	/* Errors							*/
	/****************************************************************/

	{2001,	"newline in constant"},
	{2003,	"expected 'defined id'"},
	{2004,	"expected 'defined(id)'"},
	{2005,	"#line expected a line number, found '%s'"},
	{2006,	"#include expected a file name, found '%s'"},
	{2007,	"#define syntax"},
	{2008,	"'%c' : unexpected in macro definition"},
	{2009,	"reuse of macro formal '%s'"},
	{2010,	"'%c' : unexpected in formal list"},
	{2012,	"missing name following '<'"},
	{2013,	"missing '>'"},
	{2014,	"preprocessor command must start as first non-whitespace"},
	{2015,	"too many chars in constant"},
	{2016,	"no closing single quote"},
	{2017,	"illegal escape sequence"},
	{2018,	"unknown character '0x%x'"},
	{2019,	"expected preprocessor command, found '%c'"},
	{2020,	"illegal digit '%c' for base %d"},
	{2021,	"expected exponent value, not '%c'"},
	{2022,	"'%ld' : too big for char"},
	{2023,	"divide by 0"},
	{2024,	"mod by 0"},
	{2025,	"'%s' : enum/struct/union type redefinition"},
	{2026,	"'%s' : member of enum redefinition"},
	{2028,	"struct/union member needs to be inside a struct/union"},
	{2029,	"'%Fs' : bit-fields only allowed in structs"},
	{2030,	"'%Fs' : struct/union member redefinition"},
	{2031,	"'%Fs' : function cannot be struct/union member"},
	{2033,	"'%Fs' : bit-field cannot have indirection"},
	{2034,	"'%Fs' : bit-field type too small for number of bits"},
	{2035,	"struct/union '%Fs' : unknown size"},
	{2036,	"left of '%s%s' must have a struct/union type"},
	{2037,	"left of '%s' specifies undefined struct/union '%Fs'"},
	{2038,	"'%s' : not struct/union member"},
	{2039,	"'->' requires struct/union pointer"},
	{2040,	"'.' requires struct/union name"},
	{2042,	"signed/unsigned keywords mutually exclusive"},
	{2043,	"illegal break"},
	{2044,	"illegal continue"},
	{2045,	"'%s' : label redefined"},
	{2046,	"illegal case"},
	{2047,	"illegal default"},
	{2048,	"more than one default"},
	{2050,	"non-integral switch expression"},
	{2051,	"case expression not constant"},
	{2052,	"case expression not integral"},
	{2053,	"case value %d already used"},
	{2054,	"expected '(' to follow '%Fs'"},
	{2055,	"expected formal parameter list, not a type list"},
	{2056,	"illegal expression"},
	{2057,	"expected constant expression"},
	{2058,	"constant expression is not integral"},
	{2059,	"syntax error : '%s'"},
	{2060,	"syntax error : EOF"},
	{2061,	"syntax error : identifier '%s'"},
	{2062,	"type '%s' unexpected"},
	{2063,	"'%s' : not a function"},
	{2064,	"term does not evaluate to a function"},
	{2065,	"'%s' : undefined"},
	{2066,	"cast to function returning . . . is illegal"},
	{2067,	"cast to array type is illegal"},
	{2068,	"illegal cast"},
	{2069,	"cast of 'void' term to non-void"},
	{2070,	"'%Fs' : storage class must be 'extern'"},
	{2071,	"'%Fs' : bad storage class"},
	{2072,	"'%Fs' : initialization of a function"},
	{2075,	"'%Fs' : array initialization needs curly braces"},
	{2076,	"'%Fs' : struct/union initialization needs curly braces"},
	{2077,	"non-scalar field initializer '%Fs'"},
	{2078,	"too many initializers"},
	{2079,	"'%Fs' uses undefined struct/union '%Fs'"},
	{2082,	"redefinition of formal parameter '%Fs'"},
	{2084,	"function '%Fs' already has a body"},
	{2085,	"'%Fs' : not in formal parameter list"},
	{2086,	"'%Fs' : redefinition"},
	{2087,	"'%Fs' : missing subscript"},
	{2088,	"use of undefined enum/struct/union '%Fs'"},
	{2090,	"function returns array"},
	{2091,	"function returns function"},
	{2092,	"array element type cannot be function"},
	{2093,	"cannot initialize a static or struct with address of automatic vars"},
	{2094,	"label '%Fs' was undefined"},
	{2095,	"'%Fs' : actual has type 'void' : parameter %d"},
	{2096,	"struct/union comparison illegal"},
	{2097,	"illegal initialization"},
	{2098,	"non-address expression"},
	{2099,	"non-constant offset"},
	{2100,	"illegal indirection"},
	{2101,	"'&' on constant"},
	{2102,	"'&' requires lvalue"},
	{2103,	"'&' on register variable"},
	{2104,	"'&' on bit-field ignored"},
	{2105,	"'%s' needs lvalue"},
	{2106,	"'%s' : left operand must be lvalue"},
	{2107,	"illegal index, indirection not allowed"},
	{2108,	"non-integral index"},
	{2109,	"subscript on non-array"},
	{2110,	"'+' : 2 pointers"},
	{2111,	"pointer + non-integral value"},
	{2112,	"illegal pointer subtraction"},
	{2113,	"'-' : right operand pointer"},
	{2114,	"'%s' : pointer on left; needs integral right"},
	{2115,	"'%s' : incompatible types"},
	{2116,	"'%s' : bad %s operand"},
	{2117,	"'%s' : illegal for struct/union"},
	{2118,	"negative subscript"},
	{2119,	"'typedefs' both define indirection"},
	{2120,	"'void' illegal with all types"},
	{2125,	"%Fs : allocation exceeds 64K"		/* QC, c23 */},
	{2126,	"%Fs : auto allocation exceeds %s"	/* QC, c23 */},
	{2127,	"parameter allocation exceeds 32K"	/* QC, c23 */},
	{2130,	"#line expected a string containing the file name, found '%s'"},
	{2131,	"attributes specify more than one near/far/huge"},
	{2132,	"syntax error : unexpected identifier"},
	{2133,	"'%Fs' : unknown size"},
	{2134,	"'%Fs' : struct/union too large"},
	{2137,	"empty character constant"},
	{2138,	"unmatched close comment '*/'"},
	{2139,	"type following '%s' is illegal"},
	{2140,	"argument type cannot be function returning . . ."},
	{2141,	"value out of range for enum constant"},
	{2142,	"ellipsis requires three periods"},
	{2143,	"syntax error : missing '%s' before '%s'"},
	{2144,	"syntax error : missing '%s' before type '%Fs'"},
	{2145,	"syntax error : missing '%s' before identifier"},
	{2146,	"syntax error : missing '%s' before identifier '%s'"},
	{2147,	"unknown size"},
	{2148,	"array too large"},
	{2149,	"'%Fs' : named bit-field cannot have 0 width"},
	{2150,	"'%Fs' : bit-field must have type int, signed int, or unsigned int"},
	{2151,	"more than one cdecl/fortran/pascal attribute specified"},
	{2152,	"'%s' : pointers to functions with different attributes"},
	{2153,	"hex constants must have at least 1 hex digit"},
	{2154,	"'%s' : does not refer to a segment name"},
	{2155,	"'%s' : already in a segment"},
	{2156,	"pragma must be at outer level"},
	{2157,	"'%s' : must be declared before use in pragma list"},
	{2158,	"'%s' : is a function"},
	{2159,	"more than one storage class specified"},
	{2160,	"## cannot occur at the beginning of a macro definition"},
	{2161,	"## cannot occur at the end of a macro definition"},
	{2162,	"expected macro formal parameter"},
	{2163,	"'%s' : not available as an intrinsic"},
	{2164,	"'%s' : intrinsic was not declared"},
	{2165,	"'%s' : cannot modify pointers to data"},
	{2166,	"lval specifies 'const' object"},
	{2167,	"'%Fs' : too many actual parameters for intrinsic"},
	{2168,	"'%Fs' : too few actual parameters for intrinsic"},
	{2169,	"'%Fs' : is an intrinsic, it cannot be defined"},
	{2170,	"'%s' : intrinsic not declared as a function"},
	{2171,	"'%s' : bad operand"},
	{2172,	"'%Fs' : actual is not a pointer : parameter %d"},
	{2173,	"'%Fs' : actual is not a pointer : parameter %d, parameter list %d"},
	{2174,	"'%Fs' : actual has type 'void' : parameter %d, parameter list %d"},
	{2175,	"'%Fs' : unresolved external"	/* QC */},
	{2176,	"static far data not supported"	/* QC */},
	{2177,	"constant too big"},
	{2178,	"'%s' : storage class for same_seg variables must be 'extern'"},
	{2179,	"'%Fs' : was used in same_seg, but storage class is no longer 'extern'"},
	{2180,	"controlling expression has type 'void'"},
	{2181,	"pragma requires command line option '%s'"	/* QC */},
	{2182,	"'%Fs' : has type 'void'"},
	{2183,	"'interrupt' function must be 'far'"},
	{2184,	"'%s' function cannot be 'pascal/fortran'"},
	{2186,	"'saveregs/interrupt' modifiers mutually exclusive"},
	{2187,	"cast of near function pointer to far function pointer"},
	{2188,	"#error : %s"},
	{2190,	"'%s' : is a text segment"},
	{2191,	"'%s' : is a data segment"},
	{2198,	"'%Fs' : tried to be allocated in code segment '%Fs'"},
	{2199,	"'%Fs' : tried to be allocated in data segment '%Fs'"},
	{2200,	"'%Fs' : function has already been defined"},
	{2205,	"'%Fs' : cannot initialize 'extern' block scoped variables"},
	{2400,	"inline syntax error %s, found '%Fs'"},
	{2401,	"'%s' : register must be base %s"},
	{2402,	"'%s' : register must be index %s"},
	{2403,	"'%s' : register must be base/index %s"},
	{2404,	"'%s' : illegal register %s"},
	{2405,	"illegal short forward reference with offset"},
	{2406,	"'%s' : name undefined %s"},
	{2407,	"illegal float register %s"},
	{2408,	"illegal type on PTR operator %s"},
	{2409,	"illegal type used as operator %s"},
	{2410,	"'%s' : ambiguous member name %s"},
	{2411,	"'%s' : illegal struct/union member %s"},
	{2412,	"'%s' : label redefined"},
	{2413,	"'%s' : illegal align size"},
	{2414,	"illegal number of operands"},
	{2415,	"improper operand type"},
	{2416,	"'%s' : illegal opcode for processor"},
	{2417,	"divide by zero %s"},
	{2419,	"mod by zero %s"},
	{2420,	"'%s' : illegal symbol %s"},
	{2421,	"PTR operator used with register %s"},
	{2422,	"illegal segment override %s"},
	{2424,	"'%s' : improper expression %s"},
	{2425,	"'%s' : non-constant expression %s"},
	{2426,	"'%s' : illegal operator %s"},
	{2427,	"'%Fs' : jump referencing label is out of range"			/* QC */},
	{2428,	"_asm not implemented"},
	{2000,	"UNKNOWN ERROR\n\t\tPlease report this error to your local dealer"},
	/****************************************************************/
	/* Warnings							*/
	/****************************************************************/

	{4002,	"too many actual parameters for macro '%s'"},
	{4003,	"not enough actual parameters for macro '%s'"},
	{4004,	"missing close parenthesis after 'defined'"},
	{4005,	"'%s' : redefinition"},
	{4006,	"#undef expected an identifier"},
	{4009,	"string too big, trailing chars truncated"},
	{4011,	"identifier truncated to '%s'"},
	{4012,	"float constant in a cross compilation"},
	{4014,	"'%Fs' : bit-field type must be unsigned"},
	{4015,	"'%Fs' : bit-field type must be integral"},
	{4016,	"'%s' : no function return type, using 'int' as default"},
	{4017,	"cast of int expression to far pointer"},
	{4020,	"'%Fs' : too many actual parameters"},
	{4021,	"'%Fs' : too few actual parameters"},
	{4022,	"'%Fs' : pointer mismatch : parameter %d"},
	{4024,	"'%Fs' : different types : parameter %d"},
	{4026,	"function was declared with formal argument list"},
	{4027,	"function was declared without formal argument list"},
	{4028,	"parameter %d declaration different"},
	{4029,	"declared parameter list different from definition"},
	{4030,	"first parameter list is longer than the second"},
	{4031,	"second parameter list is longer than the first"},
	{4032,	"unnamed struct/union as parameter"},
	{4033,	"function must return a value"},
	{4034,	"sizeof returns 0"},
	{4035,	"'%Fs' : no return value"},
	{4037,	"'%Fs' : formal parameters ignored"},
	{4038,	"'%Fs' : formal parameter has bad storage class"},
	{4039,	"'%Fs' : function used as an argument"},
	{4040,	"near/far/huge on '%Fs' ignored"},
	{4042,	"'%Fs' : has bad storage class"},
	{4044,	"huge on '%Fs' ignored, must be an array"},
	{4045,	"'%s' : array bounds overflow"},
	{4046,	"'&' on function/array, ignored"},
	{4047,	"'%s' : different levels of indirection"},
	{4048,	"array's declared subscripts different"},
	{4049,	"'%s' : indirection to different types"},
	{4051,	"data conversion"},
	{4053,	"at least one void operand"},
	{4058,	"address of frame variable taken, DS != SS"	/* QC, c23 */},
	{4060,	"conversion of long address to short address"	/* QC, c23 */},
	{4061,	"long/short mismatch in argument : conversion supplied"	/* QC, c23 */},
	{4062,	"near/far mismatch in argument : conversion supplied"	/* QC, c23 */},
	{4067,	"unexpected characters following '%s' directive - newline expected"},
	{4068,	"unknown pragma"},
	{4071,	"'%Fs' : no function prototype given"},
	{4074,	"non standard extension used - '%s'"},
	{4075,	"size of switch expression or case constant too large - converted to int"},
	{4076,	"'%s' : may be used on integral types only"},
	{4077,	"unknown check_stack option"},
	{4079,	"unexpected token '%s'"},
	{4080,	"expected 'identifier' for segment name, found '%s'"},
	{4081,	"expected a comma, found '%s'"},
	{4082,	"expected an identifier, found '%s'"},
	{4083,	"expected '(', found '%s'"},
	{4084,	"expected a pragma keyword, found '%s'"},
	{4085,	"expected [on | off]"},
	{4086,	"expected [1 | 2 | 4]"},
	{4087,	"'%Fs' : declared with 'void' parameter list"},
	{4088,	"'%Fs' : pointer mismatch : parameter %d, parameter list %d"},
	{4089,	"'%Fs' : different types : parameter %d, parameter list %d"},
	{4090,	"different 'const' attributes"},
	{4091,	"no symbols were declared"},
	{4092,	"untagged enum/struct/union declared no symbols"},
	{4093,	"unescaped newline in character constant in non-active code"},
	{4095,	"expected ')', found '%s'"},
	{4098,	"void function returning a value"},
	{4100,	"'%Fs' : unreferenced formal parameter"},
	{4101,	"'%Fs' : unreferenced local variable"},
	{4102,	"'%Fs' : unreferenced label"},
	{4104,	"'%s' : near data in same_seg pragma, ignored"},
	{4105,	"'%Fs' : code modifiers only on function or pointer to function"},
	{4106,	"pragma requires integer between 1 and 127"},
	{4107,	"pragma requires integer between 15 and 255"},
	{4108,	"pragma requires integer between 79 and 132"},
	{4109,	"unexpected identifier '%s'"},
	{4110,	"unexpected token 'int constant'"},
	{4111,	"unexpected token 'string'"},
	{4112,	"macro name '%s' is reserved, %s ignored"},
	{4113,	"function parameter lists differed"},
	{4114,	"same type qualifier used more than once"},
	{4115,	"'%Fs' : type definition in formal parameter list"},
	{4116,	"<no tag> : type definition in formal parameter list"},
	{4118,	"pragma not supported"},
	{4401,	"'%s' : member is bitfield"},
	{4402,	"must use PTR operator"},
	{4403,	"illegal PTR operator"},
	{4404,	"period on directive ignored"},
	{4405,	"'%s' : identifier is reserved word"},
	{4406,	"operand on directive ignored"},
	{4407,	"operand size conflict"},
	{4408,	"'%s' : ambiguous label"},
	{4409,	"illegal instruction size"},
	{4410,	"illegal size for operand"},
	{4411,	"'%s' : symbol resolves to displacement register"},
	{4412,	"'%s' : identifier is also assembler mnemonic"},
	{4413,	"Cannot determine file type for '%s' : assuming 8-bit ascii"},
	{4000,	"UNKNOWN WARNING\n\t\tPlease report this error to your local dealer"},
	{LASTMSG, ""}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\grammar.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* GRAMMAR.H - Grammar definitions for terminals			*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#define	L_NOTOKEN	1
#define	L_IDENT		2
#define	L_STRING	3
#define	L_CFLOAT	4
#define	L_CDOUBLE	5
#define	L_CLDOUBLE	6
#define	L_CINTEGER	7
#define	L_LONGINT	8
#define	L_CUNSIGNED	9
#define	L_LONGUNSIGNED	10
#define	L_AUTO		11
#define	L_STATIC	12
#define	L_EXTERN	13
#define	L_REGISTER	14
#define	L_TYPEDEF	15
#define	L_FORTRAN	16
#define	L_PASCAL	17
#define	L_C		18
#define	L_INTERRUPT	19
#define	L_SAVEREGS	20
#define	L_LOADDS	21
#define	L_EXPORT	22
#define	L_ASM		23
#define	L_NEAR		24
#define	L_FAR		25
#define	L_HUGE		26
#define	L_CONST		27
#define	L_VOLATILE	28
#define	L_CHAR		29
#define	L_INT		30
#define	L_FLOAT		31
#define	L_DOUBLE	32
#define	L_SHORT		33
#define	L_LONG		34
#define	L_VOID		35
#define	L_SIGNED	36
#define	L_UNSIGNED	37
#define	L_ENUM		38
#define	L_ENUM_TAG	39
#define	L_STRUCT	40
#define	L_STRUCT_TAG	41
#define	L_UNION		42
#define	L_UNION_TAG	43
#define	L_AND		44
#define	L_ANDAND	45
#define	L_ANDEQ		46
#define	L_ASSIGN	47
#define	L_BIT		48
#define	L_COLON		49
#define	L_COMMA		50
#define	L_DECR		51
#define	L_DIV		52
#define	L_DIVEQ		53
#define	L_EQUALS	54
#define	L_EXCLAIM	55
#define	L_EXTRACT	56
#define	L_GT		57
#define	L_GTEQ		58
#define	L_INCR		59
#define	L_LBRACK	60
#define	L_LSHFTEQ	61
#define	L_LSHIFT	62
#define	L_LT		63
#define	L_LTEQ		64
#define	L_MINUS		65
#define	L_MINUSEQ	66
#define	L_MOD		67
#define	L_MODEQ		68
#define	L_MULT		69
#define	L_MULTEQ	70
#define	L_NOTEQ		71
#define	L_OR		72
#define	L_OREQ		73
#define	L_OROR		74
#define	L_PERIOD	75
#define	L_PLUS		76
#define	L_PLUSEQ	77
#define	L_POINTSTO	78
#define	L_PREDECR	79
#define	L_PREINCR	80
#define	L_QUEST		81
#define	L_RSHFTEQ	82
#define	L_RSHIFT	83
#define	L_TILDE		84
#define	L_UMINUS	85
#define	L_XOR		86
#define	L_XOREQ		87
#define	L_ARG		88
#define	L_ASOP		89
#define	L_BREAK		90
#define	L_CASE		91
#define	L_CAST		92
#define	L_CLASS		93
#define	L_CONSTANT	94
#define	L_CONTINUE	95
#define	L_DEFAULT	96
#define	L_DIVOP		97
#define	L_DO		98
#define	L_ELLIPSIS	99
#define	L_ELSE		100
#define	L_ENTRY		101
#define	L_EOF		102
#define	L_EQUOP		103
#define	L_FILE		104
#define	L_FOR		105
#define	L_FUNCTION	106
#define	L_GOTO		107
#define	L_IF		108
#define	L_INCOP		109
#define	L_INIT		110
#define	L_LCURLY	111
#define	L_LINE		112
#define	L_LPAREN	113
#define	L_INTRINSIC	114
#define	L_MODIFIER	115
#define	L_MODULE	116
#define	L_RBRACK	117
#define	L_RCURLY	118
#define	L_RELOP		119
#define	L_RETURN	120
#define	L_RPAREN	121
#define	L_SELF		122
#define	L_SEMI		123
#define	L_SHIFTOP	124
#define	L_SIZEOF	125
#define	L_STUNOP	126
#define	L_SW		127
#define	L_SWEXP		128
#define	L_TYPE		129
#define	L_TYPENAME	130
#define	L_UPLUS		131
#define	L_WHILE		132
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\ltoa.c ===
/* Long to ASCII conversion routine - used by print, and those programs
 * which want to do low level formatted output without hauling in a great
 * deal of extraneous code.  This will convert a long value to an ascii
 * string in any radix from 2 - 16.
 * RETURNS - the number of characters in the converted buffer.
 */

static char digits[] = {
	'0', '1', '2', '3', '4',
	'5', '6', '7', '8', '9',
	'a', 'b', 'c', 'd', 'e', 'f'
	};

#define BITS_IN_LONG  (8*sizeof(long))

int zltoa(long aval, register char *buf, int base)
	{
	/*
	 * if unsigned long wont work on your host, you will probably have
	 * to use signed long and accept this as not working for negative
	 * numbers.
	 */
	register unsigned long val;
	register char *p;
	char tbuf[BITS_IN_LONG];
	int size = 0;

	p = tbuf;
	*p++ = '\0';
	if (aval < 0 && base == 10)
		{
		*buf++ = '-';
		val = -aval;
		size++;
		}
	else
		val = aval;
	do {
		*p++ = digits[val % base];
		}
	while (val /= base);
	while ((*buf++ = *--p) != 0)
		++size;
	return(size);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\msgs.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* MAIN.C - Main Program						*/
/*									*/
/* 28-Nov-90 w-BrianM  Created to remove the need for MKMSG.EXE		*/
/*									*/
/************************************************************************/

/************************************************************************/
/****							             ****/
/**** NOTE - All changees in this file must be duplicated in GETMSG.H****/
/****							             ****/
/************************************************************************/


#define	MSG_LEFT		301
#define	MSG_RIGHT		302
#define	MSG_UC_UNNAMED		303
#define	MSG_LC_UNNAMED		304
#define	MSG_COMMA		305
#define	MSG_CAST_LVAL		306
#define	MSG_EXT_INIT		307
#define	MSG_TYPEDEF		308
#define	MSG_EXT_REDEF		309
#define	MSG_MAC_FORMALS		310
#define	MSG_NO_SEMI		311
#define	MSG_BITFIELDS		312
#define	MSG_WARN		313
#define	MSG_ERROR		314
#define	MSG_FATAL		315
#define	MSG_BLOCK_FUNCDECL	316
#define	MSG_CASTTO_FUNC		317
#define	MSG_CASTTO_NONFUNC	318
#define	MSG_ELLIPSIS		320
#define	MSG_TOLEVEL0		321
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\p0expr.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0EXPR.C - Expression routines for Pre-Processor			*/
/*									*/
/* AUTHOR - Ralph Ryan, Sept. 16, 1982					*/
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/
/*
 * DESCRIPTION  
 *	Evaluate the constant expression.  Since these routines are
 *	all recursively coupled, it is clearer NOT to document them
 *	with the standard header.  Instead, BML (British Meta Language, 
 *	a BNF like meta language) will be given for each "production" 
 *	of this recursive descent parser.
 *
 * Note - Sure, yeah, right. Frankly, I'm frightened! (w-BrianM)
 ************************************************************************/

#include <stdio.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "grammar.h"

/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
long and(void);
long andif(void);
long constant(void);
long constexpr(void);
long eqset(void);
long mult(void);
long or(void);
long orelse(void);
long plus(void);
long prim(void);
long relation(void);
long shift(void);
long xor(void);


/************************************************************************/
/* File Global Variables						*/
/************************************************************************/
long	Currval = 0;
static	int		Parencnt = 0;


/************************************************************************/
/* do_constexpr()							*/
/************************************************************************/
long do_constexpr(void)
{
    REG long	val;

    Parencnt = 0;
    Currtok = L_NOTOKEN;
    val = constexpr();
    if( Currtok == L_RPAREN ) {
	if( Parencnt-- == 0 ) {
	    Msg_Temp = GET_MSG(1012);
	    SET_MSG (Msg_Text, Msg_Temp, "(");
	    fatal(1012);		/* missing left paren */
	}
    }
    else if( Currtok != L_NOTOKEN ) {
	Msg_Temp = GET_MSG(4067);
	SET_MSG (Msg_Text, Msg_Temp, PPifel_str);
	warning(4067);
    }
    if( Parencnt > 0 ) {
	Msg_Temp = GET_MSG(4012);
	SET_MSG (Msg_Text, Msg_Temp, ")");
	fatal(4012);	/* missing right paren */
    }
    return(val);
}

/************************************************************************/
/* constexpr ::= orelse [ '?' orelse ':' orelse ];			*/
/************************************************************************/
long constexpr(void)
{
    REG long		val;
    REG long		val1;
    long		val2;

    val = orelse();
    if( nextis(L_QUEST) ) {
	val1 = orelse();
	if( nextis(L_COLON) )
	    val2 = orelse();
	return(val ? val1 : val2);
    }
    return(val);
}


/************************************************************************/
/* orelse ::= andif [ '||' andif ]* ;					*/
/************************************************************************/
long orelse(void)
{
    REG long val;

    val = andif();
    while(nextis(L_OROR))
	val = andif() || val;
    return(val);
}


/************************************************************************/
/* andif ::= or [ '&&' or ]* ;						*/
/************************************************************************/
long	  andif(void)
{
    REG	long val;

    val = or();
    while(nextis(L_ANDAND))
	val = or() && val;
    return(val);
}


/************************************************************************/
/* or ::= xor [ '|' xor]* ;						*/
/************************************************************************/
long or(void)
{
    REG	long val;

    val = xor();
    while( nextis(L_OR) )
	val |= xor();
    return(val);
}


/************************************************************************/
/* xor ::= and [ '^' and]* ;						*/
/************************************************************************/
long	  xor(void)
{
    REG	long val;

    val = and();
    while( nextis(L_XOR) )
	val ^= and();
    return(val);
}


/************************************************************************/
/*  and ::= eqset [ '&' eqset]* ;					*/
/************************************************************************/
long and(void)
{
    REG	long val;

    val = eqset();
    while( nextis(L_AND) )
	val &= eqset();
    return(val);
}


/************************************************************************/
/* eqset ::= relation [ ('==' | '!=') eqset] ;				*/
/************************************************************************/
long eqset(void)
{
    REG	long val;

    val = relation();
    if( nextis(L_EQUALS) )
	return(val == relation());
    if( nextis(L_NOTEQ) )
	return(val != relation());
    return(val);
}

/************************************************************************/
/* relation ::= shift [ ('<' | '>' | '<=' | '>=' ) shift] ;		*/
/************************************************************************/
long relation(void)
{
    REG	long val;

    val = shift();
    if( nextis(L_LT) )
	return(val < shift());
    if( nextis(L_GT) )
	return(val > shift());
    if( nextis(L_LTEQ) )
	return(val <= shift());
    if( nextis(L_GTEQ) )
	return(val >= shift());
    return(val);
}


/************************************************************************/
/* shift ::= plus [ ('<< | '>>') plus] ;				*/
/************************************************************************/
long shift(void)
{
    REG	long val;

    val = plus();
    if( nextis(L_RSHIFT) )
	return(val >> plus());
    if( nextis(L_LSHIFT) )
	return(val << plus());
    return(val);
}


/************************************************************************/
/* plus ::= mult [ ('+' | '-') mult ]* ;				*/
/************************************************************************/
long	  plus(void)
{
    REG	long val;

    val = mult();
    for(;;) {
	if( nextis(L_PLUS) )
	    val += mult();
	else if( nextis(L_MINUS) )
	    val -= mult();
	else
	    break;
    }
    return(val);
}


/************************************************************************/
/* mult ::= prim [ ('*' | '/' | '%' ) prim ]* ;				*/
/************************************************************************/
long mult(void)
{
    REG	long val;

    val = prim();
    for(;;) {
	if( nextis(L_MULT) )
	    val *= prim();
	else if( nextis(L_DIV) )
	    val /= prim();
	else if( nextis(L_MOD) )
	    val %= prim();
	else
	    break;
    }
    return(val);
}


/************************************************************************/
/* prim ::= constant | ( '!' | '~' | '-' ) constant 			*/
/************************************************************************/
long prim(void)
{
    if( nextis(L_EXCLAIM) )
	return( ! constant());
    else if( nextis(L_TILDE) )
	return( ~ constant() );
    else if( nextis(L_MINUS) )
	return(-constant());
    else
	return(constant());
}


/************************************************************************/
/* constant - at last, a terminal symbol  | '(' constexpr ')'		*/
/************************************************************************/
long constant(void)
{
    REG	long val;

    if( nextis(L_LPAREN) ) {
	Parencnt++;
	val = constexpr();
	if( nextis(L_RPAREN) ) {
	    Parencnt--;
	    return(val);
	}
	else {
	    Msg_Temp = GET_MSG(1012);
	    SET_MSG (Msg_Text, Msg_Temp, ")");
	    fatal (1012);
	}
    }
    else if( ! nextis(L_CINTEGER) ) {
	Msg_Temp = GET_MSG(1017);
	SET_MSG (Msg_Text, Msg_Temp);
	fatal(1017);	/* invalid integer constant expression */
    }
    return(Currval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\p0defs.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0DEFS.H - Defintions for PreProcessor parsing code			*/
/*									*/
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

struct	s_defn	{
    pdefn_t	defn_next;		/*  pointer to next ident  */
    PUCHAR	defn_ident;		/*  pointer to name */
    ptext_t	defn_text;		/*  definition substitution string  */
    char		defn_nformals;/*number of formal arguments - can be <0*/
    char		defn_expanding;	/* are we already expanding this one? */
};

#define	DEFN_IDENT(P)		((P)->defn_ident)
#define	DEFN_NAME(P)		(DEFN_IDENT(P))
#define	DEFN_NEXT(P)		((P)->defn_next)
#define	DEFN_TEXT(P)		((P)->defn_text)
#define	DEFN_NFORMALS(P)	((P)->defn_nformals)
#define	DEFN_EXPANDING(P)	((P)->defn_expanding)

#define	FILE_EOS		0x01
#define	ACTUAL_EOS		0x02
#define	DEFINITION_EOS		0x04
#define	RESCAN_EOS		0x08
#define	BACKSLASH_EOS		0x10
#define	ANY_EOS			( FILE_EOS | ACTUAL_EOS | DEFINITION_EOS\
									   | RESCAN_EOS | BACKSLASH_EOS )

/*
**	arbitrarily chosen characters that get special treatment when found
**	after EOS in handle_eos()
*/
#define	EOS_ACTUAL		'A'
#define	EOS_DEFINITION		'D'
#define	EOS_RESCAN		'R'
#define	EOS_PAD			'P'

#define	FROM_COMMAND		-2
#define	PRE_DEFINED(P)		(DEFN_NFORMALS(P) < FROM_COMMAND)

typedef struct s_expstr	{
    ptext_t	exp_string;	/* ptr to next character in stream aft macro */
    char	*exp_actuals;	/* ptr to start of actuals linked list */
    ptext_t	exp_text;	/* ptr to expanded text for this macro */
    pdefn_t	exp_macro;		/* ptr to macro defn */
    UCHAR	exp_nactuals;	/* number of actuals */
    UCHAR	exp_nactsexpanded;/* number of expanded actuals for handle_eos*/
} expansion_t;

/*
**	note that CURRENT_STRING usually points into an area in the macro
**	expansion buffer, but the first item used (Macro_depth equals 1) points
**	to text read from a file.  In some versions, the heap is reshuffled
**	and this pointer must be updated for the first item.
*/
#define CURRENT_STRING		Macro_expansion[Macro_depth].exp_string
#define CURRENT_ACTUALS		Macro_expansion[Macro_depth].exp_actuals
#define CURRENT_TEXT		Macro_expansion[Macro_depth].exp_text
#define CURRENT_MACRO		Macro_expansion[Macro_depth].exp_macro
#define CURRENT_NACTUALS	Macro_expansion[Macro_depth].exp_nactuals
#define CURRENT_NACTSEXPANDED Macro_expansion[Macro_depth].exp_nactsexpanded

/*
**	finds address after last element in an array. Used to check for
**	buffer overflows.
*/
#define	LIMIT(a)	&(a)[sizeof(a)]

#define IS_CHAR(c,uc)	(toupper(c) == (uc))
#define IS_B(c)		IS_CHAR(c, 'B')
#define IS_D(c)		IS_CHAR(c, 'D')
#define	IS_E(c)		IS_CHAR(c, 'E')
#define	IS_F(c)		IS_CHAR(c, 'F')
#define IS_H(c)		IS_CHAR(c, 'H')
#define	IS_EL(c)	IS_CHAR(c, 'L')
#define IS_O(c)		IS_CHAR(c, 'O')
#define IS_Q(c)		IS_CHAR(c, 'Q')
#define	IS_U(c)		IS_CHAR(c, 'U')
#define	IS_X(c)		IS_CHAR(c, 'X')
#define	IS_DOT(c)	(c == '.')
#define	IS_SIGN(c)	((c == '+') || (c =='-'))

#define	P0_IF		0
#define	P0_ELIF		1
#define	P0_ELSE		2
#define	P0_ENDIF	3
#define	P0_IFDEF	4
#define	P0_IFNDEF	5
#define	P0_DEFINE	6
#define	P0_INCLUDE	7
#define	P0_PRAGMA	8
#define	P0_UNDEF	9
#define	P0_LINE		10
#define	P0_NOTOKEN	11
#define	P0_ERROR	12
#define	P0_IDENT	13


#define HLN_NAME(s)	((s).hln_name)
#define HLN_HASH(s)	((s).hln_hash)
#define HLN_LENGTH(s)	((s).hln_length)
#define HLN_IDENT_HASH(p)	(HLN_HASH(*(p)))
#define HLN_IDENT_LENGTH(p)	(HLN_LENGTH(*(p)))
#define HLN_IDENTP_NAME(p)	(HLN_NAME(*(p)))
#define	HLN_TO_NAME(S)		((PUCHAR)pstrndup(HLN_IDENTP_NAME(S),HLN_IDENT_LENGTH(S)))

#define HASH_MASK	0x5f

#define LIMIT_ID_LENGTH		31
#define LIMIT_NESTED_INCLUDES	10
#define LIMIT_MACRO_DEPTH	64
#define LIMIT_STRING_LENGTH	2043
#define LEVEL_0			0xff

#define	MUST_OPEN	1
#define	MAY_OPEN	0

/*** The following are defined to use on the Token Table ***/

#define	TS_STR(idx)		(Tokstrings[idx-L_NOTOKEN].k_text)
#define	TS_VALUE(idx)	(Tokstrings[idx-L_NOTOKEN].k_token)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\p0gettok.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0GETTOK.C - Tokenization routines					*/
/*									*/
/* 29-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "grammar.h"
#include "p0defs.h"
#include "charmap.h"

/************************************************************************
**	MAP_TOKEN : a token has two representations and additional information.
**	(ex : const, has basic token of L_CONST,
**				mapped token of [L_TYPE | L_MODIFIER]
**				and info based on what the map token is)
**	MAP_AND_FILL : has two representations, but none of the extra info.
**	(ex : '<', has basic of L_LT, and map of L_RELOP)
**  NOMAP_TOKEN : has 1 representation and additional info.
**	(ex: a string, basic and 'map' type L_STRING and ptrs to the actual str)
**	NOMAP_AND_FILL : has 1 representation and no additional info.
**	(ex : 'while', has basic and 'map' of L_WHILE)
**  the FILL versions fill the token with the basic token type.
************************************************************************/
#define	MAP_TOKEN(otok)\
	(Basic_token = (otok), TS_VALUE(Basic_token))
#define	MAP_AND_FILL(otok)\
	(yylval.yy_token = Basic_token = (otok), TS_VALUE(Basic_token))
#define	NOMAP_TOKEN(otok)\
	(Basic_token = (otok))
#define	NOMAP_AND_FILL(otok)\
	(yylval.yy_token = Basic_token = (otok))



/************************************************************************/
/* yylex - main tokenization routine					*/
/************************************************************************/

token_t yylex(void)
{
    REG	UCHAR		last_mapped;
    UCHAR		mapped_c;
    REG	token_t		lex_token;

    for(;;) {
	last_mapped = mapped_c = CHARMAP(GETCH());
first_switch:
	switch(mapped_c) {
	case LX_EACH:
	case LX_ASCII:
	    Msg_Temp = GET_MSG(2018);
	    SET_MSG (Msg_Text, Msg_Temp, PREVCH());
	    error(2018);
	    continue;
	    break;
	case LX_OBRACE:
	    return(NOMAP_AND_FILL(L_LCURLY));
	    break;
	case LX_CBRACE:
	    return(NOMAP_AND_FILL(L_RCURLY));
	    break;
	case LX_OBRACK:
	    return(NOMAP_AND_FILL(L_LBRACK));
	    break;
	case LX_CBRACK:
	    return(NOMAP_AND_FILL(L_RBRACK));
	    break;
	case LX_OPAREN:
	    return(NOMAP_AND_FILL(L_LPAREN));
	    break;
	case LX_CPAREN:
	    return(NOMAP_AND_FILL(L_RPAREN));
	    break;
	case LX_COMMA:
	    return(NOMAP_AND_FILL(L_COMMA));
	    break;
	case LX_QUEST:
	    return(NOMAP_AND_FILL(L_QUEST));
	    break;
	case LX_SEMI:
	    return(NOMAP_AND_FILL(L_SEMI));
	    break;
	case LX_TILDE:
	    return(NOMAP_AND_FILL(L_TILDE));
	    break;
	case LX_NUMBER:
	    return(MAP_TOKEN(getnum(PREVCH())));
	    break;


	case LX_MINUS:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_EQ:
		return(MAP_AND_FILL(L_MINUSEQ));
		break;
	    case LX_GT:
		return(MAP_AND_FILL(L_POINTSTO));
		break;
	    case LX_MINUS:
		return(MAP_AND_FILL(L_DECR));
		break;
	    default:
		lex_token = L_MINUS;
		break;
	    }
	    break;
	case LX_PLUS:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_EQ:
		return(MAP_AND_FILL(L_PLUSEQ));
		break;
	    case LX_PLUS:
		return(MAP_AND_FILL(L_INCR));
		break;
	    default:
		lex_token = L_PLUS;
		break;
	    }
	    break;
	case LX_AND:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_EQ:
		return(MAP_AND_FILL(L_ANDEQ));
		break;
	    case LX_AND:
		return(MAP_AND_FILL(L_ANDAND));
		break;
	    default:
		lex_token = L_AND;
		break;
	    }
	    break;
	case LX_OR:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_EQ:
		return(MAP_AND_FILL(L_OREQ));
		break;
	    case LX_OR:
		return(MAP_AND_FILL(L_OROR));
		break;
	    default:
		lex_token = L_OR;
		break;
	    }
	    break;
	case LX_COLON:
	    return(NOMAP_AND_FILL(L_COLON));
	    break;
	case LX_HAT:
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_XOREQ));
	    }
	    lex_token = L_XOR;
	    break;
	case LX_PERCENT:
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_MODEQ));
	    }
	    lex_token = L_MOD;
	    break;
	case LX_EQ:
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_EQUALS));
	    }
	    lex_token = L_ASSIGN;
	    break;
	case LX_BANG:
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_NOTEQ));
	    }
	    lex_token = L_EXCLAIM;
	    break;
	case LX_SLASH:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_STAR:
		dump_comment();
		continue;
		break;
	    case LX_SLASH:
		DumpSlashComment();
		continue;
		break;
	    case LX_EQ:
		return(MAP_AND_FILL(L_DIVEQ));
		break;
	    default:
		lex_token = L_DIV;
		break;
	    }
	    break;
	case LX_STAR:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_SLASH:
		if( ! Prep ) {
		    Msg_Temp = GET_MSG(2138);
		    SET_MSG (Msg_Text, Msg_Temp);
		    error(2138); /* (nested comments) */
		}
		else {
		    fwrite("*/", 2, 1, OUTPUTFILE);
		}
		continue;
	    case LX_EQ:
		return(MAP_AND_FILL(L_MULTEQ));
		break;
	    default:
		lex_token = L_MULT;
		break;
	    }
	    break;
	case LX_LT:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_LT:
		if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		    return(MAP_AND_FILL(L_LSHFTEQ));
		}
		mapped_c = LX_LSHIFT;
		lex_token = L_LSHIFT;
		break;
	    case LX_EQ:
		return(MAP_AND_FILL(L_LTEQ));
		break;
	    default:
		lex_token = L_LT;
		break;
	    }
	    break;
	case LX_LSHIFT:
	    /*
			**  if the next char is not an =, then we unget and return,
			**  since the only way in here is if we broke on the char
			**  following '<<'. since we'll have already worked the handle_eos()
			**  code prior to getting here, we'll not see another eos,
			**  UNLESS i/o buffering is char by char. ???
			**  see also, LX_RSHIFT
			*/
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_LSHFTEQ));
	    }
	    UNGETCH();
	    return(MAP_AND_FILL(L_LSHIFT));
	    break;
	case LX_GT:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_EQ:
		return(MAP_AND_FILL(L_GTEQ));
	    case LX_GT:
		if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		    return(MAP_AND_FILL(L_RSHFTEQ));
		}
		mapped_c = LX_RSHIFT;
		lex_token = L_RSHIFT;
		break;
	    default:
		lex_token = L_GT;
		break;
	    }
	    break;
	case LX_RSHIFT:
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_RSHFTEQ));
	    }
	    UNGETCH();
	    return(MAP_AND_FILL(L_RSHIFT));
	    break;
	case LX_POUND:
	    if( ! Prep ) {
		Msg_Temp = GET_MSG(2014);
		SET_MSG (Msg_Text, Msg_Temp);
		error(2014);/* # sign must be first non-whitespace */
		UNGETCH();		/* replace it */
		Linenumber--;	/* do_newline counts a newline */
		do_newline();	/* may be a 'real' prepro line */
	    }
	    else {
		fwrite("#", 1, 1, OUTPUTFILE);
	    }
	    continue;
	    break;
	case LX_EOS:
	    if(PREVCH() == '\\') {
		if( ! Prep ) {
		    if( ! checknl()) {	/* ignore the new line */
			Msg_Temp = GET_MSG(2017);
			SET_MSG (Msg_Text, Msg_Temp);
			error(2017);/* illegal escape sequence */
		    }
		}
		else {
		    fputc('\\', OUTPUTFILE);
		    fputc(get_non_eof(), OUTPUTFILE);
		}
		continue;
	    }
	    if(Macro_depth == 0) {
		if( ! io_eob()) {	/* not the end of the buffer */
		    continue;
		}
		if(fpop()) {		/* have more files to read */
		    continue;
		}
		return(MAP_AND_FILL(L_EOF));	/* all gone . . . */
	    }
	    handle_eos();			/* found end of macro */
	    continue;
	    break;
	case LX_DQUOTE:
	    if( ! Prep ) {
		str_const();
		return(NOMAP_TOKEN(L_STRING));
	    }
	    prep_string('\"');
	    continue;
	    break;
	case LX_SQUOTE:
	    if( ! Prep ) {
		return(MAP_TOKEN(char_const()));
	    }
	    prep_string('\'');
	    continue;
	    break;
	case LX_CR:		/*  ??? check for nl next  */
	    continue;
	    break;
	case LX_NL:
	    if(On_pound_line) {
		UNGETCH();
		return(NOMAP_TOKEN(L_NOTOKEN));
	    }
	    if(Prep) {
		fputc('\n', OUTPUTFILE);
	    }
	    do_newline();
	    continue;
	    break;
	case LX_WHITE:		/* skip all white space */
	    if( ! Prep ) {	/* check only once */
		do {
		    ;
		} while(LXC_IS_WHITE(GETCH()));
	    }
	    else {
		UCHAR	c;

		c = PREVCH();
		do {
		    fputc(c, OUTPUTFILE);
		} while(LXC_IS_WHITE(c = GETCH()));
	    }
	    UNGETCH();
	    continue;
	    break;
	    /* Note:
                 * RCPP.EXE does not support DBCS code.
                 * Therefore, we should be displaied error message.
                 * IBM-J PTR 12JP-0092
                 * MSHQ  PTR xxxxx
	                     */
	case LX_LEADBYTE:
	    if( ! Prep ) {       /* check only once */
		Msg_Temp = GET_MSG(2018);
		SET_MSG (Msg_Text, Msg_Temp, PREVCH());
		error(2018);

		Msg_Temp = GET_MSG(2018);
		SET_MSG (Msg_Text, Msg_Temp, GETCH());
		error(2018);
	    }
	    else {
		fputc(PREVCH(), OUTPUTFILE);
#ifdef DBCS // token_t yylex(void)
		fputc(get_non_eof(), OUTPUTFILE);
#else
		fputc(GETCH(), OUTPUTFILE);
#endif // DBCS
	    }
	    continue;
	    break;
	case LX_ILL:
	    if( ! Prep ) {
		Msg_Temp = GET_MSG(2018);
		SET_MSG (Msg_Text, Msg_Temp, PREVCH());
		error(2018);/* unknown character */
	    } else {
		fputc(PREVCH(), OUTPUTFILE);
	    }
	    continue;
	    break;
	case LX_BACKSLASH:
	    if( ! Prep ) {
		if( ! checknl()) {	/* ignore the new line */
		    Msg_Temp = GET_MSG(2017);
		    SET_MSG (Msg_Text, Msg_Temp);
		    error(2017);/* illegal escape sequence */
		}
	    }
	    else {
		fputc('\\', OUTPUTFILE);
		fputc(get_non_eof(), OUTPUTFILE);
	    }
	    continue;
	    break;
	case LX_DOT:
dot_switch:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_BACKSLASH:
		if(checknl()) {
		    goto dot_switch;
		}
		UNGETCH();
		break;
	    case LX_EOS:
		if(handle_eos() == BACKSLASH_EOS) {
		    break;
		}
		goto dot_switch;
		break;
	    case LX_DOT:
		if( ! checkop('.') ) {
		    Msg_Temp = GET_MSG(2142);
		    SET_MSG (Msg_Text, Msg_Temp);
		    error(2142);/* ellipsis requires three '.'s */
		}
		return(NOMAP_AND_FILL(L_ELLIPSIS));
		break;
	    case LX_NUMBER:
		/*
		**	don't worry about getting correct hash value.
		**	The text equivalent of a real number is never
		**	hashed
		*/
		Reuse_1[0] = '.';
		Reuse_1[1] = PREVCH();
		return(MAP_TOKEN(get_real(&Reuse_1[2])));
		break;
	    }
	    UNGETCH();
	    return(MAP_AND_FILL(L_PERIOD));
	    break;
	case LX_NOEXPAND:
	    SKIPCH();			/* just skip length */
	    continue;
	case LX_ID:
	    {
		pdefn_t	pdef;

		if(Macro_depth > 0) {
		    if( ! lex_getid(PREVCH())) {
			goto avoid_expand;
		    }
		}
		else {
		    getid(PREVCH());
		}

		if( ((pdef = get_defined()) != 0)
		    &&
		    ( ! DEFN_EXPANDING(pdef))
		    &&
		    ( can_expand(pdef))
		    ) {
		    continue;
		}

avoid_expand:
		if( ! Prep ) {
		    /* M00BUG get near copy of identifier???? */
		    HLN_NAME(yylval.yy_ident) = Reuse_1;
		    HLN_HASH(yylval.yy_ident) = Reuse_1_hash;
		    HLN_LENGTH(yylval.yy_ident) = (UCHAR)Reuse_1_length;
		    return(L_IDENT);
		}
		else {
		    fwrite(Reuse_1, Reuse_1_length - 1, 1, OUTPUTFILE);
		    return(NOMAP_TOKEN(L_NOTOKEN));
		}
	    }
	    continue;
	    break;
	}
	/*
	**  all the multichar ( -> -- -= etc ) operands
	**  must come through here. we've gotten the next char,
	**  and not matched one of the possiblities, but we have to check
	**  for the end of the buffer character and act accordingly
	**  if it is the eob, then we handle it and go back for another try.
	**  otherwise, we unget the char we got, and return the base token.
	*/
	if(last_mapped == LX_EOS) {
	    if(handle_eos() != BACKSLASH_EOS) {
		goto first_switch;
	    }
	}
	UNGETCH();	/* cause we got an extra one to check */
	return(MAP_AND_FILL(lex_token));
    }
}


/************************************************************************
**
**	lex_getid: reads an identifier for the main lexer.  The
**		identifier is read into Reuse_1. This function should not handle
**		an end of string if it is rescanning a macro expansion, because
**		this could switch the context with regards to whether the macro
**	      is expandable or not.  Similarly, the noexpand marker must only be
**	     allowed if a macro is being rescanned, otherwise let this character
**		be caught as an illegal character in text
************************************************************************/
int lex_getid(UCHAR c)
{
    REG	UCHAR	*p;
    int		length = 0;

    p = Reuse_1;
    *p++ = c;
    c &= HASH_MASK;
    for(;;) {
	while(LXC_IS_IDENT(*p = GETCH())) { /* collect character */
	    c += (*p & HASH_MASK);			/* hash it */
	    p++;
	}
	if(CHARMAP(*p) == LX_NOEXPAND ) {
	    length = (int)GETCH();
	    continue;
	}
	UNGETCH();
	break;				/* out of for loop  -  only way out */
    }
    if(p >= LIMIT(Reuse_1)) {	/* is this error # correct? */
	Msg_Temp = GET_MSG(1067);
	SET_MSG (Msg_Text, Msg_Temp);
	fatal(1067);
    }
    if(((p - Reuse_1) > LIMIT_ID_LENGTH) && ( ! Prep )) {
	p = Reuse_1 + LIMIT_ID_LENGTH;
	*p = '\0';
	c = local_c_hash(Reuse_1);
	Msg_Temp = GET_MSG(4011);
	SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	warning(4011);	/* id truncated */
    }
    else {
	*p = '\0';		/* terminates identifier for expandable check */
    }
    Reuse_1_hash = c;
    Reuse_1_length = (UCHAR)((p - Reuse_1) + 1);
    return(length != (p - Reuse_1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\hivepp.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* MAIN.C - Main Program                                                */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include        <windows.h>
#include        <stdlib.h>
#include        <stdio.h>
#include        <string.h>
#include        "rcpptype.h"
#include        "rcppdecl.h"
#include        "rcppext.h"
#include        "grammar.h"
#include        "getflags.h"
#ifdef DBCS
#include        "charmap.h"
#endif // DBCS

/************************************************************************/
/* Global Varialbes                                                     */
/************************************************************************/
char    *Unknown = NULL;                /* holder for bad flags */
int     Argc;
char    **Argv;

/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
char    *nextword(void);
void    __cdecl main(int, char **);
void    to_human(void);
BOOL WINAPI	Handler(ULONG CtrlType);


struct  subtab  Ztab[] = {
    'a',        UNFLAG, &Extension,
    'e',        FLAG,   &Extension,
    'E',        FLAG,   &Ehxtension,
    'i',        FLAG,   &Symbolic_debug,
    'g',        FLAG,   &Out_funcdef,
    'p',        FLAG,   &Cmd_pack_size,
    'I',        FLAG,   &Inteltypes,
    'c',        FLAG,   &ZcFlag,
    0,          0,              0,
};

struct cmdtab cmdtab[] = {
    "-pc#",             (char *)&Path_chars,            1,      STRING,
    "-pf",              (char *)&NoPasFor,              1,      FLAG,
    "-C",               (char *)&Cflag,                 1,      FLAG,
    "-CP#",             (char *)&gpszNLSoptions,        1,      STRING,
    "-D#",              (char *)&Defs,                  1,      PSHSTR,
    "-E",               (char *)&Eflag,                 1,      FLAG,
    "-I#",              (char *)&Includes,              1,      PSHSTR,
    "-P",               (char *)&Pflag,                 1,      FLAG,
    "-f",               (char *)&Input_file,            1,      STRING,
    "-g",               (char *)&Output_file,           1,      STRING,
    "-J",               (char *)&Jflag,                 1,      FLAG,
    "-Zp",              (char *)&Cmd_pack_size,         1,      FLAG,
    "-Zp#",             (char *)&Cmd_pack_size,         1,      NUMBER,
    "-Z*",              (char *)Ztab,                   1,      SUBSTR,
    "-Oi",              (char *)&Cmd_intrinsic,         1,      FLAG,
    "-Ol",              (char *)&Cmd_loop_opt,          1,      FLAG,
    "-db#",             (char *)&Debug,                 1,      STRING,
    "-ef#",             (char *)&ErrFilName,            1,      STRING,
    "-il#",             (char *)&Basename,              1,      STRING,
    "-xc",              (char *)&Cross_compile,         1,      FLAG,
    "-H",               (char *)&HugeModel,             1,      FLAG,
    "-V#",              (char *)&Version,               1,      STRING,
    "-Gs",              (char *)&Cmd_stack_check,       1,      UNFLAG,
    "-Gc",              (char *)&Plm,                   1,      FLAG,
    "-char#",           (char *)&Char_align,            1,      NUMBER,
    "-A#",              (char *)&A_string,              1,      STRING,
    "-Q#",              (char *)&Q_string,              1,      STRING,
    "-Fs",              (char *)&Srclist,               1,      FLAG,
    "-R",               (char *)&Rflag,                 1,      FLAG,
    "*",                (char *)&Unknown,               0,      STRING,
    0,                  0,                                                      0,      0,
};

/************************************************************************/
/* nextword -                                                           */
/************************************************************************/
char    *nextword(void)
{
    return((--Argc > 0) ? (*++Argv) : 0);
}

#ifdef DBCS

/************************************************************************/
/* vReConfigureLeadByteInfo -                                           */
/************************************************************************/

void vReConfigureLeadByteInfo( unsigned int uiCodePage )
{
    CPINFO CPInfo;
    PUCHAR pLeadByte;
    BYTE   i;

    /* Following instruction should be success      */
    /* because CodePage should be checked by RC.exe */
    GetCPInfo( uiCodePage , &CPInfo );

    /*  Fill Charmap table with LX_LEADBYTE  */
    pLeadByte = CPInfo.LeadByte;

    while( *pLeadByte != 0 && *(pLeadByte+1) != 0 ) {
        for( i = *pLeadByte ; i <= *(pLeadByte+1) ; i++ ) {
            Charmap[i] = LX_LEADBYTE;
        }
        pLeadByte += 2;
    }
}

#ifdef HIVEPP
void vReConfigureCharTable( void )
{
    Charmap[0x40] = LX_ID;
    Charmap[0x60] = LX_ID;
}
#endif // HIVEPP

#endif // DBCS

/************************************************************************/
/* main -                                                               */
/************************************************************************/
void __cdecl main(int argc, char **argv)
{

    Argc = argc;
    Argv = argv;

    while(crack_cmd(cmdtab, nextword(), nextword, 0)) ;

#ifdef DBCS
    {
        int CodePage;

        // To modify charmap info
        if( gpszNLSoptions != NULL )
            CodePage = atoi( gpszNLSoptions );
        else
            CodePage = GetACP();
#ifdef FIREWALLS
        fprintf( stderr , "RCPP:CodePage - %s - %d \n",gpszNLSoptions , CodePage );
#endif
        vReConfigureLeadByteInfo(CodePage);
    }
#endif // DBCS 

#ifdef DBCS
#ifdef HIVEPP
        vReConfigureCharTable();
#endif // HIVEPP
#endif // DBCS

    if(Unknown) {
        Msg_Temp = GET_MSG (1007);
        SET_MSG (Msg_Text, Msg_Temp, Unknown, "c1");
        fatal(1007);    /* unknown flag */
    }

    if( ! Input_file) {
        Msg_Temp = GET_MSG (1008);
        SET_MSG (Msg_Text, Msg_Temp);
        fatal(1008);            /* no input file specified */
    }

    if( ! Output_file) {
        Msg_Temp = GET_MSG (1011);
        SET_MSG (Msg_Text, Msg_Temp);
        fatal(1011);            /* no input file specified */
    }

    Prep = TRUE;
    if( !Eflag && !Pflag ) {
        Eflag = TRUE;
    }

    strncpy(Filename,Input_file,128);

    SetConsoleCtrlHandler(Handler, TRUE);
    p0_init(Input_file, Output_file, &Defs);
    to_human();
    SetConsoleCtrlHandler(Handler, FALSE);

    if( Prep_ifstack >= 0 ) {
        Msg_Temp = GET_MSG (1022);
        SET_MSG (Msg_Text, Msg_Temp);
        fatal(1022);            /* expected #endif */
    }

    exit(Nerrors);
}

BOOL WINAPI Handler(ULONG CtrlType)
{
    /*
    **	Unreferenced
    */
    (void)CtrlType;

    /* Close ALL files. */
    _fcloseall();

    exit(1);
    return 1;
}


/************************************************************************/
/* to_human : outputs preprocessed text in human readable form.         */
/************************************************************************/
void to_human(void)
{
    PCHAR value;
    for(;;) {
        switch(yylex()) {
        case 0:
            return;
        case L_NOTOKEN:
            break;
        default:
            if (Basic_token == 0) {
                Msg_Temp = GET_MSG(1068);
                SET_MSG(Msg_Text, Msg_Temp);
                fatal(1068);
            }
            value = Tokstrings[Basic_token - L_NOTOKEN].k_text;
            fwrite(value, strlen(value), 1, OUTPUTFILE);
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\p0io.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0IO.C - Input/Output for Preprocessor				*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"
#include "charmap.h"
#include "rcunicod.h"


/************************************************************************/
/* Local Function Prototypes 						*/
/************************************************************************/
ptext_t esc_sequence(ptext_t, ptext_t);


#define TEXT_TYPE ptext_t

/***  ASSUME : the trailing marker byte is only 1 character. ***/

#define	PUSHBACK_BYTES	1

#define	TRAILING_BYTES	1

#define	EXTRA_BYTES		(PUSHBACK_BYTES + TRAILING_BYTES)
/*
**  here are some defines for the new handling of io buffers.
**  the buffer itself is 6k plus some extra bytes.
**  the main source file uses all 6k.
**  the first level of include files will use 4k starting 2k from the beginning.
**  the 2nd level - n level will use 2k starting 4k from the beginning.
**  this implies that some special handling may be necessary when we get
**  overlapping buffers. (unless the source file itself is < 2k
**  all the include files are < 2k and they do not nest more than 2 deep.)
**  first, the source file is read into the buffer (6k at a time).
**  at the first include file, (if the source from the parent file
**  is more than 2k chars) . . .
**		if the Current_char ptr is not pointing above the 2k boundary
**		(which is the beginning of the buffer for the include file)
**		then we pretend we've read in only 2k into the buffer and
**		place the terminator at the end of the parents 2k buffer.
**		else we pretend we've used up all chars in the parents buffer
**		so the next read for the parent will be the terminator, and
**		the buffer will get filled in the usual manner.
**  (if we're in a macro, the picture is slightly different in that we have
**  to update the 'real' source file pointer in the macro structure.)
**
**  the first nested include file is handled in a similar manner. (except
**  it starts up 4k away from the start.)
**
**  any further nesting will keep overlaying the upper 2k part.
*/
#define	ONE_K		(1024)
#define	TWO_K		(ONE_K * 2)
#define	FOUR_K		(ONE_K * 4)
#define	SIX_K		(ONE_K * 6)
#define	IO_BLOCK	(TWO_K + EXTRA_BYTES)

int vfCurrFileType = DFT_FILE_IS_UNKNOWN;   //- Added for 16-bit file support.

char    InputBuffer[IO_BLOCK * 3];

//- Added to input 16-bit files. 8-2-91 David Marsyla.
WCHAR   wchInputBuffer[IO_BLOCK * 3];

extern expansion_t Macro_expansion[];

typedef struct  s_filelist  filelist_t;
static struct s_filelist {   /* list of input files (nested) */
    int         fl_bufsiz;/* bytes to read into the buffer */
    FILE *      fl_file;            /* FILE id */
    long        fl_lineno;  /* line number when file was pushed */
    PUCHAR  fl_name;            /* previous file text name */
    ptext_t fl_currc;   /* ptr into our buffer for current c */
    TEXT_TYPE   fl_buffer;          /* type of buffer */
    WCHAR   *fl_pwchBuffer; //- Added for 16-bit file support.
    //- pointer to identical wide char buffer.
    int     fl_numread;  /* # of bytes read into buffer */
    int     fl_fFileType;   //- Added for 16-bit file support.
    //- return from DetermineFileType.
    long    fl_totalread;
} Fstack[LIMIT_NESTED_INCLUDES];

static  FILE *Fp = NULL;
int     Findex = -1;


/************************************************************************
 * NEWINPUT - A new input file is to be opened, saving the old.
 *
 * ARGUMENTS
 *	char *newname - the name of the file
 *
 * RETURNS  - none
 *
 * SIDE EFFECTS
 *	- causes input stream to be switched
 *	- Linenumber is reset to 1
 *	- storage is allocated for the newname
 *	- Filename is set to the new name
 *
 * DESCRIPTION
 *	The file is opened, and if successful, the current input stream is saved
 *	and the stream is switched to the new file. If the newname is NULL,
 *	then stdin is taken as the new input.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int newinput (char *newname, int m_open)
{
    filelist_t *pF;
    TEXT_TYPE   p;
    WCHAR   *pwch;

    if ( newname == NULL ) {
        Fp = stdin;
    } else if ((Fp = fopen(newname, "rb")) == NULL) {
        if (m_open == MUST_OPEN) {
            Msg_Temp = GET_MSG (1013);
            SET_MSG (Msg_Text, Msg_Temp, newname);
            fatal(1013);
        }
        return (FALSE);
    }

    /* now push it onto the file stack */
    ++Findex;
    if (Findex >= LIMIT_NESTED_INCLUDES) {
        Msg_Temp = GET_MSG (1014);
        SET_MSG (Msg_Text, Msg_Temp);
        fatal(1014);
    }
    pF = &Fstack[Findex];
    if (Findex == 0) {
        p = &InputBuffer[(IO_BLOCK * 0) + PUSHBACK_BYTES];
        pwch = &wchInputBuffer[(IO_BLOCK * 0) + PUSHBACK_BYTES];
        pF->fl_bufsiz = SIX_K;
    } else {
        filelist_t  *pPrevF;

        pPrevF = pF - 1;
        if (Findex == 1) {           /* first level include */
            p = &InputBuffer[(IO_BLOCK * 1) + PUSHBACK_BYTES];
            pwch = &wchInputBuffer[(IO_BLOCK * 1) + PUSHBACK_BYTES];
            pF->fl_bufsiz = FOUR_K;
        } else {      /* (Findex > 1) */
            /* nested includes . . . */
            p = &InputBuffer[(IO_BLOCK * 2) + PUSHBACK_BYTES];
            pwch = &wchInputBuffer[(IO_BLOCK * 2) + PUSHBACK_BYTES];
            pF->fl_bufsiz = TWO_K;
        }
        if ((pPrevF->fl_numread > TWO_K) || (Findex > 2)) {
            /*
            **  the parent file has read something into the upper section
            **  or this is a nested include at least 3 deep.
            **  the child will overwrite some parent info. we must take this
            **  into account for the parent to reread when the time comes.
            **  we also must stick in the eos char into the parents buffer.
            **  (this latter is the useless thing in deeply nested
            **  includes since we overwrite the thing we just put in. we'll
            **  handle this later when we fpop the child.)
            */
            TEXT_TYPE   pCurrC;
            long        seek_posn;

            seek_posn = pPrevF->fl_totalread;
            if ( Macro_depth != 0 ) {
                /*
                **  in a macro, the 'current char' we want is kept as the
                **  first thing in the macro structure.
                */
                pCurrC = (TEXT_TYPE)Macro_expansion[1].exp_string;
            } else {
                pCurrC = (TEXT_TYPE)Current_char;
            }
            if (pCurrC >= p) {
                /*
                **  p is the start of the child section.
                **  current char is past it. ie, we've already read some
                **  from the upper section.
                **  current char - p = # of characters used in upper section.
                **  numread = 0 implies there are no chars left from the parent.
                **  since, this is really the 'end' of the parent's buffer,
                **  we'll have to update the info so that the next read from the
                **  parent (after the child is finished) will be the terminator
                **  and we want the io_eob handler to refill the buffer.
                **  we reset the parent's cur char ptr to the beginning of its
                **  buffer, and put the terminator there.
                */
                seek_posn += (long)(pCurrC - pPrevF->fl_buffer);
                pPrevF->fl_totalread += (long)(pCurrC - pPrevF->fl_buffer);
                pPrevF->fl_numread = 0;
                if ( Macro_depth != 0 ) {
                    Macro_expansion[1].exp_string = pPrevF->fl_buffer;
                } else {
                    Current_char = pPrevF->fl_buffer;
                }
                *(pPrevF->fl_buffer) = EOS_CHAR;
                *(pPrevF->fl_pwchBuffer) = EOS_CHAR;
            } else {
                /*
                **  the upper section has not been read from yet,
                **  but it has been read into.
                **  'p' is pointing to the start of the child's buffer.
                **  we add the terminator to the new end of the parent's buffer.
                */
                seek_posn += TWO_K;
                pPrevF->fl_numread = TWO_K;
                *(pPrevF->fl_buffer + TWO_K) = EOS_CHAR;
                *(pPrevF->fl_pwchBuffer + TWO_K) = EOS_CHAR;
            }

            if (pPrevF->fl_fFileType == DFT_FILE_IS_8_BIT) {
                if (fseek(pPrevF->fl_file, seek_posn, SEEK_SET) == -1)
                    return FALSE;
            } else {
                if (fseek(pPrevF->fl_file, seek_posn * sizeof (WCHAR), SEEK_SET) == -1)
                    return FALSE;
            }
        }
    }
    pF->fl_currc = Current_char;/*  previous file's current char */
    pF->fl_lineno = Linenumber; /*  previous file's line number  */
    pF->fl_file = Fp;           /*  the new file descriptor  */
    pF->fl_buffer = p;
    pF->fl_pwchBuffer = pwch;
    pF->fl_numread = 0;
    pF->fl_totalread = 0;

    //- Added to support 16-bit files.
    //- 8-2-91 David Marsyla.
    pF->fl_fFileType = DetermineFileType (Fp);

    //- The file type is unknown, warn them and then take a stab at an
    //- 8-bit file.  8-2-91 David Marsyla.
    if (pF->fl_fFileType == DFT_FILE_IS_UNKNOWN) {
        Msg_Temp = GET_MSG (4413);
        SET_MSG (Msg_Text, Msg_Temp, newname);
        warning (4413);
        pF->fl_fFileType = DFT_FILE_IS_8_BIT;
    }

    vfCurrFileType = pF->fl_fFileType;

    Current_char = (ptext_t)p;
    io_eob();                   /*  fill the buffer  */
    /*
    * Note that include filenames will live the entire compiland. This
    * puts the burden on the user with MANY include files.  Any other
    * scheme takes space out of static data.
    * Notice also, that we save the previous filename in the new file's
    * fl_name.
    */
    pF->fl_name = pstrdup(Filename);
    strncpy(Filebuff,newname,sizeof(Filebuff));
    Linenumber = 0; /*  do_newline() will increment to the first line */
    if (Eflag) {
        emit_line();
        fwrite("\n", 1, 1, OUTPUTFILE);     /* this line is inserted */
    }
    do_newline();   /*  a new file may have preproc cmd as first line  */
    return (TRUE);
}


/************************************************************************
 * FPOP - pop to a previous level of input stream
 *
 * ARGUMENTS - none
 *
 * RETURNS
 *	TRUE if successful, FALSE if the stack is empty
 *
 * SIDE EFFECTS
 *	- Linenumber is restored to the old files line number
 *	- Filename is reset to the old filename
 *  - frees storage allocated for filename
 *
 * DESCRIPTION
 *	Pop the top of the file stack, restoring the previous input stream.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
UCHAR fpop(void)
{
    int Old_line;

    if (Findex == -1) {      /* no files left */
        return (FALSE);
    }
    fclose(Fp);

    strappend(Filebuff,Fstack[Findex].fl_name);
    Old_line = Linenumber;
    Linenumber = (int)Fstack[Findex].fl_lineno;
    Current_char = Fstack[Findex].fl_currc;
    if (--Findex < 0) {          /* popped the last file */
        Linenumber = Old_line;
        return (FALSE);
    }
    Fp = Fstack[Findex].fl_file;
    vfCurrFileType = Fstack[Findex].fl_fFileType;
    if (Findex >= 2) {           /* popped off a deeply nested include */
        io_eob();
    }
    if (Eflag) {
        emit_line();
    }
    return (TRUE);
}


/************************************************************************
**  nested_include : searches the parentage list of the currently
**		open files on the stack when a new include file is found.
**		Input : ptr to include file name.
**		Output : TRUE if the file was found, FALSE if not.
*************************************************************************/
int nested_include(void)
{
    PUCHAR  p_tmp1;
    PUCHAR  p_file;
    PUCHAR  p_slash;
    int         tos;

    tos = Findex;
    p_file = Filename;      /* always start with the current file */
    for (;;) {
        p_tmp1 = p_file;
        p_slash = NULL;
        while (*p_tmp1) {    /* pt to end of filename, find trailing slash */
            if (CHARMAP(*p_tmp1) == LX_LEADBYTE) {
                p_tmp1++;
            } else if (strchr(Path_chars, *p_tmp1)) {
                p_slash = p_tmp1;
            }
            p_tmp1++;
        }
        if (p_slash) {
            p_tmp1 = Reuse_1;
            while (p_file <= p_slash) {  /*  we want the trailing '/'  */
                *p_tmp1++ = *p_file++;  /*  copy the parent directory  */
            }
            p_file = yylval.yy_string.str_ptr;
            while ((*p_tmp1++ = *p_file++)!=0) {  /*append include file name  */
                ;   /*  NULL  */
            }
        } else {
            SET_MSG(Reuse_1,"%s",yylval.yy_string.str_ptr);
        }
        if (newinput(Reuse_1,MAY_OPEN)) {
            return (TRUE);
        }
        if (tos <= 0) {
            break;
        }
        p_file = Fstack[tos--].fl_name;
    }
    return (FALSE);
}


/************************************************************************/
/* esc_sequence()							*/
/************************************************************************/
ptext_t esc_sequence(ptext_t dest, ptext_t name)
{
    *dest = '"';
    while ((*++dest = *name) != 0) {
        switch ( CHARMAP(*name) ) {
            case LX_EOS:
                *++dest = '\\';
                break;
            case LX_LEADBYTE:
                *++dest = *++name;
                break;
        }
        name++;
    }
    *dest++ = '"';      /* overwrite null */
    return ( dest );
}


/************************************************************************/
/* emit_line()								*/
/************************************************************************/
void   emit_line(void)
{
    char linebuf[16];
    ptext_t p;

    SET_MSG(linebuf, "#line %d ", Linenumber+1);
    fwrite(linebuf, strlen(linebuf), 1, OUTPUTFILE);
    p = esc_sequence(Reuse_1, Filename);
    fwrite(Reuse_1, (size_t)(p - Reuse_1), 1, OUTPUTFILE);
}

//-
//- wchCheckWideChar - This functions was added to support 16-bit input files.
//-     It is the equivalent of CHECKCH() but it locates the current position
//-     in the wide character buffer and then returns the stored character.
//-	8-2-91 David Marsyla.
//-

unsigned short wchCheckWideChar (void)
{
    WCHAR   *pwch;
    TEXT_TYPE   p;

    //- Get pointers to both buffers.
    pwch = Fstack[Findex].fl_pwchBuffer;
    p = Fstack[Findex].fl_buffer;

    //- Find the equivalent offset from the beginning of the pwch buffer.

    pwch += (Current_char - (ptext_t)p);

    return (*pwch);
}

/************************************************************************
**  io_eob : handle getting the next block from a file.
**  return TRUE if this is the real end of the buffer, FALSE if we have
**  more to do.
************************************************************************/
int io_eob(void)
{
    int     n;
    TEXT_TYPE   p;
    WCHAR   *pwch;

    p = Fstack[Findex].fl_buffer;
    pwch = Fstack[Findex].fl_pwchBuffer;
    if ((Current_char - (ptext_t)p) < Fstack[Findex].fl_numread) {
        /*
        **  haven't used all the chars from the buffer yet.
        **  (some clown has a null/cntl z embedded in his source file.)
        */
        if (PREVCH() == CONTROL_Z) { /* imbedded control z, real eof */
            UNGETCH();
            return (TRUE);
        }
        return (FALSE);
    }
    Current_char = p;

    //-
    //- The following section was added to support 16-bit resource files.
    //- It will just convert them to 8-bit files that the Resource Compiler
    //- can read.  Here is the basic strategy used.  An 8-bit file is
    //- read into the normal buffer and should be processed the old way.
    //- A 16-bit file is read into a wide character buffer identical to the
    //- normal 8-bit one.  The entire contents are then copied to the 8-bit
    //- buffer and processed normally.  The one exception to this is when
    //- a string literal is encountered.  We then return to the 16-bit buffer
    //- to read the characters.  These characters are written as backslashed
    //- escape characters inside an 8-bit string.  (ex. "\x004c\x523f").
    //- I'll be the first person to admit that this is an ugly solution, but
    //- hey, we're Microsoft :-).  8-2-91 David Marsyla.
    //-
    if (Fstack[Findex].fl_fFileType == DFT_FILE_IS_8_BIT) {

        n = fread (p, sizeof (char), Fstack[Findex].fl_bufsiz, Fp);

    } else {

        n = fread (pwch, sizeof (WCHAR), Fstack[Findex].fl_bufsiz, Fp);

        //-
        //- If the file is in reversed format, swap the bytes.
        //-
        if (Fstack[Findex].fl_fFileType == DFT_FILE_IS_16_BIT_REV && n > 0) {
            WCHAR  *pwchT = pwch;
            BYTE  jLowNibble;
            BYTE  jHighNibble;
            INT   cNumWords = n;

            while (cNumWords--) {
                jLowNibble = (BYTE)(*pwchT & 0xFF);
                jHighNibble = (BYTE)((*pwchT >> 8) & 0xFF);

                *pwchT++ = (WCHAR)(jHighNibble | (jLowNibble << 8));
            }
        }


        //-
        //- The following block will copy the 16-bit buffer to the 8-bit
        //- buffer.  It does this by truncating the 16-bit character.  This
        //- will cause information loss but we will keep the 16-bit buffer
        //- around for when we need to look at any string literals.
        //-
        if (n > 0) {
            char   *pchT = p;
            WCHAR  *pwchT = pwch;
            INT    cNumWords = n;

            while (cNumWords--) {

                *pchT++ = (char)*pwchT++;
            }
        }
    }

    /*
    **  the total read counts the total read *and* used.
    */
    Fstack[Findex].fl_totalread += Fstack[Findex].fl_numread;
    Fstack[Findex].fl_numread = n;
    if (n != 0) {               /* we read something */
        *(p + n) = EOS_CHAR;    /* sentinal at the end */
        *(pwch + n) = EOS_CHAR; /* sentinal at the end */
        return (FALSE);          /* more to do */
    }
    *p = EOS_CHAR;              /* read no chars */
    *pwch = EOS_CHAR;               /* read no chars */
    return (TRUE);               /* real end of buffer */
}


/************************************************************************
**  p0_init : inits for prepocessing.
**		Input : ptr to file name to use as input.
**			ptr to LIST containing predefined values.
**					 ( -D's from cmd line )
**
**  Note : if "newinput" cannot open the file,
**		  it gives a fatal msg and exits.
**
************************************************************************/
void p0_init(char *p_fname, char *p_outname, LIST *p_defns)
{
    REG char    *p_dstr;
    REG char    *p_eq;
    int     ntop;

    CHARMAP(LX_FORMALMARK) = LX_MACFORMAL;
    CHARMAP(LX_FORMALSTR) = LX_STRFORMAL;
    CHARMAP(LX_FORMALCHAR) = LX_CHARFORMAL;
    CHARMAP(LX_NOEXPANDMARK) = LX_NOEXPAND;
    if (EXTENSION) {
        /*
        **	'$' is an identifier character under extensions.
        */
        CHARMAP('$') = LX_ID;
        CONTMAP('$') = LXC_ID;
    }

    for (ntop = p_defns->li_top; ntop < MAXLIST; ++ntop) {
        p_dstr = p_defns->li_defns[ntop];
        p_eq = Reuse_1;
        while ((*p_eq = *p_dstr++) != 0) {  /* copy the name to Reuse_1 */
            if (CHARMAP(*p_eq) == LX_LEADBYTE) {
                *++p_eq = *p_dstr++;
            } else if (*p_eq == '=') { /* we're told what the value is */
                break;
            }
            p_eq++;
        }
        if (*p_eq == '=') {
            char    *p_tmp;
            char    *last_space = NULL;

            *p_eq = '\0';       /* null the = */
            for (p_tmp = p_dstr; *p_tmp; p_tmp++) {  /* find the end of it */
                if (CHARMAP(*p_tmp) == LX_LEADBYTE) {
                    p_tmp++;
                    last_space = NULL;
                } else if (isspace(*p_tmp)) {
                    if (last_space == NULL) {
                        last_space = p_tmp;
                    }
                } else {
                    last_space = NULL;
                }
            }
            if (last_space != NULL) {
                *last_space = '\0';
            }
            Reuse_1_hash = local_c_hash(Reuse_1);
            Reuse_1_length = strlen(Reuse_1) + 1;
            if ( *p_dstr ) { /* non-empty string */
                definstall(p_dstr, (strlen(p_dstr) + 2), FROM_COMMAND);
            } else {
                definstall((char *)0, 0, 0);
            }
        } else {
            Reuse_1_hash = local_c_hash(Reuse_1);
            Reuse_1_length = strlen(Reuse_1) + 1;
            definstall("1\000", 3, FROM_COMMAND);   /* value of string is 1 */
        }
    }

    if ((OUTPUTFILE = fopen (p_outname, "w+")) == NULL) {
        Msg_Temp = GET_MSG (1023);
        SET_MSG (Msg_Text, Msg_Temp);
        fatal (1023);
    }

    newinput(p_fname,MUST_OPEN);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\p0io.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0IO.H - Preprocessor I/O macros					*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/
#define	MUST_OPEN	1
#define	MAY_OPEN	0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\rcppext.h ===
extern	char 	Union_str[];
extern	char 	Struct_str[];
extern	char 	Cdecl_str[];
extern	char 	Cdecl1_str[];
extern	char 	Fortran_str[];
extern	char 	Fortran1_str[];
extern	char 	Pascal_str[];
extern	char 	Pascal1_str[];
extern	char 	PPelse_str[];
extern	char 	PPendif_str[];
extern	char 	PPifel_str[];
extern	char 	Syntax_str[];

extern	FILE	* ErrFile;
extern	FILE 	* Errfl;
extern	FILE	* OUTPUTFILE;

extern	char	* A_string;
extern	char	* Debug;
extern	char	* Input_file;
extern	char	* Output_file;
extern	char	* Q_string;
extern	char	* Version;
extern  char    * gpszNLSoptions;
extern	int		In_alloc_text;
extern	int		Bad_pragma;
extern	int		Cross_compile;
extern	int		Ehxtension;
extern	int		HugeModel;
extern	LIST	Defs;
extern	LIST	Includes;
extern	lextype_t yylval;
extern	token_t	Basic_token;
extern	char	* BTarray[];
extern	char	* Basename;
extern	char	* ErrFilName;
extern	char	* Path_chars;
extern	int		Char_align;
extern	int		Dump_tables;
extern	int		StunOpSeen;
extern	int		Inteltypes;
extern	int		List_type;
extern	int		Need_enddata;
extern	int		Nerrors;
extern	int		NoPasFor;

extern	int		Cmd_intrinsic;
extern	int		Cmd_pointer_check;
extern	int		Pointer_check;
extern	int		Cmd_stack_check;
extern	int		Stack_check;
extern	int		Cmd_loop_opt;
extern	int		Loop_opt;
extern	int		Cmd_pack_size;
extern	int		Pack_size;

extern	int		N_types;
extern	int		Got_type;
extern	int		Out_funcdef;
extern	int		Plm;
extern	int		Prep;
extern	int		Prep_ifstack;
extern	int		Ret_seen;
extern	int		Srclist;
extern	int		Stack_depth;
extern	int		Symbolic_debug;
extern	int		Table_index;
extern	int		Switch_check;
extern	int		Load_ds_with;
extern	int		Plmn;
extern	int		Plmf;
extern	int 	Cflag;
extern	int 	Eflag;
extern	int 	Jflag;
extern	int 	Pflag;
extern	int 	Rflag;
extern	int		ZcFlag;
extern	int		StunDepth;

extern	long	Enum_val;
extern	char	Size_of[];
extern	long	Max_ival[];
extern	table_t	*Table_stack[];

extern	int		Extension;

extern	char	*Filename;
extern	int		Linenumber;
extern	UCHAR	Filebuff[MED_BUFFER + 1];
extern	UCHAR	Reuse_1[BIG_BUFFER];
extern	hash_t	Reuse_1_hash;
extern	UINT	Reuse_1_length;
extern	UCHAR	Macro_buffer[BIG_BUFFER * 4];
extern	int		In_define;
extern	int		InIf;
extern	int		InInclude;
extern	int		Macro_depth;
extern	int		On_pound_line;
extern	int		Listing_value;
extern	token_t	Currtok;

extern	long		Currval;
extern	int		Comment_type;
extern	char		*Comment_string;
extern	int		Tiny_lexer_nesting;
extern	UCHAR		*Exp_ptr;
extern	int		ifstack[IFSTACK_SIZE];

extern unsigned char	Contmap[], Charmap[];

extern keytab_t		Tokstrings[];

#define EXTENSION	(Extension || Ehxtension)

/*** I/O Variable for PreProcessor ***/
extern	ptext_t	Current_char;

/*** w-BrianM - Re-write of fatal(), error() ***/
extern char	Msg_Text[];
extern char *	Msg_Temp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\p0prepro.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0PREPRO.C - Main Preprocessor					*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"
#include "charmap.h"
#include "grammar.h"
#include "trees.h"
#include "p1types.h"

/************************************************************************/
/* Internal constants							*/
/************************************************************************/
#define GOT_IF			1	/* last nesting command was an if.. */
#define GOT_ELIF		2	/* last nesting command was an if.. */
#define GOT_ELSE		3	/* last nesting command was an else */
#define	GOT_ENDIF		4	/* found endif */
#define ELSE_OR_ENDIF		5	/* skip to either #else or #endif */
#define ENDIF_ONLY		6	/* skip to #endif -- #else is an error*/

int	ifstack[IFSTACK_SIZE];


/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
void chk_newline(PCHAR);
void in_standard(void);
int incr_ifstack(void);
token_t next_control(void);
void pragma(void);
int skipto(int);
void skip_quoted(int);
PUCHAR sysinclude(void);


/************************************************************************/
/* incr_ifstack - Increment the IF nesting stack			*/
/************************************************************************/

int incr_ifstack(void)
{
    if(++Prep_ifstack >= IFSTACK_SIZE) {
	Msg_Temp = GET_MSG (1052);
	SET_MSG (Msg_Text, Msg_Temp);
	fatal (1052);
    }
    return(Prep_ifstack);
}


/************************************************************************
 * SYSINCLUDE - process a system include : #include <foo>
 *
 * ARGUMENTS - none
 *
 * RETURNS - none
 *
 * SIDE EFFECTS - none
 *
 * DESCRIPTION  
 *	Get the system include file name.  Since the name is not a "string",
 *	the name must be built much the same as the -E option rebuilds the text
 *	by using the Tokstring expansion for tokens with no expansion already
 *
 *  NOTE : IS THIS ANSI? note we're just reading chars, and not expanding
 * any macros. NO, it's not. it must expand the macros.
 * TODO : have it call yylex() unless and until it finds a '>' or a newline.
 * (probably have to set On_pound_line to have yylex return the newline.)
 *
 * AUTHOR
 *			Ralph Ryan	Sep. 1982
 *
 * MODIFICATIONS - none
 *
 *
 ************************************************************************/
PUCHAR sysinclude(void)
{
    REG	int		c;
    REG	char	*p_fname;

    p_fname = Reuse_1;
    c = skip_cwhite();
    if( c == '\n' ) {
	UNGETCH();
	Msg_Temp = GET_MSG (2012);
    	SET_MSG (Msg_Text, Msg_Temp);
	error(2012);	/* missing name after '<' */
	return(NULL);
    }
    while( c != '>' && c != '\n' ) {
	*p_fname++ = (UCHAR)c;		/* check for buffer overflow ??? */
	c = get_non_eof();
    }
    if( c == '\n' ) {
	UNGETCH();
	Msg_Temp = GET_MSG (2013);
    	SET_MSG (Msg_Text, Msg_Temp);
	error(2013);	/* missing '>' */
	return(NULL);
    }
    if(p_fname != Reuse_1) {
	p_fname--;
	while((p_fname >= Reuse_1) && isspace(*p_fname)) {
	    p_fname--;
	}
	p_fname++;
    }
    *p_fname = '\0';
    return(Reuse_1);
}


/************************************************************************
**  preprocess : the scanner found a # which was the first non-white char
**  on a line.
************************************************************************/
void   preprocess(void)
{
    REG		UCHAR	c;
    long		eval;
    int			condition;
    token_t		deftok;
    hln_t		identifier;

    if(Macro_depth != 0) {	/* # only when not in a macro */
	return;
    }
    switch(CHARMAP(c = skip_cwhite())) {
    case LX_ID:
	getid(c);
	HLN_NAME(identifier) = Reuse_1;
	HLN_LENGTH(identifier) = (UCHAR)Reuse_1_length;
	HLN_HASH(identifier) = Reuse_1_hash;
	break;
    case LX_NL:
	UNGETCH();
	return;
    default:
	Msg_Temp = GET_MSG (2019);
    	SET_MSG (Msg_Text, Msg_Temp, c);
	error(2019);	/* unknown preprocessor command */
	skip_cnew();	/* finds a newline */
	return;
    }

    On_pound_line = TRUE;
start:
    switch(deftok = is_pkeyword(HLN_IDENTP_NAME(&identifier))) {
	int			old_prep;

    case P0_DEFINE :
	define();
	break;
    case P0_LINE :
	old_prep = Prep;
	Prep = FALSE;
	yylex();
	if(Basic_token != L_CINTEGER) {		/* #line needs line number */
	    Msg_Temp = GET_MSG (2005);
    	    SET_MSG (Msg_Text, Msg_Temp, TS_STR(Basic_token));
	    error(2005);	/* unknown preprocessor command */
	    Prep = old_prep;
	    skip_cnew();
	    On_pound_line = FALSE;
	    return;
	}
	/*
	**  -1 because there's a newline at the end of this line
	**  which will be counted later when we find it.
	**  the #line says the next line is the number we've given
	*/
	Linenumber = TR_LVALUE(yylval.yy_tree) - 1;
	yylex();
	Prep = old_prep;
	switch(Basic_token) {
	case L_STRING:
	    if( strcmp(Filename, yylval.yy_string.str_ptr) != 0) {
		strncpy(Filename,
		    yylval.yy_string.str_ptr,
		    sizeof(Filebuff)
		    );
	    }
	case L_NOTOKEN:
	    break;
	default:
	    Msg_Temp = GET_MSG (2130);
    	    SET_MSG (Msg_Text, Msg_Temp, TS_STR(Basic_token));
	    error(2130);	 /* #line needs a string */
	    skip_cnew();
	    On_pound_line = FALSE;
	    return;
	    break;
	}
	emit_line();
	chk_newline("#line");
	break;
    case P0_INCLUDE :
	old_prep = Prep;
	Prep = FALSE;
	InInclude = TRUE;
	yylex();
	InInclude = FALSE;
	Prep = old_prep;
	switch(Basic_token) {
	case L_LT:
	    if((sysinclude()) == NULL) {
		skip_cnew();
		On_pound_line = FALSE;
		return;
		break;		/* error already emitted */
	    }
	    yylval.yy_string.str_ptr = Reuse_1;
	    break;
	case L_STRING:
	    break;
	default:
	    Msg_Temp = GET_MSG (2006);
    	    SET_MSG (Msg_Text, Msg_Temp, TS_STR(Basic_token));
	    error(2006);	/* needs file name */
	    skip_cnew();
	    On_pound_line = FALSE;
	    return;
	    break;
	}
	chk_newline("#include");
	if( strchr(Path_chars, *yylval.yy_string.str_ptr) ||
	    (strchr(Path_chars, ':') && (yylval.yy_string.str_ptr[1] == ':'))) {
	    /*
	    **  we have a string which either has a 1st char which is a path
	    **  delimiter or, if ':' is a path delimiter (DOS), which has
	    **  "<drive letter>:" as the first two characters.  Such names
	    **  specify a fully qualified pathnames. Do not append the search
	    **  list, just look it up.
	    */
	    if( ! newinput(yylval.yy_string.str_ptr,MAY_OPEN)) {
		Msg_Temp = GET_MSG (1015);
		SET_MSG (Msg_Text, Msg_Temp, yylval.yy_string.str_ptr);
		fatal (1015); /* can't find include file */
	    }
	}
	else if( (Basic_token != L_STRING) || (! nested_include())) {
	    in_standard();
	}
	break;
    case P0_IFDEF :
    case P0_IFNDEF :
	if(CHARMAP(c = skip_cwhite()) != LX_ID) {
	    Msg_Temp = GET_MSG (1016);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal (1016);
	}
	getid(c);
	eval = (get_defined()) ? TRUE : FALSE;
	chk_newline((deftok == P0_IFDEF) ? "#ifdef" : "#ifndef");
	if(deftok == P0_IFNDEF) {
	    eval = ( ! eval );
	}
	if(	eval
	    ||
	    ((condition = skipto(ELSE_OR_ENDIF)) == GOT_ELSE)
	    ) {
	    /*
	**  expression is TRUE or when we skipped the false part
	**  we found a #else that will be expanded.
	*/
	    ifstack[incr_ifstack()] = GOT_IF;
	}
	else if(condition == GOT_ELIF) {
	    /* hash is wrong, but it won't be used */
	    HLN_NAME(identifier) = "if";		/* sleazy HACK */
	    goto start;
	}
	break;
    case P0_IF :
	old_prep = Prep;
	Prep = FALSE;
	InIf = TRUE;
	eval = do_constexpr();
	InIf = FALSE;
	Prep = old_prep;
	chk_newline(PPifel_str /* "#if/#elif" */);
	if(	(eval)
	    ||
	    ((condition = skipto(ELSE_OR_ENDIF)) == GOT_ELSE)
	    ) {
	    /*
		**  expression is TRUE or when we skipped the false part
		**  we found a #else that will be expanded.
		*/
	    ifstack[incr_ifstack()] = GOT_IF;
	    if(Eflag && !eval)
		emit_line();
	}
	/*
	**  here the #if's expression was false, so we skipped until we found
	**  an #elif. we'll restart and fake that we're processing a #if
	*/
	else {
	    if(Eflag)
		emit_line();
	    if(condition == GOT_ELIF) {
		/* hash is wrong, but it won't be needed */
		HLN_NAME(identifier) = "if";		/* sleazy HACK */
		goto start;
	    }
	}
	break;
    case P0_ELIF :
	/*
		**  here, we have found a #elif. first check to make sure that
		**  this is not an occurrance of a #elif with no preceding #if.
		**  (if Prep_ifstack < 0) then there is no preceding #if.
		*/
	if(Prep_ifstack-- < 0) {
	    Msg_Temp = GET_MSG (1018);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal (1018);
	}
		/*
		**  now, the preceding #if/#elif was true, and we've
		**  just found the next #elif. we want to skip all #else's
		**  and #elif's from here until we find the enclosing #endif
		*/
	while(skipto(ELSE_OR_ENDIF) != GOT_ENDIF) {
	    ;
	}
	if(Eflag)
	    emit_line();
	break;
    case P0_ELSE :	/*  the preceding #if/#elif was true  */
	if((Prep_ifstack < 0) || (ifstack[Prep_ifstack--] != GOT_IF)) {
	    Msg_Temp = GET_MSG (1019);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal (1019); /*  make sure there was one  */
	}
	chk_newline(PPelse_str /* "#else" */);
	skipto(ENDIF_ONLY);
	if(Eflag)
	    emit_line();
	break;
    case P0_ENDIF :	/*  only way here is a lonely #endif  */
	if(Prep_ifstack-- < 0) {
	    Msg_Temp = GET_MSG (1020);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal (1020);
	}
	if(Eflag)
	    emit_line();
	chk_newline(PPendif_str /* "#endif" */);
	break;
    case P0_PRAGMA :
	pragma();
	break;
    case P0_UNDEF :
	if(CHARMAP(c = skip_cwhite()) != LX_ID) {
	    Msg_Temp = GET_MSG (4006);
    	    SET_MSG (Msg_Text, Msg_Temp);
	    warning(4006);	/* missing identifier on #undef */
	}
	else {
	    getid(c);
	    undefine();
	}
	chk_newline("#undef");
	break;
    case P0_ERROR:
	{
	    PUCHAR	p;

	    p = Reuse_1;
	    while((c = get_non_eof()) != LX_EOS) {
		if(c == '\n') {
		    UNGETCH();
		    break;
		}
		*p++ = c;
	    }
	    *p = '\0';
	}
	Msg_Temp = GET_MSG (2188);
    	SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	error(2188);
	chk_newline("#error");
	break;
    case P0_IDENT:
	old_prep = Prep ;
	Prep = FALSE;
	yylex();
	Prep = old_prep;
	if(Basic_token != L_STRING) {
	    Msg_Temp = GET_MSG (4079);
    	    SET_MSG (Msg_Text, Msg_Temp, TS_STR(Basic_token));
	    warning(4079);
	}
	chk_newline("#error");
	break;
    case P0_NOTOKEN:
	Msg_Temp = GET_MSG (1021);
	SET_MSG (Msg_Text, Msg_Temp, HLN_IDENTP_NAME(&identifier));
	fatal (1021);
	break;
    }
    On_pound_line = FALSE;
}


/************************************************************************ 
 * SKIPTO - skip code until the end of an undefined block is reached.
 *
 * ARGUMENTS
 *	short key - skip to an ELSE or ENDIF or just an ENDIF
 *
 * RETURNS  - none
 *
 * SIDE EFFECTS  
 *	- throws away input
 *
 * DESCRIPTION  
 *	The preprocessor is skipping code between failed ifdef, etc. and
 *	the corresponding ELSE or ENDIF (when key == ELSE_OR_ENDIF).
 *	Or it is skipping code between a failed ELSE and the ENDIF (when
 *	key == ENDIF_ONLY).
 *
 * AUTHOR - Ralph Ryan, Sept. 16, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int skipto(int key)
{
    REG	int		level;
    REG	token_t	tok;

    level = 0;
    tok = P0_NOTOKEN;
    for(;;) {
	/* make sure that IF [ELSE] ENDIF s are balanced */
	switch(next_control()) {
	case P0_IFDEF:
	case P0_IFNDEF:
	case P0_IF:
	    level++;
	    break;
	case P0_ELSE:
	    tok = P0_ELSE;
	    /*
			**  FALLTHROUGH
			*/
	case P0_ELIF:
	    /*
	    **  we found a #else or a #elif. these have their only chance
	    **  at being valid if they're at level 0.
	    **  if we're at any other level,
	    **  then this else/elif belongs to some other #if and we skip them.
	    **  if we were looking for an endif, the we have an error.
	    */
	    if(level != 0) {
		tok = P0_NOTOKEN;
		break;
	    }
	    if(key == ENDIF_ONLY) {
		Msg_Temp = GET_MSG (1022);
		SET_MSG (Msg_Text, Msg_Temp);
		fatal (1022);	/* expected #endif */
	    }
	    else if(tok == P0_ELSE) {
		chk_newline(PPelse_str /* "#else" */);
		return(GOT_ELSE);
	    }
	    else {
		return(GOT_ELIF);
	    }
	    break;
	case P0_ENDIF:
	    if(level == 0) {
		chk_newline(PPendif_str /* "#endif" */);
		return(GOT_ENDIF);
	    }
	    else {
		level--;
	    }
	    break;
	}
    }
}


/*************************************************************************
**  in_standard : search for the given file name in the directory list.
**		Input : ptr to include file name.
**		Output : fatal error if not found.
*************************************************************************/
void in_standard(void)
{
    int		i;
    int		stop;
    char	*p_dir;
    char	*p_file;
    char	*p_tmp;

    stop = Includes.li_top;

    for(i = MAXLIST-1; i >= stop; i--) {
	p_file = yylval.yy_string.str_ptr;
	if( ((p_dir = Includes.li_defns[i])!=0) &&(strcmp(p_dir, "./") != 0) ) {
	    /*
	    **  there is a directory to prepend and it's not './'
	    */
	    p_tmp = Exp_ptr;
	    while((*p_tmp++ = *p_dir++) != 0)
		;
	    /*
		**  above loop increments p_tmp past null.
		**  this replaces that null with a '/' if needed.  Not needed if the
		**  last character of the directory spec is a path delimiter.
		**  we then point to the char after the '/'
		*/
	    if(strchr(Path_chars, p_dir[-2]) == 0) {
		p_tmp[-1] = '/';
	    }
	    else {
		--p_tmp;
	    }
	    while((*p_tmp++ = *p_file++) != 0)
		;
	    p_file = Exp_ptr;
	}
	if(newinput(p_file,MAY_OPEN)) {	/* this is the non-error way out */
	    return;
	}
    }
    Msg_Temp = GET_MSG (1015);
    SET_MSG (Msg_Text, Msg_Temp, yylval.yy_string.str_ptr);
    fatal (1015);	/* can't find include file */
}


/*************************************************************************
**  chk_newline : check for whitespace only before a newline.
**  eat the newline.
*************************************************************************/
void chk_newline(PCHAR cmd)
{
    if(skip_cwhite() != '\n') {
	Msg_Temp = GET_MSG (4067);
    	SET_MSG (Msg_Text, Msg_Temp, cmd);
	warning(4067);		/* cmd expected newline */
	skip_cnew();
    }
    else {
	UNGETCH();
    }
}

/*************************************************************************
**  skip_quoted : skips chars until it finds a char which matches its arg.
*************************************************************************/
void skip_quoted(int sc)
{
    REG	UCHAR		c;

    for(;;) {
	switch(CHARMAP(c = GETCH())) {
	case LX_NL:
	    Msg_Temp = GET_MSG (4093);
    	    SET_MSG (Msg_Text, Msg_Temp);
	    warning(4093);
	    UNGETCH();
	    return;
	    break;
	case LX_DQUOTE:
	case LX_SQUOTE:
	    if(c == (UCHAR)sc)
		return;
	    break;
	case LX_EOS:
	    if(handle_eos() == BACKSLASH_EOS) {
		SKIPCH();	/* might be /" !! */

	    }
	    break;
	case LX_LEADBYTE:	
	    get_non_eof();			
	    break;
	}
    }
}


/*************************************************************************
**  next_control : find a newline. find a pound sign as the first non-white.
**  find an id start char, build an id look it up and return the token.
**  this knows about strings/char const and such.
*************************************************************************/
token_t	  next_control(void)
{
    REG	UCHAR		c;

    for(;;) {
	c = skip_cwhite();
first_switch:
	switch(CHARMAP(c)) {
	case LX_NL:
	    Linenumber++;
	    if(Prep) {
		fputc('\n', OUTPUTFILE);
	    }
	    if((c = skip_cwhite()) == '#') {
		if(LX_IS_IDENT(c = skip_cwhite())) {
		    /*
		    **  this is the only way to return to the caller.
		    */
		    getid(c);
		    return(is_pkeyword(Reuse_1));	/* if its predefined  */
		}
	    }
	    goto first_switch;
	    break;
	case LX_DQUOTE:
	case LX_SQUOTE:
	    skip_quoted(c);
	    break;
	case LX_EOS:
	    if(handle_eos() == BACKSLASH_EOS) {
		SKIPCH();	/* might be \" !! */
	    }
	    break;
	}
    }
}


/*************************************************************************
**  do_defined : does the work for the defined(id)
**		should parens be counted, or just be used as delimiters (ie the
**		first open paren matches the first close paren)? If this is ever
**		an issue, it really means that there is not a legal identifier
**		between the parens, causing an error anyway, but consider:
**		#if (defined(2*(x-1))) || 1
**		#endif
**		It is friendlier to allow compilation to continue
*************************************************************************/
int	do_defined(PUCHAR p_tmp)
{
    REG	UINT	c;
    REG	int		value=0;
    int		paren_level = 0;

    /*
	** we want to allow:
	**	#define FOO			defined
	**	#define BAR(a,b)	a FOO | b
	**	#define	SNAFOO		0
	**	#if FOO BAR
	**	print("BAR is defined");
	**	#endif
	**	#if BAR(defined, SNAFOO)
	**	print("FOO is defined");
	**	#endif
	*/
    if(strcmp(p_tmp,"defined") != 0) {
	return(0);
    }
    if((!can_get_non_white()) && (Tiny_lexer_nesting == 0)) {
	/* NL encountered */
	return(value);
    }
    if((c = CHECKCH())== '(') {	/* assumes no other CHARMAP form of OPAREN */
	*Exp_ptr++ = (UCHAR)c;
	SKIPCH();
	paren_level++;
	if((!can_get_non_white()) && (Tiny_lexer_nesting == 0)) {
	    /* NL encountered */
	    return(value);
	}
    }
    if(Tiny_lexer_nesting>0) {
	if((CHARMAP(c=CHECKCH())==LX_MACFORMAL) || (CHARMAP(c)==LX_ID)) {
	    SKIPCH();
	    tl_getid((UCHAR)c);
	}
    }
    else {
	if(LX_IS_IDENT(c = CHECKCH())) {
	    SKIPCH();
	    if(Macro_depth >0) {
		lex_getid((UCHAR)c);
	    }
	    else {
		getid((UCHAR)c);
	    }
	    value = (get_defined()) ? TRUE : FALSE;
	}
	else {
	    if(paren_level==0) {
		Msg_Temp = GET_MSG (2003);
    		SET_MSG (Msg_Text, Msg_Temp);
		error(2003);
	    }
	    else {
		Msg_Temp = GET_MSG (2004);
    		SET_MSG (Msg_Text, Msg_Temp);
		error(2004);
	    }
	}
    }
    if((CHARMAP(c = CHECKCH()) == LX_WHITE) || (CHARMAP(c) == LX_EOS)) {
	if( ! can_get_non_white()) {
	    return(value);
	}
    }
    if(paren_level) {
	if((CHARMAP(c = CHECKCH()) == LX_CPAREN)) {
	    SKIPCH();
	    paren_level--;
	    *Exp_ptr++ = (UCHAR)c;
	}
    }
    if((paren_level > 0) && (Tiny_lexer_nesting == 0)) {
	Msg_Temp = GET_MSG (4004);
    	SET_MSG (Msg_Text, Msg_Temp);
	warning(4004);
    }
    return(value);
}


/*************************************************************************
 * NEXTIS - The lexical interface for #if expression parsing.
 * If the next token does not match what is wanted, return FALSE.
 * otherwise Set Currtok to L_NOTOKEN to force scanning on the next call.
 * Return TRUE.
 * will leave a newline as next char if it finds one.
 *************************************************************************/
int nextis(register token_t tok)
{
    if(Currtok != L_NOTOKEN) {
	if(tok == Currtok) {
	    Currtok = L_NOTOKEN;			/*  use up the token  */
	    return(TRUE);
	}
	else {
	    return(FALSE);
	}
    }
    switch(yylex()) {				/*  acquire a new token  */
    case 0:
	break;
    case L_CONSTANT:
	if( ! IS_INTEGRAL(TR_BTYPE(yylval.yy_tree))) {
		Msg_Temp = GET_MSG (1017);
    		SET_MSG (Msg_Text, Msg_Temp);
    		fatal (1017);
	}
	else {
	    Currval = TR_LVALUE(yylval.yy_tree);
	}
	if(tok == L_CINTEGER) {
	    return(TRUE);
	}
	Currtok = L_CINTEGER;
	break;
    case L_IDENT:
	Currval = do_defined(HLN_IDENTP_NAME(&yylval.yy_ident));
	if(tok == L_CINTEGER) {
	    return(TRUE);
	}
	Currtok = L_CINTEGER;
	break;
    default:
	if(tok == Basic_token) {
	    return(TRUE);
	}
	Currtok = Basic_token;
	break;
    }
    return(FALSE);
}


/************************************************************************
**  skip_cnew : reads up to and including the next newline.
************************************************************************/
void   skip_cnew(void)
{
    for(;;) {
	switch(CHARMAP(GETCH())) {
	case LX_NL:		
	    UNGETCH();				
	    return;
	case LX_SLASH:	
	    skip_comment();			
	    break;
	case LX_EOS:	
	    handle_eos();			
	    break;
	}
    }
}


/************************************************************************
**  skip_NLonly : reads up to the next newline, disallowing comments
************************************************************************/
void   skip_NLonly(void)
{
    for(;;) {
	switch(CHARMAP(GETCH())) {
	case LX_NL:		
	    UNGETCH();				
	    return;
	case LX_EOS:	
	    handle_eos();			
	    break;
	}
    }
}


/************************************************************************
**  pragma : handle processing the pragma directive
**  called by preprocess() after we have seen the #pragma
**  and are ready to handle the keyword which follows.
************************************************************************/
void   pragma(void)
{
    if(Prep) {
	UCHAR	c;

	fwrite("#pragma", 7, 1, OUTPUTFILE);
	while((c = get_non_eof()) != '\n') {
	    fputc(c, OUTPUTFILE);
	}
	UNGETCH();
	return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\p0keys.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0KEYS.C - Keycode stuff						*/
/*									*/
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <string.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"

/************************************************************************/
/*  table for preprocessor id's						*/
/************************************************************************/
char	* Pkeyw_Table[] = {
#include "pkeyw.key"
};
char	Pkeyw_Index[] = {
#include        "pkeyw.ind"
};
struct	s_pkinfo	{
    token_t   	s_info;
} Pkeyw_Info[] = {
#include        "pkeyw.inf"
};


/************************************************************************/
/*  is_pkeyword : finds the token for the id if it's a preprocessor keyword.*/
/*  P0_NOTOKEN if not found.						*/
/************************************************************************/
token_t is_pkeyword(char *id)
{
    REG	char	**start;
    REG	char	**stop;
    char	*pi;

    if( (*id) < '_') {
	return(P0_NOTOKEN);
    }
    /*
	**  the indx table tells us the start of
	**  the words which begin with the first char if the id.
	**  the 'stop' is the index of the word which does not have the
	**  give char as it's first.
	**  we can start checking after the first char since, we *know* that
	**  they match (hence the additions 'id++' and (*start) + 1
	*/
    pi = &Pkeyw_Index[((*id) - '_')];
    for(start = &Pkeyw_Table[*pi++], stop = &Pkeyw_Table[*pi], id++;
        start != stop;
        start++
        ) {
	if(strcmp(*start, id) == 0) {
	    return(Pkeyw_Info[(start - &Pkeyw_Table[0])].s_info);
	}
    }
    return(P0_NOTOKEN);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\p0macros.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0MACROS.C - Preprocessor Macros definitions				*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <malloc.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"
#include "charmap.h"


/************************************************************************
**
**	WARNING:	gather_chars() depends ELIMIT being the boundary of
**		Macro_buffer.
************************************************************************/
#define	ACT_BUFFER		&Macro_buffer[0]
#define	EXP_BUFFER		&Macro_buffer[BIG_BUFFER * 2]
#define	EXP_PAD			5
#define ALIMIT			&Macro_buffer[BIG_BUFFER * 2]
#define ELIMIT			(&Macro_buffer[BIG_BUFFER * 4] - EXP_PAD)


/************************************************************************
**  actual argument lists are length preceeded strings which are copied
**  into ACT_BUFFER. the first argument is pt'd to by exp_actuals in the
**  expansion_t construct. the next actual is obtained by adding the length
**  of the current actual to the start of the current actual.
************************************************************************/
#define ACTUAL_SIZE(P)	(*(short *)(P))
#define	ACTUAL_TEXT(P)	((P) + sizeof(short))
#define	ACTUAL_NEXT(P)	((P) + ACTUAL_SIZE(P))

/************************************************************************
**	the formals are copied into the buffer similar to the actuals, except
**	the size is denoted by an unsigned char, instead of short
************************************************************************/
#define	FORMAL_SIZE(P)	(*(ptext_t)(P))
#define	FORMAL_TEXT(P)	((P) + sizeof(UCHAR))
#define	FORMAL_NEXT(P)	((P) + FORMAL_SIZE(P))

expansion_t	Macro_expansion[LIMIT_MACRO_DEPTH];

ptext_t	P_defn_start;
int		N_formals;
pdefn_t	Defn_level_0[LEVEL_0 + 1];


/************************************************************************
**	These are needed by p0scanner (Exp_ptr,Tiny_lexer_nesting)
************************************************************************/
ptext_t	Exp_ptr = EXP_BUFFER;		/* ptr to free exp space */
int		Tiny_lexer_nesting;	/* stay in tiny lexer or back to main */

static	ptext_t	Act_ptr = ACT_BUFFER;		/* ptr to free actuals space */
static	ptext_t	Save_Exp_ptr = EXP_BUFFER;	/* for buffering unbal parens */

static	ptext_t	P_actuals;		/* actuals for this (level) macro */
static	int		N_actuals;	/* number of actuals in invocation */
static	int		Macro_line;	/*  where we started the macro  */


/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
void	chkbuf(ptext_t);
ptext_t	do_strformal(void);
ptext_t	do_macformal(int *);
void	expand_actual(UCHAR);
void	expand_definition(void);
void	expand_macro(void);
void	fatal_in_macro(int);
ptext_t	gather_chars(ptext_t, UCHAR);
void	get_actuals(pdefn_t, int);
int	get_definition(void);
void	get_formals(void);
int	is_macro_arg(ptext_t);
void	move_to_actual(ptext_t, ptext_t);
void	move_to_exp(ptext_t);
void	move_to_exp_esc(int, ptext_t);
int	post_paste(void);
void	push_macro(pdefn_t);
int	redefn (ptext_t, ptext_t, int);
int	rescan_expansion(void);


/************************************************************************
** UNDEFINE - remove a symbol from the symbol table
**	No noise is made if the programmer attempts to undefine a predefined
**		macro, but it is not done.
************************************************************************/
void   undefine(void)
{
    pdefn_t	pdef;
    pdefn_t	prev;

    prev = NULL;
    pdef = Defn_level_0[Reuse_1_hash & LEVEL_0];
    while(pdef) {
	if(memcmp (Reuse_1, DEFN_IDENT(pdef), Reuse_1_length) == 0) {
	    if(PRE_DEFINED(pdef)) {
		Msg_Temp = GET_MSG (4112);
		SET_MSG (Msg_Text, Msg_Temp, Reuse_1, "#undef");
		warning(4112);
		break;
	    }
	    if(prev == NULL)	/*  match at head of list  */
		Defn_level_0[Reuse_1_hash & LEVEL_0] = DEFN_NEXT(pdef);
	    else
		DEFN_NEXT(prev) = DEFN_NEXT(pdef);
	    break;
	}
	prev = pdef;
	pdef = DEFN_NEXT(pdef);
    }
}


/************************************************************************
**  BEGIN DEFINE A MACRO {
************************************************************************/
void   define(void)
{
    UCHAR	c;

    if (! (LX_IS_IDENT(c = skip_cwhite())) ) {
	Msg_Temp = GET_MSG (2007);
	SET_MSG (Msg_Text, Msg_Temp);
        error (2007); /* #define syntax */
	skip_cnew();
	return;
    }
    getid(c);
    N_formals = 0;
    P_defn_start = Macro_buffer;
/*
**  the next character must be white space or an open paren
*/
first_switch:
    switch(CHARMAP(c = GETCH())) {
    case LX_OPAREN:			/*  we have formal parameters  */
	get_formals();		/*  changes N_formals and fills Macro_buffer */
	if(N_formals == 0) {/*  empty formal list  */
		/*
		**  we must special case this since the expand() reads in the
		**  actual arguments iff there are formal parameters. thus if we
		**	#define	foo()	bar()
		**		. . .
		**		foo()
		**  will expand as
		**		bar()()
		**  we put the right paren in to fool the expander into looking
		**  for actuals.
		*/
	    N_formals = -1;
	}
	break;
    case LX_WHITE:
	break;
    case LX_CR:
	goto first_switch;
    case LX_SLASH:
	if( ! skip_comment()) {
	    Msg_Temp = GET_MSG (2008);
            SET_MSG (Msg_Text, Msg_Temp, '/');
            error (2008);
	}
	break;
    case LX_NL:			/* no definition */
	UNGETCH();
	definstall((ptext_t)0, 0, 0);
	return;
	break;
    case LX_EOS:
	if(handle_eos() != BACKSLASH_EOS) {
	    goto first_switch;
	}
	/* got BACKSLASH_EOS */
	/*
	**  FALLTHROUGH
	*/
    default:
	Msg_Temp = GET_MSG (2008);
        SET_MSG (Msg_Text, Msg_Temp, c);
        error (2008); /* unexpected character in macro definition */
    }
    definstall(P_defn_start, get_definition(), N_formals);
}


/************************************************************************
**  get_formals : collect comma separated idents until the first closing paren
**  (the openning paren has already been read)
**  since we can't be in a macro when we're asked for this, we can be assured
**  that we can use a single buffer to collect all the formal names.
************************************************************************/
void   get_formals(void)
{
    UCHAR		c;
    ptext_t	p_stop;
    ptext_t	p_id;

    p_id = p_stop = FORMAL_TEXT(P_defn_start);
    for(;;) {
	switch(CHARMAP(c = skip_cwhite())) {
	case LX_ID:
	    if( p_id != p_stop ) {
		Msg_Temp = GET_MSG (2010);
        	SET_MSG (Msg_Text, Msg_Temp, c);
        	error (2010);
	    }
	    *p_stop++ = c;
	    for(;;) {
		while(LXC_IS_IDENT(c = GETCH())) {	/* while an id char */
		    *p_stop++ = c;			/* collect it */
		} if(c == EOS_CHAR) {
		 	/*
			**  found end of buffer marker, make sure it is,
			**  then handle it.
			*/
		    if(io_eob()) {	/* end of buffer in here is bad */
			Msg_Temp = GET_MSG (1004);
			SET_MSG (Msg_Text, Msg_Temp);
			fatal (1004);
		    }
		    continue;
		}
		if((c == '\\') && (checknl())) {
		    continue;
		}
		UNGETCH();
		break;
	    }
	    *p_stop++ = '\0';
	    break;
	case LX_COMMA:
	case LX_CPAREN:
	    if( p_stop > p_id ) {
		/* make sure an identifier was read */
		if((p_stop - p_id) >= TINY_BUFFER) {
		    p_id[TINY_BUFFER - 1] = '\0';
		    Msg_Temp = GET_MSG (4111);
		    SET_MSG (Msg_Text, Msg_Temp, p_id);
		    warning(4011);		/* id truncated */
		    p_stop = p_id + TINY_BUFFER;
		}
		if(is_macro_arg(p_id) >= 1) {
		    Msg_Temp = GET_MSG (2009);
        	    SET_MSG (Msg_Text, Msg_Temp, p_id);
		    error(2009);		/* reuse of formal */
		}
		else {
		    FORMAL_SIZE(P_defn_start) = (UCHAR)(p_stop - P_defn_start);
		    P_defn_start = p_stop;
		    N_formals++;
		}
	    }
	    else {
		if( (CHARMAP(c) == LX_COMMA) || (N_formals > 0) ) {
		    Msg_Temp = GET_MSG (2010);
        	    SET_MSG (Msg_Text, Msg_Temp, c);
		    error(2010);
		}
	    }
	    if( CHARMAP(c) == LX_CPAREN ) {
		return;
	    }
	    p_id = p_stop = FORMAL_TEXT(P_defn_start);
	    break;
	default:
	    Msg_Temp = GET_MSG (2010);
       	    SET_MSG (Msg_Text, Msg_Temp, c);
	    error(2010); /*  unexpected char in formal list */
	    break;
	}
    }
}


/************************************************************************
** definstall - Install a new definition. id is in Reuse_1.
**	p_text : ptr to the definition
**	n : number of bytes in the definition (may contain embedded nulls)
**	number : number of formals
************************************************************************/
void   definstall(ptext_t p_text, int n, int number)
{
    pdefn_t	p;

    if(n == 0) {
	p_text = NULL;
    }
    if( strcmp (Reuse_1, "defined") == 0) {
	Msg_Temp = GET_MSG (4112);
        SET_MSG (Msg_Text, Msg_Temp, Reuse_1, "#define");
	warning(4112);/* name reserved */
	return;
    }
    if((p = get_defined()) != 0) {
	if(PRE_DEFINED(p)) {
	    Msg_Temp = GET_MSG (4112);
            SET_MSG (Msg_Text, Msg_Temp, Reuse_1, "#define");
	    warning(4112);/* name reserved */
	    return;
	}
	else {
	    if(redefn(p_text, DEFN_TEXT(p), n)) {
		Msg_Temp = GET_MSG (4005);
                SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
		warning(4005);/* redefinition */
	    }
	    else {
		return;
	    }
	}
    }
    else {
	hln_t	ident;

	HLN_NAME(ident) = Reuse_1;
	HLN_HASH(ident) = Reuse_1_hash;
	HLN_LENGTH(ident) = (UCHAR)Reuse_1_length;
	p = malloc(sizeof(defn_t));
	if (p == NULL) {
	    Msg_Temp = GET_MSG (1002);
	    SET_MSG (Msg_Text, Msg_Temp);
	    error(1002);
	    return;
	}
	DEFN_IDENT(p) = HLN_TO_NAME(&ident);
	DEFN_NEXT(p) = Defn_level_0[Reuse_1_hash & LEVEL_0];
	DEFN_TEXT(p) = (char*)NULL;
	DEFN_EXPANDING(p) = 0;
	Defn_level_0[Reuse_1_hash & LEVEL_0] = p;
    }
    if(n != 0) {
	DEFN_TEXT(p) = pstrndup(p_text, n);
	if(number == FROM_COMMAND) {	/* special case from cmd line */
	    *(DEFN_TEXT(p) + n - 1) = EOS_DEFINITION;	/* for handle_eos */
	}
    }
    DEFN_NFORMALS(p) = (char)((number != FROM_COMMAND) ? number : 0);
}


/************************************************************************
**  get_defined : is the given id in the macro symbol table?
**  return a ptr to it if so, NULL if not.
************************************************************************/
pdefn_t	  get_defined(void)
{
    pdefn_t	pdef;

    for( pdef = Defn_level_0[Reuse_1_hash & LEVEL_0]; pdef;
        pdef = DEFN_NEXT(pdef)) 	{
	if(memcmp (Reuse_1, DEFN_IDENT(pdef), Reuse_1_length) == 0) {
	    return(pdef);
	}
    }
    return(NULL);
}


/************************************************************************
**  redefn : are the two definitions the same?
************************************************************************/
int redefn(REG	ptext_t p_new, ptext_t p_old, int n)
{
    if(p_old && p_new) {
	if(strncmp(p_new, p_old, n) == 0) {	/* strings are exact */
	    return(FALSE);
	}
	return(TRUE);
    }
    return((p_old != NULL) || (p_new != NULL));
}


/************************************************************************
**  get_definition : accumulate the macro definition, stops when it finds
**  a newline (it uses it). returns a ptr to the end of the string it builds.
**  builds the string in Macro_buffer. (given the start in P_defn_start)
************************************************************************/
int   get_definition(void)
{
    REG	ptext_t	p;
    UCHAR	c;
    int		stringize = FALSE;
    int		charize = FALSE;

    p = P_defn_start;
    c = skip_cwhite();
    for(;;) {
	chkbuf(p);
	switch(CHARMAP(c)) {
	case LX_EOS:
	    if(handle_eos() == BACKSLASH_EOS) {
		/* got backslash EOS */
		/* \<anything else> goes out as is.  The <anything else>
			* character must be emitted now, so that
			*		#define FOO(name)	\name
			*		. . .
			*		FOO(bar)
			*
			* does NOT see occurence of name in the definition as an
			* occurence of the formal param and emit \bar when it is
			* expanded later,but if the definition is \nname it will
			* find name as a formal paramater and emit \nbar
			*/
		*p++ = c;	/* put in backslash, break'll add new char */
		c = get_non_eof();
	    }
	    else {
		c = GETCH();
		continue;
	    }
	    break;
	case LX_NL:		/*  only way out  */
	    UNGETCH();
	    if(p == P_defn_start) {
		return(0);
	    }
	    chkbuf(p);
	    *p++ = EOS_CHAR;
	    *p++ = EOS_DEFINITION;	/* tells handle_eos defn finished */
	    return((int)(p - P_defn_start));/* p's last incr counts the 0*/
	    break;
	case LX_DQUOTE:
	case LX_SQUOTE:
	    p = gather_chars(p, c);
	    c = GETCH();
	    continue;
	    break;
	case LX_POUND:
split_op:
	    switch(CHARMAP(GETCH())) {
	    case LX_POUND:
		/*
		**  handle ## processing. cant be the first or the last.
		*/
		if(p == P_defn_start) {
	    	    Msg_Temp = GET_MSG (2160);
       	    	    SET_MSG (Msg_Text, Msg_Temp);
		    error(2160);	/* ## not allowed as first entry */
		    continue;
		}
		if(*(p - 1) == ' ') {	/* hose the last blank */
		    p--;
		}
		if(CHARMAP(c = skip_cwhite()) == LX_NL) {
		    UNGETCH();
	    	    Msg_Temp = GET_MSG (2161);
       	    	    SET_MSG (Msg_Text, Msg_Temp);
		    error(2161);
		    continue;
		}
		/* this case does *not* fall through to LX_ID */
		continue;
		break;
	    case LX_EACH:
		charize = TRUE;
		break;
	    case LX_EOS:
		if( handle_eos() != BACKSLASH_EOS ) {
		    goto split_op;
		}
		/*
		**	FALLTHROUGH
		*/
	    default:
		UNGETCH();
		stringize = TRUE;
		break;
	    }
	    if(CHARMAP(c = skip_cwhite()) != LX_ID) {
	    	Msg_Temp = GET_MSG (2162);
       	    	SET_MSG (Msg_Text, Msg_Temp);
		error(2162);	/* must have id following */
		continue;
	    }
	    /*
	    **  FALLTHROUGH
	    */
	case LX_ID:
	    {
		/* we have the start of an identifier - check it to see if
		 * its an occurence of a formal parameter name.
		 * we gather the id ourselves (instead of getid()) since this
		 * wil save us from having to copy it to our string if it's
		 * not a formal parameter.
		 */
		int			n;
		ptext_t	p_macformal;

		p_macformal = p;
		do {
		    chkbuf(p);
		    *p++ = c;
get_more_id:
		    c = GETCH();
		} while(LXC_IS_IDENT(c));
		if(CHARMAP(c) == LX_EOS) {
		    if(handle_eos() != BACKSLASH_EOS) {
			goto get_more_id;
		    }
		}
		*p = '\0'; /* term. string, but do not advance ptr */
		if((n = is_macro_arg(p_macformal)) >= 1) {
		    /*
		    **  this is an occurance of formal 'n', replace the id with
		    **  the special MAC character.
		    */
		    p = p_macformal;
		    if(stringize) {
			*p++ = LX_FORMALSTR;
		    }
		    else {
			if(charize) {
			    *p++ = LX_FORMALCHAR;
			}
			else {
			    *p++ = LX_FORMALMARK;
			}
		    }
		    *p++ = (UCHAR) n;
		}
		else if(charize || stringize) {
	  	    Msg_Temp = GET_MSG (2162);
       	    	    SET_MSG (Msg_Text, Msg_Temp);
		    error(2162);
		}
		stringize = FALSE;
		charize = FALSE;
		continue;	/* we broke out of the loop with a new char */
	    }
	case LX_SLASH:
	    if( ! skip_comment() ) {	/* really is a slash */
		break;
	    }
	    /*
			**  FALLTHROUGH
			*/
	case LX_CR:
	case LX_WHITE:
	    /*
	    **  this is white space, all contiguous whitespace is transformed
	    **  to 1 blank. (hence the skip_cwhite() and the continue).
	    */
	    if(CHARMAP(c = skip_cwhite()) != LX_NL) {
		*p++ = ' ';
	    }
	    continue;				/* restart loop */
	case LX_ILL:
	    Msg_Temp = GET_MSG (2018);
       	    SET_MSG (Msg_Text, Msg_Temp, c);
	    error(2018);
	    c = GETCH();
	    continue;
	}
	*p++ = c;
	c = GETCH();
    }
}


/************************************************************************/
/* is_macro_arg ()							*/
/************************************************************************/
int   is_macro_arg(ptext_t name)
{
    REG	int			i;
    REG	ptext_t	p;

    p = Macro_buffer;
    for(i = 1; i <= N_formals; i++) {
	if( strcmp(name, FORMAL_TEXT(p)) == 0) {
	    return(i);
	}
	p = FORMAL_NEXT(p);
    }
    return(-1);
}



/************************************************************************/
/* chkbuf ()								*/
/************************************************************************/
void   chkbuf(ptext_t p)
{
    if( p >= ELIMIT ) {
	Msg_Temp = GET_MSG (1065);
	SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	fatal (1065);
    }
}


/************************************************************************
**  gather_chars : collect chars until a matching one is found.
**  skip backslashed chars. moves the chars into the buffer,
**  returns a ptr past the last char copied.
************************************************************************/
ptext_t   gather_chars(REG ptext_t p, UCHAR match_c)
{
    UCHAR	c;

    *p++ = match_c;
    for(;;) {
	if(p > ELIMIT) {
	    return(ELIMIT);
	}
	switch(CHARMAP(c = GETCH())) {
	case LX_NL:
	    Msg_Temp = GET_MSG (2001);
       	    SET_MSG (Msg_Text, Msg_Temp);
	    error(2001);
	    UNGETCH();
	    c = match_c;
	    /*
			**  FALLTHROUGH
			*/
	case LX_DQUOTE:
	case LX_SQUOTE:
	    if(c == match_c) {
		*p++ = c;
		return(p);		/* only way out */
	    }
	    break;
	case LX_EOS:
	    if(handle_eos() != BACKSLASH_EOS) {
		continue;
	    }
	    else {
		/* got backslash */
		*p++ = '\\';
		c = get_non_eof();
		if((c == '\\') && (checknl())) {
		    continue;
		}
	    }
	    break;
	case LX_LEADBYTE:
	    *p++ = c;
	    c = get_non_eof();
	    break;
	}
	*p++ = c;
    }
}
/************************************************************************
**  END DEFINING MACROS }
************************************************************************/

/************************************************************************
**  BEGIN EXPANDING MACROS {
************************************************************************/
/************************************************************************
**	can_expand:		tries to expand the macro passed to it - returns
**		true if it succeeded in expanding it.  It will only return FALSE
**		if a macro name was found, a paren was expected, and a paren was
**		not the next non white character.
************************************************************************/
int can_expand(pdefn_t pdef)
{
    UCHAR		c;
    int			n_formals;
    int			return_value = FALSE;

    Tiny_lexer_nesting = 0;
    Save_Exp_ptr = Exp_ptr;		/* not necessarily EXP_BUFFER */
    Macro_line = Linenumber;
expand_name:

    P_actuals = Act_ptr;
    N_actuals = 0;

    n_formals = DEFN_NFORMALS(pdef);
    if( PRE_DEFINED(pdef) ) {
	push_macro(pdef);
	DEFN_EXPANDING(CURRENT_MACRO)++;
	if(rescan_expansion()) {
	    return(TRUE);			/* could expand macro */
	}
    }
    else if( n_formals == 0 ) {
	return_value = TRUE;
	if(DEFN_TEXT(pdef)) {
	    push_macro(pdef);
	    expand_definition();
	}
	else {
	    /*
		**	Macro expands to nothing (no definition).  Since it
		**	didn't have any actuals, Act_ptr is already correct.
		**	Exp_ptr must be changed however to delete the
		**	identifier from the expanded text.
		*/
	    Exp_ptr = Save_Exp_ptr;
	}
    }
    else {
	if( n_formals == -1 ) {
	    n_formals = 0;
	}
name_comment_paren:
	if( can_get_non_white()) {
	    if(CHARMAP(CHECKCH()) == LX_SLASH) {
		SKIPCH();
		if(skip_comment()) {
		    goto name_comment_paren;
		}
		else {
		    UNGETCH();
		}
	    }
	    if(CHARMAP(CHECKCH())==LX_OPAREN) {
		SKIPCH();
		return_value = TRUE;
		get_actuals(pdef, n_formals);
	    }
	    else {
		/*
				**	#define xx(a) a
				**  xx bar();
				**  don't lose white space between "xx" and "bar"
				*/
		ptext_t	p = Exp_ptr;

		push_macro(pdef);
		DEFN_EXPANDING(CURRENT_MACRO)++;
		Exp_ptr = p;
		if( rescan_expansion() ) {
		    return(FALSE);
		}
	    }
	}
	else {
	}
    }
    /*
	**	makes sure a macro is being worked on. At this point, there will
	**	be a macro to expand, unless the macro expand_the_named_macro was
	**	passed had no definition text.  If it had no defintion text,
	**	Tiny_lexer_nesting was not incremented.
	*/
    while(Tiny_lexer_nesting != 0) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	switch(CHARMAP(c = GETCH())) {
	case LX_ID:
	case LX_MACFORMAL:
	    Save_Exp_ptr = Exp_ptr;
	    if(tl_getid(c) && ((pdef = get_defined())!= 0)) {
		if(DEFN_EXPANDING(pdef)) {
		    /*
						**	the macro is already being expanded, so just
						**	write the do not expand marker and the
						**	identifier to the expand area.  The do not
						**	expand marker is necessary so this macro
						**	doesn't get expanded on the rescan
						*/
		    int		len = Reuse_1_length - 1;

		    *Exp_ptr++ = LX_NOEXPANDMARK;
		    *Exp_ptr++ = ((UCHAR)len);
		}
		else {
		    /*
						** a legal identifier was read, it is defined, and
						** it is not currently being expanded.  This means
						** there is reason to believe it can be expanded.
						*/
		    goto expand_name;
		}
	    }
	    if(InIf &&(memcmp(Reuse_1, "defined", 8) ==0)) {
		do_defined(Reuse_1);
	    }
	    continue;
	    break;
	case LX_NUMBER:
	    /* getnum with Prep on to keep leading 0x on number */
	    {
		int	Save_prep = Prep;
		Prep = TRUE;
		getnum(c);
		Prep = Save_prep;
	    }
	    continue;
	    break;
	case LX_DOT:
	    *Exp_ptr++ = '.';
dot_switch:
	    switch(CHARMAP(c = GETCH())) {
	    case LX_EOS:
		if(handle_eos() != BACKSLASH_EOS) {
		    if(Tiny_lexer_nesting > 0) {
			goto dot_switch;
		    }
		    continue;
		}
		break;
	    case LX_DOT:
		*Exp_ptr++ = '.';
		if( ! checkop('.')) {
		    break;	/* error will be caught on rescan */
		}
		*Exp_ptr++ = '.';
		continue;
		break;
	    case LX_NUMBER:
		*Exp_ptr++ = c;
		get_real(Exp_ptr);
		continue;
	    }
	    UNGETCH();
	    continue;
	case LX_CHARFORMAL:
	    move_to_exp_esc('\'', do_strformal());
	    continue;
	    break;
	case LX_STRFORMAL:
	    move_to_exp_esc('"', do_strformal());
	    continue;
	    break;
	case LX_DQUOTE:
	case LX_SQUOTE:
	    /*
	    ** 	gather_chars is called even though the error reported
	    **	on overflow may need to be changed.
	    */
	    Exp_ptr = gather_chars(Exp_ptr, c);
	    continue;
	    break;
	case LX_WHITE:
	    while(LXC_IS_WHITE(GETCH())) {
		;
	    }
	    UNGETCH();
	    c = ' ';
	    break;
	case LX_EOS:
	    if(handle_eos() == BACKSLASH_EOS) {
		*Exp_ptr++ = c;
		c = GETCH();
		break;
	    }
	    continue;
	    break;
	}
	*Exp_ptr++ = c;
    }
    return(return_value);
}


/************************************************************************
**  get_actuals :  Paren must already be found.  If all the actuals can
**		be read, the macro is pushed and expansion begins. Otherwise,
**		this function is quickly exited and lets the tiny lexer take
**		care of rescanning.
************************************************************************/
void   get_actuals(pdefn_t pdef, int n_formals)
{
    /*
    **	The only concern with this is that a rescan could finish while
    **	this is trying to collect actuals.  When a rescan finishes, it
    **	may reset Act_ptr and Exp_ptr.  Unless these are saved before the
    **	end of rescan is handled, the part of the actual collected so far
    **	would be lost.
    */
    REG	ptext_t	start;
    UCHAR		c;
    ptext_t	actuals_start;
    int			paste;
    int			level;

    *Exp_ptr++ = PREVCH();			/* must be oparen */
    level = 0;
    actuals_start = Act_ptr;

    while( level >= 0) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
more_white:
	if( ! can_get_non_white()) {
	    return;
	}
	if(CHARMAP(CHECKCH()) == LX_SLASH) {
	    SKIPCH();
	    if(skip_comment()) {
		goto more_white;
	    }
	    else {
		start = Exp_ptr;
		*Exp_ptr++ = '/';
	    }
	}
	else {
	    start = Exp_ptr;
	}
	paste = FALSE;

	for(;;) {
	    switch(CHARMAP(c = GETCH())) {
	    case LX_CPAREN:
		if(--level < 0) {
		    goto leave_loop;
		}
		break;
	    case LX_COMMA:
		/*
		**	if the comma is not at level == 0, it is part of
		**	a parenthesized list and not a delimiter
		*/
		if(level == 0) {
		    goto leave_loop;
		}
		break;
	    case LX_SLASH:
		if( ! skip_comment()) {
		    break;
		}
		if(*(Exp_ptr - 1) == ' ') {
		    continue;
		}
		c = ' ';
		break;
	    case LX_CR:
	    case LX_NL:
	    case LX_WHITE:
		UNGETCH();		/* This char is valid white space */
		if( ! can_get_non_white()) {
		    return;
		}
		continue;
		break;
	    case LX_OPAREN:
		++level;
		break;
	    case LX_DQUOTE:
	    case LX_SQUOTE:
		Exp_ptr = gather_chars(Exp_ptr, c);
		continue;
		break;
	    case LX_ID:
		*Exp_ptr++ = c;
		while(LXC_IS_IDENT(c = GETCH())) {
		    if(Exp_ptr >= ELIMIT) {
			fatal_in_macro(10056);
		    }
		    *Exp_ptr++ = c;
		}
		if(CHARMAP(c) != LX_MACFORMAL) {
		    UNGETCH();
		    continue;
		}
		paste = TRUE;
		/*
		**	FALLTHROUGH
		*/
	    case LX_MACFORMAL:
		move_to_exp(do_macformal(&paste));
		continue;
		break;
	    case LX_STRFORMAL:
		move_to_exp_esc('"', do_strformal());
		continue;
		break;
	    case LX_CHARFORMAL:
		move_to_exp_esc('\'', do_strformal());
		continue;
		break;
	    case LX_EOS:
		/*
		**	Will saving this pointers create dead space in the
		**	buffers?  Yes, but only temporarily.
		**
		**	handle_eos() may reset Act_ptr and Exp_ptr to the
		**	beginning of the buffers if a rescan is finishing
		**	and Macro_depth is going to be 0.  ANSI allows
		**	actuals to start within a macro defintion and be
		**	completed (further actuals and closing paren) later
		**	in the text.
		**
		**	These buffer pointers will eventually be reset to
		**	the beginnings of their respective buffers when the
		**	macro for the actuals being collected right now
		**	finish rescan
		**
		**	This is special handling for folks who use
		**	unbalanced parens in macro definitions
		*/
		{
		    ptext_t	Exp_save;
		    ptext_t	Act_save;
		    int	eos_res;

		    Exp_save = Exp_ptr;
		    Act_save = Act_ptr;
		    if((eos_res = handle_eos()) & (ACTUAL_EOS | RESCAN_EOS)) {
			return;
		    }
		    Act_ptr = Act_save;
		    Exp_ptr = Exp_save;
		    if(eos_res == BACKSLASH_EOS) {	/* ??? DFP QUESTION  */
			*Exp_ptr++ = c;		/*  save the \  */
			c = get_non_eof();	/*  get char following \  */
			break;
		    }
		}
		continue;
		break;
	    }
	    *Exp_ptr++ = c;
	}
leave_loop:
	/*
		**	if the last character was whitespace, hose it
		*/
	if(CHARMAP(*(Exp_ptr - 1)) == LX_WHITE) {
	    Exp_ptr--;
	}
	/*
	**	if Exp_ptr <= start, foo() was read, don't incr N_actuals
	*/
	if(Exp_ptr > start) {
	    N_actuals++;
	    move_to_actual(start, Exp_ptr);
	}
	*Exp_ptr++ = c;
    }

    P_actuals = actuals_start;
    if(n_formals < N_actuals) {
	Msg_Temp = GET_MSG (4002);
        SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	warning(4002);
    }
    else if(n_formals > N_actuals) {
	Msg_Temp = GET_MSG (4003);
        SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	warning(4003);
    }

    if(DEFN_TEXT(pdef)) {
	push_macro(pdef);
	expand_macro();
    }
    else {
	/*
		**	the macro expands to nothing (no definition)
		**	This essentially means delete the macro and its actuals
		**	from the expanded text
		*/
	Act_ptr = P_actuals;	/* reset pointer to get rid of actuals */
	Exp_ptr = Save_Exp_ptr;	/* delete macro & actuals from exp text */
    }
}

/************************************************************************
**	rescan_expansion:	pops a level off of tiny lexer.  If this is the
**		original macro called, the rescan is set up, otherwise the MACRO
**		(not only the tiny lexer level) is popped.
************************************************************************/
int rescan_expansion(void)
{
    if(--Tiny_lexer_nesting == 0) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	*Exp_ptr++ = EOS_CHAR;
	*Exp_ptr++ = EOS_RESCAN;
	Current_char = CURRENT_TEXT;
	return(TRUE);			/* rescan the expanded text */
    }
    else {
	/* reset Current_char, pop the macro */

	Current_char = CURRENT_STRING;
	Act_ptr = CURRENT_ACTUALS;	/* don't need its actuals */
	DEFN_EXPANDING(CURRENT_MACRO)--;
	--Macro_depth;
	return(FALSE);			/* do not rescan expanded text */
    }
}


/************************************************************************
** move_to_actual:	moves the string located between start and finish
**		inclusive to the current location in ACT_BUFFER as a new actual.
************************************************************************/
void   move_to_actual(ptext_t start, ptext_t finish)
{
    REG	ptext_t	p;
    REG	int			len;

    len = (int)(finish - start);
    if(Act_ptr + len >= ALIMIT - 2) {
	fatal_in_macro(10056);
    }
    strncpy(ACTUAL_TEXT(Act_ptr), start, len);
    p = ACTUAL_TEXT(Act_ptr) + len;
    if ((((ULONG_PTR)p) & 1) == 0) {
        *p++ = EOS_CHAR;
        *p++ = EOS_ACTUAL;
    }
    else {
        *p++ = EOS_CHAR;
        *p++ = EOS_PAD;
        *p++ = EOS_ACTUAL;
    }
    ACTUAL_SIZE(Act_ptr) = (short)(p - Act_ptr);
    Act_ptr = p;
}


/************************************************************************
** move_to_exp_esc:	moves zero terminated string starting at source to
**	the current position in EXP_BUFFER, with quotes placed around the
**	string and interior backslashes and dquotes are escaped with a
**	backslash.  The terminating null should not be copied.  The null
**	does not come from the property of a string, but rather is the
**	marker used to indicate there is no more actual.
************************************************************************/
void   move_to_exp_esc(int quote_char, REG ptext_t source)
{
    int		mapped_c;
    int		mapped_quote;
    int		in_quoted = FALSE;

    if( ! source ) {
	return;
    }

    *Exp_ptr++ = (char)quote_char;
    for(;;) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	switch(mapped_c = CHARMAP(*source)) {
	case LX_EOS:
	    if(*source == EOS_CHAR) {
		goto leave_move_stringize;
	    }
	    /* got BACKSLASH */
	    /* but it can't be backslash-newline combination because
				** we are reprocessing text already read in
				*/
	    if(in_quoted) {
		*Exp_ptr++ = '\\';
	    }
	    break;
	    break;
	case LX_DQUOTE:
	    if(CHARMAP(quote_char) == LX_DQUOTE) {
		*Exp_ptr++ = '\\';
	    }
	    /*
			**	FALLTHROUGH
			*/
	case LX_SQUOTE:
	    if(CHARMAP(quote_char) == LX_SQUOTE) {
		break;
	    }
	    if(in_quoted ) {
		if(mapped_c == mapped_quote) {
		    in_quoted = FALSE;
		}
	    }
	    else {
		in_quoted = TRUE;
		mapped_quote = mapped_c;
	    }
	    break;
	case LX_LEADBYTE:
	    *Exp_ptr++ = *source++;
	    break;
	}
	*Exp_ptr++ = *source++;
    }

leave_move_stringize:
    *Exp_ptr++ = (char)quote_char;
}


/************************************************************************
**	move_to_exp:	moves zero terminated string starting at source to
**		the current position in EXP_BUFFER.  The terminating null should
**		not be copied.
************************************************************************/
void   move_to_exp(REG ptext_t source)
{
    if( ! source ) {
	return;
    }

    while( *source ) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	*Exp_ptr++ = *source++;
    }
}


/************************************************************************
** push_macro:			pushes macro information onto the macro stack.
**	Information such as the current location in the Exp and Act buffers
**	will be used by whatever macros this one may call.
************************************************************************/
void   push_macro(pdefn_t pdef)
{
	/*
	**	note that increment leaves element 0 of the macro stack unused.
	**	this element can be reserved for links to dynamically allocated
	**	macro expansion stacks, if they become desirable
	*/
    if(++Macro_depth > LIMIT_MACRO_DEPTH) {
	Msg_Temp = GET_MSG (1009);
	SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	fatal (1009);
    }
    Tiny_lexer_nesting++;
    CURRENT_MACRO = pdef;
    CURRENT_ACTUALS = P_actuals;
    CURRENT_NACTUALS = (UCHAR)N_actuals;
    CURRENT_NACTSEXPANDED = 0;
    CURRENT_STRING = Current_char;
    CURRENT_TEXT = Exp_ptr = Save_Exp_ptr;
}


/************************************************************************
**expand_definition:		sets the input stream to start reading from
**		the macro definition.  Also marks the macro as in the process of
**		expanding so if it eventually invokes itself, it will not expand
**		the new occurence.
************************************************************************/
void   expand_definition(void)
{
    Current_char = DEFN_TEXT(CURRENT_MACRO);
    DEFN_EXPANDING(CURRENT_MACRO)++;
}


/************************************************************************
**expand_actual:	sets the input stream to start reading from
**		the actual specified in actual.
************************************************************************/
void   expand_actual(UCHAR actual)
{
    ptext_t	p;
    p = CURRENT_ACTUALS;
    while(--actual) {
	p = ACTUAL_NEXT(p);
    }
    Current_char = ACTUAL_TEXT(p);
}

/************************************************************************
**	expand_macro:		if there are still actuals for this macro to be
**		expanded, the next one is set up, otherwise this sets up to
**		expand the macro definition
************************************************************************/
void   expand_macro(void)
{
    if(CURRENT_NACTUALS > CURRENT_NACTSEXPANDED) {
	expand_actual(++CURRENT_NACTSEXPANDED);
    }
    else {
	expand_definition();
    }
}


/************************************************************************
**post_paste:		looks ahead one character to find out if a paste has
**	been requested immediately after this identifier.  If the next
**	character can continue an identifier, or is the macformal marker,
**	a paste should be done.  This is called after a macformal is found
**	to find out if the expanded or unexpanded actual should be used.
************************************************************************/
int  post_paste(void)
{
    UCHAR	c;

    if((CHARMAP(c = GETCH()) == LX_MACFORMAL) || (LXC_IS_IDENT(c))) {
	UNGETCH();
	return(TRUE);
    }
    UNGETCH();
    return(FALSE);
}

/************************************************************************
**do_macformal:		This function is called after a macformal marker is
**	found.  It reads the next character to find out which macformal is
**	wanted.  Then it checks to see if a paste is wanted, to find out
**	if the expanded or unexpanded actual should be used.  The return
**	value is a pointer to the text of the actual wanted, or NULL if the
**	actual asked for was not provided.
************************************************************************/
ptext_t   do_macformal(int *pre_paste)
{
    UCHAR		n;
    ptext_t	p;
    int	temp_paste;

    p = CURRENT_ACTUALS;
    n = GETCH();
    if(n > CURRENT_NACTUALS) {
	return(NULL);		/* already output warning */
    }
    temp_paste = post_paste();
    if(( ! (*pre_paste)) && ( ! temp_paste) ) {
	/*
	**	if the programmer provided x actuals, actuals x+1 to 2x are
	**	those actuals expanded
	*/
	n += CURRENT_NACTUALS;
    }
    *pre_paste = temp_paste;
    if (n != 0)
	while(--n) {
	    p = ACTUAL_NEXT(p);
	}

    return(ACTUAL_TEXT(p));
}


/************************************************************************
**tl_getid:		This function reads an identifier for the tiny lexer
**		into EXP_BUFFER.  if macformal is found, the text of that actual
**		(expanded or not) is appended to the identifier.  It is possible
**		that this text will contain characters that are not legal
**		identifiers so return value is whether checking to see if the
**		"identifier" is defined is worth the bother.
************************************************************************/
int tl_getid(UCHAR c)
{
    UCHAR	*p;
    int		paste;
    int		legal_identifier;
    int		length = 0;

    p = Exp_ptr;
    paste = FALSE;
    legal_identifier = TRUE;

do_handle_macformal:
    if(CHARMAP(c) == LX_MACFORMAL) {
	ptext_t	p_buf;

	if((p_buf = do_macformal(&paste)) != 0) {
	    while( *p_buf ) {
		if( ! LXC_IS_IDENT(*p_buf)) {
		    legal_identifier = FALSE;
		}
		if(Exp_ptr >= ELIMIT) {
		    fatal_in_macro(10056);
		}
		*Exp_ptr++ = *p_buf++;
	    }
	}
    }
    else {
	*Exp_ptr++ = c;
    }

do_handle_eos:
    while(LXC_IS_IDENT(c = GETCH())) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	*Exp_ptr++ = c;
    }

    if(CHARMAP(c) == LX_NOEXPAND) {
	length = (int)GETCH();			/* just skip length */
	goto do_handle_eos;
    }

    if(CHARMAP(c) == LX_MACFORMAL) {
	paste = TRUE;
	goto do_handle_macformal;
    }

    UNGETCH();
    if(legal_identifier && (length == (Exp_ptr - p))) {
	legal_identifier = FALSE;
    }

    if(legal_identifier) {
	if(((Exp_ptr - p) > LIMIT_ID_LENGTH) && ( ! Prep)) {
	    Exp_ptr = &p[LIMIT_ID_LENGTH];
	    *Exp_ptr = '\0';	/* terminates identifier for warning */
	    Msg_Temp = GET_MSG (4011);
            SET_MSG (Msg_Text, Msg_Temp, p);
	    warning(4011);		/* id truncated */
	}
	else {
	    *Exp_ptr = '\0';	/* terminates identifier for expandable check */
	}
	/*
	**	Whether or not we are doing Prep output, we still have to make
	**	sure the identifier will fit in Reuse_1
	*/
	if((Exp_ptr - p) > sizeof(Reuse_1)) {
	    Exp_ptr = &p[LIMIT_ID_LENGTH];
	    *Exp_ptr = '\0';
	    Msg_Temp = GET_MSG (4011);
            SET_MSG (Msg_Text, Msg_Temp, p);
	    warning(4011);
	}
	/*
	**	copy into Reuse_1 for warnings about mismatched number of
	**	formals/actuals, and in case it's not expandable
	*/
	memcpy(Reuse_1, p, (int)((Exp_ptr - p) + 1));
	Reuse_1_hash = local_c_hash(Reuse_1);
	/*
	**	the characters from Exp_ptr to p inclusive do not include the
	**	the hash character, the length character, and the terminating
	**	null.
	*/
	Reuse_1_length = (UCHAR)((Exp_ptr - p) + 1);
    }
    return(legal_identifier);
}


/************************************************************************
**	do_strformal:	returns pointer to the actual requested without
**		checking for paste (a legal token is not possible, so if a paste
**		is being done on a strformal, the behavior is undefined
************************************************************************/
ptext_t   do_strformal(void)
{
    UCHAR		n;
    ptext_t	p;

    /* use unexpanded actual */
    p = CURRENT_ACTUALS;
    n = GETCH();
    if(n > CURRENT_NACTUALS) {
	return(NULL);		/* already output warning */
    }
    if (n != 0)
	while(--n) {
	    p = ACTUAL_NEXT(p);
	}
    return(ACTUAL_TEXT(p));
}


/************************************************************************
**	can_get_non_white:	tries to get the next non white character
**		using P1 rules for white space (NL included).  If the end of
**		an actual, or a rescan is found, this returns FALSE, so control
**		can drop into one of the lexers.
************************************************************************/
int	  can_get_non_white(void)
{
    int		return_value = FALSE;
    int		white_found = FALSE;

    for(;;) {
	switch(CHARMAP(GETCH())) {
	case LX_NL:
	    if(On_pound_line) {
		UNGETCH();
		goto leave_cgnw;
	    }
	    Linenumber++;
	    /*
				**	FALLTHROUGH
				*/
	case LX_WHITE:
	case LX_CR:
	    white_found = TRUE;
	    break;
	case LX_EOS:
	    {
		int	eos_res;
		if((eos_res = handle_eos()) & (ACTUAL_EOS | RESCAN_EOS)) {
		    goto leave_cgnw;
		}
		if(eos_res != BACKSLASH_EOS) {
		    break;
		}
	    }
	    /*
				**	FALLTHROUGH
				*/
	default:
	    UNGETCH();
	    return_value = TRUE;
	    goto leave_cgnw;
	    break;
	}
    }
leave_cgnw:
    if(white_found) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	if(*(Exp_ptr - 1) != ' ') {
	    *Exp_ptr++ = ' ';
	}
    }
    return(return_value);		/* could you get next non white? */
}


/************************************************************************/
/* fatal_in_macro ()							*/
/************************************************************************/
void fatal_in_macro(int e)
{
    Linenumber = Macro_line;
    Msg_Temp = GET_MSG(e);
    SET_MSG (Msg_Text, Msg_Temp);
    fatal (e);
}


/************************************************************************
**  handle_eos : handle the end of a string.
************************************************************************/
int   handle_eos(void)
{
    if(PREVCH() == '\\') {
	if(checknl()) {
	    return(FILE_EOS);
	}
	else {
	    return(BACKSLASH_EOS);
	}
    }
    if(Macro_depth == 0) {	/* found end of file buffer or backslash */
	if(io_eob()) {		/* end of buffer in here is bad */
	    Msg_Temp = GET_MSG(1004);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal (1004);
	}
	return(FILE_EOS);
    }

    again:
    switch(GETCH()) {
    case EOS_PAD:
        goto again;
    case EOS_ACTUAL:
	/*
	** Just finished expanding actual.  Check to see if there are
	** any more actuals to be expanded.  If there are, set up to
	** expand them and return.  Otherwise, set up to expand defn
	*/

	/* move expanded text of this actual to act_buffer */
	move_to_actual(CURRENT_TEXT, Exp_ptr);

	/* reset Exp_ptr for more expansions at this macro depth */
	Exp_ptr = CURRENT_TEXT;

	/* expand next actual if there, otherwise expand definition */
	expand_macro();

	return(ACTUAL_EOS);
	break;
    case EOS_DEFINITION:
	if(rescan_expansion()) {
	    return(RESCAN_EOS);
	}
	else {
	    return(DEFINITION_EOS);
	}
	break;
    case EOS_RESCAN:
	/*
	** Reset Current_char, Exp_ptr and Act_ptr, pop the macro
	*/

	/*	get input from the previous stream */
	Current_char = CURRENT_STRING;

	/* mark this macro as not expanding */
	DEFN_EXPANDING(CURRENT_MACRO)--;


	/*
	**	if looking for the actuals of a macro, these pointers
	**	should really not be reset, however, it is cleaner to
	**	save them before calling handle_eos, and restore them
	**	upon returning, than check a static variable here.
	*/
	if(Macro_depth == 1) {
	    Act_ptr = ACT_BUFFER;
	    Exp_ptr = EXP_BUFFER;
	}
	--Macro_depth;
	return(DEFINITION_EOS);
	break;
	/* the following conditional compile is so brackets match */

    DEFAULT_UNREACHABLE;
    }
}
/************************************************************************
**	END EXPANDING MACRO }
************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\rcppdecl.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* RCPPDECL.H - RCPP function prototype declarations			*/
/*									*/
/* 04-Dec-90 w-BrianM  Created						*/
/*									*/
/************************************************************************/

/************************************************************************/
/* ERROR.C								*/
/************************************************************************/
void error	(int);
void fatal	(int);
void warning	(int);

/************************************************************************/
/* GETMSG.C								*/
/************************************************************************/
char * GET_MSG	(int);
void __cdecl SET_MSG	(char *, char *, ...);

/************************************************************************/
/* GETFLAGS.C								*/
/************************************************************************/
#if i386 == 1
int crack_cmd	(struct cmdtab *, char *, char *(*)(void), int);
#else /* MIPS */
struct cmdtab;
int crack_cmd	(struct cmdtab *, char *, char *(*)(void), int);
#endif /* i386 */

/************************************************************************/
/* LTOA.C								*/
/************************************************************************/
int zltoa	(long, char *, int);

/************************************************************************/
/* P0EXPR.C								*/
/************************************************************************/
long do_constexpr	(void);

/************************************************************************/
/* P0GETTOK.C								*/
/************************************************************************/
token_t		yylex(void);
int		lex_getid (UCHAR);

/************************************************************************/
/* P0IO.C								*/
/************************************************************************/
void		emit_line (void);
UCHAR		fpop (void);
unsigned short 		wchCheckWideChar (void);
int		io_eob (void);
int		newinput (char *, int);
int		nested_include (void);
void		p0_init (PCHAR, PCHAR, LIST *);

/************************************************************************/
/* P0KEYS.C								*/
/************************************************************************/
token_t		is_pkeyword (char *);

/************************************************************************/
/* P0MACROS.C								*/
/************************************************************************/
int		can_get_non_white (void);
int		can_expand (pdefn_t);
void 		define (void);
void		definstall (ptext_t, int, int);
pdefn_t		get_defined (void);
int		handle_eos (void);
int		tl_getid (UCHAR);
void		undefine (void);

/************************************************************************/
/* P0PREPRO.C								*/
/************************************************************************/
int		do_defined (PUCHAR);
int		nextis (token_t);
void		preprocess (void);
void		skip_cnew (void);
void		skip_NLonly (void);

/************************************************************************/
/* P1SUP.C								*/
/************************************************************************/
ptree_t		build_const (token_t, value_t *);

/************************************************************************/
/* RCPPUTIL.C								*/
/************************************************************************/
char *		pstrdup (char *);
char *		pstrndup (char *, int);
char *		strappend (char *, char *);

/************************************************************************/
/* SCANNER.C								*/
/************************************************************************/
token_t		char_const (void);
int		checknl (void);
int		checkop (int);
void		do_newline (void);
void		dump_comment (void);
void		DumpSlashComment (void);
void		getid (UINT);
UCHAR		get_non_eof (void);
token_t		getnum (UCHAR);
token_t		get_real (PUCHAR);
hash_t		local_c_hash (char *);
void		prep_string (UCHAR);
UCHAR		skip_cwhite (void);
int		skip_comment (void);
void		str_const (void);

/************************************************************************/
/* P0 I/O MACROS							*/
/************************************************************************/
#define	GETCH()		(*Current_char++)
#define	CHECKCH()	(*Current_char)
#define	UNGETCH()	(Current_char--)
#define	PREVCH()	(*(Current_char - 1))
#define	SKIPCH()	(Current_char++)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\rcpptype.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* RCPPTYPE.H - Type definitions for RCPP				*/
/*									*/
/* 04-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

/************************************************************************/
/* Define types for greater visibility and easier portability		*/
/************************************************************************/

#ifndef _WINDOWS_
typedef char		CHAR;
typedef unsigned char	BYTE;
typedef CHAR *		PCHAR;
typedef unsigned short  WCHAR;
typedef unsigned char	UCHAR;
typedef UCHAR *		PUCHAR;

typedef short		SHORT;
typedef SHORT *		PSHORT;
typedef unsigned short	USHORT;
typedef USHORT *	PUSHORT;

typedef int		INT;
typedef INT		BOOL;
typedef INT *		PINT;
typedef unsigned int	UINT;
typedef UINT *		PUINT;

typedef long		LONG;
typedef LONG *		PLONG;
typedef unsigned long	ULONG;
typedef ULONG *		PULONG;

typedef void		VOID;
typedef VOID *		PVOID;
#endif

typedef double		DOUBLE;
typedef DOUBLE *	PDOUBLE;


/************************************************************************/
/*									*/
/* Define internal types						*/
/*									*/
/************************************************************************/

#define	TRUE	1
#define FALSE	0

#define EXTERN	extern
#define REG	register
#define STATIC	static


#define	BIG_BUFFER	512
#define MED_BUFFER	256
#define SMALL_BUFFER	128
#define TINY_BUFFER	32
#define MSG_BUFF_SIZE	256
#define IFSTACK_SIZE	TINY_BUFFER


/*
**	some commonly used typdefs for scalar items
*/
typedef	UINT		p1key_t;
typedef	UCHAR		hash_t;
typedef	UCHAR		token_t;
typedef	UCHAR		shape_t;

typedef	UCHAR		blknum_t;	/*  lexical level  */
typedef	UCHAR		class_t;

typedef	USHORT	btype_t;	/*  basic type specifier  */
typedef	USHORT	refcnt_t;	/*  symbol's reference count  */
typedef	USHORT	hey_t;		/*  unique keys  */
typedef	USHORT	offset_t;	/*  members offset within a struct  */

typedef	ULONG		abnd_t;		/*  array bound type  */
typedef	ULONG 	len_t;		/*  number of bytes/bits of member/field  */

typedef	struct	s_adj		symadj_t;
typedef	struct	s_defn		defn_t;
typedef	struct	s_flist		flist_t;
typedef	struct	s_indir		indir_t;
typedef	struct	s_stack		stack_t;
typedef	struct	s_sym		sym_t;
typedef	struct	s_table		table_t;
typedef	struct	s_toklist	toklist_t;
typedef	struct	s_tree		tree_t;
typedef	struct	s_type		type_t;
typedef	struct	s_case		case_t;

typedef	union	u_ivalue	ivalue_t;

/*
**	abstract char pointer types
*/
typedef	PUCHAR		ptext_t;	/* wherever input text comes from */ 

/*
**	other abstract pointer types
*/
typedef	type_t *	ptype_t;		/* ptr to types */
typedef	indir_t *	pindir_t;		/* ptr to indirections */
typedef	flist_t *	pflist_t;		/* ptr to formal list type */
typedef	sym_t *		psym_t;		/* symbol ptrs */
typedef	defn_t *	pdefn_t;		/* #define names */

typedef	tree_t *	ptree_t;


typedef struct s_realt {
    LONG	S_sizet;
    DOUBLE	S_realt;
} Srealt_t;


/* declspec type */
struct s_declspec {
    class_t ds_calss;
    ptype_t ds_type;
};
typedef struct s_declspec	declspec_t;
typedef	declspec_t *		pdeclspec_t;


/* string type */
struct s_string {
    CHAR *	str_ptr;
    USHORT	str_len;
};
typedef struct s_string		string_t;
typedef string_t *		pstring_t;


/* rcon type */
struct rcon {
    Srealt_t	rcon_real;
};
typedef struct rcon		rcon_t;
typedef struct rcon *		prcon_t;


/* hln type */
struct s_hln {
    PCHAR hln_name;
    UCHAR hln_hash;
    UCHAR hln_length;
};
typedef	struct	s_hln		hln_t;
typedef	hln_t *			phln_t;


/*
**	union used to return values from the lexer
*/
typedef	union	s_lextype	{
	btype_t		yy_btype;
	PCHAR		yy_cstr;
	int			yy_int;
	int			yy_class;
	long		yy_long;
	hln_t		yy_ident;
	declspec_t	yy_declspec;
	string_t	yy_string;
	psym_t		yy_symbol;
	token_t		yy_token;
	ptree_t		yy_tree;
	ptype_t		yy_type;
	} lextype_t;

/* value_t definition */
union u_value {
    prcon_t	v_rcon;
    long	v_long;
    string_t	v_string;
    psym_t	v_symbol;
};
typedef	union	u_value		value_t;

/* keytab_t definition */
typedef struct {
    char *	k_text;
    UCHAR	k_token;
} keytab_t;


/************************************************************************/
/* LIST definition for \D values					*/
/************************************************************************/
#define	MAXLIST	100

typedef struct LIST {
	INT	li_top;
	CHAR *	li_defns[MAXLIST];
} LIST;

#define UNREFERENCED_PARAMETER(x) (x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\p1types.h ===
/*
**  symbols basic types
**  if the values are changed check : init'd arrays in globals.c
*/
#define	BTundef		0
#define	BTchar		1
#define	BTshort		2
#define	BTint		3
#define	BTlong		4
#define	BTenumuse	5
#define	BTfloat		6
#define	BTdouble	7
#define	BTldouble	8
#define	BTseg		9
#define	BTBASIC		9   /* used elsewhere to indicate the last basic type */
#define	BTvoid		10
#define	BTenum		11
#define	BTstruct	12
#define	BTunion		13
#define	BTstuse		14
#define	BTunuse		15

#define	BT_MASK		0x0f	/* basic type mask */

/*
**  the following are also used in indirection strings as modifiers
**  to the basic indirections.
**  NOTE THIS DOESN'T really work for C600, but for just one case.
**  if a typedef has 'near' on it, 'consolidate_types' will consider
**  it to be a 'signed' bit, and remove it, thus, near never gets
**  added to whatever the typedef is used on.
*/
#define	BT_UNSIGNED		0x0010	/* unsigned keyword used */
#define	BT_SIGNED		0x0020	/* signed keyword used */
#define	SU_MASK			0x0030	/* signed/unsigned mask */

#define	BT_NEAR			0x0040	/* near keyword used */
#define	BT_FAR			0x0080	/* far keyword used */
#define	BT_HUGE			0x00c0	/* huge keyword used */
#define	NFH_MASK		0x00c0	/* near/far/huge mask */

#define	BT_INTERRUPT	0x0100	/* interrupt seen */
#define	BT_SAVEREGS		0x0200	/* dynalink seen */
#define	BT_EXPORT		0x0400	/* export seen */
#define	BT_LOADDS		0x0800	/* loadds seen */
#define	CODEMOD_MASK	0x0f00	/* code modifiers */

#define	BT_CONST		0x1000	/* constant keyword used */
#define	BT_VOLATILE		0x2000	/* volatile keyword used */
#define	CV_MASK			0x3000	/* const/volatile mask */

#define	BT_CDECL		0x4000	/* cdecl keyword used */
#define	BT_FORTRAN		0x8000	/* fortran keyword used */
#define	BT_PASCAL		0xc000	/* pascal keyword used */
#define	LANGUAGE_MASK	0xc000	/* cdecl/fortran/pascal mask */

#define	MODIFIER_MASK	(NFH_MASK | LANGUAGE_MASK | CODEMOD_MASK | CV_MASK)
#define	ALL_MODIFIERS	(MODIFIER_MASK | SU_MASK)
/*
**	macros for getting/setting basic type information
**  Q_* to query the flag.
**	S_* to set the flag.
**  the Q_near/far/huge things are defined later, and are called IS_*.
*/
#define	IS_BTBASIC(P)		((P) <= BTBASIC)
#define	IS_BTINTEGRAL(P)	((P) <= BTenumuse)
#define	IS_BTFLOAT(P)		((BTfloat <= (P)) && ((P) <= BTldouble))
#define	IS_BTVOID(P)		((P) == BTvoid)

#define	IS_BASIC(P)		(IS_BTBASIC(Q_BTYPE(P)))
#define	IS_INTEGRAL(P)	(IS_BTINTEGRAL(Q_BTYPE(P)))
#define	IS_FLOAT(P)		(IS_BTFLOAT(Q_BTYPE(P)))
#define	IS_VOID(P)		(IS_BTVOID(Q_BTYPE(P)))

#define	IS_MULTIBYTE(P)	((BTstruct <= (P)) && ((P) <= BTunuse))
#define	IS_UNSIGNED(P)	((P) & BT_UNSIGNED)
#define	IS_SIGNED(P)	((P) & BT_SIGNED)
#define	CLR_SIGNED(P)	((P) &= ~BT_SIGNED)

#define	S_UNSIGNED(P)	((P) |= BT_UNSIGNED)
#define	S_SIGNED(P)		((P) |= BT_SIGNED)
#define	S_CONST(P)		((P) |= BT_CONST)
#define	S_VOLATILE(P)	((P) |= BT_VOLATILE)
#define	S_NEAR(P)		((P) |= BT_NEAR)
#define	S_FAR(P)		((P) |= BT_FAR)
#define	S_HUGE(P)		((P) |= BT_HUGE)
#define	S_CDECL(P)		((P) |= BT_CDECL)
#define	S_FORTRAN(P)	((P) |= BT_FORTRAN)
#define	S_PASCAL(P)		((P) |= BT_PASCAL)
#define	S_INTERRUPT(P)	((P) |= BT_INTERRUPT)
#define	S_SAVEREGS(P)	((P) |= BT_SAVEREGS)

#define	Q_BTYPE(P)		((P) & ( BT_MASK ))
#define	S_BTYPE(P,V)	((P) = (((P) & ( ~ BT_MASK )) | V))

struct	s_flist		{			/* formal parameter list of types */
	ptype_t		fl_type;		/* type of formal */
	pflist_t	fl_next;		/* next one */
	};

#define	FL_NEXT(P)		((P)->fl_next)
#define	FL_TYPE(P)		((P)->fl_type)

union	u_ivalue	{
	abnd_t		ind_subscr;		/*  array subscript size  */
	psym_t		ind_formals;	/*  formal symbol list  */
	pflist_t	ind_flist;		/*  formal type list  */
	psym_t		ind_basesym;	/*  segment we're based on  */
	ptype_t		ind_basetype;	/*  type we're based on  */
	phln_t		ind_baseid;		/*  id we're based on  */
	};

#define	PIVALUE_ISUB(P)			((P)->ind_subscr)
#define	PIVALUE_IFORMALS(P)		((P)->ind_formals)
#define	PIVALUE_IFLIST(P)		((P)->ind_flist)
#define	PIVALUE_BASEDSYM(P)		((P)->ind_basesym)
#define	PIVALUE_BASEDTYPE(P)	((P)->ind_basetype)
#define	PIVALUE_BASEDID(P)		((P)->ind_baseid)

#define	IVALUE_ISUB(P)			(PIVALUE_ISUB(&(P)))
#define	IVALUE_IFORMALS(P)		(PIVALUE_IFORMALS(&(P)))
#define	IVALUE_IFLIST(P)		(PIVALUE_IFLIST(&(P)))
#define	IVALUE_BASEDSYM(P)		(PIVALUE_BASEDSYM(&(P)))
#define	IVALUE_BASEDTYPE(P)		(PIVALUE_BASEDTYPE(&(P)))
#define	IVALUE_BASEDID(P)		(PIVALUE_BASEDID(&(P)))

struct	s_indir	{
	btype_t		ind_type;		/*  what kind ?  */
	pindir_t	ind_next;		/*  next one  */
	ivalue_t	ind_info;		/*  subscript/function's params  */
	};

#define	INDIR_INEXT(P)		((P)->ind_next)
#define	INDIR_ITYPE(P)		((P)->ind_type)
#define	INDIR_INFO(P)		((P)->ind_info)
#define	INDIR_ISUB(P)		(IVALUE_ISUB(INDIR_INFO(P)))
#define	INDIR_IFORMALS(P)	(IVALUE_IFORMALS(INDIR_INFO(P)))
#define	INDIR_IFLIST(P)		(IVALUE_IFLIST(INDIR_INFO(P)))
#define	INDIR_BASEDSYM(P)	(IVALUE_BASEDSYM(INDIR_INFO(P)))
#define	INDIR_BASEDTYPE(P)	(IVALUE_BASEDTYPE(INDIR_INFO(P)))
#define	INDIR_BASEDID(P)	(IVALUE_BASEDID(INDIR_INFO(P)))
/*
**  optimal choices for these things.
**  however, everyone uses macros to test them, so if i'm wrong,
**  it should be easy to change the values, but think well !!!
*/
#define	IN_FUNC				0x00
#define	IN_PFUNC			0x01
#define	IN_ARRAY			0x02
#define	IN_PDATA			0x03
#define	IN_VOIDLIST			0x04
#define	IN_VARARGS			0x08
#define	IN_MASK				(IN_ARRAY | IN_PDATA | IN_PFUNC | IN_FUNC)
#define	IN_ADDRESS			(IN_ARRAY | IN_PDATA | IN_PFUNC)
#define	IN_DATA_ADDRESS		(IN_ARRAY & IN_PDATA)	/* yes, i meant '&' */
#define	IN_POINTER			(IN_PFUNC & IN_PDATA)	/* yes, i meant '&' */
#if IN_DATA_ADDRESS == 0
#error IN_DATA_ADDRESS is ZERO
#endif
#if IN_POINTER == 0
#error IN_POINTER is ZERO
#endif
#define	IS_ARRAY(I)			(((I) & IN_MASK) == IN_ARRAY)
#define	IS_PDATA(I)			(((I) & IN_MASK) == IN_PDATA)
#define	IS_PFUNC(I)			(((I) & IN_MASK) == IN_PFUNC)
#define	IS_FUNC(I)			(((I) & IN_MASK) == IN_FUNC)
#define	IS_EXTRACT(I)		((I) & IN_POINTER)
#define	IS_DATA_ADDRESS(I)	((I) & IN_DATA_ADDRESS)
#define	IS_ADDRESS(I)		((I) & IN_ADDRESS)
#define	IS_INDIR(I)			((I) & IN_MASK)
#define	MASK_INDIR(I)		((I) & IN_MASK)
#define	IS_VOIDLIST(I)		((I) & IN_VOIDLIST)
#define	IS_VARARGS(I)		((I) & IN_VARARGS)

#define	IS_NFH(I)			((I) & NFH_MASK)
#define	IS_NEARNFH(I)		((I) == BT_NEAR)
#define	IS_FARNFH(I)		((I) == BT_FAR)
#define	IS_HUGENFH(I)		((I) == BT_HUGE)
#define	IS_BASEDNFH(I)		((I) >= BT_BASED)
#define	IS_BASEDSELFNFH(I)	((I) == BT_BASEDSELF)
#define	IS_BASEDIDNFH(I)	((I) == BT_BASEDID)
#define	IS_BASEDSYMNFH(I)	((I) == BT_BASEDSYM)
#define	IS_BASEDTYPENFH(I)	((I) == BT_BASEDTYPE)

#define	IS_NEAR(I)			(IS_NEARNFH(IS_NFH(I)))
#define	IS_FAR(I)			(IS_FARNFH(IS_NFH(I)))
#define	IS_HUGE(I)			(IS_HUGENFH(IS_NFH(I)))
#define	IS_BASED(I)			(IS_BASEDNFH(IS_NFH(I)))
#define	IS_BASEDSELF(I)		(IS_BASEDSELFNFH(IS_NFH(I)))
#define	IS_BASEDID(I)		(IS_BASEDIDNFH(IS_NFH(I)))
#define	IS_BASEDSYM(I)		(IS_BASEDSYMNFH(IS_NFH(I)))
#define	IS_BASEDTYPE(I)		(IS_BASEDTYPENFH(IS_NFH(I)))

#define	IS_INTERRUPT(I)		((I) & BT_INTERRUPT)
#define	IS_SAVEREGS(I)		((I) & BT_SAVEREGS)
#define	IS_EXPORT(I)		((I) & BT_EXPORT)
#define	IS_LOADDS(I)		((I) & BT_LOADDS)
#define	IS_CODEMOD(I)		((I) & CODEMOD_MASK)

#define	IS_CONST(I)			((I) & BT_CONST)
#define	IS_VOLATILE(I)		((I) & BT_VOLATILE)

#define	IS_MODIFIED(I)		((I) & (MODIFIER_MASK))
#define	ANY_MODIFIER(I)		((I) & (ALL_MODIFIERS))

#define INTERF(I)			(MASK_INDIR(I) + (((I) & NFH_MASK) > 4))

#define	S_ITYPE(I,V)	((I) = ((I) & ( ~ IN_MASK )) | (V))
#define	S_INFH(I,V)		((I) = ((I) & ( ~ NFH_MASK )) | (V))
/*
**  type info for symbols
*/
struct	s_type	{
	btype_t		ty_bt;		/*  base type specifiers  */
	pindir_t	ty_indir;	/*  indirection string  */
	p1key_t		ty_dtype;	/*  derived type */
	psym_t		ty_esu;		/*  enum/structure/union/static defining type  */
	USHORT		ty_index;	/*	unique index of type for debugger */
	};
/*
**  help getting type info. P is pointer to TYPE (struct s_type).
**	TYPE contains the basic type, adjectives and an optional pointer
**	to a symbol which is an enumeration, structure, union which is the type
**	of this TYPE.
*/
#define	TY_BTYPE(P)		((P)->ty_bt)	/*  basic type  */
#define	TY_DTYPE(P)		((P)->ty_dtype)	/*  derived type  */
#define	TY_ESU(P)		((P)->ty_esu)	/*  ptr to parent enum/struct/union  */
#define	TY_INDIR(P)		((P)->ty_indir)	/*  indirection string  */
#define	TY_TINDEX(P)	((P)->ty_index)	/*  type index */
#define	TY_INEXT(P)		(INDIR_INEXT(TY_INDIR(P)))
#define	TY_ITYPE(P)		(INDIR_ITYPE(TY_INDIR(P)))
#define	TY_ISUB(P)		(INDIR_ISUB(TY_INDIR(P)))
#define	TY_IFORMALS(P)	(INDIR_IFORMALS(TY_INDIR(P)))
#define	TY_IFLIST(P)	(INDIR_IFLIST(TY_INDIR(P)))

typedef	struct	s_indir_entry	indir_entry_t;
typedef	struct	s_type_entry	type_entry_t;

struct	s_indir_entry	{
	indir_entry_t	*ind_next;
	indir_t			ind_type;
	};

struct	s_type_entry	{
	type_entry_t	*te_next;
	type_t			te_type;
	};

#define	TYPE_TABLE_SIZE		0x100
#define	INDIR_TABLE_SIZE	0x040
/*
**  HASH_MASK : is a value which consists of the bits in common
**  between upper and lower case. we mask each char we read with this
**  to sum them for a hash value. we do this so that all names consisting
**  of the same chars (case insensitive), will hash to the same location.
*/
#define	HASH_MASK			0x5f

#define	DATASEGMENT			0
#define	TEXTSEGMENT			1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\p1sup.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P1SUP.C - First pass C stuff which probably is not used		*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p1types.h"
#include "trees.h"
#include "grammar.h"
#include "strings.h"

/* trees */
#define	LEFT			1
#define	RIGHT			2

#define	MORE_CHECKING	2

int TypeCount;
int TreeCount;
char * TypePool;
char * TreePool;

type_entry_t    *Type_table[TYPE_TABLE_SIZE];


/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
ptype_t  hash_type(ptype_t);
int types_equal(ptype_t, ptype_t);


/************************************************************************
**  hash_type : returns a pointer to an already built type, if it
**  exists, or builds one.
************************************************************************/
ptype_t  hash_type(type_t  * p_type)
{
    REG type_entry_t    *p_tmp;
    type_entry_t    **p_start;

    /* Try to get a unique hash value for every type...keep
     * type_equal in mind if changing this
     */
    p_start = &Type_table[(TY_BTYPE(p_type) + TY_DTYPE(p_type) + (INT_PTR) TY_INDIR(p_type)) & (TYPE_TABLE_SIZE - 1)];

    for (p_tmp= *p_start; p_tmp; p_tmp = p_tmp->te_next ) {
        if (types_equal(p_type,&(p_tmp->te_type))) {
            return(&(p_tmp->te_type));
        }
    }
    p_tmp = malloc(sizeof(type_entry_t));
    if (p_tmp == NULL) {
        Msg_Temp = GET_MSG (1002);
        SET_MSG (Msg_Text, Msg_Temp);
        error(1002);
        return NULL;
    }
    p_tmp->te_next = *p_start;
    *p_start = p_tmp;
    p_tmp->te_type = *p_type;
    TY_TINDEX(&(p_tmp->te_type)) = 0;
    return(&(p_tmp->te_type));
}


/************************************************************************
**  types_equal : are two types equal?
************************************************************************/
int types_equal(REG ptype_t p1, REG ptype_t p2)
{
    return( (TY_BTYPE(p1) == TY_BTYPE(p2))
            &&
            (TY_DTYPE(p1) == TY_DTYPE(p2))
            &&
            TY_INDIR(p1) == TY_INDIR(p2)
          );
}

/************************************************************************
**	build_const - builds and returns a pointer to a constant tree.
**		Input	: constant type.
**			: ptr to a union containing the value of the constant
**		Output	: Pointer to constant tree.
************************************************************************/
ptree_t build_const(REG token_t type, value_t *value)
{
    REG ptree_t     res;
    ptype_t     p_type;
    btype_t     btype;

    res = malloc(sizeof(tree_t));
    if (res == NULL) {
        Msg_Temp = GET_MSG (1002);
        SET_MSG (Msg_Text, Msg_Temp);
        error(1002);
        return NULL;
    }
    TR_SHAPE(res) = TTconstant;
    TR_TOKEN(res) = type;
    switch ( type ) {
        case L_CINTEGER:
        case L_LONGINT:
        case L_CUNSIGNED:
        case L_LONGUNSIGNED:
            if ( type == L_CUNSIGNED || type == L_LONGUNSIGNED ) {
                btype = (btype_t)(BT_UNSIGNED |
                                  (btype_t)((type == L_CUNSIGNED) ? BTint : BTlong));
            } else {
                btype = (btype_t)((type == L_CINTEGER) ? BTint : BTlong);
            }
            if ((TR_LVALUE(res) = PV_LONG(value)) == 0) {
                TR_SHAPE(res) |= TTzero;
            }
            break;
        case L_CFLOAT:
            btype = BTfloat;
            TR_RCON(res) = PV_RCON(value);
            break;
        case L_CDOUBLE:
            btype = BTdouble;
            TR_RCON(res) = PV_RCON(value);
            break;
        case L_CLDOUBLE:
            btype = BTldouble;
            TR_RCON(res) = PV_RCON(value);
            break;
        default:
            btype=BTundef;
            break;
    }
    p_type = malloc(sizeof(type_t));
    if (p_type == NULL) {
        Msg_Temp = GET_MSG (1002);
        SET_MSG (Msg_Text, Msg_Temp);
        error(1002);
        return NULL;
    }
    TY_BTYPE(p_type) = (btype_t)(btype | BT_CONST);
    TR_P1TYPE(res) = hash_type(p_type);
    return(res);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\rcpputil.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* RCPPTIL.C - Utility routines for RCPP                                */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include <malloc.h>
#include <string.h>
#include "rcpptype.h"
#include "rcppdecl.h"

extern void     error(int);
extern char     Msg_Text[];
extern char *   Msg_Temp;

/************************************************************************
 * PSTRDUP - Create a duplicate of string s and return a pointer to it.
 ************************************************************************/
char *pstrdup(char *s)
{
    char *p = malloc(strlen(s)+1);
    if (p)
        return(strcpy(p, s));
    else
        return NULL;
}


/************************************************************************
**  pstrndup : copies n bytes from the string to a newly allocated
**  near memory location.
************************************************************************/
char * pstrndup(char *s, int n)
{
    char        *r;
    char        *res;

    r = res = malloc(n+1);
    if (res == NULL) {
        Msg_Temp = GET_MSG (1002);
        SET_MSG (Msg_Text, Msg_Temp);
        error(1002);
        return NULL;
    }
    while(n--) {
        *r++ = *s++;
    }
    *r = '\0';
    return(res);
}


/************************************************************************
**      strappend : appends src to the dst,
**  returns a ptr in dst to the null terminator.
************************************************************************/
char * strappend(register char *dst, register char *src)
{
    while ((*dst++ = *src++) != 0);
    return(--dst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\rcunicod.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.h

Abstract:

    This is the header file for rcpp 16-bit unicode support.  It contains
	the translatation table for codepage 1252.  This was taken from the
	nls1252.txt file.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/

#ifndef __RCUNICOD

#define __RCUNICOD

#define IN
#define OUT


#define DFT_TEST_SIZE			10	// The number of words to test to get
									// an accurate determination of file type.

//
// The following may be retruned from DetermineFileType ().
//

#define DFT_FILE_IS_UNKNOWN		0	// File type not yet determined.
#define DFT_FILE_IS_8_BIT		1	// File is an 8-bit ascii file.
#define DFT_FILE_IS_16_BIT		2	// File is standard 16-bit unicode file.
#define DFT_FILE_IS_16_BIT_REV	3	// File is reversed 16-bit unicode file.

//
// This function can be used to determine the format of a disk file.
//
INT
DetermineFileType (
    IN      FILE	*fpInputFile
    );

//
// The following may be returned from DetermnineSysEndianType ().
//

#define DSE_SYS_LITTLE_ENDIAN	1	// Return values from determine system
#define DSE_SYS_BIG_ENDIAN		2	// endian type.

//
// This function will return the endian type of the current system.
//
INT
DetermineSysEndianType (
	VOID
    );


#endif  // __RCUNICOD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\strings.h ===
#define RCON_REAL(p)	((p)->rcon_real)

/*
**  given a VALUE ptr, return the various fields.
*/
#define	PV_RCON(P)		((P)->v_rcon)
#define	PV_DOUBLE(P)	(PV_RCON(P)->rcon_real)
#define	PV_LONG(P)		((P)->v_long)
#define	PV_STRPTR(P)	((P)->v_string.str_ptr)
#define	PV_STRLEN(P)	((P)->v_string.str_len)
#define PV_SYM(P)		((P)->v_symbol)
/*
**  given a reference to a VALUE, return the given field
*/
#define	V_RCON(V)	((V).v_rcon)
#define	V_DOUBLE(V)	(V_RCON(V)->rcon_real)
#define	V_LONG(V)	((V).v_long)
#define	V_STRPTR(V)	((V).v_string.str_ptr)
#define	V_STRLEN(V)	((V).v_string.str_len)
#define V_SYM(V)	((V).v_symbol)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\rcunicod.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.c

Abstract:

    Routines added to rcpp to support 16-bit unicode file parsing.
    Note that as of Aug 91, rcpp will not fully transfer the unicode
    characters but only the string constants are guaranteed to be passed
    cleanly.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/


#include <stdio.h>
#include <ctype.h>
#include <process.h>
#include "windows.h"
#include "rcunicod.h"


INT
DetermineFileType (
                  IN      FILE    *fpInputFile
                  )

/*++

Routine Description:

    This function is used to determine what type of file is being read.
    Note that it assumes that the first few bytes of the given file contain
    mostly ascii characters.  This routine was originally intended for use
    on .rc files and include files.
    Note, the file is returned to it's proper position after function.

Arguments:

    fpInputFile			- File pointer to file we are checking, must be
                          open with read permissions.

Return Value:

    DFT_FILE_IS_UNKNOWN     - It was impossible to determine what type of file
                              we were checking.  This usually happens when EOF
                              is unexpectedly reached.
    DFT_FILE_IS_8_BIT       - File was determined to be in standard 8-bit
                              format.
    DFT_FILE_IS_16_BIT      - File was determined to be a 16 bit unicode file
                              which can be directly read into a WCHAR array.
    DFT_FILE_IS_16_BIT_REV  - File was determined to be a 16 bit unicode file
                              which has it's bytes reversed in order.

--*/

{
    CHAR    rgchTestBytes [DFT_TEST_SIZE << 2]; // Storage for test data.
    INT     cNumberBytesTested = 0;         // Test information.
    INT     cNumberOddZerosFound = 0;
    INT     cNumberEvenZerosFound = 0;
    INT     cNumberAsciiFound = 0;
    INT     cCountRead;                     // Temp storage for count read.
    LONG    lStartFilePos;                  // Storage for file position.
    INT     fSysEndianType;                 // System endian type.
    INT     fFileType = DFT_FILE_IS_UNKNOWN;// File type, when found.

    fSysEndianType = DetermineSysEndianType ();

    //
    // Store position so we can get back to it.
    //
    lStartFilePos = ftell (fpInputFile);

    //
    // Make sure we start on an even byte to simplify routines.
    //
    if (lStartFilePos % 2) {

        fgetc (fpInputFile);
    }

    do {
        INT     wT;

        //
        // Read in the first test segment.
        //

        cCountRead = fread (rgchTestBytes, sizeof (CHAR), DFT_TEST_SIZE << 2,
                            fpInputFile);

        //
        // Determine results and add to totals.
        //

        for (wT = 0; wT < cCountRead; wT++) {

            if (rgchTestBytes [wT] == 0) {

                if (wT % 2) {

                    cNumberOddZerosFound++;

                } else {

                    cNumberEvenZerosFound++;
                }
            }

            if (isprint (rgchTestBytes [wT]) ||
                rgchTestBytes[wT] == '\t' ||
                rgchTestBytes[wT] == '\n' ||
                rgchTestBytes[wT] == '\r' ) {

                cNumberAsciiFound++;
            }
        }

        cNumberBytesTested += cCountRead;

        //
        // Check if we have a definite pattern.
        //

        {
            INT     cMajorityTested;        // 80% of the bytes tested.

            cMajorityTested = cNumberBytesTested << 2;
            cMajorityTested /= 5;

            if (cNumberAsciiFound > cMajorityTested) {

                fFileType = DFT_FILE_IS_8_BIT;

            } else if (cNumberOddZerosFound > (cMajorityTested >> 1)) {

                //
                // File type was determined to be little endian.
                // If system is also little endian, byte order is correct.
                //
                fFileType = (fSysEndianType == DSE_SYS_LITTLE_ENDIAN) ?
                            DFT_FILE_IS_16_BIT : DFT_FILE_IS_16_BIT_REV;

            } else if (cNumberEvenZerosFound > (cMajorityTested >> 1)) {

                //
                // File type was determined to be big endian.
                // If system is also big endian, byte order is correct.
                //
                fFileType = (fSysEndianType == DSE_SYS_LITTLE_ENDIAN) ?
                            DFT_FILE_IS_16_BIT_REV : DFT_FILE_IS_16_BIT;

            }
        }

    } while (cCountRead == (DFT_TEST_SIZE << 2) &&
             fFileType == DFT_FILE_IS_UNKNOWN);

    //
    // Return to starting file position.  (usually beginning)
    //

    if (fseek (fpInputFile, lStartFilePos, SEEK_SET) == -1)
        fFileType = DFT_FILE_IS_UNKNOWN;

    return (fFileType);
}


INT
DetermineSysEndianType (
                       VOID
                       )

/*++

Routine Description:

    This function is used to determine how the current system stores its
    integers in memory.

    For those of us who are confused by little endian and big endian formats,
    here is a breif recap.

    Little Endian:  (This is used on Intel 80x86 chips.  The MIPS RS4000 chip
         is switchable, but will run in little endian format for NT.)
       This is where the high order bytes of a short or long are stored higher
       in memory.  For example the number 0x80402010 is stored as follows.
         Address:        Value:
             00            10
             01            20
             02            40
             03            80
       This looks backwards when memory is dumped in order: 10 20 40 80

    Big Endian:  (This is not currently used on any NT systems but hey, this
         is supposed to be portable!!)
       This is where the high order bytes of a short or long are stored lower
       in memory.  For example the number 0x80402010 is stored as follows.
         Address:        Value:
             00            80
             01            40
             02            20
             03            10
       This looks correct when memory is dumped in order: 80 40 20 10

Arguments:

    None.

Return Value:

    DSE_SYS_LITTLE_ENDIAN   - The system stores integers in little endian
                              format.  (this is 80x86 default).
    DSE_SYS_BIG_ENDIAN  	- The system stores integers in big endian format.

--*/

{
    INT     nCheckInteger;
    CHAR    rgchTestBytes [sizeof (INT)];

    //
    // Clear the test bytes to zero.
    //

    *((INT *)rgchTestBytes) = 0;

    //
    // Set first to some value.
    //

    rgchTestBytes [0] = (UCHAR)0xFF;

    //
    // Map it to an integer.
    //

    nCheckInteger = *((INT *)rgchTestBytes);

    //
    // See if value was stored in low order of integer.
    // If so then system is little endian.
    //

    if (nCheckInteger == 0xFF) {

        return (DSE_SYS_LITTLE_ENDIAN);
    } else {

        return (DSE_SYS_LITTLE_ENDIAN);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\tokens.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* TOKENS.C - Token stuff, probably removable from RCPP			*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include "rcpptype.h"
#include "rcppext.h"
#include "grammar.h"

/*
 * TOKENS - This file contains the initialized tables of text, token pairs for
 * all the C language symbols and keywords, and the mapped value for YACC.
 *
 * IMPORTANT : this MUST be in the same order as the %token list in grammar.y
 *
 */
keytab_t Tokstrings[] = {
#define	DAT(tok1, name2, map3, il4, mmap5)	{ name2, map3 },
#include "tokdat.h"
#undef DAT
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\symbols.h ===
/*
**  Symbol types . . .
*/
#define	SYMV_SYMBOL		0x001
#define	SYMV_RAWSYMBOL	0x002
#define	SYMV_FORMAL		0x004
#define	SYMV_SEGMENT	0x008

#define	SYMV_FUNCTION	0x010
#define	SYMV_INTRINSIC	0x020
#define	SYMV_LABEL		0x040

#define	SYMV_TAG		0x080
#define	SYMV_MOE		0x100
#define	SYMV_MEMBER		0x200
#define	SYMV_FIELD		0x400
#define	SYMV_OPC		0x800

#define	SYMV_ABSTRSYM	0x1000

#define	SYM_ISSYMBOL(p)		(SYM_ANYVTAG(p) & SYMV_SYMBOL)
#define	SYM_ISFUNCTION(p)	(SYM_ANYVTAG(p) & SYMV_FUNCTION)
#define	SYM_ISFORMAL(p)		(SYM_ANYVTAG(p) & SYMV_FORMAL)
#define	SYM_ISABSTRSYM(p)	(SYM_ANYVTAG(p) & SYMV_ABSTRSYM)
#define	SYM_ISLABEL(p)		(SYM_ANYVTAG(p) & SYMV_LABEL)
#define	SYM_ISTAG(p)		(SYM_ANYVTAG(p) & SYMV_TAG)
#define	SYM_ISMOE(p)		(SYM_ANYVTAG(p) & SYMV_MOE)
#define	SYM_ISMEMBER(p)		(SYM_ANYVTAG(p) & SYMV_MEMBER)
#define	SYM_ISFIELD(p)		(SYM_ANYVTAG(p) & SYMV_FIELD)
#define	SYM_ISINTRINSIC(p)	(SYM_ANYVTAG(p) & SYMV_INTRINSIC)
#define	SYM_ISRAWSYMBOL(p)	(SYM_ANYVTAG(p) & SYMV_RAWSYMBOL)
#define	SYM_ISSEGMENT(p)	(SYM_ANYVTAG(p) & SYMV_SEGMENT)
/*
**  parameter list types
*/
#define	NO_LIST		0
#define	EMPTY_LIST	1
#define	NAME_LIST	2
#define	PASCAL_LIST	3
#define	TYPE_LIST	4
/*
**  symbol storage classes
**  symbol adjectives, these have nothing to do with types.
*/
#define	SCundef		0
#define	SCauto		0x01
#define	SCextern	0x02
#define	SCregister	0x04
#define	SCstatic	0x08
#define	SCtypedef	0x10
#define	SCglobal	0x20
#define	SCabsolute	0x40
#define	SCreally	0x80	/* used w/ SCregister by p2 if it allocs a reg */

#define	SCp2stuff	SCreally

/*
**  symbol table sizes
*/
#define	LEVEL_0		0xff
#define	LEVEL_N		0x0f

struct	s_adj	{
	uchar_t	bit_0:1;
	uchar_t	bit_1:1;
	uchar_t	bit_2:1;
	uchar_t	bit_3:1;

	uchar_t	bit_4:1;
	uchar_t	bit_5:1;
	uchar_t	bit_6:1;
	uchar_t	bit_7:1;

	uchar_t	bit_8:1;
	uchar_t	bit_9:1;
	uchar_t	bit_10:1;
	uchar_t	bit_11:1;

	uchar_t	bit_12:1;
	uchar_t	bit_13:1;
	uchar_t	bit_14:1;
	uchar_t	bit_15:1;
	};

#if VERS_DEBUG
/*
 * d=DEFINED o=OUTPUT S=INASEGMENT n=NEAR
 * v=VISIBLE p=PASCAL i=INIT s=STRING
 * N=HASANAMELIST E=DEFNBEFOREUSE C=CODESEGNAME D=DATASEGNAME
 * B=ISBACKREF F=FORWARDREF
 */
#define	SYM_ADJFMT				"??FBDCENsipvnSod"	/* prword() fmt */
#endif

#define	IS_INVISIBLE			0
#define	IS_VISIBLE				1

#define	SYM_ISDEFINED(s)		((SYM_ANYADJ(s)).bit_0)	/* all */
#define	SYM_ISOUTPUT(s)			((SYM_ANYADJ(s)).bit_1)	/* all */
#define	SYM_ISINASEGMENT(s)		((SYM_ANYADJ(s)).bit_2)	/* all */
#define	SYM_ISNEAR(s)			((SYM_ANYADJ(s)).bit_3)	/* all */
#define	SYM_ISVISIBLE(s)		((SYM_ANYADJ(s)).bit_4)	/* all */
#define	SYM_ISPASCAL(s)			((SYM_ANYADJ(s)).bit_5)	/* all */

#define	SYM_ISINITIALIZED(s)	((SYM_ANYADJ(s)).bit_6)	/* symbol */
#define	SYM_ISSTRING(s)			((SYM_ANYADJ(s)).bit_7)	/* symbol */

#define	SYM_HASANAMELIST(s)		((SYM_ANYADJ(s)).bit_8)	/* funcs */
#define	SYM_DEFNBEFOREUSE(s)	((SYM_ANYADJ(s)).bit_9)	/* overload for QC */

#define	SYM_ISCODESEGNAME(s)	((SYM_ANYADJ(s)).bit_10)/* segment */
#define	SYM_ISDATASEGNAME(s)	((SYM_ANYADJ(s)).bit_11)/* segment */

#define	SYM_ISBACKREF(s)		((SYM_ANYADJ(s)).bit_12)/* label */
#define	SYM_ISFORWARDREF(s)		((SYM_ANYADJ(s)).bit_13)/* label */
#define SYM_ISMASM(s)			((SYM_ANYADJ(s)).bit_14)/* label */
#define SYM_TOLEVEL0(s)			((SYM_ANYADJ(s)).bit_15)/* funcs moved to 0 */

typedef	struct	sym_200	{			/* for fields */
	uchar_t		field_bitstart;		/* in which bit does the field start */
	uchar_t		field_nbits;		/* number of bits in this field */
	} sym_200_t;

typedef	struct	sym_190	{			/* struct/union members/fields */
	fpsym_t		member_prev;		/* previous member */
	ushort_t	member_offset;		/* offset of this member in the struct */
	sym_200_t	m200;
	} sym_190_t;

#define	SOB_sym_190	(sizeof(sym_190_t) - sizeof(sym_200_t))

typedef	struct	sym_180	{			/* struct/union/enum tags */
	len_t		tag_size;			/* sizeof the struct/union */
	ushort_t	tag_align;			/* alignment of this struct */
	} sym_180_t;

typedef	struct	sym_170	{			/* intrinsics */
	ushort_t	intrin_ino;			/* intrinsic number */
	ushort_t	intrin_nparms;		/* number of actuals it takes */
	} sym_170_t;

typedef	struct	sym_160	{			/* labels */
	NA_TYPE		label_template;		/* label template */
	} sym_160_t;

typedef	struct	sym_150	{			/* formals */
	fpsym_t		formal_prev;		/* ptr to previous formal */
	} sym_150_t;

typedef	struct	sym_140	{			/* raw symbols */
	hash_t		raw_hash;			/* the hash of this symbol */
	} sym_140_t;

typedef	union	sym_135	{
	sym_140_t	m140;				/* raw symbols */
	sym_150_t	m150;				/* formals */
	sym_160_t	m160;				/* labels */
	} sym_135_t;

typedef	struct	sym_130	{
/*
	SYMV_SYMBOL
	SYMV_RAWSYMBOL
	SYMV_FORMAL
	SYMV_SEGMENT
	SYMV_FUNCTION
	SYMV_LABEL
*/
	fpsym_t		sym_anysegment;		/* ptr to segment this is alloc'd in */
	sym_135_t	m135;
	} sym_130_t;

#define	SOB_sym_130	(sizeof(sym_130_t) - sizeof(sym_135_t))

typedef	union	sym_125	{
	sym_130_t	m130;
	sym_170_t	m170;
	} sym_125_t;

typedef	struct	sym_120	{
/*
	case SYMV_SYMBOL:
	case SYMV_RAWSYMBOL:
	case SYMV_FORMAL:
	case SYMV_SEGMENT:
	case SYMV_FUNCTION:
	case SYMV_INTRINSIC:
	case SYMV_LABEL:
*/
	refcnt_t	sym_anyrefcnt;	/* reference count  */
	class_t		sym_anyclass;	/* symbol's class */
	symadj_t	sym_anyadj;		/* adjectives  */
	sym_125_t	m125;
	} sym_120_t;

#define	SOB_sym_120	(sizeof(sym_120_t) - sizeof(sym_125_t))

typedef	union	sym_115	{
	sym_120_t	m120;
	sym_180_t	m180;
	} sym_115_t;

typedef	struct	sym_110	{
/*
	case SYMV_SYMBOL:
	case SYMV_RAWSYMBOL:
	case SYMV_FORMAL:
	case SYMV_SEGMENT:
	case SYMV_FUNCTION:
	case SYMV_INTRINSIC:
	case SYMV_LABEL:
	case SYMV_TAG:
*/
	p1key_t		sym_anykey;
	sym_115_t	m115;
	} sym_110_t;

#define	SOB_sym_110	(sizeof(sym_110_t) - sizeof(sym_115_t))

typedef	union	sym_105	{
	sym_110_t	m110;
	sym_190_t	m190;
	} sym_105_t;

typedef	struct	sym_100	{
	ptype_t		sym_anytype;
	sym_105_t	m105;
	} sym_100_t;

#define	SOB_sym_100	(sizeof(sym_100_t) - sizeof(sym_105_t))

typedef	union	sym_95	{
	long		moe_value;
	sym_100_t	m100;
	} sym_95_t;

struct	s_sym	{
	fpsym_t		sym_anynext;		/*  pointer to next ident  */
	fpuchar_t	sym_anyname;		/*  pointer to name */
	ushort_t	sym_anyvtag;		/*  which variant do we have? */
	sym_95_t		m95;
	};

#define	M95(p)	((p)->m95)
#define	M100(p)	((p)->m95.m100)
#define	M105(p)	((p)->m95.m100.m105)
#define	M110(p)	 ((p)->m95.m100.m105.m110)
#define	M115(p)	  ((p)->m95.m100.m105.m110.m115)
#define	M120(p)	   ((p)->m95.m100.m105.m110.m115.m120)
#define	M125(p)	    ((p)->m95.m100.m105.m110.m115.m120.m125)
#define	M130(p)	     ((p)->m95.m100.m105.m110.m115.m120.m125.m130)
#define	M135(p)	      (M130(p).m135)
#define	M140(p)	       (M135(p).m140)
#define	M150(p)	       (M135(p).m150)
#define	M160(p)	       (M135(p).m160)
#define	M170(p)	      ((p)->m95.m100.m105.m110.m115.m120.m125.m170)
#define	M180(p)	   ((p)->m95.m100.m105.m110.m115.m180)
#define	M190(p)	 ((p)->m95.m100.m105.m190)
#define	M200(p)	  (M190(p).m200)

#define	SO_BASICSYM	(sizeof(sym_t) - sizeof(sym_95_t))

#define	SO_SYMBOL		(	SO_BASICSYM\
							+ SOB_sym_100\
							+ SOB_sym_110\
							+ SOB_sym_120\
							+ SOB_sym_130\
							)
#define	SO_SEGMENT		(SO_SYMBOL)
#define	SO_FUNCTION		(SO_SYMBOL)
#define	SO_RAWSYMBOL	(	SO_SYMBOL\
							+ sizeof(sym_140_t)\
							)
#define	SO_FORMAL		(	SO_SYMBOL\
							+ sizeof(sym_150_t)\
							)
#define	SO_LABEL		(	SO_SYMBOL\
							+ sizeof(sym_160_t)\
							)
#define	SO_INTRINSIC	(	SO_BASICSYM\
							+ SOB_sym_100\
							+ SOB_sym_110\
							+ SOB_sym_120\
							+ sizeof(sym_170_t)\
							)
#define	SO_TAG			(	SO_BASICSYM\
							+ SOB_sym_100\
							+ SOB_sym_110\
							+ sizeof(sym_180_t)\
							)

#define	SO_MEMBER		(	SO_BASICSYM\
							+ SOB_sym_100\
							+ SOB_sym_190\
							)
#define	SO_FIELD		(	SO_MEMBER\
							+ sizeof(sym_200_t)\
							)
#define	SO_MOE			(SO_BASICSYM + sizeof(long))	/* sizeof(moe_value) */

#if 0	/* this is just a big comment */

*all* use s_sym and the following parts.

SYMV_SYMBOL(and SYMV_SEGMENT, SYMV_FUNCTION)
				uses : sym_100, sym_110, sym_120, sym_130

SYMV_RAWSYMBOL	uses : SYMV_SYMBOL *and* sym_140
SYMV_FORMAL		uses : SYMV_SYMBOL *and* sym_150
SYMV_LABEL		uses : SYMV_SYMBOL *and* sym_160

SYMV_INTRINSIC	uses : sym_100, sym_110, sym_120, sym_170

SYMV_TAG		uses : sym_100, sym_110, sym_180

SYMV_MEMBER		uses : sym_100, sym_190

SYMV_FIELD		uses : SYMV_MEMBER *and* sym_200

SYMV_MOE		uses : moe_value

SYMV_OPC

#endif

#define	SYM_ANYNEXT(p)		((p)->sym_anynext)
#define	SYM_ANYNAME(p)		((p)->sym_anyname)
#define	SYM_ANYVTAG(p)		((p)->sym_anyvtag)

#define	SYM_ANYTYPE(p)		((p)->m95.m100.sym_anytype)
#define	SYM_ANYKEY(p)		((p)->m95.m100.m105.m110.sym_anykey)
#define	SYM_ANYREFCNT(p)	((p)->m95.m100.m105.m110.m115.m120.sym_anyrefcnt)
#define	SYM_ANYCLASS(p)		((p)->m95.m100.m105.m110.m115.m120.sym_anyclass)
#define	SYM_ANYADJ(p)		((p)->m95.m100.m105.m110.m115.m120.sym_anyadj)
#define	SYM_ANYSEGMENT(p)	(M130(p).sym_anysegment)
#define	SYM_ANYAOFF(p)		(M130(p).sym_anyaoff)	/* P-2 allocation offset */
#define	SYM_ANYAREGS(p)		(M130(p).sym_anyaregs)	/* P-2 allocation regs */
#define	SYM_ANYASEG(p)		(M130(p).sym_anyaseg)	/* P-2 allocation segment */

#define	SYM_SYNEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_SYNAME(p)		(SYM_ANYNAME(p))
#define	SYM_SYTYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_SYKEY(p)		(SYM_ANYKEY(p))
#define	SYM_SYREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_SYCLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_SYADJ(p)		(SYM_ANYADJ(p))
#define	SYM_SYSEGMENT(p)	(SYM_ANYSEGMENT(p))
#define	SYM_SYAOFF(p)		(SYM_ANYAOFF(p))
#define	SYM_SYASEG(p)		(SYM_ANYASEG(p))

#define	SYM_SENEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_SENAME(p)		(SYM_ANYNAME(p))
#define	SYM_SETYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_SEKEY(p)		(SYM_ANYKEY(p))
#define	SYM_SEREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_SECLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_SEADJ(p)		(SYM_ANYADJ(p))
#define	SYM_SEAOFF(p)		(SYM_ANYAOFF(p))

#define	SYM_RANAME(p)		(SYM_ANYNAME(p))
#define	SYM_RATYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_RASEGMENT(p)	(SYM_ANYSEGMENT(p))
#define	SYM_RAHASH(p)		(M140(p).raw_hash)

#define	SYM_FUNEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_FUNAME(p)		(SYM_ANYNAME(p))
#define	SYM_FUTYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_FUKEY(p)		(SYM_ANYKEY(p))
#define	SYM_FUREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_FUCLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_FUADJ(p)		(SYM_ANYADJ(p))
#define	SYM_FUSEGMENT(p)	(SYM_ANYSEGMENT(p))
#define	SYM_FUAOFF(p)		(SYM_ANYAOFF(p))
#define	SYM_FUASEG(p)		(SYM_ANYASEG(p))

#define	SYM_FONEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_FONAME(p)		(SYM_ANYNAME(p))
#define	SYM_FOTYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_FOKEY(p)		(SYM_ANYKEY(p))
#define	SYM_FOREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_FOCLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_FOADJ(p)		(SYM_ANYADJ(p))
#define	SYM_FOAOFF(p)		(SYM_ANYAOFF(p))
#define	SYM_FOPREV(p)		(M150(p).formal_prev)

#define	SYM_LANEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_LANAME(p)		(SYM_ANYNAME(p))
#define	SYM_LATYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_LAKEY(p)		(SYM_ANYKEY(p))
#define	SYM_LAREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_LACLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_LAADJ(p)		(SYM_ANYADJ(p))
#define	SYM_LAAOFF(p)		(SYM_ANYAOFF(p))
#define	SYM_LAASEG(p)		(SYM_ANYASEG(p))
#define	SYM_LATEMPLATE(p)	(M160(p).label_template)

#define	SYM_INNEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_INNAME(p)		(SYM_ANYNAME(p))
#define	SYM_INTYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_INKEY(p)		(SYM_ANYKEY(p))
#define	SYM_INREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_INCLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_INADJ(p)		(SYM_ANYADJ(p))
#define	SYM_INNUMBER(p)		(M170(p).intrin_ino)
#define	SYM_INNPARMS(p)		(M170(p).intrin_nparms)

#define	SYM_TANEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_TANAME(p)		(SYM_ANYNAME(p))
#define	SYM_TATYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_TAKEY(p)		(SYM_ANYKEY(p))
#define	SYM_TASIZE(p)		(M180(p).tag_size)
#define	SYM_TAALIGN(p)		(M180(p).tag_align)

#define	SYM_MENEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_MENAME(p)		(SYM_ANYNAME(p))
#define	SYM_METYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_MEPREV(p)		(M190(p).member_prev)
#define	SYM_MEOFFSET(p)		(M190(p).member_offset)
#define	SYM_MEVACCESS(p)	(M190(p).member_vaccess)

#define	SYM_FINEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_FINAME(p)		(SYM_ANYNAME(p))
#define	SYM_FITYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_FIPREV(p)		(M190(p).member_prev)
#define	SYM_FIOFFSET(p)		(M190(p).member_offset)
#define	SYM_FIVACCESS(p)	(M190(p).member_vaccess)
#define	SYM_FIBITSTART(p)	(M200(p).field_bitstart)
#define	SYM_FINBITS(p)		(M200(p).field_nbits)

#define	SYM_MONEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_MONAME(p)		(SYM_ANYNAME(p))
#define	SYM_MOVALUE(p)		((p)->m95.moe_value)

/*
**	macros for acessing informmation on symbols type
*/
#define	SYM_ANYBTYPE(P)		(TY_BTYPE(SYM_ANYTYPE(P)))
#define	SYM_ANYESU(P)		(TY_ESU(SYM_ANYTYPE(P)))
#define	SYM_ANYTINDEX(P)	(TY_TINDEX(SYM_ANYTYPE(P)))
#define	SYM_ANYINDIR(P)		(TY_INDIR(SYM_SYTYPE(P)))

#define	SYM_ANYISUB(P)		(INDIR_ISUB(SYM_ANYINDIR(P)))
#define	SYM_ANYINEXT(P)		(INDIR_INEXT(SYM_ANYINDIR(P)))
#define	SYM_ANYITYPE(P)		(INDIR_ITYPE(SYM_ANYINDIR(P)))
#define	SYM_ANYIFORMALS(P)	(INDIR_IFORMALS(SYM_ANYINDIR(P)))

#define	SYM_NEAR(P)			(IS_NEAR(SYM_ANYBTYPE(P)))
#define	SYM_FAR(P)			(IS_FAR(SYM_ANYBTYPE(P)))
#define	SYM_HUGE(P)			(IS_HUGE(SYM_ANYBTYPE(P)))
#define	SYM_CONST(P)		(IS_CONST(SYM_ANYBTYPE(P)))
/*
**  the symbol table
*/
struct	s_table	{
	table_t		*st_next;	/*  link to next  */
	table_t		*st_incl;	/*  block is included in block pointer  */
	fpsym_t		*st_table;	/*  ptr to hash table  */
	blknum_t	st_level;	/*  block level  */
	uchar_t		st_size;	/*  number of entries in hash table  */
	};
/*
**  macros for accessing the symbol tables.
**	`level' is the level of interest.
**	`ptab' is a ptr to a symbol table
*/
#define	ST_NEXT(ptab)			((ptab)->st_next)
#define	ST_INCL(ptab)			((ptab)->st_incl)
#define	ST_SYM(ptab)			((ptab)->st_table)
#define	ST_LEVEL(ptab)			((ptab)->st_level)
#define	ST_MOD(ptab)			((ptab)->st_size)

#define	ST_TABLE(level)			((level) ? Table_n : Table_0)
#define	ST_BUCKET(ptab,hash)	(((ptab)->st_table[hash & ST_MOD(ptab)]))

/*
**	A Hash/Length/Name string is one where the first character is the hash
**	of the name.  The second character is the length of the identifier
**	including the hash and length characters.  The name begins at the third
**	character. 
*/
#define	HLN_IDENT_HASH(P)		(HLN_HASH(*(P)))
#define	HLN_IDENT_LENGTH(P)		(HLN_LENGTH(*(P)))
#define	HLN_IDENTP_NAME(P)		(HLN_NAME(*(P)))
/*
**  delcaration specifiers, used by to hold both the class and the type.
*/
struct	s_declspec	{
	class_t	ds_class;
	ptype_t	ds_type;
	};

#define	DSP_CLASS(p)	((p)->ds_class)
#define	DSP_TYPE(p)		((p)->ds_type)
#define	DS_CLASS(p)		((p).ds_class)
#define	DS_TYPE(p)		((p).ds_type)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\scanner.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* SCANNER.C - Routines for token scanning				*/
/*									*/
/* 29-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <limits.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"
#include "charmap.h"
#include "grammar.h"
#include "rcunicod.h"


#define ABS(x) ((x > 0) ? x : -1 * x)


#define ALERT_CHAR	'\007'		/* ANSI alert character is ASCII BEL */

extern int vfCurrFileType;	//- Added for 16-bit file support.


/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
token_t	c_size(long);
int	ctoi(int);
int	escape(int);
token_t	get_real(PUCHAR);
token_t	l_size(long);
long	matol(PUCHAR, int);
token_t	uc_size(long);
token_t	ul_size(long);
void	skip_1comment(void);



/************************************************************************/
/* local_c_hash								*/
/************************************************************************/
hash_t	local_c_hash(REG char *name)
{
    REG	hash_t 	i;

    i = 0;
    while(*name) {
	i += (*name & HASH_MASK);
	name++;
    }
    return(i);
}


/************************************************************************ 
 * GETID - Get an identifier or keyword.
 * (we know that we're given at least 1 id char)
 * in addition, we'll hash the value using 'c'.
 ************************************************************************/
void getid(REG	UINT	c)
{
    REG	UCHAR	*p;

    p = Reuse_1;
    *p++ = (UCHAR)c;
    c &= HASH_MASK;

repeat:
    while(LXC_IS_IDENT(*p = GETCH())) {    /* while it's an id char . . . */
	c += (*p & HASH_MASK);			/* hash it */
	p++;
    }
    if(*p != EOS_CHAR) {
	if((*p == '\\') && (checknl())) {
	    goto repeat;
	}
	UNGETCH();
	if(p >= LIMIT(Reuse_1)) {
	    Msg_Temp = GET_MSG (1067);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal(1067);
	}
	if(	((p - Reuse_1) > LIMIT_ID_LENGTH) && ( ! Prep )) {
	    p = Reuse_1 + LIMIT_ID_LENGTH;
	    *p++ = '\0';
	    c = local_c_hash(Reuse_1);
	    Msg_Temp = GET_MSG (4011);
	    SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	    warning(4011);	/* id truncated */
	}
	else {
	    *p++ = '\0';
	}
	Reuse_1_hash = (UCHAR)c;
	Reuse_1_length = (UCHAR)(p - Reuse_1);
	return;
    }
    if(io_eob()) {			/* end of file in middle of id */
	Msg_Temp = GET_MSG (1004);
	SET_MSG (Msg_Text, Msg_Temp);
	fatal(1004);
    }
    goto repeat;
}


/************************************************************************
**	prep_string : outputs char/string constants when preprocessing only
************************************************************************/
void   prep_string(REG UCHAR c)
{
    REG char *p_buf;
    int term_char;

    p_buf = Reuse_1;
    term_char = c;

    *p_buf++ = c;		/*  save the open quote  */

    //-
    //- The following check was added to support 16-bit files.
    //- For the 8-bit file, the code has not changed at all.
    //-
    if (vfCurrFileType == DFT_FILE_IS_8_BIT) {

	for(;;) {
	    switch(CHARMAP(c = GETCH())) {
	    case LX_DQUOTE:
	    case LX_SQUOTE:
		if(c == (UCHAR)term_char) {
		    *p_buf++ = (UCHAR)term_char;/* save the terminating quote */
		    goto out_of_loop;
		}
		break;
	    case LX_BACKSLASH:
	    case LX_LEADBYTE:
		*p_buf++ = c;
		c = get_non_eof();
		break;
	    case LX_CR:								
		continue;
	    case LX_NL:		
		UNGETCH();				
		goto out_of_loop;
	    case LX_EOS:
		if(c == '\\') {
		    *p_buf++ = c;
		    c = get_non_eof();
		    break;
		}
		handle_eos();
		continue;
		break;
	    }
	    *p_buf++ = c;
	    if(p_buf == &Reuse_1[MED_BUFFER - 1]) {
		*p_buf = '\0';
		fwrite(Reuse_1, (size_t)(p_buf - Reuse_1), 1, OUTPUTFILE);
		p_buf = Reuse_1;
	    }
	}

    } else {

	WCHAR 	wchCurr;

	for(;;) {

	    wchCurr = (WCHAR)wchCheckWideChar ();
	    c = GETCH ();    //- Make sure buffers increment normally.

	    if (wchCurr < 127) {

		switch(CHARMAP(c)) {

		case LX_DQUOTE:
		case LX_SQUOTE:
		    if(c == (UCHAR)term_char) {
			*p_buf++ = (UCHAR)term_char;/* save the quote */
			goto out_of_loop;
		    }
		    break;
		case LX_BACKSLASH:
		    *p_buf++ = c;
		    break;
		case LX_CR:
		    continue;
		case LX_NL:		
		    UNGETCH();				
		    goto out_of_loop;
		case LX_EOS:
		    handle_eos ();
		    continue;
		}

		*p_buf++ = c;

	    } else {

		//- Write out as 6 octal characters.
		//- This is the safest way to do it.

		*p_buf++ = '\\';
		*p_buf++ = (CHAR)('0' + ((wchCurr >> 15) & 7));
		*p_buf++ = (CHAR)('0' + ((wchCurr >> 12) & 7));
		*p_buf++ = (CHAR)('0' + ((wchCurr >> 9) & 7));
		*p_buf++ = (CHAR)('0' + ((wchCurr >> 6) & 7));
		*p_buf++ = (CHAR)('0' + ((wchCurr >> 3) & 7));
		*p_buf++ = (CHAR)('0' + (wchCurr & 7));
	    }

	    if(p_buf > &Reuse_1[MED_BUFFER - 10]) {
		*p_buf = '\0';
		fwrite(Reuse_1, (size_t)(p_buf - Reuse_1), 1, OUTPUTFILE);
		p_buf = Reuse_1;
	    }
	}
    }

out_of_loop:
	*p_buf = '\0';
	fwrite(Reuse_1, (size_t)(p_buf - Reuse_1), 1, OUTPUTFILE);
}


/************************************************************************
**	char_const : gather up a character constant
**  we're called after finding the openning single quote.
************************************************************************/
token_t char_const(void)
{
    REG UCHAR c;
    value_t value;
    token_t	tok;

    tok = (token_t)(Jflag ? L_CUNSIGNED : L_CINTEGER);
first_switch:
    switch(CHARMAP(c = GETCH())) {
    case LX_BACKSLASH:
	break;
    case LX_SQUOTE:
	Msg_Temp = GET_MSG (2137);
	SET_MSG (Msg_Text, Msg_Temp); /* empty character constant */
	error(2137);
	value.v_long = 0;
	UNGETCH();
	break;
    case LX_EOS:		/* ??? assumes i/o buffering > 1 char */
	if(handle_eos() != BACKSLASH_EOS) {
	    goto first_switch;
	}
	value.v_long = escape(get_non_eof());
	if( tok == L_CUNSIGNED ) {		/* don't sign extend */
	    value.v_long &= 0xff;
	}
	break;
    case LX_NL:
	/* newline in character constant */
	Msg_Temp = GET_MSG (2001);
	SET_MSG(Msg_Text, Msg_Temp);
	error (2001);
	UNGETCH();
	/*
		**  FALLTHROUGH
		*/
    default:
	value.v_long = c;
	break;
    }
    if((c = get_non_eof()) != '\'') {
	Msg_Temp = GET_MSG (2015);
	SET_MSG (Msg_Text, Msg_Temp);
	error (2015);		/* too many chars in constant */
	do {
	    if(c == '\n') {
		Msg_Temp = GET_MSG (2016);
		SET_MSG (Msg_Text, Msg_Temp);
		error(2016);		/* missing closing ' */
		    break;
	    }
	} while((c = get_non_eof()) != '\'');
    }
    yylval.yy_tree = build_const(tok, &value);
    return(tok);
}


/************************************************************************
**	str_const : gather up a string constant
************************************************************************/
void   str_const(VOID)
{
    REG UCHAR c;
    REG PUCHAR	p_buf;
    int not_warned_yet = TRUE;

    p_buf = yylval.yy_string.str_ptr = Macro_buffer;
    /*
	**	Is it possible that reading this string during a rescan will
	**	overwrite the expansion being rescanned?  No, because a macro
	**	expansion is limited to the top half of Macro_buffer.  
	**	For Macro_depth > 0, this is like copying the string from 
	**	somewhere in the top half of Macro_buffer to the bottom half
	**	of Macro_buffer.
	**	Note that the restriction on the size of an expanded macro is
	**	stricter than the limit on an L_STRING length.  An expanded
	**	macro is limited to around 1019 bytes, but an L_STRING is
	**	limited to 2043 bytes.
	*/
    for(;;) {
	switch(CHARMAP(c = GETCH())) {
	case LX_NL:
	    UNGETCH();
	    Msg_Temp = GET_MSG (2001);
	    SET_MSG (Msg_Text, Msg_Temp);
	    error(2001);
	    /*
			**  FALLTHROUGH
			*/
	case LX_DQUOTE:
	    *p_buf++ = '\0';
	    yylval.yy_string.str_len = (USHORT)(p_buf-yylval.yy_string.str_ptr);
	    return;
	    break;
	case LX_LEADBYTE:
	    *p_buf++ = c;
	    c = get_non_eof();
	    break;
	case LX_EOS:
	    if(handle_eos() != BACKSLASH_EOS) {
		continue;
	    }
	    if(InInclude) {
		break;
	    }
	    else {
		c = (UCHAR)escape(get_non_eof());  /* process escaped char */
	    }
	    break;
	}
	if(p_buf - Macro_buffer > LIMIT_STRING_LENGTH) {
	    if( not_warned_yet ) {
		Msg_Temp = GET_MSG (4009);
		SET_MSG (Msg_Text, Msg_Temp);
		warning(4009);		/* string too big, truncating */
		not_warned_yet = FALSE;
	    }
	}
	else {
	    *p_buf++ = c;
	}
    }
}


/************************************************************************
**  do_newline : does work after a newline has been found.
************************************************************************/
void   do_newline()
{
    ++Linenumber;
    for(;;) {
	switch(CHARMAP(GETCH())) {
	case LX_CR:						
	    break;
	case LX_POUND:	
	    preprocess();	
	    break;
	case LX_SLASH:
	    if( ! skip_comment()) {
		goto leave_do_newline;
	    }
	    break;
	case LX_NL:
	    Linenumber++;
	    /*
			**  FALLTHROUGH
			*/
	case LX_WHITE:
	    if( Prep ) {	/*  preprocessing only, output whitespace  */
		fputc(PREVCH(), OUTPUTFILE);
	    }
	    else {
		do {
		    ;
		} while(LXC_IS_WHITE(GETCH()));
		UNGETCH();
	    }
	    break;
	case LX_EOS:
	    if(PREVCH() == EOS_CHAR || PREVCH() == CONTROL_Z) {
		if(io_eob()) {		/* leaves us pointing at a valid char */
		    return;
		}
		break;
	    }
	    if(checknl()) {
		continue;
	    }
	    /* it's a backslash */
	    /*
			**	FALLTHROUGH
			*/
	default:		/* first non-white is not a '#', leave */

leave_do_newline:

	    UNGETCH();
	    return;
	}
    }
}


/************************************************************************
 * GETNUM - Get a number from the input stream.
 *
 * ARGUMENTS
 *	radix - the radix of the number to be accumulated.  Can only be 8, 10,
 *			or 16
 *	pval - a pointer to a VALUE union to be filled in with the value
 *
 * RETURNS - type of the token (L_CINTEGER or L_CFLOAT)
 *
 * SIDE EFFECTS - 
 *	does push back on the input stream.
 *	writes into pval by reference
 *  uses buffer Reuse_1
 *
 * DESCRIPTION - 
 *	Accumulate the number according to the rules for each radix.
 *	Set up the format string according to the radix (or distinguish
 *	integer from float if radix is 10) and convert to binary.
 *
 * AUTHOR - Ralph Ryan, Sept. 8, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
token_t getnum(REG	UCHAR		c)
{
    REG	char	*p;
    UCHAR	*start;
    int		radix;
    token_t	tok;
    value_t	value;

    tok = L_CINTEGER;
    start = (Tiny_lexer_nesting ? Exp_ptr : Reuse_1);
    p = start;
    if( c == '0' ) {
	c = get_non_eof();
	if( IS_X(c) ) {
	    radix = 16;
	    if( Prep ) {
		*p++ = '0';
		*p++ = 'x';
	    }
	    for(c = get_non_eof(); LXC_IS_XDIGIT(c); c = get_non_eof()) {
		/* no check for overflow? */
		*p++ = c;
	    }
	    if((p == Reuse_1) && (Tiny_lexer_nesting == 0)) {
		Msg_Temp = GET_MSG (2153);
		SET_MSG (Msg_Text, Msg_Temp);
		error(2153);
	    }
	    goto check_suffix;
	}
	else {
	    radix = 8;
	    *p++ = '0';	/* for preprocessing or 0.xxx case */
	}
    }
    else {
	radix = 10;
    }

    while( LXC_IS_DIGIT(c) ) {
	*p++ = c;
	c = get_non_eof();
    }

    if( IS_DOT(c) || IS_E(c) ) {
	UNGETCH();
	return(get_real(p));
    }

check_suffix:
    if( IS_EL(c) ) {
	if( Prep ) {
	    *p++ = c;
	}
	c = get_non_eof();
	if( IS_U(c) ) {
	    if(Prep) {
		*p++ = c;
	    }
	    tok = L_LONGUNSIGNED;
	}
	else {
	    tok = L_LONGINT;
	    UNGETCH();
	}
    }
    else if( IS_U(c) ) {
	if( Prep ) {
	    *p++ = c;
	}
	c = get_non_eof();
	if( IS_EL(c) ) {
	    if( Prep ) {
		*p++ = c;
	    }
	    tok = L_LONGUNSIGNED;
	}
	else {
	    tok = L_CUNSIGNED;
	    UNGETCH();
	}
    }
    else {
	UNGETCH();
    }
    *p = '\0';
    if( start == Exp_ptr ) {
	Exp_ptr = p;
	return(L_NOTOKEN);
    }
    else if( Prep ) {
	fwrite( Reuse_1, (size_t)(p - Reuse_1), 1, OUTPUTFILE);
	return(L_NOTOKEN);
    }
    value.v_long = matol(Reuse_1,radix);
    switch(tok) {
    case L_CINTEGER:
	tok = (radix == 10)
	    ? c_size(value.v_long)
	    : uc_size(value.v_long)
	    ;
	break;
    case L_LONGINT:
	tok = l_size(value.v_long);
	break;
    case L_CUNSIGNED:
	tok = ul_size(value.v_long);
	break;
    }
    yylval.yy_tree = build_const(tok, &value);
    return(tok);
}


/************************************************************************
**  get_real : gathers the real part/exponent of a real number.
**		Input  : ptr to the null terminator of the whole part
**				 pointer to receive value.
**		Output : L_CFLOAT
**
**  ASSUMES whole part is either at Exp_ptr or Reuse_1.
************************************************************************/
token_t	   get_real(REG	PUCHAR p)
{
    REG	int		c;
    token_t	tok;

    c = get_non_eof();
    if(Cross_compile && (Tiny_lexer_nesting == 0)) {
	Msg_Temp = GET_MSG (4012);
	SET_MSG (Msg_Text, Msg_Temp);
	warning(4012);	/* float constant in cross compilation */
	Cross_compile = FALSE;	/*  only one msg per file */
    }
    /*
**  if the next char is a digit, then we've been called after
**  finding a '.'. if this is true, then
**  we want to find the fractional part of the number.
**  if it's a '.', then we've been called after finding
**  a whole part, and we want the fraction.
*/
    if( LXC_IS_DIGIT(c) || IS_DOT(c) ) {
	do {
	    *p++ = (UCHAR)c;
	    c = (int)get_non_eof();
	} while( LXC_IS_DIGIT(c) );
    }
    if( IS_E(c) ) {			/*  now have found the exponent  */
	*p++ = (UCHAR)c;		/*  save the 'e'  */
	c = (UCHAR)get_non_eof();	/*  skip it  */
	if( IS_SIGN(c) ) {		/*  optional sign  */
	    *p++ = (UCHAR)c;		/*  save the sign  */
	    c = (int)get_non_eof();
	}
	if( ! LXC_IS_DIGIT(c)) {
	    if( ! Rflag ) {
	        if(Tiny_lexer_nesting == 0) {
		    Msg_Temp = GET_MSG (2021);
		    SET_MSG (Msg_Text, Msg_Temp, c);
		    error(2021); /* missing or malformed exponent */
	        }
	        *p++ = '0';
	    }
	}
	else {
	    do {			/* gather the exponent */
		*p++ = (UCHAR)c;
		c = (int)get_non_eof();
	    } while( LXC_IS_DIGIT(c) );
	}
    }
    if( IS_F(c) ) {
	tok = L_CFLOAT;
	if( Prep ) {
	    *p++ = (UCHAR)c;
	}
    }
    else if( IS_EL(c) ) {
	tok = L_CLDOUBLE;
	if( Prep ) {
	    *p++ = (UCHAR)c;
	}
    }
    else {
	UNGETCH();
	tok = L_CDOUBLE;
    }
    *p = '\0';
    if( Tiny_lexer_nesting > 0 ) {
	Exp_ptr = p;
	return(L_NOTOKEN);
    }
    else if( Prep ) {
	fwrite( Reuse_1, (size_t)(p - Reuse_1), 1, OUTPUTFILE);
	return(L_NOTOKEN);
    }
    /*
	** reals aren't used during preprocessing
	*/
    return(tok);
}


/************************************************************************
**  matol : ascii to long, given a radix.
************************************************************************/
long	   matol(REG PUCHAR p_start,REG int radix)
{
    long	result, old_result;
    unsigned	int	i;

    old_result = result = 0;
    while(*p_start) {
	result *= radix;
	i = ctoi(*p_start);
	if( ((int)i >= radix) && (! Prep) ) {
	    Msg_Temp = GET_MSG (2020);
	    SET_MSG (Msg_Text, Msg_Temp, *p_start, radix);
	    error(2020); /* illegal digit % for base % */
	}
	result += i;
	p_start++;
	if(radix == 10) {
	    if(result < old_result) {
		p_start--;   /*  fix the string ptr since we have overflowed  */
		break;
	    }
	}
	else if(*p_start) {
	    /*
		**  the loop is not finished.
		**  we will multiply by the radix again
		**  check the upper bits. if they're on, then
		**  that mult will overflow the value
		*/
	    if(radix == 8) {
		if(result & 0xe0000000) {
		    break;
		}
	    }
	    else if(result & 0xf0000000) {
		break;
	    }
	}
	old_result = result;
    }
    if(*p_start) {
	Msg_Temp = GET_MSG (2177);
	SET_MSG (Msg_Text, Msg_Temp);
	error(2177);		/* constant too big */
	result = 0;
    }
    return(result);
}


/************************************************************************
**  uc_size : returns 'int' or 'long' (virtual unsigned).
**  if their are no bits in the upper part of the value,
**  then it's an int. otherwise, it's a long.
**  this is valid too if target sizeof(int) != sizeof(long).
**  then L_CINTEGER and L_LONGINT are synonymous.
************************************************************************/
token_t	uc_size(long value)
{
    return((token_t)((value > INT_MAX) ? L_CUNSIGNED : L_CINTEGER));
}


/************************************************************************
**  c_size : returns 'int' or 'long' for signed numbers.
**  if the sign bit of the lower word is on or any bits
**  in the upper word are on, then we must use 'long'.
************************************************************************/
token_t c_size(long value)
{
    return((token_t)((ABS(value) > INT_MAX) ? L_LONGINT : L_CINTEGER));
}


/************************************************************************
**  l_size : returns 'longint' or 'longunsigned' for long numbers.
**  if the sign bit of the high word is on this is 'longunsigned';
************************************************************************/
token_t	l_size(long	value)
{
    return((token_t)((value > LONG_MAX) ? L_LONGUNSIGNED : L_LONGINT));
}


/************************************************************************
**	ul_size : returns 'unsigned' or 'longunsigned' for unsigned numbers.
**	if the number can't be represented as unsigned, it is promoted to
**	unsignedlong.
************************************************************************/
token_t	ul_size(long value)
{
    return((token_t)((ABS(value) > UINT_MAX-1) ? L_LONGUNSIGNED : L_CUNSIGNED));
}


/************************************************************************
**  ctoi : character to int.
************************************************************************/
int	  ctoi(int	c)
{
    if(LXC_IS_DIGIT(c)) {
	return(c - '0');
    }
    else {
	return(toupper(c) - toupper('A') + 10);
    }
}


/************************************************************************
 * ESCAPE - get an escaped character
 *
 * ARGUMENTS - none
 *
 * RETURNS - value of escaped character
 *
 * SIDE EFFECTS - may push back input
 *
 * DESCRIPTION - An escape ( '\' ) was discovered in the input.  Translate
 *	 the next symbol or symbols into an escape sequence.
 *
 * AUTHOR - Ralph Ryan, Sept. 7, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int escape(REG int c)
{
    REG int value;
    int cnt;

escape_again:
    if( LXC_IS_ODIGIT(c) ) {/* \ooo is an octal number, must fit into a byte */
	cnt = 1;
	for(value = ctoi(c), c = get_non_eof();
	    (cnt < 3) && LXC_IS_ODIGIT(c);
	    cnt++, c = get_non_eof()
	    ) {
	    value *= 8;
	    value += ctoi(c);
	}
	if( ! Prep ) {
	    if(value > 255) {
		Msg_Temp = GET_MSG (2022);
		SET_MSG (Msg_Text, Msg_Temp, value);
		error (2022);
	    }
	}
	UNGETCH();
	return((char)value);
    }
    switch( c ) {
    case 'a':	
	return(ALERT_CHAR);	
	break;
    case 'b':	
	return('\b');		
	break;
    case 'f':	
	return('\f');		
	break;
    case 'n':	
	return('\n');		
	break;
    case 'r':	
	return('\r');		
	break;
    case 't':	
	return('\t');		
	break;
    case 'v':	
	return('\v');		
	break;
    case 'x':
	cnt = 0;
	value = 0;
	c = get_non_eof();
	while((cnt < 3) && LXC_IS_XDIGIT(c)) {
	    value *= 16;
	    value += ctoi(c);
	    c = get_non_eof();
	    cnt++;
	}
	if(cnt == 0) {
	    Msg_Temp = GET_MSG (2153);
	    SET_MSG (Msg_Text, Msg_Temp);
	    error (2153);
	}
	UNGETCH();
	return((char)value);	/* cast to get sign extend */
    default:
	if(c != '\\') {
	    return(c);
	}
	else {
	    if(checknl()) {
		c = get_non_eof();
		goto escape_again;
	    }
	    else {
		return(c);
	    }
	}
    }
}


/************************************************************************ 
 * CHECKOP - Check whether the next input character matches the argument.
 *
 * ARGUMENTS
 *	short op - the character to be checked against
 *
 * RETURNS  
 *	TRUE or FALSE
 *
 * SIDE EFFECTS  
 *	Will push character back onto the input if there is no match.
 *
 * DESCRIPTION  
 *	If the next input character matches op, return TRUE.  Otherwise
 *	push it back onto the input.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int checkop(int op)
{
    if(op == (int)get_non_eof()) {
	return(TRUE);
    }
    UNGETCH();
    return(FALSE);
}


/************************************************************************
**  DumpSlashComment : while skipping a comment, output it.
************************************************************************/
void   DumpSlashComment(VOID)
{
    if( ! Cflag ) {
	skip_NLonly();
	return;
    }
    fwrite("//", 2, 1, OUTPUTFILE);
    for(;;) {
	REG UCHAR c;

	switch(CHARMAP(c = GETCH())) {
	case LX_CR:								
	    continue;
	case LX_EOS:	
	    handle_eos();			
	    continue;
	case LX_NL:		
	    UNGETCH();				
	    return;
	}
	fputc(c, OUTPUTFILE);
    }
}


/************************************************************************
**  dump_comment : while skipping a comment, output it.
************************************************************************/
void   dump_comment()
{
    if( ! Cflag ) {
	skip_1comment();
	return;
    }
    fwrite("/*", 2, 1, OUTPUTFILE);
    for(;;) {
	REG UCHAR c;

	switch(CHARMAP(c = GETCH())) {
	case LX_STAR:
	    if(checkop('/')) {
		fwrite("*/", 2, 1, OUTPUTFILE);
		return;
	    }
	    break;
	case LX_EOS:	
	    handle_eos();			
	    continue;
	case LX_NL:		
	    Linenumber++;			
	    break;	/* output below */
	case LX_CR:								
	    continue;
	}
	fputc(c, OUTPUTFILE);
    }
}

/************************************************************************/
/* skip_comment()							*/
/************************************************************************/
int skip_comment(void)
{
    if(checkop('*')) {
	skip_1comment();
	return(TRUE);
    }
    else if(checkop('/')) {
	skip_NLonly();
	return(TRUE);
    }
    else {
	return(FALSE);
    }
}


/************************************************************************
**  skip_1comment : we're called when we're already in a comment.
**  we're looking for the comment close. we also count newlines
**  and output them if we're preprocessing.
************************************************************************/
void   skip_1comment(void)
{
    UINT	c;

    for(;;) {
	c = GETCH();
	if(c == '*') {

recheck:

	    c = GETCH();
	    if(c == '/') {	/* end of comment */
		return;
	    }
	    else if(c == '*') {
		/*
		**  if we get another '*' go back and check for a slash
		*/
		goto recheck;
	    }
	    else if(c == EOS_CHAR) {
		handle_eos();
		goto recheck;
	    }
	}
	/*
	**  note we fall through here. we know this baby is not a '*'
	**  we used to unget the char and continue. since we check for
	**  another '*' inside the above test, we can fall through here
	**  without ungetting/getting and checking again.
	*/
	if(c <= '\n') {
	    /*
	    **  hopefully, the above test is less expensive than doing two tests
	    */
	    if(c == '\n') {
		Linenumber++;
		if(Prep) {
		    fputc('\n', OUTPUTFILE);
		}
	    }
	    else if(c == EOS_CHAR) {
		handle_eos();
	    }
	}
    }
}


/************************************************************************
**  skip_cwhite : while the current character is whitespace or a comment.
**  a newline is NOT whitespace.
************************************************************************/
UCHAR	  skip_cwhite(void)
{
    REG	UCHAR		c;

skip_cwhite_again:
    while((c = GETCH()) <= '/') {	/* many chars are above this */
	if(c == '/') {
	    if( ! skip_comment()) {
		return('/');
	    }
	}
	else if(c > ' ') {		/* char is between '!' and '.' */
	    return(c);
	}
	else {
	    switch(CHARMAP(c)) {
	    case LX_EOS:
		handle_eos();
		break;
	    case LX_WHITE:	
		continue;	
		break;
	    case LX_CR:		
		continue;	
		break;
	    default:		
		return(c);	
		break;
	    }
	}
    }
    if((c == '\\') && (checknl())) {
	goto skip_cwhite_again;
    }
    return(c);
}


/************************************************************************
**  checknl : check for newline, skipping carriage return if there is one.
**  also increments Linenumber, so this should be used by routines which
**  will not push the newline back in such a way that rawtok() will be invoked,
**  find the newline and do another increment.
************************************************************************/
int checknl(void)
{
    REG	UCHAR		c;

    for(;;) {
	c = GETCH();
	if(c > '\r') {
	    UNGETCH();
	    return(FALSE);
	}
	switch(c) {
	case '\n':
	    Linenumber++;
	    if( Prep ) {
		fputc('\n', OUTPUTFILE);
	    }
	    return(TRUE);
	    break;
	case '\r':							
	    continue;		
	    break;
	case EOS_CHAR:
	    handle_eos();
	    PREVCH() = '\\';	/* M00HACK - needs pushback */
	    continue;
	    break;
	default:		
	    UNGETCH();			
	    return(FALSE);	
	    break;
	}
    }
}


/************************************************************************
**  get_non_eof : get a real char.
************************************************************************/
UCHAR	  get_non_eof(void)
{
    UCHAR		c;

get_non_eof_again:
    while((c = GETCH()) <= '\r') {
	if(c == '\r') {
	    continue;
	}
	else if(c != EOS_CHAR) {
	    break;
	}
	if(Tiny_lexer_nesting > 0) {
	    break;
	}
	handle_eos();
    }
    if((c == '\\') && (checknl())) {
	goto get_non_eof_again;
    }
    return(c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\trees.h ===
/*
**	Tree types
*/
#define	TTfree			0x0
#define	TTconstant		0x01
#define	TTsymbol		0x02
#define	TTunary			0x04
#define	TTleaf			0x08
#define	TTbinary		0x10
#define	TThybrid		0x20
#define	TTBasicShape	(TTfree|TTconstant|TTsymbol|TTunary|TTbinary|TThybrid)
#define	TTzero			0x40

typedef	USHORT		p2type_t;
typedef	p2type_t	*pp2type_t;

typedef	struct	tree_200	{
	ptree_t		tr_left;	/*  left child  */
	ptree_t		tr_right;	/*  right child  */
	} tree_200_st;

typedef	struct	tree_190	{
	ptree_t		tr_uchild;	/*  unary child  */
	} tree_190_st;

typedef	struct	tree_180	{
	psym_t		tr_symbol;	/*  symbol  */
	} tree_180_st;

typedef	struct	tree_170	{
	value_t		tr_value;	/*  value of the tree  */
	} tree_170_st;

typedef	union	tree_100	{
	tree_200_st	t200;
	tree_190_st	t190;
	tree_180_st	t180;
	tree_170_st	t170;
	} tree_100_st;

struct	s_tree	{
	token_t		tr_token;	/*  tree's token  */
	shape_t		tr_shape;	/*  tree shape  */
	ptype_t		tr_p1type;	/*  p1's view of the type  */
	p2type_t	tr_p2type;	/*  p1's view of the type p2 should have */
	tree_100_st	t100;
	};

#define	TR_SHAPE(P)		((P)->tr_shape)
#define	BASIC_SHAPE(S)	((S) & TTBasicShape)
#define	TR_TOKEN(P)		((P)->tr_token)
#define	TR_P1TYPE(P)	((P)->tr_p1type)		/*  resultant type  */
#define	TR_P2TYPE(P)	((P)->tr_p2type)		/*  resultant type  */
#define	TR_ISZERO(P)	(TR_SHAPE(P) & TTzero)

#define	TR_LEFT(P)		((P)->t100.t200.tr_left)	/*  left child  */
#define	TR_RIGHT(P)		((P)->t100.t200.tr_right)	/*  right child  */
#define	TR_UCHILD(P)	((P)->t100.t190.tr_uchild)	/*  unary's child */
#define	TR_SVALUE(P)	((P)->t100.t180.tr_symbol)	/*  ptr to the symbol */
#define	TR_VALUE(P)		((P)->t100.t170.tr_value)	/*  value of tree  */

#define	TR_RCON(P)		(TR_VALUE(P).v_rcon)		/*  real constant  */
#define	TR_DVALUE(P)	(TR_RCON(P)->rcon_real)	/*  double value  */
#define	TR_LVALUE(P)	(TR_VALUE(P).v_long)		/*  long value  */
#define	TR_STRING(P)	(TR_VALUE(P).v_string)	/*  string value  */

#define	TR_CVALUE(P)	(TR_STRING(P).str_ptr)	/*  ptr to string  */
#define	TR_CLEN(P)		(TR_STRING(P).str_len)	/*  length of string  */

#define	TR_BTYPE(P)		(TY_BTYPE(TR_P1TYPE(P)))/*  base type  */
#define	TR_ESU(P)		(TY_ESU(TR_P1TYPE(P)))	/*  parent enum/struct/union  */
#define	TR_INDIR(P)		(TY_INDIR(TR_P1TYPE(P)))

#define	TR_INEXT(P)		(INDIR_INEXT(TR_INDIR(P)))
#define	TR_ITYPE(P)		(INDIR_ITYPE(TR_INDIR(P)))
#define	TR_ISUB(P)		(INDIR_ISUB(TR_INDIR(P)))
#define	TR_IFORMALS(P)	(INDIR_IFORMALS(TR_INDIR(P)))
/*
**  for cases
*/
struct	s_case	{
	case_t	*c_next;	/*  next in list  */
	long	c_expr;		/*  value of constant expression  */
	p1key_t	c_label;	/*  label to which to jump if expr  */
	};

#define	NEXT_CASE(p)	((p)->c_next)
#define	CASE_EXPR(p)	((p)->c_expr)
#define	CASE_LABEL(p)	((p)->c_label)

/*
**  loop inversion structs
**  for( init; test; incr ) { ... }
**  we handle : sym | const relop sym | const; sym op sym | const
*/
typedef	struct	s_loopia	 loopia_t, *loopiap_t;
typedef	struct	s_liarray	 liarray_t, *liarrayp_t;

struct	s_loopia	{
	token_t		lia_token;
	union	{
		psym_t		lia_sym;
		long		lia_value;
		liarrayp_t	lia_array;
		} lia_union;
	};

#define	LIA_TOKEN(p)	((p)->lia_token)
#define	LIA_SYM(p)		((p)->lia_union.lia_sym)
#define	LIA_VALUE(p)	((p)->lia_union.lia_value)
#define	LIA_ARRAY(p)	((p)->lia_union.lia_array)

typedef	struct	s_liarray	{
	loopia_t	liar_left;
	loopia_t	liar_right;
	};

#define	LIAR_LEFT(p)	(&((p)->liar_left))
#define	LIAR_RIGHT(p)	(&((p)->liar_right))

typedef	struct	s_loopi	{
	int			li_relop;
	int			li_incop;
	loopia_t	li_w;
	loopia_t	li_x;
	loopia_t	li_y;
	loopia_t	li_z;
	} loopi_t, *loopip_t;

#define	LOOP_RELOP(p)	((p)->li_relop)
#define	LOOP_INCOP(p)	((p)->li_incop)

#define	LOOP_W(p)		(&((p)->li_w))
#define	LOOP_X(p)		(&((p)->li_x))
#define	LOOP_Y(p)		(&((p)->li_y))
#define	LOOP_Z(p)		(&((p)->li_z))

#define	LOOP_W_TOKEN(p)	LIA_TOKEN(LOOP_W(p))
#define	LOOP_X_TOKEN(p)	LIA_TOKEN(LOOP_X(p))
#define	LOOP_Y_TOKEN(p)	LIA_TOKEN(LOOP_Y(p))
#define	LOOP_Z_TOKEN(p)	LIA_TOKEN(LOOP_Z(p))

#define	LOOP_W_SYM(p)	LIA_SYM(LOOP_W(p))
#define	LOOP_X_SYM(p)	LIA_SYM(LOOP_X(p))
#define	LOOP_Y_SYM(p)	LIA_SYM(LOOP_Y(p))
#define	LOOP_Z_SYM(p)	LIA_SYM(LOOP_Z(p))

#define	LOOP_W_VALUE(p)	LIA_VALUE(LOOP_W(p))
#define	LOOP_X_VALUE(p)	LIA_VALUE(LOOP_X(p))
#define	LOOP_Y_VALUE(p)	LIA_VALUE(LOOP_Y(p))
#define	LOOP_Z_VALUE(p)	LIA_VALUE(LOOP_Z(p))
/*
**	stack structure for saving items which must be stacked at various places
*/
struct	s_stack	{
	stack_t	*stk_next;
	union	{
		ptree_t		sv_tree;
		psym_t		sv_sym;
		int			sv_int;
		loopip_t	sv_loopi;
		} stk_value;
	};

#define	TEST_LAB		(Test->stk_value.sv_tree)
#define	START_LAB		(Start->stk_value.sv_tree)
#define	CONTINUE_LAB	(Continue->stk_value.sv_tree)
#define	BREAK_LAB		(Break->stk_value.sv_tree)
#define	CA_LAB			(Case->stk_value.sv_tree)
#define	DEFAULT_LAB		(Default->stk_value.sv_tree)

#define	LOOPI(p)		((p)->stk_value.sv_loopi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hivepp\tokdat.h ===
/*
 * TOKENS - This file contains the initialized tables of text, token pairs for
 * all the C language symbols and keywords, and the mapped value for YACC
 * and inline assembler.
 *
 * IMPORTANT : this MUST be in the same order as the %token list in grammar.y
 *
 */
/* token	TEXT		MAPPED TO 	IL OPCODE	ASM TOKEN */

DAT(L_NOTOKEN,	"newline",	L_NOTOKEN,	MAX_OPCODE,	ML_NL)
DAT(L_IDENT,	"identifier",	L_IDENT,	OPname,		ML_IDENT)
DAT(L_STRING,	"string",	L_STRING,	OPconstant,	ML_NOTOKEN)
DAT(L_CFLOAT,	"float constant", L_CONSTANT,	OPconstant,	ML_NOTOKEN)
DAT(L_CDOUBLE,	"double constant", L_CONSTANT,	OPconstant,	ML_NOTOKEN)
DAT(L_CLDOUBLE,	"long double constant",L_CONSTANT, OPconstant,	ML_NOTOKEN)
DAT(L_CINTEGER,	"int constant",	L_CONSTANT,	OPconstant,	ML_CONSTANT)
DAT(L_LONGINT,	"long constant", L_CONSTANT,	OPconstant,	ML_CONSTANT)
DAT(L_CUNSIGNED,"unsigned int constant",L_CONSTANT,OPconstant,	ML_CONSTANT)
DAT(L_LONGUNSIGNED,"unsigned long constant",L_CONSTANT,OPconstant,ML_CONSTANT)
DAT(L_AUTO,	"auto",		L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_STATIC,	"static",	L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_EXTERN,	"extern",	L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_REGISTER,	"register",	L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_TYPEDEF,	"typedef",	L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_FORTRAN,	Fortran_str,	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_PASCAL,	Pascal_str,	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_C,	Cdecl_str,	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_INTERRUPT,"interrupt",	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_SAVEREGS,	"saveregs",	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_LOADDS,	"loadds",	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_EXPORT,	"export",	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_ASM,	"_asm",		L_ASM,		MAX_OPCODE,	ML_NL)
DAT(L_NEAR,	"near",		L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_FAR,	"far",		L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_HUGE,	"huge",		L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_CONST,	"const",	L_MODIFIER,	MAX_OPCODE,	ML_CDATATYPE)
DAT(L_VOLATILE,	"volatile",	L_MODIFIER,	MAX_OPCODE,	ML_CDATATYPE)
DAT(L_CHAR,	"char",		L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_INT,	"int",		L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_FLOAT,	"float",	L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_DOUBLE,	"double",	L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_SHORT,	"short",	L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_LONG,	"long",		L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_VOID,	"void",		L_TYPE,		MAX_OPCODE,	ML_IDENT)
DAT(L_SIGNED,	"signed",	L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_UNSIGNED,	"unsigned",	L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_ENUM,	"enum",		L_ENUM,		MAX_OPCODE,	ML_IDENT)
DAT(L_ENUM_TAG,	"enum tag",	L_ENUM_TAG,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_STRUCT,	"struct",	L_STRUCT,	MAX_OPCODE,	ML_IDENT)
DAT(L_STRUCT_TAG,"struct tag",	L_STRUCT_TAG,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_UNION,	"union",	L_UNION,	MAX_OPCODE,	ML_IDENT)
DAT(L_UNION_TAG,"union tag",	L_UNION_TAG,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_AND,	"&",		L_AND,		OPband,		ML_AND)
DAT(L_ANDAND,	"&&",		L_ANDAND,	OPandif,	ML_NOTOKEN)
DAT(L_ANDEQ,	"&=",		L_ASOP,		OPandeq,	ML_NOTOKEN)
DAT(L_ASSIGN,	"=",		L_ASSIGN,	OPassign,	ML_NOTOKEN)
DAT(L_BIT,	"bit field",	L_BIT,		OPbit,		ML_NOTOKEN)
DAT(L_COLON,	":",		L_COLON, 	OPcolon,	ML_COLON)
DAT(L_COMMA,	",", 		L_COMMA,	OPcomma,	ML_COMMA)
DAT(L_DECR,	"--",		L_INCOP,	OPpostdecr,	ML_NOTOKEN)
DAT(L_DIV,	"/",		L_DIVOP,	OPdiv,		ML_DIV)
DAT(L_DIVEQ,	"/=",		L_ASOP,		OPdiveq,	ML_NOTOKEN)
DAT(L_EQUALS,	"==",		L_EQUOP,	OPeq,		ML_EQ)
DAT(L_EXCLAIM,	"!",		L_EXCLAIM,	OPnot,		ML_NOTOKEN)
DAT(L_EXTRACT,	"*",		L_EXTRACT,	OPextract,	ML_NOTOKEN)
DAT(L_GT,	">",		L_RELOP,	OPgt,		ML_GT)
DAT(L_GTEQ,	">=",		L_RELOP,	OPge,		ML_GE)
DAT(L_INCR,	"++",		L_INCOP,	OPpostincr,	ML_NOTOKEN)
DAT(L_LBRACK,	"[",		L_LBRACK,	OPindex,	ML_LBRACK)
DAT(L_LSHFTEQ,	"<<=",		L_ASOP,		OPlsheq,	ML_NOTOKEN)
DAT(L_LSHIFT,	"<<",		L_SHIFTOP,	OPlshift,	ML_SHL)
DAT(L_LT,	"<",		L_RELOP,	OPlt,		ML_LT)
DAT(L_LTEQ,	"<=",		L_RELOP,	OPle,		ML_LE)
DAT(L_MINUS,	"-",		L_MINUS,	OPminus,	ML_SUB)
DAT(L_MINUSEQ,	"-=",		L_ASOP,		OPminuseq,	ML_NOTOKEN)
DAT(L_MOD,	"%",		L_DIVOP,	OPrem,		ML_MOD)
DAT(L_MODEQ,	"%=",		L_ASOP,		OPremeq,	ML_NOTOKEN)
DAT(L_MULT,	"*",		L_MULT,		OPmult,		ML_MUL)
DAT(L_MULTEQ,	"*=",		L_ASOP,		OPmulteq,	ML_NOTOKEN)
DAT(L_NOTEQ,	"!=",		L_EQUOP,	OPne,		ML_NE)
DAT(L_OR,	"|",		L_OR,		OPbor,		ML_OR)
DAT(L_OREQ,	"|=",		L_ASOP,		OPoreq,		ML_NOTOKEN)
DAT(L_OROR,	"||",		L_OROR,		OPorelse,	ML_NOTOKEN)
DAT(L_PERIOD,	".",		L_STUNOP,	OPfield,	ML_PERIOD)
DAT(L_PLUS,	"+",		L_PLUS,		OPplus,		ML_ADD)
DAT(L_PLUSEQ,	"+=",		L_ASOP,		OPpluseq,	ML_NOTOKEN)
DAT(L_POINTSTO,	"->",		L_STUNOP,	OPfield,	ML_NOTOKEN)
DAT(L_PREDECR,	"--",		L_INCOP,	OPminuseq,	ML_NOTOKEN)
DAT(L_PREINCR,	"++",		L_INCOP,	OPpluseq,	ML_NOTOKEN)
DAT(L_QUEST,	"?",		L_QUEST,	OPquestion,	ML_NOTOKEN)
DAT(L_RSHFTEQ,	">>=",		L_ASOP,		OPrsheq,	ML_NOTOKEN)
DAT(L_RSHIFT,	">>",		L_SHIFTOP,	OPrshift,	ML_SHR)
DAT(L_TILDE,	"~",		L_TILDE,	OPcompl,	ML_NOT)
DAT(L_UMINUS,	"unary minus",	L_UMINUS,	OPneg,		ML_NOTOKEN)
DAT(L_XOR,	"^",		L_XOR,		OPxor,		ML_XOR)
DAT(L_XOREQ,	"^=",		L_ASOP,		OPxoreq,	ML_NOTOKEN)
DAT(L_ARG,	"argument",	L_ARG,		OPargument,	ML_NOTOKEN)
DAT(L_ASOP,	"assign op",	L_ASOP,		MAX_OPCODE,	ML_NOTOKEN)
DAT(L_BREAK,	"break",	L_BREAK,	MAX_OPCODE,	ML_IDENT)
DAT(L_CASE,	"case",		L_CASE,		OPcase,		ML_IDENT)
DAT(L_CAST,	"cast",		L_CAST,		OPcast,		ML_NOTOKEN)
DAT(L_CLASS,	"storage class",L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_CONSTANT,	"constant",	L_CONSTANT,	MAX_OPCODE,	ML_MAPPED)
DAT(L_CONTINUE,	"continue",	L_CONTINUE,	MAX_OPCODE,	ML_IDENT)
DAT(L_DEFAULT,	"default",	L_DEFAULT,	MAX_OPCODE,	ML_IDENT)
DAT(L_DIVOP,	"div op",	L_DIVOP,	MAX_OPCODE,	ML_MAPPED)
DAT(L_DO,	"do",		L_DO,		MAX_OPCODE,	ML_IDENT)
DAT(L_ELLIPSIS,	"...",		L_ELLIPSIS,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_ELSE,	"else",		L_ELSE,		MAX_OPCODE,	ML_IDENT)
DAT(L_ENTRY,	"entry",	L_ENTRY,	OPentry,	ML_NOTOKEN)
DAT(L_EOF,	"end of file",	0,		MAX_OPCODE,	ML_EOF)
DAT(L_EQUOP,	"equ op",	L_EQUOP,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_FILE,	0,		L_FILE,		MAX_OPCODE,	ML_NOTOKEN)
DAT(L_FOR,	"for",		L_FOR,		MAX_OPCODE,	ML_IDENT)
DAT(L_FUNCTION,	"argument",	L_FUNCTION,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_GOTO,	"goto",		L_GOTO,		MAX_OPCODE,	ML_IDENT)
DAT(L_IF,	"if",		L_IF,		MAX_OPCODE,	ML_IDENT)
DAT(L_INCOP,	"incr op",	L_INCOP,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_INIT,	"initializing",	L_INIT,		MAX_OPCODE,	ML_NOTOKEN)
DAT(L_LCURLY,	"{",		L_LCURLY,	MAX_OPCODE,	ML_LCURLY)
DAT(L_LINE,	"line",		L_LINE,		MAX_OPCODE,	ML_NOTOKEN)
DAT(L_LPAREN,	"(",		L_LPAREN,	OPfunction,	ML_LPAREN)
DAT(L_INTRINSIC,"intrinsic",	L_INTRINSIC,	OPintrinsic,	ML_NOTOKEN)
DAT(L_MODIFIER,	"modifier",	L_MODIFIER,	MAX_OPCODE,	ML_MAPPED)
DAT(L_MODULE,	"module",	L_MODULE,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_RBRACK,	"]",		L_RBRACK,	MAX_OPCODE,	ML_RBRACK)
DAT(L_RCURLY,	"}",		L_RCURLY,	MAX_OPCODE,	ML_NL)
DAT(L_RELOP,	"rel op",	L_RELOP,	MAX_OPCODE,	ML_MAPPED)
DAT(L_RETURN,	"return",	L_RETURN,	MAX_OPCODE,	ML_IDENT)
DAT(L_RPAREN,	")",		L_RPAREN,	MAX_OPCODE,	ML_RPAREN)
DAT(L_SELF,	"_self",	L_SELF,		OPself,		ML_IDENT)
DAT(L_SEMI,	";",		L_SEMI,		MAX_OPCODE,	ML_SEMI)
DAT(L_SHIFTOP,	"shift op",	L_SHIFTOP,	MAX_OPCODE,	ML_MAPPED)
DAT(L_SIZEOF,	"sizeof",	L_SIZEOF,	MAX_OPCODE,	ML_IDENT)
DAT(L_STUNOP,	"struct op",	L_STUNOP,	MAX_OPCODE,	ML_MAPPED)
DAT(L_SW,	"switch",	L_SW,		OPswitch,	ML_IDENT)
DAT(L_SWEXP,	0,		L_SWEXP,	OPswexp,	ML_NOTOKEN)
DAT(L_TYPE,	"type",		L_TYPE,		MAX_OPCODE,	ML_MAPPED)
DAT(L_TYPENAME,	"typedef name",	L_TYPENAME,	MAX_OPCODE,	ML_CTYPENAME)
DAT(L_UPLUS,	"unary plus", 	L_UPLUS,	OPparen,	ML_NOTOKEN)
DAT(L_WHILE,	"while",	L_WHILE,	MAX_OPCODE,	ML_IDENT)
DAT(0,	0,		0,	MAX_OPCODE,	ML_NOTOKEN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\clistviews.h ===
//
// CListViews -- Class Descriptions for the main list views.
//
// 
// File: Globals.h
// Contains Global definitions for the Hotfix OCX
//

#include "Resource.h"

typedef struct _FILELIST
{
	_TCHAR		FileName[255];
	_TCHAR		InstallPath[255];
	_TCHAR		FileVersion[255];
	_TCHAR      IsCurrent[255];
	_TCHAR      FileDate[255];

	struct _FILELIST * pPrev;
	struct _FILELIST * pNext;
} * PFILELIST,FILELIST;

typedef struct _HOTFIXLIST
{
	_TCHAR      HotfixName[255];
	_TCHAR		Description[255];
	_TCHAR		InstalledDate[255];
	_TCHAR		InstalledBy[255];
	_TCHAR		Type[255];
	_TCHAR		Locale[255];
	_TCHAR		PackageCode[255];
	_TCHAR		ServicePack[255];
	_TCHAR      Uninstall[255];
	struct _HOTFIXLIST * pPrev;
	struct _HOTFIXLIST * pNext;
	PFILELIST FileList;
} * PHOTFIXLIST,HOTFIXLIST;

typedef struct _ProductNode {
	_TCHAR ProductName[255];
	_ProductNode * pPrev;
	_ProductNode * pNext;
	PHOTFIXLIST      HotfixList;
} * PPRODUCT, PRODUCTLIST;

static BOOL m_SortOrder ;   // True = Acending false = Decending
static HWND  TopList;
class CListViews
{

private:
	
	
	HWND  BottomList;
	PPRODUCT DataBase ;
	BOOL FreeDatabase();
	BOOL FreeHotfixList(PHOTFIXLIST CurrentHotfix);
	BOOL FreeFileList(PFILELIST CurrentFile);
//	BOOL    BuildDataBase(_TCHAR * ComputerName);
	PHOTFIXLIST GetHotfixInfo( _TCHAR * pszProductName, HKEY* hUpdateKey );
	PPRODUCT BuildDatabase(_TCHAR * lpszComputerName);
	PFILELIST GetFileInfo(HKEY* hHotfixKey);
	VOID VerifyFiles(PPRODUCT Database);
	BOOL AddItemsTop();
	BOOL   AddItemsBottom ();

    BOOL   bUserAbort;
	HWND hDlgPrint;

	_TCHAR  m_ProductName[255];
	DWORD   m_CurrentView;					// TRUE = By Hotfix, FALSE = BY File
	HINSTANCE m_hInst;
	_TCHAR CurrentProductName[255];
	_TCHAR CurrentFile[255];
	_TCHAR m_ComputerName[255];
	HWND    m_WebButton;
	HWND    m_UninstButton;
	HWND    m_RptButton;
	
public:
	_TCHAR m_CurrentHotfix[255];	
	BOOL      m_bRemoted;
	CListViews() {DataBase = NULL; m_CurrentView = VIEW_ALL_HOTFIX; m_SortOrder = TRUE;}
	~CListViews() {;}
	BOOL    Initialize( HWND ParentWnd, HINSTANCE hInst,_TCHAR *ComputerName, 
		                         HWND WebButton, HWND UninstButton, HWND RptButton);
	BOOL    Initialize( _TCHAR * ComputerName);
	BOOL    ShowLists(RECT * rc);
	BOOL    Resize(RECT *rc);
	DWORD     GetCurrentView () { return m_CurrentView;}
	
	void    SetViewMode(DWORD ViewType) ;
/*	void    RefreshView (BOOL Reload) {;}	// TRUE - if we just uninstalled or Refresh option selected
																    // FALSE - for view and product selection changes. */
	void PrintReport();
	void    SetProductName(_TCHAR * NewName);
	DWORD GetState();
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled, HWND m_hWnd);
	_TCHAR * GetCurrentHotfix();
	BOOL  Uninstall();
	HWND GetTopList() { return TopList; }
	void SaveToCSV();
	 static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
//	BOOL CALLBACK AbortProc(HDC PrinterDC, int iCode);
//	BOOL CALLBACK PrintDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\database.cpp ===
//
// File: Database.cpp
// BY:   Anthony V. Demarco
// Date: 12/28/1999
// Description: Contains routines for reading system update registry entries into an
//						internal database. See Database.h for database structure.
// Copyright (c) Microsoft Corporation 1999-2000
//


#include "stdafx.h"
#include "Database.h"
#define BUFFER_SIZE   255
PPRODUCT BuildDatabase(_TCHAR * lpszComputerName)
{

	HKEY		 hPrimaryKey;						// Handle of the target system HKLM 
//	_TCHAR    szPrimaryPath;			 // Path to the update key;

	HKEY		hUpdatesKey;					  // Handle to the updates key.
	_TCHAR   szUpdatesPath[BUFFER_SIZE];				// Path to the udates key
	DWORD   dwUpdatesIndex;			  // index of current updates subkey
	DWORD   dwBufferSize;				  // Size of the product name buffer.



	_TCHAR	 szProductPath[BUFFER_SIZE];				// Path of the current product key
	_TCHAR  szProductName[BUFFER_SIZE];			  // Name of product; also path to product key

	PPRODUCT	pProductList = NULL;			// Pointer to the head of the product list.
	PPRODUCT    pNewProdNode;					// Pointer used to allocate new nodes in the product list.
	PPRODUCT    pCurrProdNode;					  // Used to walk the Products List;

    // Connect to the target registry
	RegConnectRegistry(lpszComputerName,HKEY_LOCAL_MACHINE, &hPrimaryKey);
	// insert error handling here......

	if (hPrimaryKey != NULL)
	{
		// Initialize the primary path not localized since registry keys are not localized.
	    _tcscpy (szUpdatesPath, _T("SOFTWARE\\Microsoft\\Updates"));
		// open the udates key
		RegOpenKeyEx(hPrimaryKey,szUpdatesPath, 0, KEY_READ ,&hUpdatesKey);

		// Enumerate the Updates key.
		dwUpdatesIndex = 0;
		while (	RegEnumKeyEx(hUpdatesKey,dwUpdatesIndex,szProductName, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
		{
			// Create a node for the current product 
			pNewProdNode = (PPRODUCT) malloc(sizeof(PPRODUCT));
			_tcscpy(pNewProdNode->ProductName,szProductName);

			_tcscpy (szProductPath, szProductName);
			// now get the hotfix for the current product.
			pNewProdNode->HotfixList = GetHotfixInfo(szProductName, &hUpdatesKey);

			 // Insert the new node into the list.
			 pCurrProdNode=pProductList;
			 if (pCurrProdNode == NULL)						// Head of the list
			 {
				 pProductList = pNewProdNode;
				 pProductList->pPrev = NULL;
				 pProductList->pNext = NULL;
			 }
			 else
			 {
				 //Find the end of the list.
				 while (pCurrProdNode->pNext != NULL)
						pCurrProdNode = pCurrProdNode->pNext;
				 // Now insert the new node at the end of the list.
				 pCurrProdNode->pNext = pNewProdNode;
				 pNewProdNode->pPrev = pCurrProdNode;
				 pNewProdNode->pNext = NULL;
			 }

			// increment index and clear the szProducts name string for the next pass.
			
			dwUpdatesIndex++;
			_tcscpy (szProductName,_T("\0"));
			_tcscpy(szProductPath, _T("\0"));
			dwBufferSize = 255;					
		}
	}
	// close the open keys
    RegCloseKey(hUpdatesKey);
	RegCloseKey(hPrimaryKey);
	// return a pointer to the head of our database.
	return pProductList;
}

PHOTFIXLIST GetHotfixInfo( _TCHAR * pszProductName, HKEY* hUpdateKey )
{
	HKEY			   hHotfix;						// Handle of the hotfix key being processed.
	HKEY			   hProduct;				   // Handle to the current product key

	_TCHAR          szHotfixName[BUFFER_SIZE];    // Name of the current hotfix.
//	_TCHAR			szHotfixPath[BUFFER_SIZE];	 // Path of the current hotfix key
    _TCHAR          szValueName[BUFFER_SIZE];
	


	PHOTFIXLIST	 pHotfixList = NULL; // Pointer to the head of the hotfix list.
	PHOTFIXLIST  pCurrNode;				  // Used to walk the list of hotfixes
	PHOTFIXLIST  pNewNode;				 // Used to create nodes to be added to the list.

	DWORD		   dwBufferSize;			// Size of the product name buffer.
	DWORD          dwValIndex;					  // index of current value.
	DWORD		   dwHotfixIndex = 0;
	BYTE				*Data;
	DWORD			dwDataSize = BUFFER_SIZE;
	DWORD			dwValType;

	Data = (BYTE *) malloc(BUFFER_SIZE);


	// Open the current product key
	RegOpenKeyEx(*hUpdateKey,pszProductName,0 , KEY_READ, &hProduct);
	dwHotfixIndex = 0;
	dwBufferSize = BUFFER_SIZE;
	while (RegEnumKeyEx(hProduct,dwHotfixIndex, szHotfixName,&dwBufferSize, 0, NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
	{
			// now create a new node
			pNewNode = (PHOTFIXLIST) malloc (sizeof(PHOTFIXLIST));
			pNewNode->pNext = NULL;
			pNewNode->FileList = NULL;
			_tcscpy(pNewNode->HotfixName,szHotfixName);

			// open the hotfix key
			RegOpenKeyEx(hProduct,szHotfixName,0,KEY_READ,&hHotfix);
			// Now enumerate the values of the current hotfix.
			dwValIndex = 0;
			dwBufferSize =BUFFER_SIZE;
			dwDataSize = BUFFER_SIZE;
			while (RegEnumValue(hHotfix,dwValIndex, szValueName,&dwBufferSize, 0,&dwValType, Data, &dwDataSize) != ERROR_NO_MORE_ITEMS)
			{
					// Fill in the hotfix data members.
					
					++ dwValIndex;
					_tcscpy (szValueName, _T("\0"));
					ZeroMemory(Data,BUFFER_SIZE);
					dwValType = 0;
					dwBufferSize =BUFFER_SIZE;
					dwDataSize   = BUFFER_SIZE;
			}
			// Get the file list for the current hotfix.
			pNewNode->FileList = GetFileInfo(&hHotfix);

			//insert the new node at the end of the hotfix list.
           
			if (pHotfixList = NULL)
			{
				pHotfixList = pNewNode;
				pHotfixList->pPrev = NULL;
				pHotfixList->pNext = NULL;


			}
			else
			{
				 pCurrNode = pHotfixList;
				 while (pCurrNode->pNext != NULL)
					 pCurrNode = pCurrNode->pNext;
				 pCurrNode->pNext = pNewNode;
				 pNewNode->pPrev = pCurrNode;
				 pNewNode->pNext = NULL;
			}
			// Close the current Hotfix Key
			RegCloseKey(hHotfix);

			// Clear the strings.
			_tcscpy(szHotfixName,_T("\0"));

			// increment the current index
			++dwHotfixIndex;
			dwBufferSize = BUFFER_SIZE;
	}
	// Close all open keys
	RegCloseKey(hProduct);
	if (Data != NULL)
		free (Data);
	return pHotfixList;
}

PFILELIST GetFileInfo(HKEY* hHotfixKey)
{
		PFILELIST			   pFileList = NULL;				   // Pointer to the head of the file list.
//		_TCHAR				 szFilePath;				// Path to the files subkey.
		PFILELIST			   pNewNode = NULL;
		PFILELIST			   pCurrNode = NULL;;
		BYTE *					Data;
		DWORD				 dwBufferSize = BUFFER_SIZE;
		DWORD				 dwDataSize	  = BUFFER_SIZE;
		DWORD				 dwFileIndex	= 0;
		DWORD				 dwPrimeIndex = 0;
		DWORD				 dwValType = 0;
		HKEY					hPrimaryFile;
		HKEY					hFileKey;
		_TCHAR				 szFileSubKey[BUFFER_SIZE];
		_TCHAR				 szValueName[BUFFER_SIZE];
	
		Data = (BYTE *) malloc(BUFFER_SIZE);
			ZeroMemory(Data,BUFFER_SIZE);
		// Open the files subkey of the current hotfix
		RegOpenKeyEx(*hHotfixKey, _T("Files"),0,KEY_READ,&hPrimaryFile);
		while (RegEnumKeyEx(hPrimaryFile,dwPrimeIndex,szFileSubKey, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
		{

			// open the subfile key
			RegOpenKeyEx(hPrimaryFile,szFileSubKey,0,KEY_READ,&hFileKey);

		// Enumerate the file(x) subkeys of the file subkey
			while (RegEnumValue(hFileKey,dwFileIndex,szValueName,&dwBufferSize,0,&dwValType,Data,&dwDataSize) != ERROR_NO_MORE_ITEMS)
			{
				pNewNode = (PFILELIST) malloc (sizeof(PFILELIST));
				pNewNode->pNext = NULL;
				pNewNode->pPrev = NULL;
				dwFileIndex ++;
				_tcscpy(szValueName,_T("\0"));
				ZeroMemory(Data,BUFFER_SIZE);
				dwValType = 0;
				dwBufferSize = BUFFER_SIZE;
				dwDataSize = BUFFER_SIZE;
			}
			RegCloseKey(hFileKey);
			    // add the current node to the list
			if (pFileList == NULL)
			{
				pFileList = pNewNode;
			}
			else
			{
				pCurrNode = pFileList;
				while (pCurrNode->pNext != NULL)
					pCurrNode = pCurrNode->pNext;
				pCurrNode->pNext = pNewNode;
			}
			
		} // end enum of primary file key
		RegCloseKey(hPrimaryFile);
		if (Data != NUL)
			free (Data);
		return pFileList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\clistviews.cpp ===
//
// Implementation file for the CListViews Class
//
#include <Windows.h>
#include "stdafx.h"
#include "CListViews.h"
#include "resource.h"
#include <wbemidl.h>
#include <comdef.h>
#include <Commctrl.h>
#include  <io.h>
#include <Math.h>
#include <commdlg.h>
#define   FILENAME_FIELD_WIDTH  10
#define   VERSION_FIELD_WIDTH    13
#define   DATE_FIELD_WIDTH   9
#define   CURRENT_FIELD_WIDTH 8
#define   PATH_FIELD_WIDTH   13

BOOL bUserAbort;
BOOL bSuccess;
HWND hDlgPrint;
#define BUFFER_SIZE 255
LRESULT CListViews::OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled,HWND m_hWnd)
{
	LPNMHDR  lpnmh = (LPNMHDR) lParam;
	NM_LISTVIEW *pnm = (NM_LISTVIEW *)lParam;
	LPNMITEMACTIVATE lpnmia;
 HWND     hwndListView = ::GetDlgItem(m_hWnd, 1001);
_TCHAR  ItemName[255];
_TCHAR FileName[255];
_TCHAR TempProduct[255];
    if ( lpnmh->idFrom != 1001)
	{
	
			return 0;
	}
	

	switch(lpnmh->code)
	{

	case LVN_ITEMCHANGED:
			lpnmia = (LPNMITEMACTIVATE)lParam;
			switch (m_CurrentView) 
			{
			case VIEW_ALL_FILE:
				ListView_GetItemText(hwndListView, lpnmia->iItem,0,TempProduct,255);
				ListView_GetItemText(hwndListView, lpnmia->iItem,1,ItemName, 255);
				
				_tcscpy(CurrentProductName,TempProduct);
				_tcscpy(m_CurrentHotfix, ItemName);
				_tcscpy (m_ProductName,_T("\0"));

				AddItemsBottom();
				break;
			case VIEW_ALL_HOTFIX:
				ListView_GetItemText(hwndListView, lpnmia->iItem,0,TempProduct,255);
				ListView_GetItemText(hwndListView, lpnmia->iItem,1,ItemName, 255);
				_tcscpy(CurrentProductName,TempProduct);
					_tcscpy(m_CurrentHotfix, ItemName);
					_tcscpy (m_ProductName,_T("\0"));

					AddItemsBottom();

				break;
			case VIEW_BY_FILE:
				ListView_GetItemText(hwndListView, lpnmia->iItem,0,ItemName, 255);
					ListView_GetItemText(hwndListView, lpnmia->iItem,0,FileName, 255);
					_tcscpy(CurrentFile, FileName);
					_tcscpy(m_CurrentHotfix, ItemName);
					AddItemsBottom();
				break;
			case VIEW_BY_HOTFIX:
				ListView_GetItemText(hwndListView, lpnmia->iItem,0,ItemName, 255);
					_tcscpy(m_CurrentHotfix, ItemName);
					AddItemsBottom();
				break;
			} // end switch
		    //_tcscpy(m_CurrentHotfix, ItemName);
			 // Process LVN_COLUMNCLICK to sort items by column. 
			break;
        case LVN_COLUMNCLICK:
		{
			//Message(TEXT("NotifyListView: LVN_COLUMNCLICK"), -1, NULL);
            ListView_SortItemsEx(
				lpnmh->hwndFrom, 
				CompareFunc, 
				pnm->iSubItem);
			    m_SortOrder = !m_SortOrder;
            break;
		}
			

		break;
	
	} // end switch


				DWORD Status = GetState();
			
				::EnableWindow(m_WebButton,FALSE);
				::EnableWindow(m_UninstButton,FALSE);
				::EnableWindow(m_RptButton,FALSE);
			
				if (Status & UNINSTALL_OK)
					::EnableWindow(m_UninstButton,TRUE);
				if (Status & HOTFIX_SELECTED)
					::EnableWindow(m_WebButton,TRUE);
				if (Status & OK_TO_PRINT)
					::EnableWindow(m_RptButton,TRUE);
			
			//	SetFocus(m_WebButton);


	bHandled = TRUE;	
	return 0;
}

BOOL CListViews::Initialize( _TCHAR * ComputerName)
{
	LVCOLUMN Col;
	_TCHAR TempComputer[255];



	_tcscpy(m_ProductName,_T("\0"));
	EnableWindow(m_WebButton, FALSE);
	EnableWindow(m_UninstButton,FALSE);
	for (DWORD  i = 0; i< 3000000;i++) ;
	_tcscpy ( m_ComputerName, ComputerName);
	if (DataBase)
		FreeDatabase();
	DataBase = NULL;

	Col.mask = LVCF_WIDTH;
	SendMessage(TopList, LVM_DELETEALLITEMS, 0, 0);
  
	SendMessage(TopList, WM_SETREDRAW, FALSE, 0);
	while (ListView_GetColumn(TopList,0,&Col))
			ListView_DeleteColumn(TopList,0);

	
	// Clear the bottom list 
   
	SendMessage(BottomList, LVM_DELETEALLITEMS, 0, 0);
  
	SendMessage(BottomList, WM_SETREDRAW, FALSE, 0);
	while (ListView_GetColumn(BottomList,0,&Col))
			ListView_DeleteColumn(BottomList,0);

	SendMessage(BottomList, WM_SETREDRAW,TRUE, 0);
		
		
         Col.mask = LVCF_FMT | LVCF_TEXT;
         Col.fmt =  LVCFMT_LEFT;
		Col.pszText = _T("Hotfix Manager");
	
		ListView_InsertColumn(TopList,0,&Col);
		LVITEM LvItem;
		LvItem.mask = LVIF_TEXT;
		LvItem.iItem = 0;
		_TCHAR Message[255];
		_tcscpy(Message,_T("\0"));
		LoadString(m_hInst,IDS_RETRIEVE_DATA,Message,255);
		LvItem.pszText = Message;
	    LvItem.iSubItem = 0;
		ListView_InsertItem(TopList,&LvItem);
		SendMessage(TopList, WM_SETREDRAW,TRUE, 0);
	
	DataBase = BuildDatabase (ComputerName);

	DWORD dwLength = 255;
	GetComputerName(TempComputer, &dwLength);
	if (_tcscmp(ComputerName, TempComputer))
		m_bRemoted = TRUE;
	else
		m_bRemoted = FALSE;


	_tcscpy (m_ProductName,_T("\0"));
   	_tcscpy(m_CurrentHotfix, _T("\0"));
	
	AddItemsTop();
   AddItemsBottom();
	return TRUE;
}




BOOL CListViews::Initialize( HWND ParentWnd, HINSTANCE hInst,_TCHAR * ComputerName, 
							                  HWND WebButton, HWND UninstButton, HWND RptButton)
{
	m_bRemoted = FALSE;
	m_WebButton = WebButton;
	m_UninstButton = UninstButton;
	m_RptButton = RptButton;
	m_hInst = hInst;
	m_CurrentView = VIEW_ALL_HOTFIX;
	_tcscpy (m_ProductName,_T("\0"));
	DWORD dwStyle =  
            WS_CHILD | 
            WS_BORDER | 
            LVS_AUTOARRANGE |
		//	LVS_SORTDESCENDING|
            LVS_REPORT | 
            LVS_SHAREIMAGELISTS |
            WS_VISIBLE | LVS_SHOWSELALWAYS   ;

	
	
	TopList = CreateWindowEx(   WS_EX_CLIENTEDGE,          // ex style
                                 WC_LISTVIEW,               // class name - defined in commctrl.h
                                 NULL,                      // window text
                                 dwStyle,                   // style
                                 0,                         // x position
                                 0,                         // y position
                                 0,                         // width
                                 0,                         // height
                                 ParentWnd,                // parent
                                 (HMENU)1001,       // ID
                                 hInst,                   // instance
                                 NULL);                     // no extra data


	dwStyle |= LVS_NOSORTHEADER;
	BottomList = CreateWindowEx(   WS_EX_CLIENTEDGE,          // ex style
                                 WC_LISTVIEW,               // class name - defined in commctrl.h
                                 NULL,                      // window text
                                 dwStyle,                   // style
                                 0,                         // x position
                                 0,                         // y position
                                 0,                         // width
                                 0,                         // height
                                 ParentWnd,                // parent
                                 NULL,       // ID
                                 hInst,                   // instance
                                 NULL);                     // no extra data

		ListView_SetExtendedListViewStyle(TopList, LVS_EX_FULLROWSELECT);
		ListView_SetExtendedListViewStyle(BottomList, LVS_EX_FULLROWSELECT);
		_tcscpy (m_ProductName,_T("\0"));
		_tcscpy (m_CurrentHotfix,_T("\0"));
	return TRUE;
}

BOOL    CListViews::Resize(RECT *rc)
{
	MoveWindow( TopList, 
            rc->left,
            rc->top,
            rc->right - rc->left,
            (rc->bottom -50) /2 - 2,
            TRUE);

	MoveWindow( BottomList, 
            rc->left,
           ( rc->bottom-50) / 2 ,
            rc->right - rc->left,
           rc->bottom-50 - (rc->bottom -50) /2,
            TRUE);
	return TRUE;

}

BOOL    CListViews::ShowLists(RECT * rc)
{
	ShowWindow(TopList,TRUE);
	ShowWindow(BottomList, TRUE);
	Resize(rc);
	return TRUE;
}


BOOL CListViews::AddItemsTop()
{

		// Top View First
	LVITEM     LvItem;
	LVCOLUMN Col;
	_TCHAR      szBuffer[255];
	PHOTFIXLIST CurrentHotfix;
	PFILELIST       CurrentFile;
    int itemnum = 0;
//	int iSubItem = 0;
	PPRODUCT CurrentEntry; 
    
	LvItem.iItem = itemnum;
	LvItem.mask = LVIF_TEXT ;
    Col.mask = LVCF_WIDTH;
	SendMessage(TopList, LVM_DELETEALLITEMS, 0, 0);
  
	SendMessage(TopList, WM_SETREDRAW, FALSE, 0);
	while (ListView_GetColumn(TopList,0,&Col))
			ListView_DeleteColumn(TopList,0);

	
	 Col.cx =100;
  Col.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
   Col.fmt =  LVCFMT_LEFT;
    
	switch (m_CurrentView )
	{
	case VIEW_ALL_HOTFIX:			// default for primary node.
		{
		CurrentEntry = DataBase;
		
		
    	LoadString(m_hInst,IDS_PRODUCT_NAME,szBuffer ,255);
		Col.pszText = _T("Product Name");
		ListView_InsertColumn(TopList,0,&Col);

		LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,1,&Col);

		LoadString(m_hInst,IDS_DESCRIPTION,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,2,&Col);
		
		LoadString(m_hInst,IDS_SERVICE_PACK,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,3,&Col);

		LoadString(m_hInst,IDS_INSTALLED_BY,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,4,&Col);
		
		LoadString(m_hInst,IDS_INSTALL_DATE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,5,&Col);

		LoadString(m_hInst,IDS_UPDATE_TYPE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,6,&Col);

		LvItem.mask = LVIF_TEXT ;
   
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
			SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
		}
		while (CurrentEntry != NULL)
		{
			// first insert the product name
		    	

			// Now walk down the hotfix list.
			CurrentHotfix = CurrentEntry->HotfixList;
			while (CurrentHotfix != NULL)
			{
				LvItem.mask |= LVIF_PARAM;
				LvItem.iItem = itemnum;
				
			
				LvItem.pszText = CurrentEntry->ProductName;
	    		LvItem.iSubItem = 0;
				ListView_InsertItem(TopList,&LvItem);
			
			
				ListView_SetItemText(TopList, itemnum, 1, CurrentHotfix->HotfixName);
				ListView_SetItemText(TopList, itemnum, 2 , CurrentHotfix->Description);
				ListView_SetItemText(TopList, itemnum, 3, CurrentHotfix->ServicePack);
			
				ListView_SetItemText(TopList, itemnum, 4, CurrentHotfix->InstalledBy);
					ListView_SetItemText(TopList, itemnum, 5, CurrentHotfix->InstalledDate);
				ListView_SetItemText(TopList, itemnum, 6, CurrentHotfix->Type);

				if (itemnum == 0)
				{
//					MessageBox(NULL,CurrentEntry->ProductName, _T("Selecting Product"),MB_OK);
					_tcscpy(CurrentProductName,CurrentEntry->ProductName);
					
					_tcscpy(m_CurrentHotfix, CurrentEntry->HotfixList->HotfixName );
					ListView_SetItemState(TopList, 0,LVIS_SELECTED,LVIS_STATEIMAGEMASK | LVIS_SELECTED);
					::EnableWindow(m_WebButton,FALSE);
					::EnableWindow(m_UninstButton,FALSE);
					::EnableWindow(m_RptButton,FALSE);
			        DWORD Status = GetState();
					if (Status & UNINSTALL_OK)
						::EnableWindow(m_UninstButton,TRUE);
					if (Status & HOTFIX_SELECTED)
						::EnableWindow(m_WebButton,TRUE);
					if (Status & OK_TO_PRINT)
						::EnableWindow(m_RptButton,TRUE);
			
					SetFocus(m_WebButton);
				}
			
				itemnum++;
			
				CurrentHotfix = CurrentHotfix->pNext;
			}
		
			CurrentEntry = CurrentEntry->pNext;
		}
		 
	
		}
	
	break;

	case VIEW_ALL_FILE:					// View all of the files updated by all products.
		CurrentEntry = DataBase;
		
//		MessageBox(NULL,_T("Viewing all by file"),NULL,MB_OK);
    LoadString(m_hInst,IDS_PRODUCT_NAME,szBuffer ,255);
	Col.pszText = szBuffer;
    ListView_InsertColumn(TopList,0,&Col);

	LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
	Col.pszText = szBuffer;
    ListView_InsertColumn(TopList,1,&Col);

	LoadString(m_hInst,IDS_FILE_NAME,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,2,&Col);
	
	LoadString(m_hInst,IDS_FILE_DATE,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,3,&Col);

	LoadString(m_hInst,IDS_FILE_CURRENT,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,4,&Col);

	LoadString(m_hInst,IDS_FILE_VERSION,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,5,&Col);

	LoadString(m_hInst,IDS_FILE_LOCATION,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,6,&Col);

	
	if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
			SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL,_T("No Database"),NULL,MB_OK);
			return FALSE;
		}
	
    
		LvItem.mask = LVIF_TEXT;
		
		while (CurrentEntry != NULL)
		{
		
			// first insert the product name
		  	// Now walk down the hotfix list.
			CurrentHotfix = CurrentEntry->HotfixList;
			while (CurrentHotfix != NULL)
			{
				CurrentFile = CurrentHotfix->FileList;
				LvItem.iItem = itemnum;
			
				while (CurrentFile != NULL)
				{
					
				    LvItem.pszText = CurrentEntry->ProductName;
	    	    	LvItem.iSubItem = 0;
					ListView_InsertItem(TopList,&LvItem);
				
					ListView_SetItemText(TopList, itemnum, 1, CurrentHotfix->HotfixName);
					ListView_SetItemText(TopList, itemnum, 2 , CurrentFile->FileName);
					ListView_SetItemText(TopList, itemnum, 3, CurrentFile->FileDate);
					ListView_SetItemText(TopList, itemnum, 4, CurrentFile->IsCurrent);
					ListView_SetItemText(TopList, itemnum, 5, CurrentFile->FileVersion);
						ListView_SetItemText(TopList, itemnum, 6, CurrentFile->InstallPath);
					itemnum++;
					
					CurrentFile = CurrentFile->pNext;
					LvItem.iItem = itemnum;
				}	
				CurrentHotfix = CurrentHotfix->pNext;
			}
			CurrentEntry = CurrentEntry->pNext;
		}
		
	break;
    case VIEW_BY_HOTFIX:

		CurrentEntry = DataBase;
			if (CurrentEntry == NULL)
			{
				LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
				SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
				return FALSE;
			}
		LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,0,&Col);

		LoadString(m_hInst,IDS_DESCRIPTION,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,1,&Col);
		
		LoadString(m_hInst,IDS_SERVICE_PACK,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,2,&Col);

		LoadString(m_hInst,IDS_INSTALLED_BY,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,3,&Col);
		
		LoadString(m_hInst,IDS_INSTALL_DATE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,4,&Col);

		LoadString(m_hInst,IDS_UPDATE_TYPE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,5,&Col);

		LvItem.mask = LVIF_TEXT;
       
		while ( _tcscmp(CurrentEntry->ProductName, m_ProductName) && (CurrentEntry != NULL))
			CurrentEntry = CurrentEntry->pNext;
			// first insert the product name
		
			

			// Now walk down the hotfix list.
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
				SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
		}
		CurrentHotfix = CurrentEntry->HotfixList;
		while (CurrentHotfix != NULL)
		{
			LvItem.iItem = itemnum;
			LvItem.pszText = CurrentHotfix->HotfixName;
	    	LvItem.iSubItem = 0;
			ListView_InsertItem(TopList,&LvItem);
		
			ListView_SetItemText(TopList, itemnum, 1 , CurrentHotfix->Description);
			ListView_SetItemText(TopList, itemnum, 2, CurrentHotfix->ServicePack);
			ListView_SetItemText(TopList, itemnum, 4, CurrentHotfix->InstalledDate);
			ListView_SetItemText(TopList, itemnum, 3, CurrentHotfix->InstalledBy);
			ListView_SetItemText(TopList, itemnum, 5, CurrentHotfix->Type);

				if (itemnum == 0)
				{
//					MessageBox(NULL,CurrentEntry->ProductName, _T("Selecting Product"),MB_OK);
					_tcscpy(CurrentProductName,CurrentEntry->ProductName);
					
					_tcscpy(m_CurrentHotfix, CurrentEntry->HotfixList->HotfixName );
					ListView_SetItemState(TopList, 0,LVIS_SELECTED,LVIS_STATEIMAGEMASK | LVIS_SELECTED);
					::EnableWindow(m_WebButton,FALSE);
					::EnableWindow(m_UninstButton,FALSE);
					::EnableWindow(m_RptButton,FALSE);
			        DWORD Status = GetState();
					if (Status & UNINSTALL_OK)
						::EnableWindow(m_UninstButton,TRUE);
					if (Status & HOTFIX_SELECTED)
						::EnableWindow(m_WebButton,TRUE);
					if (Status & OK_TO_PRINT)
						::EnableWindow(m_RptButton,TRUE);
			
					SetFocus(m_WebButton);
				}
			itemnum++;
		
			CurrentHotfix = CurrentHotfix->pNext;
		}
		break;
	case VIEW_BY_FILE:				// Displays all files modified by all updates for the current product.
		CurrentEntry = DataBase;
		
		LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
	Col.pszText = szBuffer;
    ListView_InsertColumn(TopList,1,&Col);

	LoadString(m_hInst,IDS_FILE_NAME,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,2,&Col);
	
	LoadString(m_hInst,IDS_FILE_DATE,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,3,&Col);

	LoadString(m_hInst,IDS_FILE_CURRENT,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,4,&Col);

	LoadString(m_hInst,IDS_FILE_VERSION,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,5,&Col);

	LoadString(m_hInst,IDS_FILE_LOCATION,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,6,&Col);
	if (CurrentEntry == FALSE)
	{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
				SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
	}
    
		LvItem.mask = LVIF_TEXT;
		// first insert locate the product name
		while ( (_tcscmp(CurrentEntry->ProductName,m_ProductName) )&& (CurrentEntry != NULL))
				CurrentEntry = CurrentEntry->pNext;
		
		  	// Now walk down the hotfix list.
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
				SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
		}

		CurrentHotfix = CurrentEntry->HotfixList;
		while (CurrentHotfix != NULL)
		{
			LvItem.iItem = itemnum;
			CurrentFile = CurrentHotfix->FileList;
			
			while (CurrentFile != NULL)
			{
				LvItem.pszText = CurrentHotfix->HotfixName;
	    		LvItem.iSubItem = 0;
				ListView_InsertItem(TopList,&LvItem);
				ListView_SetItemText(TopList, itemnum, 1 , CurrentFile->FileName);
				ListView_SetItemText(TopList, itemnum, 2, CurrentFile->FileDate);
				ListView_SetItemText(TopList, itemnum, 3, CurrentFile->IsCurrent);
				ListView_SetItemText(TopList, itemnum, 4, CurrentFile->FileVersion);
					ListView_SetItemText(TopList, itemnum, 5, CurrentFile->InstallPath);
						if (itemnum == 0)
				{
//					MessageBox(NULL,CurrentEntry->ProductName, _T("Selecting Product"),MB_OK);
					_tcscpy(CurrentProductName,CurrentEntry->ProductName);
					
					_tcscpy(m_CurrentHotfix, CurrentEntry->HotfixList->HotfixName );
					ListView_SetItemState(TopList, 0,LVIS_SELECTED,LVIS_STATEIMAGEMASK | LVIS_SELECTED);
					::EnableWindow(m_WebButton,FALSE);
					::EnableWindow(m_UninstButton,FALSE);
					::EnableWindow(m_RptButton,FALSE);
			        DWORD Status = GetState();
					if (Status & UNINSTALL_OK)
						::EnableWindow(m_UninstButton,TRUE);
					if (Status & HOTFIX_SELECTED)
						::EnableWindow(m_WebButton,TRUE);
					if (Status & OK_TO_PRINT)
						::EnableWindow(m_RptButton,TRUE);
			
					SetFocus(m_WebButton);
				}
				itemnum++;
				LvItem.iItem = itemnum;
				CurrentFile = CurrentFile->pNext;
			}	
			CurrentHotfix = CurrentHotfix->pNext;
		}
	

	break;	
	} // end switch			
	SendMessage(TopList, WM_SETREDRAW, TRUE, 0);


	return TRUE;
}

BOOL CListViews::AddItemsBottom ()
{
	LVITEM     LvItem;
	LVCOLUMN Col;
	_TCHAR      szBuffer[255];
	PHOTFIXLIST CurrentHotfix;
	PFILELIST       CurrentFile;
    int itemnum = 0;
//	int iSubItem = 0;
//	int ItemCount = 0;
	BOOL Done = FALSE;


	LvItem.mask = LVIF_TEXT;
	LvItem.iItem = itemnum;
	PPRODUCT CurrentEntry; 
    // Clear the List View and prepare it for updating....
	SendMessage(BottomList, LVM_DELETEALLITEMS, 0, 0);
  	SendMessage(BottomList, WM_SETREDRAW, FALSE, 0);


	

	Col.mask =LVCF_WIDTH;
	while (ListView_GetColumn(BottomList,0,&Col))
			ListView_DeleteColumn(BottomList,0);

	Col.mask = LVCF_TEXT | LVCF_WIDTH;
	Col.cx = 100;

	
    switch (m_CurrentView)
	{
	case VIEW_ALL_FILE:
	case VIEW_BY_FILE:
		CurrentEntry = DataBase;
	
		LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,0,&Col);

		LoadString(m_hInst,IDS_DESCRIPTION,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,1,&Col);
		
		LoadString(m_hInst,IDS_SERVICE_PACK,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,2,&Col);

		LoadString(m_hInst,IDS_INSTALLED_BY,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,3,&Col);
		
		LoadString(m_hInst,IDS_INSTALL_DATE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,4,&Col);

		LoadString(m_hInst,IDS_UPDATE_TYPE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,5,&Col);
	SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
		LvItem.mask = LVIF_TEXT;
       
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL, _T("Database is NULL"),_T("No Items"), MB_OK);
			return FALSE;
		}
		Done = FALSE;
		
		if (_tcscmp (m_ProductName,_T("\0")))
		{
			while (  (!Done) && (CurrentEntry != NULL))
			{
			
				if (!_tcscmp(CurrentEntry->ProductName, m_ProductName))
					Done = TRUE;
				else
					CurrentEntry = CurrentEntry->pNext;
			}
		}
		else
		{
		
			while (  (!Done) && (CurrentEntry != NULL))
			{
		
				if (!_tcscmp(CurrentEntry->ProductName, CurrentProductName))
					Done = TRUE;
				else
					CurrentEntry = CurrentEntry->pNext;
			}
		}
				// Now walk down the hotfix list.
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL, _T("Product Not found or not selected"), _T("No Items"),MB_OK);
			return FALSE;
		
		}
		CurrentHotfix = CurrentEntry->HotfixList;
		while ( (CurrentHotfix != NULL) && (_tcscmp(CurrentHotfix->HotfixName, m_CurrentHotfix)))
			CurrentHotfix = CurrentHotfix->pNext;

		if (CurrentHotfix != NULL)
		{
			LvItem.iItem = itemnum;
			LvItem.pszText = CurrentHotfix->HotfixName, 
	    	LvItem.iSubItem = 0;
			ListView_InsertItem(BottomList,&LvItem);
		
			ListView_SetItemText(BottomList, itemnum, 1 , CurrentHotfix->Description);
			ListView_SetItemText(BottomList, itemnum, 2, CurrentHotfix->ServicePack);
			ListView_SetItemText(BottomList, itemnum, 3, CurrentHotfix->InstalledBy);
			ListView_SetItemText(BottomList, itemnum, 4, CurrentHotfix->InstalledDate);
			ListView_SetItemText(BottomList, itemnum, 5, CurrentHotfix->Type);
			itemnum++;
		
			CurrentHotfix = CurrentHotfix->pNext;
		}
		else
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL, _T("No Hotfix Found"), _T("No Items"),MB_OK);
			return FALSE;
		}
		break;

	case VIEW_ALL_HOTFIX:
	case VIEW_BY_HOTFIX:
		CurrentEntry = DataBase;
		
		LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,1,&Col);

		LoadString(m_hInst,IDS_FILE_NAME,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,2,&Col);
		
		LoadString(m_hInst,IDS_FILE_DATE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,3,&Col);

		LoadString(m_hInst,IDS_FILE_CURRENT,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,4,&Col);

		LoadString(m_hInst,IDS_FILE_VERSION,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,5,&Col);

		LoadString(m_hInst,IDS_FILE_LOCATION,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,6,&Col);
    
		SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
		LvItem.mask = LVIF_TEXT ;
		// first insert locate the product name
/*		if (!_tcscmp(m_ProductName,_T("\0")))

		{	LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
			
		}
		*/
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			LvItem.lParam = NULL;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL, _T("No Database"), _T("No Items"),MB_OK);
			return FALSE;
		}

		
		
		if (_tcscmp (m_ProductName,_T("\0")))
		{
			
			while (  (!Done) && (CurrentEntry != NULL))
			{
		
				if (!_tcscmp(CurrentEntry->ProductName, m_ProductName))
					Done = TRUE;
				else
					CurrentEntry = CurrentEntry->pNext;
			}
		}
		else
		{
		
			while (  (!Done) && (CurrentEntry != NULL))
			{
			
				if (!_tcscmp(CurrentEntry->ProductName, CurrentProductName))
					Done = TRUE;
				else
					CurrentEntry = CurrentEntry->pNext;
			}
		}
		
		  	// Now walk down the hotfix list.
		if (CurrentEntry == NULL)
		{
			
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			LvItem. lParam = NULL;
			ListView_InsertItem(BottomList,&LvItem);
		
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL, _T("Product Not found or not selected"), _T("No Items"),MB_OK);
			return FALSE;
		}

		CurrentHotfix = CurrentEntry->HotfixList;
		while ((CurrentHotfix != NULL) && (_tcscmp(CurrentHotfix->HotfixName, m_CurrentHotfix)))
			CurrentHotfix = CurrentHotfix->pNext;

		if ( CurrentHotfix == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			LvItem.lParam = NULL;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL,_T("No Hotfix Found"), _T("No Items"), MB_OK);
			return FALSE;
		}
		if (CurrentHotfix != NULL)
		{
			LvItem.iItem = itemnum;
			
			CurrentFile = CurrentHotfix->FileList;
			if (CurrentFile == NULL)
			{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			LvItem.lParam = NULL;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox (NULL, _T("No Files Found"), _T("No Items"), MB_OK);
			return FALSE;
			}
			while (CurrentFile != NULL)
			{
				LvItem.pszText = CurrentHotfix->HotfixName;
	    		LvItem.iSubItem = 0;
				ListView_InsertItem(BottomList,&LvItem);
				ListView_SetItemText(BottomList, itemnum, 1 , CurrentFile->FileName);
				ListView_SetItemText(BottomList, itemnum, 2, CurrentFile->FileDate);
				ListView_SetItemText(BottomList, itemnum, 3, CurrentFile->IsCurrent);
				ListView_SetItemText(BottomList, itemnum, 4, CurrentFile->FileVersion);
				ListView_SetItemText(BottomList, itemnum, 5, CurrentFile->InstallPath);
				itemnum++;
				LvItem.iItem = itemnum;
				CurrentFile = CurrentFile->pNext;
			}	
			CurrentHotfix = CurrentHotfix->pNext;
		}
		else
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
		}
		break;	
		default:
				LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			return FALSE;
		
	}	// end switch
	SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
	return TRUE;
}
PPRODUCT CListViews::BuildDatabase(_TCHAR * lpszComputerName)
{

	HKEY		 hPrimaryKey;						// Handle of the target system HKLM 
//	_TCHAR    szPrimaryPath;			 // Path to the update key;

	HKEY		hUpdatesKey;					  // Handle to the updates key.
	_TCHAR   szUpdatesPath[BUFFER_SIZE];				// Path to the udates key
	DWORD   dwUpdatesIndex;			  // index of current updates subkey
	DWORD   dwBufferSize;				  // Size of the product name buffer.



	_TCHAR	 szProductPath[BUFFER_SIZE];				// Path of the current product key
	_TCHAR  szProductName[BUFFER_SIZE];			  // Name of product; also path to product key

	PPRODUCT	pProductList = NULL;			// Pointer to the head of the product list.
	PPRODUCT    pNewProdNode;					// Pointer used to allocate new nodes in the product list.
	PPRODUCT    pCurrProdNode;					  // Used to walk the Products List;

    // Connect to the target registry
	RegConnectRegistry(lpszComputerName,HKEY_LOCAL_MACHINE, &hPrimaryKey);
	// insert error handling here......

	if (hPrimaryKey != NULL)
	{
		// Initialize the primary path not localized since registry keys are not localized.
	    _tcscpy (szUpdatesPath, _T("SOFTWARE\\Microsoft\\Updates"));
		// open the udates key
		RegOpenKeyEx(hPrimaryKey,szUpdatesPath, 0, KEY_READ ,&hUpdatesKey);
        if (hUpdatesKey != NULL)
		{
			// Enumerate the Updates key.
			dwUpdatesIndex = 0;
			while (	RegEnumKeyEx(hUpdatesKey,dwUpdatesIndex,szProductName, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
			{
				// Create a node for the current product 
				pNewProdNode = (PPRODUCT) malloc(sizeof(PRODUCTLIST));
				_tcscpy(pNewProdNode->ProductName,szProductName);
				
				_tcscpy (szProductPath, szProductName);
				// now get the hotfix for the current product.
				pNewProdNode->HotfixList = GetHotfixInfo(szProductName, &hUpdatesKey);

				 // Insert the new node into the list.
				 pCurrProdNode=pProductList;
				 if (pCurrProdNode == NULL)						// Head of the list
				 {
					 pProductList = pNewProdNode;
					 pProductList->pPrev = NULL;
					 pProductList->pNext = NULL;
				 }
				 else
				 {
					 //Find the end of the list.
					 while (pCurrProdNode->pNext != NULL)
							pCurrProdNode = pCurrProdNode->pNext;
					 // Now insert the new node at the end of the list.
					 pCurrProdNode->pNext = pNewProdNode;
					 pNewProdNode->pPrev = pCurrProdNode;
					 pNewProdNode->pNext = NULL;
				 }

				// increment index and clear the szProducts name string for the next pass.
				
				dwUpdatesIndex++;
				_tcscpy (szProductName,_T("\0"));
				_tcscpy(szProductPath, _T("\0"));
				dwBufferSize = 255;					
			}
		}
		// close the open keys
		RegCloseKey(hUpdatesKey);
		RegCloseKey(hPrimaryKey);
	}
	// return a pointer to the head of our database.
	VerifyFiles(pProductList);
	return pProductList;
}


void BuildQuery (_TCHAR * Path, _TCHAR * FileName, _TCHAR * Result)
{

	_TCHAR * src;
	_TCHAR * dest;
	_TCHAR Temp[255];


	src = Path;
	dest = Temp;


	while (*src != _T('\0'))
	{
		if (*src == _T('\\'))  // if we hit a \ character we need to insert four of them in the dest string.
		{
			for (int i = 0; i < 4; i++)
			{
				*dest = *src;
				++dest;
			}
			++src;
		
		}
		else
		{
			*dest = *src;
			++src;
			++dest;
		}
	
	}
	*dest = _T('\0');

	_stprintf(Result,_T("SELECT * from CIM_DataFile WHERE Name = '%s\\\\\\\\%s'"), Temp, FileName);
	
}
	
BOOL VerifyVersion(_TCHAR * Ver1, _TCHAR * Ver2)
{
	_TCHAR *src1;
	_TCHAR *src2;
	_TCHAR *dest1, *dest2;
	_TCHAR temp[20];
	_TCHAR temp2[20];
	BOOL  Done = FALSE;
	BOOL  Status = TRUE;
	src1 =  Ver1;
	src2 = Ver2;
	dest1 = temp;
	dest2 = temp2;

	if ((!src1) || (!src2))
		return FALSE;

	if (!_tcscmp (src1, src2))
		return TRUE;
	  
	while ( (*src1 != _T('\0')) && (!Done) )
	{
		_tcscpy (temp, _T("\0"));
		_tcscpy (temp2, _T("\0"));
		dest1 = temp;
		dest2 = temp2;
		// Get the next field of the registry string
		while( (*src1 != _T('.')) && (*src1 != _T('\0')))
		{
			*dest1 = *src1;
			++dest1;
			++src1;
		}
		if ( *src1 != _T('\0'))
			++src1; // skip the .
		*dest1 = _T('\0');
		++dest1;
		*dest1= _T('\0');

		// Now get the next field from the WMI returned version.
		while ( (*src2 != _T('.') ) && (*src2 != _T('\0')) )
		{
			*dest2= *src2;
			++dest2;
			++src2;

		}
		if ( *src2 != _T('\0'))
			++src2; // skip the .
		*dest2 = _T('\0');
		++dest2;
		*dest2= _T('\0');
	
        // Now convert the strings to integers.

		if ( _ttol (temp) != _ttol (temp2) )
		{
			Status = FALSE;
			Done = TRUE;
		}
	
		if ( (*src1 == _T('\0')) && (*src2 != _T('\0')) )
		{
			Done = TRUE;
			Status = FALSE;
		}
		if ( ( *src1 != _T('\0')) && (*src2 == _T('\0')) )
		{
			Done = TRUE;
			Status = FALSE;
		}
	}
	return Status;
}

VOID CListViews::VerifyFiles(PPRODUCT Database)
{

	PPRODUCT CurrentProduct = NULL;
	PHOTFIXLIST CurrentHotfix    = NULL;
	PFILELIST CurrentFile        = NULL;
    HRESULT     hres;
	_TCHAR      ConnectString[255];
	_TCHAR     TempBuffer[255];
	 
	    
	    IWbemLocator *pLoc = 0;
		hres = CoCreateInstance(CLSID_WbemLocator, 0,CLSCTX_INPROC_SERVER,IID_IWbemLocator, (LPVOID *) &pLoc);
		if ( FAILED (hres))
		{
//			MessageBox(NULL, _T("Failed to create IWebmLocator Object"),NULL,MB_OK);
		}
		else
		{
			IWbemServices *pSvc = NULL;
			// Build the connection string.
			if (!_tcscmp(m_ComputerName,_T("\0")))
				_stprintf(ConnectString,_T("ROOT\\CIMV2"));
			else
				_stprintf(ConnectString,_T("\\\\%s\\ROOT\\CIMV2"), m_ComputerName);
			_TCHAR * ConnectString1;
			ConnectString1 = SysAllocString(ConnectString);
			// Connect to the default namespace 
			hres = pLoc->ConnectServer(
				ConnectString1,
				NULL,NULL,0,NULL,0,0,&pSvc);
			SysFreeString(ConnectString1);
			if ( FAILED (hres))
			{
				;				
			}
			else
			{
					CoSetProxyBlanket(pSvc, RPC_C_AUTHN_WINNT,RPC_C_AUTHZ_NONE,
					NULL,
					RPC_C_AUTHN_LEVEL_CALL,
					RPC_C_IMP_LEVEL_IMPERSONATE,
					NULL,
					EOAC_NONE);
				IEnumWbemClassObject *pEnum = NULL;
				IWbemClassObject *pObj = NULL;

                // Now Update the Current field of all of the File Entries.
				CurrentProduct = Database;
				_TCHAR Query[255];
				while (CurrentProduct != NULL)
				{
		
					CurrentHotfix = CurrentProduct->HotfixList;
				    while (CurrentHotfix != NULL)
					{
						CurrentFile = CurrentHotfix->FileList;
						while (CurrentFile != NULL)
						{
							_tcscpy (Query,_T("\0"));
							BuildQuery(CurrentFile->InstallPath, CurrentFile->FileName,  Query);

							_TCHAR * bstrQuery = SysAllocString(Query);
							_TCHAR * bstrType = SysAllocString(_T("WQL"));
							hres = pSvc->ExecQuery(bstrType,
								                                       bstrQuery,
																	   WBEM_FLAG_FORWARD_ONLY,
																	   NULL, 
																	   &pEnum);
							SysFreeString (bstrQuery);
							SysFreeString(bstrType);
							if (hres == WBEM_S_NO_ERROR)
							{
									ULONG uReturned = 1;
									while (uReturned == 1)
									{
										hres = pEnum->Next(WBEM_INFINITE ,1,&pObj, &uReturned);
										if ( (SUCCEEDED (hres))  && (uReturned == 1))
										{
												VARIANT pVal;
												VariantClear (&pVal);

												BSTR propName = SysAllocString(L"Version");
    											hres = pObj->Get(propName,
												0L,
												&pVal,
												NULL,
												NULL);


												if  (pVal.vt == VT_NULL)
													;
												else if (pVal.vt == VT_BSTR)
												{
													TCHAR  NewVal[255];
													    _tcscpy (NewVal, pVal.bstrVal);
														//_bstr_t NewVal(pVal.bstrVal,FALSE); 
														if (! _tcscmp(CurrentFile->FileVersion, _T("\0")))
															_tcscpy (CurrentFile->IsCurrent, _T("N\\A"));
														else
														{
															if (VerifyVersion ( CurrentFile->FileVersion, NewVal) )
															{
																LoadString(m_hInst, IDS_YES, TempBuffer, 255);
																_tcscpy(CurrentFile->IsCurrent, TempBuffer);
															}
															else 
															{
																LoadString(m_hInst, IDS_NO, TempBuffer, 255);
																_tcscpy(CurrentFile->IsCurrent,_T("\0"));
															}
														}

													
												}
												if (pObj) pObj->Release();
												
										}
										else
											;
									} // end while uReturned
								
							} 
							// Done with this enumerator
							if (pEnum) pEnum->Release();
							CurrentFile = CurrentFile->pNext;
						}// end while CurrentFile != NULL
						CurrentHotfix = CurrentHotfix->pNext;
					}// end while hotfix != NULL
					CurrentProduct = CurrentProduct->pNext;
				} // end while product != NULL
			}//end else
		} // end else
} // end


					
					
					
				
			
			



PHOTFIXLIST CListViews::GetHotfixInfo( _TCHAR * pszProductName, HKEY* hUpdateKey )
{
	HKEY			   hHotfixKey = NULL;						// Handle of the hotfix key being processed.
	HKEY			   hProduct = NULL ;				   // Handle to the current product key
    HKEY               hSPKey = NULL; 
	_TCHAR          szHotfixName[BUFFER_SIZE];    // Name of the current hotfix.
    _TCHAR          szValueName[BUFFER_SIZE];
	_TCHAR          szSPName[BUFFER_SIZE];


	PHOTFIXLIST	 pHotfixList = NULL; // Pointer to the head of the hotfix list.
	PHOTFIXLIST  pCurrNode = NULL;				  // Used to walk the list of hotfixes
	PHOTFIXLIST  pNewNode = NULL;				 // Used to create nodes to be added to the list.

	DWORD		   dwBufferSize;			// Size of the product name buffer.
	DWORD          dwValIndex;					  // index of current value.
	DWORD		   dwHotfixIndex = 0;
	BYTE				*Data = NULL;
	DWORD			dwDataSize = BUFFER_SIZE;
	DWORD			dwValType;
	DWORD           dwSPIndex = 0;


	Data = (BYTE *) malloc(BUFFER_SIZE);
    if (Data == NULL)
		return NULL;

	// Open the current product key
	if (*hUpdateKey != NULL)
	{
		RegOpenKeyEx(*hUpdateKey,pszProductName,0 , KEY_READ, &hProduct);
		if (hProduct != NULL)
		{
			dwHotfixIndex = 0;
			dwBufferSize = BUFFER_SIZE;
			dwSPIndex = 0;
			while (RegEnumKeyEx(hProduct,dwSPIndex, szSPName,&dwBufferSize, 0, NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
			{
				 // Open the Service pack Key
				RegOpenKeyEx(hProduct,szSPName,0,KEY_READ,&hSPKey);
				if (hSPKey != NULL)
				{
					// Enumerate the Service Pack key to get the hotfix keys.
					dwBufferSize = BUFFER_SIZE;
					dwHotfixIndex = 0;
					while (RegEnumKeyEx(hSPKey,dwHotfixIndex, szHotfixName, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
					{
						
						// now create a new node
							pNewNode = (PHOTFIXLIST) malloc (sizeof(HOTFIXLIST));
							pNewNode->pNext = NULL;
							pNewNode->FileList = NULL;
							_tcscpy(pNewNode->HotfixName,szHotfixName);
							_tcscpy(pNewNode->ServicePack,szSPName);
								_tcscpy(pNewNode->Uninstall,_T("\0"));
							// Open the Hotfix Key
							RegOpenKeyEx(hSPKey,szHotfixName, 0, KEY_READ,&hHotfixKey);
						
						
							if (hHotfixKey != NULL)
							{
								// Now enumerate the values of the current hotfix.
								dwValIndex = 0;
								dwBufferSize =BUFFER_SIZE;
								dwDataSize = BUFFER_SIZE;
								while (RegEnumValue(hHotfixKey,dwValIndex, szValueName,&dwBufferSize, 0,&dwValType, Data, &dwDataSize) != ERROR_NO_MORE_ITEMS)
								{
										// Fill in the hotfix data members.
										_tcslwr(szValueName);
										if (!_tcscmp(szValueName,_T("description")))
											_tcscpy(pNewNode->Description,(_TCHAR *) Data);

										if (!_tcscmp(szValueName,_T("installeddate")))
											_tcscpy(pNewNode->InstalledDate,(_TCHAR *) Data);

										if (!_tcscmp(szValueName,_T("type")))
											_tcscpy(pNewNode->Type,(_TCHAR*) Data);

										if (!_tcscmp(szValueName,_T("installedby")))
											_tcscpy(pNewNode->InstalledBy , (_TCHAR*) Data);

										if (!_tcscmp(szValueName,_T("uninstallcommand")))
											_tcscpy(pNewNode->Uninstall, (_TCHAR*)Data);
										++ dwValIndex;
										_tcscpy (szValueName, _T("\0"));
										ZeroMemory(Data,BUFFER_SIZE);
										dwValType = 0;
										dwBufferSize =BUFFER_SIZE;
										dwDataSize   = BUFFER_SIZE;
								}
								// Get the file list for the current hotfix.
								pNewNode->FileList = GetFileInfo(&hHotfixKey);
								//insert the new node at the end of the hotfix list.
							   pCurrNode = pHotfixList;
								if (pCurrNode == NULL)
								{
									pHotfixList = pNewNode;
									pHotfixList->pPrev = NULL;
									pHotfixList->pNext = NULL;


								}
								else
								{
									 pCurrNode = pHotfixList;
									 while (pCurrNode->pNext != NULL)
										 pCurrNode = pCurrNode->pNext;
									 pCurrNode->pNext = pNewNode;
									 pNewNode->pPrev = pCurrNode;
									 pNewNode->pNext = NULL;
								}
								// Close the current Hotfix Key
								RegCloseKey(hHotfixKey);

								// Clear the strings.
							 _tcscpy(szHotfixName,_T("\0"));

								// increment the current index
								++dwHotfixIndex;
								dwBufferSize = BUFFER_SIZE;
							}
					}
					RegCloseKey(hSPKey);
					_tcscpy (szSPName,_T("\0"));
					dwBufferSize = BUFFER_SIZE;
					dwSPIndex++;
				}
			}// end enum SP keys.
			// Close all open keys
			RegCloseKey(hProduct);
		}
		if (Data != NULL)
			free (Data);
	}
	return pHotfixList;
}
PFILELIST CListViews::GetFileInfo(HKEY* hHotfixKey)
{
		PFILELIST			   pFileList = NULL;				   // Pointer to the head of the file list.
//		_TCHAR				 szFilePath;				// Path to the files subkey.
		PFILELIST			   pNewNode = NULL;
		PFILELIST			   pCurrNode = NULL;;
		BYTE *					Data;
		DWORD				 dwBufferSize = BUFFER_SIZE;
		DWORD				 dwDataSize	  = BUFFER_SIZE;
		DWORD				 dwFileIndex	= 0;
		DWORD				 dwPrimeIndex = 0;
		DWORD				 dwValType = 0;
		HKEY					hPrimaryFile;
		HKEY					hFileKey;
		_TCHAR				 szFileSubKey[BUFFER_SIZE];
		_TCHAR				 szValueName[BUFFER_SIZE];
	
		Data = (BYTE *) malloc(BUFFER_SIZE);
			ZeroMemory(Data,BUFFER_SIZE);
		// Open the files subkey of the current hotfix
	   if (RegOpenKeyEx(*hHotfixKey, _T("FileList"),0,KEY_READ,&hPrimaryFile) != ERROR_SUCCESS)
	   {
		     
			return NULL;
	   }
		_tcscpy(szValueName,_T("\0"));
		while (RegEnumKeyEx(hPrimaryFile,dwPrimeIndex,szFileSubKey, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
		{

			// open the subfile key
			RegOpenKeyEx(hPrimaryFile,szFileSubKey,0,KEY_READ,&hFileKey);
			dwFileIndex = 0;
		// Enumerate the file(x) subkeys of the file subkey
			dwDataSize	  = BUFFER_SIZE;
			dwBufferSize = BUFFER_SIZE;
			pNewNode = (PFILELIST) malloc (sizeof(FILELIST));
			pNewNode->pNext = NULL;
			pNewNode->pPrev = NULL;
			_tcscpy (pNewNode->IsCurrent,_T("\0"));
			_tcscpy(pNewNode->FileDate,_T("\0"));
		
			while (RegEnumValue(hFileKey,dwFileIndex,szValueName,&dwBufferSize,0,&dwValType,Data,&dwDataSize) != ERROR_NO_MORE_ITEMS)
			{
				
				_tcslwr(szValueName);

				// now find out which value we have and insert it into the node
				if (! _tcscmp(szValueName,_T("filename")))
				{
					_tcscpy(pNewNode->FileName,(_TCHAR *) Data);
				}
				if (! _tcscmp(szValueName,_T("version")))
				{
					_tcscpy(pNewNode->FileVersion,(_TCHAR*)Data);
				}
				if (!_tcscmp(szValueName,_T("builddate")))
				{		    
					_tcscpy(pNewNode->FileDate,(_TCHAR*) Data);
				}
				if (! _tcscmp(szValueName, _T("location")))
				{
					_tcscpy(pNewNode->InstallPath, (_TCHAR*) Data);
			
				}

				dwFileIndex ++;
				_tcscpy(szValueName,_T("\0"));
				ZeroMemory(Data,BUFFER_SIZE);
				dwValType = 0;
				dwBufferSize = BUFFER_SIZE;
				dwDataSize = BUFFER_SIZE;
			}
			RegCloseKey(hFileKey);
			    // add the current node to the list if not stored in dll cache
			_TCHAR TempString[255];
			_tcscpy (TempString, pNewNode->InstallPath);
			_tcslwr(TempString);
			if (  (_tcsstr (TempString, _T("dllcache")) == NULL ) && (_tcsstr (TempString, _T("driver cache") )== NULL))
			{
				pCurrNode = pFileList;
				if (pNewNode != NULL)
				{
					if (pFileList == NULL)
					{
						pFileList = pNewNode;
					}
					else
					{
						
						while (pCurrNode->pNext != NULL)
							pCurrNode = pCurrNode->pNext;
						pCurrNode->pNext = pNewNode;
						pNewNode->pPrev = pCurrNode;
					}
				}
			}
			else // otherwise free the node.
				free (pNewNode);
			++dwPrimeIndex;
		} // end enum of primary file key
		RegCloseKey(hPrimaryFile);
		if (Data != NULL)
			free (Data);
		return pFileList;
}

_TCHAR * CListViews::GetCurrentHotfix()
{
	return m_CurrentHotfix;
}


void CListViews::SetViewMode(DWORD ViewType) 
{
	m_CurrentView = ViewType;
    _tcscpy (m_CurrentHotfix,_T("\0"));
	EnableWindow(m_UninstButton,FALSE);
	EnableWindow(m_WebButton,FALSE);
	switch (ViewType)
	{
	case VIEW_BY_FILE:
			if (! _tcscmp(m_ProductName,_T("\0")))
				m_CurrentView = VIEW_ALL_FILE;
			else
				m_CurrentView = VIEW_BY_FILE;
		break;
	case VIEW_BY_HOTFIX:
	        if (! _tcscmp(m_ProductName,_T("\0")))
				m_CurrentView =VIEW_ALL_HOTFIX;
			else
				m_CurrentView = VIEW_BY_HOTFIX;
			
	    break;
	}
	AddItemsTop();
	AddItemsBottom();
	
}

void CListViews::SetProductName(_TCHAR * NewName) 
{ 
	_tcscpy (m_ProductName,NewName);
	 _tcscpy(m_ProductName, NewName);
	 EnableWindow(m_WebButton, FALSE);
	 EnableWindow(m_UninstButton,FALSE);
	_tcscpy(m_CurrentHotfix, _T("\0"));
	if (_tcscmp(NewName, _T("\0")))
	{
		switch (m_CurrentView)
		{
		case VIEW_ALL_FILE:
			m_CurrentView = VIEW_BY_FILE;
			break;
		case VIEW_ALL_HOTFIX:
			m_CurrentView = VIEW_BY_HOTFIX;
			break;
	
		}
	}
	if (!_tcscmp(NewName, _T("\0")))
	{
		switch (m_CurrentView)
		{
		case VIEW_BY_FILE:
			m_CurrentView = VIEW_ALL_FILE;
					break;
		case VIEW_BY_HOTFIX:
			m_CurrentView = VIEW_ALL_HOTFIX;
			break;
		default:
			m_CurrentView = VIEW_ALL_HOTFIX;
		}
			_tcscpy(m_ProductName,_T("\0"));
			_tcscpy(m_CurrentHotfix,_T("\0"));
	}

	
	AddItemsTop();
	AddItemsBottom();
}

BOOL CListViews::FreeFileList(PFILELIST CurrentFile)
{
	while (CurrentFile->pNext->pNext != NULL)
			CurrentFile = CurrentFile->pNext;

		//Remove the file list
	while ( (CurrentFile->pPrev != NULL) && (CurrentFile->pNext != NULL) )
	{
		free ( CurrentFile->pNext );
		CurrentFile = CurrentFile->pPrev ;
	}
	if (CurrentFile != NULL)
	free (CurrentFile);
	CurrentFile = NULL;
	return TRUE;
}

BOOL CListViews::FreeHotfixList (PHOTFIXLIST CurrentHotfix)
{
	PFILELIST CurrentFile;

	while (CurrentHotfix->pNext != NULL)
			CurrentHotfix = CurrentHotfix->pNext;

	if (CurrentHotfix->pPrev != NULL)
		CurrentHotfix = CurrentHotfix->pPrev;
		//Remove the Hotfix list
	while ( (CurrentHotfix->pPrev != NULL) && (CurrentHotfix->pNext != NULL) )
	{
		CurrentFile = CurrentHotfix->pNext->FileList ;
		FreeFileList (CurrentFile);
		free ( CurrentHotfix->pNext );
		CurrentHotfix = CurrentHotfix->pPrev ;
	}
	if (CurrentHotfix != NULL)
	free (CurrentHotfix);
	return TRUE;
}
BOOL CListViews::FreeDatabase()
{


	PPRODUCT CurrentProduct = DataBase;
	PHOTFIXLIST CurrentHotfix;
	PFILELIST   CurrentFile;

	while (CurrentProduct->pNext->pNext != NULL) 
			CurrentProduct = CurrentProduct->pNext;

	while (CurrentProduct->pPrev != NULL)
	{
	
		CurrentHotfix = CurrentProduct->HotfixList;
		FreeHotfixList(CurrentHotfix);
		CurrentProduct = CurrentProduct->pPrev ;
	}

	if (CurrentProduct != NULL)
		free(CurrentProduct);
	DataBase = NULL;
	return TRUE;
}

BOOL CListViews::Uninstall()
{
	char temp[255];
	
	PPRODUCT pProduct = NULL;
	PHOTFIXLIST pHotfix = NULL;
    
	
	pProduct = DataBase;
	BOOL Done = FALSE;

	if (_tcscmp  (m_ProductName,_T("\0")))
	{
		while (  (!Done) && (pProduct != NULL))
		{
		
			 if (!_tcscmp(pProduct->ProductName, m_ProductName))
				Done = TRUE;
			else
				pProduct = pProduct->pNext;
		}
	}
	else
	{
		while (  (!Done) && (pProduct != NULL))
		{
		
			 if (!_tcscmp(pProduct->ProductName, CurrentProductName))
				Done = TRUE;
			else
				pProduct = pProduct->pNext;
		}
	}


	if (pProduct != NULL)
		pHotfix = pProduct->HotfixList;

	if (pHotfix != NULL)
	{
		Done = FALSE;
		while( (!Done) && (pHotfix != NULL) )
		{ 
			if ( ! _tcscmp(pHotfix->HotfixName,m_CurrentHotfix)) 
				Done = TRUE;
			else
				pHotfix = pHotfix->pNext;
		}
		if (pHotfix != NULL)
		{
			if (_tcscmp(pHotfix->Uninstall, _T("\0")))
			{
				_TCHAR TempString[255];
				_TCHAR TempString2[255];
				LoadString(m_hInst,IDS_UNINSTAL_WRN,TempString,255);
				_tcscat (TempString, pHotfix->HotfixName);
				LoadString(m_hInst,IDS_UNINSTAL_WRN_TITLE,TempString2,255);
				if (::MessageBox(NULL,TempString,TempString2, MB_OKCANCEL) != IDCANCEL)
				{
					wcstombs(temp,pHotfix->Uninstall,255);
      				WinExec( (char*)temp, SW_SHOWNORMAL);
					// Free the database
					FreeDatabase();
					DataBase = NULL;
					BuildDatabase( m_ComputerName);
				}
			}
		}
	}
	return TRUE;
}


	void InitializeOfn(OPENFILENAME *ofn)
	{


		static _TCHAR szFilter[] =  _T("Text (Comma Delimited) (*.csv)\0*.csv\0\0") ;
													
											

		ofn->lStructSize = sizeof (OPENFILENAME);
		ofn->hwndOwner = NULL;
		ofn->hInstance = NULL;
		ofn->lpstrFilter = szFilter;
		ofn->lpstrCustomFilter = NULL;
		ofn->nMaxCustFilter = 0;
		ofn->lpstrFile = NULL;
		ofn->nMaxFile = MAX_PATH;
		ofn->lpstrFileTitle = NULL;
		ofn->Flags = OFN_OVERWRITEPROMPT;
		ofn->nFileOffset = 0;
		ofn->nFileExtension  = 0;
		ofn->lpstrDefExt = _T("csv");
		ofn->lCustData = 0L;
		ofn->lpfnHook = NULL;
		ofn->lpTemplateName = NULL;
	}
void CListViews::SaveToCSV()
{
	PPRODUCT    pProduct = NULL;
	PHOTFIXLIST pHotfix = NULL; 
	PFILELIST       pFileList = NULL;
	_TCHAR        *Buffer;
	DWORD        LineLength = 0;
	HANDLE		 hFile = NULL;
	DWORD		 BytesWritten = 0;
	DWORD LineSize = 0;

	char			  *Buffer2;


	static OPENFILENAME ofn;
	 _TCHAR FileName[MAX_PATH];
	_tcscpy (FileName,_T("\0"));
	 InitializeOfn (&ofn);
	 ofn.lpstrFile = FileName;
	 if ( !GetSaveFileName(&ofn) )
	 {
		 return;
	 }
	// open the file
    hFile = CreateFile( FileName, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	
	if ( hFile == INVALID_HANDLE_VALUE)
	{
	
		LPVOID lpMsgBuf;
FormatMessage( 
    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
    FORMAT_MESSAGE_FROM_SYSTEM | 
    FORMAT_MESSAGE_IGNORE_INSERTS,
    NULL,
    GetLastError(),
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
    (LPTSTR) &lpMsgBuf,
    0,
    NULL 
);
// Process any inserts in lpMsgBuf.
// ...
// Display the string.
//	MessageBox( NULL, (LPCTSTR)lpMsgBuf,_T(" Error"), MB_OK | MB_ICONINFORMATION );
// Free the buffer.
LocalFree( lpMsgBuf );

		return;
	} 
	// Store Headers
	Buffer = (_TCHAR *) malloc (2000);
	Buffer2 = (char*) malloc(2000);
	LoadString(m_hInst,IDS_CSV_HEADER,Buffer,1000);
	//_stprintf(Buffer, _T("Product,Service Pack,Article,InstalledBy,InstalledDate,FileName,FileVersion,FileDate,InstallPath,Current\r"));
	wcstombs(Buffer2,Buffer, _msize(Buffer2) );
	WriteFile(hFile,Buffer2, strlen(Buffer2), &BytesWritten, NULL);

	if (Buffer)
		free (Buffer);
	if (Buffer2)
		free (Buffer2);

	Buffer = NULL;
	Buffer2 = NULL;



	// Run through the Data base and write the info to the file.
	pProduct = DataBase;
	while (pProduct != NULL)
	{
		pHotfix = pProduct->HotfixList;

		while (pHotfix != NULL)
		{
			pFileList = pHotfix->FileList;
			while (pFileList != NULL)
			{
				// Build the CSV output string
				// Product,Article,Description, ServicePack, By, Date, Type, FileName, Version, Date,Current,InstallPath
			
				// Add up the string lengths and allocata a large enough buffer.
				LineLength = _tcslen(pProduct->ProductName) + _tcslen(pHotfix->ServicePack)+
									   _tcslen(pHotfix->HotfixName) + _tcslen(pHotfix->Description )+ _tcslen(pHotfix->InstalledBy ) +
										_tcslen(pHotfix->InstalledDate)  +  _tcslen(pHotfix->Type) +
										_tcslen(pFileList->FileName ) + _tcslen(pFileList->FileVersion ) +
										_tcslen(pFileList->FileDate  ) + _tcslen(pFileList->InstallPath )+
										_tcslen(pFileList->IsCurrent  );
				Buffer = (_TCHAR *) malloc ( LineLength * sizeof (_TCHAR ) *2) ;
				Buffer2 = (char  *) malloc (LineLength *2);
				//ZeroMemory(Buffer, (LineLength * sizeof (_TCHAR)) +2);
				_tcscpy (Buffer,_T("\0"));
				strcpy(Buffer2,"\0");
				if (!Buffer)
					MessageBox (NULL,_T("NO Memory"),NULL, MB_OK);
				else
				{
				_stprintf(Buffer,_T("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\r\0\0"),pProduct->ProductName,
					pHotfix->ServicePack,pHotfix->HotfixName,pHotfix->Description ,pHotfix->InstalledBy, pHotfix->InstalledDate, 
					pHotfix->Type,pFileList->FileName,pFileList->FileVersion,pFileList->FileDate ,
					pFileList->InstallPath,pFileList->IsCurrent);
				
				// Write the line to the file
				LineSize = 0;
				LineSize = 	wcstombs(Buffer2,Buffer, _msize (Buffer2) );
				strcat(Buffer2,"\0");
				WriteFile(hFile, Buffer2, LineSize, &BytesWritten, NULL);
				}
				// Free the buffer and zero the line length for next pass.
				if (Buffer)
				{
					free (Buffer);
					free (Buffer2);
				}
				Buffer = NULL;
				Buffer2 = NULL;
				LineLength = 0;
				pFileList = pFileList->pNext;
			}
			pHotfix = pHotfix->pNext;
		}
		pProduct = pProduct->pNext;
	}
	CloseHandle(hFile);
}


DWORD CListViews::GetState()
{
	DWORD dwStatus =0;
    PPRODUCT CurrentProduct;
	PHOTFIXLIST CurrentHotfix;
	BOOL Done = FALSE;;


	switch (m_CurrentView)
	{
	case VIEW_ALL_FILE:
	case VIEW_BY_FILE:
		dwStatus |= STATE_VIEW_FILE;
		break;
	case VIEW_ALL_HOTFIX:
	case VIEW_BY_HOTFIX:
		dwStatus |= STATE_VIEW_HOTFIX;
		break;
	}

	// Do we have a database.
	if (DataBase == NULL)
		return dwStatus;

	// Does the database contain any data...
	    // A case can arise if a hotfix is installed and then uninstalled where the Registry keys 
	    // for the Product and Service Pack are not removed. We need to have at least 1 hotfix list.
     CurrentProduct = DataBase;
	 while ( (CurrentProduct != NULL) && (!Done))
	 {
		 if (CurrentProduct ->HotfixList != NULL)
			 Done = TRUE;
		 CurrentProduct = CurrentProduct->pNext;
	 }
	 if (!Done)
	 {
		//dwStatus = 0;
		 return dwStatus;
	 }
	 else 
	 {
		 // We do have data in the database so we can enable the Export list and Print options.
		 dwStatus |= DATA_TO_SAVE;
		 dwStatus |= OK_TO_PRINT;
	 }
	 	
	// Do we have a hotfix selected 
	if (_tcscmp(m_CurrentHotfix,_T("\0")))
		dwStatus |= HOTFIX_SELECTED;
    else
	{
		// If we don't have a selected hotfix we cant view the web or uninstall so 
		// Just return the current status

		return dwStatus;
	}

	// Now we need to see if we have an uninstall string for the current hotfix
	CurrentProduct = DataBase;
	// Find the selected product
	Done = FALSE;
	while ( (CurrentProduct != NULL) && (!Done))
	{
		if (!_tcscmp(CurrentProduct->ProductName ,m_ProductName))
		{
			// Find the selected hotfix
			CurrentHotfix = CurrentProduct->HotfixList;
			while ((CurrentHotfix != NULL) && (!Done))
			{
				if (! _tcscmp (CurrentHotfix->HotfixName, m_CurrentHotfix))
				{
						// Now verify the uninstall string exists
					    if (_tcscmp(CurrentHotfix->Uninstall, _T("\0")))
						{
							
							// Now verify the directory still exists
							_TCHAR TempString[255];
							_tcscpy (TempString,CurrentHotfix->Uninstall);
							PathRemoveArgs(TempString);
						    if (  PathFileExists( TempString  ))
							{
								// Yes it does we can enable uninstall
								dwStatus |=UNINSTALL_OK;
							}
							
						}
						Done = TRUE;
				}
				CurrentHotfix = CurrentHotfix->pNext;
				
			}
		}
		CurrentProduct = CurrentProduct->pNext;
	}

	

	return dwStatus;
}

_TCHAR * BuildDocument()
{


//	_TCHAR Document;
	return NULL;
}

BOOL CALLBACK AbortProc(HDC hPrinterDC, int iCode)
{
	MSG msg;
	while (!bUserAbort && PeekMessage (&msg, NULL,0,0,PM_REMOVE))
	{
		if (!hDlgPrint || !IsDialogMessage (hDlgPrint, &msg))
		{
			TranslateMessage (&msg);
			DispatchMessage (&msg);
		}
	}
	return !bUserAbort;
}

BOOL CALLBACK PrintDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{

	switch (msg)
	{
	case WM_INITDIALOG :
		EnableMenuItem (GetSystemMenu (hDlg,FALSE), SC_CLOSE, MF_GRAYED);
		return TRUE;
	case WM_COMMAND:
		bUserAbort = TRUE;
		EnableWindow (GetParent (hDlg), TRUE);
		DestroyWindow (hDlg);
	    hDlgPrint = NULL;
		return TRUE;
	}
	return FALSE;
}

BOOL JustifyString( _TCHAR* String, int FieldLength, BOOL Left)
{
	_TCHAR TempString[255];
    int   i= 0;
	int   NumSpaces = 0;
	_TCHAR Message[100];
	_TCHAR *src, *dest;



	if (String == NULL)
	{
		return FALSE;
	}

	if (Left)
	{
			// String leading spaces.
		src = String;
		dest = TempString;
		while (*src == _T(' '))
			++src;

		while (*src != _T('\0'))
		{
			*dest = *src;
			++src;
			++dest;
		}
		*dest = _T('\0');
		++dest;
		*dest = _T('\0');
		NumSpaces = (FieldLength - _tcslen(TempString) );
		_stprintf(Message,_T("FieldSize: %d, String Length: %d"),FieldLength, _tcslen(TempString));
	//	MessageBox(NULL,Message,_T("Justify"),MB_OK);
		while (NumSpaces >0)
		{
			_tcscat(TempString,_T(" "));
			--NumSpaces;
		}
	    _tcscpy (String, TempString);
		_stprintf(Message,_T("NewString Length: %d"),_tcslen(String));
	//	MessageBox(NULL,Message,_T("New String Length"),MB_OK);
		
	}
	else
	{

		_tcscpy(TempString,_T("\0"));

		NumSpaces = FieldLength - _tcslen(String);
		if (NumSpaces > 0 )
		{
			for (i = 0 ; i < NumSpaces;i++)
				TempString[i] = _T(' ');
			TempString[i] = _T('\0');
			_tcscat(TempString,String);
			_tcscpy(String,TempString);
		}
	}
	return TRUE;
}

void GetFont ( int PointSize, BOOL Bold, BOOL Underlined, LOGFONT * lf, HDC hDC)
{
	POINT pt;

	lf->lfHeight = PointSize * 10;
	pt.y = GetDeviceCaps(hDC, LOGPIXELSY) * lf->lfHeight;
	pt.y /= 720;    // 72 points/inch, 10 decipoints/point
	DPtoLP(hDC, &pt, 1);
	POINT ptOrg = { 0, 0 };
	DPtoLP(hDC, &ptOrg, 1);
	lf->lfHeight = -abs(pt.y - ptOrg.y);
	if (Underlined)
		lf->lfUnderline = TRUE;
	else
		lf->lfUnderline = FALSE;
	if (Bold)
		lf->lfWeight = FW_BOLD;
	else
		lf->lfWeight = FW_NORMAL;
	

}


void NewPage (HDC hDC, _TCHAR *Header1, _TCHAR * Header2, DWORD * CurrentLine, LOGFONT * lf)
{
	TEXTMETRIC tm;
	SIZE size;
	DWORD xStart;
	DWORD yChar;
	RECT  rect;


	rect.left = (LONG) (0 + GetDeviceCaps(hDC, LOGPIXELSX) * 0.5);
	rect.right =  (LONG) (GetDeviceCaps(hDC, PHYSICALWIDTH) -(1+ (GetDeviceCaps(hDC, LOGPIXELSX) / 2)));
	rect.top =  (LONG) (1 + GetDeviceCaps(hDC, LOGPIXELSY) * 0.5);
	rect.bottom =  (LONG) (GetDeviceCaps(hDC, PHYSICALHEIGHT) - GetDeviceCaps(hDC, LOGPIXELSX) * 0.5);
	if (StartPage(hDC) > 0)
	{
		*CurrentLine = 1;
		GetFont (12,TRUE,TRUE,lf,hDC);
		SelectObject(hDC, CreateFontIndirect(lf));
		GetTextMetrics(hDC,&tm);
		yChar = tm.tmHeight + tm.tmExternalLeading ;
		GetTextExtentPoint32(hDC, Header1,_tcslen(Header1),&size);

		xStart = (rect.right - rect.left)/2 - size.cx/2 ;
		TextOut (hDC, xStart,(*CurrentLine)* yChar ,Header1, _tcslen(Header1) );

		GetFont (10,FALSE, FALSE, lf, hDC);
		SelectObject(hDC, CreateFontIndirect (lf));
		GetTextMetrics (hDC, &tm);
		yChar = tm.tmHeight + tm.tmExternalLeading ;
		xStart = rect.right - ((_tcslen(Header2) +2) * tm.tmAveCharWidth);
		TextOut(hDC, xStart,(*CurrentLine) * yChar, Header2, _tcslen(Header2));

		(*CurrentLine) += 4;
	}
	


}
void CListViews::PrintReport()
{
	static DOCINFO	di = {sizeof (DOCINFO)  } ;
	static PRINTDLG pd;
	BOOL			bSuccess;
	int				yChar, iCharsPerLine, iLinesPerPage;


	_TCHAR			Header1[255];
	_TCHAR			Header2[255];
	TEXTMETRIC		tm;

	_TCHAR			Line [255];
	PPRODUCT		CurrentProduct;
	PHOTFIXLIST		CurrentHotfix;
	PFILELIST		CurrentFile;
	DWORD			CurrentLine = 0;
	DWORD			yStart = 0;
	_TCHAR			TempBuffer[255];
	RECT			rect;
    SIZE			size;
	_TCHAR *		src;
	DWORD			xStart;
	static LOGFONT	lf;
	SYSTEMTIME		systime;
	BOOL			Done = FALSE;
	_TCHAR			SystemDate[255];
	_TCHAR			SystemTime[255];

	_TCHAR			TempBuffer1[255];
	_TCHAR			TempBuffer2[255];
	// invoke Print common dialog box

	GetLocalTime(&systime);
	GetDateFormatW (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,NULL, SystemDate,255);
	GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &systime,NULL,SystemTime,255);
	CurrentProduct = DataBase;
	pd.lStructSize = sizeof (PRINTDLG);
	pd.hwndOwner = TopList; //m_hWnd;
	pd.hDevMode = NULL;
	pd.hDevNames= NULL;
	pd.hDC= NULL;
	pd.Flags = PD_ALLPAGES | PD_COLLATE |
					   PD_RETURNDC | PD_NOSELECTION ;
	pd.nFromPage = 0;
	pd.nToPage = 0;
	pd.nMinPage = 0;
	pd.nMaxPage = 0;
	pd.nCopies = 1;
	pd.hInstance = NULL;
	pd.lCustData = 0L;
	pd.lpfnPrintHook = NULL;
	pd.lpfnSetupHook = NULL;
	pd.lpPrintTemplateName = NULL;
	pd.lpSetupTemplateName = NULL;
	pd.hPrintTemplate = NULL;
	pd.hSetupTemplate = NULL;
 	
	if (!PrintDlg (&pd) )
			return; //TRUE;

	else
	{
		
		// Setup the printer dimensions.
		
		rect.left = (LONG) (0 + GetDeviceCaps(pd.hDC, LOGPIXELSX) * 0.5);
		rect.right =  (LONG) (GetDeviceCaps(pd.hDC, PHYSICALWIDTH) - GetDeviceCaps(pd.hDC, LOGPIXELSX) * 0.5);
		rect.top =  (LONG) (1 + GetDeviceCaps(pd.hDC, LOGPIXELSY) * 0.5);
		rect.bottom = (LONG) ( GetDeviceCaps(pd.hDC, PHYSICALHEIGHT) - GetDeviceCaps(pd.hDC, LOGPIXELSX) * 0.5);
		rect.bottom -= 100;


		bSuccess = TRUE;
		bUserAbort = TRUE;
		hDlgPrint = CreateDialog(m_hInst, _T("PrintDlgBox"),
		TopList, PrintDlgProc );
	   
		di.lpszDocName = _T("Hotfix Manager"); 
		SetAbortProc(pd.hDC, AbortProc);

		LOGFONT logFont;
		memset(&logFont, 0, sizeof(LOGFONT));
		logFont.lfCharSet = DEFAULT_CHARSET;
		_tcscpy(logFont.lfFaceName, _T("Dlg Shell Font"));
		
		LoadString(m_hInst, IDS_UPDATE_REPORT, TempBuffer, 255);
		_stprintf(Header1,_T("%s %s"), TempBuffer,m_ComputerName);
		_stprintf(Header2, _T("%s %s"),SystemDate,SystemTime);

		StartDoc(pd.hDC,&di);
			
			
					_tcscpy (Line,_T("\0"));
							
					NewPage (pd.hDC, Header1,Header2, &CurrentLine, &logFont);
					GetTextMetrics(pd.hDC,&tm);
					yChar = tm.tmHeight + tm.tmExternalLeading ;
    				iCharsPerLine = GetDeviceCaps (pd.hDC, HORZRES) / tm.tmAveCharWidth ;
					iLinesPerPage = GetDeviceCaps (pd.hDC, VERTRES) / yChar ;
					_tcscpy (Line,_T("\0"));
					xStart = rect.left;
					while ( (CurrentProduct != NULL) && (!Done))
					{
						
						_tcscpy (Line,_T("\0"));
						LoadString(m_hInst,IDS_PRODUCT_NAME, TempBuffer,255);
						logFont.lfWeight = FW_BOLD;
						SelectObject(pd.hDC,CreateFontIndirect (&logFont));
						GetTextMetrics (pd.hDC, &tm);
					
						_stprintf (Line, _T("%s: "), TempBuffer);
						yStart = CurrentLine * yChar;
						if (yStart >=  (UINT) rect.bottom)
						{
							EndPage(pd.hDC);
							NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
							yStart = CurrentLine * yChar;
						}
					
						TextOut (pd.hDC, xStart,yStart ,Line, _tcslen(Line) );
						xStart = rect.left + ((_tcslen(Line) + 4 )* tm.tmAveCharWidth);
						logFont.lfWeight = FW_NORMAL;
						SelectObject(pd.hDC,CreateFontIndirect (&logFont));
						GetTextMetrics (pd.hDC, &tm);
					
						_tcscpy (Line, CurrentProduct->ProductName);
					
						TextOut(pd.hDC, xStart, yStart , Line, _tcslen(Line) );
						CurrentLine ++;
						yStart = CurrentLine * yChar;
						if (yStart >=   (UINT)rect.bottom)
						{
							EndPage(pd.hDC);
							NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
							yStart = CurrentLine * yChar;
						}
						xStart = rect.left; 
						CurrentHotfix = CurrentProduct->HotfixList;
						while ( (CurrentHotfix != NULL ) && (!Done))
						{
							
							_stprintf (Line, _T("%s \t%s"),CurrentHotfix->HotfixName,CurrentHotfix->Description );
							TabbedTextOut (pd.hDC, xStart,yStart ,Line, _tcslen(Line),0,NULL,0 );
							++CurrentLine;
							yStart = CurrentLine * yChar;
							if (yStart >=   (UINT)rect.bottom)
							{
								EndPage(pd.hDC);
								NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
								yStart = CurrentLine * yChar;
							}
							LoadString (m_hInst,IDS_SERVICE_PACK, TempBuffer, 255);
							LoadString (m_hInst,IDS_INSTALL_DATE, TempBuffer1, 255);
							LoadString (m_hInst,IDS_INSTALLED_BY, TempBuffer2, 255);
						
							_stprintf(Line, _T("\t\t%s: %s \t%s: %s \t%s: %s"), TempBuffer,   CurrentHotfix->ServicePack,
																		TempBuffer1, CurrentHotfix->InstalledDate,
																		TempBuffer2, CurrentHotfix->InstalledBy);
						//	_stprintf (Line, _T("\t\tService Pack: %s\tInstall Date: %s\tInstalled By %s"),
							//	CurrentHotfix->ServicePack,CurrentHotfix->InstalledDate, CurrentHotfix->InstalledBy);
							TabbedTextOut (pd.hDC, xStart,yStart ,Line, _tcslen(Line),0,NULL,0 );

							CurrentLine +=2;
							yStart = CurrentLine * yChar;
							if (yStart >=   (UINT)rect.bottom)
							{
								EndPage(pd.hDC);
								NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
								yStart = CurrentLine * yChar;
							} 
							CurrentFile = CurrentHotfix->FileList ;
							if (CurrentFile == NULL)
							{
								_tcscpy (Line, _T("\0"));
								LoadString(m_hInst,IDS_NO_FILES,Line,255);
								TextOut (pd.hDC, xStart,yStart ,Line, _tcslen(Line) );
								CurrentLine += 2;
								if (yStart >=  (UINT) rect.bottom)
								{
									EndPage(pd.hDC);
									NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
									yStart = CurrentLine * yChar;
								} 
							}
							else
							{
								logFont.lfUnderline = TRUE;
								logFont.lfWeight = FW_BOLD;
								SelectObject(pd.hDC, CreateFontIndirect (&logFont));
								_tcscpy (Line, _T("\0"));
								LoadString (m_hInst, IDS_FILE,TempBuffer,255);
							    JustifyString(TempBuffer,FILENAME_FIELD_WIDTH,TRUE);
								TextOut( pd.hDC, xStart,yStart ,TempBuffer, _tcslen(TempBuffer) );

								LoadString (m_hInst, IDS_FILEDATE,TempBuffer,255);
							    JustifyString(TempBuffer,DATE_FIELD_WIDTH,TRUE);
								TextOut( pd.hDC, xStart + 29 * tm.tmAveCharWidth ,yStart ,TempBuffer, _tcslen(TempBuffer) );
								
								LoadString (m_hInst, IDS_FILEVERSION,TempBuffer,255);
							    JustifyString(TempBuffer,VERSION_FIELD_WIDTH,TRUE);
								TextOut( pd.hDC, xStart + 45 * tm.tmAveCharWidth ,yStart ,TempBuffer, _tcslen(TempBuffer) );

								LoadString (m_hInst, IDS_FILECURRENT,TempBuffer,255);
							    JustifyString(TempBuffer,CURRENT_FIELD_WIDTH,TRUE);
								TextOut( pd.hDC, xStart + 61* tm.tmAveCharWidth,yStart ,TempBuffer, _tcslen(TempBuffer) );

								LoadString (m_hInst, IDS_FILEPATH,TempBuffer,255);
							    JustifyString(TempBuffer,PATH_FIELD_WIDTH,TRUE);
								TextOut( pd.hDC, xStart+72 * tm.tmAveCharWidth ,yStart ,TempBuffer, _tcslen(TempBuffer) );
								++ CurrentLine;
								yStart = CurrentLine * yChar;
								if (yStart >=   (UINT)rect.bottom)
								{
									EndPage(pd.hDC);
									NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
									yStart = CurrentLine * yChar;
								} 
							}
							while ( (CurrentFile != NULL) && (!Done) )
							{
								logFont.lfWeight = FW_NORMAL;
								logFont.lfUnderline = FALSE;
								SelectObject(pd.hDC, CreateFontIndirect (&logFont));
								_tcscpy (Line, _T("\0"));

								_tcscpy (Line, CurrentFile->FileName);
							//	JustifyString(Line,40, TRUE);
								TextOut (pd.hDC, xStart,yStart ,Line, _tcslen(Line) );
							//_tcscat (Line,TempBuffer);

								_tcscpy (Line, CurrentFile->FileDate);
							//	JustifyString(Line,20, TRUE);
								TextOut (pd.hDC, xStart + 29 * tm.tmAveCharWidth,yStart ,Line, _tcslen(Line) );

								_tcscpy (Line, CurrentFile->FileVersion );
							//	JustifyString(Line,18, TRUE);
								TextOut (pd.hDC, xStart + 45 * tm.tmAveCharWidth,yStart ,Line, _tcslen(Line) );

								_tcscpy (Line, CurrentFile->IsCurrent);
							//	JustifyString(Line,12, TRUE);
								TextOut (pd.hDC, xStart + 61 * tm.tmAveCharWidth,yStart ,Line, _tcslen(Line) );

								_tcscpy (Line,CurrentFile->InstallPath);
								TextOut (pd.hDC, xStart + 72 * tm.tmAveCharWidth,yStart ,Line, _tcslen(Line) );
								++CurrentLine;

								yStart = CurrentLine * yChar;
								if (yStart >=   (UINT)rect.bottom)
								{
//									MessageBox (NULL,_T("Hit Page Break Code"),NULL,MB_OK);
									EndPage(pd.hDC);
									NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
									yStart = CurrentLine * yChar;
								} 
								CurrentFile = CurrentFile->pNext;
								if (!bUserAbort)
									Done = TRUE;
								
							} // End While Current File
							++CurrentLine;

							yStart = CurrentLine * yChar;
							if (yStart >=   (UINT)rect.bottom)
							{
								EndPage(pd.hDC);
								NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
								yStart = CurrentLine * yChar;
							} 
							CurrentHotfix = CurrentHotfix->pNext;
							if (!bUserAbort)
								Done = TRUE;
						}
						++CurrentLine;
						yStart = CurrentLine * yChar;
						if (yStart >=   (UINT)rect.bottom)
						{
							EndPage(pd.hDC);
							NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
							yStart = CurrentLine * yChar;
						} 
						CurrentProduct = CurrentProduct->pNext;
						if (!bUserAbort)
							Done = TRUE;
					}

					if (EndPage(pd.hDC) > 0)
						EndDoc(pd.hDC);
					DeleteDC(pd.hDC);
					DestroyWindow(hDlgPrint);
				
				
			
		

		
	}
	return; //FALSE;
}


int CALLBACK CListViews::CompareFunc (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	int Result = -1;
	int SubItemIndex = (INT) lParamSort;
	
	_TCHAR String1[1000];
	_TCHAR String2 [1000];


	ListView_GetItemText( TopList, lParam1, SubItemIndex, String1, 1000);
	ListView_GetItemText( TopList, lParam2, SubItemIndex, String2, 1000);
	if (! (String1 && String2) )
		return 1;
	if (m_SortOrder)   // Sort Acending
	{
		Result = _tcscmp(String1,String2);
	}
	else						// Sort Decending
	{
		Result = -_tcscmp(String1,String2);
	}
	if (Result == 0)
		Result = -1;
	return Result; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\database.h ===
//
// File:	Database.h
// By:		Anthony V. DeMarco (ademar)
// Date:  12/28/1999
// Description:  Contains the internal hotfix database data structures.
// Copyright (c) Microsoft Corporation 1999-2000
//

typedef struct _FILELIST
{
	_TCHAR FileName[255];
	_TCHAR CheckSum;
	struct _FILELIST * pPrev;
	struct _FILELIST * pNext;
} * PFILELIST;

typedef struct _HOTFIXLIST
{
	_TCHAR HotfixName[255];
	struct _HOTFIXLIST * pPrev;
	struct _HOTFIXLIST * pNext;
	PFILELIST FileList;
} * PHOTFIXLIST;

typedef struct _ProductNode {
	_TCHAR ProductName[255];
	_ProductNode * pPrev;
	_ProductNode * pNext;
	PHOTFIXLIST      HotfixList;
} * PPRODUCT;

PHOTFIXLIST GetHotfixInfo( _TCHAR * pszProductName, HKEY* hUpdateKey );
PPRODUCT BuildDatabase(_TCHAR * lpszComputerName);
PFILELIST GetFileInfo(HKEY* hHotfixKey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( HotfixManager )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( HotfixManager ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\hotfixmanager_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Feb 16 13:06:19 2000
 */
/* Compiler settings for E:\HotfixManager\HotfixManager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IHotfixOCX = {0x692E94C7,0xA5AC,0x401B,{0xA4,0x71,0xBC,0xD1,0x01,0xB4,0x56,0xF4}};


const IID LIBID_HOTFIXMANAGERLib = {0x8384D1FB,0xF41D,0x4540,{0xB0,0xCA,0xC0,0x26,0xDA,0x83,0x64,0xBD}};


const IID DIID__IHotfixOCXEvents = {0x7E2DCE25,0xE11D,0x45D6,{0x9A,0xE7,0xAD,0x52,0x2D,0x91,0x5F,0xFC}};


const CLSID CLSID_HotfixOCX = {0x883B970F,0x690C,0x45F2,{0x8A,0x3A,0xF4,0x28,0x3E,0x07,0x81,0x18}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\hotfixmanager.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Feb 16 13:06:19 2000
 */
/* Compiler settings for E:\HotfixManager\HotfixManager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __HotfixManager_h__
#define __HotfixManager_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IHotfixOCX_FWD_DEFINED__
#define __IHotfixOCX_FWD_DEFINED__
typedef interface IHotfixOCX IHotfixOCX;
#endif 	/* __IHotfixOCX_FWD_DEFINED__ */


#ifndef ___IHotfixOCXEvents_FWD_DEFINED__
#define ___IHotfixOCXEvents_FWD_DEFINED__
typedef interface _IHotfixOCXEvents _IHotfixOCXEvents;
#endif 	/* ___IHotfixOCXEvents_FWD_DEFINED__ */


#ifndef __HotfixOCX_FWD_DEFINED__
#define __HotfixOCX_FWD_DEFINED__

#ifdef __cplusplus
typedef class HotfixOCX HotfixOCX;
#else
typedef struct HotfixOCX HotfixOCX;
#endif /* __cplusplus */

#endif 	/* __HotfixOCX_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IHotfixOCX_INTERFACE_DEFINED__
#define __IHotfixOCX_INTERFACE_DEFINED__

/* interface IHotfixOCX */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IHotfixOCX;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("692E94C7-A5AC-401B-A471-BCD101B456F4")
    IHotfixOCX : public IDispatch
    {
    public:
        virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ IFontDisp __RPC_FAR *pFont) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Font( 
            /* [in] */ IFontDisp __RPC_FAR *pFont) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *ppFont) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Command( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Command( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ComputerName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProductName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ProductName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ViewState( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Remoted( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HaveHotfix( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentState( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHotfixOCXVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHotfixOCX __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHotfixOCX __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHotfixOCX __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Font )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ IFontDisp __RPC_FAR *pFont);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Font )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ IFontDisp __RPC_FAR *pFont);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Font )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *ppFont);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Command )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Command )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ComputerName )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ComputerName )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProductName )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProductName )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ViewState )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Remoted )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HaveHotfix )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentState )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        END_INTERFACE
    } IHotfixOCXVtbl;

    interface IHotfixOCX
    {
        CONST_VTBL struct IHotfixOCXVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHotfixOCX_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHotfixOCX_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHotfixOCX_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHotfixOCX_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHotfixOCX_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHotfixOCX_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHotfixOCX_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHotfixOCX_putref_Font(This,pFont)	\
    (This)->lpVtbl -> putref_Font(This,pFont)

#define IHotfixOCX_put_Font(This,pFont)	\
    (This)->lpVtbl -> put_Font(This,pFont)

#define IHotfixOCX_get_Font(This,ppFont)	\
    (This)->lpVtbl -> get_Font(This,ppFont)

#define IHotfixOCX_get_Command(This,pVal)	\
    (This)->lpVtbl -> get_Command(This,pVal)

#define IHotfixOCX_put_Command(This,newVal)	\
    (This)->lpVtbl -> put_Command(This,newVal)

#define IHotfixOCX_get_ComputerName(This,pVal)	\
    (This)->lpVtbl -> get_ComputerName(This,pVal)

#define IHotfixOCX_put_ComputerName(This,newVal)	\
    (This)->lpVtbl -> put_ComputerName(This,newVal)

#define IHotfixOCX_get_ProductName(This,pVal)	\
    (This)->lpVtbl -> get_ProductName(This,pVal)

#define IHotfixOCX_put_ProductName(This,newVal)	\
    (This)->lpVtbl -> put_ProductName(This,newVal)

#define IHotfixOCX_get_ViewState(This,pVal)	\
    (This)->lpVtbl -> get_ViewState(This,pVal)

#define IHotfixOCX_get_Remoted(This,pVal)	\
    (This)->lpVtbl -> get_Remoted(This,pVal)

#define IHotfixOCX_get_HaveHotfix(This,pVal)	\
    (This)->lpVtbl -> get_HaveHotfix(This,pVal)

#define IHotfixOCX_get_CurrentState(This,pVal)	\
    (This)->lpVtbl -> get_CurrentState(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propputref] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_putref_Font_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [in] */ IFontDisp __RPC_FAR *pFont);


void __RPC_STUB IHotfixOCX_putref_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_put_Font_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [in] */ IFontDisp __RPC_FAR *pFont);


void __RPC_STUB IHotfixOCX_put_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_Font_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *ppFont);


void __RPC_STUB IHotfixOCX_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_Command_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_Command_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_put_Command_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IHotfixOCX_put_Command_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_ComputerName_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_ComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_put_ComputerName_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IHotfixOCX_put_ComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_ProductName_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_ProductName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_put_ProductName_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IHotfixOCX_put_ProductName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_ViewState_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_ViewState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_Remoted_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_Remoted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_HaveHotfix_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_HaveHotfix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_CurrentState_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_CurrentState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHotfixOCX_INTERFACE_DEFINED__ */



#ifndef __HOTFIXMANAGERLib_LIBRARY_DEFINED__
#define __HOTFIXMANAGERLib_LIBRARY_DEFINED__

/* library HOTFIXMANAGERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HOTFIXMANAGERLib;

#ifndef ___IHotfixOCXEvents_DISPINTERFACE_DEFINED__
#define ___IHotfixOCXEvents_DISPINTERFACE_DEFINED__

/* dispinterface _IHotfixOCXEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__IHotfixOCXEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("7E2DCE25-E11D-45D6-9AE7-AD522D915FFC")
    _IHotfixOCXEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IHotfixOCXEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IHotfixOCXEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IHotfixOCXEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IHotfixOCXEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _IHotfixOCXEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _IHotfixOCXEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _IHotfixOCXEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _IHotfixOCXEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _IHotfixOCXEventsVtbl;

    interface _IHotfixOCXEvents
    {
        CONST_VTBL struct _IHotfixOCXEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IHotfixOCXEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IHotfixOCXEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IHotfixOCXEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IHotfixOCXEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _IHotfixOCXEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _IHotfixOCXEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _IHotfixOCXEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IHotfixOCXEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HotfixOCX;

#ifdef __cplusplus

class DECLSPEC_UUID("883B970F-690C-45F2-8A3A-F4283E078118")
HotfixOCX;
#endif
#endif /* __HOTFIXMANAGERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\hotfixmanager.cpp ===
// HotfixManager.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f HotfixManagerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "HotfixManager.h"

#include "HotfixManager_i.c"
#include "HotfixOCX.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_HotfixOCX, CHotfixOCX)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_HOTFIXMANAGERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\hotfixmanager_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Feb 16 13:06:19 2000
 */
/* Compiler settings for E:\HotfixManager\HotfixManager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "HotfixManager.h"

#define TYPE_FORMAT_STRING_SIZE   81                                
#define PROC_FORMAT_STRING_SIZE   365                               

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IHotfixOCX, ver. 0.0,
   GUID={0x692E94C7,0xA5AC,0x401B,{0xA4,0x71,0xBC,0xD1,0x01,0xB4,0x56,0xF4}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IHotfixOCX_ServerInfo;

#pragma code_seg(".orpc")
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x50100a4, /* MIDL Version 5.1.164 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

static const unsigned short IHotfixOCX_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    28,
    56,
    84,
    112,
    140,
    168,
    196,
    224,
    252,
    280,
    308,
    336
    };

static const MIDL_SERVER_INFO IHotfixOCX_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IHotfixOCX_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IHotfixOCX_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IHotfixOCX_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(20) _IHotfixOCXProxyVtbl = 
{
    &IHotfixOCX_ProxyInfo,
    &IID_IHotfixOCX,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* IHotfixOCX::putref_Font */ ,
    (void *)-1 /* IHotfixOCX::put_Font */ ,
    (void *)-1 /* IHotfixOCX::get_Font */ ,
    (void *)-1 /* IHotfixOCX::get_Command */ ,
    (void *)-1 /* IHotfixOCX::put_Command */ ,
    (void *)-1 /* IHotfixOCX::get_ComputerName */ ,
    (void *)-1 /* IHotfixOCX::put_ComputerName */ ,
    (void *)-1 /* IHotfixOCX::get_ProductName */ ,
    (void *)-1 /* IHotfixOCX::put_ProductName */ ,
    (void *)-1 /* IHotfixOCX::get_ViewState */ ,
    (void *)-1 /* IHotfixOCX::get_Remoted */ ,
    (void *)-1 /* IHotfixOCX::get_HaveHotfix */ ,
    (void *)-1 /* IHotfixOCX::get_CurrentState */
};


static const PRPC_STUB_FUNCTION IHotfixOCX_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IHotfixOCXStubVtbl =
{
    &IID_IHotfixOCX,
    &IHotfixOCX_ServerInfo,
    20,
    &IHotfixOCX_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute, more than 32 methods in the interface.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure putref_Font */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pFont */

/* 16 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 18 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 24 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Font */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 36 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pFont */

/* 44 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 46 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 48 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 52 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Font */

/* 56 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 64 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x8 ),	/* 8 */
/* 70 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppFont */

/* 72 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
#ifndef _ALPHA_
/* 74 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 76 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Return value */

/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 80 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Command */

/* 84 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
/* 90 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 92 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x10 ),	/* 16 */
/* 98 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 100 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 102 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 108 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Command */

/* 112 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 120 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 122 */	NdrFcShort( 0x8 ),	/* 8 */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter newVal */

/* 128 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 130 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 134 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 136 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 138 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ComputerName */

/* 140 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 142 */	NdrFcLong( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 148 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 152 */	NdrFcShort( 0x8 ),	/* 8 */
/* 154 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 156 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 158 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 160 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 164 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ComputerName */

/* 168 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 176 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 182 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter newVal */

/* 184 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 186 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 188 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 190 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 192 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 194 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ProductName */

/* 196 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 198 */	NdrFcLong( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 204 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 212 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 214 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 216 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 220 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ProductName */

/* 224 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 232 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 238 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter newVal */

/* 240 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 242 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 244 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 246 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 248 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 250 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ViewState */

/* 252 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 254 */	NdrFcLong( 0x0 ),	/* 0 */
/* 258 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 260 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x10 ),	/* 16 */
/* 266 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 268 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 270 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 272 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 274 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 276 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 278 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Remoted */

/* 280 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 282 */	NdrFcLong( 0x0 ),	/* 0 */
/* 286 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 288 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 290 */	NdrFcShort( 0x0 ),	/* 0 */
/* 292 */	NdrFcShort( 0x10 ),	/* 16 */
/* 294 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 296 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 298 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 300 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 302 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 304 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 306 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_HaveHotfix */

/* 308 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 310 */	NdrFcLong( 0x0 ),	/* 0 */
/* 314 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 316 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 318 */	NdrFcShort( 0x0 ),	/* 0 */
/* 320 */	NdrFcShort( 0x10 ),	/* 16 */
/* 322 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 324 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 326 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 330 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 332 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 334 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_CurrentState */

/* 336 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 338 */	NdrFcLong( 0x0 ),	/* 0 */
/* 342 */	NdrFcShort( 0x13 ),	/* 19 */
#ifndef _ALPHA_
/* 344 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
/* 348 */	NdrFcShort( 0x10 ),	/* 16 */
/* 350 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 352 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 354 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 356 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 358 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 360 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 362 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0xbef6e003 ),	/* -1091117053 */
/*  8 */	NdrFcShort( 0xa874 ),	/* -22412 */
/* 10 */	NdrFcShort( 0x101a ),	/* 4122 */
/* 12 */	0x8b,		/* 139 */
			0xba,		/* 186 */
/* 14 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 16 */	0x0,		/* 0 */
			0x30,		/* 48 */
/* 18 */	0xc,		/* 12 */
			0xab,		/* 171 */
/* 20 */	
			0x11, 0x10,	/* FC_RP */
/* 22 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (2) */
/* 24 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 26 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 28 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 30 */	NdrFcShort( 0x1a ),	/* Offset= 26 (56) */
/* 32 */	
			0x13, 0x0,	/* FC_OP */
/* 34 */	NdrFcShort( 0xc ),	/* Offset= 12 (46) */
/* 36 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 38 */	NdrFcShort( 0x2 ),	/* 2 */
/* 40 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 42 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 44 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 46 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
/* 50 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (36) */
/* 52 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x4 ),	/* 4 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
/* 64 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (32) */
/* 66 */	
			0x12, 0x0,	/* FC_UP */
/* 68 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (46) */
/* 70 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x4 ),	/* 4 */
/* 76 */	NdrFcShort( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (66) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _HotfixManager_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IHotfixOCXProxyVtbl,
    0
};

const CInterfaceStubVtbl * _HotfixManager_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IHotfixOCXStubVtbl,
    0
};

PCInterfaceName const _HotfixManager_InterfaceNamesList[] = 
{
    "IHotfixOCX",
    0
};

const IID *  _HotfixManager_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _HotfixManager_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _HotfixManager, pIID, n)

int __stdcall _HotfixManager_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_HotfixManager_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo HotfixManager_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _HotfixManager_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _HotfixManager_StubVtblList,
    (const PCInterfaceName * ) & _HotfixManager_InterfaceNamesList,
    (const IID ** ) & _HotfixManager_BaseIIDList,
    & _HotfixManager_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\hotfixocx.cpp ===
// HotfixOCX.cpp : Implementation of CHotfixOCX

#include "stdafx.h"
#include "HotfixManager.h"
#include "HotfixOCX.h"
#include <Windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <comdef.h>


/////////////////////////////////////////////////////////////////////////////
// CHotfixOCX
BOOL CHotfixOCX::ResizeButtons(RECT *rc)
{


	::MoveWindow(WebButton, 
            rc->left+40,
            rc->bottom - 40,
            100,
			28,
            TRUE);
	::MoveWindow(UninstButton,
			rc->left+180,
			rc->bottom - 40,
            100,
            28,
            TRUE);
	::MoveWindow(RptButton,
			rc->left+320,
			rc->bottom - 40,
            100,
            28,
            TRUE);

	return TRUE;
}
BOOL CHotfixOCX::CreateButton( HINSTANCE hInst, HWND hWnd, RECT * rc)							
{

	_TCHAR       Temp[255];
	DWORD        dwSize = 255;
	BOOL        bSuccess = TRUE;
	
	LoadString(hInst,IDS_BN_VIEW_WEB, Temp,dwSize);
	WebButton = CreateWindow (_T("button"), Temp,WS_CHILD | BS_DEFPUSHBUTTON|WS_VISIBLE,0,0,0,0,hWnd,(HMENU) IDC_WEB_BUTTON,hInst,NULL);
	LoadString(hInst,IDS_BN_UNINSTALL, Temp,dwSize);

	UninstButton = CreateWindow (_T("button"), Temp,WS_CHILD | BS_PUSHBUTTON|WS_VISIBLE,0,0,0,0,hWnd,(HMENU) IDC_UNINST_BUTTON,hInst,NULL);
	LoadString(hInst,IDS_BN_PRINT_REPORT, Temp,dwSize);

	RptButton = CreateWindow (_T("button"), Temp,WS_CHILD | BS_PUSHBUTTON|WS_VISIBLE,0,0,0,0,hWnd,(HMENU) IDC_RPT_BUTTON,hInst,NULL);

/*	if(!hButton)
	   return NULL;*/
    NONCLIENTMETRICS ncm;
	HFONT hFont;

		ncm.cbSize = sizeof(ncm);
		SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof (ncm),&ncm,0);
	
	//	_tcscpy(ncm.lfMenuFont.lfFaceName,_T("MS Shell Dlg"));
		 // = _T("MS Shell Dlg");
		hFont = CreateFontIndirect(&ncm.lfMenuFont);
		
	SendMessage(WebButton,WM_SETFONT, (WPARAM)hFont ,MAKELPARAM(TRUE, 0));
	SendMessage(UninstButton,WM_SETFONT, (WPARAM)hFont ,MAKELPARAM(TRUE, 0));
	SendMessage(RptButton,WM_SETFONT, (WPARAM)hFont ,MAKELPARAM(TRUE, 0));

	
//	MessageBox(NULL,_T("Got the Button Created"),_T(""),MB_OK);
	ResizeButtons(rc);
	return TRUE;
}

BOOL CHotfixOCX::ShowWebPage(_TCHAR *HotFix)
{
    char temp[255];
	char Command[255];	
	if (_tcscmp(HotFix,_T("\0")))
	{
		wcstombs(temp,HotFix,255);
        sprintf(Command, "Explorer.exe \"http://Support.Microsoft.com/Support/Misc/KbLookup.asp?ID=%s\"",  temp+1);
		 //MessageBox(Command,NULL,MB_OK);
		WinExec( (char*)Command, SW_SHOWNORMAL);
	}
	return TRUE;
}

STDMETHODIMP CHotfixOCX::get_Command(long *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CHotfixOCX::put_Command(long newVal)
{
	// TODO: Add your implementation code here
	switch (newVal)
	{
	case IDC_VIEW_BY_FILE:
		// Change the current view type to by file.
		ListViews.SetViewMode(VIEW_BY_FILE);
		break;
	case IDC_VIEW_BY_HOTFIX:
	    // Change the current view type to by hotfix
		ListViews.SetViewMode(VIEW_BY_HOTFIX);
		break;
	case IDC_UNINSTALL:
		// Uninstall the current hotfix if pointing at the local system
		ListViews.Uninstall();
		break;
	
	case IDC_VIEW_WEB:
		// View the web page for the current hotfix
		ShowWebPage(ListViews.GetCurrentHotfix());
		break;
		
	case IDC_EXPORT:
			ListViews.SaveToCSV();

        	// Generate a report for the current system
		break;
	case IDC_PRINT_REPORT:
			ListViews.PrintReport();
		break; 
	}
 	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_ComputerName(BSTR *pVal)
{
	// TODO: Add your implementation code here
	// Return the name of the current target computer.
	return S_OK;
}

STDMETHODIMP CHotfixOCX::put_ComputerName(BSTR newVal)
{
	// TODO: Add your implementation code here
	// Set the name of the target computer.
	//_bstr_t Val(newVal,FALSE);
	_tcscpy(ComputerName,newVal);

	ListViews.Initialize(ComputerName);
	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_ProductName(BSTR *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CHotfixOCX::put_ProductName(BSTR newVal)
{
	_TCHAR Temp[255];
	// TODO: Add your implementation code here
	// Set the name of the current producted selected in the snap-in scope tree.
//	_bstr_t Val(newVal,FALSE);
    _tcscpy (Temp,newVal);
	
//	MessageBox(Temp,_T("Recieved....."),MB_OK);
	ListViews.SetProductName(Temp);
	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_ViewState(long *pVal)
{
	// TODO: Add your implementation code here
	*pVal = ListViews.GetCurrentView();
	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_Remoted(BOOL *pVal)
{
	// TODO: Add your implementation code here
	*pVal = ListViews.m_bRemoted;
	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_HaveHotfix(BOOL *pVal)
{
	// TODO: Add your implementation code here
	if (_tcscmp( ListViews.m_CurrentHotfix, _T("\0")))
		*pVal = TRUE;
	else
		*pVal = FALSE;
	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_CurrentState(long *pVal)
{
	// TODO: Add your implementation code here
    *pVal = ListViews.GetState();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D0136A53_0029_4990_8249_8E89D9963E8B__INCLUDED_)
#define AFX_STDAFX_H__D0136A53_0029_4990_8249_8E89D9963E8B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D0136A53_0029_4990_8249_8E89D9963E8B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\snapin\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "HotfixManager_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HotfixManager.rc
//
#define UNINSTALL_OK                    1
#define HOTFIX_SELECTED                 2
#define IS_REMOTED                      4
#define DATA_TO_SAVE                    8
#define OK_TO_PRINT                     16
#define STATE_VIEW_FILE                 32
#define STATE_VIEW_HOTFIX               64
#define IDS_PROJNAME                    100
#define IDB_HOTFIXOCX                   101
#define IDR_HOTFIXOCX                   102
#define IDR_MENU1                       201
#define IDC_RPT_BUTTON                  998
#define IDC_UNINST_BUTTON               999
#define VIEW_BY_FILE                    1000
#define IDC_WEB_BUTTON                  1000
#define VIEW_BY_HOTFIX                  1001
#define VIEW_FILE_INFO                  1002
#define VIEW_HOTFIX_INFO                1003
#define VIEW_ALL_FILE                   1004
#define VIEW_ALL_HOTFIX                 1005
#define IDC_VIEW_WEB                    2000
#define IDC_VIEW_BY_FILE                2001
#define IDC_VIEW_BY_HOTFIX              2002
#define IDC_UNINSTALL                   2003
#define IDC_REFRESH                     2004
#define IDC_EXPORT                      2005
#define IDC_PRINT_REPORT                2006
#define IDS_ARTICLE_NUMBER              32767
#define IDM_VIEW_FILE                   32768
#define IDM_VIEW_HOTFIX                 32769
#define IDM_GENERATE_REPORT             32770
#define IDM_VIEW_WEB                    32771
#define IDM_UNINSTALL                   32772
#define ID_CONTEXTMENU                  32773
#define IDS_PRODUCT_NAME                32774
#define ID_CONTEXTMENU_PRINT            32774
#define IDS_INSTALLED_BY                32775
#define IDM_EXPORT_LIST                 32775
#define IDS_DESCRIPTION                 32776
#define IDS_INSTALL_DATE                32777
#define IDS_SERVICE_PACK                32778
#define IDS_UPDATE_TYPE                 32779
#define IDS_FILE_NAME                   32780
#define IDS_FILE_CURRENT                32781
#define IDS_FILE_DATE                   32782
#define IDS_FILE_VERSION                32783
#define IDS_BN_VIEW_WEB                 32784
#define IDS_BN_UNINSTALL                32785
#define IDS_BN_PRINT_REPORT             32786
#define IDS_FILE_LOCATION               32787
#define IDS_RETRIEVE_DATA               32788
#define IDS_CSV_HEADER                  32789
#define IDS_NO_ITEMS                    32790
#define IDS_UNINSTALL_WRN               32791
#define IDS_UNINSTAL_WRN                32791
#define IDS_UNINSTAL_WRN_TITLE          32792
#define IDS_FILE_TITLE                  32793
#define IDS_NO_FILES                    32794
#define IDS_UPDATE_REPORT               32795
#define IDS_FILE                        32796
#define IDS_FILEVERSION                 32797
#define IDS_FILEDATE                    32798
#define IDS_FILEPATH                    32799
#define IDS_FILECURRENT                 32800
#define IDS_YES                         32801
#define IDS_NO                          32802

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\ocx\hotfixocx.h ===
// HotfixOCX.h : Declaration of the CHotfixOCX

#ifndef __HOTFIXOCX_H_
#define __HOTFIXOCX_H_
#include <atlctl.h>
#include "resource.h"       // main symbols
#include <windowsx.h>
#include <windows.h>
#include "CListViews.h"




/////////////////////////////////////////////////////////////////////////////
// CHotfixOCX
class ATL_NO_VTABLE CHotfixOCX : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CHotfixOCX, IHotfixOCX, &IID_IHotfixOCX, &LIBID_HOTFIXMANAGERLib>,
	public CComControl<CHotfixOCX>,
	public IPersistStreamInitImpl<CHotfixOCX>,
	public IOleControlImpl<CHotfixOCX>,
	public IOleObjectImpl<CHotfixOCX>,
	public IOleInPlaceActiveObjectImpl<CHotfixOCX>,
	public IViewObjectExImpl<CHotfixOCX>,
	public IOleInPlaceObjectWindowlessImpl<CHotfixOCX>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CHotfixOCX>,
	public IPersistStorageImpl<CHotfixOCX>,
	public ISpecifyPropertyPagesImpl<CHotfixOCX>,
	public IQuickActivateImpl<CHotfixOCX>,
	public IDataObjectImpl<CHotfixOCX>,
	public IProvideClassInfo2Impl<&CLSID_HotfixOCX, &DIID__IHotfixOCXEvents, &LIBID_HOTFIXMANAGERLib>,
	public IPropertyNotifySinkCP<CHotfixOCX>,
	public CComCoClass<CHotfixOCX, &CLSID_HotfixOCX>
{
public:
	CHotfixOCX()
	{
		m_bWindowOnly = TRUE;
		_tcscpy(ComputerName,_T("\0"));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_HOTFIXOCX)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHotfixOCX)
	COM_INTERFACE_ENTRY(IHotfixOCX)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CHotfixOCX)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	PROP_ENTRY("Font", DISPID_FONT, CLSID_StockFontPage)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CHotfixOCX)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CHotfixOCX)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_NOTIFY,OnNotify)
	MESSAGE_HANDLER(WM_COMMAND,OnCommand)
	MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
	CHAIN_MSG_MAP(CComControl<CHotfixOCX>)
	DEFAULT_REFLECTION_HANDLER()

END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		static const IID* arr[] = 
		{
			&IID_IHotfixOCX,
		};
		for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
		{
		//	if (InlineIsEqualGUID(*arr[i], riid))
				return S_OK;
		}
		return S_FALSE;
	} 

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IHotfixOCX
public:
	STDMETHOD(get_CurrentState)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_HaveHotfix)(/*[out, retval]*/ BOOL*pVal);
	STDMETHOD(get_Remoted)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_ViewState)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_ProductName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ProductName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ComputerName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ComputerName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Command)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Command)(/*[in]*/ long newVal);

	ShowWebPage(_TCHAR *HotFix);

	BOOL CreateButton( HINSTANCE hInst, HWND hWnd,RECT* rc);
	BOOL ResizeButtons(RECT *rc);
	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

		HBRUSH hBrush = GetSysColorBrush (COLOR_BTNFACE );
		
		FillRect (di.hdcDraw, &rc, hBrush);
		SelectObject(di.hdcDraw, hBrush);
		DeleteObject (hBrush);

		return S_OK;
	}
	CComPtr<IFontDisp> m_pFont;
	CListViews ListViews;
	  HWND WebButton;
	   HWND UninstButton;
	   HWND RptButton;
	_TCHAR ComputerName[256];
	BOOL m_bInitComplete;
	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		_TCHAR TempName[255];
		DWORD dwLength = 255;
		m_bInitComplete = FALSE;
		// TODO : Add Code for message handler. Call DefWindowProc if necessary.
		RECT rc;
		GetClientRect(&rc);
		CreateButton(_Module.GetModuleInstance(),m_hWnd,&rc);
		::EnableWindow( WebButton,FALSE);
		::EnableWindow(UninstButton,FALSE);
		ListViews.Initialize(m_hWnd, _Module.GetModuleInstance(),ComputerName,
			WebButton, UninstButton, RptButton);
		ListViews.ShowLists(&rc);
        GetComputerName(TempName, &dwLength);
//		MessageBox(TempName, ComputerName,MB_OK);
	
	
		m_bInitComplete = TRUE;
		return 0;
	}

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		RECT rc;
		rc.top = 0;
		rc.left = 0;
		rc.right = LOWORD(lParam);
		rc.bottom = HIWORD(lParam);
		// TODO : Add Code for message handler. Call DefWindowProc if necessary.
		ListViews.Resize(&rc);
		ResizeButtons(&rc);
		return 0;
	}
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return ListViews.OnNotify( uMsg, wParam,  lParam, bHandled,m_hWnd);
	}





	LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
	  
		 switch (HIWORD (wParam))
		 {
			 case BN_CLICKED:
			 if ( WebButton == (HWND)lParam)
			 {
				ShowWebPage(ListViews.GetCurrentHotfix());
				return 0;
			 }
			 else if (UninstButton == (HWND)lParam)
			 {
				 ListViews.Uninstall();
			}
			 else if (RptButton == (HWND)lParam)
			 {
				 ListViews.PrintReport();
			 }
				break;
		 }


		 switch (LOWORD (wParam))
		 {
		 case IDM_VIEW_WEB:
			  ShowWebPage(ListViews.GetCurrentHotfix());
			 break;
		 case IDM_UNINSTALL:
			 
			 ListViews.Uninstall();
			 break;
		 case IDM_EXPORT_LIST:
			 	ListViews.SaveToCSV();
			 break;
		 case IDM_VIEW_FILE:
			  ListViews.SetViewMode(VIEW_BY_FILE);
			  break;
		 case IDM_VIEW_HOTFIX:
			 ListViews.SetViewMode(VIEW_BY_HOTFIX);
			 break;
		 case ID_CONTEXTMENU_PRINT:
			 ListViews.PrintReport();
			 break;

		 }

		bHandled = FALSE;
		return 0;
	}
	LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		// TODO : Add Code for message handler. Call DefWindowProc if necessary.
		HMENU hMenuLoad,
		hMenu;

		DWORD dwCurrentState =0;
		hMenuLoad = LoadMenu(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_MENU1));
		
		hMenu = GetSubMenu(hMenuLoad, 0);
         
		 dwCurrentState = ListViews.GetState ();
		 if (!(dwCurrentState&UNINSTALL_OK) )
		           ::EnableMenuItem(hMenu,IDM_UNINSTALL,MF_BYCOMMAND | MF_GRAYED);
		 if (!(dwCurrentState&HOTFIX_SELECTED))
		 {
				   ::EnableMenuItem(hMenu,IDM_VIEW_WEB,MF_BYCOMMAND | MF_GRAYED);
		 }

		 if ( ! (dwCurrentState & DATA_TO_SAVE))
		 {
					::EnableMenuItem(hMenu,IDM_EXPORT_LIST,MF_BYCOMMAND | MF_GRAYED);
					
		 }
		 if (! (dwCurrentState & OK_TO_PRINT))
					::EnableMenuItem(hMenu,ID_CONTEXTMENU_PRINT,MF_BYCOMMAND | MF_GRAYED);

		 
		 if ( dwCurrentState & STATE_VIEW_FILE)
		 {
			 ::CheckMenuItem(hMenu, IDM_VIEW_FILE, MF_BYCOMMAND|MF_CHECKED);
			 ::CheckMenuItem(hMenu, IDM_VIEW_HOTFIX, MF_BYCOMMAND|MF_UNCHECKED);
		 }
		 else
		 {
			 ::CheckMenuItem(hMenu, IDM_VIEW_HOTFIX, MF_BYCOMMAND|MF_CHECKED);
			 ::CheckMenuItem(hMenu, IDM_VIEW_FILE, MF_BYCOMMAND|MF_UNCHECKED);
		 }
		 
		TrackPopupMenu(   hMenu,
                  TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                  GET_X_LPARAM(lParam),
                  GET_Y_LPARAM(lParam),
                  0,
                  m_hWnd,
                  NULL);

		DestroyMenu(hMenuLoad);

		return 0;
	}

};


#endif //__HOTFIXOCX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\snapin\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__186FC3A7_559D_4DB6_9E45_F0CEAEF2D00C__INCLUDED_)
#define AFX_DLLDATAX_H__186FC3A7_559D_4DB6_9E45_F0CEAEF2D00C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__186FC3A7_559D_4DB6_9E45_F0CEAEF2D00C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\snapin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\snapin\hotfixmanager.cpp ===
// HotfixManager.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for HotfixManager.idl by adding the following 
//      files to the Outputs.
//          HotfixManager_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f HotfixManagerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "HotfixManager.h"
#include "dlldatax.h"

#include "HotfixManager_i.c"
#include "Hotfix_Manager.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Hotfix_Manager, CHotfix_Manager)
OBJECT_ENTRY(CLSID_Hotfix_ManagerAbout, CHotfix_ManagerAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
/*    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif */
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_HOTFIXMANAGERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
/*#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif */
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
/*#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif*/
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
/*#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif*/
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\snapin\hotfixmanager_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for hotfixmanager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_HOTFIXMANAGERLib,0x7CF18F93,0x72F5,0x44D1,0x99,0x06,0xDB,0xFA,0x6A,0x21,0x6B,0xE8);


MIDL_DEFINE_GUID(CLSID, CLSID_Hotfix_Manager,0xE810E1EB,0x6B52,0x45D0,0xAB,0x07,0xFB,0x4B,0x04,0x39,0x2A,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_Hotfix_ManagerAbout,0x4F0EBD75,0xDA9D,0x4D09,0x8A,0x2E,0x9A,0xF1,0xD6,0xE0,0x25,0x11);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for hotfixmanager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_HOTFIXMANAGERLib,0x7CF18F93,0x72F5,0x44D1,0x99,0x06,0xDB,0xFA,0x6A,0x21,0x6B,0xE8);


MIDL_DEFINE_GUID(CLSID, CLSID_Hotfix_Manager,0xE810E1EB,0x6B52,0x45D0,0xAB,0x07,0xFB,0x4B,0x04,0x39,0x2A,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_Hotfix_ManagerAbout,0x4F0EBD75,0xDA9D,0x4D09,0x8A,0x2E,0x9A,0xF1,0xD6,0xE0,0x25,0x11);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\snapin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Hotfix_Snapin.rc
//
#define UNINSTALL_OK                    1
#define HOTFIX_SELECTED                 2
#define IS_REMOTED                      4
#define DATA_TO_SAVE                    8
#define OK_TO_PRINT                     16
#define STATE_VIEW_FILE                 32
#define STATE_VIEW_HOTFIX               64
#define IDS_PROJNAME                    100
#define IDB_HOTFIXMANAGER_16            101
#define IDB_HOTFIXMANAGER_32            102
#define IDR_HOTFIXMANAGER_MENU          103
#define IDD_HOTFIXMANAGER               104
#define IDS_HOTFIXMANAGER_DESC          105
#define IDS_HOTFIXMANAGER_PROVIDER      106
#define IDS_HOTFIXMANAGER_VERSION       107
#define IDR_HOTFIXMANAGER               108
#define IDS_VIEW_BY_FILE                108
#define IDS_BY_FILE_STATUS_BAR          109
#define IDS_BY_KB_ARTICLE_STATUS_BAR    110
#define IDS_BY_KB_ARTICLE               111
#define IDS_UNINSTALL                   112
#define IDS_UNINSTALL_STATUS_BAR        113
#define IDS_VIEW_WEB                    114
#define IDS_VIEW_WEB_STATUS_BAR         115
#define IDS_PRINT_REPORT                116
#define IDS_PRINT_REPORT_STATUS_BAR     117
#define IDS_COLUMN_TYPE                 118
#define IDS_COLUMN_DESC                 119
#define IDS_DISPLAY_NAME                120
#define IDS_EXPORT                      121
#define IDS_EXPORT_STATUS_BAR           122
#define IDS_NO_ACCESS                   123
#define IDC_VIEW_WEB                    2000
#define IDC_VIEW_BY_FILE                2001
#define IDC_VIEW_BY_HOTFIX              2002
#define IDC_UNINSTALL                   2003
#define IDC_REFRESH                     2004
#define IDC_EXPORT                      2005
#define IDC_PRINT_REPORT                2006
#define ID_VIEW_BY_FILE                 32770
#define ID_VIEW_BY_KB                   32771
#define ID_VIEW_WEB                     32772
#define ID_PRINT_REPORT                 32773
#define ID_EXPORT                       32774
#define ID_UNINSTALL                    32775

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\snapin\hotfixmanager.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for hotfixmanager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __hotfixmanager_h__
#define __hotfixmanager_h__

/* Forward Declarations */ 

#ifndef __Hotfix_Manager_FWD_DEFINED__
#define __Hotfix_Manager_FWD_DEFINED__

#ifdef __cplusplus
typedef class Hotfix_Manager Hotfix_Manager;
#else
typedef struct Hotfix_Manager Hotfix_Manager;
#endif /* __cplusplus */

#endif 	/* __Hotfix_Manager_FWD_DEFINED__ */


#ifndef __Hotfix_ManagerAbout_FWD_DEFINED__
#define __Hotfix_ManagerAbout_FWD_DEFINED__

#ifdef __cplusplus
typedef class Hotfix_ManagerAbout Hotfix_ManagerAbout;
#else
typedef struct Hotfix_ManagerAbout Hotfix_ManagerAbout;
#endif /* __cplusplus */

#endif 	/* __Hotfix_ManagerAbout_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __HOTFIXMANAGERLib_LIBRARY_DEFINED__
#define __HOTFIXMANAGERLib_LIBRARY_DEFINED__

/* library HOTFIXMANAGERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HOTFIXMANAGERLib;

EXTERN_C const CLSID CLSID_Hotfix_Manager;

#ifdef __cplusplus

class DECLSPEC_UUID("E810E1EB-6B52-45D0-AB07-FB4B04392AB4")
Hotfix_Manager;
#endif

EXTERN_C const CLSID CLSID_Hotfix_ManagerAbout;

#ifdef __cplusplus

class DECLSPEC_UUID("4F0EBD75-DA9D-4D09-8A2E-9AF1D6E02511")
Hotfix_ManagerAbout;
#endif
#endif /* __HOTFIXMANAGERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\snapin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__ABD9AA5B_11DD_4A99_8030_DFD9F6C3701D__INCLUDED_)
#define AFX_STDAFX_H__ABD9AA5B_11DD_4A99_8030_DFD9F6C3701D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__ABD9AA5B_11DD_4A99_8030_DFD9F6C3701D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\snapin\hotfix_manager.h ===
#ifndef HOTFIX_MANAGER
#define HOTFIX_MANAGER

#include "resource.h"
#include <atlsnap.h>

static _TCHAR gszComputerName[255];
static BOOL ComputerNameSent = FALSE;
static  IDispatch* gszManagerCtlDispatch = NULL;
inline LPOLESTR CoTaskDupString( LPOLESTR pszInput )
{
	USES_CONVERSION;
	LPOLESTR pszOut = NULL;

	//
	// We throw an exception if the following allocation fails.
	//
	pszOut = (LPOLESTR) CoTaskMemAlloc( ( wcslen( pszInput ) + 1 ) * sizeof( OLECHAR ) );
	if ( pszOut == NULL )
		throw;

	wcscpy( pszOut, pszInput );

	return( pszOut );
};

template <class T>        
class ATL_NO_VTABLE ISnapinHelpImpl : public ISnapinHelp
{
public:

	// get the dkms help file location and returns it
	STDMETHOD( GetHelpTopic )( LPOLESTR* lpCompiledHelpFile )
	{
		_ASSERT( lpCompiledHelpFile != NULL );
		USES_CONVERSION;
		HRESULT hr = E_FAIL;
		TCHAR szPath[ _MAX_PATH * 2 ];

		// this is where the dkms help file is stored
	
		wcscpy(szPath,L"C:\\mmc-samples\\Hotfix_Snapin\\snapsamp.chm");
//		MessageBox(NULL,szPath,_T("Help File Path"),MB_OK);
		// expand out the %systemroot% variable
	//	ExpandEnvVars(szPath);

	//	MessageBox(NULL,szPath,_T("Help File Path"),MB_OK);
		// Allocate the string and return it.
		*lpCompiledHelpFile = CoTaskDupString( T2W( szPath ) );
		hr = S_OK;

		return( hr );
	}
};

class CHotfix_ManagerComponent;
class CHotfix_ManagerData : public CSnapInItemImpl<CHotfix_ManagerData>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	_TCHAR m_szComputerName[255];
	_TCHAR m_szCreation[255];
    bool m_bChild;
	bool b_Expanded;
	DWORD m_dwCurrentView;
	_TCHAR m_ProductName[255];
    CHotfix_ManagerComponent* m_pComponent;
	static BSTR m_bstrColumnType;
	static BSTR m_bstrColumnDesc;
	CComPtr<IControlbar> m_spControlBar;

	BEGIN_SNAPINCOMMAND_MAP(CHotfix_ManagerData, FALSE)
	END_SNAPINCOMMAND_MAP()

//	SNAPINMENUID(IDR_HOTFIXMANAGER_MENU)

	BEGIN_SNAPINTOOLBARID_MAP(CHotfix_ManagerData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

	CHotfix_ManagerData(_TCHAR * ProductName,_TCHAR * new_ComputerName, bool Child)
	{
		_TCHAR Messg[255];
		m_dwCurrentView = IDC_VIEW_BY_HOTFIX;
			m_bChild = Child;
			_tcscpy (m_szComputerName, new_ComputerName);
		b_Expanded = false;
				
	
		// Image indexes may need to be modified depending on the images specific to 
		// the snapin.
		// Image indexes may need to be modified depending on the images specific to 
		// the snapin.
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
		m_scopeDataItem.displayname = MMC_CALLBACK;
		m_scopeDataItem.nImage = 4; 		// May need modification
		m_scopeDataItem.nOpenImage = 5; 	// May need modification
		m_scopeDataItem.lParam = (LPARAM) this;
		memset(&m_resultDataItem, 4, sizeof(RESULTDATAITEM));
		m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
		m_resultDataItem.str = MMC_CALLBACK;
		m_resultDataItem.nImage = 4;		// May need modification
		m_resultDataItem.lParam = (LPARAM) this;

		if (ProductName == NULL)
		{
		LoadString(_Module.GetResourceInstance(),IDS_DISPLAY_NAME,Messg,255);
		_tcscpy(m_ProductName,_T("\0"));
		}
		else 
		{
			_tcscpy(Messg,ProductName);
			_tcscpy(m_ProductName,ProductName);
			
		}

		m_bstrDisplayName = SysAllocString(Messg);
			
		LoadString(_Module.GetResourceInstance(),IDS_COLUMN_TYPE,Messg,255);
		m_bstrColumnType = SysAllocString(Messg);
		
		LoadString(_Module.GetResourceInstance(),IDS_COLUMN_DESC,Messg,255);
		m_bstrColumnDesc = SysAllocString( Messg );

	}

	~CHotfix_ManagerData()
	{
	}

	STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);

		STDMETHOD( GetResultViewType )( LPOLESTR* ppViewType, long* pViewOptions );

	
	STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);

	STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
		long arg,
		long param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type);

	LPOLESTR GetResultPaneColInfo(int nCol);
	BOOL SendProductName(_TCHAR *szPoductName, IDispatch * pDisp);
	BOOL SendComputerName(_TCHAR *szDataMachineName,IDispatch * pDisp);



	BOOL SendCommand( LPARAM lparamCommand );
	
 
		STDMETHOD( Command )(long lCommandID,		
		CSnapInObjectRootBase* pObj,		
		DATA_OBJECT_TYPES type);

	STDMETHOD(AddMenuItems)(
	LPCONTEXTMENUCALLBACK pContextMenuCallback,
	long  *pInsertionAllowed,
	DATA_OBJECT_TYPES type); 


};

DWORD GetCtrlStatus();

class CHotfix_ManagerExtData : public CSnapInItemImpl<CHotfix_ManagerExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	BEGIN_SNAPINCOMMAND_MAP(CHotfix_ManagerExtData, FALSE)
	END_SNAPINCOMMAND_MAP()

//	SNAPINMENUID(IDR_HOTFIXMANAGER_MENU)

	BEGIN_SNAPINTOOLBARID_MAP(CHotfix_ManagerExtData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

	CHotfix_ManagerExtData()
	{
		m_pNode = NULL;
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CHotfix_ManagerExtData()
	{
			if ( m_pNode != NULL )
			delete m_pNode;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}
	STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
		long arg,
		long param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type);

    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		return( S_OK );
	}

protected:
		CSnapInItem* m_pNode;

};

class CHotfix_Manager;

class CHotfix_ManagerComponent : public CComObjectRootEx<CComSingleThreadModel>,
	public CSnapInObjectRoot<2, CHotfix_Manager >,
	public IExtendContextMenuImpl<CHotfix_Manager>,
//	public IExtendControlbarImpl<CHotfix_ManagerComponent>,
	public IPersistStreamInit,
	public IComponentImpl<CHotfix_ManagerComponent>
{
public:
BEGIN_COM_MAP(CHotfix_ManagerComponent)
	COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
 //   COM_INTERFACE_ENTRY(IExtendControlbar)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
END_COM_MAP()
//	SNAPINMENUID(IDR_HOTFIXMANAGER_MENU)
public:
	CHotfix_ManagerComponent()
	{
	}

		STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
	{
		//
		// Check for a special data object being sent.
		// Might be able to extract the computer name here....
		if ( IS_SPECIAL_DATAOBJECT( lpDataObject ) )
			return( S_OK );
		if (lpDataObject != NULL)
			return IComponentImpl<CHotfix_ManagerComponent>::Notify(lpDataObject, event, arg, param);
		// TODO : Add code to handle notifications that set lpDataObject == NULL.
		return E_NOTIMPL;
	}

	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACENOTIMPL(_T("CHotfix_ManagerComponent::GetClassID"));
	}	

	STDMETHOD(IsDirty)()
	{
		ATLTRACENOTIMPL(_T("CHotfix_ManagerComponent::IsDirty"));
	}

	STDMETHOD(Load)(IStream *pStm)
	{
		ATLTRACENOTIMPL(_T("CHotfix_ManagerComponent::Load"));
	}

	STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty)
	{
		ATLTRACENOTIMPL(_T("CHotfix_ManagerComponent::Save"));
	}

	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
	{
		ATLTRACENOTIMPL(_T("CHotfix_ManagerComponent::GetSizeMax"));
	}

	STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject);
	STDMETHOD(InitNew)()
	{
		ATLTRACE(_T("CHotfix_ManagerComponent::InitNew\n"));
		return S_OK;
	}
	STDMETHOD (AddMenuItems) (LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK piCallback,long *pInsertionAllowed);

};

class CHotfix_Manager : public CComObjectRootEx<CComSingleThreadModel>,
public CSnapInObjectRoot<1, CHotfix_Manager>,
	public IComponentDataImpl<CHotfix_Manager, CHotfix_ManagerComponent>,
	public IExtendControlbarImpl<CHotfix_Manager>,
	public IExtendContextMenuImpl<CHotfix_Manager>,
	public IPersistStreamInit,
	public ISnapinHelpImpl<CHotfix_Manager>,
	public CComCoClass<CHotfix_Manager, &CLSID_Hotfix_Manager>
{
public:
	CHotfix_Manager();

	bool IsRemoted()
	{
		return( m_fRemoted );
	}


	~CHotfix_Manager()
	{
		delete m_pNode;
		m_pNode = NULL;
	}

EXTENSION_SNAPIN_DATACLASS(CHotfix_ManagerExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CHotfix_Manager)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CHotfix_ManagerExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CHotfix_Manager)
	  COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_HOTFIXMANAGER)

DECLARE_NOT_AGGREGATABLE(CHotfix_Manager)

	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACENOTIMPL(_T("CHotfix_Manager::GetClassID"));
	}	

	STDMETHOD(IsDirty)()
	{
		ATLTRACENOTIMPL(_T("CHotfix_Manager::IsDirty"));
	}

	STDMETHOD(Load)(IStream *pStm)
	{
		ATLTRACENOTIMPL(_T("CHotfix_Manager::Load"));
	}

	STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty)
	{
		ATLTRACENOTIMPL(_T("CHotfix_Manager::Save"));
	}

	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
	{
		ATLTRACENOTIMPL(_T("CHotfix_Manager::GetSizeMax"));
	}


	STDMETHOD(InitNew)()
	{
		ATLTRACE(_T("CHotfix_Manager::InitNew\n"));
		return S_OK;
	}

	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}


	STDMETHOD(Notify)( LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

protected:
	_TCHAR m_szComputerName[255];
	bool ExtractString( IDataObject* pDataObject, unsigned int cfClipFormat, LPTSTR pBuf, DWORD dwMaxLength );
	//
	// Register the clipboard format and get the value to query on.
	//
	void RegisterRemotedClass()
	{
		m_ccfRemotedFormat = RegisterClipboardFormat( _T( "MMC_SNAPIN_MACHINE_NAME" ) );
		_ASSERTE( m_ccfRemotedFormat > 0 );
	}
	//
	// Determine if we're monitoring a local or remote machine based on the given data object.
	//
	bool IsDataObjectRemoted( IDataObject* pDataObject );
	//
	// Used to track whether we're remoted or not.
	//
	bool m_fRemoted;
	//
	// Initialized by RegisterRemoteClass(). Contains the clipboard ID
	// of MMC_SNAPIN_MACHINE_NAME after registered with the clipboard.
	//
	UINT m_ccfRemotedFormat;
};

class ATL_NO_VTABLE CHotfix_ManagerAbout : public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass< CHotfix_ManagerAbout, &CLSID_Hotfix_ManagerAbout>
{
public:
	DECLARE_REGISTRY(CHotfixManagerAbout, _T("Hotfix_ManagerAbout.1"), _T("Hotfix_ManagerAbout.1"), IDS_HOTFIXMANAGER_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CHotfix_ManagerAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_HOTFIXMANAGER_DESC, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_HOTFIXMANAGER_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_HOTFIXMANAGER_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = NULL;
		return S_OK;
	}

	STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
		HBITMAP *hSmallImageOpen,
		HBITMAP *hLargeImage,
		COLORREF *cMask)
	{
		*hSmallImageOpen = *hLargeImage = *hLargeImage = 0;
		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotfixmanager\snapin\hotfix_manager.cpp ===
#include "stdafx.h"
#include "HotfixManager.h"
#include "Hotfix_Manager.h"
#ifndef DNS_MAX_NAME_LENGTH
#define DNS_MAX_NAME_LENGTH 255
#endif

#define   REMOTE_STATE 0
#define   HOTFIX_STATE 1

static CRITICAL_SECTION CritSec;

BSTR CHotfix_ManagerData::m_bstrColumnType;
BSTR CHotfix_ManagerData::m_bstrColumnDesc;
static CComPtr<IDispatch> gpDisp = NULL;




/////////////////////////////////////////////////////////////////////////////
// CHotfix_ManagerComponentData
static const GUID CHotfix_ManagerGUID_NODETYPE = 
{ 0x2315305b, 0x3abe, 0x4c07, { 0xaf, 0x6e, 0x95, 0xdc, 0xa4, 0x82, 0x5b, 0xdd } };
const GUID*  CHotfix_ManagerData::m_NODETYPE = &CHotfix_ManagerGUID_NODETYPE;
const OLECHAR* CHotfix_ManagerData::m_SZNODETYPE = OLESTR("2315305B-3ABE-4C07-AF6E-95DCA4825BDD");
const OLECHAR* CHotfix_ManagerData::m_SZDISPLAY_NAME = OLESTR("Hotfix_Manager");
const CLSID* CHotfix_ManagerData::m_SNAPIN_CLASSID = &CLSID_Hotfix_Manager;

static const GUID CHotfix_ManagerExtGUID_NODETYPE = 
{ 0x476e6448, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*  CHotfix_ManagerExtData::m_NODETYPE = &CHotfix_ManagerExtGUID_NODETYPE;
const OLECHAR* CHotfix_ManagerExtData::m_SZNODETYPE = OLESTR("476e6448-aaff-11d0-b944-00c04fd8d5b0");
const OLECHAR* CHotfix_ManagerExtData::m_SZDISPLAY_NAME = OLESTR("Hotfix_Manager");
const CLSID* CHotfix_ManagerExtData::m_SNAPIN_CLASSID = &CLSID_Hotfix_Manager;



CHotfix_Manager::CHotfix_Manager()
	{
	
		
	
		DWORD dwSize = 255;
		GetComputerName(m_szComputerName,&dwSize);
		InitializeCriticalSection(&CritSec);
//		m_pNode = new CHotfix_ManagerData(NULL ,m_szComputerName, FALSE);
//		_ASSERTE(m_pNode != NULL);
		m_pComponentData = this;
		RegisterRemotedClass();
	}
HRESULT CHotfix_ManagerData::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
	if (pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if (pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if (pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if (pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if (pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;

	// TODO : Add code for SDI_CHILDREN 
	if (pScopeDataItem->mask & SDI_CHILDREN )
		pScopeDataItem->cChildren = 0;
	return S_OK;
}

HRESULT CHotfix_ManagerData::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
	if (pResultDataItem->bScopeItem)
	{
		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if (pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if (pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if (pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if (pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if (pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}
HRESULT CHotfix_Manager::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
	HRESULT hr = E_UNEXPECTED;

	if (lpDataObject != NULL)
	{
			switch ( event )
			{
			
			case MMCN_EXPAND:
				{
					//
					// Process out the local or machine name if we're expanding.
					//
					if (arg == TRUE)
						{
						
						
							
							if (	ExtractString( lpDataObject,  m_ccfRemotedFormat, m_szComputerName, DNS_MAX_NAME_LENGTH + 1 ) )
							{
								if (!_tcscmp (m_szComputerName,_T("\0")))
								{
									DWORD dwSize = 255;
									GetComputerName(m_szComputerName,&dwSize);
								}
									
								
							}
							else
							{
								DWORD dwSize = 255;
								GetComputerName(m_szComputerName,&dwSize);
							}
						
						if (	_tcscmp (gszComputerName, m_szComputerName) )
						{
//								MessageBox (NULL,_T("Setting Computername sent to false"), _T("Main Data Notify"),MB_OK);
							ComputerNameSent = FALSE;
							_tcscpy (gszComputerName,m_szComputerName);
							
						
						}
					//
					// Intentionally left to fall through to default handler.
					//
				}
					
				}
				default:
				{
					//
					// Call our default handling.
					//
					hr = IComponentDataImpl<CHotfix_Manager, CHotfix_ManagerComponent>::Notify( lpDataObject, event, arg, param );
				}
			}
	}
	return( hr );
}

HRESULT CHotfix_ManagerData::Notify( MMC_NOTIFY_TYPE event,
    long arg,
    long param,
	IComponentData* pComponentData,
	IComponent* pComponent,
	DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.
	HRESULT hr = E_NOTIMPL;

	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComPtr<IConsole> spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
	if (pComponentData != NULL)
		spConsole = ((CHotfix_Manager*)pComponentData)->m_spConsole;
	else
	{
		spConsole = ((CHotfix_ManagerComponent*)pComponent)->m_spConsole;
		spHeader = spConsole;
	}

	switch (event)
	{
	case MMCN_INITOCX:
		{
//		MessageBox(NULL,_T("Recieved init OCX"),NULL,MB_OK);
		CComQIPtr<IDispatch,&IID_IDispatch> pDisp = (IUnknown *) param;
		gpDisp = pDisp;
//		MessageBox(NULL,m_szComputerName,_T("Init Ocx Sending"),MB_OK);
		SendComputerName(m_szComputerName, gpDisp);
//		MessageBox(NULL,_T("Setting ComputerNameSent to TRUE"),_T("ManagerData::Notify"),MB_OK);
		ComputerNameSent = TRUE;
		break;
		}

/*	case MMCN_CONTEXTHELP:
		{
			CComQIPtr<IDisplayHelp,&IID_IDisplayHelp> spHelp = spConsole;
			spHelp->ShowTopic(CoTaskDupString(OLESTR("snapsamp.chm::/default.htm")));
			hr = S_OK;
		}
		break;
*/
	case MMCN_SHOW:
		{
			
			if (arg == TRUE)
			{
				
				IUnknown *pUnk;
				if (gpDisp == NULL)
				{
					CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
					spConsole->QueryResultView(&pUnk);
					CComQIPtr<IDispatch,&IID_IDispatch> pDisp = pUnk;
					gpDisp = pDisp;
				}
				EnterCriticalSection(&CritSec);

				if (!ComputerNameSent)
				{
						SendComputerName(m_szComputerName,gpDisp);
//						MessageBox(NULL,_T("Setting SentComputerName to TRUE:"), _T("ManagerData::Notify, Show"), MB_OK);
						ComputerNameSent = TRUE;
//					MessageBox(NULL,m_szComputerName,_T("Show Sending"),MB_OK);
				}
				LeaveCriticalSection(&CritSec);
				EnterCriticalSection(&CritSec);
					SendProductName(m_ProductName,gpDisp);
				LeaveCriticalSection(&CritSec);

			}
			hr = S_OK;
			break;
		}
	case MMCN_EXPAND:
		{
			HKEY hKLM = NULL;
	        HKEY hKey = NULL;
			DWORD dwProductIndex = 0;
			_TCHAR szProductName[255];
			DWORD dwBufferSize = 255;

			if (arg == TRUE)
			{
				gszManagerCtlDispatch = (IDispatch *) NULL;
				//SendProductName(m_ProductName);
			
				if ( !m_bChild)
				{

				
					if (!ComputerNameSent)
					{
//						MessageBox(NULL,_T("Expand Determining New ComputerName"),NULL,MB_OK);
//				        MessageBox(NULL,m_szComputerName,gszComputerName,MB_OK);
					
					    //_tcscpy(m_szComputerName,gszComputerName);
					
						b_Expanded = FALSE;
					}
					
				}
				if (  ( !m_bChild) && (!b_Expanded))
				{
					b_Expanded =TRUE;
				// open the updates registry key and enumerate the children
//				MessageBox(NULL,m_szComputerName,_T("Expand Connecting to "),MB_OK);
				RegConnectRegistry(m_szComputerName,HKEY_LOCAL_MACHINE,&hKLM);
				if (hKLM != NULL)
				{
					RegOpenKeyEx(hKLM,_T("SOFTWARE\\MICROSOFT\\UPDATES"),0,KEY_READ,&hKey);
					if (hKey != NULL)
					{
						dwProductIndex = 0;
						while (RegEnumKeyEx(hKey, dwProductIndex,szProductName, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
						{
							CSnapInItem* m_pNode;
							CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
							// TODO : Enumerate scope pane items
							SCOPEDATAITEM *pScopeData;
							
//							MessageBox(NULL,szProductName,_T("Creating node"),MB_OK);
//							MessageBox(NULL, m_szComputerName,_T("With computer Name"),MB_OK);
							m_pNode = new CHotfix_ManagerData( szProductName,m_szComputerName, TRUE);
							m_pNode->GetScopeData( &pScopeData );
							pScopeData->cChildren = 0;
							pScopeData->relativeID = param;
							spConsoleNameSpace->InsertItem( pScopeData );

							_tcscpy(szProductName,_T("\0"));
							++dwProductIndex;
							dwBufferSize = 255;
						}
						RegCloseKey(hKey);
						RegCloseKey(hKLM);
					}
				}
//				SendProductName(m_ProductName);
				}
			
				//gf_NewComputer = FALSE;
		
			hr = S_OK;
			}
			break;
		}
	case MMCN_ADD_IMAGES:
		{
			// Add Images
			IImageList* pImageList = (IImageList*) arg;
			hr = E_FAIL;
			// Load bitmaps associated with the scope pane
			// and add them to the image list
			// Loads the default bitmaps generated by the wizard
			// Change as required
			HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_HOTFIXMANAGER_16));
			if (hBitmap16 != NULL)
			{
				HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_HOTFIXMANAGER_32));
				if (hBitmap32 != NULL)
				{
					hr = pImageList->ImageListSetStrip((long*)hBitmap16, 
					(long*)hBitmap32, 0, RGB(0, 128, 128));
					if (FAILED(hr))
						ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
				}
			}
			break;
		}
	}
	return hr;
}

LPOLESTR CHotfix_ManagerData::GetResultPaneColInfo(int nCol)
{
	//if (nCol == 0)
	//	return m_bstrDisplayName;
		LPOLESTR pStr = NULL;

	switch ( nCol )
	{
	case 0:
		pStr = m_bstrDisplayName;
		break;

	case 1:
		pStr = m_bstrColumnType;
		break;

	case 2:
		pStr = m_bstrColumnDesc;
		break;
	}

	_ASSERTE( pStr != NULL );
	return( pStr );
	// TODO : Return the text for other columns
//	return OLESTR("Override GetResultPaneColInfo");
}

HRESULT CHotfix_Manager::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CHotfix_Manager, CHotfix_ManagerComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_HOTFIXMANAGER_16));
	if (hBitmap16 == NULL)
		return S_OK;

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_HOTFIXMANAGER_32));
	if (hBitmap32 == NULL)
		return S_OK;

	if (spImageList->ImageListSetStrip((long*)hBitmap16, 
		(long*)hBitmap32, 0, RGB(0, 128, 128)) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}
	return S_OK;
}


//
// Retrieves the value of a given clipboard format from a given data object.
//
bool CHotfix_Manager::ExtractString( IDataObject* pDataObject, unsigned int cfClipFormat, LPTSTR pBuf, DWORD dwMaxLength)
{
    USES_CONVERSION;
	bool fFound = false;
    FORMATETC formatetc = { (CLIPFORMAT) cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    stgmedium.hGlobal = ::GlobalAlloc( GMEM_SHARE, dwMaxLength  * sizeof(TCHAR));
    HRESULT hr;

	do 
    {
		//
		// This is a memory error condition!
		//
        if ( NULL == stgmedium.hGlobal )
			break;

        hr = pDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
            break;

        LPWSTR pszNewData = reinterpret_cast<LPWSTR>( ::GlobalLock( stgmedium.hGlobal ) );
        if ( NULL == pszNewData )
            break;

        pszNewData[ dwMaxLength - 1 ] = L'\0';
        _tcscpy( pBuf, OLE2T( pszNewData ) );
		fFound = true;
    } 
	while( false );

    if ( NULL != stgmedium.hGlobal )
    {
        GlobalUnlock( stgmedium.hGlobal );
        GlobalFree( stgmedium.hGlobal );
    }
    _tcscpy (gszComputerName, pBuf);
	return( fFound );
}

//
// Determines if the enumeration is for a remoted machine or not.
//

bool CHotfix_Manager::IsDataObjectRemoted( IDataObject* pDataObject )
{
bool fRemoted = false;
    TCHAR szComputerName[ DNS_MAX_NAME_LENGTH + 1 ];
    DWORD dwNameLength = (DNS_MAX_NAME_LENGTH + 1) * sizeof(TCHAR);
	TCHAR szDataMachineName[ DNS_MAX_NAME_LENGTH + 1 ];

	//
	// Get local computer name.
	//
    GetComputerName(szComputerName, &dwNameLength);

	//
	// Get the machine name from the given data object.
	//
    if ( ExtractString( pDataObject,  m_ccfRemotedFormat, szDataMachineName, DNS_MAX_NAME_LENGTH + 1 ) )
	{
		_toupper( szDataMachineName );

		//
		// Find the start of the server name.
		//
		LPTSTR pStr = szDataMachineName;
		while ( pStr && *pStr == L'\\' )
			pStr++;

		//
		// Compare the server name.
		//
		if ( pStr && *pStr && wcscmp( pStr, szComputerName ) != 0 )
			fRemoted = true;
	}

	if (fRemoted)
		_tcscpy (m_szComputerName, szDataMachineName);
	else
		_tcscpy (m_szComputerName, szComputerName);
	return( fRemoted );
}

STDMETHODIMP  CHotfix_ManagerData::GetResultViewType ( LPOLESTR* ppViewType, long* pViewOptions )
{

	
	
		*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS; 

	*ppViewType = _T("{883B970F-690C-45F2-8A3A-F4283E078118}");
	 return S_OK;
}

/////////////////////////////////////////////////////
//
// Dispatch interface of the OCX  to send commands
//
/////////////////////////////////////////////////////
BOOL CHotfix_ManagerData::SendComputerName(_TCHAR *szDataMachineName, IDispatch * pDisp)
{
		HRESULT hr;


	// Ensure that we have a pointer to the  OCX
	if (pDisp == NULL ){
//		MessageBox(NULL,_T("Failed to send Message"),NULL,MB_OK);
			return( FALSE );
	}

	// get the  OCX dispatch interface
	CComPtr<IDispatch> pManagerCtlDispatch = pDisp;

	// get the ID of the "ComputerName" interface
	OLECHAR FAR* szMember = TEXT("ComputerName");  // maps this to "put_Command()"

	DISPID dispid;
	hr = pManagerCtlDispatch->GetIDsOfNames(
			IID_NULL,			// Reserved for future use. Must be IID_NULL.
			&szMember,			// Passed-in array of names to be mapped.
			1,					// Count of the names to be mapped.
			LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
			&dispid);			// Caller-allocated array

	if (!SUCCEEDED(hr)) {
//		MessageBox(NULL,_T("Failed to send Message"),NULL,MB_OK);
		return FALSE;
	}

	DISPID mydispid = DISPID_PROPERTYPUT;
	VARIANTARG* pvars = new VARIANTARG;
	

	VariantInit(&pvars[0]);
	BSTR NewVal( szDataMachineName);
	
	pvars[0].vt = VT_BSTR;
//	pvars[0].iVal = (short)lparamCommand;
	pvars[0].bstrVal = NewVal;
	DISPPARAMS disp = { pvars, &mydispid, 1, 1 };

	hr = pManagerCtlDispatch->Invoke(
			dispid, 				// unique number identifying the method to invoke
			IID_NULL,				// Reserved. Must be IID_NULL
			LOCALE_USER_DEFAULT,	// A locale ID
			DISPATCH_PROPERTYPUT,	// flag indicating the context of the method to invoke
			&disp,					// A structure with the parameters to pass to the method
			NULL,					// The result from the calling method
			NULL,					// returned exception information
			NULL);					// index indicating the first argument that is in error

	delete [] pvars;

	if (!SUCCEEDED(hr)) {
//		MessageBox(NULL,_T("Failed to send Message"),NULL,MB_OK);
		return FALSE;
	}
//	MessageBox(NULL,_T("Message sent"),NULL,MB_OK);
	return TRUE;
}

DWORD GetCtrlStatus()
{
		DISPID dispid;
	HRESULT hr;
	DWORD Status = 0;

	if ( gpDisp == NULL)
		return FALSE;
	// array of the interface names
	OLECHAR FAR* szMember[1] = {
		OLESTR("CurrentState")
	};
	
	hr = gpDisp->GetIDsOfNames(
			IID_NULL,			// Reserved for future use. Must be IID_NULL.
			&szMember[0],			// Passed-in array of names to be mapped.
			1/*INTERFACE_COUNT*/,					// Count of the names to be mapped.
			LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
			&dispid);			// Caller-allocated array (see help for details)

	if (!SUCCEEDED(hr)) {
//		MessageBox(NULL,_T("Failed to get Dispatch pointer"),NULL,MB_OK);
	
		return FALSE;
	}

	VARIANT varResult;
	VariantInit(&varResult);
	V_VT(&varResult) = VT_I2;
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

	hr = gpDisp->Invoke(
			dispid, 				// unique number identifying the method to invoke
			IID_NULL,				// Reserved. Must be IID_NULL
			LOCALE_USER_DEFAULT,	// A locale ID
			DISPATCH_PROPERTYGET,	// flag indicating the context of the method to invoke
			&dispparamsNoArgs,		// A structure with the parameters to pass to the method
			&varResult, 			// The result from the calling method
			NULL,					// returned exception information
			NULL);					// index indicating the first argument that is in error

		if (!SUCCEEDED(hr)) {
//			MessageBox(NULL,_T("Failed To Get Value"),NULL,MB_OK);
		return FALSE;
	}
		
//	 return  varResult.bVal;

	Status = varResult.lVal;
	//delete [] pvars;



	_TCHAR Message[100];
	_stprintf(Message,_T("%d"),Status);
//	MessageBox(NULL, Message, _T("Returned Status"),MB_OK);
	return Status;
	
}
BOOL CHotfix_ManagerData::SendProductName(_TCHAR *szProductName, IDispatch * pDisp)
{
		HRESULT hr;

	if ( pDisp == NULL ){
			return( FALSE );
	}

	// get the OCX dispatch interface
	CComPtr<IDispatch> pManagerCtlDispatch = pDisp;

	// get the ID of the "ComputerName" interface
	OLECHAR FAR* szMember = TEXT("ProductName");  // maps this to "put_Command()"

	DISPID dispid;
	hr = pManagerCtlDispatch->GetIDsOfNames(
			IID_NULL,			// Reserved for future use. Must be IID_NULL.
			&szMember,			// Passed-in array of names to be mapped.
			1,					// Count of the names to be mapped.
			LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
			&dispid);			// Caller-allocated array

	if (!SUCCEEDED(hr)) {
	//	MessageBox(NULL,_T("Failed to send Message"),NULL,MB_OK);
		return FALSE;
	}

	DISPID mydispid = DISPID_PROPERTYPUT;
	VARIANTARG* pvars = new VARIANTARG;
	

	VariantInit(&pvars[0]);
	BSTR NewVal( szProductName);
	
	pvars[0].vt = VT_BSTR;
//	pvars[0].iVal = (short)lparamCommand;
	pvars[0].bstrVal = NewVal;
	DISPPARAMS disp = { pvars, &mydispid, 1, 1 };

	hr = pManagerCtlDispatch->Invoke(
			dispid, 				// unique number identifying the method to invoke
			IID_NULL,				// Reserved. Must be IID_NULL
			LOCALE_USER_DEFAULT,	// A locale ID
			DISPATCH_PROPERTYPUT,	// flag indicating the context of the method to invoke
			&disp,					// A structure with the parameters to pass to the method
			NULL,					// The result from the calling method
			NULL,					// returned exception information
			NULL);					// index indicating the first argument that is in error

	delete [] pvars;

	if (!SUCCEEDED(hr)) {
		
		return FALSE;
	}

	return TRUE;
}
BOOL CHotfix_ManagerData::SendCommand(LPARAM lparamCommand)
{
	HRESULT hr;

	// Ensure that we have a pointer to the  OCX
	if ( gpDisp == NULL ){
			return( FALSE );
	}

	// get the OCX dispatch interface
	CComPtr<IDispatch> pManagerCtlDispatch = gpDisp;

	// get the ID of the "Command" interface
	OLECHAR FAR* szMember = TEXT("Command");  // maps this to "put_Command()"

	DISPID dispid;
	hr = pManagerCtlDispatch->GetIDsOfNames(
			IID_NULL,			// Reserved for future use. Must be IID_NULL.
			&szMember,			// Passed-in array of names to be mapped.
			1,					// Count of the names to be mapped.
			LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
			&dispid);			// Caller-allocated array

	if (!SUCCEEDED(hr)) {
		return FALSE;
	}

	DISPID mydispid = DISPID_PROPERTYPUT;
	VARIANTARG* pvars = new VARIANTARG;
	

	VariantInit(&pvars[0]);

	pvars[0].vt = VT_I2;
	pvars[0].iVal = (short)lparamCommand;
	DISPPARAMS disp = { pvars, &mydispid, 1, 1 };

	hr = pManagerCtlDispatch->Invoke(
			dispid, 				// unique number identifying the method to invoke
			IID_NULL,				// Reserved. Must be IID_NULL
			LOCALE_USER_DEFAULT,	// A locale ID
			DISPATCH_PROPERTYPUT,	// flag indicating the context of the method to invoke
			&disp,					// A structure with the parameters to pass to the method
			NULL,					// The result from the calling method
			NULL,					// returned exception information
			NULL);					// index indicating the first argument that is in error

	delete [] pvars;

	if (!SUCCEEDED(hr)) {
		
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////
// IExtendContextMenu::Command()
STDMETHODIMP CHotfix_ManagerData::Command(long lCommandID,		
		CSnapInObjectRootBase* pObj,		
		DATA_OBJECT_TYPES type)
{
	// Handle each of the commands.
	switch (lCommandID) {

	case ID_VIEW_BY_FILE:
//		MessageBox(NULL,_T("Sending View By File"),NULL,MB_OK);
		SendCommand(IDC_VIEW_BY_FILE);
		m_dwCurrentView = IDC_VIEW_BY_FILE;
		break;

	case ID_VIEW_BY_KB:
		SendCommand(IDC_VIEW_BY_HOTFIX);
		m_dwCurrentView = IDC_VIEW_BY_HOTFIX;
		break;

	case ID_UNINSTALL:
		SendCommand(IDC_UNINSTALL);
		break;

	case ID_VIEW_WEB:
		SendCommand(IDC_VIEW_WEB);
		break;

	case ID_PRINT_REPORT:
		SendCommand(IDC_PRINT_REPORT);
		break;
	case ID_EXPORT:
		SendCommand(IDC_EXPORT);
		break;



	default:
		break;
	}

	return S_OK;
}

HRESULT CHotfix_ManagerExtData::Notify( MMC_NOTIFY_TYPE event,
	long arg,
	long param,
	IComponentData* pComponentData,
	IComponent* pComponent,
	DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.

	HRESULT hr = E_NOTIMPL;
	bool fRemoted = false;

	_ASSERTE( pComponentData != NULL || pComponent != NULL );

	CComPtr<IConsole> spConsole;

	if ( pComponentData != NULL )
	{
		CHotfix_Manager* pExt = (CHotfix_Manager*) pComponentData;
		spConsole = pExt->m_spConsole;

		//
		// Determine if we're remoted.
		//
		fRemoted = pExt->IsRemoted();
	}
	else
	{
		spConsole = ( (CHotfix_ManagerComponent*) pComponent )->m_spConsole;
	}

	switch ( event )
	{
	case MMCN_SHOW:
		arg = arg;
		hr = S_OK;
		break;
	case MMCN_EXPAND:
		{
			if ( arg == TRUE )
			{
				CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
				SCOPEDATAITEM* pScopeData;
				DWORD dwSize = 255;
				if (!_tcscmp(gszComputerName,_T("\0")))
					GetComputerName(gszComputerName,&dwSize);
				m_pNode = new CHotfix_ManagerData( NULL,gszComputerName, FALSE);
				m_pNode->GetScopeData( &pScopeData );
				pScopeData->relativeID = param;
				spConsoleNameSpace->InsertItem( pScopeData );

				if ( pComponentData )
					( (CHotfix_Manager*) pComponentData )->m_pNode = m_pNode;  
			}
			
			hr = S_OK;
			break;
		}
	case MMCN_REMOVE_CHILDREN:
		{
			//
			// We are not deleting this node since this same pointer is
			// stashed in the pComponentData in response to the MMCN_EXPAND
			// notification. The destructor of pComponentData deletes the pointer
			// to this node.
			//
			//delete m_pNode;
			m_pNode = NULL;
			hr = S_OK;
			break;
		} 
		case MMCN_ADD_IMAGES:
		{
		}
	
	}  
 
	return S_OK; 
}

STDMETHODIMP CHotfix_ManagerComponent::Command(long lCommandID, LPDATAOBJECT pDataObject)
{
	HRESULT hr;

	if ( IS_SPECIAL_DATAOBJECT( pDataObject ) )
	{
		hr = m_pComponentData->m_pNode->Command( lCommandID, this, CCT_RESULT );
	}
	else
	{
		hr = IExtendContextMenuImpl<CHotfix_Manager>::Command( lCommandID, pDataObject );
	}

	return( hr );
}

STDMETHODIMP CHotfix_ManagerData::AddMenuItems(
	LPCONTEXTMENUCALLBACK pContextMenuCallback,
	long  *pInsertionAllowed,
	DATA_OBJECT_TYPES type)
{

	DWORD Status = GetCtrlStatus();
		HRESULT hr = S_OK;

	// Note - snap-ins need to look at the data object and determine
	// in what context, menu items need to be added. They must also
	// observe the insertion allowed flags to see what items can be 
	// added.
	/* handy comment:
	typedef struct	_CONTEXTMENUITEM
		{
		LPWSTR strName;
		LPWSTR strStatusBarText;
		LONG lCommandID;
		LONG lInsertionPointID;
		LONG fFlags;
		LONG fSpecialFlags;
		}	CONTEXTMENUITEM;
	*/
	CONTEXTMENUITEM singleMenuItem;
	TCHAR menuText[200];
	TCHAR statusBarText[300];

	singleMenuItem.strName = menuText;
	singleMenuItem.strStatusBarText = statusBarText;
	singleMenuItem.fFlags = 0;
	singleMenuItem.fSpecialFlags = 0;

    // Add each of the items to the Action menu
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) {

		// setting for the Action menu
		singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
		singleMenuItem.lCommandID = ID_VIEW_WEB;
		if (Status & HOTFIX_SELECTED)
			singleMenuItem.fFlags = MF_ENABLED;
		else
			singleMenuItem.fFlags = MF_GRAYED;
		LoadString(_Module.GetResourceInstance(), IDS_VIEW_WEB, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_VIEW_WEB_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr = pContextMenuCallback->AddItem(&singleMenuItem);

	
		singleMenuItem.lCommandID = ID_UNINSTALL;
		if (Status & UNINSTALL_OK)
			singleMenuItem.fFlags = MF_ENABLED;
		else
			singleMenuItem.fFlags = MF_GRAYED;

		LoadString(_Module.GetResourceInstance(), IDS_UNINSTALL, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_UNINSTALL_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr = pContextMenuCallback->AddItem(&singleMenuItem);


		if (Status & DATA_TO_SAVE)
		{
			singleMenuItem.lCommandID = ID_EXPORT;
			singleMenuItem.fFlags = MF_ENABLED;
			LoadString(_Module.GetResourceInstance(), IDS_EXPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
			LoadString(_Module.GetResourceInstance(), IDS_EXPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
			hr = pContextMenuCallback->AddItem(&singleMenuItem);

			
			singleMenuItem.lCommandID = ID_PRINT_REPORT;
			singleMenuItem.fFlags = MF_ENABLED;
			LoadString(_Module.GetResourceInstance(), IDS_PRINT_REPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
			LoadString(_Module.GetResourceInstance(), IDS_PRINT_REPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
			hr = pContextMenuCallback->AddItem(&singleMenuItem);
		}
		else
		{
			singleMenuItem.lCommandID = ID_EXPORT;
			singleMenuItem.fFlags = MF_GRAYED;
			LoadString(_Module.GetResourceInstance(), IDS_EXPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
			LoadString(_Module.GetResourceInstance(), IDS_EXPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
			hr = pContextMenuCallback->AddItem(&singleMenuItem);

			
			singleMenuItem.lCommandID = ID_PRINT_REPORT;
			singleMenuItem.fFlags = MF_GRAYED;
			LoadString(_Module.GetResourceInstance(), IDS_PRINT_REPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
			LoadString(_Module.GetResourceInstance(), IDS_PRINT_REPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
			hr = pContextMenuCallback->AddItem(&singleMenuItem);
		}

	}


    return S_OK;
	
}


STDMETHODIMP CHotfix_ManagerComponent::AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK piCallback,long *pInsertionAllowed)
{
	HRESULT hr;

	if ( IS_SPECIAL_DATAOBJECT( pDataObject ) )
	{
			
	}
	else
	{
		CONTEXTMENUITEM singleMenuItem;
	TCHAR menuText[200];
	TCHAR statusBarText[300];
    DWORD State = GetCtrlStatus();
	
	//
	// Retrieve the control from the current component.
	//
//	assert( m_pComponent != NULL );
//	CComPtr<IDispatch> spDispCtl = m_pComponent->GetControl();
    
	singleMenuItem.strName = menuText;
	singleMenuItem.strStatusBarText = statusBarText;
	singleMenuItem.fFlags = 0;
	singleMenuItem.fSpecialFlags = 0;

    // Add each of the items to the Action menu
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
	{
	
		singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		singleMenuItem.lCommandID = ID_VIEW_BY_KB ;
		if ( State & STATE_VIEW_HOTFIX)
			singleMenuItem.fFlags = MF_CHECKED;
		else
			singleMenuItem.fFlags = MF_UNCHECKED; 
		LoadString(_Module.GetResourceInstance(), IDS_BY_KB_ARTICLE, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_BY_KB_ARTICLE_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr = piCallback->AddItem(&singleMenuItem);
		// setting for the Action menu
		singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		singleMenuItem.lCommandID = ID_VIEW_BY_FILE;
		if ( State & STATE_VIEW_FILE )
			singleMenuItem.fFlags = MF_CHECKED ;
		else
			singleMenuItem.fFlags = MF_UNCHECKED ;  
		LoadString(_Module.GetResourceInstance(), IDS_VIEW_BY_FILE, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_BY_FILE_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr =  piCallback->AddItem(&singleMenuItem);

			hr = IExtendContextMenuImpl<CHotfix_Manager>::AddMenuItems( pDataObject, piCallback, pInsertionAllowed );
			// setting for the Action menu
	/*	singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
		singleMenuItem.lCommandID = IDM_VIEW_WEB;
		if (HaveHotfix)
			singleMenuItem.fFlags = MF_ENABLED;
		else
			singleMenuItem.fFlags = MF_GRAYED;
		LoadString(_Module.GetResourceInstance(), IDS_VIEW_WEB, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_VIEW_WEB_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr = piCallback->AddItem(&singleMenuItem);

	//	singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		singleMenuItem.lCommandID = IDM_UNINSTALL;
//		singleMenuItem.fFlags = analyzeFlags;
		if ((!Remote) && (HaveHotfix))
			singleMenuItem.fFlags = MF_ENABLED;
		else
			singleMenuItem.fFlags = MF_GRAYED;

		LoadString(_Module.GetResourceInstance(), IDS_UNINSTALL, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_UNINSTALL_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr =  piCallback->AddItem(&singleMenuItem);

	//	singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		singleMenuItem.lCommandID = IDM_GENERATE_REPORT;
		singleMenuItem.fFlags = MF_ENABLED;
		LoadString(_Module.GetResourceInstance(), IDS_GENERATE_REPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_GENERATE_REPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr =  piCallback->AddItem(&singleMenuItem); */
	} 
//	hr = m_pComponentData->m_pNode->AddMenuItems( piCallback, pInsertionAllowed, CCT_RESULT );
	}
	


	return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hsplit\hsglobal.c ===
/****************************** Module Header ******************************\
* Module Name: hsglobals.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/06/96 GerardoB Created
\***************************************************************************/
#include "hsplit.h"

/***************************************************************************\
* Globals
\***************************************************************************/
/*
 * Files
 */
char * gpszInputFile = NULL;
HANDLE ghfileInput;
char * gpszPublicFile = NULL;
HANDLE ghfilePublic;
char * gpszInternalFile = NULL;
HANDLE ghfileInternal;

PHSEXTRACT gpExtractFile = NULL;

/*
 * Map file
 */
HANDLE ghmap;
char * gpmapStart;
char * gpmapEnd;

/*
 * Switches et al
 */
DWORD gdwOptions = 0;
DWORD gdwVersion = LATEST_WIN32_WINNT_VERSION;
char gszVerifyVersionStr [11];
DWORD gdwFilterMask = HST_DEFAULT;
char * gpszTagMarker = ";";
DWORD gdwTagMarkerSize = 1;
char gszMarkerCharAndEOL [] = ";" "\r";

DWORD gdwLineNumber = 0;

/*
 * Compatibility tags. Specify size so sizeof operator can be used to
 *  determine strlen at compile time
 */
char gsz35 [3] = "35";
char gszCairo [6] = "cairo";
char gszChicago [8] = "chicago";
char gszNashville [10] = "nashville";
char gszNT [3] = "NT";
char gszSur [4] = "sur";
char gszSurplus [8] = "surplus";
char gszWin40 [6] = "win40";
char gszWin40a [7] = "win40a";

/*
 * Predefined tags table (ghst).
 * begin-end are special tags that use HST_ bits but are not included in
 *  this table (because they must be the first tag afer the marker)
 * All other tags are user defined through the command line (-t?); up to
 *  32 - HST_MASKBITCOUNT user defined tags are allowed.
 *
 * Size is specified so sizeof operator work fine
 */

HSTAG ghstPredefined [16] = {
    /*
     * Headers - output file
     */
    {HSLABEL(public),   HST_PUBLIC},
    {HSLABEL(internal), HST_INTERNAL},
    {HSLABEL(both),     HST_BOTH},
    {HSLABEL($),        HST_SKIP},
    {HSLABEL(only),     HST_EXTRACTONLY},

    /*
     * Old tags used with all old switches
     */
    {HSLABEL(winver),                         HST_WINVER | HST_MAPOLD},
    {HSCSZSIZE(gszCairo),      gszCairo,      HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszChicago),    gszChicago,    HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszNashville),  gszNashville,  HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszNT),         gszNT,         HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszSur),        gszSur,        HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszSurplus),    gszSurplus,    HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszWin40),      gszWin40,      HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszWin40a),     gszWin40a,     HST_SKIP | HST_MAPOLD},
    
    /*
     * if tags.
     */
    {HSLABEL(if), HST_IF},

    {0, NULL, 0}
};

PHSTAG gphst = ghstPredefined;

DWORD gdwLastTagMask = HST_LASTMASK;

/*
 * Block stack
 */
HSBLOCK ghsbStack [HSBSTACKSIZE];
PHSBLOCK gphsbStackTop = ghsbStack;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hotpatch\test\patch.c ===
/*

Copyright (c) 2000  Microsoft Corporation

File name:

    patch.c
   
Author:
    
    Adrian Marinescu (adrmarin)  Wed Nov 14 2001

*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sfc.h>  
#include <psapi.h>

//
//  Global constants
//

#define PATCH_OC_INSTALL        1
#define PATCH_OC_UNINSTALL      2
#define PATCH_OC_REPLACE_FILE   3

ULONG OperationCode = 0;


//
//  System file protection utilities
//

typedef HANDLE (WINAPI *CONNECTTOSFCSERVER)(PCWSTR);
typedef DWORD  (WINAPI *SFCFILEEXCEPTION)(HANDLE, PCWSTR, DWORD);
typedef VOID (WINAPI * SFCCLOSE)(HANDLE);

SFCFILEEXCEPTION pSfcFileException = NULL;
CONNECTTOSFCSERVER pConnectToSfcServer = NULL;
SFCCLOSE pSfcClose = NULL;

HANDLE
LoadSfcLibrary()
{
    HANDLE hLibSfc;

    hLibSfc = LoadLibrary("SFC.DLL");

    if ( hLibSfc != NULL ) {

        pConnectToSfcServer = (CONNECTTOSFCSERVER)GetProcAddress( hLibSfc, (LPCSTR)0x00000003 );
        pSfcClose = (SFCCLOSE)GetProcAddress( hLibSfc, (LPCSTR)0x00000004 );
        pSfcFileException = (SFCFILEEXCEPTION)GetProcAddress( hLibSfc, (LPCSTR)0x00000005 );
    }

    return hLibSfc;
}


NTSTATUS
RemoveKnownDll (
               PWSTR FileName
               )
{
    WCHAR Buffer[DOS_MAX_PATH_LENGTH + 1];
    int BytesCopied;
    UNICODE_STRING Unicode;

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Section;


    BytesCopied = _snwprintf( Buffer, 
                              DOS_MAX_PATH_LENGTH,
                              L"\\KnownDlls\\%ws",                              
                              FileName );

    if ( BytesCopied < 0 ) {

        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlInitUnicodeString(&Unicode, Buffer);

    //
    // open the section object
    //

    InitializeObjectAttributes (&Obja,
                                &Unicode,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = NtOpenSection (&Section,
                            SECTION_ALL_ACCESS,
                            &Obja);

    if ( !NT_SUCCESS(Status) ) {

        printf("%ws is not a known dll\n", FileName);

        return Status;
    }

    printf("%ws is a known dll. Deleting ...\n", FileName);

    Status = NtMakeTemporaryObject(Section);

    if ( !NT_SUCCESS(Status) ) {

        printf("NtMakeTemporaryObject failed with status %lx\n", Status);

    }

    NtClose(Section);

    return Status;
}


NTSTATUS
RemoveDelayedRename(
                   IN PUNICODE_STRING OldFileName,
                   IN PUNICODE_STRING NewFileName,
                   IN ULONG Index
                   )

/*++

Routine Description:

    Appends the given delayed move file operation to the registry
    value that contains the list of move file operations to be
    performed on the next boot.

Arguments:

    OldFileName - Supplies the old file name

    NewFileName - Supplies the new file name

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    HANDLE KeyHandle;
    PWSTR ValueData, s;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;
    ULONG ValueLength = 1024;
    ULONG ReturnedLength;
    WCHAR ValueNameBuf[64];
    NTSTATUS Status;

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );

    if ( Index == 1 ) {
        RtlInitUnicodeString( &ValueName, L"PendingFileRenameOperations" );
    } else {
        swprintf(ValueNameBuf,L"PendingFileRenameOperations%d",Index);
        RtlInitUnicodeString( &ValueName, ValueNameBuf );
    }

    InitializeObjectAttributes(
                              &Obja,
                              &KeyName,
                              OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    Status = NtCreateKey( &KeyHandle,
                          GENERIC_READ | GENERIC_WRITE,
                          &Obja,
                          0,
                          NULL,
                          0,
                          NULL
                        );
    if ( Status == STATUS_ACCESS_DENIED ) {
        Status = NtCreateKey( &KeyHandle,
                              GENERIC_READ | GENERIC_WRITE,
                              &Obja,
                              0,
                              NULL,
                              REG_OPTION_BACKUP_RESTORE,
                              NULL
                            );
    }

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    while ( TRUE ) {
        ValueInfo = RtlAllocateHeap(RtlProcessHeap(),
                                    0,
                                    ValueLength);

        if ( ValueInfo == NULL ) {
            NtClose(KeyHandle);
            return(STATUS_NO_MEMORY);
        }

        //
        // File rename operations are stored in the registry in a
        // single MULTI_SZ value. This allows the renames to be
        // performed in the same order that they were originally
        // requested. Each rename operation consists of a pair of
        // NULL-terminated strings.
        //

        Status = NtQueryValueKey(KeyHandle,
                                 &ValueName,
                                 KeyValuePartialInformation,
                                 ValueInfo,
                                 ValueLength,
                                 &ReturnedLength);

        if ( Status != STATUS_BUFFER_OVERFLOW ) {
            break;
        }

        //
        // The existing value is too large for our buffer.
        // Retry with a larger buffer.
        //
        ValueLength = ReturnedLength;
        RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
    }

    if ( NT_SUCCESS(Status) ) {
        //
        // A value already exists, append our two strings to the
        // MULTI_SZ.
        //
        ValueData = (PWSTR)(&ValueInfo->Data);
        s = (PWSTR)((PCHAR)ValueData + ValueInfo->DataLength) - 1;

        while ( ValueData < s ) {

            UNICODE_STRING CrtString;
            PWSTR Base;
            ULONG RemovedBytes;
            Base = ValueData;

            RtlInitUnicodeString(&CrtString, ValueData);
            RemovedBytes = CrtString.Length + sizeof(WCHAR);

            if ( RtlEqualUnicodeString( &CrtString,
                                        OldFileName,
                                        TRUE ) ) {

                ValueData += CrtString.Length / sizeof(WCHAR) + 1;

                RtlInitUnicodeString(&CrtString, ValueData + 1);

                if ( RtlEqualUnicodeString( &CrtString,
                                            NewFileName,
                                            TRUE ) ) {

                    RemovedBytes += CrtString.Length + 2 * sizeof(WCHAR);  //  NULL + !
                    printf("Removing delayed entry %ws -> %ws\n", Base, ValueData);

                    ValueData += CrtString.Length / sizeof(WCHAR) + 1;
                    MoveMemory(Base, ValueData, (ULONG_PTR)s - (ULONG_PTR)ValueData);

                    printf("Deleting delayed rename key (%ld bytes left)\n", (ULONG)ValueInfo->DataLength - RemovedBytes);

                    Status = NtSetValueKey(KeyHandle,
                                           &ValueName,
                                           0,
                                           REG_MULTI_SZ,
                                           &ValueInfo->Data,
                                           (ULONG)ValueInfo->DataLength - RemovedBytes);

                    break;
                }
            } else {

                ValueData += CrtString.Length / sizeof(WCHAR) + 1;
            }
        }

    } else {
        NtClose(KeyHandle);
        RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
        return(Status);
    }

    NtClose(KeyHandle);
    RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);

    return(Status);
}


NTSTATUS
ReplaceSystemFile(
                 PWSTR TargetPath,
                 PWSTR ReplacedFileName,
                 PWSTR ReplacementFile
                 )
{
    WCHAR FullOriginalName[DOS_MAX_PATH_LENGTH + 1];
    WCHAR TmpReplacementFile[DOS_MAX_PATH_LENGTH + 1];
    WCHAR TmpOrigName[DOS_MAX_PATH_LENGTH + 1];

    int BytesCopied;
    UNICODE_STRING ReplacedUnicodeString, NewUnicodeString, TempOrigFile; 
    HANDLE hSfp;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    HANDLE ReplacedFileHandle = NULL, NewFileHandle = NULL;
    PFILE_RENAME_INFORMATION RenameInfo1 = NULL, RenameInfo2 = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD Result;
    ULONG i;
    int ThreadPriority;

    RtlInitUnicodeString(&ReplacedUnicodeString, NULL);
    RtlInitUnicodeString(&NewUnicodeString, NULL);

    BytesCopied = _snwprintf( FullOriginalName, 
                              DOS_MAX_PATH_LENGTH,
                              L"%ws\\%ws",
                              TargetPath, 
                              ReplacedFileName );

    if ( BytesCopied < 0 ) {

        return STATUS_BUFFER_TOO_SMALL;
    }

    if ( !RtlDosPathNameToNtPathName_U(
                                      FullOriginalName,
                                      &ReplacedUnicodeString,
                                      NULL,
                                      NULL
                                      ) ) {
        printf("RtlDosPathNameToNtPathName_U failed\n");

        Status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    //
    //  Open the target file and keep a handle opened to it
    //

    InitializeObjectAttributes (&ObjectAttributes,
                                &ReplacedUnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = NtOpenFile( &ReplacedFileHandle,
                         SYNCHRONIZE | DELETE | FILE_GENERIC_READ,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if ( !NT_SUCCESS(Status) ) {

        printf( "Opening the \"%ws\" file failed %lx (IOStatus = %lx)\n", 
                FullOriginalName, 
                Status, 
                IoStatus);

        goto cleanup;
    }

    //
    //  If a knowndll file, then remove it from the system known dll directory
    //

    Status = RemoveKnownDll( ReplacedFileName );

    if ( !NT_SUCCESS(Status) &&
         (Status != STATUS_OBJECT_NAME_NOT_FOUND) ) {

        printf( "Removing the KnownDll entry for \"%ws\" failed %lx\n", 
                ReplacedFileName, 
                Status);

        goto cleanup;
    }

    //
    // Unprotect the replaced file
    //

    hSfp = (pConnectToSfcServer)( NULL );

    if ( hSfp ) {

        if ( SfcIsFileProtected(hSfp, FullOriginalName) ) {

            printf("Replacing protected file \"%ws\"\n", FullOriginalName);

            Result = (pSfcFileException)(
                                        hSfp,
                                        (PWSTR) FullOriginalName,
                                        (DWORD) -1
                                        );
            if ( Result != NO_ERROR ) {
                printf("Unprotect file \"%ws\" failed, ec = %d\n", FullOriginalName, Result);

                (pSfcClose)(hSfp);

                Status = STATUS_UNSUCCESSFUL;
                goto cleanup;
            }

        } else {

            printf("Replacing unprotected file \"%ws\"\n", FullOriginalName);
        }

        (pSfcClose)(hSfp);

    } else {

        printf("SfcConnectToServer failed\n");

        Status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    if ( GetTempFileNameW(TargetPath, L"HOTP", 0, TmpReplacementFile) == 0 ) {

        printf("GetTempFileNameW failed\n");

        Status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    if ( !DeleteFileW(TmpReplacementFile) ) {

        printf("DeleteFile \"%ws\" failed with error %ld\n", TmpReplacementFile, GetLastError());

        Status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    if ( !CopyFileW ( ReplacementFile, 
                      TmpReplacementFile,
                      TRUE ) ) {

        printf("CopyFileW \"%ws\" failed with error %ld\n", TmpReplacementFile, GetLastError());

        Status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    if ( !RtlDosPathNameToNtPathName_U(
                                      TmpReplacementFile,
                                      &NewUnicodeString,
                                      NULL,
                                      NULL
                                      ) ) {

        printf("RtlDosPathNameToNtPathName_U failed\n");

        Status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    //
    //  Open the new file and keep a handle opened to it
    //

    InitializeObjectAttributes (&ObjectAttributes,
                                &NewUnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = NtOpenFile( &NewFileHandle,
                         SYNCHRONIZE | DELETE | FILE_GENERIC_READ,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if ( !NT_SUCCESS(Status) ) {

        printf("Opening the temporary file \"%ws\" failed %lx (IOStatus = %lx)\n", TmpReplacementFile, Status, IoStatus);

        goto cleanup;
    }

    //
    //  Prepare the rename info for the original file
    //  It will be a temporary
    //

    if ( GetTempFileNameW(TargetPath, L"HPO", 0, TmpOrigName) == 0 ) {

        printf("GetTempFileNameW failed\n");

        Status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    if ( !DeleteFileW(TmpOrigName) ) {

        printf("DeleteFile \"%ws\" failed with error %ld\n", TmpOrigName, GetLastError());

        Status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    if ( !RtlDosPathNameToNtPathName_U(
                                      TmpOrigName,
                                      &TempOrigFile,
                                      NULL,
                                      NULL
                                      ) ) {
        printf("RtlDosPathNameToNtPathName_U failed\n");

        Status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }


    RenameInfo1 = RtlAllocateHeap( RtlProcessHeap(), 
                                   0, 
                                   TempOrigFile.Length+sizeof(*RenameInfo1));

    if ( RenameInfo1 == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

        goto cleanup;
    }

    RtlCopyMemory( RenameInfo1->FileName, TempOrigFile.Buffer, TempOrigFile.Length );

    RenameInfo1->ReplaceIfExists = TRUE;
    RenameInfo1->RootDirectory = NULL;
    RenameInfo1->FileNameLength = TempOrigFile.Length;

    RenameInfo2 = RtlAllocateHeap( RtlProcessHeap(), 
                                   0, 
                                   ReplacedUnicodeString.Length+sizeof(*RenameInfo2));

    if ( RenameInfo2 == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

        goto cleanup;
    }

    RtlCopyMemory( RenameInfo2->FileName, ReplacedUnicodeString.Buffer, ReplacedUnicodeString.Length );

    RenameInfo2->ReplaceIfExists = TRUE;
    RenameInfo2->RootDirectory = NULL;
    RenameInfo2->FileNameLength = ReplacedUnicodeString.Length;

    //
    //  We have everything set to do the two rename operations. However if
    //  the machine crashes before the second rename operation the system may not recover at boot
    //  We queue a delayed rename so smss will do the job at next boot. If we succeed,
    //  then smss will not find the file so it will skip that step.  
    //

    if ( !MoveFileExW( TmpReplacementFile, 
                       FullOriginalName, 
                       MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT) ) {

        //
        //  We cannot queue the rename operation, so we cannot recover if
        //  the machine crashes between the two renames below. Better refuse to apply the patch
        //

        printf("Failed to queue the rename operation for the temporary file (%ld)\n", GetLastError());

        Status =  STATUS_UNSUCCESSFUL;

        goto cleanup;
    }



    ThreadPriority = GetThreadPriority(GetCurrentThread());

    if ( !SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL) ) {

        printf("SetThreadPriority failed\n");
    }

    Status = NtSetInformationFile( ReplacedFileHandle,
                                   &IoStatus,
                                   RenameInfo1,
                                   TempOrigFile.Length+sizeof(*RenameInfo1),
                                   FileRenameInformation);

    if ( !NT_SUCCESS(Status) ) {

        printf("NtSetInformationFile failed for the original file %lx  %lx\n", Status, IoStatus);

        goto cleanup;
    }

    Status = NtSetInformationFile( NewFileHandle,
                                   &IoStatus,
                                   RenameInfo2,
                                   ReplacedUnicodeString.Length+sizeof(*RenameInfo1),
                                   FileRenameInformation);

    if ( !NT_SUCCESS(Status) ) {

        printf("NtSetInformationFile failed for the new file %lx (IOStatus %lx). Restoring the original.\n", Status, IoStatus);

        //
        //  Restore the original file
        //

        Status = NtSetInformationFile( ReplacedFileHandle,
                                       &IoStatus,
                                       RenameInfo2,
                                       ReplacedUnicodeString.Length+sizeof(*RenameInfo1),
                                       FileRenameInformation);

        goto cleanup;
    }

    if ( !SetThreadPriority(GetCurrentThread(), ThreadPriority) ) {

        printf("Restoring the thread priority failed\n");
    }

    if ( NT_SUCCESS(Status) ) {

        for ( i = 0; i < 3; i++ ) {

            Status = RemoveDelayedRename( &NewUnicodeString, 
                                          &ReplacedUnicodeString, 
                                          i );
            if ( NT_SUCCESS(Status) ) {
                break;
            }
        }
    }

    if ( ReplacedFileHandle ) {
        NtClose(ReplacedFileHandle);
    }

    if ( NewFileHandle ) {
        NtClose(NewFileHandle);
    }

    if ( !DeleteFileW(TmpOrigName) ) {

        printf("Queueing the temp file deletion for \"%ws\" \n", TmpOrigName);

        //
        //  Detele the temporary file after next reboot
        //

        if ( !MoveFileExW( TmpOrigName, 
                           NULL, 
                           MOVEFILE_DELAY_UNTIL_REBOOT) ) {

            //
            //  We cannot queue the delete operation operation
            //

            printf("Failed to queue the delete operation for the temporary file (%ld)\n", GetLastError());

            Status =  STATUS_UNSUCCESSFUL;

            goto cleanup;
        }

        Status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    cleanup:

    if ( RenameInfo1 ) {

        RtlFreeHeap( RtlProcessHeap(), 0, RenameInfo1 );
    }

    if ( RenameInfo2 ) {

        RtlFreeHeap( RtlProcessHeap(), 0, RenameInfo2 );
    }

    RtlFreeUnicodeString(&NewUnicodeString);
    RtlFreeUnicodeString(&ReplacedUnicodeString);

    return Status;
}

BOOL
PSTRToUnicodeString(
                   OUT PUNICODE_STRING UnicodeString,
                   IN LPCSTR lpSourceString
                   )
/*++

Routine Description:

    Captures and converts a 8-bit (OEM or ANSI) string into a heap-allocated
    UNICODE string

Arguments:

    UnicodeString - location where UNICODE_STRING is stored

    lpSourceString - string in OEM or ANSI

Return Value:

    TRUE if string is correctly stored, FALSE if an error occurred.  In the
    error case, the last error is correctly set.

--*/

{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    //
    //  Convert input into dynamic unicode string
    //

    RtlInitString( &AnsiString, lpSourceString );
    RtlAnsiStringToUnicodeString(UnicodeString, &AnsiString, TRUE);

    return TRUE;
}

BOOLEAN
InitializeAsDebugger(VOID)
{

    HANDLE              Token;
    PTOKEN_PRIVILEGES   NewPrivileges;
    BYTE                OldPriv[1024];
    PBYTE               pbOldPriv;
    ULONG               cbNeeded;
    BOOLEAN             bRet = FALSE;
    LUID                LuidPrivilege, LoadDriverPrivilege;
    DWORD PID = 0;

    //
    // Make sure we have access to adjust and to get the old token privileges
    //

    if ( !OpenProcessToken( GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                            &Token) ) {

        printf("Cannot open process token %ld\n", GetLastError());
        return( FALSE );

    }

    cbNeeded = 0;

    //
    // Initialize the privilege adjustment structure
    //

    LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &LuidPrivilege );
    LookupPrivilegeValue(NULL, SE_LOAD_DRIVER_NAME, &LoadDriverPrivilege );

    NewPrivileges = (PTOKEN_PRIVILEGES)calloc( 1,
                                               sizeof(TOKEN_PRIVILEGES) +
                                               (2 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if ( NewPrivileges == NULL ) {

        CloseHandle(Token);
        return( bRet );
    }

    NewPrivileges->PrivilegeCount = 2;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    NewPrivileges->Privileges[1].Luid = LoadDriverPrivilege;
    NewPrivileges->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    pbOldPriv = OldPriv;
    bRet = (BOOLEAN)AdjustTokenPrivileges( Token,
                                           FALSE,
                                           NewPrivileges,
                                           1024,
                                           (PTOKEN_PRIVILEGES)pbOldPriv,
                                           &cbNeeded );

    if ( !bRet ) {

        //
        // If the stack was too small to hold the privileges
        // then allocate off the heap
        //

        printf("AdjustTokenPrivileges returned %ld\n", GetLastError());

        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {

            pbOldPriv = calloc(1,cbNeeded);
            if ( pbOldPriv == NULL ) {
                CloseHandle(Token);
                return( bRet);
            }

            bRet = (BOOLEAN)AdjustTokenPrivileges( Token,
                                                   FALSE,
                                                   NewPrivileges,
                                                   cbNeeded,
                                                   (PTOKEN_PRIVILEGES)pbOldPriv,
                                                   &cbNeeded );
        } else {

            printf("Cannot adjust token privileges %ld\n", GetLastError());
        }
    }

    CloseHandle( Token );
    return(bRet);
}

void Usage ()
{
    printf("Usage:\n");
    
    printf("    patch -k [-i|-u] pach_file\n");
    printf("        Apply a patch to a system driver.\n");
    printf("            -i Enable patch\n");
    printf("            -u Disable patch\n\n");
        
    
    printf("    patch -i pach_file [PID|image_name]\n");
    printf("        Apply a patch to a process.\n");
    printf("        If Image name is missing, all existing processes will be patched.\n\n");
    
    printf("    patch -u pach_file [PID|image_name] \n");
    printf("        Uninstall an existing patch.\n");
    printf("        If Image name is missing, all existing processes will be patched.\n\n");
    
    printf("    patch -r TargetPath TargetBinary SourcePath\n");
    printf("        Replaces the TargetPath\\TargetBinary with SourcePath\n");
    printf("        \n");
    printf("    \n");
}


PVOID
MapPatchFile(
            HANDLE ProcessHandle,
            LPCTSTR wPatchName,
            ULONG PatchFlags
            )
{
    PSYSTEM_HOTPATCH_CODE_INFORMATION RemoteInfo;
    SYSTEM_HOTPATCH_CODE_INFORMATION LocaLRemoteInfo;
    CANSI_STRING AnsiString;

    WCHAR Buffer[1024];
    SIZE_T Size;

    UNICODE_STRING DestinationString;

    DestinationString.Buffer = Buffer;
    DestinationString.Length = 0;
    DestinationString.MaximumLength = sizeof(Buffer);

    RtlInitAnsiString(&AnsiString, wPatchName);

    RtlAnsiStringToUnicodeString(
                                &DestinationString,
                                &AnsiString,
                                FALSE
                                );

    RemoteInfo = VirtualAllocEx( ProcessHandle, 
                                 NULL,
                                 4096 * 16,
                                 MEM_RESERVE | MEM_COMMIT,
                                 PAGE_READWRITE);

    if ( RemoteInfo == NULL ) {

        printf("VirtualAllocEx failed %ld\n", GetLastError());

        return NULL;
    }

    LocaLRemoteInfo.Flags = PatchFlags | FLG_HOTPATCH_NAME_INFO;
    LocaLRemoteInfo.NameInfo.NameLength = DestinationString.Length;
    LocaLRemoteInfo.NameInfo.NameOffset = sizeof(LocaLRemoteInfo);
    LocaLRemoteInfo.InfoSize = LocaLRemoteInfo.NameInfo.NameLength + LocaLRemoteInfo.NameInfo.NameOffset;


    if ( !WriteProcessMemory(ProcessHandle,
                             RemoteInfo,
                             &LocaLRemoteInfo,
                             sizeof(LocaLRemoteInfo),
                             &Size) ) {

        printf("Write process memory failed %ld\n", GetLastError());

        return NULL;
    }


    if ( !WriteProcessMemory(ProcessHandle,
                             (RemoteInfo + 1),
                             DestinationString.Buffer,
                             DestinationString.Length + sizeof(LocaLRemoteInfo),
                             &Size) ) {

        printf("Write process memory failed %ld\n", GetLastError());

        return NULL;
    }

    return RemoteInfo;

}


PSYSTEM_HOTPATCH_CODE_INFORMATION
InitializeKernelPatchData(
                         LPCTSTR wPatchName,
                         ULONG PatchFlags
                         )
{
    PSYSTEM_HOTPATCH_CODE_INFORMATION KernelPatch;
    CANSI_STRING AnsiString;

    WCHAR Buffer[1024];
    SIZE_T Size;

    UNICODE_STRING DestinationString;

    DestinationString.Buffer = Buffer;
    DestinationString.Length = 0;
    DestinationString.MaximumLength = sizeof(Buffer);

    RtlInitAnsiString(&AnsiString, wPatchName);

    RtlAnsiStringToUnicodeString(
                                &DestinationString,
                                &AnsiString,
                                FALSE
                                );

    if ( !RtlDosPathNameToNtPathName_U(
                                      Buffer,
                                      &DestinationString,
                                      NULL,
                                      NULL
                                      ) ) {

        printf("RtlDosPathNameToNtPathName_U failed\n");

        return NULL;
    }


    KernelPatch = malloc(sizeof(SYSTEM_HOTPATCH_CODE_INFORMATION) + DestinationString.Length);

    if ( KernelPatch == NULL ) {

        printf("Not enough memory\n");

        RtlFreeUnicodeString(&DestinationString);
        return NULL;
    }

    KernelPatch->Flags = PatchFlags | FLG_HOTPATCH_NAME_INFO;
    KernelPatch->NameInfo.NameOffset = sizeof(SYSTEM_HOTPATCH_CODE_INFORMATION);
    KernelPatch->NameInfo.NameLength = DestinationString.Length;
    KernelPatch->InfoSize = sizeof(SYSTEM_HOTPATCH_CODE_INFORMATION) + DestinationString.Length;

    memcpy( (KernelPatch + 1), DestinationString.Buffer, DestinationString.Length);

    RtlFreeUnicodeString(&DestinationString);

    return KernelPatch;
}
 

int ApplyPatchToProcess(
                       DWORD PID,
                       PCHAR PatchFile)
{

    DWORD ThreadId;
    HANDLE ProcessHandle = NULL;
    HANDLE RemoteThread = NULL;
    PVOID ThreadParam = NULL;
    HANDLE PortHandle = NULL;
    HMODULE NtDllHandle;
    LPTHREAD_START_ROUTINE PatchRoutine;
    DWORD ExitStatus;
    NTSTATUS Status;

    //
    //  User mode patch
    //

    ProcessHandle = OpenProcess( PROCESS_QUERY_INFORMATION |
                                 PROCESS_VM_OPERATION |
                                 PROCESS_CREATE_THREAD |
                                 PROCESS_VM_WRITE |
                                 PROCESS_VM_READ,
                                 FALSE, 
                                 PID );

    if ( ProcessHandle == NULL ) {

        printf("Cannot open process. Error %ld\n", GetLastError());
        return EXIT_FAILURE;
    }

    ThreadParam = MapPatchFile( ProcessHandle,
                                PatchFile,
                                ((OperationCode == PATCH_OC_INSTALL) ? 1 : 0)
                              );

    if ( ThreadParam == NULL ) {

        return EXIT_FAILURE;
    }

    NtDllHandle = GetModuleHandle("ntdll.dll");

    if ( NtDllHandle == NULL ) {

        printf("Cannot get ntdll.dll handle\n");

        return EXIT_FAILURE;
    }

    PatchRoutine = (LPTHREAD_START_ROUTINE)GetProcAddress(NtDllHandle, "LdrHotPatchRoutine");

    if ( PatchRoutine == NULL ) {

        printf("Cannot get LdrHotPatchRoutine\n");

        return EXIT_FAILURE;
    }

    //
    //  Use the Rtl version of create remote thread since the win32 version
    //  does not work cross-session
    //

    Status = RtlCreateUserThread (ProcessHandle,
                                  NULL,
                                  FALSE,
                                  0,
                                  0,
                                  0,
                                  (PUSER_THREAD_START_ROUTINE) PatchRoutine,
                                  ThreadParam,
                                  &RemoteThread,
                                  NULL);

    if (!NT_SUCCESS (Status)) {

        printf("Cannot create user thread. Error %ld\n", GetLastError());

        VirtualFreeEx( ProcessHandle, 
                       ThreadParam,
                       0,
                       MEM_RELEASE
                     );
        return EXIT_FAILURE;
    }

    WaitForSingleObject(RemoteThread, INFINITE);

    VirtualFreeEx( ProcessHandle, 
                   ThreadParam,
                   0,
                   MEM_RELEASE
                 );

    if ( GetExitCodeThread(RemoteThread, &ExitStatus) ) {

        if ( ExitStatus ) {

            printf("Error 0x%lx\n", ExitStatus);
        } else {
            
            printf("OK\n");
        }
    }

    return EXIT_SUCCESS;
}

BOOLEAN
UpdateProcessList(PCHAR ProcName,
                  PCHAR PatchFile)
{
    DWORD  CrtSize, cbNeeded, cProcesses;
    PDWORD aProcesses;
    DWORD i;

    CrtSize = cbNeeded = 1  * sizeof(DWORD);

    aProcesses = malloc(CrtSize);

    if ( aProcesses == NULL ) {

        exit(EXIT_FAILURE);
    }

    for ( ;; ) {

        if ( !EnumProcesses( aProcesses, CrtSize, &cbNeeded ) )
            return FALSE;

        if ( CrtSize > cbNeeded ) {

            break;
        }

        free(aProcesses);

        CrtSize = cbNeeded + 1024;

        aProcesses = malloc(CrtSize);

        if ( aProcesses == NULL ) {

            exit(EXIT_FAILURE);
        }
    }


    // Calculate how many process identifiers were returned.

    cProcesses = cbNeeded / sizeof(DWORD);

    // Print the name and process identifier for each process.

    for ( i = 0; i < cProcesses; i++ ) {

        char szProcessName[MAX_PATH] = "";
        DWORD processID = aProcesses[i];


        // Get a handle to the process.

        HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
                                       PROCESS_VM_READ,
                                       FALSE, processID );

        // Get the process name.

        if ( hProcess ) {
            HMODULE hMod;
            DWORD cbNeeded;

            if ( EnumProcessModules( hProcess, &hMod, sizeof(hMod), &cbNeeded) ) {

                GetModuleBaseName( hProcess, hMod, szProcessName, 
                                   sizeof(szProcessName) );

                if ( (ProcName == NULL)
                     ||
                     _stricmp(szProcessName, ProcName) == 0 ) {

                    printf("Patching %s : ", szProcessName);

                    ApplyPatchToProcess(processID, PatchFile);
                    
                }
            }

            CloseHandle( hProcess );
        }
    }

    return TRUE;
}

int __cdecl main (int argc, char ** argv)
{
    LONG i;
    DWORD id;
    DWORD PID;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PCHAR PatchFile = NULL;
    BOOLEAN KernelPatch = FALSE;
    char * ProgramName = NULL;

    //
    //  By default the tool instals the patch
    //

    OperationCode = 0;
    PID = 0;


    for ( i = 1; i < argc; i++ ) {
        PCHAR CrtArg = argv[i];

        if ( *CrtArg == '-' ) {
            CrtArg++;

            switch ( toupper(*CrtArg) ) {
                case 'I':
                    if ( OperationCode != 0 ) {
                        printf("Invalid argument %s\n", CrtArg);
                        exit(0);
                    }
                    OperationCode = PATCH_OC_INSTALL;
                    break;
                case 'U':
                    if ( OperationCode != 0 ) {
                        printf("Invalid argument %s\n", CrtArg);
                        exit(0);
                    }
                    OperationCode = PATCH_OC_UNINSTALL;
                    break;

                case 'K':
                    KernelPatch = TRUE;
                    break;

                case 'R':
                    if ( OperationCode != 0 ) {
                        printf("Invalid argument %s\n", CrtArg);
                        exit(0);
                    }
                    OperationCode = PATCH_OC_REPLACE_FILE;
                    break;

                default:
                    Usage();
                    return EXIT_FAILURE;
            }
        } else {

            if ( KernelPatch ) {

                PatchFile = CrtArg;

            } else {

                if ( PatchFile == NULL ) {

                    PatchFile = CrtArg;

                } else {
                    sscanf(CrtArg, "%ld", &PID);

                    if ( !PID ) {

                        ProgramName = CrtArg;
                        //printf("Program %s\n", CrtArg);
                    }
                }
            }
        }
    }

    if (OperationCode == 0) {
        
        Usage();
        return EXIT_FAILURE;
    }

    if ( OperationCode == PATCH_OC_REPLACE_FILE ) {

        //
        //  Replace a binary file to a target path
        //

        HANDLE SfcLibrary;


        if ( argc <= 4 ) {

            Usage();
            return EXIT_FAILURE;
        }

        SfcLibrary = LoadSfcLibrary();

        if ( SfcLibrary ) {

            UNICODE_STRING p1, p2, p3;

            PSTRToUnicodeString(&p1, argv[2]);
            PSTRToUnicodeString(&p2, argv[3]);
            PSTRToUnicodeString(&p3, argv[4]);

            ReplaceSystemFile(p1.Buffer, p2.Buffer, p3.Buffer);

            FreeLibrary(SfcLibrary);

            if ( _stricmp(argv[3], "ntdll.dll") == 0 ) {

                SYSTEM_HOTPATCH_CODE_INFORMATION KernelPatch;
                NTSTATUS Status;

                printf("Replacing system ntdll.dll section\n");

                if ( !InitializeAsDebugger() ) {

                    printf("Cannot initialize as debugger\n");
                    return EXIT_FAILURE;
                }

                KernelPatch.Flags = FLG_HOTPATCH_RELOAD_NTDLL;

                Status = NtSetSystemInformation( SystemHotpatchInformation, 
                                                 (PVOID)&KernelPatch, 
                                                 sizeof(KernelPatch) + 100
                                               );

                if ( !NT_SUCCESS(Status) ) {

                    printf("SystemHotpatchInformation failed with %08lx\n", Status);
                }
            }
        }
    } else {

        if ( !InitializeAsDebugger() ) {

            printf("Cannot initialize as debugger\n");
            return EXIT_FAILURE;
        }

        if ( KernelPatch ) {

            PSYSTEM_HOTPATCH_CODE_INFORMATION KernelPatchData = 
            InitializeKernelPatchData( PatchFile,
                                       ((OperationCode == PATCH_OC_INSTALL) ? 1 : 0)
                                     );


            if ( KernelPatchData == NULL ) {

                return EXIT_FAILURE;
            }

            KernelPatchData->Flags |= FLG_HOTPATCH_KERNEL;

            Status = NtSetSystemInformation( SystemHotpatchInformation, 
                                             (PVOID)KernelPatchData, 
                                             KernelPatchData->InfoSize
                                           );

            free(KernelPatchData);

            if ( !NT_SUCCESS(Status) ) {

                printf("Patching kernel driver failed with status 0x%lx\n", Status);
                return EXIT_FAILURE;
            }

            return EXIT_SUCCESS;

        } else {

            //
            //  Use-mode patching.
            //

            if ( PID != 0 ) {

                return ApplyPatchToProcess(PID, PatchFile);
            }

            return UpdateProcessList( ProgramName,
                                      PatchFile);
        }
    }

    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hsplit\hsparse.c ===
/****************************** Module Header ******************************\
* Module Name: hsparse.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/05/96 GerardoB Created
\***************************************************************************/
#include "hsplit.h"
/***************************************************************************\
* Globals
\***************************************************************************/
/*
 * #if - #endif strings
 * Compatibility: no space after #if and ( -- breaks wcshdr.exe
 */
static char gszIfStart [] = "\r\n#if(" ;
static char gszIfStop [] = ")";
static char gszDefCompOperator [] = ">=";
static char gszLessThan [] = "<";
static char gszEndStart [] = "\r\n#endif /* ";
static char gszEndStop [] = " */";

static char gszNewLine [] = "\r\n";
/*********************************************************************
* hsWriteNewLine
\***************************************************************************/
__inline BOOL hsWriteNewLine (DWORD dwMask)
{
    return hsWriteHeaderFiles(gszNewLine, sizeof(gszNewLine)-1, dwMask);
}
/***************************************************************************\
* hsFindFirstSubTag
\***************************************************************************/
char * hsFindFirstSubTag(char * pmap)
{
    /*
     * pmap points to the beginning of the tag marker. So skip it
     *  and any spaces after it
     */
    pmap += gdwTagMarkerSize;
    while (pmap < gpmapEnd) {
        if (*pmap == ' ') {
            pmap++;
        } else {
            return pmap;
        }
    }

    hsLogMsg(HSLM_EOFERROR, "hsFindFirstSubTag");
    return NULL;
}
/*********************************************************************
* hsFindFirstCharInString
*
* Finds the first occurrence of any character in psz
\***************************************************************************/
char * hsFindFirstCharInString (char * pmap, char * psz)
{
    char * pszNext;

    while (pmap < gpmapEnd) {
        /*
         * Compare current char to all chars in psz
         */
        pszNext = psz;
        do {
            if (*pmap == *pszNext++) {
                return pmap;
            }
        } while (*pszNext != '\0');

        pmap++;
    }

    return NULL;
}
/*********************************************************************
* hsFindEndOfString
\***************************************************************************/
__inline char * hsFindEndOfString (char * pmap)
{
    return hsFindFirstCharInString(pmap, " " "\r");
}
/***************************************************************************\
* hsIsString
\***************************************************************************/
BOOL hsIsString (char * pmap, char * psz)
{
    while (*psz != '\0') {
        if (pmap >= gpmapEnd) {
            return FALSE;
        }
        if (*pmap++ != *psz++) {
            return FALSE;
        }
    }

    return TRUE;
}
/***************************************************************************\
* hsFindTagMarker
\***************************************************************************/
char * hsFindTagMarker(char * pmap, char ** ppmapLineStart)
{
    char * pmapMarker;

    while (pmap < gpmapEnd) {
        /*
         * If this is the first character of the marker
         */
        if (*pmap == *gpszTagMarker) {
            /*
             * If this is the marker, find the last one in this line
             */
            if (hsIsString(pmap + 1, gpszTagMarker + 1)) {
                pmapMarker = pmap++;
                do {
                    /*
                     * Find the EOL or the first char of the next marker
                     */
                    pmap = hsFindFirstCharInString(pmap, gszMarkerCharAndEOL);
                    /*
                     * If EOL or end of map, return
                     */
                    if ((pmap == NULL) || (*pmap != *gpszTagMarker)) {
                        return pmapMarker;
                    }
                   /*
                    * If this is the marker, update pmapMarker
                    */
                   if (hsIsString(pmap + 1, gpszTagMarker + 1)) {
                        pmapMarker = pmap;
                   }
                   /*
                    * It wasn't a marker, keep looking for EOL
                    */
                   pmap++;
                } while (TRUE);
            } else {
                /*
                 * This wasn't the marker, continue parsing
                 */
                pmap++;
                continue;
            }
        } /* if (*pmap == *gpszTagMarker) */

        /*
         * If this is the end of a line, update *ppmapLineStart and
         *  gdwLineNumber. The line begins before the EOL
         */
        if (*pmap++ == '\r') {
            if (pmap >= gpmapEnd) {
                hsLogMsg(HSLM_EOFERROR, "hsFindTagMarker");
                return NULL;
            }
            if (*pmap++ != '\n') {
                hsLogMsg(HSLM_ERROR, "Missing \\n after \\r");
                return FALSE;
            }
            *ppmapLineStart = pmap - 2;
            gdwLineNumber++;
            continue;
        }
    } /* while (pmap < pmapEnd) */

    return NULL;
}
/***************************************************************************\
* hsSkipTag
\***************************************************************************/
char * hsSkipTag(char * pmap)
{

    while (pmap < gpmapEnd) {
        switch (*pmap) {
            case '_':
            case ' ':
            case '\r':
                return pmap;

            default:
                pmap++;
        }
    }

    hsLogMsg(HSLM_EOFERROR, "hsSkipTag");
    return NULL;
}
/***************************************************************************\
* hsSkipEmptyLines
* If there are multiple empty lines, skip all but one
\***************************************************************************/
char * hsSkipEmptyLines(char * pmap)
{
    char * pmapCurrentLine, *pmapLastEmptyLine;

    pmapCurrentLine = pmapLastEmptyLine = pmap;
    pmap++;
    while (pmap < gpmapEnd) {
        switch (*pmap) {
           case '\r':
                gdwLineNumber++;
                pmapLastEmptyLine = pmapCurrentLine;
                pmapCurrentLine = pmap;

            case '\n':
            case ' ':
                pmap++;
                break;

            default:
                /*
                 * If we've found more than one line,
                 * adjust line number since we're not skipping
                 * the last line we found
                 */
                if (pmapCurrentLine != pmapLastEmptyLine) {
                    gdwLineNumber--;
                }
                return pmapLastEmptyLine;
        }
    }

    return gpmapEnd;

}
/***************************************************************************\
* hsIsEmpty
* Returns TRUE if there is nothing but spaces and \r\n
\***************************************************************************/
BOOL hsIsEmpty(char * pmap, char * pmapEnd)
{
    while (pmap < pmapEnd) {
        switch (*pmap++) {
            case '\n':
            case '\r':
            case ' ':
                break;

            default:
                return FALSE;
        }
    }
    return TRUE;
}
/***************************************************************************\
* hsLastRealChar
* Returns a pointer past the last non-space non-line-break char.
* If there are multiple empty lines, returns a pointer past the last line break
\***************************************************************************/
char * hsLastRealChar(char * pmapLinesStart, char * pmap)
{

    char * pmapCurrentLine, *pmapLastEmptyLine;

    pmap--;
    pmapCurrentLine = pmapLastEmptyLine = NULL;
    while (pmapLinesStart < pmap) {
        switch (*pmap) {
            case '\n':
                pmapLastEmptyLine = pmapCurrentLine;
                pmapCurrentLine = pmap;
            case '\r':
            case ' ':
                pmap--;
                break;

            default:
                goto FoundIt;
        }
    }

FoundIt:
    /*
     * If we found multiple lines or spaces,
     *  then return a pointer to the last empty line
     * else if we didn't reach pmapLinesStart, we're at the last real char
     * else we're on an empty line
     */
    if (pmapLastEmptyLine != pmapCurrentLine) {
        if (pmapLastEmptyLine != NULL) {
            return pmapLastEmptyLine + 1;
        } else {
            return pmapCurrentLine + 1;
        }
    } else if (pmap > pmapLinesStart) {
        return pmap + 1;
    } else {
        return pmapLinesStart;
    }

}
/***************************************************************************\
* hsFindEOL
*
\***************************************************************************/
char * hsFindEOL(char * pmap)
{
    while (pmap < gpmapEnd) {
        if (*pmap++ == '\r') {
            if (pmap >= gpmapEnd) {
                hsLogMsg(HSLM_EOFERROR, "hsFindEOL");
                return NULL;
            }
            if (*pmap != '\n') {
                hsLogMsg(HSLM_ERROR, "Missing \\n after \\r");
                return NULL;
            }
            gdwLineNumber++;
            return pmap - 1;
        }
    }

    return NULL;
}
/***************************************************************************\
* hsFindTagInList
*
\***************************************************************************/
PHSTAG hsFindTagInList (PHSTAG phst, char * pmapTag, DWORD dwTagSize)
{

    while (phst->dwLabelSize != 0) {

        if ((phst->dwLabelSize == dwTagSize)
                && !_strnicmp(phst->pszLabel, pmapTag, dwTagSize)) {

            return phst;
        }
        phst++;
    }

    return NULL;

}
/***************************************************************************\
* hsSkipBlockTagIfPresent
*
\***************************************************************************/
char * hsSkipBlockTagIfPresent (char * pmap, DWORD * pdwMask)
{
    static char gszBegin [] = "begin";
    static char gszEnd [] = "end";

    char * pmapTag;
    DWORD dwTagSize;
    PHSTAG phst;

    /*
     * Remember the beginning of the tag
     */
    pmapTag = pmap;

    /*
     * Compatibility. Deal with old lt? and bt? switches.
     * If the whole tag was added to the tag list, get the flags
     *  and stop parsing.
     */
    if (gdwOptions & (HSO_USERBLOCK | HSO_USERHEADERTAG)) {
        pmap = hsFindEndOfString(pmap);
        if ((pmap != NULL) && (pmap != pmapTag)) {
            phst = hsFindTagInList (gphst, pmapTag, (DWORD)(pmap - pmapTag));
            if (phst != NULL) {
                *pdwMask |= phst->dwMask;
                return pmap;
            }
        }

        /*
         * Didn't find the string in the table so restore pmap and continue
         */
        pmap = pmapTag;
    }


    /*
     * Find the end of the current tag
     */
    pmap = hsSkipTag(pmap);
    if ((pmap == NULL) || (pmap == pmapTag)) {
        return pmap;
    }

    dwTagSize = (DWORD)(pmap - pmapTag);

    /*
     * If at separator, skip so the caller won't have to deal with it
     */
    if (*pmap == '_') {
        pmap++;
    }

    /*
     * begin tag
     */
    if ((HSCSZSIZE(gszBegin) == dwTagSize)
            && !_strnicmp(gszBegin, pmapTag, dwTagSize)) {

        *pdwMask |= HST_BEGIN;
        return pmap;
    }

    /*
     * end tag
     */
    if ((HSCSZSIZE(gszEnd) == dwTagSize)
            && !_strnicmp(gszEnd, pmapTag, dwTagSize)) {

        *pdwMask |= HST_END;
        return pmap;
    }

    return pmapTag;

}
/***************************************************************************\
* hsPopBlock
*
\***************************************************************************/
BOOL hsPopBlock (void)
{
    /*
     * Check for underflow
     */
    if (gphsbStackTop <= ghsbStack) {
        hsLogMsg(HSLM_ERROR, "Block stack underflow!");
        return FALSE;
    }

    if (gphsbStackTop->pszifLabel != NULL) {
        LocalFree(gphsbStackTop->pszifLabel);
    }

    gphsbStackTop--;

    return TRUE;
}
/***************************************************************************\
* hsPushBlock
*
\***************************************************************************/
BOOL hsPushBlock(void)
{
    /*
     * Make sure we got room in the block stack
     */
    if (gphsbStackTop >= HSBSTACKLIMIT) {
        hsLogMsg(HSLM_ERROR, "Too many nested blocks. Artificial limit:%#lx", HSBSTACKSIZE);
        return FALSE;
    }

    /*
     * Grow the stack and initialize the new entry
     */
    gphsbStackTop++;
    ZeroMemory(gphsbStackTop, sizeof(*gphsbStackTop));
    gphsbStackTop->dwLineNumber = gdwLineNumber;

    /*
     * propagate the mask
     */
    gphsbStackTop->dwMask |= (gphsbStackTop - 1)->dwMask;

    return TRUE;
}
/***************************************************************************\
* hsSkipBlock
*
\***************************************************************************/
char * hsSkipBlock(char * pmap)
{
    char * pmapLineStart;
    DWORD dwMask;

    while (pmap < gpmapEnd) {
        /*
         * Find the next marker (; by default)
         */
        pmap = hsFindTagMarker(pmap, &pmapLineStart);
        if (pmap == NULL) {
            return NULL;
        }

        /*
         * Skip the marker and any spaces after it
         */
        pmap = hsFindFirstSubTag(pmap);
        if (pmap == NULL) {
            return NULL;
        }

        /*
         * Check if this is the beginning-end of a block
         */
        dwMask = 0;
        pmap = hsSkipBlockTagIfPresent(pmap, &dwMask);
        if (pmap == NULL) {
            return NULL;
        }

        /*
         * If it found the beginning of another block, push it in the
         *  the stack and skip it.
         */
        if (dwMask & HST_BEGIN) {
            if (!hsPushBlock()) {
                return NULL;
            }
            pmap = hsSkipBlock(pmap);
            if (pmap == NULL) {
                return NULL;
            }
        } else if (dwMask & HST_END) {
            /*
             * It found the end of the block; pop it out of the stack
             *  and return the beginning of the next line
             */
            if (!hsPopBlock()) {
                return NULL;
            }
            return hsFindEOL(pmap);
        }

        /*
         * It wasn't a block tag so keep going
         */
        pmap++;
    }

    return NULL;
}
/***************************************************************************\
* hsBuildifString
*
\***************************************************************************/
BOOL hsBuildifString(char * pString, DWORD dwStringSize, char * pCompOperator, DWORD dwCompOperatorSize)
{
    char * psz;

    /*
     * Use default operator if none was provided.
     */
    if (pCompOperator == NULL) {
        pCompOperator = gszDefCompOperator;
        dwCompOperatorSize = HSCSZSIZE(gszDefCompOperator);
    }

    /*
     * Make a NULL terminated copy. Allocate enough space for the
     *  "label CompOperator version" string: 2 spaces + 10 digits (0xl#) +
     *  null termination
     */
    psz = (char *) LocalAlloc(LPTR, dwStringSize + dwCompOperatorSize + 13);
    if (psz == NULL) {
        hsLogMsg(HSLM_APIERROR, "LocalAlloc");
        hsLogMsg(HSLM_ERROR, "hsBuildifString allocation failed. Size:%#lx", dwStringSize+ dwCompOperatorSize + 13);
        return FALSE;
    }

    /*
     * Save it in the stack.
     */
    gphsbStackTop->pszifLabel = psz;

    /*
     * Build the string (the right side of the comparison (version) will
     *  be added later when available.
     */
    strncpy(psz, pString, dwStringSize);
    psz += dwStringSize;
    *psz++ = ' ';
    strncpy(psz, pCompOperator, dwCompOperatorSize);
    psz += dwCompOperatorSize;
    *psz++ = ' ';

    return TRUE;
}
/***************************************************************************\
* hsParseAndBuildifString
*
\***************************************************************************/
char * hsParseAndBuildifString(char * pmap, BOOL fSkip)
{
    BOOL fEnclosed;
    char * pmapTag, * pCompOperator;
    DWORD dwTagSize, dwCompOperatorSize;

    /*
     * Skip the tag concatenator (_)
     */
    if (*pmap++ != '_') {
        hsLogMsg(HSLM_ERROR, "Expected '_' after if tag");
        return NULL;
    }

    if (pmap >= gpmapEnd) {
        hsLogMsg(HSLM_EOFERROR, "hsParseAndBuildifString");
        return NULL;
    }

    /*
     * Find the end of the string. If it starts wiht '(', then the string
     *  is enclosed in parens. This is for strings that use _ (like _WIN32_WINDOWS)
     */
    pmapTag = pmap;
    fEnclosed = (*pmap == '(');
    if (fEnclosed) {
        pmapTag = ++pmap;
        pmap = hsFindFirstCharInString(pmap, ")" " " "\r");
        if ((pmap == NULL) || (*pmap != ')')) {
            hsLogMsg(HSLM_ERROR, "Expected ')' after if_(");
            return NULL;
        }
    } else {
        pmap = hsSkipTag(pmap);
        if ((pmap == NULL) || (pmap == pmapTag)) {
            hsLogMsg(HSLM_ERROR, "Expected string after if_");
            return NULL;
        }
    }
    dwTagSize = (DWORD)(pmap - pmapTag);


    /*
     * Skip the ')'
     */
    if (fEnclosed) {
        pmap++;
        if (pmap >= gpmapEnd) {
            hsLogMsg(HSLM_EOFERROR, "hsParseAndBuildifString");
            return NULL;
        }
    }

    /*
     * If a comparison operator follows, use it
     */
   if ((pmap + 1 < gpmapEnd) && (*pmap == '_')) {
       switch (*(pmap + 1)) {
           case '=':
           case '>':
           case '<':
               pCompOperator = ++pmap;
               pmap = hsSkipTag(pmap);
               if ((pmap == NULL) || (pmap == pCompOperator)) {
                   hsLogMsg(HSLM_EOFERROR, "hsParseAndBuildifString");
                   return NULL;
               }
               dwCompOperatorSize = (DWORD)(pmap - pCompOperator);
               break;

           default:
               pCompOperator = NULL;
               break;
       }
   }


    /*
     * Build the stirng a copy it into the block stack
     */
    if (!fSkip) {
        if (!hsBuildifString(pmapTag, (DWORD)dwTagSize, pCompOperator, (DWORD)dwCompOperatorSize)) {
            return NULL;
        }
    }

    return pmap;

}
/***************************************************************************\
* hsMapOldTag
*
\***************************************************************************/
BOOL hsMapOldTag(char * pmapTag, DWORD dwTagSize, DWORD * pdwTagMask, DWORD * pdwVersion)
{
    static char gszifWinver [] = "WINVER";
    static char gszif_WIN32_WINDOWS [] = "_WIN32_WINDOWS";
    static char gszif_WIN32_WINNT [] = "_WIN32_WINNT";

    char * pszLabel;
    UINT uSize;

    /*
     * Old tags must have a block or header bit set. Otherwise, they
     *  should be ignored
     */
    if (!(*pdwTagMask & (HST_BOTH | HST_BLOCK))) {
        *pdwTagMask |= HST_IGNORE;
        return TRUE;
    }

    /*
     * No mapping needed if at the end of a block or HST_SKIP is the only
     *  additional flag set.
     */
    if ((*pdwTagMask & HST_END)
        || ((*pdwTagMask & ~(HST_BLOCK | HST_USERBLOCK | HST_BOTH | HST_USERHEADERTAG))
                == (HST_SKIP | HST_MAPOLD))) {

        return TRUE;
    }

    /*
     * winver maps to if_winver
     */
    if (*pdwTagMask & HST_WINVER) {

        /*
         * Compatibility
         */
        if (!(gdwOptions & HSO_OLDPROJSW_4)
                && (*pdwTagMask & HST_INTERNAL)
                && !(gdwOptions & HSO_OLDPROJSW_E)) {

            *pdwTagMask |= HST_SKIP;
            return TRUE;
        }

        pszLabel = gszifWinver;
        uSize = HSCSZSIZE(gszifWinver);
        goto AddIf;
    }

    /*
     * nashville maps to if_(_WIN32_WINDOWS)_40a
     */
    if ((dwTagSize == HSCSZSIZE(gszNashville)) && !_strnicmp(pmapTag, gszNashville, dwTagSize)) {

        *pdwVersion = 0x40a;
        pszLabel = gszif_WIN32_WINDOWS;
        uSize = HSCSZSIZE(gszif_WIN32_WINDOWS);
        goto AddIf;
    }
    /*
     * sur and surplus map to if_(_WIN32_WINNT)_400 if public
     */
    if ((dwTagSize == HSCSZSIZE(gszSur)) && !_strnicmp(pmapTag, gszSur, dwTagSize)
        || (dwTagSize == HSCSZSIZE(gszSurplus)) && !_strnicmp(pmapTag, gszSurplus, dwTagSize)) {

        if (*pdwTagMask & HST_INTERNAL) {
            return TRUE;
        }

        *pdwVersion = 0x400;
        pszLabel = gszif_WIN32_WINNT;
        uSize = HSCSZSIZE(gszif_WIN32_WINNT);
        goto AddIf;
    }
    /*
     * 35 is excluded when building for old switch e and p
     */
    if ((dwTagSize == HSCSZSIZE(gsz35)) && !_strnicmp(pmapTag, gsz35, dwTagSize)) {

        *pdwTagMask |= HST_SKIP;
        return TRUE;
    }

    return TRUE;

AddIf:
        *pdwTagMask |= HST_IF;
        /*
         * If we're not in a block, push one to save the string
         */
        if (!(*pdwTagMask & HST_BEGIN)) {
            if (!hsPushBlock()) {
                return FALSE;
            }
        }

        if (!hsBuildifString(pszLabel, uSize, NULL, 0)) {
            return FALSE;
        }

    return TRUE;
}
/***************************************************************************\
* hsParseTag
*
\***************************************************************************/
DWORD hsParseTag(char * pmap, DWORD * pdwVersion)
{
    char * pmapTag;
    DWORD dwTagMask = HST_DEFAULT;
    DWORD dwTagSize;
    PHSTAG phst;

    *pdwVersion = 0;

    /*
     * Skip the marker and any spaces after it
     */
    pmap = hsFindFirstSubTag(pmap);
    if (pmap == NULL) {
        return HST_DEFAULT;
    }

    /*
     * Check for begin-end of block
     */
    pmap = hsSkipBlockTagIfPresent(pmap, &dwTagMask);
    if (pmap == NULL) {
        return HST_DEFAULT;
    }

    /*
     * If this the beginning of a block, push in the stack
     *  skip the tag concatenator (_)
     */
    if (dwTagMask & HST_BEGIN) {
        if (!hsPushBlock()) {
            return HST_ERROR;
        }
    }

    /*
     * Build tag mask. Tags are concatenated by underscores (_); each
     *  iteration of this loop processes one "sub-tag"
     */
    do {
        /*
         * Find current tag end. Bail if at last one.
         */
        pmapTag = pmap;
        pmap = hsSkipTag(pmap);
        if ((pmap == NULL) || (pmap == pmapTag)) {
            break;
        }

        /*
         * Look up the tag
         */
        dwTagSize = (DWORD)(pmap - pmapTag);
        phst = hsFindTagInList (gphst, pmapTag, dwTagSize);
        if (phst != NULL) {
            dwTagMask |= phst->dwMask;
            /*
             * Compatibility
             * If this is an old tag, map it.
             * No mapping needed if doing split only (tag is going to be
             *  ignored)
             */
            if ((dwTagMask & HST_MAPOLD)
                    && !(gdwOptions & HSO_SPLITONLY)) {

                if (!hsMapOldTag(pmapTag, dwTagSize, &dwTagMask, pdwVersion)) {
                    return HST_ERROR;
                }

            } else {
                /*
                 * If this is an if tag, copy the block string
                 */
                if (phst->dwMask & HST_IF) {
                    BOOL fEndBlock;
                    /*
                     * If not in a block, push a fake one in to save the string
                     */
                    if (!(dwTagMask & HST_BLOCK)) {
                        if (!hsPushBlock()) {
                            return HST_ERROR;
                        }
                    }
                    /*
                     * If we're at the end of a block, we want to skip
                     *  the if string (already taken care of at begin tag)
                     */
                    fEndBlock = (dwTagMask & HST_END);
                    if (fEndBlock) {
                        dwTagMask &= ~HST_IF;
                    }
                    pmap = hsParseAndBuildifString(pmap, fEndBlock);
                    if (pmap == NULL) {
                        return HST_ERROR;
                    }
                }
            } /* if ((dwTagMask & HST_MAPOLD)... */
        } else {
            /*
             * If this is not the version number, then this is an unkown tag
             */
            if (!hsVersionFromString (pmapTag, dwTagSize, pdwVersion)) {
                dwTagMask |= HST_UNKNOWN;
            }
        } /* if (phst != NULL) */

    } while (*pmap++ == '_');

    /*
     * Bail if we didn't find any tags
     */
    if (dwTagMask == HST_DEFAULT) {
        return HST_DEFAULT;
    }

   /*
    * Unknown tags are to be skipped or ignored
    */
   if (dwTagMask & HST_UNKNOWN) {
        if (gdwOptions & HSO_SKIPUNKNOWN) {
            dwTagMask |= HST_SKIP;
        } else {
            goto IgnoreTag;
        }
   }

   /*
    * Ignore the tag if marked as such
    */
   if (dwTagMask & HST_IGNORE) {
       goto IgnoreTag;
   }

    /*
     * Compatibility hack. public_winver_40a is not included for old -n and
     *  it's internal for old -e. 400 is goes to both headers for -n
     */
   if (dwTagMask & HST_WINVER) {
        if (*pdwVersion == 0x40a) {
            if (gdwOptions & HSO_OLDPROJSW_E) {
                dwTagMask |= HST_INTERNAL;
                dwTagMask &= ~HST_PUBLIC;
            } else if (gdwOptions & HSO_OLDPROJSW_N) {
                dwTagMask |= HST_SKIP;
            }
        } else if ((*pdwVersion == 0x400)
                && (gdwOptions & HSO_OLDPROJSW_N)) {

            dwTagMask |= HST_INTERNALNOTCOMP | HST_BOTH;
        }
   }

   /*
    * if using old lt2, ltb, bt2 or btb switches,
    *  then both/internal tag/block must be skipped
    */
   if ((gdwOptions & (HSO_USERBLOCK | HSO_USERHEADERTAG))
        && !(dwTagMask & ~(HST_BLOCK | HST_BOTH))) {

       if ((gdwOptions & HSO_USERINTERNALBLOCK)
                && ((dwTagMask == (HST_BEGIN | HST_INTERNAL))
                    || (dwTagMask == (HST_END | HST_INTERNAL)))) {

            dwTagMask &= HST_BLOCK;
            dwTagMask |= HST_SKIP;

       } else if ((gdwOptions & HSO_USERBOTHBLOCK)
                && ((dwTagMask == (HST_BEGIN | HST_BOTH))
                    || (dwTagMask == (HST_END | HST_BOTH)))) {

           dwTagMask &= HST_BLOCK;
           dwTagMask |= HST_SKIP;

       } else if ((gdwOptions & HSO_USERINTERNALTAG)
                && (dwTagMask == HST_INTERNAL)) {

           dwTagMask = HST_SKIP;

       } else if ((gdwOptions & HSO_USERBOTHTAG)
                && (dwTagMask == HST_BOTH)) {

           dwTagMask = HST_SKIP;
       }
   } /* if ((gdwOptions & (HSO_USERBLOCK | HSO_USERHEADERTAG))... */


   /*
    * If doing split only, anything other than both/internal is treated
    *  as untagged. If we pushed a block, pop it out as it will be ignored
    */
   if (gdwOptions & HSO_SPLITONLY) {
        if (dwTagMask & ~(HST_BLOCK | HST_USERBLOCK | HST_BOTH | HST_USERHEADERTAG)) {
            goto IgnoreTag;
        }
        *pdwVersion = 0;
   }


    /*
     * If this is the beginning of a block, save the mask in the block stack
     */
    if (dwTagMask & HST_BEGIN) {
        gphsbStackTop->dwMask |= dwTagMask;
    }

    return dwTagMask;


IgnoreTag:
    /*
     * If a block was pushed, pop it out.
     */
    if (dwTagMask & HST_BEGIN) {
        if (!hsPopBlock()) {
            return HST_ERROR;
        }
    }

    *pdwVersion = 0;
    return HST_DEFAULT;

}
/***************************************************************************\
* hsBeginEndBlock
*
\***************************************************************************/
BOOL hsBeginEndBlock (DWORD dwMask, DWORD dwVersion)
{

    char * psz;
    UINT uPasses;

    /*
     * Compatibility. If writting this block to the internal header
     *  using the not comp (ie., from >= to <), then do two passes
     *  writing one header each time.
     */
    if (dwMask & HST_INTERNALNOTCOMP) {
        uPasses = 2;
        if (dwMask & HST_BEGIN) {
            /*
             * Write public header first
             */
            dwMask &= ~HST_INTERNAL;
        } else {
            /*
             * Write internal header first
             */
            dwMask &= ~HST_PUBLIC;
        }
    } else {
        uPasses = 1;
    }

    /*
     * Add version to the string
     */
    if (dwMask & HST_BEGIN) {

        /*
         * Beginning of block or if
         * If there is no if string, done
         */
        if (gphsbStackTop->pszifLabel == NULL) {
            return TRUE;
        }

        /*
         * Something is fishy is dwVersion is 0
         */
        if (dwVersion == 0) {
            hsLogMsg(HSLM_ERROR, "if tag without version");
            return FALSE;
        }
        sprintf(gphsbStackTop->pszifLabel + strlen(gphsbStackTop->pszifLabel),
                "%#06lx", dwVersion);

    }


    /*
     * Write headers
     */
    do {
        if (dwMask & HST_BEGIN) {

            /*
             * Write #if to output file
             */
            if (!hsWriteHeaderFiles(gszIfStart, HSCSZSIZE(gszIfStart), dwMask)
                    || !hsWriteHeaderFiles(gphsbStackTop->pszifLabel, lstrlen(gphsbStackTop->pszifLabel), dwMask)
                    || !hsWriteHeaderFiles(gszIfStop, HSCSZSIZE(gszIfStop), dwMask)) {

                return FALSE;
            }

        } else {
            /*
             * End of block or if
             * If there is an if string, Write #endif to output file
             */
            if (gphsbStackTop->pszifLabel != NULL) {

                if (!hsWriteHeaderFiles(gszEndStart, HSCSZSIZE(gszEndStart), dwMask)
                        || !hsWriteHeaderFiles(gphsbStackTop->pszifLabel, lstrlen(gphsbStackTop->pszifLabel), dwMask)
                        || !hsWriteHeaderFiles(gszEndStop, HSCSZSIZE(gszEndStop), dwMask)) {

                    return FALSE;
                }
            }
        }

        /*
         * If doing a second pass, fix the mask and the string
         */
        if (uPasses > 1) {
            psz = gphsbStackTop->pszifLabel;
            if (dwMask & HST_BEGIN) {
                /*
                 * Write internal header now
                 */
                dwMask &= ~HST_PUBLIC;
                dwMask |= HST_INTERNAL;

                /*
                 * From >= to <
                 */
                while (*psz != '>') {
                    psz++;
                }
                *psz++ = '<';
                *psz = ' ';
            } else {
                /*
                 * Write public header now
                 */
                dwMask &= ~HST_INTERNAL;
                dwMask |= HST_PUBLIC;
                /*
                 * From < to >=
                 */
                while (*psz != '<') {
                    psz++;
                }
                *psz++ = '>';
                *psz = '=';
            }
        }

    } while (--uPasses != 0);


    /*
     * Clean up the block if at the end
     */
    if (dwMask & HST_END) {
        if (!hsPopBlock()) {
            return FALSE;
        }
    }


    return TRUE;
}
/***************************************************************************\
* hsSplit
*
\***************************************************************************/
BOOL hsSplit (void)
{
    BOOL fSkip;
    char * pmap, *pmapLineStart, *pmapLastLineStart, *pmapMarker, *pmapLastChar;
    DWORD dwMask, dwVersion, dwPreviousMask, dwLastMask;

    /*
     *  Initialize block stack top, map pointer, etc
     */
    ZeroMemory(gphsbStackTop, sizeof(*gphsbStackTop));
    dwLastMask = 0;
    pmap = pmapLineStart = pmapLastLineStart = gpmapStart;
    gdwLineNumber = 1;

    while (pmap < gpmapEnd) {
        /*
         * Find the marker and the line it is on
         */
        pmap = hsFindTagMarker(pmap, &pmapLineStart);
        if (pmap == NULL) {
            break;
        }

        /*
         * Parse the tag
         */
        dwMask = hsParseTag(pmap, &dwVersion);
        if (dwMask & HST_ERROR) {
            return FALSE;
        }

        /*
         * If this wasn't a tag (just the tag marker), continue
         */
        if ((dwMask == HST_DEFAULT) && (dwVersion == 0)) {
            pmap++;
            continue;
        }

        /*
         * Write any previous non-empty (untagged) lines.
         * If we're about to start a block, make sure to use the right mask.
         */
        dwPreviousMask = ((dwMask & (HST_BEGIN | HST_IF)) ? (gphsbStackTop - 1)->dwMask : gphsbStackTop->dwMask);
        pmapLastChar = hsLastRealChar(pmapLastLineStart, pmapLineStart);
        if (pmapLastLineStart < pmapLastChar) {
            /*
             * Empty lines between internal (block) tags go to the internal file
             */
            if (!(dwPreviousMask & HST_BOTH)
                    && ((dwMask & HST_BOTH) == HST_INTERNAL)
                    && ((dwLastMask & HST_BOTH) == HST_INTERNAL)
                    && hsIsEmpty(pmapLastLineStart, pmapLastChar)) {

                dwPreviousMask |= HST_INTERNAL;
            }

            if (!hsWriteHeaderFiles(pmapLastLineStart, (DWORD)(pmapLastChar - pmapLastLineStart), dwPreviousMask)) {
                return FALSE;
            }
        }

        /*
         * Determine if this tag is to be skipped.
         * If we're at the END tag, then we include it since the block was
         *  already included.
         * If gdwFilterMask contains any user-defined tags, then they must
         *  be present or the block is to be skipped -- note that this only
         *  applies for not HST_SKIP | HST_IGNORE blocks.
         */

        fSkip = (!(dwMask & HST_END)
                    && ((dwMask & HST_SKIP)
                        || (gdwVersion < dwVersion)
                        || ((gdwFilterMask & HST_USERTAGSMASK)
                             &&  ((gdwFilterMask & dwMask  & HST_USERTAGSMASK) != (dwMask & HST_USERTAGSMASK)))));


        /*
         * If it is to be skipped, do it
         */
        if (fSkip) {
            /*
             * If it's a block, skip the marker and the skip the block
             * Otherwise, skip the current line
             */
            if (dwMask & HST_BEGIN) {
                pmap = hsSkipBlock(++pmap);
            } else {
                /*
                 * If this was an if tag with no begin-end block, pop
                 *  the fake block out of the stack.
                 */
                if (dwMask & HST_IF) {
                    if (!hsPopBlock()) {
                        return FALSE;
                    }
                }

                /*
                 * Go to the beginning of the next line.
                 */
                pmap = hsFindEOL(pmap);
            }
            if (pmap == NULL) {
                return TRUE;
            }

            goto SkipEmptyLines;
        }

        /*
         * remember the marker position and the tag
         */
        pmapMarker = pmap;
        dwLastMask = dwMask;

        /*
         * For old switch 4, internal tags go into the public header
         */
        if ((gdwOptions & HSO_INCINTERNAL) && ((dwMask & HST_BOTH) == HST_INTERNAL)) {
            dwMask |= HST_INCINTERNAL;
            if (dwMask & HST_BEGIN) {
                gphsbStackTop->dwMask |= HST_INCINTERNAL;
            }
        }


        /*
         * If this is the end of a block, write the #endif statement
         *  else, if this is the beginning of a block or an if tag, add the
         *   #if statement.
         */
        if (dwMask & HST_END) {
            if (!hsBeginEndBlock(dwMask, dwVersion)) {
                return FALSE;
            }
        } else if (dwMask & (HST_BEGIN | HST_IF)) {
            if (!hsBeginEndBlock(dwMask | HST_BEGIN, dwVersion)) {
                return FALSE;
            }
        }

        //
        // Later: If we're inside a block and find a tag the needs to go to a file
        //  that doesn't have the ifdef, then we might want to add it to that file.
        // Few issues: more than one nesting. if add #if.. make sure to add #endif when
        //  block ends. Also hsBeginEnd doesn't expect to get called more than once
        //  per block. It would append the version twice.
        //
        //    else if ((gphsbStackTop->pszifLabel != NULL)
        //            && ((gphsbStackTop->dwMask & HST_BOTH) != (dwMask & HST_BOTH))) {
        //
        //            if ((gphsbStackTop->dwMask & HST_BOTH) == HST_INTERNAL) {
        //                hsLogMsg(HSLM_DEFAULT, "Public. Line:%d Block line:%d", gdwLineNumber, gphsbStackTop->dwLineNumber);
        //            } else if (!(gphsbStackTop->dwMask & HST_INTERNAL)
        //                    && ((dwMask & HST_BOTH) == HST_INTERNAL)) {
        //                hsLogMsg(HSLM_DEFAULT, "Internal. Line:%d Block line:%d", gdwLineNumber, gphsbStackTop->dwLineNumber);
        //            }
        //    }

        /*
         * Write the line up to the tag marker
         * If the line begins with the tag marker, then there is nothing to write
         * Compatibility: Don't copy any trailing spaces (breaks mc.exe).
         */
        if (pmapLineStart + 2 < pmapMarker) {
            pmapLastChar = hsLastRealChar(pmapLineStart, pmapMarker);
            if (pmapLineStart < pmapLastChar) {
                if (!hsWriteHeaderFiles(pmapLineStart, (DWORD)(pmapLastChar - pmapLineStart), dwMask)) {
                    return FALSE;
                }
            }
        }

        /*
         * If this is an if tag without a begin-end block,
         *  write the #endif statement
         */
        if ((dwMask & HST_IF) && !(dwMask & HST_BLOCK)) {
            if (!hsBeginEndBlock(dwMask | HST_END, dwVersion)) {
                return FALSE;
            }
        }

        /*
         * Skip the tag (go to the beginning of the next line)
         */
        pmap = hsFindEOL(pmapMarker);
        if (pmap == NULL) {
            return TRUE;
        }

        /*
         * If including internal tags in the public header, add the tag
         *  as a comment.
         */
        if (dwMask & HST_INCINTERNAL) {
            /*
             * Start a new line if at the end of a block
             */
            if (dwMask & HST_END) {
                if (!hsWriteNewLine(dwMask)) {
                    return FALSE;
                }
            }

            if (!hsWriteHeaderFiles(" // ", 4, dwMask)
                    || !hsWriteHeaderFiles(pmapMarker, (DWORD)(pmap - pmapMarker), dwMask)) {

                return FALSE;
            }
        }

SkipEmptyLines:
        /*
         * Update line pointers and move past beginning of new line
         */
        pmapLastLineStart = pmapLineStart = hsSkipEmptyLines(pmap);
        pmap = pmapLastLineStart + 2;
    } /* while (pmap < gpmapEnd) */


    /*
     * This is not good if we were inside a block
     */
    if (gphsbStackTop > ghsbStack) {
        hsLogMsg(HSLM_ERROR, "Missing end block");
        hsLogMsg(HSLM_ERROR | HSLM_NOLINE, "Last block Line: %d. if Label:'%s'. Mask: %#lx",
                gphsbStackTop->dwLineNumber, gphsbStackTop->pszifLabel, gphsbStackTop->dwMask);
        return FALSE;
    }

    /*
     * Write last (untagged) lines to public header.
     */
    if (pmapLastLineStart < gpmapEnd) {
        if (!hsWriteHeaderFiles(pmapLastLineStart, (DWORD)(gpmapEnd - pmapLastLineStart), HST_DEFAULT)) {
            return FALSE;
        }
    }

    /*
     * Terminate the last line
     */
    if (!hsWriteNewLine(HST_BOTH)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hsplit\hsfile.c ===
/****************************** Module Header ******************************\
* Module Name: hsfile.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/05/96 GerardoB Created
\***************************************************************************/
#include "hsplit.h"

/*********************************************************************
* hsUnmapFile
*
\***************************************************************************/
void hsUnmapFile (void)
{
    LocalFree(gpmapStart);
    CloseHandle(ghfileInput);
}
/*********************************************************************
* hsMapFile
*
\***************************************************************************/
BOOL hsMapFile (void)
{
    DWORD dwFileSize, dwBytesRead;

    ghfileInput = CreateFile(gpszInputFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
    if (ghfileInput == INVALID_HANDLE_VALUE) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "CreateFile");
        goto CleanupAndFail;
    }

    dwFileSize = GetFileSize(ghfileInput, NULL);
    if (dwFileSize == 0xFFFFFFFF) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "GetFileSize");
        goto CleanupAndFail;
    }

    gpmapStart = LocalAlloc(LPTR, dwFileSize + 1);
    if (!gpmapStart) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "LocalAlloc");
        goto CleanupAndFail;
    }

    if (!ReadFile(ghfileInput, gpmapStart, dwFileSize, &dwBytesRead, NULL)) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "ReadFile");
        goto CleanupAndFail;
    }

    if (dwFileSize != dwBytesRead) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "ReadFile");
        goto CleanupAndFail;
    }

    gpmapEnd = gpmapStart + dwFileSize;
    gpmapStart[dwFileSize] = '\0';

#if 0
    ghmap = CreateFileMapping(ghfileInput, NULL, PAGE_READONLY, 0, 0, NULL);
    if (ghmap == NULL) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "CreateFileMapping");
        goto CleanupAndFail;
    }

    gpmapStart = MapViewOfFile(ghmap, FILE_MAP_READ, 0, 0, 0);
    if (gpmapStart == NULL) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "MapViewOfFile");
        goto CleanupAndFail;
    }

    gpmapEnd = gpmapStart + dwFileSize;
#endif

    return TRUE;

CleanupAndFail:
    hsLogMsg(HSLM_ERROR | HSLM_NOLINE, "hsMapFile failed. File: '%s'", gpszInputFile);
    return FALSE;
}
/*********************************************************************
* hsCloseWorkingFiles
*
\***************************************************************************/
BOOL hsCloseWorkingFiles (void)
{
    CloseHandle(ghfilePublic);
    CloseHandle(ghfileInternal);

    hsUnmapFile();

   return TRUE;
}
/*********************************************************************
* hsOpenWorkingFiles
*
\***************************************************************************/
BOOL hsOpenWorkingFiles (void)
{
    char * pszFileFailed;

    /*
     * Map input file to memory
     */
    if (!hsMapFile()) {
        pszFileFailed = gpszInputFile;
        goto CleanupAndFail;
    }

    /*
     * Open/Create public header file
     */
    ghfilePublic = CreateFile(gpszPublicFile, GENERIC_WRITE, 0, NULL,
                            (gdwOptions & HSO_APPENDOUTPUT ? OPEN_EXISTING : CREATE_ALWAYS),
                            FILE_ATTRIBUTE_NORMAL,  NULL);

    if (ghfilePublic == INVALID_HANDLE_VALUE) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "CreateFile");
        pszFileFailed = gpszPublicFile;
        goto CleanupAndFail;
    }

    if (gdwOptions & HSO_APPENDOUTPUT) {
        if (0xFFFFFFFF == SetFilePointer (ghfilePublic, 0, 0, FILE_END)) {
            hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "SetFilePointer");
            pszFileFailed = gpszPublicFile;
            goto CleanupAndFail;
        }
    }

    /*
     * Open/Create internal header file
     */
    ghfileInternal = CreateFile(gpszInternalFile, GENERIC_WRITE, 0, NULL,
                            (gdwOptions & HSO_APPENDOUTPUT ? OPEN_EXISTING : CREATE_ALWAYS),
                            FILE_ATTRIBUTE_NORMAL,  NULL);

    if (ghfileInternal == INVALID_HANDLE_VALUE) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "CreateFile");
        pszFileFailed = gpszInternalFile;
        goto CleanupAndFail;
    }

    if (gdwOptions & HSO_APPENDOUTPUT) {
        if (0xFFFFFFFF == SetFilePointer (ghfileInternal, 0, 0, FILE_END)) {
            hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "SetFilePointer");
            pszFileFailed = gpszInternalFile;
            goto CleanupAndFail;
        }
    }

    return TRUE;

CleanupAndFail:
    hsLogMsg(HSLM_ERROR | HSLM_NOLINE, "hsOpenWorkingFiles failed. File:'%s'", pszFileFailed);
    return FALSE;
}

/***************************************************************************\
* hsWriteHeaderFiles
*
\***************************************************************************/
BOOL hsWriteHeaderFiles (char * pmap, DWORD dwSize, DWORD dwFlags)
{
    DWORD dwWritten;

    /*
     * propagate the flags from previous blocks
     */
    if (ghsbStack < gphsbStackTop) {
        dwFlags |= (gphsbStackTop - 1)->dwMask;
    }

    /*
     * write this to the public/private files only if the
     * extractonly flag is not set !
     */
    if (!(dwFlags & HST_EXTRACTONLY)) {
        /*
         * If defaulting or if requested, write it to the public header
         */
        if (!(dwFlags & HST_BOTH)
                || (dwFlags & (HST_PUBLIC | HST_INCINTERNAL))) {

            if (!WriteFile(ghfilePublic, pmap, dwSize, &dwWritten, NULL)) {
                hsLogMsg(HSLM_APIERROR, "WriteFile");
                hsLogMsg(HSLM_ERROR, "Error writing public header: %s. Handle:%#lx.", gpszPublicFile, ghfilePublic);
                return FALSE;
            }
        }

        /*
         * Write it to internal header if requested
         */
        if ((dwFlags & HST_INTERNAL) && !(dwFlags & HST_INCINTERNAL)) {

            if (!WriteFile(ghfileInternal, pmap, dwSize, &dwWritten, NULL)) {
                hsLogMsg(HSLM_APIERROR, "WriteFile");
                hsLogMsg(HSLM_ERROR, "Error writing internal header: %s. Handle:%#lx.", gpszInternalFile, ghfileInternal);
                return FALSE;
            }
        }
    }

    /*
     * Write it to extract header if requested
     */
    if (!(dwFlags & HST_INTERNAL) && (dwFlags & HST_EXTRACT)) {

        PHSEXTRACT pe = gpExtractFile;

        while (pe != NULL) {
            if ((pe->dwMask & dwFlags) != HST_EXTRACT) {
                if (!WriteFile(pe->hfile, pmap, dwSize, &dwWritten, NULL)) {
                    hsLogMsg(HSLM_APIERROR, "WriteFile");
                    hsLogMsg(HSLM_ERROR, "Error writing extract header: %s. Handle:%#lx.",
                             pe->pszFile, pe->hfile);
                    return FALSE;
                }
            }
            pe = pe->pNext;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hsplit\hsplit.c ===
/****************************** Module Header ******************************\
* Module Name: hsplit.c
*
* Structure parser - struct field name-offset tabel generator.
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/05/96 GerardoB Created
\***************************************************************************/
#include "hsplit.h"

/*
 * Maximum size of tags (gphst) table including possible user defined tags
 */
#define HSTAGTABLESIZE (sizeof(ghstPredefined) + ((32 - HST_MASKBITCOUNT) * sizeof(HSTAG)))
/***************************************************************************\
* hsAddTag
*
\***************************************************************************/
PHSTAG hsAddTag (char * pszTag, DWORD dwMask)
{
    PHSTAG phst;
    DWORD dwTagSize;

    /*
     * Make sure we still have mask bits to uniquely identified this tag
     */
    if (((dwMask | HST_EXTRACT) == HST_EXTRACT) && (gdwLastTagMask == HST_MAXMASK)) {
        hsLogMsg(HSLM_ERROR, "Too many user defined tags. Max allowed: %d", 32 - HST_MASKBITCOUNT);
        return NULL;
    }

    /*
     * Create the table the first time around.
     */
    if (gphst == ghstPredefined) {
        gphst = (PHSTAG) LocalAlloc(LPTR, HSTAGTABLESIZE);
        if (gphst == NULL) {
            hsLogMsg(HSLM_APIERROR, "LocalAlloc");
            hsLogMsg(HSLM_ERROR, "hsAddTag Allocation failed. Size:%#lx", HSTAGTABLESIZE);
            return NULL;
        }

        CopyMemory(gphst, &ghstPredefined, sizeof(ghstPredefined));
    }

    /*
     * If the string is in the table, we update the mask.
     */
    dwTagSize = strlen(pszTag);
    phst = hsFindTagInList(gphst, pszTag, dwTagSize);
    if (phst == NULL) {
        /*
         * New string. Find next available entry in the table
         */
        phst = gphst;
        while (phst->dwLabelSize != 0) {
            phst++;
        }
    }

    /*
     * Initialize it
     */
    phst->dwLabelSize = dwTagSize;
    phst->pszLabel = pszTag;

    /*
     * If generating a mask, use the next available bit in the tag mask
     *  else use the one supplied by the caller
     */
    if ((dwMask | HST_EXTRACT) == HST_EXTRACT) {
        gdwLastTagMask *= 2;
        phst->dwMask = (gdwLastTagMask | dwMask);
    } else {
        phst->dwMask = dwMask;
    }

    /*
     * Add this tag's mask to the filter mask so lines mark with this tag
     *  will be included
     */
    gdwFilterMask |= (phst->dwMask & HST_USERTAGSMASK);

    return phst;
}
/***************************************************************************\
* hsIsSwitch
*
\***************************************************************************/
__inline BOOL hsIsSwitch(char c)
{
    return (c == '/') || (c == '-');
}

/***************************************************************************\
* hsAddUserDefinedTag
*
\***************************************************************************/

BOOL hsAddUserDefinedTag(DWORD* pdwMask, int* pargc, char*** pargv)
{
    DWORD  dwRetMask = *pdwMask;
    PHSTAG phst;

    if (*pargc < 2) {
        return FALSE;  // invalid switch
    }
    
    /*
     * Allow multiple tags to be specified for one switch
     *  i.e., -t tag1 <tag2 tag2....>
     */
    do {
        (*pargc)--, (*pargv)++;

        /*
         * Add tag to table
         */
        phst = hsAddTag(**pargv, *pdwMask);
        if (phst == NULL) {
            return 0;
        }
        
        dwRetMask |= phst->dwMask;

    } while ((*pargc >= 2) && !hsIsSwitch(**(*pargv + 1)));

    /*
     * save the new mask
     */
    *pdwMask = dwRetMask;

    return TRUE;
}

/***************************************************************************\
* hsAddExtractFile
*
\***************************************************************************/
BOOL hsAddExtractFile(char* pszExtractFile, DWORD dwMask, BOOL bAppend)
{
    PHSEXTRACT pe;

    pe = LocalAlloc(LPTR, sizeof(HSEXTRACT));
    
    if (pe == NULL) {
        return FALSE;
    }
    pe->pszFile = pszExtractFile;
    pe->dwMask  = dwMask;

    pe->hfile = CreateFile(pszExtractFile, GENERIC_WRITE, 0, NULL,
                            (bAppend ? OPEN_EXISTING : CREATE_ALWAYS),
                            FILE_ATTRIBUTE_NORMAL,  NULL);

    if (pe->hfile == INVALID_HANDLE_VALUE) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "CreateFile failed for file %s",
                 pszExtractFile);
        LocalFree(pe);
        return FALSE;
    }
    if (bAppend) {
        if (0xFFFFFFFF == SetFilePointer (pe->hfile, 0, 0, FILE_END)) {
            hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "SetFilePointer failed for file %s",
                     pszExtractFile);
            CloseHandle(pe->hfile);
            LocalFree(pe);
            return FALSE;
        }
    }
    
    /*
     * link it in the list of extract files
     */
    pe->pNext = gpExtractFile;
    gpExtractFile = pe;
    
    return TRUE;
}

/***************************************************************************\
* hsProcessParameters
*
\***************************************************************************/
int hsProcessParameters(int argc, LPSTR argv[])
{
    char c, *p;
    DWORD dwMask;
    int argcParm = argc;
    PHSTAG phst;

    /*
     * Compatibility. Assume default project the first time this
     *  function is called
     */
    if (!(gdwOptions & HSO_APPENDOUTPUT)) {
        gdwOptions |= HSO_OLDPROJSW_N;
    }

    /*
     * Loop through parameters.
     */
    while (--argc) {
        p = *++argv;
        if (hsIsSwitch(*p)) {
            while (c = *++p) {
                switch (toupper(c)) {
                /*
                 * Compatibility.
                 * Chicago/Nashvilled header.
                 */
               case '4':
                   gdwOptions &= ~HSO_OLDPROJSW;
                   gdwOptions |= HSO_OLDPROJSW_4;
                   break;

                /*
                 * Old bt2 and btb switches to replace internal and
                 *  both block tags.
                 */
                case 'B':
                   p++;
                   if (toupper(*p++) != 'T') {
                       goto InvalidSwitch;
                   }
                   if (toupper(*p) == 'B') {
                       dwMask = HST_BOTH | HST_USERBOTHBLOCK;
                       gdwOptions |= HSO_USERBOTHBLOCK;
                   } else if (*p == '2') {
                       dwMask = HST_INTERNAL | HST_USERINTERNALBLOCK;
                       gdwOptions |= HSO_USERINTERNALBLOCK;
                   } else {
                       goto InvalidSwitch;
                   }

                   if (argc < 3) {
                       goto InvalidSwitch;
                   }


                   /*
                    * Add these strings as tags and mark them as blocks
                    */
                   argc--, argv++;
                   phst = hsAddTag(*argv, HST_BEGIN | dwMask);
                   if (phst == NULL) {
                       return 0;
                   }

                   argc--, argv++;
                   phst = hsAddTag(*argv, HST_END | dwMask);
                   if (phst == NULL) {
                       return 0;
                   }
                   break;

                /*
                 * Tag marker
                 */
               case 'C':
                   if (argc < 2) {
                       goto InvalidSwitch;
                   }

                   argc--, argv++;
                   gpszTagMarker = *argv;
                   *gszMarkerCharAndEOL = *gpszTagMarker;
                   gdwTagMarkerSize = strlen(gpszTagMarker);
                   if (gdwTagMarkerSize == 0) {
                       goto InvalidSwitch;
                   }
                   break;

                /*
                 * Compatibility.
                 * NT SUR header
                 */
               case 'E':
                   gdwOptions &= ~HSO_OLDPROJSW;
                   gdwOptions |= HSO_OLDPROJSW_E;
                   break;

                /*
                 * Input file
                 */
                case 'I':
                    if (argc < 2) {
                        goto InvalidSwitch;
                    }

                    argc--, argv++;
                    gpszInputFile = *argv;
                    goto ProcessInputFile;
                    break;

                /*
                 * Extract file
                 */
                case 'X':
                    {
                        char* pszExtractFile;
                        BOOL  bAppend = FALSE;
                        
                        if (toupper(*(p+1)) == 'A') {
                            p++;
                            bAppend = TRUE;
                        }
                        
                        if (argc < 3) {
                            goto InvalidSwitch;
                        }
    
                        argc--, argv++;
                        pszExtractFile = *argv;
    
                        dwMask = HST_EXTRACT;
                        if (!hsAddUserDefinedTag(&dwMask, &argc, &argv))
                            goto InvalidSwitch;
                        
                        hsAddExtractFile(pszExtractFile, dwMask, bAppend);
                        
                        break;
                    }

                /*
                 * Old lt2 and ltb switches to replace internal and
                 *  both tags.
                 */
               case 'L':
                   p++;
                   if (toupper(*p++) != 'T') {
                       goto InvalidSwitch;
                   }
                   if (toupper(*p) == 'B') {
                       dwMask = HST_BOTH | HST_USERBOTHTAG;
                       gdwOptions |= HSO_USERBOTHTAG;
                   } else if (*p == '2') {
                       dwMask = HST_INTERNAL | HST_USERINTERNALTAG;
                       gdwOptions |= HSO_USERINTERNALTAG;
                   } else {
                       goto InvalidSwitch;
                   }

                   if (!hsAddUserDefinedTag(&dwMask, &argc, &argv))
                       goto InvalidSwitch;
                   
                   break;

                /*
                 * Compatibility.
                 * NT header
                 */
               case 'N':
                    gdwOptions &= ~HSO_OLDPROJSW;
                    gdwOptions |= HSO_OLDPROJSW_N;
                   break;

                /*
                 * Ouput files
                 */
                case 'O':
                    if (argc < 3) {
                        goto InvalidSwitch;
                    }

                    argc--, argv++;
                    gpszPublicFile = *argv;

                    argc--, argv++;
                    gpszInternalFile = *argv;
                    break;

                /*
                 * Compatibility.
                 * NT SURPlus header
                 */
               case 'P':
                   gdwOptions &= ~HSO_OLDPROJSW;
                   gdwOptions |= HSO_OLDPROJSW_P;
                   break;

                /*
                 * Split only. Process internal/both tags only. Tags
                 *  including other tags as well (i.e., internal_NT)
                 *  are treated as untagged.
                 */
               case 'S':
                   gdwOptions |= HSO_SPLITONLY;
                   break;

                /*
                 * User defined tags.
                 */
                case 'T':
                    switch (toupper(*++p)) {
                        /*
                         * Include lines mark with this tag
                         */
                        case 'A':
                            dwMask = 0;
                            break;
                        /*
                         * Ignore lines marked with this tag (i.e, treated
                         *  as untagged)
                         */
                        case 'I':
                            dwMask = HST_IGNORE;
                            break;
                        /*
                         * Skip lines marked with this tag (i.e., not
                         *  included in header files)
                         */
                        case 'S':
                            dwMask = HST_SKIP;
                            break;

                        default:
                            goto InvalidSwitch;
                    }

                    if (!hsAddUserDefinedTag(&dwMask, &argc, &argv))
                        goto InvalidSwitch;

                    break;

                /*
                 * Version
                 */
                case 'V':
                    if (argc < 2) {
                        goto InvalidSwitch;
                    }

                    argc--, argv++;
                    if (!hsVersionFromString (*argv, strlen(*argv), &gdwVersion)) {
                        goto InvalidSwitch;
                    }
                    break;

                /*
                 * Unknown tags are to be skipped, as opposed to ignored.
                 */
               case 'U':
                   gdwOptions |= HSO_SKIPUNKNOWN;
                   break;

                /*
                 * Invalid switch
                 */
                default:
InvalidSwitch:
                    hsLogMsg(HSLM_ERROR | HSLM_NOLINE, "Invalid switch or parameter: %c", c);
                    // Fall through

                /*
                 * Help
                 */
                case '?':
                   goto PrintHelp;

                } /* switch (toupper(c)) */
            } /* while (c = *++p) */
        } else { /* hsIsSwitch(*p) { */
            /*
             * No switch specified. Process this input file
             */
            gpszInputFile = *argv;
            break;
        }
    } /* while (--argc) */

ProcessInputFile:
    /*
     * Make sure we got input and ouput files.
     */
    if ((gpszInputFile == NULL)
            || (gpszPublicFile == NULL)
            || (gpszInternalFile == NULL)) {

        hsLogMsg(HSLM_ERROR | HSLM_NOLINE, "Missing input or ouput file");
        goto PrintHelp;
    }

    /*
     * Add compatibility tags for default projects (first call only)
     */
    if ((gdwOptions & HSO_OLDPROJSW) && !(gdwOptions & HSO_APPENDOUTPUT)) {
        if (!(gdwOptions & HSO_OLDPROJSW_4)) {
            phst = hsAddTag(gszNT, 0);
            if (phst == NULL) {
                return 0;
            }
            phst->dwMask |= HST_MAPOLD;
            dwMask = phst->dwMask;
        }

        if (gdwOptions & HSO_OLDPROJSW_E) {
            hsAddTag(gszCairo, dwMask);
            hsAddTag(gszSur, dwMask);
            hsAddTag(gszWin40, dwMask);
            hsAddTag(gsz35, dwMask);

        } else if (gdwOptions & HSO_OLDPROJSW_P) {
            hsAddTag(gszWin40, dwMask);
            hsAddTag(gszWin40a, dwMask);
            hsAddTag(gszCairo, dwMask);
            hsAddTag(gszSur, dwMask);
            hsAddTag(gszSurplus, dwMask);
            hsAddTag(gsz35, dwMask);

        } else if (gdwOptions & HSO_OLDPROJSW_4) {
            gdwOptions |= HSO_INCINTERNAL;
            phst = hsAddTag(gszChicago, 0);
            if (phst == NULL) {
                return 0;
            }
            phst->dwMask |= HST_MAPOLD;
            dwMask = phst->dwMask;
            hsAddTag(gszNashville, dwMask);
            hsAddTag(gszWin40, dwMask);
            hsAddTag(gszWin40a, dwMask);

        } else if (!(gdwOptions & HSO_APPENDOUTPUT)) {
            gdwOptions |= HSO_OLDPROJSW_N;
        }

    } /* (gdOptions & HSO_OLDPROJW) */


    /*
     * Compatibility. If doing split only, don't include internal tags
     *  in public file
     */
    if (gdwOptions & HSO_SPLITONLY) {
        gdwOptions &= ~HSO_INCINTERNAL;
    }

    return argcParm - argc;

PrintHelp:
    hsLogMsg(HSLM_DEFAULT, "Header Split Utility. Version 2.1");
    hsLogMsg(HSLM_NOLABEL, "Usage: hsplit [options] <-o PublicFile InternalFile> [-i] File1 [-i] File2...");
    hsLogMsg(HSLM_NOLABEL, "\t[-4] Generate chicago/nashville headers");
    hsLogMsg(HSLM_NOLABEL, "\t[-bt2 BeginStr EndStr] Replace begin_internal/end_internal - Obsolete");
    hsLogMsg(HSLM_NOLABEL, "\t[-btb BeginStr EndStr] Replace begin_both/end_both tags - Obsolete");
    hsLogMsg(HSLM_NOLABEL, "\t[-c TagMarker] Replace tag marker. default \";\"");
    hsLogMsg(HSLM_NOLABEL, "\t[-e] Generate NT sur headers");
    hsLogMsg(HSLM_NOLABEL, "\t[[-i] file1 file2 ..] Input files - Required");
    hsLogMsg(HSLM_NOLABEL, "\t[-lt2 str] Replace internal tag - Obsolete");
    hsLogMsg(HSLM_NOLABEL, "\t[-ltb str] Replace both tag - Obsolete");
    hsLogMsg(HSLM_NOLABEL, "\t[-n] Generate NT headers - default");
    hsLogMsg(HSLM_NOLABEL, "\t[-x[a] ExtractHeader ExtractTag] Extract files and tags files");
    hsLogMsg(HSLM_NOLABEL, "\t[-o PublicHeader InternalHeader] Output files - Required");
    hsLogMsg(HSLM_NOLABEL, "\t[-p] Generate NT surplus headers");
    hsLogMsg(HSLM_NOLABEL, "\t[-s] Process internal and both tags only");
    hsLogMsg(HSLM_NOLABEL, "\t[-ta tag1 tag2 ..] Include lines using these tags");
    hsLogMsg(HSLM_NOLABEL, "\t[-ti tag1 tag2 ..] Ignore these tags");
    hsLogMsg(HSLM_NOLABEL, "\t[-ts tag1 tag2 ..] Skip lines using these tags");
    hsLogMsg(HSLM_NOLABEL, "\t[-u] Skip unknown tags. Default: ignore");
    hsLogMsg(HSLM_NOLABEL, "\t[-v] Version number. Default: LATEST_WIN32_WINNT_VERSION");
    hsLogMsg(HSLM_NOLABEL, "\r\nTags Format:");
    hsLogMsg(HSLM_NOLABEL, "\t<TagMarker>[begin/end][_public/internal][[_tag1][_tag2]...][_if_(str)_version | _version]");
    return 0;
}
/***************************************************************************\
* main
*
\***************************************************************************/
int __cdecl main (int argc, char *argv[])
{
    int argcProcessed;

    /*
     * Each loop processes one input file
     */
    do {
        argcProcessed = hsProcessParameters(argc, argv);
        if (argcProcessed == 0) {
            break;
        }

        if (!hsOpenWorkingFiles()
                || !hsSplit()) {

            return TRUE;
        }

        hsCloseWorkingFiles();

        gdwOptions |= HSO_APPENDOUTPUT;

        argc -= argcProcessed;
        argv += argcProcessed;

    } while (argc > 1);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hsplit\hsplit.h ===
/****************************** Module Header ******************************\
* Module Name: hsplit.h
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/05/96 GerardoB Created
\***************************************************************************/
#include <stdio.h>
#include <stddef.h>
#include <windows.h>

/***************************************************************************\
 * Defines
\***************************************************************************/
// hsLogMsg
#define HSLM_DEFAULT        0x0000
#define HSLM_NOLABEL        0x0001
#define HSLM_ERROR          0x0002
#define HSLM_WARNING        0x0004
#define HSLM_API            0x0008
#define HSLM_APIERROR       (HSLM_API | HSLM_ERROR)
#define HSLM_NOEOL          0x0010
#define HSLM_APPEND         (HSLM_NOLABEL | HSLM_NOEOL)
#define HSLM_NOLINE         0x0020
#define HSLM_UNEXPECTEDEOF  0x0040
#define HSLM_EOFERROR       (HSLM_UNEXPECTEDEOF | HSLM_ERROR)

/*
 * Tag mask bits.
 * IMPORTANT: If you add a tag mask bit,
 *  update HST_MASKBITCOUNT and HST_NEXTMASK
 */
/*
 * Types
 */
#define HST_DEFAULT             0x00000000
#define HST_ERROR               0x00000001
#define HST_MAPOLD              0x00000002
#define HST_SKIP                0x00000004
#define HST_UNKNOWN             0x00000008
#define HST_IGNORE              0x00000010

/*
 * Headers
 */
#define HST_PUBLIC              0x00000020
#define HST_INTERNAL            0x00000040
#define HST_BOTH                (HST_PUBLIC | HST_INTERNAL)
#define HST_USERINTERNALTAG     0x00000080
#define HST_USERBOTHTAG         0x00000100
#define HST_USERHEADERTAG       (HST_USERINTERNALTAG | HST_USERBOTHTAG)

/*
 * Blocks
 */
#define HST_BEGIN               0x00000200
#define HST_END                 0x00000400
#define HST_BLOCK               (HST_BEGIN | HST_END)
#define HST_IF                  0x00000800
#define HST_USERINTERNALBLOCK   0x00001000
#define HST_USERBOTHBLOCK       0x00002000
#define HST_USERBLOCK           (HST_USERINTERNALBLOCK | HST_USERBOTHBLOCK)


#define HST_WINVER              0x00004000
#define HST_INCINTERNAL         0x00008000
#define HST_INTERNALNOTCOMP     0x00010000

#define HST_EXTRACTONLY         0x00020000
#define HST_EXTRACT             0x00040000

/*
 * This is the count of HST_ bits; 32 - HST_MASKBITCOUNT is the number
 *  of tags that can be created from the command line parameters
 */
#define HST_LASTMASK            0x00040000
#define HST_USERTAGSMASK        0xFFF80000
#define HST_MAXMASK             0x80000000
#define HST_MASKBITCOUNT        19

/*
 * Options
 */
#define HSO_APPENDOUTPUT        0x00000001
#define HSO_OLDPROJSW_N         0x00000002
#define HSO_OLDPROJSW_4         0x00000004
#define HSO_OLDPROJSW_E         0x00000008
#define HSO_OLDPROJSW_P         0x00000010
#define HSO_OLDPROJSW           (HSO_OLDPROJSW_N | HSO_OLDPROJSW_4 | HSO_OLDPROJSW_E | HSO_OLDPROJSW_P)
#define HSO_SPLITONLY           0x00000020
#define HSO_INCINTERNAL         0x00000040
#define HSO_USERINTERNALBLOCK   0x00000080
#define HSO_USERBOTHBLOCK       0x00000100
#define HSO_USERBLOCK           (HSO_USERINTERNALBLOCK | HSO_USERBOTHBLOCK)
#define HSO_USERINTERNALTAG     0x00000200
#define HSO_USERBOTHTAG         0x00000400
#define HSO_USERHEADERTAG       (HSO_USERINTERNALTAG | HSO_USERBOTHTAG)
#define HSO_SKIPUNKNOWN         0x00000800

/***************************************************************************\
 * Structures
\***************************************************************************/

typedef struct _HSTAG
{
    SIZE_T dwLabelSize;
    char * pszLabel;
    DWORD dwMask;
} HSTAG, * PHSTAG;

typedef struct _HSBLOCK
{
    DWORD dwMask;
    char * pszifLabel;
    DWORD dwLineNumber;
} HSBLOCK, * PHSBLOCK;

typedef struct _HSEXTRACT
{
    struct _HSEXTRACT * pNext;
    char *              pszFile;
    HANDLE              hfile;
    DWORD               dwMask;
} HSEXTRACT, * PHSEXTRACT;

/***************************************************************************\
 * Macros
\***************************************************************************/
#define HSCSZSIZE(sz) sizeof(sz)-1
#define HSLABEL(sz) HSCSZSIZE(#sz), #sz


/***************************************************************************\
 * Globals
\***************************************************************************/
/*
 * Files
 */
extern char * gpszInputFile;
extern HANDLE ghfileInput;
extern char * gpszPublicFile;
extern HANDLE ghfilePublic;
extern char * gpszInternalFile;
extern HANDLE ghfileInternal;

extern PHSEXTRACT gpExtractFile;

/*
 * Map file
 */
extern HANDLE ghmap;
extern char * gpmapStart;
extern char * gpmapEnd;

/*
 * Switches et al
 */
extern DWORD gdwOptions;
extern DWORD gdwVersion;
extern char gszVerifyVersionStr [];
extern DWORD gdwFilterMask;
extern char * gpszTagMarker;
extern DWORD gdwTagMarkerSize;
extern char gszMarkerCharAndEOL [];

extern DWORD gdwLineNumber;

/*
 * Compatibility tags.
 * Specify size so sizeof operator can be used to calculate strlen at
 *  compile time
 */
extern char gsz35 [3];
extern char gszCairo [6];
extern char gszChicago [8];
extern char gszNashville [10];
extern char gszNT [3];
extern char gszSur [4];
extern char gszSurplus [8];
extern char gszWin40 [6];
extern char gszWin40a [7];

/*
 * Tag labels
 * Specify size so sizeof operator can be used to calculate table size at
 *  compile time
 */
extern HSTAG ghstPredefined [16];

extern PHSTAG gphst;
extern DWORD gdwLastTagMask;

/*
 * Blocks stack
 */
#define HSBSTACKSIZE 20
extern HSBLOCK ghsbStack [HSBSTACKSIZE];
#define HSBSTACKLIMIT (ghsbStack + HSBSTACKSIZE - 1)
extern PHSBLOCK gphsbStackTop;

/***************************************************************************\
 * Funtion Prototypes
\***************************************************************************/
// hsfile.c
BOOL hsCloseWorkingFiles (void);
BOOL hsOpenWorkingFiles (void);
BOOL hsWriteHeaderFiles (char * pmap, DWORD dwSize, DWORD dwFlags);

// hsparse.c
PHSTAG hsFindTagInList (PHSTAG phst, char * pmapTag, DWORD dwTagSize);
BOOL hsSplit (void);

// hsutil.c
void __cdecl hsLogMsg(DWORD dwFlags, char *pszfmt, ...);

/***************************************************************************\
 * Inline functions
\***************************************************************************/
__inline BOOL hsVersionFromString (char * pString, DWORD dwSize, DWORD * pdwVersion)
{
    return sscanf(pString, "%x", pdwVersion)
            && (dwSize == (DWORD)sprintf(gszVerifyVersionStr, "%x", *pdwVersion));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\hsplit\hsutil.c ===
/****************************** Module Header ******************************\
* Module Name: hsutil.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/05/96 GerardoB Created
\***************************************************************************/
#include "hsplit.h"
/***************************************************************************\
* soLosgMsg
\***************************************************************************/
void __cdecl hsLogMsg(DWORD dwFlags, char *pszfmt, ...)
{
    static BOOL gfAppending = FALSE;

    va_list va;

    if (!(dwFlags & HSLM_NOLABEL)) {
        if (gfAppending) {
            fprintf(stdout, "\r\n");
        }
        fprintf(stdout, "HSPLIT: ");
    }

    if (dwFlags & HSLM_ERROR) {
        if (dwFlags & HSLM_NOLINE) {
            hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, "Error: ");
        } else {
            hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, "Error (line %d): ", gdwLineNumber);
        }
    } else if (dwFlags & HSLM_WARNING) {
        if (dwFlags & HSLM_NOLINE) {
            hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, "Warning: ");
        } else {
            hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, "Warning (line %d): ", gdwLineNumber);
        }
    }

    va_start(va, pszfmt);
    vfprintf(stdout, pszfmt, va);
    va_end(va);

    if (dwFlags & HSLM_API) {
        hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, " Failed. GetLastError: %d", GetLastError());
    } else if (dwFlags & HSLM_UNEXPECTEDEOF) {
        hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, " found unexpected end of file");
    }

    gfAppending = (dwFlags & HSLM_NOEOL);
    if (!gfAppending) {
        fprintf(stdout, "\r\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ia64\inc\vxchange.h ===
/*****************************************************************************
Copyright (c) 1997-98 Intel Corp.

All Rights Reserved.

The source code contained or described herein and all documents
related to the source code ("Material") are owned by Intel Corporation
or its suppliers and licensors. Title to the Material remains with
Intel Corporation or its suppliers and licensors. The Material
contains trade secrets and proprietary and confidential information of
Intel or its suppliers and licensors. The Material is protected by
worldwide copyright and trade secret laws and treaty provisions. No
part of the Material may be used, copied, reproduced, modified,
published, uploaded, posted, transmitted, distributed, or disclosed in
any way without Intel's prior express written permission.

Unless otherwise expressly permitted by Intel in a separate license
agreement, use of the Material is subject to the copyright notices,
trademarks, warranty, use, and disclosure restrictions reflected on
the outside of the media, in the documents themselves, and in the
"About" or "Read Me" or similar file contained within this source
code, and identified as (name of the file) . Unless otherwise
expressly agreed by Intel in writing, you may not remove or alter such
notices in any way.


File:           vxchange.h

Description:    Defines the Ioctl API between the Win32 application and
                the kernel mode driver

Revision: $Revision:$ // Do not delete or replace

Notes:

Major History:

    When        Who         What
    ----------  ----------  ----------
    03/06/98    Jey         Created

*****************************************************************************/

#ifndef _VXCHANGE_H_
#define _VXCHANGE_H_

#include <windef.h>    // for MAX_PATH

/*-------------------------------------------------------------------------
// VxChange kernel mode device names
//------------------------------------------------------------------------*/

#define VXCHANGE_KERNEL_DEVICE_NAME     L"\\Device\\VxChange"
#define VXCHANGE_WIN32DEVICE_NAME       L"\\DosDevices\\VxChange"

/*-------------------------------------------------------------------------
// Interface structures and Defines
//------------------------------------------------------------------------*/

/*
// After the device open the following structure is queried from the
// driver to understand the version number of the interface supported.
*/

typedef struct tagVxChange_Attrs_t
{
    ULONG structSize;                /* Size of this structure    */
    ULONG Version;                   /* Driver Version            */
    UCHAR Data[1];                   /* more data in the future?  */
} VxChange_Attrs_t, *VxChange_Attrs_Ptr_t;


typedef struct tagVxChange_MapMem_t
{
    PVOID            ProcessVirtualAddress;
    ULONG            MapLength;
} VxChange_MapMem_t, *VxChange_MapMem_Ptr_t;


/*-------------------------------------------------------------------------
// Ioctl defines
//------------------------------------------------------------------------*/

#define FUNCTION_GET_DRIVER_ATTRIBUTES  3000    /* read request           */
#define FUNCTION_CREATE_FILE            3001    /* read/write request     */
#define FUNCTION_CLOSE_FILE             3002    /* write request          */
#define FUNCTION_READ_FILE              3003    /* buff io  read request  */
#define FUNCTION_WRITE_FILE             3004    /* buff io  write request */
#define FUNCTION_DISABLE_OS_EVENT_NOTIFICATION 3005
#define FUNCTION_ENABLE_OS_EVENT_NOTIFICATION  3006
#define FUNCTION_LOCK_MEMORY            3007
#define FUNCTION_UNLOCK_MEMORY          3008
#define FUNCTION_OPEN_FILE				3009    /* open request - no create */


#define IOCTL_VXCHANGE_GET_DRIVER_ATTRIBUTES  \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_GET_DRIVER_ATTRIBUTES,   \
            METHOD_BUFFERED,                  \
            FILE_ANY_ACCESS )

/* This IOCTL is used to open an existing file on the host.  No create */
#define IOCTL_VXCHANGE_OPEN_FILE            \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_OPEN_FILE,             \
            METHOD_BUFFERED,                  \
            FILE_ANY_ACCESS )

/* This IOCTL is used to open a file on the host.  If the file does not exist,
 *	it will be created. */
#define IOCTL_VXCHANGE_CREATE_FILE            \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_CREATE_FILE,             \
            METHOD_BUFFERED,                  \
            FILE_ANY_ACCESS )

#define IOCTL_VXCHANGE_CLOSE_FILE             \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_CLOSE_FILE,              \
            METHOD_BUFFERED,                  \
            FILE_ANY_ACCESS )

#define IOCTL_VXCHANGE_READ_FILE              \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_READ_FILE,               \
            METHOD_BUFFERED,                  \
            FILE_READ_ACCESS )

#define IOCTL_VXCHANGE_WRITE_FILE             \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_WRITE_FILE,              \
            METHOD_BUFFERED,                  \
            FILE_WRITE_ACCESS )

#define IOCTL_VXCHANGE_DISABLE_OS_EVENT_NOTIFICATION       \
  CTL_CODE( FILE_DEVICE_UNKNOWN,                           \
            FUNCTION_DISABLE_OS_EVENT_NOTIFICATION,        \
            METHOD_BUFFERED,                               \
            FILE_WRITE_ACCESS )

#define IOCTL_VXCHANGE_ENABLE_OS_EVENT_NOTIFICATION        \
  CTL_CODE( FILE_DEVICE_UNKNOWN,                           \
            FUNCTION_ENABLE_OS_EVENT_NOTIFICATION,         \
            METHOD_BUFFERED,                               \
            FILE_WRITE_ACCESS )

#define IOCTL_VXCHANGE_LOCK_MEMORY            \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_LOCK_MEMORY,             \
            METHOD_BUFFERED,                  \
            FILE_WRITE_ACCESS )

#define IOCTL_VXCHANGE_UNLOCK_MEMORY          \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_UNLOCK_MEMORY,           \
            METHOD_BUFFERED,                  \
            FILE_WRITE_ACCESS )


#endif // _VXCHANGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\command.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    command.h
//
// SYNOPSIS
//
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version. Thierry Perraut
//
///////////////////////////////////////////////////////////////////////////////
#include "precomp.hpp"
#include "database.h"

// from command.cpp
HRESULT ProcessCommand(
                       int          argc, 
                       wchar_t      * argv[],  
                       HINF         *ppHINF,
                       CDatabase&   pDatabase
                       );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\database.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
// Database.cpp
//
// SYNOPSIS
//
//    Implementation of the CDatabase class. Mainly initialize, compact...
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version. Thierry Perraut       
//
//////////////////////////////////////////////////////////////////////////////
#include "precomp.hpp"

#include "database.h"
#include "msjetoledb.h"
#include "jetoledb.h"


//////////////////////////////////////////////////////////////////////////////
//
// Uninitialize: called at the end by main(), that calls compact()
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CDatabase::Uninitialize (bool bFatalError)
{
    HRESULT                 hres;

    #ifdef THPDEBUG
        bFatalError = false;
    #endif
    
    ////////////////////////////////////////
    // if a fatal error occured before
    ////////////////////////////////////////
    if (bFatalError)
    {
        hres = (m_pITransactionLocal->Abort (NULL, TRUE, FALSE));
        TracePrintf ("Fatal Error: import to the database aborted.");
    }
    else
    {
        hres = (m_pITransactionLocal->Commit (TRUE, XACTTC_SYNC, 0));
#ifdef DEBUG
        TracePrintf ("Successful import.\n");
#endif        
    }
    
    ///////////
    // Clean
    ///////////
    m_pIOpenRowset->Release();
    m_pITransactionLocal->Release();  
    m_pIDBCreateSession->Release();

    ////////////////////////////////////////
    // compact the DB
    ////////////////////////////////////////
    CHECK_CALL_HRES (Compact()); 

    m_pIDBInitialize->Release();

    return hres;
}


//////////////////////////////////////////////////////////////////////////////
//
// Compact the database
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CDatabase::Compact ()
{
    HRESULT                     hres;

    CHECK_CALL_HRES (m_pIDBInitialize->Uninitialize ());
 
    ///////////////////////////////////////////////
    // Set the properties for the data source.
    //////////////////////////////////////////////
    CComPtr <IDBProperties>  l_pIDBProperties;

    CHECK_CALL_HRES (m_pIDBInitialize->QueryInterface (
                                                 __uuidof (IDBProperties),
                                                 (void **) &l_pIDBProperties)
                                                 );

    //////////////////////////////////
    // Prepare the create session
    //////////////////////////////////
    DBPROP                      lprop[2];

    VariantInit(&lprop[0].vValue);
    lprop[0].dwOptions              = DBPROPOPTIONS_REQUIRED;
    lprop[0].dwPropertyID           = DBPROP_INIT_DATASOURCE;
    V_VT (&(lprop[0].vValue))       = VT_BSTR;
    
    //////////////////////////////////////////////////////
    // put the path to the DB in the property.
    // remark: temporaryname was used befire
    // but the compacted database will have the name
    // that was given as a parameter to that program
    //////////////////////////////////////////////////////
    V_BSTR (&(lprop[0].vValue))     = SysAllocString (TEMPORARY_FILENAME);

    VariantInit(&lprop[1].vValue);
    lprop[1].dwOptions              = DBPROPOPTIONS_REQUIRED;
    lprop[1].dwPropertyID           = DBPROP_INIT_MODE;
    V_VT (&(lprop[1].vValue))       = VT_I4;
    V_I4 (&(lprop[1].vValue))       = DB_MODE_READ;


    DBPROPSET                      lPropSet;
    lPropSet.rgProperties           = lprop;
    lPropSet.cProperties            = 2;
    lPropSet.guidPropertySet        = DBPROPSET_DBINIT;

    ///////////////////////
    // Set the properties
    ///////////////////////
    CHECK_CALL_HRES (l_pIDBProperties->SetProperties (
                                                 1,
                                                 &lPropSet
                                                 ));


    CHECK_CALL_HRES (m_pIDBInitialize->Initialize ());

    IJetCompact*                l_pIJetCompact;
    CHECK_CALL_HRES ((m_pIDBInitialize->QueryInterface (
                                                 __uuidof (IJetCompact),
                                                 (void **) &l_pIJetCompact))
                                                   );

    /////////////////////////////////////////////////////////////
    // Prepare the properties for the data dest. (destination)
    /////////////////////////////////////////////////////////////
    DBPROP                          lpropDest[1];

    VariantInit (&lprop[0].vValue);
    lpropDest[0].dwOptions          = DBPROPOPTIONS_REQUIRED;
    lpropDest[0].dwPropertyID       = DBPROP_INIT_DATASOURCE;
    V_VT (&(lpropDest[0].vValue))   = VT_BSTR;

    ///////////////////////////////////////////////////
    // Delete the database file if it already existed.
    // that should be safe because the temporary DB
    // was succesfully created
    ///////////////////////////////////////////////////
    DeleteFileW(mpDBPath.c_str());

    //////////////////////////////////////////////
    // put the path to the DB in the property.
    //////////////////////////////////////////////
    V_BSTR (&(lpropDest[0].vValue)) = SysAllocString (mpDBPath.c_str());

    DBPROPSET                       lPropSetDest[1];
    lPropSetDest[0].rgProperties        = lpropDest;
    lPropSetDest[0].cProperties         = 1;
    lPropSetDest[0].guidPropertySet     = DBPROPSET_DBINIT;

    
    CHECK_CALL_HRES (l_pIJetCompact->Compact(1, lPropSetDest));
    
    /////////////
    // Clean
    /////////////
    CHECK_CALL_HRES (m_pIDBInitialize->Uninitialize());
    
    ////////////////////////////////////////////
    //result not checked: that's not important
    ////////////////////////////////////////////
    DeleteFileW(TEMPORARY_FILENAME);	
    SysFreeString( V_BSTR (&(lpropDest[0].vValue)) );
    SysFreeString( V_BSTR (&(lprop[0].vValue)) );

    // The CHECK_CALL_HRES set the value of hres
    return hres; 
}


// ///////////////////////////////////////////////////////////////////////////
//
// InitializeDB
//
// Comes from the file \ias\devtest\services\dictionary\dnary\dnarydump.cpp
//
// ///////////////////////////////////////////////////////////////////////////
HRESULT CDatabase::InitializeDB(WCHAR * pDatabasePath)
{
    CLSID                       clsid;
    HRESULT                     hres;

    ////////////////////////////////////////////////////
    // Retrieve the classID for the jet 4.0 provider
    ////////////////////////////////////////////////////
    CHECK_CALL_HRES(
                    CLSIDFromProgID (
                                     OLESTR ("Microsoft.Jet.OLEDB.4.0"),
                                     &clsid	//Pointer to the CLSID
                                     )
                   );


    ////////////////////////////////////
    // init: init the provider directly
    ////////////////////////////////////
    CHECK_CALL_HRES(
                    CoCreateInstance (
                                      clsid,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      __uuidof (IDBInitialize),
                                      (void **) &m_pIDBInitialize
                                     )
                   );

    mpDBPath = pDatabasePath;

    //////////////////////////////////////////////
    // Set the properties for the data source.
    //////////////////////////////////////////////
    CComPtr <IDBProperties>         pIDBProperties;

    CHECK_CALL_HRES(
                    m_pIDBInitialize->QueryInterface(
                                                     __uuidof (IDBProperties),
                                                     (void **) &pIDBProperties
                                                    )
                   );

    ///////////////////////////////
    // Prepare the create session
    ///////////////////////////////
    DBPROP                      lprop[2];

    VariantInit (&lprop[0].vValue);
    lprop[0].dwOptions              = DBPROPOPTIONS_REQUIRED;
    lprop[0].dwPropertyID           = DBPROP_INIT_DATASOURCE;
    V_VT (&(lprop[0].vValue))       = VT_BSTR;

    //////////////////////////////////////////////
    // put the path to the DB in the property.
    // this is the temporary filename
    //////////////////////////////////////////////
    V_BSTR (&(lprop[0].vValue))     = SysAllocString (TEMPORARY_FILENAME);
    
    VariantInit(&lprop[1].vValue);
    lprop[1].dwOptions              = DBPROPOPTIONS_REQUIRED;
    lprop[1].dwPropertyID           = DBPROP_INIT_MODE;
    V_VT (&(lprop[1].vValue))       = VT_I4;
    V_I4 (&(lprop[1].vValue))       = DB_MODE_READWRITE;


    DBPROPSET                   lPropSet;
    lPropSet.rgProperties           = lprop;
    lPropSet.cProperties            = 2;
    lPropSet.guidPropertySet        = DBPROPSET_DBINIT;


    // Set the properties
    CHECK_CALL_HRES(pIDBProperties->SetProperties (1, &lPropSet));


    ////////////////////
    // Lock properties 
    ////////////////////
    DBPROP dbpropb[1];
    dbpropb[0].dwPropertyID    = DBPROP_JETOLEDB_DATABASELOCKMODE;
    dbpropb[0].dwOptions       = DBPROPOPTIONS_REQUIRED;
    dbpropb[0].colid           = DB_NULLID;
    dbpropb[0].vValue.vt       = VT_I4;
    dbpropb[0].vValue.lVal     = DBPROPVAL_DL_OLDMODE;


    DBPROPSET dbpropSetb;
    dbpropSetb.guidPropertySet = DBPROPSET_JETOLEDB_DBINIT;
    dbpropSetb.cProperties     = 1;
    dbpropSetb.rgProperties    = dbpropb;

    // Set the properties
    CHECK_CALL_HRES (pIDBProperties->SetProperties(1, &dbpropSetb));

    CHECK_CALL_HRES (m_pIDBInitialize->Initialize ());


    CHECK_CALL_HRES(
                    m_pIDBInitialize->QueryInterface(
                                            __uuidof (IDBCreateSession),
                                            (void **) &m_pIDBCreateSession
                                            )
                   );


    CHECK_CALL_HRES(
                    m_pIDBCreateSession->CreateSession (
                                            NULL,	// pUnkOuter
                                            __uuidof (IOpenRowset),
                                            (IUnknown **) & m_pIOpenRowset
                                            )
                   );


    CHECK_CALL_HRES(
                    m_pIOpenRowset->QueryInterface (
                                            __uuidof (ITransactionLocal),
                                            (PVOID *) & m_pITransactionLocal
                                            )
                   );

    //////////////////////////////////////////////
    // start a transaction
    // everything is "under" that transaction
    //////////////////////////////////////////////

    CHECK_CALL_HRES(
                    m_pITransactionLocal->StartTransaction (
                                            ISOLATIONLEVEL_READUNCOMMITTED,
                                            0,
                                            NULL,
                                            NULL
                                            )
                   );

    ////////////////////////////
    // prepare the properties
    ////////////////////////////

    mlrgProperties[0].dwPropertyID          = DBPROP_IRowsetChange;
    mlrgProperties[0].dwOptions             = DBPROPOPTIONS_REQUIRED;
    mlrgProperties[0].colid                 = DB_NULLID;
    VariantInit(&mlrgProperties[0].vValue);
    V_VT (&(mlrgProperties[0].vValue))      = VT_BOOL;
    V_BOOL (&(mlrgProperties[0].vValue))    = VARIANT_TRUE;


    mlrgProperties[1].dwPropertyID      = DBPROP_UPDATABILITY;
    mlrgProperties[1].dwOptions         = DBPROPOPTIONS_REQUIRED;
    mlrgProperties[1].colid             = DB_NULLID;
    VariantInit (&mlrgProperties[1].vValue);
    V_VT (&(mlrgProperties[1].vValue))  = VT_I4;
    V_I4 (&(mlrgProperties[1].vValue))  = DBPROPVAL_UP_CHANGE |
                                          DBPROPVAL_UP_DELETE |
                                          DBPROPVAL_UP_INSERT;

    mlrgPropSets->rgProperties          = mlrgProperties;
    mlrgPropSets->cProperties           = 2;
    mlrgPropSets->guidPropertySet       = DBPROPSET_ROWSET;


    SysFreeString(V_BSTR (&(lprop[0].vValue)));

    return hres;
}


// ///////////////////////////////////////////////////////////////////////////
//
// InitializeRowset
//
// ///////////////////////////////////////////////////////////////////////////
HRESULT CDatabase::InitializeRowset(WCHAR * pTableName, IRowset ** ppRowset)
{
    //Create the tableID
    mTableID.eKind          = DBKIND_NAME;
    mTableID.uName.pwszName = pTableName;

    //Open the (defined by parameters) rowset
    return m_pIOpenRowset->OpenRowset(
                                        NULL,
                                        &mTableID,
                                        NULL,
                                        __uuidof (IRowset),
                                        1,
                                        mlrgPropSets,
                                        (IUnknown **) ppRowset
                                      );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\bitvec.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998-1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    BitVec.h
//
// SYNOPSIS
//
//    This file implements the class BitVector
//
// MODIFICATION HISTORY
//
//    02/09/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _BITVEC_H_
#define _BITVEC_H_

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    BitVector
//
// DESCRIPTION
//
//    Very simple bit vector optimized for use by the CSimpleTable class.
//
///////////////////////////////////////////////////////////////////////////////
class BitVector
{
public:
   // Type used to store bits.
   typedef unsigned long Bucket;

   BitVector()
      : numBuckets(0), numSet(0), bits(NULL) { }

   ~BitVector()
   {
      delete[] bits;
   }

   // Returns true if any bits are set.
   bool any() const
   {
      return numSet != 0;
   }

   // Returns the number of bits set.
   size_t count() const
   {
      return numSet;
   }

   // Returns true if no bits are set.
   bool none() const
   {
      return numSet == 0;
   }

   // Clears all bits.
   void reset()
   {
      if (any())
      {
         memset(bits, 0, numBuckets * sizeof(Bucket));

         numSet = 0;
      }
   }

   // Resizes the bitvector to have room for at least 'n' bits. Also clears
   // any existing bits.
   bool resize(size_t n)
   {
      size_t newBuckets = (n + sizeof(Bucket) - 1)/sizeof(Bucket);

      if (newBuckets >= numBuckets)
      {
         numBuckets = newBuckets;

         delete[] bits;

         bits = new (std::nothrow) Bucket[numBuckets];
         if ( !bits )
         {
             return false;
         }
      }

      memset(bits, 0, numBuckets * sizeof(Bucket));

      numSet = 0;
      return true;
   }

   // Sets the given bit.
   void set(size_t i)
   {
      if (!test(i))
      {
         ++numSet;

         getBucket(i) |= getBit(i);
      }
   }

   // Returns true if the given bit is set.
   bool test(size_t i) const
   {
      return (getBucket(i) & getBit(i)) != 0;
   }

protected:
   // Return the bit for a given index.
   static Bucket getBit(size_t i)
   { return (Bucket)1 << (i % sizeof(Bucket)); }

   // Return the bucket for a given index.
   Bucket& getBucket(size_t i) const
   { return bits[i / sizeof(Bucket)]; }

   size_t numBuckets;  // Number of bit buckets.
   size_t numSet;      // Number of bits currently set.
   Bucket* bits;       // Array of bit buckets.

   // Not implemented.
   BitVector(const BitVector&);
   BitVector& operator=(const BitVector&);
};

#endif  // _BITVEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ia64\sscput\sscput.c ===
/*****************************************************************************
Copyright (c) 1997-98 Intel Corp.

All Rights Reserved.

The source code contained or described herein and all documents
related to the source code ("Material") are owned by Intel Corporation
or its suppliers and licensors. Title to the Material remains with
Intel Corporation or its suppliers and licensors. The Material
contains trade secrets and proprietary and confidential information of
Intel or its suppliers and licensors. The Material is protected by
worldwide copyright and trade secret laws and treaty provisions. No
part of the Material may be used, copied, reproduced, modified,
published, uploaded, posted, transmitted, distributed, or disclosed in
any way without Intel's prior express written permission.

Unless otherwise expressly permitted by Intel in a separate license
agreement, use of the Material is subject to the copyright notices,
trademarks, warranty, use, and disclosure restrictions reflected on
the outside of the media, in the documents themselves, and in the
"About" or "Read Me" or similar file contained within this source
code, and identified as (name of the file) . Unless otherwise
expressly agreed by Intel in writing, you may not remove or alter such
notices in any way.


File:           vxchange.c

Description:    VxChane Console Mode File Copy utility

Revision: $Revision:$ // Do not delete or replace

Notes:

Major History:

    When        Who         What
    ----------  ----------  ----------
    03/06/98    Jey         Created

*****************************************************************************/


#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>

#include <vxchange.h>

void print_usage(char *module)
{
	printf("\n%s usage: filename1 filename2 \n\n",module);
	printf("Note: where filename1 is the source VPC file name\n");
	printf("      where filename2 is the destination HOST file name\n\n");
}


int
__cdecl
main(
  IN int  argc,
  IN char *argv[]
)
{
    HANDLE  hDevice;
    VxChange_Attrs_t DriverAttrs;
	DWORD BytesDone;
	unsigned char *VpcFile;
	unsigned char *HostFile;
	HANDLE hVpc;
	unsigned char *Data;
	BOOLEAN rc;
		
    if (argc < 3)
	{
		print_usage(argv[0]);
		return 1;
	}

	// open the kernel mode driver
    if ((hDevice = CreateFile("\\\\.\\VxChange",
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              )) == ((HANDLE)-1))
    {
        printf("%s error: Can't get a handle to VxChange device\n", argv[0]);
        return 2;
    }

	// get the Driver Attributes
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_GET_DRIVER_ATTRIBUTES,   // DWORD dwIoControlCode, // control code of operation to perform
             NULL,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             0,                                      // DWORD nInBufferSize,   // size of input buffer
             &DriverAttrs,                           // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             sizeof(VxChange_Attrs_t),               // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Query Driver Attributes failed\n", argv[0]);
		CloseHandle(hDevice);
		return 3;
	}

	VpcFile = argv[1];
	HostFile = argv[2];

	// open/create the Vpc file
    if ((hVpc = CreateFile(VpcFile,
		                   GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           )) == ((HANDLE)-1))
    {
        printf("%s error: Can't open the Vpc file %s\n", argv[0], VpcFile);
        return 4;
    }
  
	// open/create the Host file
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_CREATE_FILE,             // DWORD dwIoControlCode, // control code of operation to perform
             HostFile,                               // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             MAX_PATH,                               // DWORD nInBufferSize,   // size of input buffer
             NULL,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             0,                                      // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Can't open the Host file %s\n", argv[0], HostFile);

		CloseHandle(hDevice);
		CloseHandle(hVpc);
		return 5;
	}

#define  DATA_BUFFER_SIZE   4096

	// allocate 4096 bytes of memory and commit the pages
	Data = (unsigned char *)VirtualAlloc(NULL, DATA_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);

	if (Data == NULL)
	{
		printf("%s error: Can't allocate memory for data buffers\n", argv[0]);
		CloseHandle(hDevice);
		CloseHandle(hVpc);
		return 6;
	}

	rc = TRUE;
	
	// read from the source file and write to destination
    while (rc)
	{
		// read data from the Vpc file
		if (!ReadFile(
					hVpc,
					Data,
					DATA_BUFFER_SIZE,
					&BytesDone,
					NULL))
		{
			printf("%s error: Can't read from the Vpc file %s\n", argv[0], VpcFile);

			CloseHandle(hDevice);
			CloseHandle(hVpc);
			return 7;
		}

		if (BytesDone < DATA_BUFFER_SIZE)
			rc = FALSE;

		//  write data to the Host file
	    if(!DeviceIoControl(
			    hDevice,                                // HANDLE hDevice,	     // handle to device of interest
				IOCTL_VXCHANGE_WRITE_FILE,              // DWORD dwIoControlCode, // control code of operation to perform
				Data,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
				BytesDone,                              // DWORD nInBufferSize,   // size of input buffer
				NULL,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
				0,                                      // DWORD nOutBufferSize,	 // size of output buffer             
				&BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
				NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
				))
		{
			printf("%s error: Can't write to the Host file %s\n", argv[0], HostFile);

			CloseHandle(hDevice);
			CloseHandle(hVpc);
			return 8;
		}


	}

	// close the Vpc file
	CloseHandle(hVpc);

	// close the Host file
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_CLOSE_FILE,              // DWORD dwIoControlCode, // control code of operation to perform
             NULL,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             0,                                      // DWORD nInBufferSize,   // size of input buffer
             NULL,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             0,                                      // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Can't open the Host file %s\n", argv[0], HostFile);

		CloseHandle(hDevice);
		CloseHandle(hVpc);
		return 9;
	}
	
    CloseHandle(hDevice);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ia64\sscget\sscget.c ===
/*****************************************************************************
Copyright (c) 1997-98 Intel Corp.

All Rights Reserved.

The source code contained or described herein and all documents
related to the source code ("Material") are owned by Intel Corporation
or its suppliers and licensors. Title to the Material remains with
Intel Corporation or its suppliers and licensors. The Material
contains trade secrets and proprietary and confidential information of
Intel or its suppliers and licensors. The Material is protected by
worldwide copyright and trade secret laws and treaty provisions. No
part of the Material may be used, copied, reproduced, modified,
published, uploaded, posted, transmitted, distributed, or disclosed in
any way without Intel's prior express written permission.

Unless otherwise expressly permitted by Intel in a separate license
agreement, use of the Material is subject to the copyright notices,
trademarks, warranty, use, and disclosure restrictions reflected on
the outside of the media, in the documents themselves, and in the
"About" or "Read Me" or similar file contained within this source
code, and identified as (name of the file) . Unless otherwise
expressly agreed by Intel in writing, you may not remove or alter such
notices in any way.


File:           sscget.c

Description:    sscget console mode file copy utility

Revision: $Revision:$ // Do not delete or replace

Notes:

Major History:

    When        Who         What
    ----------  ----------  ----------
    03/06/98    Jey         Created

*****************************************************************************/


#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>

#include <vxchange.h>

void print_usage(char *module)
{
	printf("\n%s usage: filename1 filename2 \n\n",module);
	printf("Note: where filename1 is the source HOST file name\n");
	printf("      where filename2 is the destination VPC file name\n\n");
}


int
__cdecl
main(
  IN int  argc,
  IN char *argv[]
)
{
    HANDLE  hDevice;
    VxChange_Attrs_t DriverAttrs;
	DWORD BytesDone;
	unsigned char *VpcFile;
	unsigned char *HostFile;
	HANDLE hVpc;
	unsigned char *Data;
	BOOLEAN rc;
		
    if (argc < 3)
	{
		print_usage(argv[0]);
		return 1;
	}

	// open the kernel mode driver
    if ((hDevice = CreateFile("\\\\.\\VxChange",
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              )) == ((HANDLE)-1))
    {
        printf("%s error: Can't get a handle to VxChange device\n", argv[0]);
        return 2;
    }

	// get the Driver Attributes
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_GET_DRIVER_ATTRIBUTES,   // DWORD dwIoControlCode, // control code of operation to perform
             NULL,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             0,                                      // DWORD nInBufferSize,   // size of input buffer
             &DriverAttrs,                           // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             sizeof(VxChange_Attrs_t),               // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Query Driver Attributes failed\n", argv[0]);
		CloseHandle(hDevice);
		return 3;
	}

    HostFile = argv[1];
	VpcFile  = argv[2];
	
	// open/create the Host file
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_OPEN_FILE,               // DWORD dwIoControlCode, // control code of operation to perform
             HostFile,                               // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             MAX_PATH,                               // DWORD nInBufferSize,   // size of input buffer
             NULL,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             0,                                      // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Can't open the Host file %s\n", argv[0], HostFile);

		CloseHandle(hDevice);
		return 5;
	}

	// open/create the Vpc file
    if ((hVpc = CreateFile(VpcFile,
		                   GENERIC_WRITE,
                           FILE_SHARE_WRITE,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           )) == ((HANDLE)-1))
    {
        printf("%s error: Can't open the Vpc file %s\n", argv[0], VpcFile);
		CloseHandle(hDevice);
		CloseHandle(hVpc);
        return 4;
    }
  
#define  DATA_BUFFER_SIZE   4096

	// allocate 4096 bytes of memory and commit the pages
	Data = (unsigned char *)VirtualAlloc(NULL, DATA_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);

	if (Data == NULL)
	{
		printf("%s error: Can't allocate memory for data buffers\n", argv[0]);
		CloseHandle(hDevice);
		CloseHandle(hVpc);
		return 6;
	}

	rc = TRUE;
	
	// read from the source file and write to destination
    while (rc)
	{
		// read data from the Host file 
	    if(!DeviceIoControl(
			    hDevice,                                // HANDLE hDevice,	     // handle to device of interest
				IOCTL_VXCHANGE_READ_FILE,               // DWORD dwIoControlCode, // control code of operation to perform
				NULL,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
				0,                                      // DWORD nInBufferSize,   // size of input buffer
				Data,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
				DATA_BUFFER_SIZE,                       // DWORD nOutBufferSize,	 // size of output buffer             
				&BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
				NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
				))
		{
			printf("%s error: Can't read from the Host file %s\n", argv[0], HostFile);

			CloseHandle(hDevice);
			CloseHandle(hVpc);
			return 5;
		}

		if (BytesDone < DATA_BUFFER_SIZE)
			rc = FALSE;

		// write data to the Vpc file
		if (!WriteFile(
					hVpc,
					Data,
					BytesDone,
					&BytesDone,
					NULL))
		{
			printf("%s error: Can't write to the Vpc file %s\n", argv[0], VpcFile);
				
			CloseHandle(hDevice);
			CloseHandle(hVpc);
			return 6;
		}
	} 

	// close the Vpc file
	CloseHandle(hVpc);

	// close the Host file
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_CLOSE_FILE,              // DWORD dwIoControlCode, // control code of operation to perform
             NULL,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             0,                                      // DWORD nInBufferSize,   // size of input buffer
             NULL,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             0,                                      // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Can't close the Host file %s\n", argv[0], HostFile);

		CloseHandle(hDevice);
		CloseHandle(hVpc);
		return 9;
	}
	
    CloseHandle(hDevice);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\command.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    command.cpp
//
// SYNOPSIS
//
//    Process the command-line parameters of iasinfdb.exe
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version. Thierry Perraut
//
//////////////////////////////////////////////////////////////////////////////
#include "precomp.hpp"
#include "command.h"

using namespace std;

//////////////////////////////////////////////////////////////////////////////
//
// ProcessCommand
//
//
//////////////////////////////////////////////////////////////////////////////
HRESULT ProcessCommand(
                       int argc,
                       wchar_t * argv[],  
                       HINF *ppHINF, 
                       CDatabase& Database
                       )
{
   _ASSERTE(ppHINF != NULL);

    HRESULT                 hres;

    if (argc != NUMBER_ARGUMENTS)
    {
        /////////////////////////////////////
        // not the right number of arguments
        /////////////////////////////////////

       cerr << "inf2db Import an INF file into a Jet4 Database\n\ninf2db ";
       cerr << "[drive:][path]template.mdb [drive:][path]filename.inf";
       cerr << "[drive:][path]destination_database.mdb\n";
       hres = E_INVALIDARG;
    }
    else
    {
       /////////////////////////////////////
       // argv[1] = template database
       /////////////////////////////////////
       BOOL bCopyOk = CopyFileW(
                                 argv[1],     
                                 TEMPORARY_FILENAME, 
                     // here false means success even if file already exists
                                 FALSE        
                                );            
 
        if (!bCopyOk)
        {
           TracePrintf("Error: copy template %S -> new file %S failed ",
                                                        argv[1], 
                                                        TEMPORARY_FILENAME
                                                        );
           
           hres = E_FAIL;
        }
        else
        {
           ///////////////////////////////////////////////////////
           // suppress the read-only attribute from the new file
           ///////////////////////////////////////////////////////
           BOOL bChangedAttributeOK = SetFileAttributesW(
                                                        TEMPORARY_FILENAME, 
                                                        FILE_ATTRIBUTE_NORMAL
                                                        );
           if(!bChangedAttributeOK)
           {
              TracePrintf("Error: change attribute (RW) on %S failed",
                                                TEMPORARY_FILENAME
                                                ); 
              hres = E_FAIL;
           }
           else
           {
             ///////////////////////////////////////////////////////
             // three arg (argc = 4) Open the INF file for reading
             // Open for read (will fail if file does not exist) 
             ///////////////////////////////////////////////////////
       
             UINT                    lErrorCode;
             if( (*ppHINF = (HINF) SetupOpenInfFileW(
                                    // name of the INF to open
                                    argv[2], 
                                    // optional, the class of the INF file
                                    NULL, 
                                    // specifies the style of the INF file
                                    INF_STYLE_WIN4,  
                                    &lErrorCode  
                                    ))
                == INVALID_HANDLE_VALUE
               )
              {
                  //////////////////////////////////
                  // Error situation
                  //////////////////////////////////

                  LPVOID                 lpMsgBuf;
                  FormatMessageW( 
                                  FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                  FORMAT_MESSAGE_FROM_SYSTEM | 
                                  FORMAT_MESSAGE_IGNORE_INSERTS,
                                  NULL,
                                  GetLastError(),
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  (LPWSTR) &lpMsgBuf,
                                  0,
                                  NULL 
                                );

                  TracePrintf("Error: %S",(LPCWSTR)lpMsgBuf);
                  cerr << "Error: " << (LPCWSTR)lpMsgBuf << "\n";
                  /////////////////////
                  // Free the buffer.
                  /////////////////////
                  LocalFree(lpMsgBuf);
                  cerr << "ERROR: Can't open the INF file " << argv[1] <<"\n";
                  hres = E_INVALIDARG;
              }
              else 
              {
              #ifdef DEBUG
                 TraceString("Info: inf file open\n");
              #endif
                 ////////////////////////////////////////////////                  
                 // argv[3] = destination path to the database 
                 // call the initialize member function
                 ////////////////////////////////////////////////                  
                 Database.InitializeDB(argv[3]);
                 hres = S_OK;
              }
           }
        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\database.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    database.h
//
// SYNOPSIS
//
//   Interface for the CDatabase class
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version. Thierry Perraut
//
//////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6_INCLUDED)
#define AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.hpp"
using namespace std;

class CDatabase  
{
public:
	HRESULT Uninitialize(bool  bFatalError);
    HRESULT InitializeDB(WCHAR *pDatabasePath);
    HRESULT InitializeRowset(WCHAR *pTableName, IRowset **ppRowset);
    HRESULT Compact();
    
private:
    ITransactionLocal*          m_pITransactionLocal;
    IOpenRowset*                m_pIOpenRowset;
    IDBCreateSession*           m_pIDBCreateSession;
    IDBInitialize*              m_pIDBInitialize;

    DBID                        mTableID;
    DBPROPSET                   mlrgPropSets[1]; // number will not change
    DBPROP                      mlrgProperties[2]; //number will not change
    wstring                     mpDBPath;
};

#endif
 // !defined(AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\inf2db.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    inf2db.h
//
// SYNOPSIS
//    import the information stored in an INF file into a MSJet4 relational
//    database
//
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////
// inf2db.cpp : Defines the entry point for the console application.
//
#include "precomp.hpp"
#include "inf2db.h"

///////////////////////////////////////////////////////////////////////////////
//
//  Main
//
///////////////////////////////////////////////////////////////////////////////
extern "C"
void __cdecl wmain(int argc, wchar_t* argv[])
{
    HINF           lHINF;

    HRESULT     hres = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hres))
    {
        cerr << "Unable to initialize COM!\n";
    }
    else
    {
        CDatabase               Database;

        ////////////////////////////////////////////////////////////////
        // Call the process command (process the command-line arguments)
        ////////////////////////////////////////////////////////////////
        hres = ProcessCommand(argc, argv, &lHINF, Database);
        if (FAILED(hres))
        {
            g_FatalError = true;
        }
        else
        {
             ////////////////////////////////////////////////
             // Call the process function to parse the file
             ////////////////////////////////////////////////
            hres = Process(lHINF, Database);
            if (FAILED(hres))
            {
                g_FatalError = true;
            }

            //////////////////////////
            // then call uninitialize
            //////////////////////////
            hres = Uninitialize(&lHINF, Database);

            if (g_FatalError)
            {
                cerr << "Fatal Error: check the Trace file.";
                cerr << "Import operation aborted.\n";
            }
            else
            {
                cerr << "Import successful.\n";
            }
        }
    }
    CoUninitialize();
}


//////////////////////////////////////////////////////////////////////////////
//
// Unitialize
//
//////////////////////////////////////////////////////////////////////////////
HRESULT Uninitialize(HINF *phINF, CDatabase& Database)
{
   _ASSERTE(phINF != NULL);

   SetupCloseInfFile(*phINF);

   return Database.Uninitialize(g_FatalError);
}


//////////////////////////////////////////////////////////////////////////////
//
// Process
//
//////////////////////////////////////////////////////////////////////////////
HRESULT Process(const HINF& hINF, CDatabase& Database)
{

    // get the number of tables
    LONG lTotalTableNumber = SetupGetLineCountW(
                                    // handle to the INF file
                                    hINF,
                                    // the section in which to count lines
                                    TABLE_SECTION
                                    );


    bool            bError = false; //needs to be outside the if, loop...
    HRESULT         hres;

    if (lTotalTableNumber > 0)
    {
    #ifdef DEBUG
        TracePrintf("Info: number of tables = %d\n",lTotalTableNumber);
    #endif

        INFCONTEXT        lTableContext;
        // if <>0 do a loop on the tables
        BOOL bOK = SetupFindFirstLineW(
                                       hINF,
                                       TABLE_SECTION,
                                       NULL,
                                       &lTableContext
                                       );

        for (
             LONG lTableCounter = 0;
             lTableCounter < lTotalTableNumber;
             lTableCounter++
             )
        {
            // read the Table name in the Tables section
            WCHAR lTableName[SIZELINEMAX];

            bOK = SetupGetLineTextW(
                                   &lTableContext,
                                   NULL,
                                   NULL,
                                   NULL,
                                   lTableName,
                                   SIZELINEMAX,
                                   NULL
                                   );

            // fetch the next line's context
            if (!bOK)
            {
                g_FatalError = true;
                bError = true;
                break;
            }

            // Rowset pointer
            CComPtr<IRowset>  lpRowset;

            //////////////////////
            // create one rowset
            //////////////////////
            hres = Database.InitializeRowset(lTableName, &lpRowset);

            if (FAILED(hres))
            {
                g_FatalError = true;
                bError = true;
                break;
            }
            else
            {
                // create the simpletable
                CSimpleTableEx    lSimpleTable;

                lSimpleTable.Attach(lpRowset);
                lSimpleTable.MoveFirst();

                //////////////////////////////////////////////////////
                // now one table and all its columns are well known.
                // empty database assumed
                // process the rows
                //////////////////////////////////////////////////////
                hres = ProcessAllRows(
                                      hINF,
                                      lSimpleTable,
                                      lTableName
                                      );

                if (FAILED(hres))
                {
                    // process rows should not fail, even if no rows are read
                    bError       = true;
                    g_FatalError = true;
                }
            }

            //////////////////////////////////////////////////////
            // Read the next table's name (if any)
            //////////////////////////////////////////////////////
            bOK = SetupFindNextLine(
                                      &lTableContext,
                                      &lTableContext
                                     );
            if (!bOK)
            {
                if ((lTableCounter + 1) < lTotalTableNumber)
                {
                   // find next line should not crash. fatal error
                   g_FatalError = true;
                   bError       = true;
                   break;
                }
                break;
            } //end of tables
        }
    }
    else
    {// no tables: do nothing
        TracePrintf("Info: No [tables] section in the inf file\n");
        // bError = true;
    }

    if (bError)
    {
        LPVOID              lpMsgBuf;
        FormatMessageW(
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_SYSTEM |
                      FORMAT_MESSAGE_IGNORE_INSERTS,
                      NULL,
                      GetLastError(),
                      // Default language
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPWSTR) &lpMsgBuf,
                      0,
                      NULL
                      );

        // Display the string.
        TracePrintf("Error: %S",lpMsgBuf);

        // Free the buffer.
        LocalFree( lpMsgBuf );
        hres = E_FAIL;
    }

    return      hres;
}


//////////////////////////////////////////////////////////////////////////////
//
// ProcessAllRows
//
//////////////////////////////////////////////////////////////////////////////
HRESULT ProcessAllRows(
                       const HINF&       hINF,
                       CSimpleTableEx&  pSimpleTable,
                       const WCHAR*     pTableName
                       )
{
   _ASSERTE(pTableName != NULL);

    ////////////////////
    // process the rows.
    ////////////////////

   wstring              lwsRowSection;
   lwsRowSection        += pTableName;

   LONG                 lRowCounter = 1;

   INFCONTEXT           lRowContext;

    #ifdef DEBUG
       TracePrintf("Info: %S",lwsRowSection.c_str());
    #endif

    ////////////////////////////////////////////////////
    // if <>0 do a loop on the lines (ie row names)
    ////////////////////////////////////////////////////
    BOOL bOK = SetupFindFirstLineW(
                           hINF,
                           // section in which to find a line
                           lwsRowSection.c_str(),
                           NULL,          // optional, key to search for
                           &lRowContext  // context of the found line
                           );

    HRESULT              hres = S_OK;

    if (!bOK)
    {
        //no such section (end of section = end of rows)
    }
    else
    {

        LONG                lTotalLinesNumber = 0; //safer
        //////////////////////////////////////////////////////
        // Get the Number of lines in that section. (& check)
        //////////////////////////////////////////////////////
        lTotalLinesNumber = SetupGetLineCountW(
                                          hINF, // handle to the INF file
                                   // the section in which to count lines
                                          lwsRowSection.c_str()
                                          );


        //////////////////////////////
        // Read eerything (loop)
        //////////////////////////////
        for (
             LONG lLinesCounter = 0;
             lLinesCounter < lTotalLinesNumber;
             lLinesCounter++
            )
        {

            #ifdef DEBUG
              TracePrintf("Info: for loop: %d", lLinesCounter);
            #endif

            ///////////////////////////////////////////////
            // read the Table name in the Tables section
            ///////////////////////////////////////////////
            WCHAR lLineName[SIZELINEMAX];

            bOK = SetupGetLineTextW(
                                    &lRowContext,
                                    NULL,
                                    NULL,
                                    NULL,
                                    lLineName,
                                    SIZELINEMAX,
                                    NULL
                                   );

            if (!bOK)
            {
                g_FatalError = true;
                TracePrintf("Error: SetupGetLineText Failed "
                               "in ProcessAllRows");
            }
            else //everything is ok, process the corresponding row
            {
                ///////////////////////
                // process the rows
                ///////////////////////
                hres = ProcessOneRow(
                                      hINF,
                                      pSimpleTable,
                                      lLineName
                                    );
                if (FAILED(hres)) { g_FatalError = true; }

            }

            //////////////////////////////////
            // fetch the next line's context
            //////////////////////////////////
            bOK = SetupFindNextLine(
                                    // starting context in an INF file
                                    &lRowContext,
                                    // context of the next line
                                    &lRowContext
                                   );
            if (!bOK)
            {
                ////////////////////////////////////////////////
                // end of the lines
                // compare the counter to the max to make sure
                // that last line is ok
                ////////////////////////////////////////////////
                if((lLinesCounter + 1) < lTotalLinesNumber)
                {
                    // too early
                    g_FatalError = true;
                    TracePrintf("Error: FindNext Line failed."
                                  "Not enough lines in the section %S",
                                  lwsRowSection.c_str());

                }
            }
        }
    }

    return      hres;
}


//////////////////////////////////////////////////////////////////////////////
//
// ProcessOneRow
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
ProcessOneRow(
    HINF inf,
    CSimpleTableEx& table,
    PCWSTR rowName
    )
{
   // Iterate through the columns in the database and see if the INF file
   // specifies a value for each column.
   for (DBORDINAL i = 0; i < table.GetColumnCount(); ++i)
   {
      // First try with a stack-based buffer.
      WCHAR buffer[1024];
      PWCHAR text = buffer;
      DWORD textSize = sizeof(buffer) / sizeof(buffer[0]);
      BOOL success = SetupGetLineTextW(
                         NULL,
                         inf,
                         rowName,
                         table.GetColumnName(i),
                         text,
                         textSize,
                         &textSize
                         );
      DWORD error = success ? NO_ERROR : GetLastError();

      if (error == ERROR_INSUFFICIENT_BUFFER)
      {
         // The stack-based buffer wasn't big enough, so allocate one on the
         // heap ...
         text = (PWCHAR)HeapAlloc(
                            GetProcessHeap(),
                            0,
                            textSize * sizeof(WCHAR)
                            );
         if (!text) { return E_OUTOFMEMORY; }

         // ... and try again.
         success = SetupGetLineTextW(
                       NULL,
                       inf,
                       rowName,
                       table.GetColumnName(i),
                       text,
                       textSize,
                       &textSize
                       );
         error = success ? NO_ERROR : GetLastError();
      }

      // If we successfully retrieved the line text AND it has at least one
      // character ...
      if (!error && textSize > 1)
      {
         // ... then process based on the column data type.
         switch (table.GetColumnType(i))
         {
            case DBTYPE_I4:
            {
               table.SetValue(i, _wtol(text));
               break;
            }

            case DBTYPE_WSTR:
            {
               table.SetValue(i, text);
               break;
            }

            case DBTYPE_BOOL:
            {
               table.SetValue(i, (VARIANT_BOOL)_wtol(text));
               break;
            }
         }
      }

      // Free the heap-based buffer if necessary.
      if (text != buffer) { HeapFree(GetProcessHeap(), 0, text); }

      switch (error)
      {
         case NO_ERROR:
            // Everything succeeded.
         case ERROR_INVALID_PARAMETER:
            // SETUPAPI didn't like the column name.
         case ERROR_LINE_NOT_FOUND:
            // The INF file didn't provide a value for this column.
            break;

         default:
            // Something went wrong.
            return HRESULT_FROM_WIN32(error);
      }
   }

   // All the columns are populated, so insert the row.
   return table.Insert();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\inf2db.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    inf2db.h
//
// SYNOPSIS
//
// Header file for inf2db: the main file for that project.
//    
//
// MODIFICATION HISTORY
//
//    02/11/1999    Original version.
//
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6__INCLUDED_)
#define AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.hpp"

#include "database.h"
#include "simpletableex.h"
#include "command.h"

using namespace std;

namespace
{
    bool g_FatalError;

    class CLocalBinding  
    {
        public:
            WCHAR    ColumnName[SIZELINEMAX];
            LONG     Ordinal;
            LONG     DBType;
    };
}


HRESULT Uninitialize(HINF *phINF, CDatabase& Database);

HRESULT Process(const HINF& hINF, CDatabase& Database);

HRESULT ProcessAllRows(
                       const HINF&       hINF,
                       CSimpleTableEx&  pSimpleTable,
                       const WCHAR*     pTableName
                       );

HRESULT ProcessOneRow(
                        HINF inf,
                        CSimpleTableEx& table,
                        PCWSTR rowName);




#endif
 // !defined(AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\simpletableex.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    MySimpleTable.cpp
//
// SYNOPSIS
//
//    MySimpleTable.cpp: derived from CSimpleTable. Only difference
//    is _GetDataPtr now public instead of being protected
//
// MODIFICATION HISTORY
//
//    01/26/1999    Original version.
//
//
//////////////////////////////////////////////////////////////////////

#include "precomp.hpp"
#include "simpletableex.h"

#ifdef _DEBUG
    #undef THIS_FILE
    static char THIS_FILE[]=__FILE__;
    #define new DEBUG_NEW
#endif


///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    DBBinding
//
// DESCRIPTION
//
//    This struct extends the DBBINDING struct to provide functionality
//    to initialize the struct from a DBCOLUMNINFO struct.
//
///////////////////////////////////////////////////////////////////////////////
struct DBBinding : DBBINDING
{
   //////////
   // 'offset' is the offset in bytes of this column's data within the
   //  row buffer.
   //////////
   void Initialize(DBCOLUMNINFO& columnInfo, DBBYTEOFFSET& offset)
   {
      iOrdinal   = columnInfo.iOrdinal;
      obValue    = offset;
      obLength   = offset + columnInfo.ulColumnSize;
      obStatus   = obLength + sizeof(DBLENGTH);
      pTypeInfo  = NULL;
      pObject    = NULL;
      pBindExt   = NULL;
      dwPart     = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
      eParamIO   = DBPARAMIO_NOTPARAM;
      dwMemOwner = (columnInfo.wType & DBTYPE_BYREF) ? DBMEMOWNER_PROVIDEROWNED
                                                     : DBMEMOWNER_CLIENTOWNED;
      cbMaxLen   = columnInfo.ulColumnSize;
      dwFlags    = 0;
      wType      = columnInfo.wType;
      bPrecision = columnInfo.bPrecision;
      bScale     = columnInfo.bScale;

      offset = obStatus + sizeof(DBSTATUS);
   }
};

   
///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTableEx::Attach
//
//    Size bug "fixed"
//
// DESCRIPTION
//
//    This method binds the table object to a new rowset. The previous rowset
//    (if any) will be detached.
//
// REMARK: see "Changes" below
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTableEx::Attach(IRowset* pRowset)
{
   // Make sure we didn't get a null pointer.
   if (!pRowset) { return E_POINTER; }

   // Detach the current rowset.
   Detach();

   // We don't care if this returns an error. It will just prevent
   // the user from updating.
   pRowset->QueryInterface(IID_IRowsetChange, (void**)&rowsetChange);

   //////////
   // Get the column information for the table.
   //////////

   CComPtr<IColumnsInfo> ColumnsInfo;
   RETURN_ERROR(pRowset->QueryInterface(IID_IColumnsInfo,
                                        (void**)&ColumnsInfo));

   RETURN_ERROR(ColumnsInfo->GetColumnInfo(&numColumns,
                                           &columnInfo,
                                           &stringsBuffer));

   //////////
   // Allocate the per-column data.
   //////////

   // tperraut Bug 449498
   columnBinding = new (std::nothrow) DBBinding[numColumns];

   if ( !columnBinding )
   {
      return E_OUTOFMEMORY;
   }

   // 449498 resize changed: will not throw an exception. 
   // false if out of memory
   if ( !dirty.resize(numColumns) )
   {
       return E_OUTOFMEMORY;
   }

   //////////
   // Create a binding for each column.
   //////////

   bufferLength = 0;

   for (DBORDINAL i = 0; i < numColumns; ++i)
   {
      // Compute the width of the column.
      DBLENGTH width = columnInfo[i].ulColumnSize;

      //////////////////////////////////////////////////////////////////
      //
      // CHANGES: if size is too big (1 giga byte), then size = a 
      // pre-defined value. Note: that's dangerous 
      //
      //////////////////////////////////////////////////////////////////
      if (SIZE_MEMO_MAX < width)
      {
          width = SIZE_MEMO_MAX;
      }

      // Add room for the null terminator.
      if (columnInfo[i].wType == DBTYPE_STR)
      {
         width += 1;
      }
      else if (columnInfo[i].wType == DBTYPE_WSTR)
      {
         width = (width + 1) * sizeof(WCHAR);
      }

      // Round to an 8-byte boundary (could peek ahead and be more efficient).
      width = (width + 7) >> 3 << 3;

      columnInfo[i].ulColumnSize = width;

      // We're using the pTypeInfo element to store the offset to our data.
      // We have to store the offset now, since it will be overwritten by
      // DBBinding::Initialize.
      columnInfo[i].pTypeInfo = (ITypeInfo*)bufferLength;

      columnBinding[i].Initialize(columnInfo[i], bufferLength);
   }

   //////////
   // Allocate a buffer for the row data.
   //////////

   buffer = new (std::nothrow) BYTE[bufferLength];

   if (!buffer) { return E_OUTOFMEMORY; }

   //////////
   // Create an accessor.
   //////////

   RETURN_ERROR(pRowset->QueryInterface(IID_IAccessor,
                                        (void**)&accessor));

   RETURN_ERROR(accessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                         numColumns,
                                         columnBinding,
                                         bufferLength,
                                         &readAccess,
                                         NULL));

   // I used this hokey method of assigning the pointer to avoid a
   // dependency on atlimpl.cpp
   //
   // We do this assignment last, so that the presence of a rowset means the
   // entire initialization succeeded.
   (rowset.p = pRowset)->AddRef();

   endOfRowset = false;

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\simpletableex.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    SimpleTableEx.h
//
// SYNOPSIS
//
//    SimpleTableEx.h: header for CSimpleTableEx
//    derived from CSimpleTable. Only difference
//    is SetValue() overloaded for WCHAR *
//
// MODIFICATION HISTORY
//
//    01/26/1999    Original version.
//    
//
//////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MYSIMPLETABLE_H__EEA1D7F0_B649_11D2_9E24_00C04F6EA5B6_INCLUDED)
#define AFX_MYSIMPLETABLE_H__EEA1D7F0_B649_11D2_9E24_00C04F6EA5B6_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.hpp"
#include "simTable.h"


//////////////////////////////////////////////////////////////////////////////
//
// Class CSimpleTableEx
//
//////////////////////////////////////////////////////////////////////////////
class CSimpleTableEx : public CSimpleTable  
{
public:
   using CSimpleTable::SetValue;
    // set public a protected method from the super class

   void SetValue(DBORDINAL nOrdinal, WCHAR *szValue)
   {
      wcscpy((WCHAR *)_GetDataPtr(nOrdinal), szValue);
   }
   HRESULT Attach(IRowset* pRowset);

};

#endif 
// !defined(AFX_MYSIMPLETABLE_H__EEA1D7F0_B649_11D2_9E24_00C04F6EA5B6_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\helper.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    helper.cpp
//
// SYNOPSIS
//
//    Helper functions: log file, string conversion
//
// MODIFICATION HISTORY
//
//    01/25/1999    Original version. Thierry Perraut
//
///////////////////////////////////////////////////////////////////////////////

#include "precomp.hpp"
#include "SimpleTableEx.h"


//////////////////////////////////////////////////////////////////////////////
//
// TracePrintf: trace function
//
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TracePrintf(
     IN PCSTR szFormat,
     ...
    )
{
    va_list marker;
    va_start(marker, szFormat);
    vprintf(
           szFormat,
           marker
          );
    va_end(marker);
}


//////////////////////////////////////////////////////////////////////////////
//
// TraceString: trace function
//
//////////////////////////////////////////////////////////////////////////////
void TraceString(char* cString)
{
    _ASSERTE(cString);
    printf("%s\n", cString);
}


// ///////////////////////////////////////////////////////////////////////////
//
// ConvertTypeStringToLong
//
//
// ///////////////////////////////////////////////////////////////////////////
HRESULT ConvertTypeStringToLong(const WCHAR *lColumnType, LONG *pType)
{
   _ASSERTE(pType != NULL);
   HRESULT                  hres = S_OK;

   if(wcscmp(L"DBTYPE_I4",lColumnType) == 0)
   {
      *pType = DBTYPE_I4;
   }
   else if(wcscmp(L"DBTYPE_WSTR",lColumnType) == 0)
   {
      *pType = DBTYPE_WSTR;
   }
   else if(wcscmp(L"DBTYPE_BOOL",lColumnType) == 0)
   {
      *pType = DBTYPE_BOOL;
   }
   else
   {
      *pType = -1;
      hres = E_FAIL;
   }

   return    hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\precomp.hpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    precomp.h
//
// SYNOPSIS
//
//    Include file for the inf2db project
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version.
//
//////////////////////////////////////////////////////////////////////////////

#if !defined(PRECOMP_H__61594E40_C20F_11D2_9E31_00C04F6EA5B6__INCLUDED_)
#define PRECOMP_H__61594E40_C20F_11D2_9E31_00C04F6EA5B6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

////////////////////////
// Old-type defines
////////////////////////
#define DBINITCONSTANTS // Initialize OLE constants...
#define SIZELINEMAX     512

////////////////////////////////////
// Macro
////////////////////////////////////

#define CHECK_CALL_HRES(expr) \
hres = expr;      \
if (FAILED(hres)) \
{       \
    TracePrintf("%s returned 0x%X\n",  ## #expr, hres); \
    return hres; \
}

// Return the error code from a failed COM invocation.  Useful if you don't
// have to do any special clean-up.
#define RETURN_ERROR(expr) \
   { HRESULT __hr__ = (expr); if (FAILED(__hr__)) return __hr__; }

#include <atlbase.h>

#include <crtdbg.h>

#include <iostream>
#include <vector>
#include <list>
#include <string>

#include "oledb.h"
#include "oledberr.h"
#include "setupapi.h"

namespace
{
    const WCHAR     TABLE_SECTION[]         = L"Tables";
    const WCHAR     VERSION_SECTION[]       = L"Version";
    const WCHAR     DATABASE_KEY[]          = L"Database";
    const WCHAR     TEMPORARY_FILENAME[]    = L".\\_temporary.mdb";

    const long      SIZELONGMAX             = 10; //10 digits ?
    const int       NUMBER_ARGUMENTS        = 4;

    const long      SIZE_MEMO_MAX           = 32768;
}


// from helper
HRESULT ConvertTypeStringToLong(const WCHAR *lColumnType, LONG *pType);
void __cdecl TracePrintf(IN PCSTR szFormat, ...);
void TraceString(IN WCHAR* wcString);
void TraceString(IN char* cString);



#endif
// !defined(PRECOMP_H__61594E40_C20F_11D2_9E31_00C04F6EA5B6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\simtable.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997-1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    SimTable.cpp
//
// SYNOPSIS
//
//    This file implements the class CSimpleTable
//
// MODIFICATION HISTORY
//
//    10/31/1997    Original version.
//    02/09/1998    Reorganized some things to make is easier to extend.
//    02/27/1998    Changes to support moving it into the iasutil.lib
//    10/16/1998    Support DBTYPE_WSTR.
//
///////////////////////////////////////////////////////////////////////////////

#include "precomp.hpp"
#include <oledberr.h>
#include <SimTable.h>

//////////
// Stack version of the new operator.
//////////
#define stack_new(obj, num) new (_alloca(sizeof(obj)*num)) obj[num]


///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    DBBinding
//
// DESCRIPTION
//
//    This struct extends the DBBINDING struct to provide functionality
//    to initialize the struct from a DBCOLUMNINFO struct.
//
///////////////////////////////////////////////////////////////////////////////
struct DBBinding : DBBINDING
{
   //////////
   // 'offset' is the offset in bytes of this column's data within the
   //  row buffer.
   //////////
   void Initialize(DBCOLUMNINFO& columnInfo, DBBYTEOFFSET& offset)
   {
      iOrdinal   = columnInfo.iOrdinal;
      obValue    = offset;
      obLength   = offset + columnInfo.ulColumnSize;
      obStatus   = obLength + sizeof(DBLENGTH);
      pTypeInfo  = NULL;
      pObject    = NULL;
      pBindExt   = NULL;
      dwPart     = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
      eParamIO   = DBPARAMIO_NOTPARAM;
      dwMemOwner = (columnInfo.wType & DBTYPE_BYREF) ? DBMEMOWNER_PROVIDEROWNED
                                                     : DBMEMOWNER_CLIENTOWNED;
      cbMaxLen   = columnInfo.ulColumnSize;
      dwFlags    = 0;
      wType      = columnInfo.wType;
      bPrecision = columnInfo.bPrecision;
      bScale     = columnInfo.bScale;

      offset = obStatus + sizeof(DBSTATUS);
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::CSimpleTable
//
// DESCRIPTION
//
//    Constructor.
//
///////////////////////////////////////////////////////////////////////////////
CSimpleTable::CSimpleTable()
   : numColumns(0),
     columnInfo(NULL),
     stringsBuffer(NULL),
     columnBinding(NULL),
     readAccess(NULL),
     buffer(NULL),
     numRows(0),
     currentRow(0),
     endOfRowset(false)
{
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::~CSimpleTable
//
// DESCRIPTION
//
//    Destructor.
//
///////////////////////////////////////////////////////////////////////////////
CSimpleTable::~CSimpleTable()
{
   Detach();
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Attach
//
// DESCRIPTION
//
//    This method binds the table object to a new rowset. The previous rowset
//    (if any) will be detached.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::Attach(IRowset* pRowset)
{
   // Make sure we didn't get a null pointer.
   if (!pRowset) { return E_POINTER; }

   // Detach the current rowset.
   Detach();

   // We don't care if this returns an error. It will just prevent
   // the user from updating.
   pRowset->QueryInterface(IID_IRowsetChange, (void**)&rowsetChange);

   //////////
   // Get the column information for the table.
   //////////

   CComPtr<IColumnsInfo> ColumnsInfo;
   RETURN_ERROR(pRowset->QueryInterface(IID_IColumnsInfo,
                                        (void**)&ColumnsInfo));

   RETURN_ERROR(ColumnsInfo->GetColumnInfo(&numColumns,
                                           &columnInfo,
                                           &stringsBuffer));

   //////////
   // Allocate the per-column data.
   //////////

   // tperraut Bug 449498
   columnBinding = new (std::nothrow) DBBinding[numColumns];

   if ( !columnBinding )
   {
      return E_OUTOFMEMORY;
   }

   // 449498 resize changed: will not throw an exception. 
   // false if out of memory
   if ( !dirty.resize(numColumns) )
   {
       return E_OUTOFMEMORY;
   }

   //////////
   // Create a binding for each column.
   //////////

   bufferLength = 0;

   for (DBORDINAL i = 0; i < numColumns; ++i)
   {
      // Compute the width of the column.
      DBLENGTH width = columnInfo[i].ulColumnSize;

      // Add room for the null terminator.
      if (columnInfo[i].wType == DBTYPE_STR)
      {
         width += 1;
      }
      else if (columnInfo[i].wType == DBTYPE_WSTR)
      {
         width = (width + 1) * sizeof(WCHAR);
      }

      // Round to an 8-byte boundary (could peek ahead and be more efficient).
      width = (width + 7) >> 3 << 3;

      columnInfo[i].ulColumnSize = width;

      // We're using the pTypeInfo element to store the offset to our data.
      // We have to store the offset now, since it will be overwritten by
      // DBBinding::Initialize.
      columnInfo[i].pTypeInfo = (ITypeInfo*)bufferLength;

      columnBinding[i].Initialize(columnInfo[i], bufferLength);
   }

   //////////
   // Allocate a buffer for the row data.
   //////////

   buffer = new (std::nothrow) BYTE[bufferLength];

   if (!buffer) { return E_OUTOFMEMORY; }

   //////////
   // Create an accessor.
   //////////

   RETURN_ERROR(pRowset->QueryInterface(IID_IAccessor,
                                        (void**)&accessor));

   RETURN_ERROR(accessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                         numColumns,
                                         columnBinding,
                                         bufferLength,
                                         &readAccess,
                                         NULL));

   // I used this hokey method of assigning the pointer to avoid a
   // dependency on atlimpl.cpp
   //
   // We do this assignment last, so that the presence of a rowset means the
   // entire initialization succeeded.
   (rowset.p = pRowset)->AddRef();

   endOfRowset = false;

   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Detach
//
// DESCRIPTION
//
//    Frees all the resources associated with the current rowset.
//
///////////////////////////////////////////////////////////////////////////////
IRowset* CSimpleTable::Detach()
{
   ReleaseRows();

   delete[] buffer;
   buffer = NULL;

   delete[] columnBinding;
   columnBinding = NULL;

   CoTaskMemFree(columnInfo);
   columnInfo = NULL;

   CoTaskMemFree(stringsBuffer);
   stringsBuffer = NULL;

   accessor.Release();
   rowsetChange.Release();

   IRowset* temp = rowset;
   rowset.Release();
   return temp;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::MoveFirst
//
// DESCRIPTION
//
//    Positions the cursor over the first row in the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::MoveFirst()
{
   if (rowset == NULL) return E_FAIL;

   ReleaseRows();

   RETURN_ERROR(rowset->RestartPosition(NULL));

   endOfRowset = false;

   return MoveNext();
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::MoveNext
//
// DESCRIPTION
//
//    Positions the cursor over the next row in the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::MoveNext()
{
   // If the data wasn't opened successfully then fail
   if (rowset == NULL) return E_FAIL;

   // Too late to save any changes.
   DiscardChanges();

   // If we've used all the rows from the last fetch, then get some more.
   if (++currentRow >= numRows)
   {
      ReleaseRows();

      // We have to do this check here, since some providers automatically
      // reset to the beginning of the rowset.
      if (endOfRowset) { return DB_S_ENDOFROWSET; }

      HROW* pRow = row;
      HRESULT hr = rowset->GetNextRows(NULL,
                                       0,
                                       FETCH_QUANTUM,
                                       &numRows,
                                       &pRow);

      if (hr == DB_S_ENDOFROWSET)
      {
         // Mark that we've reached the end of the rowset.
         endOfRowset = true;

         // If we didn't get any rows, then we're really at the end.
         if (numRows == 0) { return DB_S_ENDOFROWSET; }
      }
      else if (FAILED(hr))
      {
         return hr;
      }
   }

   // Load the data into the buffer.
   RETURN_ERROR(rowset->GetData(row[currentRow], readAccess, buffer));

   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Insert
//
// DESCRIPTION
//
//    Inserts the contents of the accessor buffer into the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::Insert()
{
   // Is a rowset attached?
   if (!rowset) { return E_FAIL; }

   // Does this rowset support changes?
   if (!rowsetChange) { return E_NOINTERFACE; }

   // Get an accessor for the dirty columns.
   HACCESSOR writeAccess;
   RETURN_ERROR(CreateAccessorForWrite(&writeAccess));

   // Release the existing rows to make room for the new one.
   ReleaseRows();

   HRESULT hr = rowsetChange->InsertRow(NULL, writeAccess, buffer, row);

   if (SUCCEEDED(hr))
   {
      // The changes were save successfully, so reset the dirty vector.
      DiscardChanges();

      // We now have exactly one row in our buffer.
      numRows = 1;
   }

   // Release the accessor.
   accessor->ReleaseAccessor(writeAccess, NULL);

   return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Delete
//
// DESCRIPTION
//
//    Deletes the current row from the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::Delete()
{
   // Are we positioned over a valid row?
   if (!rowset || currentRow >= numRows) { return E_FAIL; }

   // Does this rowset support changes?
   if (!rowsetChange) { return E_NOINTERFACE; }

   DBROWSTATUS rowStatus[1];

   return rowsetChange->DeleteRows(NULL, 1, row + currentRow, rowStatus);
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::SetData
//
// DESCRIPTION
//
//    Updates the current row with the data in the accessor buffer.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::SetData()
{
   // Are we positioned over a valid row?
   if (!rowset || currentRow >= numRows) { return E_FAIL; }

   // Does this rowset support changes?
   if (!rowsetChange) { return E_NOINTERFACE; }

   // Get an accessor for the dirty columns.
   HACCESSOR writeAccess;
   RETURN_ERROR(CreateAccessorForWrite(&writeAccess));

   HRESULT hr = rowsetChange->SetData(row[currentRow], writeAccess, buffer);

   if (SUCCEEDED(hr))
   {
      // The changes were save successfully, so reset the dirty vector.
      DiscardChanges();
   }

   // Release the accessor.
   accessor->ReleaseAccessor(writeAccess, NULL);

   return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::GetLength
//
// DESCRIPTION
//
//    Returns the length of the current value for a given column.
//
///////////////////////////////////////////////////////////////////////////////
DBLENGTH CSimpleTable::GetLength(DBORDINAL nOrdinal) const
{
   return *(DBLENGTH*)((BYTE*)_GetDataPtr(nOrdinal) +
                       columnInfo[OrdinalToColumn(nOrdinal)].ulColumnSize);
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::GetOrdinal
//
// DESCRIPTION
//
//    Returns the ordinal for a given column name.
//
///////////////////////////////////////////////////////////////////////////////
bool CSimpleTable::GetOrdinal(LPCWSTR szColumnName, DBORDINAL* pOrdinal) const
{
   for (DBORDINAL i = 0; i < numColumns; ++i)
   {
      if (lstrcmpW(columnInfo[i].pwszName, szColumnName) == 0)
      {
         *pOrdinal = columnInfo[i].iOrdinal;

         return true;
      }
   }

   return false;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::GetStatus
//
// DESCRIPTION
//
//    Returns the status code associated with the current value of a column.
//
///////////////////////////////////////////////////////////////////////////////
DBSTATUS CSimpleTable::GetStatus(DBORDINAL nOrdinal) const
{
   return *(DBSTATUS*)((BYTE*)_GetDataPtr(nOrdinal) +
                       columnInfo[OrdinalToColumn(nOrdinal)].ulColumnSize +
                       sizeof(DBLENGTH));
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::CreateAccessorForWrite
//
// DESCRIPTION
//
//    Creates an accessor that is only to bound to columns that have been
//    modified.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::CreateAccessorForWrite(HACCESSOR* phAccessor)
{
   //////////
   // Allocate temporary space for the bindings.
   //////////

   DBBINDING* writeBind = stack_new(DBBINDING, dirty.count());

   //////////
   // Load in all the dirty columns.
   //////////

   size_t total = 0;

   for (size_t i = 0; total < dirty.count(); ++i)
   {
      if (dirty.test(i))
      {
         // We only want to bind the value.
         (writeBind[total++] = columnBinding[i]).dwPart = DBPART_VALUE;
      }
   }

   //////////
   // Create the accessor.
   //////////

   return accessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                   dirty.count(),
                                   writeBind,
                                   bufferLength,
                                   phAccessor,
                                   NULL);
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::_GetDataPtr
//
// DESCRIPTION
//
//    Non-const version of _GetDataPtr. Marks the target column as dirty.
//
///////////////////////////////////////////////////////////////////////////////
void* CSimpleTable::_GetDataPtr(DBORDINAL nOrdinal)
{
   DBORDINAL nColumn = OrdinalToColumn(nOrdinal);

   dirty.set(nColumn);

   return buffer + (ULONG_PTR)columnInfo[nColumn].pTypeInfo;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::ReleaseRows
//
// DESCRIPTION
//
//    Releases all the rows returned by the last fetch.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::ReleaseRows()
{
   if (rowset != NULL)
   {
      HRESULT hr = rowset->ReleaseRows(numRows, row, NULL, NULL, NULL);

      currentRow = numRows = 0;

      return hr;
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ini\ini.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    munge.h

Abstract:

    This is the main include file for the Windows ini file dumper

Author:

    Steve Wood (stevewo) 16-May-1989

Revision History:

--*/

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <tools.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ini\ini.c ===
/*
 * Utility program to dump the contents of a Windows .ini file.
 * one form to another.  Usage:
 *
 *      ini [-f FileSpec] [SectionName | SectionName.KeywordName [= Value]]
 *
 *
 */

#include "ini.h"

BOOL fRefresh;
BOOL fSummary;
BOOL fUnicode;

void
DumpIniFileA(
            char *IniFile
            )
{
    char *Sections, *Section;
    char *Keywords, *Keyword;
    char *KeyValue;

    Sections = LocalAlloc( 0, 8192 );
    if (Sections) {
        memset( Sections, 0xFF, 8192 );
    } else {
        return;
    }
    Keywords = LocalAlloc( 0, 8192 );
    if (Keywords) {
        memset( Keywords, 0xFF, 8192 );
    } else {
        LocalFree(Sections);
        return;
    }
    KeyValue = LocalAlloc( 0, 2048 );
    if (KeyValue) {
        memset( KeyValue, 0xFF, 2048 );
    } else {
        LocalFree(Keywords);
        LocalFree(Sections);
        return;
    }

    *Sections = '\0';
    if (!GetPrivateProfileStringA( NULL, NULL, NULL,
                                   Sections, 8192,
                                   IniFile
                                 )
       ) {
        printf( "*** Unable to read - rc == %d\n", GetLastError() );
    }

    Section = Sections;
    while (*Section) {
        printf( "[%s]\n", Section );
        if (!fSummary) {
            *Keywords = '\0';
            GetPrivateProfileStringA( Section, NULL, NULL,
                                      Keywords, 4096,
                                      IniFile
                                    );
            Keyword = Keywords;
            while (*Keyword) {
                GetPrivateProfileStringA( Section, Keyword, NULL,
                                          KeyValue, 2048,
                                          IniFile
                                        );
                printf( "    %s=%s\n", Keyword, KeyValue );

                while (*Keyword++) {
                }
            }
        }

        while (*Section++) {
        }
    }

    LocalFree( Sections );
    LocalFree( Keywords );
    LocalFree( KeyValue );

    return;
}

void
DumpIniFileW(
            WCHAR *IniFileW
            )
{
    WCHAR *Sections, *Section;
    WCHAR *Keywords, *Keyword;
    WCHAR *KeyValue;

    Sections = LocalAlloc( 0, 8192 );
    if (Sections) {
        memset( Sections, 0xFF, 8192 );
    } else {
        return;
    }
    Keywords = LocalAlloc( 0, 8192 );
    if (Keywords) {
        memset( Keywords, 0xFF, 8192 );
    } else {
        LocalFree(Sections);
        return;
    }
    KeyValue = LocalAlloc( 0, 2048 );
    if (KeyValue) {
        memset( KeyValue, 0xFF, 2048 );
    } else {
        LocalFree(Keywords);
        LocalFree(Sections);
        return;
    }

    *Sections = '\0';
    if (!GetPrivateProfileStringW( NULL, NULL, NULL,
                                   Sections, 8192 / sizeof(WCHAR),
                                   IniFileW
                                 )
       ) {
        wprintf( L"*** Unable to read - rc == %d\n", GetLastError() );
    }

    Section = Sections;
    while (*Section) {
        wprintf( L"[%s]\n", Section );
        if (!fSummary) {
            *Keywords = '\0';
            GetPrivateProfileStringW( Section, NULL, NULL,
                                      Keywords, 4096 / sizeof(WCHAR),
                                      IniFileW
                                    );
            Keyword = Keywords;
            while (*Keyword) {
                GetPrivateProfileStringW( Section, Keyword, NULL,
                                          KeyValue, 2048 / sizeof(WCHAR),
                                          IniFileW
                                        );
                wprintf( L"    %s=%s\n", Keyword, KeyValue );

                while (*Keyword++) {
                }
            }
        }

        while (*Section++) {
        }
    }

    LocalFree( Sections );
    LocalFree( Keywords );
    LocalFree( KeyValue );

    return;
}


void
DumpIniFileSectionA(
                   char *IniFile,
                   char *SectionName
                   )
{
    DWORD cb;
    char *SectionValue;
    char *s;

    cb = 4096;
    while (TRUE) {
        SectionValue = LocalAlloc( 0, cb );
        if (!SectionValue) {
            return;
        }
        *SectionValue = '\0';
        if (GetPrivateProfileSection( SectionName,
                                      SectionValue,
                                      cb,
                                      IniFile
                                    ) == cb-2
           ) {
            LocalFree( SectionValue );
            cb *= 2;
        } else {
            break;
        }
    }

    printf( "[%s]\n", SectionName );
    s = SectionValue;
    while (*s) {
        printf( "    %s\n", s );

        while (*s++) {
        }
    }

    LocalFree( SectionValue );
    return;
}

void
DumpIniFileSectionW(
                   WCHAR *IniFile,
                   WCHAR *SectionName
                   )
{
    DWORD cb;
    WCHAR *SectionValue;
    WCHAR *s;
    cb = 4096;
    while (TRUE) {
        SectionValue = LocalAlloc( 0, cb );
        if (!SectionValue) {
            return;
        }
        *SectionValue = L'\0';
        if (GetPrivateProfileSectionW( SectionName,
                                       SectionValue,
                                       cb,
                                       IniFile
                                     ) == cb-2
           ) {
            LocalFree( SectionValue );
            cb *= 2;
        } else {
            break;
        }
    }

    wprintf( L"[%s]\n", SectionName );
    s = SectionValue;
    while (*s) {
        wprintf( L"    %s\n", s );

        while (*s++) {
        }
    }

    LocalFree( SectionValue );
    return;
}



void
Usage( void )
{
    fputs( "usage: INI | [-f FileSpec] [-r | [SectionName | SectionName.KeywordName [ = Value]]]\n"
           "Where...\n"
           "    -f  Specifies the name of the .ini file.  WIN.INI is the default.\n"
           "    -s  Print only the sections in the .ini file\n"
           "    -u  Use the Unicode version of GetPrivateProfileString\n"
           "\n"
           "    -r  Refresh the .INI file migration information for the specified file.\n"
           "\n"
           "        blanks around = sign are required when setting the value.\n",

           stderr);
    exit( 1 );
}

char KeyValueBuffer[ 4096 ];
WCHAR IniFileW[_MAX_PATH];
WCHAR SectionNameW[_MAX_PATH];
WCHAR KeywordNameW[4096];
WCHAR KeywordValueW[4096];

int __cdecl main( int argc, char *argv[] )
{
    int i, n;
    LPSTR s, IniFile, SectionName, KeywordName, KeywordValue;
    BOOL  rc;

    ConvertAppToOem( argc, argv );
    if (argc < 1) {
        Usage();
    }

    IniFile = "win.ini";
    SectionName = NULL;
    KeywordName = NULL;
    KeywordValue = NULL;
    argc -= 1;
    argv += 1;
    while (argc--) {
        s = *argv++;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch ( tolower( *s ) ) {
                    case 'r':   fRefresh = TRUE;
                        break;

                    case 's':   fSummary = TRUE;
                        break;

                    case 'u':   fUnicode = TRUE;
                        break;

                    case 'f':   if (argc) {
                            argc -= 1;
                            IniFile = *argv++;
                            break;
                        }

                    default:    Usage();
                }
            }
        } else
            if (SectionName == NULL) {
            if (argc && !strcmp( *argv, ".")) {
                SectionName = s;
                argc -= 1;
                argv += 1;
                if (argc) {
                    if (!strcmp( *argv, "=" )) {
                        argc -= 1;
                        argv += 1;
                        KeywordName = NULL;
                        if (argc) {
                            KeywordValue = calloc( 1, 4096 );
                            s = KeywordValue;
                            while (argc) {
                                strcpy( s, *argv++ );
                                s += strlen( s ) + 1;
                                argc -= 1;
                            }
                        } else {
                            KeywordValue = (LPSTR)-1;
                        }
                    } else {
                        argc -= 1;
                        KeywordName = *argv++;
                    }
                } else {
                    KeywordName = NULL;
                }
            } else
                if (KeywordName = strchr( s, '.' )) {
                *KeywordName++ = '\0';
                SectionName = s;
            } else {
                SectionName = s;
            }
        } else
            if (!strcmp( s, "=" )) {
            if (argc) {
                argc -= 1;
                KeywordValue = *argv++;
            } else {
                KeywordValue = (LPSTR)-1;
            }
        } else {
            Usage();
        }
    }

    if (fRefresh) {
        printf( "Refreshing .INI file mapping information for %s\n", IniFile );
        WritePrivateProfileString( NULL, NULL, NULL, IniFile );
        exit( 0 );
    }

    printf( "%s contents of %s\n", KeywordValue ? "Modifying" : "Displaying", IniFile );

    MultiByteToWideChar(GetACP(), 0, IniFile, strlen(IniFile)+1, IniFileW, sizeof(IniFileW)/sizeof(WCHAR));

    if (SectionName)
        MultiByteToWideChar(GetACP(), 0, SectionName, strlen(SectionName)+1, SectionNameW, sizeof(SectionNameW)/sizeof(WCHAR));

    if (SectionName == NULL) {
        if (fUnicode)
            DumpIniFileW( IniFileW );
        else
            DumpIniFileA( IniFile );
    } else
        if (KeywordName == NULL) {
        if (fUnicode)
            DumpIniFileSectionW( IniFileW, SectionNameW );
        else
            DumpIniFileSectionA( IniFile, SectionName );

        if (KeywordValue != NULL) {
            printf( "Above application variables are being deleted" );
            if (KeywordValue != (LPSTR)-1) {
                printf( " and rewritten" );
            } else {
                KeywordValue = NULL;
            }
            if (fUnicode) {

                MultiByteToWideChar(GetACP(), 0, KeywordName, strlen(KeywordName)+1, KeywordNameW, sizeof(KeywordNameW)/sizeof(WCHAR));
                if (KeywordValue)
                    MultiByteToWideChar(GetACP(), 0, KeywordValue, strlen(KeywordValue)+1, KeywordValueW, sizeof(KeywordValueW)/sizeof(WCHAR));

                rc = WritePrivateProfileStringW( SectionNameW,
                                                 KeywordNameW,
                                                 KeywordValue ? KeywordValueW : NULL,
                                                 IniFileW
                                               );
            } else {
                rc = WritePrivateProfileStringA( SectionName,
                                                 KeywordName,
                                                 KeywordValue,
                                                 IniFile
                                               );
            }

            if (!rc) {
                printf( " *** failed, ErrorCode -== %u\n", GetLastError() );
            } else {
                puts  ( " [ok]");
            }
        }
    } else {
        printf( "[%s]\n    %s == ", SectionName, KeywordName );
        if (fUnicode) {
            MultiByteToWideChar(GetACP(), 0, KeywordName, strlen(KeywordName)+1, KeywordNameW, sizeof(KeywordNameW)/sizeof(WCHAR));

            n = GetPrivateProfileStringW( SectionNameW,
                                         KeywordNameW,
                                         L"*** Section or keyword not found ***",
                                         (LPWSTR)KeyValueBuffer,
                                         sizeof( KeyValueBuffer ) / sizeof(WCHAR),
                                         IniFileW
                                       );
        } else {
            n = GetPrivateProfileStringA( SectionName,
                                         KeywordName,
                                         "*** Section or keyword not found ***",
                                         KeyValueBuffer,
                                         sizeof( KeyValueBuffer ),
                                         IniFile
                                       );
        }

        if (KeywordValue == NULL && n == 0 && GetLastError() != NO_ERROR) {
            printf( " (ErrorCode == %u)\n", GetLastError() );
        } else {
            if (fUnicode)
                wprintf( L"%s", (WCHAR *)KeyValueBuffer );
            else
                printf( "%s", KeyValueBuffer );
            if (KeywordValue == NULL) {
                printf( "\n" );
            } else {
                if (KeywordValue == (LPSTR)-1) {
                    printf( " (deleted)" );
                    KeywordValue = NULL;
                } else {
                    printf( " (set to %s)", KeywordValue );
                }

                if (fUnicode) {

                    MultiByteToWideChar(GetACP(), 0, KeywordName, strlen(KeywordName)+1, KeywordNameW, sizeof(KeywordNameW)/sizeof(WCHAR));
                    if (KeywordValue)
                        MultiByteToWideChar(GetACP(), 0, KeywordValue, strlen(KeywordValue)+1, KeywordValueW, sizeof(KeywordValueW)/sizeof(WCHAR));

                    rc = WritePrivateProfileStringW( SectionNameW,
                                                     KeywordNameW,
                                                     KeywordValue ? KeywordValueW : NULL,
                                                     IniFileW
                                                   );
                } else {
                    rc = WritePrivateProfileStringA( SectionName,
                                                     KeywordName,
                                                     KeywordValue,
                                                     IniFile
                                                   );
                }

                if (!rc) {
                    printf( " *** failed, ErrorCode -== %u", GetLastError() );
                }
                printf( "\n" );
            }
        }
    }

    return ( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ioverify\main.cxx ===
//                                          
// System level IO verification configuration utility
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: main.cxx
// author: DMihai
// created: 04/19/99
// description: command line parsing and help information
//

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>

#include <common.ver>

#include "resid.hxx"
#include "resutil.hxx"
#include "regutil.hxx"

void
DisplayHelpInformation();

//////////////////////////////////////////////////////////

extern "C" void _cdecl
wmain( int argc, TCHAR *argv[] )
{
    BOOL bResult;
    DWORD dwVerifierLevel;
    
    TCHAR strCmdLineOption[ 64 ];

    dwVerifierLevel = -1;

    //
    // look for /enable
    //
    
    bResult = GetStringFromResources(
        IDS_ENABLE_CMDLINE_OPTION,
        strCmdLineOption,
        ARRAY_LEN( strCmdLineOption ) );
    
    if( bResult && argc >= 2 && _tcsicmp( argv[ 1 ], strCmdLineOption ) == 0 )
    {
        //
        // level is hardcoded for now
        //

        dwVerifierLevel = 3;

        //
        // this will exit process
        //

        EnableSysIoVerifier(
            dwVerifierLevel );
    }

    //
    // look for /disable
    //

    bResult = GetStringFromResources(
        IDS_DISABLE_CMDLINE_OPTION,
        strCmdLineOption,
        ARRAY_LEN( strCmdLineOption ) );

    if( bResult && argc == 2 && _tcsicmp( argv[ 1 ], strCmdLineOption ) == 0 )
    {
        //
        // get the name of the kernel module
        //
        //
        // this will exit process
        //

        DisableSysIoVerifier();
    }

    //
    // look for /status
    //

    bResult = GetStringFromResources(
        IDS_STATUS_CMDLINE_OPTION,
        strCmdLineOption,
        ARRAY_LEN( strCmdLineOption ) );

    if( bResult && argc == 2 && _tcsicmp( argv[ 1 ], strCmdLineOption ) == 0 )
    {
        //
        // this will exit process
        //

        DumpSysIoVerifierStatus();
    }

    DisplayHelpInformation();
}

///////////////////////////////////////////////////////////

void
DisplayHelpInformation()
{
    PrintStringFromResources( IDS_HELP_LINE1 );

    puts( VER_LEGALCOPYRIGHT_STR );

    PrintStringFromResources( IDS_HELP_LINE3 );
    PrintStringFromResources( IDS_HELP_LINE4 );
    PrintStringFromResources( IDS_HELP_LINE5 );
    PrintStringFromResources( IDS_HELP_LINE6 );
    PrintStringFromResources( IDS_HELP_LINE7 );
    PrintStringFromResources( IDS_HELP_LINE8 );
    PrintStringFromResources( IDS_HELP_LINE9 );

    exit( EXIT_CODE_NOTHING_CHANGED );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\idlemon\idlemon.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    idlemon.c

Abstract:

    Little program for recording the various idle states of a machine

Author:

    John Vert (jvert) 1/14/2000

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <conio.h>

#define DISPLAY_TOTAL 0
#define DISPLAY_DELTA 1
#define DISPLAY_RAW   2

int Display=DISPLAY_TOTAL;
int ShowTransitions=FALSE;

#define printtime(_x_) {                                               \
        ULONGLONG ms = (_x_)/10000;                                    \
        ULONG hours, minutes, seconds;                                 \
        hours = (ULONG)ms/(1000*60*60);                                \
        if (hours) printf("%3d:",(ULONG)(ms/(1000*60*60)));            \
        ms=ms%(1000*60*60);                                            \
        minutes = (ULONG)ms/(1000*60);                                 \
        if (minutes || hours) printf("%02d:",(ULONG)(ms/(1000*60)));   \
        ms=ms%(1000*60);                                               \
        seconds = (ULONG)ms/1000;                                      \
        printf("%02d.",seconds);                                       \
        ms=ms%1000;                                                    \
        printf("%03d",(ULONG)ms);                                      \
    }

__cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    CHAR Buff[sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION)*MAXIMUM_PROCESSORS];
    PSYSTEM_PROCESSOR_IDLE_INFORMATION IdleInfo = (PSYSTEM_PROCESSOR_IDLE_INFORMATION)Buff;
    ULONG Length;
    NTSTATUS Status;
    ULONGLONG LastIdleTime[MAXIMUM_PROCESSORS];
    ULONGLONG LastC1Time[MAXIMUM_PROCESSORS], LastC2Time[MAXIMUM_PROCESSORS], LastC3Time[MAXIMUM_PROCESSORS];
    ULONG LastC1Transitions[MAXIMUM_PROCESSORS], LastC2Transitions[MAXIMUM_PROCESSORS], LastC3Transitions[MAXIMUM_PROCESSORS];
    ULONG i,NumProc;
    LARGE_INTEGER Delay;
    ULONGLONG DeltaTime;
    ULONGLONG Diff;
    ULONG Delta;

    for (i=0;i<MAXIMUM_PROCESSORS;i++) {
        LastIdleTime[i] = LastC1Time[i] = LastC2Time[i] = LastC3Time[i] = 0;
        LastC1Transitions[i] = LastC2Transitions[i] = LastC3Transitions[i] = 0;

    }

    Delay.QuadPart = -5 * 1000 * 1000 * 10;
    printf("TOT IDLE     TOTC1    TOTC2  TOTC3    DELTA IDLE  DELTAC1    DELTAC2    DELTAC3\n");

    while (1) {
        if (_kbhit()) {
            int Char=_getch();
            switch (toupper(Char)) {
                case 'T':
                    Display = DISPLAY_TOTAL;
                    break;
                case 'D':
                    Display = DISPLAY_DELTA;
                    break;
                case 'R':
                    Display = DISPLAY_RAW;
                    break;
                case 'C':
                    ShowTransitions = !ShowTransitions;
                    break;
                case 'P':
                    printf("Hit a key to continue\n");
                    _getch();
                    break;
                case 'Q':
                    return;

                default:
                    printf("Type :\n");
                    printf("\t'T' - display Total\n");
                    printf("\t'D' - display Delta\n");
                    printf("\t'R' - display Raw\n");
                    printf("\t'C' - toggle between transition Counts and time\n");
                    printf("\t'P' - Pause\n");
                    printf("\t'Q' - quit\n");

            }
        }
        Status = NtQuerySystemInformation(SystemProcessorIdleInformation,
                                          IdleInfo,
                                          sizeof(Buff),
                                          &Length);
        if (!NT_SUCCESS(Status)) {
            fprintf(stderr, "NtQuerySystemInformation failed: %lx\n",Status);
            return(Status);
        }
        NumProc = Length/sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION);
        for (i=0;i<NumProc;i++) {
            if (NumProc > 1) {
                printf("%2d>",i);
            } else {
                printf("   ");
            }
            if (ShowTransitions) {
                switch (Display) {
                    case DISPLAY_TOTAL:
                        printf("Idle ");
                        printtime(IdleInfo[i].IdleTime);
                        printf("  C1 %d (%d us)",
                               IdleInfo[i].C1Transitions,
                               IdleInfo[i].C1Transitions ? 
                               (ULONG)(IdleInfo[i].C1Time*10/IdleInfo[i].C1Transitions):0);
                        printf("  C2 %d (%d us)",
                               IdleInfo[i].C2Transitions,
                               IdleInfo[i].C2Transitions ?
                               (ULONG)(IdleInfo[i].C2Time*10/IdleInfo[i].C2Transitions):0);
                        printf("  C3 %d (%d us)",
                               IdleInfo[i].C3Transitions,
                               IdleInfo[i].C3Transitions ?
                               (ULONG)(IdleInfo[i].C3Time*10/IdleInfo[i].C3Transitions):0);
                        break;

                    case DISPLAY_DELTA:
                        printf("Idle ");
                        DeltaTime = IdleInfo[i].IdleTime-LastIdleTime[i];
                        printtime(DeltaTime);
                        DeltaTime = IdleInfo[i].C1Time-LastC1Time[i];
                        Delta = IdleInfo[i].C1Transitions-LastC1Transitions[i];
                        printf("  C1 %d (%d us)",
                               Delta,
                               (Delta == 0) ? 0 : (ULONG)(DeltaTime/10/Delta));
                        DeltaTime = IdleInfo[i].C2Time-LastC2Time[i];
                        Delta = IdleInfo[i].C2Transitions-LastC2Transitions[i];
                        printf("  C2 %d (%d us)",
                               Delta,
                               (Delta == 0) ? 0 : (ULONG)(DeltaTime/10/Delta));
                        DeltaTime = IdleInfo[i].C3Time-LastC3Time[i];
                        Delta = IdleInfo[i].C3Transitions-LastC3Transitions[i];
                        printf("  C3 %d (%d us)",
                               Delta,
                               (Delta == 0) ? 0 : (ULONG)(DeltaTime/10/Delta));
                        break;

                    case DISPLAY_RAW:
                        printf("Idle %I64X  C1 %d  C2 %d  C3 %d",
                               IdleInfo[i].IdleTime,
                               IdleInfo[i].C1Transitions,
                               IdleInfo[i].C2Transitions,
                               IdleInfo[i].C3Transitions);
                        break;

                }
            } else {
                switch (Display) {
                    case DISPLAY_TOTAL:
                        printf("Idle ");
                        printtime(IdleInfo[i].IdleTime);
                        printf("  C1 ");
                        printtime(IdleInfo[i].C1Time);
                        printf("(%2d%%)  C2 ",IdleInfo[i].C1Time*100/IdleInfo[i].IdleTime);
                        printtime(IdleInfo[i].C2Time);
                        printf("(%2d%%)  C3 ",IdleInfo[i].C2Time*100/IdleInfo[i].IdleTime);
                        printtime(IdleInfo[i].C3Time);
                        printf("(%2d%%) ",IdleInfo[i].C3Time*100/IdleInfo[i].IdleTime);
                        break;

                    case DISPLAY_DELTA:
                        printf("Idle ");
                        printtime(IdleInfo[i].IdleTime-LastIdleTime[i]);
                        printf("  C1 ");
                        printtime(IdleInfo[i].C1Time-LastC1Time[i]);
                        DeltaTime = IdleInfo[i].C1Time-LastC1Time[i];
                        Diff = IdleInfo[i].IdleTime - LastIdleTime[i];
                        printf("(%2d%%)  C2 ",(Diff == 0 ? 0 : (DeltaTime * 100 / Diff) ) );
                        DeltaTime = IdleInfo[i].C2Time-LastC2Time[i];
                        printtime(IdleInfo[i].C2Time-LastC2Time[i]);
                        printf("(%2d%%)  C3 ",(Diff == 0 ? 0 : (DeltaTime * 100/ Diff) ) );
                        DeltaTime = IdleInfo[i].C3Time-LastC3Time[i];
                        printtime(IdleInfo[i].C3Time-LastC3Time[i]);
                        printf("(%2d%%) ",(Diff == 0 ? 0 : (DeltaTime * 100 / Diff) ) );
                        break;
                    case DISPLAY_RAW:
                        printf("Idle %I64X  C1 %I64X  C2 %I64X  C3 %I64X",
                               IdleInfo[i].IdleTime,
                               IdleInfo[i].C1Time,
                               IdleInfo[i].C2Time,
                               IdleInfo[i].C3Time);
                        break;
                }

            }


            LastIdleTime[i] = IdleInfo[i].IdleTime;
            LastC1Time[i] = IdleInfo[i].C1Time;
            LastC2Time[i] = IdleInfo[i].C2Time;
            LastC3Time[i] = IdleInfo[i].C3Time;

            LastC1Transitions[i] = IdleInfo[i].C1Transitions;
            LastC2Transitions[i] = IdleInfo[i].C2Transitions;
            LastC3Transitions[i] = IdleInfo[i].C3Transitions;

            printf("\n");
        }
        NtDelayExecution(FALSE, &Delay);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ioverify\regutil.cxx ===
//                                          
// System level IO verification configuration utility
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: regutil.cxx
// author: DMihai
// created: 04/19/99
// description: registry keys manipulation routines
//

extern "C" {
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
}

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>

#include "ResId.hxx"
#include "ResUtil.hxx"
#include "RegUtil.hxx"

#define VRF_MAX_DRIVER_STRING_LENGTH    4196

//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Registry Strings
//////////////////////////////////////////////////////////////////////

LPCTSTR RegMemoryManagementKeyName = 
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

LPCTSTR RegMmVerifyDriverLevelValueName =
    TEXT ("VerifyDriverLevel");

LPCTSTR RegVerifyDriversValueName =
TEXT ("VerifyDrivers");

LPCTSTR RegSessionManagerKeyName = 
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager");

LPCTSTR RegIOVerifyKeyName = 
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\I/O System");

LPCTSTR RegIOVerifySubKeyName = 
    TEXT ("I/O System");

LPCTSTR RegIOVerifyLevelValueName =
    TEXT ("IoVerifierLevel");

//////////////////////////////////////////////////////////////////////
/////////////// Forward decl for local registry manipulation functions
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (
    HKEY hKey,
    LPCTSTR Name,
    DWORD * Value);

BOOL
WriteRegistryValue (
    HKEY hKey,
    LPCTSTR Name,
    DWORD Value);

BOOL
ReadRegistryString (
    HKEY hKey,
    LPCTSTR Name,
    LPTSTR Buffer,
    DWORD BufferSize );

BOOL
WriteRegistryString (
    HKEY hKey,
    LPCTSTR Name,
    LPTSTR Value);

BOOL
IsKernelVerifierEnabled( HKEY MmKey );

//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Public functions
//////////////////////////////////////////////////////////////////////

void
EnableSysIoVerifier(
    DWORD dwNewVerifierLevel )
{
    HKEY MmKey = NULL;
    HKEY IoKey = NULL;
    HKEY SmKey = NULL;
    DWORD dwExitCode;
    DWORD dwCrtFlags;
    DWORD dwCrtSysVerifierLevel;
    LONG lResult;

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &MmKey);

    if (lResult != ERROR_SUCCESS) 
    {
        dwExitCode = EXIT_CODE_ERROR;

        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            DisplayErrorMessage( 
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lResult);
        }
    }
    else
    {
        if( IsKernelVerifierEnabled( MmKey ) )
        {
            //
            // must disable kernel verifier first
            //

            dwExitCode = EXIT_CODE_ERROR;

            DisplayErrorMessage( IDS_KVERIFY_ENABLED );
        }
        else
        {
            //
            // Open the "I/O System" key
            //

            lResult = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                RegIOVerifyKeyName,
                0,
                KEY_QUERY_VALUE | KEY_WRITE,
                &IoKey);

            if( lResult != ERROR_SUCCESS )
            {
                dwExitCode = EXIT_CODE_ERROR;

                if( lResult == ERROR_ACCESS_DENIED ) 
                {
                    //
                    // access is denied
                    //

                    DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
                }
                else
                {
                    if( lResult == ERROR_FILE_NOT_FOUND ) 
                    {
                        //
                        // the "I/O System" key doesn't exist, try to create it
                        //

                        //
                        // open the "Session Manager" key
                        //

                        lResult = RegOpenKeyEx (
                            HKEY_LOCAL_MACHINE,
                            RegSessionManagerKeyName,
                            0,
                            KEY_QUERY_VALUE | KEY_WRITE,
                            &SmKey);

                        if( lResult != ERROR_SUCCESS )
                        {
                            DisplayErrorMessage( 
                                IDS_REGOPENKEYEX_FAILED,
                                RegSessionManagerKeyName,
                                (DWORD)lResult);
                        }
                        else
                        {
                            //
                            // create the "I/O System" key
                            //

                            lResult = RegCreateKeyEx(
                                SmKey,
                                RegIOVerifySubKeyName,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE | KEY_QUERY_VALUE,
                                NULL,
                                &IoKey,
                                NULL );

                            if( lResult != ERROR_SUCCESS )
                            {
                                DisplayErrorMessage( 
                                    IDS_REGCREATEKEYEX_FAILED,
                                    RegIOVerifySubKeyName,
                                    (DWORD)lResult);
                            }
                            else
                            {
                                //
                                // recover from RegOpenKeyEx failure - reset the error code
                                //

                                dwExitCode = EXIT_CODE_NOTHING_CHANGED;
                            }

                            //
                            // close the "Session Manager" key
                            //

                            lResult = RegCloseKey(
                                SmKey );
                        }
                    }
                    else
                    {
                        // 
                        // other error opening the "I/O System" key
                        //
                    
                        DisplayErrorMessage( 
                            IDS_REGOPENKEYEX_FAILED,
                            RegIOVerifyKeyName,
                            (DWORD)lResult);
                    }
                }
            }

            if( dwExitCode != EXIT_CODE_ERROR )
            {
                //
                // read "Mm\VerifyDriverLevel" value
                //

                if( ReadRegistryValue( MmKey, RegMmVerifyDriverLevelValueName, &dwCrtFlags ) == FALSE )
                {
                    dwExitCode = EXIT_CODE_ERROR;
                }
                else
                {
                    if( dwCrtFlags == -1 )
                    {
                        //
                        // could not find the value
                        //
                    
                        dwCrtFlags = 0;
                    }

                    if( ( dwCrtFlags & DRIVER_VERIFIER_IO_CHECKING ) == 0 )
                    {
                        //
                        // set DRIVER_VERIFIER_IO_CHECKING bit in "Mm\VerifyDriverLevel" value
                        //

                        dwCrtFlags |= DRIVER_VERIFIER_IO_CHECKING ;

                        if( WriteRegistryValue( MmKey, RegMmVerifyDriverLevelValueName, dwCrtFlags ) == FALSE )
                        {
                            //
                            // cannot recover from this
                            //

                            dwExitCode = EXIT_CODE_ERROR;
                        }
                        else
                        {
                            dwExitCode = EXIT_CODE_REBOOT;
                        }
                    }
                }

                if( dwExitCode != EXIT_CODE_ERROR )
                {
                    if( ReadRegistryValue( IoKey, RegIOVerifyLevelValueName, &dwCrtSysVerifierLevel ) == FALSE )
                    {
                        dwExitCode = EXIT_CODE_ERROR;
                    }
                    else
                    {
                        if( dwCrtSysVerifierLevel != dwNewVerifierLevel )
                        {
                            //
                            // set "I/O System\IoVerifierLevel" value
                            //

                            if( WriteRegistryValue( IoKey, RegIOVerifyLevelValueName, dwNewVerifierLevel ) == FALSE )
                            {
                                //
                                // cannot recover from this
                                //

                                dwExitCode = EXIT_CODE_ERROR;
                            }
                            else
                            {
                                dwExitCode = EXIT_CODE_REBOOT;
                            }
                        }
                    }
                }

                RegCloseKey (IoKey);
            }
        }

        RegCloseKey (MmKey);
    }

    if( EXIT_CODE_REBOOT == dwExitCode )
    {
        DisplayErrorMessage( IDS_MUST_REBOOT );
    }
    else
    {
        if( EXIT_CODE_NOTHING_CHANGED == dwExitCode )
        {
            DisplayErrorMessage( IDS_NOTHING_CHANGED );
        }
    }

    exit( dwExitCode );
}

///////////////////////////////////////////////////////////////////

void
DisableSysIoVerifier( void )
{
    HKEY MmKey = NULL;
    HKEY IoKey = NULL;
    DWORD dwExitCode;
    DWORD dwCrtFlags;
    LONG lResult;

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &MmKey);

    if (lResult != ERROR_SUCCESS) 
    {
        dwExitCode = EXIT_CODE_ERROR;

        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            DisplayErrorMessage( 
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lResult);
        }
    }
    else
    {
        //
        // read "Mm\VerifyDriverLevel" value
        //

        if( ReadRegistryValue( MmKey, RegMmVerifyDriverLevelValueName, &dwCrtFlags ) == FALSE )
        {
            dwExitCode = EXIT_CODE_ERROR;
        }
        else
        {
            if( ( dwCrtFlags != -1 ) && 
                ( ( dwCrtFlags & DRIVER_VERIFIER_IO_CHECKING ) != 0 ) )
            {
                //
                // wipe out the DRIVER_VERIFIER_IO_CHECKING flag
                //

                dwCrtFlags &= ~DRIVER_VERIFIER_IO_CHECKING;

                if( WriteRegistryValue( MmKey, RegMmVerifyDriverLevelValueName, dwCrtFlags ) == FALSE )
                {
                    //
                    // cannot recover from this
                    //

                    dwExitCode = EXIT_CODE_ERROR;
                }
                else
                {
                    dwExitCode = EXIT_CODE_REBOOT;
                }
            }
        }

        RegCloseKey (MmKey);
    }

    if( dwExitCode != EXIT_CODE_ERROR )
    {
        //
        // open the "I/O" key
        //

        lResult = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            RegIOVerifyKeyName,
            0,
            KEY_QUERY_VALUE | KEY_WRITE,
            &IoKey);

        if (lResult != ERROR_SUCCESS) 
        {
            if( lResult != ERROR_FILE_NOT_FOUND )
            {
                dwExitCode = EXIT_CODE_ERROR;

                if( lResult == ERROR_ACCESS_DENIED ) 
                {
                    DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
                }
                else 
                {
                    DisplayErrorMessage( 
                        IDS_REGOPENKEYEX_FAILED,
                        RegIOVerifyKeyName,
                        (DWORD)lResult);
                }
            }
        }
        else
        {
            //
            // delete "I/O System\IoVerifierLevel" value
            //

            lResult = RegDeleteValue(
                IoKey,
                RegIOVerifyLevelValueName );

            if( lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND )
            {
                dwExitCode = EXIT_CODE_ERROR;

                DisplayErrorMessage( 
                    IDS_REGDELETEVALUE_FAILED,
                    RegIOVerifyLevelValueName,
                    (DWORD)lResult);
            }
            
            RegCloseKey (IoKey);
        }
    }

    if( EXIT_CODE_REBOOT == dwExitCode )
    {
        DisplayErrorMessage( IDS_MUST_REBOOT );
    }
    else
    {
        if( EXIT_CODE_NOTHING_CHANGED == dwExitCode )
        {
            DisplayErrorMessage( IDS_NOTHING_CHANGED );
        }
    }

    exit( dwExitCode );
}

//////////////////////////////////////////////////

void
DumpSysIoVerifierStatus( void )
{
    HKEY MmKey = NULL;
    HKEY IoKey = NULL;
    DWORD dwExitCode;
    DWORD dwCrtFlags;
    DWORD dwCrtSysVerifLevel;
    LONG lResult;
    BOOL bMmFlagIsSet = FALSE;

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE,
        &MmKey);

    if (lResult != ERROR_SUCCESS) 
    {
        if( lResult != ERROR_FILE_NOT_FOUND )
        {
            dwExitCode = EXIT_CODE_ERROR;

            if( lResult == ERROR_ACCESS_DENIED ) 
            {
                DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
            }
            else 
            {
                DisplayErrorMessage( 
                    IDS_REGOPENKEYEX_FAILED,
                    RegMemoryManagementKeyName,
                    (DWORD)lResult);
            }
        }
    }
    else
    {
        //
        // read "Mm\VerifyDriverLevel" value
        //

        if( ReadRegistryValue( MmKey, RegMmVerifyDriverLevelValueName, &dwCrtFlags ) == FALSE )
        {
            dwExitCode = EXIT_CODE_ERROR;
        }
        else
        {
            if( ( dwCrtFlags != -1 ) && 
                ( ( dwCrtFlags & DRIVER_VERIFIER_IO_CHECKING ) != 0 ) )
            {
                //
                // DRIVER_VERIFIER_IO_CHECKING is set
                //
                
                bMmFlagIsSet = TRUE;
            }
        }


        RegCloseKey (MmKey);
    }

    if( dwExitCode != EXIT_CODE_ERROR && bMmFlagIsSet )
    {
        //
        // open the "I/O" key
        //

        lResult = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            RegIOVerifyKeyName,
            0,
            KEY_QUERY_VALUE | KEY_WRITE,
            &IoKey);

        if (lResult != ERROR_SUCCESS) 
        {
            if( lResult != ERROR_FILE_NOT_FOUND )
            {
                dwExitCode = EXIT_CODE_ERROR;

                if( lResult == ERROR_ACCESS_DENIED ) 
                {
                    DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
                }
                else 
                {
                    DisplayErrorMessage( 
                        IDS_REGOPENKEYEX_FAILED,
                        RegIOVerifyKeyName,
                        (DWORD)lResult);
                }
            }
        }
        else
        {
            //
            // read "I/O System\IoVerifierLevel" value
            //

            if( ReadRegistryValue( IoKey, RegIOVerifyLevelValueName, &dwCrtSysVerifLevel ) == FALSE )
            {
                dwExitCode = EXIT_CODE_ERROR;
            }
            
            RegCloseKey (IoKey);
        }
    }

    if( dwExitCode != EXIT_CODE_ERROR )
    {
        if( bMmFlagIsSet && 
            ( dwCrtSysVerifLevel == 2 || dwCrtSysVerifLevel == 3 ) )
        {
            DisplayErrorMessage( 
                IDS_VERIFIER_ENABLED_FORMAT,
                dwCrtSysVerifLevel);
        }
        else
        {
            DisplayErrorMessage( 
                IDS_VERIFIER_NOT_ENABLED_FORMAT );
        }
    }

    exit( dwExitCode );
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////// Local registry manipulation functions
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (

    HKEY hKey,
    LPCTSTR Name,
    DWORD * Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;
    
    //
    // default value
    //

    *Value = -1;
    
    Size = sizeof( *Value );
  
    Result = RegQueryValueEx (
        hKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Value),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) 
    {
        *Value = -1;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) 
    {
        DisplayErrorMessage ( 
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            Result);
      
        return FALSE;
    }
    
    if (Type != REG_DWORD) 
    {
        DisplayErrorMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);
      
        return FALSE;
    }
    
    if (Size != sizeof *Value) 
    {
        DisplayErrorMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_SIZE,
            Name);
      
        return FALSE;
    }
    
    return TRUE;
}



BOOL
WriteRegistryValue (

    HKEY hKey,
    LPCTSTR Name,
    DWORD Value)
{
    LONG Result;
    
    Result = RegSetValueEx (
        hKey,
        Name,
        0,
        REG_DWORD,
        (LPBYTE)(&Value),
        sizeof Value);


    if (Result != ERROR_SUCCESS) 
    {
        DisplayErrorMessage ( 
            IDS_REGSETVALUEEX_FAILED,
            Name,
            Result);
     
        return FALSE;
    }
    
    return TRUE;
}


BOOL
ReadRegistryString (

    HKEY hKey,
    LPCTSTR Name,
    LPTSTR Buffer,
    DWORD BufferSize )
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;
    
    //
    // default value
    //

    *Buffer = 0;

    Size = BufferSize;
  
    Result = RegQueryValueEx (
        hKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Buffer),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) 
    {
        *Buffer = 0;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) 
    {
        DisplayErrorMessage ( 
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            Result);
      
        return FALSE;
    }
    
    if (Type != REG_SZ) 
    {
        DisplayErrorMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);
      
        return FALSE;
    }
    
    return TRUE;
}


BOOL
WriteRegistryString (

    HKEY hKey,
    LPCTSTR Name,
    LPTSTR Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
   
    Result = RegSetValueEx (

        hKey,
        Name,
        0,
        REG_SZ,
        (LPBYTE)(Value),
        (_tcslen (Value) + 1) * sizeof (TCHAR));

    if (Result != ERROR_SUCCESS) 
    {
        DisplayErrorMessage ( 
            IDS_REGSETVALUEEX_FAILED,
            Name,
            Result);
      
        return FALSE;
    }
    
    return TRUE;
}

BOOL
IsKernelVerifierEnabled( HKEY MmKey )
{
    BOOL bKernelVerified;
    int nKernelModuleNameLen;
    TCHAR *pstrCrtNameMatch, *pstrSubstring, *pCrtChar;
    TCHAR strVrfDriver [VRF_MAX_DRIVER_STRING_LENGTH];
    const TCHAR strKernelModuleName[] = _T( "ntoskrnl.exe" );

    bKernelVerified = FALSE;

    if( ReadRegistryString (MmKey, RegVerifyDriversValueName, strVrfDriver, sizeof( strVrfDriver ) ) ) 
    {
        pstrSubstring = _tcsstr( strVrfDriver, strKernelModuleName );
    
        if( pstrSubstring != NULL )
        {
            // 
            // the name seems to be already there
            //

            pCrtChar = strVrfDriver;

            while( pCrtChar < pstrSubstring )
            {
                if( (*pCrtChar) != _T( ' ' ) && (*pCrtChar) != _T( '\t' ) )
                {
                    //
                    // non-blanc character before the name
                    //

                    break;
                }

                pCrtChar ++;
            }

            if( pCrtChar >= pstrSubstring )
            {
                //
                // the module name begins as the first non-blanc character
                //

                nKernelModuleNameLen = _tcsclen( strKernelModuleName );

                if( pstrSubstring[ nKernelModuleNameLen ] == (TCHAR)0    ||
                    pstrSubstring[ nKernelModuleNameLen ] == _T( ' ' )   ||
                    pstrSubstring[ nKernelModuleNameLen ] == _T( '\t' ) )
                {
                    bKernelVerified = TRUE;
                }
            }
        }
    }

    return bKernelVerified;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\iasinfdb\simtable.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997-1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    SimTable.h
//
// SYNOPSIS
//
//    This file describes the class CSimpleTable
//
// MODIFICATION HISTORY
//
//    10/31/1997    Original version.
//    02/09/1998    Reorganized some things to make is easier to extend.
//                  Thierry Perraut
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _SIMTABLE_H_
#define _SIMTABLE_H_

#include <atlbase.h>
#include <oledb.h>
#include <bitvec.h>
struct DBBinding;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CSimpleTable
//
// DESCRIPTION
//
//    This class provides a simple read-only wrapper for iterating through a
//    rowset and retrieving information.  The interface is based on the ATL
//    CTable<> class. I kept all the function signatures the same, so the two
//    should be almost interchangeable. The main difference is that CTable<>
//    opens a table and retrieves a rowset, while CSimpleTable is handed a
//    rowset that was retrieved elsewhere.
//
///////////////////////////////////////////////////////////////////////////////
class CSimpleTable
{
public:

   CSimpleTable();
   ~CSimpleTable();

   HRESULT Attach(IRowset* pRowset);
   IRowset* Detach();

   HRESULT MoveFirst();
   HRESULT MoveNext();

   HRESULT Insert();
   HRESULT Delete();
   HRESULT SetData();

   void DiscardChanges()
   {
      dirty.reset();
   }

   DBORDINAL GetColumnCount() const
   {
      return numColumns;
   }

   DBCOLUMNFLAGS GetColumnFlags(DBORDINAL nOrdinal) const
   {
      return columnInfo[OrdinalToColumn(nOrdinal)].dwFlags;
   }

   LPCWSTR GetColumnName(DBORDINAL nOrdinal) const
   {
      return columnInfo[OrdinalToColumn(nOrdinal)].pwszName;
   }

   DBTYPE GetColumnType(DBORDINAL nOrdinal) const
   {
      return columnInfo[OrdinalToColumn(nOrdinal)].wType;
   }

   DBLENGTH GetLength(DBORDINAL nOrdinal) const;

   bool GetOrdinal(LPCWSTR szColumnName, DBORDINAL* pOrdinal) const;

   DBSTATUS GetStatus(DBORDINAL nOrdinal) const;

   const void* GetValue(DBORDINAL nOrdinal) const
   {
      return _GetDataPtr(nOrdinal);
   }

   template <class T>
   void SetValue(DBORDINAL nOrdinal, const T& t)
   {
      *(T*)_GetDataPtr(nOrdinal) = t;
   }

   void SetValue(DBORDINAL nOrdinal, PCSTR szValue)
   {
      strcpy((PSTR)_GetDataPtr(nOrdinal), szValue);
   }

   void SetValue(DBORDINAL nOrdinal, PSTR szValue)
   {
      strcpy((PSTR)_GetDataPtr(nOrdinal), szValue);
   }

   bool HasBookmark() const
   {
      return (numColumns > 0) && (columnInfo->iOrdinal == 0);
   }

protected:

   enum { FETCH_QUANTUM = 256 };   // The number of rows fetched at a time.

   HRESULT CreateAccessorForWrite(HACCESSOR* phAccessor);

   void* _GetDataPtr(DBORDINAL nOrdinal);

   const void* _GetDataPtr(DBORDINAL nOrdinal) const
   {
      return buffer +
             (ULONG_PTR)columnInfo[OrdinalToColumn(nOrdinal)].pTypeInfo;
   }

   HRESULT ReleaseRows();

   DBORDINAL OrdinalToColumn(DBORDINAL nOrdinal) const
   {
      return nOrdinal -= columnInfo->iOrdinal;
   }

   // Various representations of the rowset being manipulated.
   CComPtr<IRowset> rowset;
   CComPtr<IAccessor> accessor;
   CComPtr<IRowsetChange> rowsetChange;

   DBORDINAL numColumns;      // Number of columns in the table.
   DBCOLUMNINFO* columnInfo;  // Column info.
   OLECHAR* stringsBuffer;    // Buffer used by columnInfo.
   DBBinding* columnBinding;  // Column bindings.
   HACCESSOR readAccess;      // Handle for read accessor.
   PBYTE buffer;              // Accessor buffer.
   DBLENGTH bufferLength;     // Length of accessor buffer.
   HROW row[FETCH_QUANTUM];   // Array of row handles.
   DBCOUNTITEM numRows;       // Number of rows in the row array.
   DBCOUNTITEM currentRow;    // Current row being accessed.
   BitVector dirty;           // Columns that have been modified.
   bool endOfRowset;          // True if we've reached the end of the rowset.
};

#endif  // _SIMTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kbdtool\getopt.c ===
/*
        getopt.c

        modified public-domain AT&T getopt(3)
*/

#include <stdio.h>
#include <string.h>

#ifdef _POSIX_SOURCE
#       include <unistd.h>
#else
#       define STDERR_FILENO 2
#       ifdef __STDC__
                extern int write (int fildes, char * buf, unsigned nbyte);
#       else
                extern int write ();
#       endif
#endif

int opterr = 1;
int optind = 1;
int optopt;
char *optarg;

static void ERR(char **argv, char *s, char c)
{
    if (opterr) {
        fprintf(stderr, "%s%s%c\n", argv[0], s, c);
    }
}

int getopt(int argc, char **argv, char *opts)
{
    static int sp = 1, error = (int) '?';
    static char sw = '-', eos = '\0', arg = ':';
    char c, * cp;

    if (sp == 1)
        if (optind >= argc || argv[optind][0] != sw
            || argv[optind][1] == eos)
            return EOF;
        else if (strcmp(argv[optind],"--") == 0) {
            optind++;
            return EOF;
        }
    c = argv[optind][sp];
    optopt = (int) c;
    if (c == arg || (cp = strchr(opts,c)) == NULL) {
        ERR(argv,": illegal option: -",c);
        if (argv[optind][++sp] == eos) {
            optind++;
            sp = 1;
        }
        return error;
    }
    else if (*++cp == arg) {
        if (argv[optind][sp + 1] != eos)
            optarg = &argv[optind++][sp + 1];
        else if (++optind >= argc) {
            ERR(argv,": option requires an argument--",c);
            sp = 1;
            return error;
        }
        else
            optarg = argv[optind++];
        sp = 1;
    }
    else {
        if (argv[optind][++sp] == eos) {
            sp = 1;
            optind++;
        }
        optarg = NULL;
    }
    return (int)c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ioverify\resutil.cxx ===
//
// System level IO verification configuration utility
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: resutil.cxx
// author: DMihai
// created: 04/19/99
// description: resources manipulation routines
//

#include <windows.h>
#include <tchar.h>

#include "resutil.hxx"

//////////////////////////////////////////////////////////////////////

BOOL
GetStringFromResources(
    UINT uIdResource,
    TCHAR *strResult,
    int nBufferLen )
{
    UINT LoadStringResult;

    LoadStringResult = LoadString (
        GetModuleHandle (NULL),
        uIdResource,
        strResult,
        nBufferLen );

    assert_ (LoadStringResult > 0);

    return (LoadStringResult > 0);
}

//////////////////////////////////////////////////////////////////////
void
PrintStringFromResources(

    UINT uIdResource)
{
    TCHAR strStringFromResource[ 1024 ];
    BOOL bResult;

    bResult = GetStringFromResources(
        uIdResource,
        strStringFromResource,
        ARRAY_LEN( strStringFromResource ) );

    if( bResult == TRUE )
    {
        _putts( strStringFromResource );
    }
}

//////////////////////////////////////////////////////////////////////

void
__cdecl
DisplayErrorMessage(
    UINT uFormatResId,
    ... )
{
    TCHAR strMsgFormat[ 256 ];
    BOOL bResult;
    va_list prms;

    va_start (prms, uFormatResId);

    bResult = GetStringFromResources(
        uFormatResId,
        strMsgFormat,
        ARRAY_LEN( strMsgFormat ) );

    if( bResult == TRUE )
    {
        _vtprintf ( strMsgFormat, prms);
        _tprintf ( _TEXT( "\n" ) );
    }

    va_end (prms);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\job\query.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    job.c

Abstract:

    A user mode app that allows creation and management of jobs.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>

#include "jobmgr.h"

typedef struct {
    char Option;
    JOBOBJECTINFOCLASS InfoClass;
    char *Name;
    DWORD (*Function)(HANDLE Job, JOBOBJECTINFOCLASS InfoClass);
} JOB_QUERY_OPTION, *PJOB_QUERY_OPTION;

#define MKOPTION(optChar, optClass) {optChar, optClass, #optClass, Dump##optClass}

DWORD DumpJobObjectBasicProcessIdList(HANDLE JobHandle, 
                                      JOBOBJECTINFOCLASS InfoClass);
DWORD DumpJobObjectBasicUIRestrictions(HANDLE JobHandle, 
                                      JOBOBJECTINFOCLASS InfoClass);
DWORD 
DumpJobObjectBasicAndIoAccountingInformation(
    HANDLE JobHandle, 
    JOBOBJECTINFOCLASS InfoClass
    );

DWORD 
DumpJobObjectExtendedLimitInformation(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    );

DWORD 
DumpJobObjectSecurityLimitInformation(
    HANDLE JobHandle, 
    JOBOBJECTINFOCLASS InfoClass
    );

JOB_QUERY_OPTION JobInfoClasses[] = {
    MKOPTION('a', JobObjectBasicAndIoAccountingInformation),
    MKOPTION('l', JobObjectExtendedLimitInformation),
    MKOPTION('p', JobObjectBasicProcessIdList),
    MKOPTION('s', JobObjectSecurityLimitInformation),
    MKOPTION('u', JobObjectBasicUIRestrictions),
    {'\0', 0, NULL}
};


DWORD
QueryJobCommand(
    IN PCOMMAND CommandEntry,
    IN int argc, 
    IN char* argv[]
    )
{
    CHAR defaultOptions[] = {'p', '\0'};
    PTSTR options;
    PTSTR jobName;

    HANDLE job;

    int i;

    BOOLEAN matchAll = FALSE;

    DWORD status;

    if(argc == 0) {
        return -1;
    }

    GetAllProcessInfo();

    if((argc > 1) && (argv[0][0] == '-')) {

        // a - accounting & io
        // l - extended limit info
        // p - process id list
        // u - basic ui restrictions
        // s - security limits

        options = &(argv[0][1]);

        argc -= 1;
        argv += 1;
    } else {
        options = defaultOptions;
    }

    if(strchr(options, '*') != NULL) {
       if(strlen(options) != 1) {
           puts("Cannot specify '*' with other flags");
           return -1;
       } else {
           matchAll = TRUE;
           options = defaultOptions;
       }
    }

    jobName = argv[0];

    printf("Opening job object %s\n", jobName);

    job = OpenJobObject(JOB_OBJECT_QUERY, FALSE, jobName);

    if(job == NULL) {
        return GetLastError();
    }

    for(i = 0; JobInfoClasses[i].Option != '\0'; i++) {
        LPSTR match;

        if(!matchAll) {
            match = strchr(options, JobInfoClasses[i].Option);
    
            if(match == NULL) {
                continue;
            }
    
            //
            // Clear the option so we can report the invalid option flags at the 
            // end.
            //
    
            *match = ' ';
        }

        printf("%s [%#x]:\n", JobInfoClasses[i].Name, 
                              JobInfoClasses[i].InfoClass);

        status = JobInfoClasses[i].Function(job, 
                                            JobInfoClasses[i].InfoClass);
        puts("");

        if(status != ERROR_SUCCESS) {
            DWORD length;
            LPSTR buffer;

            printf("Error %d querying info: ", status);

            length = FormatMessage((FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                    FORMAT_MESSAGE_FROM_SYSTEM |
                                    FORMAT_MESSAGE_IGNORE_INSERTS |
                                    (FORMAT_MESSAGE_MAX_WIDTH_MASK & 0)),
                                   NULL,
                                   status,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   (LPSTR) &buffer,
                                   1,
                                   NULL);

            if(length != 0) {
                puts(buffer);
                LocalFree(buffer);
            }
        }
    }

    if(!matchAll) {
        LPSTR header = "Option flag not understood:";
        while(options[0] != '\0') {
            if(options[0] != ' ') {
                printf("%s %c", header, options[0]);
                header = "";
            }
            options += 1;
        }
    }

    CloseHandle(job);
    return ERROR_SUCCESS;
}

DWORD 
DumpJobObjectBasicProcessIdList(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    )
{
    JOBOBJECT_BASIC_PROCESS_ID_LIST buffer;
    PJOBOBJECT_BASIC_PROCESS_ID_LIST idList = NULL;
    
    ULONG bufferSize;

    BOOL result;
    DWORD status;

    DWORD i;

    result = QueryInformationJobObject(Job, 
                                       InfoClass, 
                                       &buffer, 
                                       sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST),
                                       NULL);
    status = GetLastError();

    if((!result) && (status != ERROR_MORE_DATA)) {
        return status;
    }

    do {
        
        if(idList != NULL) {
            buffer.NumberOfAssignedProcesses = 
                idList->NumberOfAssignedProcesses;
            LocalFree(idList);
            idList = NULL;
        }

        //
        // Calculate the actual size of the list and allocate a buffer to hold it.
        //
    
        bufferSize = offsetof(JOBOBJECT_BASIC_PROCESS_ID_LIST, ProcessIdList);
        bufferSize += sizeof(ULONG_PTR) * buffer.NumberOfAssignedProcesses;
    
        assert(idList == NULL);
        idList = LocalAlloc(LPTR, bufferSize);
    
        if(idList == NULL) {
            return GetLastError();
        }

        result = QueryInformationJobObject(Job,
                                           InfoClass,
                                           idList,
                                           bufferSize,
                                           NULL);

        status = GetLastError();

        if((!result) && (status != ERROR_MORE_DATA)) {
            LocalFree(idList);
            return status;
        }

    } while(idList->NumberOfAssignedProcesses > 
            idList->NumberOfProcessIdsInList);

    assert(idList->NumberOfAssignedProcesses == 
           idList->NumberOfProcessIdsInList);

    //
    // Dump the information.
    //

    printf("  %d processes assigned to job:\n", 
           idList->NumberOfAssignedProcesses);

    for(i = 0; i < idList->NumberOfAssignedProcesses; i++) {
        printf("%8d", idList->ProcessIdList[i]);
        PrintProcessInfo(idList->ProcessIdList[i]);
        puts("");
    }

    FreeProcessInfo();
    LocalFree(idList);
    return ERROR_SUCCESS;
}

DWORD 
DumpJobObjectBasicUIRestrictions(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    )
{
    JOBOBJECT_BASIC_UI_RESTRICTIONS uiLimit;
    
    static FLAG_NAME jobUiLimitFlags[] = {
        FLAG_NAME(JOB_OBJECT_UILIMIT_HANDLES          ), //0x00000001
        FLAG_NAME(JOB_OBJECT_UILIMIT_READCLIPBOARD    ), //0x00000002
        FLAG_NAME(JOB_OBJECT_UILIMIT_WRITECLIPBOARD   ), //0x00000004
        FLAG_NAME(JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS ), //0x00000008
        FLAG_NAME(JOB_OBJECT_UILIMIT_DISPLAYSETTINGS  ), //0x00000010
        FLAG_NAME(JOB_OBJECT_UILIMIT_GLOBALATOMS      ), //0x00000020
        FLAG_NAME(JOB_OBJECT_UILIMIT_DESKTOP          ), //0x00000040
        FLAG_NAME(JOB_OBJECT_UILIMIT_EXITWINDOWS      ), //0x00000080
        {0,0}
    };
    
    BOOL result;
    DWORD status;

    DWORD i;

    result = QueryInformationJobObject(Job, 
                                       InfoClass, 
                                       &uiLimit, 
                                       sizeof(JOBOBJECT_BASIC_UI_RESTRICTIONS),
                                       NULL);
    status = GetLastError();

    if(!result) {
        return status;
    }

    if(uiLimit.UIRestrictionsClass == JOB_OBJECT_UILIMIT_NONE) {
        printf("  Job has no UI restrictions\n");
        return ERROR_SUCCESS;
    }

    DumpFlags(2, 
              "UI Restrictions", 
              uiLimit.UIRestrictionsClass, 
              jobUiLimitFlags);

    return ERROR_SUCCESS;
}

DWORD 
DumpJobObjectBasicAndIoAccountingInformation(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    )
{
    JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION info;
    
    BOOL result;
    DWORD status;

    DWORD i;

    result = QueryInformationJobObject(
                Job, 
                InfoClass, 
                &info, 
                sizeof(JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),
                NULL);
    status = GetLastError();

    if(!result) {
        return status;
    }

    xprintf(2, "Basic Info\n");
    xprintf(4, "TotalUserTime: %s\n", TicksToString(info.BasicInfo.TotalUserTime));
    xprintf(4, "TotalKernelTime: %s\n", TicksToString(info.BasicInfo.TotalKernelTime));
    xprintf(4, "ThisPeriodTotalUserTime: %s\n", TicksToString(info.BasicInfo.ThisPeriodTotalUserTime));
    xprintf(4, "ThisPeriodTotalKernelTime: %s\n", TicksToString(info.BasicInfo.ThisPeriodTotalKernelTime));
    xprintf(4, "TotalPageFaultCount: %d\n", info.BasicInfo.TotalPageFaultCount);
    xprintf(4, "TotalProcesses: %d\n", info.BasicInfo.TotalProcesses);
    xprintf(4, "ActiveProcesses: %d\n", info.BasicInfo.ActiveProcesses);
    xprintf(4, "TotalTerminatedProcesses: %d\n",  info.BasicInfo.TotalTerminatedProcesses);

    xprintf(2, "I/O Info\n");

    xprintf(4, "ReadOperationCount: %I64d\n", info.IoInfo.ReadOperationCount);
    xprintf(4, "WriteOperationCount: %I64d\n", info.IoInfo.WriteOperationCount);
    xprintf(4, "OtherOperationCount: %I64d\n", info.IoInfo.OtherOperationCount);
    xprintf(4, "ReadTransferCount: %I64d\n", info.IoInfo.ReadTransferCount);
    xprintf(4, "WriteTransferCount: %I64d\n", info.IoInfo.WriteTransferCount);
    xprintf(4, "OtherTransferCount: %I64d\n", info.IoInfo.OtherTransferCount);

    return ERROR_SUCCESS;
}

DWORD 
DumpJobObjectExtendedLimitInformation(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    )
{
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION info;
    ULONG limits;
    
    static FLAG_NAME basicJobLimitFlags[] = {
        FLAG_NAME(JOB_OBJECT_LIMIT_WORKINGSET                 ), //0x00000001
        FLAG_NAME(JOB_OBJECT_LIMIT_PROCESS_TIME               ), //0x00000002
        FLAG_NAME(JOB_OBJECT_LIMIT_JOB_TIME                   ), //0x00000004
        FLAG_NAME(JOB_OBJECT_LIMIT_ACTIVE_PROCESS             ), //0x00000008
        FLAG_NAME(JOB_OBJECT_LIMIT_AFFINITY                   ), //0x00000010
        FLAG_NAME(JOB_OBJECT_LIMIT_PRIORITY_CLASS             ), //0x00000020
        FLAG_NAME(JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME          ), //0x00000040
        FLAG_NAME(JOB_OBJECT_LIMIT_SCHEDULING_CLASS           ), //0x00000080
        {0,0}
    };

//
// Extended Limits
//
    static FLAG_NAME extendedJobLimitFlags[] = {
        FLAG_NAME(JOB_OBJECT_LIMIT_PROCESS_MEMORY             ), //0x00000100
        FLAG_NAME(JOB_OBJECT_LIMIT_JOB_MEMORY                 ), //0x00000200
        FLAG_NAME(JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION ), //0x00000400
        FLAG_NAME(JOB_OBJECT_LIMIT_BREAKAWAY_OK               ), //0x00000800
        FLAG_NAME(JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK        ), //0x00001000
        FLAG_NAME(JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE          ), //0x00002000

        FLAG_NAME(JOB_OBJECT_LIMIT_RESERVED2                  ), //0x00004000
        FLAG_NAME(JOB_OBJECT_LIMIT_RESERVED3                  ), //0x00008000
        FLAG_NAME(JOB_OBJECT_LIMIT_RESERVED4                  ), //0x00010000
        FLAG_NAME(JOB_OBJECT_LIMIT_RESERVED5                  ), //0x00020000
        FLAG_NAME(JOB_OBJECT_LIMIT_RESERVED6                  ), //0x00040000
        {0,0}
    };

    BOOL result;
    DWORD status;

    DWORD i;

    result = QueryInformationJobObject(
                Job, 
                InfoClass, 
                &info, 
                sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
                NULL);

    status = GetLastError();

    if(!result) {
        return status;
    }

    limits = info.BasicLimitInformation.LimitFlags;

    if(TEST_FLAG(limits, JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS) == 0) {
        xprintf(2, "No basic limits on job\n");
    } else {
        DumpFlags(2, "Basic Limit Flags", limits & JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS, basicJobLimitFlags);
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_PROCESS_TIME)) {
            xprintf(4, "PerProcessUserTimeLimit: %s\n", TicksToString(info.BasicLimitInformation.PerProcessUserTimeLimit));
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_JOB_TIME)) {
            xprintf(4, "PerJobUserTimeLimit: %s\n", TicksToString(info.BasicLimitInformation.PerJobUserTimeLimit));
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_WORKINGSET)) {
            xprintf(4, "MinimumWorkingSetSize: %I64d\n", (ULONGLONG) info.BasicLimitInformation.MinimumWorkingSetSize);
            xprintf(4, "MaximumWorkingSetSize: %I64d\n", (ULONGLONG) info.BasicLimitInformation.MaximumWorkingSetSize);
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_ACTIVE_PROCESS)) {
            xprintf(4, "ActiveProcessLimit: %d\n",info.BasicLimitInformation.ActiveProcessLimit);
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_AFFINITY)) {
            xprintf(4, "Affinity: %#I64x\n", (ULONGLONG)info.BasicLimitInformation.Affinity);
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_PRIORITY_CLASS)) {
            xprintf(4, "PriorityClass: %d\n",info.BasicLimitInformation.PriorityClass);
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_SCHEDULING_CLASS)) {
            xprintf(4, "SchedulingClass: %d\n",info.BasicLimitInformation.SchedulingClass);
        }
    }

    if(TEST_FLAG(limits, JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS) == 0) {
        xprintf(2, "No extended limits on job\n");
    } else {

        DumpFlags(2, "Extended Limit Flags", limits & JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS & ~JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS, extendedJobLimitFlags);
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_PROCESS_MEMORY)) {
            xprintf(4, "ProcessMemoryLimit: %I64d\n", (ULONGLONG) info.ProcessMemoryLimit);
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_PROCESS_MEMORY)) {
            xprintf(4, "JobMemoryLimit: %I64d\n", (ULONGLONG) info.JobMemoryLimit);
        }
    }

    xprintf(2, "PeakProcessMemoryUsed: %I64d\n", (ULONGLONG) info.PeakProcessMemoryUsed);
    xprintf(2, "PeakJobMemoryUsed: %I64d\n", (ULONGLONG) info.PeakJobMemoryUsed);

    return ERROR_SUCCESS;
}

DWORD 
DumpJobObjectSecurityLimitInformation(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    )
{
    JOBOBJECT_SECURITY_LIMIT_INFORMATION buffer;
    PJOBOBJECT_SECURITY_LIMIT_INFORMATION info = NULL;
    
    static FLAG_NAME jobSecurityLimitFlags[] = {
        FLAG_NAME(JOB_OBJECT_SECURITY_NO_ADMIN            ), //00000001
        FLAG_NAME(JOB_OBJECT_SECURITY_RESTRICTED_TOKEN    ), //00000002
        FLAG_NAME(JOB_OBJECT_SECURITY_ONLY_TOKEN          ), //00000004
        FLAG_NAME(JOB_OBJECT_SECURITY_FILTER_TOKENS       ), //00000008
        {0, 0}
    };

    ULONG bufferSize;

    BOOL result;
    DWORD status;

    DWORD i;

    result = QueryInformationJobObject(
                Job, 
                InfoClass, 
                &buffer, 
                sizeof(JOBOBJECT_SECURITY_LIMIT_INFORMATION),
                &bufferSize);

    status = GetLastError();

    if((!result) && (status != ERROR_MORE_DATA)) {
        return status;
    }

    info = LocalAlloc(LPTR, bufferSize);

    if(info == NULL) {
        return GetLastError();
    }

    result = QueryInformationJobObject(Job, InfoClass, info, bufferSize, NULL);

    if(!result) {
        status = GetLastError();
        LocalFree(info);
        return status;
    }

    if(info->SecurityLimitFlags == 0) {
        xprintf(2, "No security limitations on job\n");
    } else {
        DumpFlags(2, "SecurityLimitFlags", info->SecurityLimitFlags, jobSecurityLimitFlags);
    }

    LocalFree(info);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\job\proc.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    proc.c

Abstract:

    Code for dumping information about processes using the NT API rather than 
    the win32 API.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#define PROCESS_BUFFER_INCREMENT (16 * 4096)

PSYSTEM_PROCESS_INFORMATION ProcessInfo = NULL;
DWORD ProcessInfoLength;


VOID
GetAllProcessInfo(
    VOID
    )
{
    PSYSTEM_PROCESS_INFORMATION buffer;
    DWORD bufferSize = 1 * PROCESS_BUFFER_INCREMENT;

    NTSTATUS status;

    assert(ProcessInfo == NULL);

    do {
        buffer = LocalAlloc(LMEM_FIXED, bufferSize);

        if(buffer == NULL) {
            return;
        }

        status = NtQuerySystemInformation(SystemProcessInformation,
                                          buffer,
                                          bufferSize,
                                          &ProcessInfoLength);

        if(status == STATUS_INFO_LENGTH_MISMATCH) {

            LocalFree(buffer);
            bufferSize += PROCESS_BUFFER_INCREMENT;
            continue;
        }

    } while(status == STATUS_INFO_LENGTH_MISMATCH);

    if(NT_SUCCESS(status)) {
        ProcessInfo = buffer;
    }
}


VOID
PrintProcessInfo(
    DWORD_PTR ProcessId
    )
{
    PSYSTEM_PROCESS_INFORMATION info;

    if(ProcessInfo == NULL) {
        return;
    }

    info = ProcessInfo;

    do {

        if(ProcessId == (DWORD_PTR) info->UniqueProcessId) {

            printf(": %.*S", 
                   (info->ImageName.Length / sizeof(WCHAR)), 
                   info->ImageName.Buffer);

            break;
        }

        info = (PSYSTEM_PROCESS_INFORMATION) (((ULONG_PTR) info) + 
                                              info->NextEntryOffset);
    } while((ULONG_PTR) info <= (ULONG_PTR) ProcessInfo + ProcessInfoLength);
}


VOID
FreeProcessInfo(
    VOID
    )
{
    LocalFree(ProcessInfo);
    ProcessInfo = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\job\job.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    job.c

Abstract:

    A user mode app that allows creation and management of jobs.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>

#include "jobmgr.h"

void PrintHelp(char *Command);

DWORD TestCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD HelpCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD CreateJobCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD KillJobCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD ExecuteCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD QueryJobCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD AssignProcessCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD SetPriorityCommand(PCOMMAND CommandEntry,int argc, char *argv[]);

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

COMMAND CommandArray[] = {
    {"create", 
     "creates the specified job object", 
     "jobmgr create [-s] <job name>\n"
        "  Creates a job object with the specified name.\n"
        "    -s - jobmgr will sleep after creating the job object until cancelled.\n"
        "    <job name> - specifies the job name.\n",
     CreateJobCommand
    },

    {"exec",
     "executes a program in the specified job object",
     "jobmgr exec <job name> <command> [args ...]\n"
        "  Executes the command in the specified job.\n"
        "    <command> - [quoted] string specifying the command any any arguments.\n",
     ExecuteCommand
    },

    {"help", 
     "help for all commands", 
     "jobmgr help [command]\n"
        "  Lists help for specified command or all commands.\n", 
     HelpCommand},

    {"assign", 
     "assigns a process to the specified job",
     "jobmgr assign <job name> <process id>\n"
        "  Associates the process with the specified job.\n",
     AssignProcessCommand
    },

    {"kill",
     "kills a job object and associated processes",
     "kill <job name>\n",
     KillJobCommand},

    {"query",
     "queries information about a job object",
     "query [-alpsu | -*] <job name>\n"
        "  a - dump accounting (basic & io) information\n"
        "  l - dump limit (basic & extended) information\n"
        "  p - dump process ID list\n"
        "  s - dump security limit information\n"
        "  u - dump UI restrictions\n"
        "  * - dump all information (cannot be specified with other options)\n"
        "  if no options are specified the process ID list will be dumped\n.",
     QueryJobCommand},

    {"setpriority",
     "Sets priority for processes within the job 0 - 5.  0 = Idle, 5 = Realtime, 2 = Normal.",
     "setpriority <job name> <priority>\n",
     SetPriorityCommand},

    {"test", 
     NULL, 
     "jobmgr test [arg]...\n", 
     TestCommand},

    {NULL, NULL, NULL}
    };

int __cdecl main(int argc, char *argv[])
{
    int i = 0;

    if(argc < 2) {
        puts("Usage: jobmgr <command> [parameters]");
        puts("possible commands: ");
        HelpCommand(NULL, 0 , NULL);
        puts("");
        return -1;
    }

    //
    // Iterate through the command array and find the correct function to
    // call.
    //

    while(CommandArray[i].Name != NULL) {

        if(strcmp(argv[1], CommandArray[i].Name) == 0) {
            DWORD status;

            status = (CommandArray[i].Function)(&(CommandArray[i]), 
                                                (argc - 2), 
                                                &(argv[2]));

            if(status == -1) {
                PrintHelp(CommandArray[i].Name);
                return -1;
            } else if(status != 0) {
                DWORD length;
                PVOID buffer;

                printf("Error: command %s returned status %d\n", 
                       CommandArray[i].Name, status);

                length = FormatMessage((FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_FROM_SYSTEM |
                                        FORMAT_MESSAGE_IGNORE_INSERTS |
                                        (FORMAT_MESSAGE_MAX_WIDTH_MASK & 0)),
                                       NULL,
                                       status,
                                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                       (LPTSTR) &buffer,
                                       1,
                                       NULL);

                if(length != 0) {
                    puts(buffer);
                    LocalFree(buffer);
                }
            }

            break;
        }

        i++;
    }

    if(CommandArray[i].Name == NULL) {
        printf("Unknown command %s\n", argv[2]);
    }

    return 0;
}

VOID
PrintBuffer(
    IN  PUCHAR Buffer,
    IN  SIZE_T Size
    )
{
    DWORD offset = 0;

    while (Size > 0x10) {
        printf( "%08x:"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "\n",
                offset,
                *(Buffer +  0), *(Buffer +  1), *(Buffer +  2), *(Buffer +  3),
                *(Buffer +  4), *(Buffer +  5), *(Buffer +  6), *(Buffer +  7),
                *(Buffer +  8), *(Buffer +  9), *(Buffer + 10), *(Buffer + 11),
                *(Buffer + 12), *(Buffer + 13), *(Buffer + 14), *(Buffer + 15)
                );
        Size -= 0x10;
        offset += 0x10;
        Buffer += 0x10;
    }

    if (Size != 0) {

        DWORD spaceIt;

        printf("%08x:", offset);
        for (spaceIt = 0; Size != 0; Size--) {

            if ((spaceIt%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *Buffer);
            spaceIt++;
            Buffer++;
        }
        printf("\n");

    }
    return;
}

DWORD TestCommand(PCOMMAND commandEntry, int argc, char *argv[])
/*++

Routine Description:

    Tests the command "parsing"

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{
    int i;
    DWORD result = ERROR_SUCCESS;

    printf("Test - %d additional arguments\n", argc);

    for(i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }

    if(argc >= 1) {
        result = atoi(argv[0]);
    }

    printf("returning %d\n", result);

    return result;
}

void PrintHelp(char *Command)
/*++

Routine Description:

    Prints detailed help for a particular command.

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i;

    assert(Command != NULL);

    for(i = 0; CommandArray[i].Name != NULL; i++) {
        COMMAND *entry;

        entry = &(CommandArray[i]);

        if(_stricmp(entry->Name, Command) == 0) {
            if(entry->ExtendedHelp != NULL) {
                printf("%s", entry->ExtendedHelp);
            } else {
                printf("  %s - %s\n", entry->Name, entry->Description);
            }
            return;
        }
    }

    printf("Command %s not recognized\n", Command);

    return;
}

DWORD HelpCommand(PCOMMAND commandEntry, int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i = 0;

    if(argc >= 1) {

        PrintHelp(argv[0]);

    } else for(i = 0; CommandArray[i].Name != NULL; i++) {

        COMMAND *entry;

        entry = &(CommandArray[i]);

        if(entry->Description != NULL) {
            printf("  %s - %s\n", entry->Name, entry->Description);
        }
    }

    return ERROR_SUCCESS;
}


DWORD CreateJobCommand(PCOMMAND CommandEntry, int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    BOOL sleep = FALSE;
    LPCTSTR jobName;

    HANDLE job;

    //
    // Get the name of the job object from the arguments.
    //

    if(argc <= 0) {
        return -1;
    } else if(argc == 1) {
        jobName = argv[0];
    } else {
        if((argv[0][0] == '-') && (tolower(argv[0][1] == 's'))) {
            sleep = TRUE;
        }
        jobName = argv[1];
    }

    printf("Creating job %s\n", jobName);

    job = CreateJobObject(NULL, jobName);

    if(job == NULL) {
        DWORD status = GetLastError();

        printf("Error %d occurred creating job\n", status);
        return status;
    }

    printf("Job object %s created\n", jobName);

    if(sleep) {
        puts("Sleeping...");
        SleepEx(INFINITE, TRUE);
        puts("process alerted - exiting");
    }

    //
    // Destroy the job object.
    //

    CloseHandle(job);

    return ERROR_SUCCESS;
}

ULONG PriorityTable[] =  { IDLE_PRIORITY_CLASS,
                           BELOW_NORMAL_PRIORITY_CLASS,
                           NORMAL_PRIORITY_CLASS,
                           ABOVE_NORMAL_PRIORITY_CLASS,
                           HIGH_PRIORITY_CLASS,
                           REALTIME_PRIORITY_CLASS };

DWORD
SetPriorityCommand(
    PCOMMAND CommandEntry,
    int argc, 
    char *argv[]
    )
{
    LPCTSTR jobName;
    int i;
    DWORD status;
    ULONG Priority;
    HANDLE Job;

    JOBOBJECT_BASIC_LIMIT_INFORMATION Limits;

    if(argc < 2) {
        return -1;
    }

    //
    // extract job name and priority.
    // 

    jobName = argv[0];
    Priority = atoi(argv[1]);

    if (Priority > 5)  {
        printf("Priority must be 0 - 5\n");
        return ERROR_INVALID_PARAMETER;
    }
    
    //
    // Open a handle to the specified job object.
    //

    Job = OpenJobObject(JOB_OBJECT_SET_ATTRIBUTES , FALSE, jobName);

    if(Job == NULL) {
        return GetLastError();
    }

    //
    //  And set the priority limit.
    //

    memset( &Limits, 0, sizeof( Limits));

    Limits.PriorityClass = PriorityTable[Priority];
    Limits.LimitFlags = JOB_OBJECT_LIMIT_PRIORITY_CLASS;

    if (!SetInformationJobObject(Job, 
                                 JobObjectBasicLimitInformation,
                                 (PVOID)&Limits,
                                 sizeof(Limits))) {
        CloseHandle(Job);
        return GetLastError();
    }
    
    CloseHandle(Job);
    return 0;
}


DWORD
ExecuteCommand(
    PCOMMAND CommandEntry,
    int argc, 
    char *argv[]
    )
{
    LPCTSTR jobName;

    ULONG commandLineLength = 0;
    LPTSTR commandLine = NULL;
    LPTSTR tmp;

    SECURITY_ATTRIBUTES security;
    HANDLE job;

    STARTUPINFO startupInfo;
    PROCESS_INFORMATION processInfo;

    int i;
    DWORD status;

    if(argc < 2) {
        return -1;
    }

    //
    // save the job name and push argc/argv forward.
    // 

    jobName = argv[0];
    argv += 1;
    argc -= 1;

    //
    // Create a command line to hand to CreateProcess.  Start by counting the 
    // number of bytes necessary for the buffer.
    //

    for(i = 0; i < argc; i++) {
        commandLineLength += strlen(argv[i]);
        commandLineLength += 1;

        //
        // If there's a space in the argument then leave room for quotes
        // around it.
        //

        if(strchr(argv[i], ' ') != NULL) {
            commandLineLength += 2;
        }
    }

    commandLineLength += 1;

    commandLine = LocalAlloc(LPTR, commandLineLength * sizeof(char));

    if(commandLine == NULL) {
        status = GetLastError();
        return status;
    }

    //
    // Now copy each argument string into the buffer.
    //

    tmp = commandLine;

    for(i = 0; i < argc; i++) {
        ULONG size;
        BOOLEAN containsSpace;

        if(strchr(argv[i], ' ') != NULL) {
            containsSpace = TRUE;
            *tmp = '\"';
            tmp += 1;
        } else {
            containsSpace = FALSE;
        }

        size = strlen(argv[i]);
        memcpy(tmp, argv[i], size);

        if(containsSpace) {
            tmp[size] = '\"';
            tmp += 1;
        }

        tmp[size] = ' ';
        tmp += size + 1;
    }

    printf("Command Arguments are %s\n", commandLine);

    //
    // Open a handle to the specified job object.
    //

    printf("Opening job %s\n", jobName);

    security.nLength = sizeof(SECURITY_ATTRIBUTES);
    security.lpSecurityDescriptor = NULL;
    security.bInheritHandle = TRUE;

    job = CreateJobObject(&security, jobName);

    if(job == NULL) {
        status = GetLastError();
        LocalFree(commandLine);
        return status;
    }

    printf("Creating process '%s'\n", commandLine);

    GetStartupInfo(&startupInfo);

    //
    // Create the process but leave it suspended so we can assign it to the
    // job we created before it starts running.
    //

    if(!CreateProcess(NULL,
                      commandLine,
                      NULL,
                      NULL,
                      TRUE,
                      (CREATE_NEW_CONSOLE | CREATE_SUSPENDED),
                      NULL,
                      NULL,
                      &startupInfo,
                      &processInfo)) {
        status = GetLastError();
        CloseHandle(job);
        LocalFree(commandLine);
        return status;
    }

    //
    // Assign the process to the job.
    //

    printf("Assigning process %d to job %s\n", 
           processInfo.dwProcessId, jobName);

    if(!AssignProcessToJobObject(job, processInfo.hProcess)) {
        status = GetLastError();

        TerminateProcess(processInfo.hProcess, ERROR_SUCCESS);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);
        CloseHandle(job);
        LocalFree(commandLine);

        return status;
    }

    //
    // Unsuspend the process.
    //

    if(ResumeThread(processInfo.hThread) == -1) {
        status = GetLastError();

        TerminateProcess(processInfo.hProcess, ERROR_SUCCESS);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);
        CloseHandle(job);
        LocalFree(commandLine);

        return status;
    }

    //
    // Close all our handles.
    //

    CloseHandle(processInfo.hProcess);
    CloseHandle(processInfo.hThread);
    CloseHandle(job);
    LocalFree(commandLine);

    return ERROR_SUCCESS;
}


DWORD
KillJobCommand(
    IN PCOMMAND CommandEntry,
    IN int argc, 
    IN char* argv[]
    )
{
    HANDLE job;
    DWORD status;

    if(argc <= 0) {
        return -1;
    }

    job = OpenJobObject(JOB_OBJECT_TERMINATE, FALSE, argv[0]);

    if(job == NULL) {
        return GetLastError();
    }

    TerminateJobObject(job, ERROR_PROCESS_ABORTED);

    status = GetLastError();

    CloseHandle(job);
    return status;
}


DWORD
AssignProcessCommand(
    IN PCOMMAND CommandEntry,
    IN int argc, 
    IN char* argv[]
    )
{
    HANDLE job;

    DWORD processId;
    HANDLE process;

    DWORD status = ERROR_SUCCESS;

    if(argc != 2) {
        return -1;
    }

    processId = strtoul(argv[1], NULL, 10);

    printf("process id %s = %d\n", argv[1], processId);

    if(processId == 0) {
        printf("Invalid process id %s\n", argv[1]);
        return -1;
    }

    //
    // Open the job first.
    //

    job = OpenJobObject(JOB_OBJECT_ASSIGN_PROCESS, FALSE, argv[0]);

    if(job == NULL) {
        return GetLastError();
    }

    //
    // Open the process now.
    //

    process = OpenProcess(PROCESS_SET_QUOTA | PROCESS_TERMINATE,
                          FALSE,
                          processId);

    if(process == NULL) {
        status = GetLastError();
        CloseHandle(job);
        return status;
    }

    //
    // Assign the process to the job.
    //

    if(!AssignProcessToJobObject(job, process)) {
        status = GetLastError();
    }

    CloseHandle(job);
    CloseHandle(process);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\job\jobmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    proc.h

Abstract:

    Definitions for dumping information about processes using the NT API 
    rather than the win32 API.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int

#ifdef DBG
#define dbg(x) x
#define HELP_ME() printf("Reached line %4d\n", __LINE__);
#else
#define dbg(x)    /* x */
#define HELP_ME() /* printf("Reached line %4d\n", __LINE__); */
#endif

#define ARGUMENT_USED(x)    (x == NULL)

#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

typedef struct _COMMAND COMMAND, *PCOMMAND;

struct _COMMAND {
    char *Name;
    char *Description;
    char *ExtendedHelp;
    DWORD (*Function)(PCOMMAND CommandEntry, int argc, char *argv[]);
};

extern COMMAND CommandArray[];

VOID
GetAllProcessInfo(
    VOID
    );

VOID
PrintProcessInfo(
    DWORD_PTR ProcessId
    );

VOID
FreeProcessInfo(
    VOID
    );

DWORD 
QueryJobCommand(
    PCOMMAND commandEntry, 
    int argc, 
    char *argv[]
    );


VOID
xprintf(
    ULONG  Depth,
    PTSTR Format,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PTSTR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

LPCTSTR
TicksToString(
    LARGE_INTEGER TimeInTicks
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kbdtool\kbdx.h ===
/****************************** Module Header ******************************\
* Module Name: kbdx.h
*
* Copyright (c) 1985-95, Microsoft Corporation
*
* History:
* 26-Mar-1995 a-KChang
\***************************************************************************/

#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <time.h>
#include <windef.h>

#define KBDSHIFT 1
#define KBDCTRL  2
#define KBDALT   4

#define CAPLOK      0x01
#define SGCAPS      0x02
#define CAPLOKALTGR 0x04

#define LINEBUFSIZE  256
#define WORDBUFSIZE   32
#define MAXWCLENGTH    8
#define MAXKBDNAME     6
#define MAXSTATES     65
#define FILENAMESIZE  13
#define FAILURE        0
#define SUCCESS        1

/*
 * max. number of characters per ligature.
 * Currently only the Arabic layouts use
 * ligatures, and they have a maximum of
 * two characters per ligatures.  This should
 * provide plenty of room for growth.
 */
#define MAXLIGATURES   5

/*
 * Statically initialized to store default ScanCode-VK relation
 * Copied into Layout[] by doLAYOUT()
 */
typedef struct {
  USHORT Scan;
  BYTE   VKey;
  char  *VKeyName;
  BOOL   bUsed;
} SC_VK;

/* virtual key name, used only by those other than 0-9 and A-Z */
typedef struct {
  int   VKey;
  char *pName;
} VKEYNAME;

/* store LAYOUT */
typedef struct _layout{
  USHORT          Scan;
  BYTE            VKey;
  BYTE            VKeyDefault;    /* VK for this Scancode as in kbd.h */
  BYTE            Cap;            /* 0; 1 = CAPLOK; 2 = SGCAP         */
  int             nState;         /* number of valid states for WCh[] */
  int             WCh[MAXSTATES];
  int             DKy[MAXSTATES]; /* is it a dead key ?               */
  int             LKy[MAXSTATES]; /* is it a ligature ?               */
  struct _layout *pSGCAP;         /* store extra struct for SGCAP     */
  char *          VKeyName;       /* Optional name for VK             */
  BOOL            defined;        /* prevent redefining               */
  int             nLine;          /* from input file line number      */
} KEYLAYOUT, *PKEYLAYOUT;

/* generic link list header */
typedef struct {
  int   Count;
  void *pBeg;
  void *pEnd;
} LISTHEAD;

/* store each DEADTRANS */
typedef struct _DeadTrans {
  DWORD               Base;
  DWORD               WChar;
  USHORT              uFlags;
  struct _DeadTrans *pNext;
} DEADTRANS, *PDEADTRANS;

/* store Key Name */
/* store each DEADKEY */
typedef struct _Dead{
  DWORD        Dead;
  PDEADTRANS   pDeadTrans;
  struct _Dead *pNext;
} DEADKEY, *PDEADKEY;

/* store LIGATURE */
typedef struct _ligature{
  struct _ligature *pNext;
  BYTE             VKey;
  BYTE             Mod;            /* Shift State                            */
  int              nCharacters;    /* number of characters for this ligature */
  int              WCh[MAXLIGATURES];
} LIGATURE, *PLIGATURE;

typedef struct _Name {
  DWORD          Code;
  char         *pName;
  struct _Name *pNext;
} KEYNAME, *PKEYNAME;


extern int getopt(int argc, char **argv, char *opts);
extern int optind;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kbdtool\kbdtxt2c.c ===
/******************************* Module Header *******************************\
* Module Name: KBDTXT2C.C
*
* Copyright (c) 1985-2001, Microsoft Corporation
*
* History:
* 1995-03-26  a-KChang
* 1997-06-13  GregoryW  v2.00  BiDi Support
* 1997-06-19  IanJa     v2.01  Add ATTRIBUTES section
* 1998-03-04  IanJa     v3.0   Add dead key composition can be dead char too
*                              (Useful for CAN/CSA, Serge Caron @ Attachmate
*                               and a customer of Eliyas Yakub's)
* 1998-05-01  HiroYama  v3.01  -k switch to make fallback layout for win32k.sys
* 1998-05-08  IanJa     v3.02  new E1 scancodes allowed
* 1998-05-19  v-thief   v3.03  Add IA64 support. Implies that the data arrays
*                              are located in the long data section.
*                              Uses IA64 compiler specific pragmas.
*                              data_seg() is not explicit enough.
* 1998-05-20  v-thief   v3.04  For the fallback layout in win32k.sys, we are
*                              not relocating the data in long data section.
* 1998-10-29  WKwok     v3.05  Specify VER_LANGNEUTRAL in RC.
* 1998-12-03  IanJa     v3.06  Add SpeedRacer VKs, include strid.h
* 1999-01-12  IanJa     v3.07  check for dup VKs, beautify, improve VkKeyScan
* 1999-01-28  v-thief   v3.08  fixed IA64 warnings for .data section. The new
*                              IA64 compiler defaults to a "long" attribute
*                              for this known section.
* 1999-02-11  IanJa     v3.09  check for dup chars (for VkKeyScanEx's sake)
* 1999-03-25  IanJa     v3.10  no more vkoem.h (get VKs from winuser.h)
* 1999-03-31  IanJa     v3.11  comment out spurious DumpLayoutEntry() call
* 2001-06-28  Hiroyama  v3.12  fix the upper case warnings etc..
                               putting the sanity check in "-W".
\*****************************************************************************/

#include <windows.h>
#include <winuserp.h>
#include "kbdx.h"

DWORD gVersion = 3;
DWORD gSubVersion = 12;

char *KeyWord[] = { /* used by isKeyWord() */
  "KBD",            /*  0 */
  "VERSION",        /*  1 */
  "MODIFIERS",      /*  2 */
  "SHIFTSTATE",     /*  3 */
  "ATTRIBUTES",     /*  4 */
  "LAYOUT",         /*  5 */
  "DEADKEY",        /*  6 */
  "LIGATURE",       /*  7 */
  "KEYNAME",        /*  8 */
  "KEYNAME_EXT",    /*  9 */
  "KEYNAME_DEAD",   /* 10 */
  "ENDKBD",         /* 11 */
};
#define KEYWORD_KBD          0
#define KEYWORD_VERSION      1
#define KEYWORD_MODIFIERS    2
#define KEYWORD_SHIFTSTATE   3
#define KEYWORD_ATTRIBUTES   4
#define KEYWORD_LAYOUT       5
#define KEYWORD_DEADKEY      6
#define KEYWORD_LIGATURE     7
#define KEYWORD_KEYNAME      8
#define KEYWORD_KEYNAME_EXT  9
#define KEYWORD_KEYNAME_DEAD 10
#define KEYWORD_ENDKBD       11


#define NUMKEYWORD ( sizeof(KeyWord) / sizeof(char*) )

#define NOT_KEYWORD 999 /* a number bigger than NUMKEYWORD */

#define DEADKEYCODE 6   /* only DEADKEY can have multiple entries */

VKEYNAME VKName[] = {   /* used only by virtual keys other than 0-9 and A-Z */
    {VK_BACK,       "BACK"       },
    {VK_CANCEL,     "CANCEL"     },
    {VK_ESCAPE,     "ESCAPE"     },
    {VK_RETURN,     "RETURN"     },
    {VK_SPACE,      "SPACE"      },
    {VK_DECIMAL,    "DECIMAL"    },
    {VK_OEM_1,      "OEM_1"      },
    {VK_OEM_PLUS,   "OEM_PLUS"   },
    {VK_OEM_COMMA,  "OEM_COMMA"  },
    {VK_OEM_MINUS,  "OEM_MINUS"  },
    {VK_OEM_PERIOD, "OEM_PERIOD" },
    {VK_OEM_2,      "OEM_2"      },
    {VK_OEM_3,      "OEM_3"      },
    {VK_OEM_4,      "OEM_4"      },
    {VK_OEM_5,      "OEM_5"      },
    {VK_OEM_6,      "OEM_6"      },
    {VK_OEM_7,      "OEM_7"      },
    {VK_OEM_8,      "OEM_8"      },
    {VK_OEM_102,    "OEM_102"    },
    {0xC1,          "ABNT_C1"    },
    {0xC2,          "ABNT_C2"    },
    {VK_SHIFT,      "SHIFT"      },
    {VK_LSHIFT,     "LSHIFT"     },
    {VK_RSHIFT,     "RSHIFT"     },
    {VK_MENU,       "MENU"       },
    {VK_LMENU,      "LMENU"      },
    {VK_RMENU,      "RMENU"      },
    {VK_CONTROL,    "CONTROL"    },
    {VK_LCONTROL,   "LCONTROL"   },
    {VK_RCONTROL,   "RCONTROL"   },
    {VK_SEPARATOR,  "SEPARATOR"  },
    {VK_ICO_00,     "ICO_00"     },
    {VK_DELETE,     "DELETE"     },
    {VK_INSERT,     "INSERT"     },
    {VK_GROUPSHIFT, "GROUPSHIFT" },
    {VK_RGROUPSHIFT,"RGROUPSHIFT"},
};

#define NUMVKNAME ( sizeof(VKName) / sizeof(VKEYNAME) )

/*
 * Default ScanCode-VirtualKey relation
 *
 * Includes a comment string used only for E0 prefixed scancodes and
 * then only as a comment for aE0VscToVk[] entries in the output .C file
 *
 * This does not have to be ordered by scancode or virtual key code.
 * The order *does* affect VkKeyScan[Ex] - each aVkToWch*[] table is
 * ordered according to the order of the entries in this table.
 *
 *
 * Scan  VKey       comment
 * ====  =========  =======
 */
SC_VK ScVk[] = {
  {0x02, 0x31,      NULL},   /* 1          */
  {0x03, 0x32,      NULL},   /* 2          */
  {0x04, 0x33,      NULL},   /* 3          */
  {0x05, 0x34,      NULL},   /* 4          */
  {0x06, 0x35,      NULL},   /* 5          */
  {0x07, 0x36,      NULL},   /* 6          */
  {0x08, 0x37,      NULL},   /* 7          */
  {0x09, 0x38,      NULL},   /* 8          */
  {0x0a, 0x39,      NULL},   /* 9          */
  {0x0b, 0x30,      NULL},   /* 0          */
  {0x0c, 0xbd,      NULL},   /* OEM_MINUS  */
  {0x0d, 0xbb,      NULL},   /* OEM_PLUS   */
  {0x10, 0x51,      NULL},   /* Q          */
  {0x11, 0x57,      NULL},   /* W          */
  {0x12, 0x45,      NULL},   /* E          */
  {0x13, 0x52,      NULL},   /* R          */
  {0x14, 0x54,      NULL},   /* T          */
  {0x15, 0x59,      NULL},   /* Y          */
  {0x16, 0x55,      NULL},   /* U          */
  {0x17, 0x49,      NULL},   /* I          */
  {0x18, 0x4f,      NULL},   /* O          */
  {0x19, 0x50,      NULL},   /* P          */
  {0x1a, 0xdb,      NULL},   /* OEM_4      */
  {0x1b, 0xdd,      NULL},   /* OEM_6      */
  {0x1e, 0x41,      NULL},   /* A          */
  {0x1f, 0x53,      NULL},   /* S          */
  {0x20, 0x44,      NULL},   /* D          */
  {0x21, 0x46,      NULL},   /* F          */
  {0x22, 0x47,      NULL},   /* G          */
  {0x23, 0x48,      NULL},   /* H          */
  {0x24, 0x4a,      NULL},   /* J          */
  {0x25, 0x4b,      NULL},   /* K          */
  {0x26, 0x4c,      NULL},   /* L          */
  {0x27, 0xba,      NULL},   /* OEM_1      */
  {0x28, 0xde,      NULL},   /* OEM_7      */
  {0x29, 0xc0,      NULL},   /* OEM_3      */
  {0x2b, 0xdc,      NULL},   /* OEM_5      */
  {0x2c, 0x5a,      NULL},   /* Z          */
  {0x2d, 0x58,      NULL},   /* X          */
  {0x2e, 0x43,      NULL},   /* C          */
  {0x2f, 0x56,      NULL},   /* V          */
  {0x30, 0x42,      NULL},   /* B          */
  {0x31, 0x4e,      NULL},   /* N          */
  {0x32, 0x4d,      NULL},   /* M          */
  {0x33, 0xbc,      NULL},   /* OEM_COMMA  */
  {0x34, 0xbe,      NULL},   /* OEM_PERIOD */
  {0x35, 0xbf,      NULL},   /* OEM_2      */
  {0x56, 0xe2,      NULL},   /* OEM_102    */
  {0x73, 0xc1,      NULL},   /* ABNT_C1    */
  {0x7e, 0xc2,      NULL},   /* ABNT_C2    */


  // extended scancodes
  // The comment is only as a comment for aE0VscToVk[] entries
  // in the output .C file
  {0xE010, VK_MEDIA_PREV_TRACK, "Speedracer: Previous Track"   },
  {0xE019, VK_MEDIA_NEXT_TRACK, "Speedracer: Next Track"       },
  {0xE01D, VK_RCONTROL        , "RControl"                     },
  {0xE020, VK_VOLUME_MUTE     , "Speedracer: Volume Mute"      },
  {0xE021, VK_LAUNCH_APP2     , "Speedracer: Launch App 2"     },
  {0xE022, VK_MEDIA_PLAY_PAUSE, "Speedracer: Media Play/Pause" },
  {0xE024, VK_MEDIA_STOP      , "Speedracer: Media Stop"       },
  {0xE02E, VK_VOLUME_DOWN     , "Speedracer: Volume Down"      },
  {0xE030, VK_VOLUME_UP       , "Speedracer: Volume Up"        },
  {0xE032, VK_BROWSER_HOME    , "Speedracer: Browser Home"     },
  {0xE035, VK_DIVIDE          , "Numpad Divide"        },
  {0xE037, VK_SNAPSHOT        , "Snapshot"             },
  {0xE038, VK_RMENU           , "RMenu"                },
  {0xE047, VK_HOME            , "Home"                 },
  {0xE048, VK_UP              , "Up"                   },
  {0xE049, VK_PRIOR           , "Prior"                },
  {0xE04B, VK_LEFT            , "Left"                 },
  {0xE04D, VK_RIGHT           , "Right"                },
  {0xE04F, VK_END             , "End"                  },
  {0xE050, VK_DOWN            , "Down"                 },
  {0xE051, VK_NEXT            , "Next"                 },
  {0xE052, VK_INSERT          , "Insert"               },
  {0xE053, VK_DELETE          , "Delete"               },
  {0xE05B, VK_LWIN            , "Left Win"             },
  {0xE05C, VK_RWIN            , "Right Win"            },
  {0xE05D, VK_APPS            , "Application"          },

  // reserved (VKey == 0xff)
  {0xE05E,   0xff             , "Power"                },
  {0xE05F, VK_SLEEP           , "Speedracer: Sleep"    },
  {0xE060,   0xff             , "BAD SCANCODE"         }, // break would be 0xE0
  {0xE061,   0xff             , "BAD SCANCODE"         }, // break would be 0xE1

  // available for adding extended scancodes (VKey == 0x00)
  {0xE065, VK_BROWSER_SEARCH     , "Speedracer: Browser Search"       },
  {0xE066, VK_BROWSER_FAVORITES  , "Speedracer: Browser Favorites"    },
  {0xE067, VK_BROWSER_REFRESH    , "Speedracer: Browser Refresh"      },
  {0xE068, VK_BROWSER_STOP       , "Speedracer: Browser Stop"         },
  {0xE069, VK_BROWSER_FORWARD    , "Speedracer: Browser Forward"      },
  {0xE06A, VK_BROWSER_BACK       , "Speedracer: Browser Back"         },
  {0xE06B, VK_LAUNCH_APP1        , "Speedracer: Launch App 1"         },
  {0xE06C, VK_LAUNCH_MAIL        , "Speedracer: Launch Mail"          },
  {0xE06D, VK_LAUNCH_MEDIA_SELECT, "Speedracer: Launch Media Selector"},

  // These come near the end for VkKeyScan...
  {0x53,   VK_DECIMAL, NULL                  },  /* Numpad Decimal */
  {0x0e,   VK_BACK,    NULL                  },  /* Backspace      */
  {0x01,   VK_ESCAPE,  NULL                  },  /* Escape         */
  {0xE01C, VK_RETURN,  "Numpad Enter"        },
  {0x1c,   VK_RETURN,  NULL                  },  /* Enter          */
  {0x39,   VK_SPACE,   NULL                  },  /* Space          */
  {0xE046, VK_CANCEL, "Break (Ctrl + Pause)" },

  // ...but the 0xffff entries (for new scancodes) must come last
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },

};

#define NUMSCVK ( sizeof(ScVk) / sizeof(SC_VK) )

typedef struct {
    UINT Vk;
    char *pszModBits;
} MODIFIERS, *PMODIFIERS;

MODIFIERS Modifiers[] = {
    { VK_SHIFT,    "KBDSHIFT"   },
    { VK_CONTROL,  "KBDCTRL"    },
    { VK_MENU,     "KBDALT"     },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         }
};

char* StateLabel[] = {
  "",                 /* 0          */
  "Shift",            /* 1          */
  "  Ctrl",           /* 2          */
  "S+Ctrl",           /* 3          */
  "      Alt",        /* 4:not used */
  "Shift+Alt",        /* 5:not used */
  "  Ctl+Alt",        /* 6          */
  "S+Ctl+Alt",        /* 7          */
  "      X1   ",      /* 8          */
  "S+    X1   ",      /* 9           */
  "  C+  X1   ",      /* 10          */
  "S+C+  X1   ",      /* 11          */
  "    A+X1   ",      /* 12          */
  "S+  A+X1   ",      /* 13          */
  "  C+A+X1   ",      /* 14          */
  "S+C+A+X1   ",      /* 15          */
  "         X2",      /* 16          */
  "S+       X2",      /* 17          */
  "  C+     X2",      /* 18          */
  "S+C+     X2",      /* 19          */
  "    A+   X2",      /* 20          */
  "S+  A+   X2",      /* 21          */
  "  C+A+   X2",      /* 22          */
  "S+C+A+   X2",      /* 23          */
  "      X1+X2",      /* 24          */
  "S+    X1+X2",      /* 25          */
  "  C+  X1+X2",      /* 26          */
  "S+C+  X1+X2",      /* 27          */
  "    A+X1+X2",      /* 28          */
  "S+  A+X1+X2",      /* 29          */
  "  C+A+X1+X2",      /* 30          */
  "S+C+A+X1+X2",      /* 31          */
  "            X3",   /* 32          */
  "S+          X3",   /* 33          */
  "  C+        X3",   /* 34          */
  "S+C+        X3",   /* 35          */
  "    A+      X3",   /* 36          */
  "S+  A+      X3",   /* 37          */
  "  C+A+      X3",   /* 38          */
  "S+C+A+      X3",   /* 39          */
  "      X1+   X3",   /* 40          */
  "S+    X1+   X3",   /* 41          */
  "  C+  X1+   X3",   /* 42          */
  "S+C+  X1+   X3",   /* 43          */
  "    A+X1+   X3",   /* 44          */
  "S+  A+X1+   X3",   /* 45          */
  "  C+A+X1+   X3",   /* 46          */
  "S+C+A+X1+   X3",   /* 47          */
  "         X2+X3",   /* 48          */
  "S+       X2+X3",   /* 49          */
  "  C+     X2+X3",   /* 50          */
  "S+C+     X2+X3",   /* 51          */
  "    A+   X2+X3",   /* 52          */
  "S+  A+   X2+X3",   /* 53          */
  "  C+A+   X2+X3",   /* 54          */
  "S+C+A+   X2+X3",   /* 55          */
  "      X1+X2+X3",   /* 56          */
  "S+    X1+X2+X3",   /* 57          */
  "  C+  X1+X2+X3",   /* 58          */
  "S+C+  X1+X2+X3",   /* 59          */
  "    A+X1+X2+X3",   /* 60          */
  "S+  A+X1+X2+X3",   /* 61          */
  "  C+A+X1+X2+X3",   /* 62          */
  "S+C+A+X1+X2+X3",   /* 63          */
  "unexpected",       /* 64          */
  "unexpected",       /* 65          */
};

/*************************************************************\
* forward declarations                                       *
\*************************************************************/
BOOL  NextLine(char *Buf, DWORD cchBuf, FILE *fIn);
int   SkipLines(void);
int   isKeyWord(char *s);
int   getVKNum(char *pVK);
char *getVKName(int VK, BOOL prefixVK_);
int   doKBD();
int   doMODIFIERS();
int   doSHIFTSTATE(int *nState, int aiState[]);
int   doATTRIBUTES(char *szAttrs);
int   doLAYOUT(KEYLAYOUT Layout[], int aiState[], int nState);
int   doDEADKEY(PDEADKEY *ppDeadKey);
int   doLIGATURE(PLIGATURE *ppLigature);
int   doKEYNAME(PKEYNAME *ppKeyName);
int   kbd_h(KEYLAYOUT Layout[]);
int   kbd_rc(void);
int   kbd_def(void);
char *WChName(int WC, int Zero);
VOID __cdecl Error(const char *Text, ... );
ULONG __cdecl Warning(int nLine, const char *Text, ... );
VOID  DumpLayoutEntry(PKEYLAYOUT pLayout);
BOOL  MergeState(KEYLAYOUT[], int Vk, WCHAR, WCHAR, WCHAR, int aiState[], int nState);

int   kbd_c(int        nState,
            int        aiState[],
            char *     szAttrs,
            KEYLAYOUT  Layout[],
            PDEADKEY  pDeadKey,
            PLIGATURE pLigature,
            PKEYNAME  pKeyName,
            PKEYNAME  pKeyNameExt,
            PKEYNAME  pKeyNameDead);
void PrintNameTable(FILE *pOut, PKEYNAME pKN, BOOL bDead);

/*************************************************************\
* Global variables
\*************************************************************/
BOOL  verbose = FALSE;
BOOL  fallback_driver = FALSE;
BOOL  sanity_check = FALSE;
FILE *gfpInput;
char  gBuf[LINEBUFSIZE];
int   gLineCount;
LPSTR  gpszFileName;
char  gVKeyName[WORDBUFSIZE];
char  gKBDName[MAXKBDNAME];
char  gDescription[LINEBUFSIZE];
int gID = 0;
char  gCharName[WORDBUFSIZE];

struct tm *Now;
time_t Clock;


void usage()
{
    fprintf(stderr, "Usage: KbdTool [-v] [-k] file\n");
    fprintf(stderr, "\t[-?] display this message\n");
    fprintf(stderr, "\t[-v] verbose diagnostics/warnings\n");
    fprintf(stderr, "\t[-k] builds kbd layout for embedding in the kernel\n");
    fprintf(stderr, "\t[-W] performs sanity check\n");
    exit(EXIT_FAILURE);
}

/*************************************************************\
*  Main
\*************************************************************/
int _cdecl main(int argc, char** argv)
{
    int   c;
    int   i;
    int   nKW[NUMKEYWORD];    /* keep track of KeyWord read to prevent duplicates */
    int   iKW;
    int   nState;             /* number of states */
    int   aiState[MAXSTATES];
    char  szAttrs[128] = "\0";
    int   nTotal = 0;
    int   nFailH = 0;
    int   nFailC = 0;
    int   nFailRC = 0;
    int   nFailDEF = 0;

    KEYLAYOUT  Layout[NUMSCVK];
    PDEADKEY  pDeadKey = NULL;
    PLIGATURE pLigature = NULL;
    PKEYNAME  pKeyName = NULL;
    PKEYNAME  pKeyNameExt = NULL;
    PKEYNAME  pKeyNameDead = NULL;

    printf("\nKbdTool v%d.%02d - convert keyboard text file to C file\n\n",
           gVersion, gSubVersion);

    while ((c = getopt(argc, argv, "vkW?")) != EOF) {
        switch (c) {
        case 'v':
            verbose = TRUE;
            break;
        case 'k': // means 'kernel'
            fallback_driver = TRUE;
            break;
        case 'W':   // Turn on warning
            sanity_check = TRUE;
            break;
        case '?':
        default:
            usage();
            // never reaches here
        }
    }

    if (optind == argc) {
        usage();
        // never reaches here
    }
    argv = argv + optind;

    while (*argv) {
        nTotal++;
        gpszFileName = *argv;
        if ((gfpInput = fopen(*argv, "rt")) == NULL) {
            Error("can't open for read\n");
            nFailH++;
            nFailC++;
            nFailRC++;
            nFailDEF++;
            argv++;
            continue;
        }
        printf("%-23s:\n", *argv);

        /* initialize for each input file */
        for (i = 0; i < NUMKEYWORD; i++) {
            nKW[i]=0;
        }
        gLineCount = 0;
        /**********************************/

        if ((iKW = SkipLines()) >= NUMKEYWORD) {
            fclose(gfpInput);
            Error("no keyword found\n");
            nFailH++;
            nFailC++;
            nFailRC++;
            nFailDEF++;
            continue;
        }

        while (iKW < NUMKEYWORD - 1) {
            nKW[iKW]++;
            if (iKW != DEADKEYCODE && nKW[iKW] > 1 && verbose) {
                Warning(0, "duplicate %s", KeyWord[iKW]);
            }

            switch (iKW) {
            case KEYWORD_KBD:

                iKW = doKBD();
                break;

            case KEYWORD_VERSION: // ignored for now

                iKW = SkipLines();
                break;

            case KEYWORD_MODIFIERS:

                iKW = doMODIFIERS();
                break;

            case KEYWORD_SHIFTSTATE:

                iKW = doSHIFTSTATE(&nState, aiState);
                if (nState < 2) {
                    fclose(gfpInput);
                    Error("must have at least 2 states\n");
                    nFailH++;
                    nFailC++;
                    continue;
                }
                break;

            case KEYWORD_ATTRIBUTES:
                iKW = doATTRIBUTES(szAttrs);
                break;

            case KEYWORD_LAYOUT:

                if ((iKW = doLAYOUT(Layout, aiState, nState)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                /* add layout checking later */

                break;

            case KEYWORD_DEADKEY:

                if ((iKW = doDEADKEY(&pDeadKey)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                break;

            case KEYWORD_LIGATURE:

                if ((iKW = doLIGATURE(&pLigature)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                break;

            case KEYWORD_KEYNAME:

                if ((iKW = doKEYNAME(&pKeyName)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                break;

            case KEYWORD_KEYNAME_EXT:

                if ((iKW = doKEYNAME(&pKeyNameExt)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                break;

            case KEYWORD_KEYNAME_DEAD:

                if ((iKW = doKEYNAME(&pKeyNameDead)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                break;

            default:

                break;
            }
        }

        fclose(gfpInput);

        /* add later : checking for LAYOUT & DEADKEY */

        time(&Clock);
        Now = localtime(&Clock);

        if (!fallback_driver && kbd_h(Layout) == FAILURE) {
            nFailH++;
        }

        if (!fallback_driver && kbd_rc() != SUCCESS) {
            nFailRC++;
        }

        if (kbd_c(nState, aiState, szAttrs, Layout,
                  pDeadKey, pLigature, pKeyName, pKeyNameExt, pKeyNameDead) == FAILURE) {
            nFailC++;
        }

        if (!fallback_driver && kbd_def() != SUCCESS) {
            nFailDEF++;
        }

        printf("\n");

        argv++;
    }

    printf("\n     %13d     ->% 12d %12d %12d %12d\n",
           nTotal, nTotal - nFailH, nTotal - nFailRC,
           nTotal - nFailC, nTotal - nFailDEF);

  return EXIT_SUCCESS;
}

/*************************************************************\
* Check keyword
*  Return: 0 - 8 for valid keyword
*          9     for invalid keyword
\*************************************************************/
int isKeyWord(char *s)
{
  int i;

  for(i = 0; i < NUMKEYWORD; i++)
  {
    if(_strcmpi(KeyWord[i], s) == 0)
    {
      return i;
    }
  }

  return NOT_KEYWORD;
}

/*************************************************************\
* Skip lines till a valid keyword is available
*  Return: 0 - 8 for valid keyword
*          9     for invalid keyword
\*************************************************************/
int SkipLines()
{
  int   iKW;
  char  KW[WORDBUFSIZE];

  while (NextLine(gBuf, LINEBUFSIZE, gfpInput))
  {
    if(sscanf(gBuf, "%s", KW) == 1)
    {
      if((iKW = isKeyWord(KW)) < NUMKEYWORD)
      {
        return iKW;
      }
    }
  }

  return NUMKEYWORD;
}

/*************************************************************\
* Convert Virtual Key name to integer
*  Return : -1 if fail
\*************************************************************/
int getVKNum(char *pVK)
{
  int i, len;

  len = strlen(pVK);

  if (len < 1) {
      return -1;
  }

  if (len == 1) {
      if (*pVK >= '0' && *pVK <= '9') {
          return *pVK;
      }

      *pVK = (char)toupper(*pVK);
      if (*pVK >= 'A' && *pVK <='Z') {
          return *pVK;
      }
  } else {
      for (i = 0; i < NUMVKNAME; i++) {
          if(_strcmpi(VKName[i].pName, pVK) == 0) {
            return VKName[i].VKey;
          }
      }

      /*
       * Hey! It's unknown!  Perhaps it is a new one, in which
       * case it must be of the form 0xNN
       */
      if (pVK[0] == '0' &&
              (pVK[1] == 'x' || pVK[1] == 'X')) {
          pVK[1] = 'x';
          if (sscanf(pVK, "0x%x", &i) == 1) {
              return i;
          }
      }
  }

  return -1;
}

/*************************************************************\
* Convert VK integer to name and store it in gVKeyName
\*************************************************************/
char *getVKName(int VK, BOOL pre