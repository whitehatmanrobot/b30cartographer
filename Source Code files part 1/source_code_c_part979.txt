te();
	ULONG			SuiteMask();

	protected:
	private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\kuserdata.cpp ===
//=================================================================

//

// KUserdata.cpp --

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    02/16/98	a-peterc        Created

// Encapsulates kernel user data into an extraction class. This is
// done primarily to avoid nt header files from colliding with wmi
// provider headers.
// No member data.
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include "KUserdata.h"

#if defined(_WIN64)
#else
void ConvertTime( volatile KSYSTEM_TIME* ksTime, LARGE_INTEGER* pTime );
#endif
//
BOOLEAN KUserdata::IsNec98()
{ return USER_SHARED_DATA->AlternativeArchitecture == NEC98x86; }

//
ULONG KUserdata::TickCountLow()
{ return USER_SHARED_DATA->TickCountLow; }

//
ULONG KUserdata::TickCountMultiplier()
{ return USER_SHARED_DATA->TickCountMultiplier; }

#if defined(_WIN64)
#else
//
LARGE_INTEGER KUserdata::InterruptTime()
{
	LARGE_INTEGER llTime;

#ifdef _MIPS_
	*((DOUBLE *)(&llTime)) = *((DOUBLE *)(&USER_SHARED_DATA->InterruptTime));
#else
	ConvertTime( &USER_SHARED_DATA->InterruptTime, &llTime );
#endif

	return llTime;
}

//
LARGE_INTEGER KUserdata::SystemTime()
{
	LARGE_INTEGER llTime;

#ifdef _MIPS_
	*((DOUBLE *)(pTime)) = *((DOUBLE *)(&USER_SHARED_DATA->SystemTime));
#elif defined(_IA64_)
    llTime.LowPart = USER_SHARED_DATA->SystemLowTime;
    llTime.HighPart = USER_SHARED_DATA->SystemHigh1Time;
#else
	ConvertTime( &USER_SHARED_DATA->SystemTime, &llTime );
#endif

	return llTime;
}

//
LARGE_INTEGER KUserdata::TimeZoneBias()
{
	LARGE_INTEGER llTime;
	ConvertTime( &USER_SHARED_DATA->TimeZoneBias, &llTime );

	return llTime;
}
#endif

//
USHORT KUserdata::ImageNumberLow()
{ return USER_SHARED_DATA->ImageNumberLow; }

//
USHORT KUserdata::ImageNumberHigh()
{ return USER_SHARED_DATA->ImageNumberHigh; }

//
WCHAR* KUserdata::NtSystemRoot()
{ return (WCHAR*)&USER_SHARED_DATA->NtSystemRoot; }

//
ULONG KUserdata::MaxStackTraceDepth()
{ return USER_SHARED_DATA->MaxStackTraceDepth; }

//
ULONG KUserdata::CryptoExponent()
{ return USER_SHARED_DATA->CryptoExponent; }

//
ULONG KUserdata::TimeZoneId()
{ return USER_SHARED_DATA->TimeZoneId; }

//
ULONG KUserdata::NtProductType()
{ return USER_SHARED_DATA->NtProductType; }

//
BOOLEAN KUserdata::ProductTypeIsValid()
{ return USER_SHARED_DATA->ProductTypeIsValid; }

//
ULONG KUserdata::NtMajorVersion()
{ return USER_SHARED_DATA->NtMajorVersion; }

//
ULONG KUserdata::NtMinorVersion()
{ return USER_SHARED_DATA->NtMinorVersion; }

//
BOOLEAN KUserdata::ProcessorFeatures(DWORD dwIndex, BOOLEAN& bFeature )
{
	if(dwIndex < PROCESSOR_FEATURE_MAX )
	{
		bFeature = USER_SHARED_DATA->ProcessorFeatures[dwIndex];
		return TRUE;
	}
	return FALSE;
 }

//
ULONG KUserdata::TimeSlip()
{ return USER_SHARED_DATA->TimeSlip; }

//
LARGE_INTEGER KUserdata::SystemExpirationDate()
{ return USER_SHARED_DATA->SystemExpirationDate; }

//
ULONG KUserdata::SuiteMask()
{ return USER_SHARED_DATA->SuiteMask; }

#if defined(_WIN64)
#else
//
void ConvertTime( volatile KSYSTEM_TIME* ksTime, LARGE_INTEGER* pTime )
{
#ifdef _ALPHA_
    pTime->QuadPart = *ksTime;
#elif defined(_IA64_)
    pTime->QuadPart = *ksTime;
#else
    do {
		pTime->HighPart = ksTime->High1Time;
        pTime->LowPart	= ksTime->LowPart;
    } while (pTime->HighPart != ksTime->High2Time);
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\loaddepends.h ===
//=================================================================

//

// loaddepends.h -- LoadOrderGroup to Service association provider

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    12/26/97    davwoh         Created
//
// Comments: Shows the load order groups that each service depends
//           on to start.
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_LOADORDERGROUPSERVICEDEPENDENCIES L"Win32_LoadOrderGroupServiceDependencies"

class CWin32LoadGroupDependency ;

class CWin32LoadGroupDependency:public Provider {

   public:

      // Constructor/destructor
      //=======================

      CWin32LoadGroupDependency(LPCWSTR name, LPCWSTR pszNamespace) ;
      ~CWin32LoadGroupDependency() ;

      // Functions provide properties with current values
      //=================================================

      virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
      virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

   private:

      // Utility function(s)
      //====================

      HRESULT GetDependentsFromService(const CHString &sServiceName, CHStringArray &asArray);

      CHString m_sGroupBase;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\loadmember.h ===
//=================================================================

//

// loadmember.h -- LoadOrderGroup to Service association provider

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/06/97    davwoh         Created
//
// Comment: Shows the members of each load order group
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_LOADORDERGROUPSERVICEMEMBERS L"Win32_LoadOrderGroupServiceMembers"

class CWin32LoadGroupMember ;

class CWin32LoadGroupMember:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32LoadGroupMember(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32LoadGroupMember() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    private:

        // Utility function(s)
        //====================

        CHString GetGroupFromService(const CHString &sServiceName);

        CHString m_sGroupBase;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\loadorder.cpp ===
//=================================================================

//

// LoadOrder.CPP --Service Load Order Group property set provider

//                Windows NT only

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/25/97    davwoh         Moved to curly
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "LoadOrder.h"

// Property set declaration
//=========================
CWin32LoadOrderGroup MyLoadOrderGroupSet ( PROPSET_NAME_LOADORDERGROUP , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadOrderGroup::CWin32LoadOrderGroup
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LoadOrderGroup :: CWin32LoadOrderGroup (

	LPCWSTR Name,
	LPCWSTR pszNamespace

) : Provider ( Name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadOrderGroup::~CWin32LoadOrderGroup
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LoadOrderGroup :: ~CWin32LoadOrderGroup ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadOrderGroup::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadOrderGroup :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    CHString sSeeking;
    pInstance->GetCHString ( L"Name" , sSeeking ) ;

    return WalkGroups ( NULL , pInstance , sSeeking ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadOrderGroup::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadOrderGroup :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	return WalkGroups ( pMethodContext , NULL , NULL ) ;
}

HRESULT CWin32LoadOrderGroup :: WalkGroups (

	MethodContext *pMethodContext,
    CInstance *a_pInstance,
	LPCWSTR pszSeekName
)
{
	bool bDone = false ;

	CInstancePtr	t_pInstance = a_pInstance ;
	CHStringArray	saGroups;
					saGroups.SetSize ( 10 ) ;

	HRESULT			hRes = WBEM_S_NO_ERROR ;

	CRegistry RegInfo ;

	DWORD lResult = RegInfo.Open (

		HKEY_LOCAL_MACHINE,
		L"System\\CurrentControlSet\\Control\\ServiceGroupOrder",
		KEY_READ
	) ;

	if ( lResult == ERROR_SUCCESS )
	{
		CHString sTemp ;
		lResult = RegInfo.GetCurrentKeyValue ( L"List" , sTemp ) ;
		if ( lResult  == ERROR_SUCCESS )
		{

#ifdef WIN9XONLY
			// If this is a w98 box, sTemp comes back as a binary field instead
		// of the multisz on nt.  As a result, GetCurrentKeyValue didn't perform
		// its translation on it.  So I will do it here.

			DWORD dwLen = sTemp.GetLength () ;
			if ( dwLen )
			{
				LPWSTR pBuff = sTemp.GetBuffer(dwLen + 2);
				pBuff[dwLen] = '\0';
				pBuff[dwLen + 1] = '\0';
				sTemp.ReleaseBuffer(dwLen + 2);

				CHString sTemp2 ( sTemp ) ;
				sTemp.Empty();

				WCHAR *pW = (WCHAR *)(LPCWSTR) sTemp2 ;

				do
				{
					sTemp += pW;
					sTemp += '\n';
					pW += wcslen(pW) + 1;

				} while (*pW != 0 );
			}
#endif

			WCHAR *pszServiceName = wcstok(sTemp.GetBuffer(sTemp.GetLength() + 1), L"\n") ;
			DWORD dwIndex = 1 ;

			while ( ( pszServiceName != NULL ) && ( ! bDone ) && ( SUCCEEDED ( hRes ) ) )
			{
				if ( pszServiceName [ 0 ] != '\0' )
				{
					if ( pMethodContext )
					{
						t_pInstance.Attach( CreateNewInstance ( pMethodContext ) ) ;
					}

					if ( ( pMethodContext ) || ( bDone = ( _wcsicmp ( pszServiceName , pszSeekName ) == 0 ) ) )
					{
						t_pInstance->SetCharSplat ( L"Name" , pszServiceName ) ;
						t_pInstance->SetDWORD ( L"GroupOrder" , dwIndex ) ;
						t_pInstance->SetCharSplat ( L"Caption" , pszServiceName ) ;
						t_pInstance->SetCharSplat ( L"Description" , pszServiceName ) ;
						t_pInstance->SetCharSplat ( L"Status" , L"OK" ) ;
						t_pInstance->Setbool ( L"DriverEnabled" , true ) ;
					}

					if ( pMethodContext )
					{
						hRes = t_pInstance->Commit() ;
					}

					saGroups.SetAtGrow ( dwIndex , _wcsupr ( pszServiceName ) ) ;
					dwIndex ++ ;
				}

				pszServiceName = wcstok(NULL, L"\n") ;
			}

			if( !bDone )
			{
				lResult = RegInfo.OpenAndEnumerateSubKeys (

					HKEY_LOCAL_MACHINE,
					L"System\\CurrentControlSet\\Services",
					KEY_READ
				) ;

				if ( lResult == ERROR_SUCCESS )
				{
					hRes = WBEM_S_NO_ERROR;

					bool bAnother ;

					for (	bAnother = (RegInfo.GetCurrentSubKeyCount() > 0);
							bAnother && !bDone && SUCCEEDED(hRes);
							bAnother = (RegInfo.NextSubKey() == ERROR_SUCCESS )
					)
					{
						CHString sKey ;
						RegInfo.GetCurrentSubKeyPath ( sKey ) ;

						CRegistry COne ;

						if ( COne.Open ( HKEY_LOCAL_MACHINE , sKey, KEY_READ ) == ERROR_SUCCESS )
						{
							if ( COne.GetCurrentKeyValue (L"Group", sTemp) == ERROR_SUCCESS )
							{
								if ( !FindGroup ( saGroups , sTemp , dwIndex ) )
								{
									if ( !sTemp.IsEmpty () )
									{
										if ( pMethodContext )
										{
											t_pInstance.Attach( CreateNewInstance ( pMethodContext ) ) ;
										}

										if ( ( pMethodContext ) || ( bDone = ( sTemp.CompareNoCase ( pszSeekName ) == 0 ) ) )
										{
											t_pInstance->SetCharSplat ( L"Name" , sTemp ) ;
											t_pInstance->SetDWORD ( L"GroupOrder" , dwIndex ) ;
											t_pInstance->SetCharSplat ( L"Caption" , sTemp ) ;
											t_pInstance->SetCharSplat ( L"Description" , sTemp ) ;
											t_pInstance->SetCharSplat ( L"Status" , L"OK" ) ;
											t_pInstance->Setbool ( L"DriverEnabled" , false ) ;
										}

										if ( pMethodContext )
										{
											hRes = t_pInstance->Commit() ;
										}

										sTemp.MakeUpper();
										saGroups.SetAtGrow(dwIndex, sTemp);
										dwIndex ++;

									}
								}
							}
						}
					}
				}
			}
		}

    // 95 doesn' have this key, but 98 should
    }

#ifdef WIN9XONLY

    else if ( IsWin95 () )
	{
        hRes = WBEM_S_NO_ERROR ;
	}

#endif
    else
	{
		hRes = WinErrorToWBEMhResult ( lResult ) ;
	}

	if ( ( pszSeekName != NULL ) && ( hRes == WBEM_S_NO_ERROR ) && ! bDone )
	{
		hRes = WBEM_E_NOT_FOUND ;
	}

   return hRes;

}

bool CWin32LoadOrderGroup :: FindGroup (

	const CHStringArray &saGroup,
	LPCWSTR pszTemp,
	DWORD dwSize
)
{
	CHString sTemp ( pszTemp ) ;
	sTemp.MakeUpper () ;

	LPCWSTR pszTemp2 = (LPCWSTR) sTemp ;

	for ( DWORD x = 1 ; x < dwSize ; x ++ )
	{
		if ( saGroup [ x ] == pszTemp2 )
		{
			return true ;
		}
	}

	return false ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\loadmember.cpp ===
//=================================================================

//

// LoadMember.CPP -- LoadOrderGroup to Service association provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/06/97    davwoh         Created
//
// Comment: Shows the members of each load order group
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "LoadMember.h"
#include "loadorder.h"

// Property set declaration
//=========================

CWin32LoadGroupMember MyLoadMember(PROPSET_NAME_LOADORDERGROUPSERVICEMEMBERS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupMember::CWin32LoadGroupMember
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LoadGroupMember::CWin32LoadGroupMember(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
   CHString sTemp(PROPSET_NAME_LOADORDERGROUP);

   sTemp += L".Name=\"";

   // Just saves us from having to constantly re-calculate this when sending
   // instances back.
   m_sGroupBase = MakeLocalPath(sTemp);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupMember::~CWin32LoadGroupMember
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LoadGroupMember::~CWin32LoadGroupMember()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupMember::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadGroupMember::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
   CHString sService, sGroupDesired, sGroupGot;
   HRESULT hRet = WBEM_E_NOT_FOUND;
	CInstancePtr pGroup;
	CInstancePtr pPart;

   // Get the two paths
   pInstance->GetCHString(IDS_PartComponent, sService);
   pInstance->GetCHString(IDS_GroupComponent, sGroupDesired);

   // If both ends are there
   if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstanceByPath(sService, &pPart, pInstance->GetMethodContext() ) ) )
   {
      if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstanceByPath(sGroupDesired, &pGroup, pInstance->GetMethodContext() ) ) )
      {

         // Now we need to check to see if this service really is in this group
         CHString sServiceName, sGroupGot;

         pPart->GetCHString(IDS_Name, sServiceName);

         // Get the group and check it
         sGroupGot = GetGroupFromService(sServiceName);
         if (sGroupGot.CompareNoCase(sGroupDesired) == 0) 
         {
            hRet = WBEM_S_NO_ERROR;
         }
         else
         {
            hRet = WBEM_E_NOT_FOUND;
         }
      }
   }

   return hRet;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupMember::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadGroupMember::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	CHString sService, sServicePath, sGroupGot;
	HRESULT hr = WBEM_S_NO_ERROR;

   // Get list of Services
   //=====================
   TRefPointerCollection<CInstance> Services;

//   if (SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances(
//		_T("Win32_BaseService"), &Services, pMethodContext, IDS_CimWin32Namespace)))

   if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(
		L"Select __relpath, Name from Win32_BaseService", &Services, pMethodContext, GetNamespace())))
	{
      REFPTRCOLLECTION_POSITION pos;
      CInstancePtr pService;

      if (Services.BeginEnum(pos))
      {
         for (pService.Attach(Services.GetNext( pos )) ;
             (SUCCEEDED(hr)) && (pService != NULL) ;
             pService.Attach(Services.GetNext( pos )))
         {

            pService->GetCHString(IDS_Name, sService) ;
            pService->GetCHString(IDS___Relpath, sServicePath) ;

            // See if there is a group for this service.  sGroupGot comes
            // back as a full path or as blank
            sGroupGot = GetGroupFromService(sService);
            if (!sGroupGot.IsEmpty()) {
               CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
               if (pInstance)
               {
                   // Ok, turn the relpath into a complete path
                   GetLocalInstancePath(pService, sServicePath);

                   // Do the puts, and that's it
                   pInstance->SetCHString(IDS_PartComponent, sServicePath);
                   pInstance->SetCHString(IDS_GroupComponent, sGroupGot);
                   hr = pInstance->Commit();
               }
               else
               {
                   hr = WBEM_E_OUT_OF_MEMORY;
               }
            }
         }

         Services.EndEnum();
      }
   }

   return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupMember::GetGroupFromService
 *
 *  DESCRIPTION : Given a service name, returns the Group name
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : Returns CHString.Empty() if no group, empty group, or bad
 *                service name.
 *
 *****************************************************************************/
CHString CWin32LoadGroupMember::GetGroupFromService(const CHString &sServiceName)
{
   CRegistry RegInfo;
   CHString sGroupName;
   CHString sKeyName(L"SYSTEM\\CurrentControlSet\\Services\\");

   sKeyName += sServiceName;

   // Open the key, get the name
   if (RegInfo.Open(HKEY_LOCAL_MACHINE, sKeyName, KEY_READ) == ERROR_SUCCESS) {
      if (RegInfo.GetCurrentKeyValue(L"Group", sGroupName) == ERROR_SUCCESS) {
         if (sGroupName == _T("")) {
            sGroupName.Empty();
         }
      }
   }

   // If we found something, turn it into a full path.  m_sGroupbase
   // was set in constructor.
   if (!sGroupName.IsEmpty()) {
      sGroupName = m_sGroupBase + sGroupName;
      sGroupName += _T('"');
   }

   return sGroupName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\loadorder.h ===
//=================================================================

//

// LoadOrder.h -- Service Load Order Group property set provider

//               Windows NT only

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/25/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_LOADORDERGROUP L"Win32_LoadOrderGroup"

class CWin32LoadOrderGroup ;

class CWin32LoadOrderGroup:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32LoadOrderGroup(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32LoadOrderGroup() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    private:
        // Utility
        //========

        bool FindGroup(const CHStringArray &saGroup, LPCWSTR pszTemp, DWORD dwSize);
        HRESULT WalkGroups(MethodContext *pMethodContext, CInstance *pInstance, LPCWSTR pszSeekName);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logdiskpartition.cpp ===
//=================================================================

//

// LogDiskPartition.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>

typedef  long NTSTATUS;
#include <devioctl.h>
#include <ntddft.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include <ntdskreg.h>

#include "logdiskpartition.h"

#define CLUSTERSIZE 4096
#define MAXEXTENTS 31
#define MAXEXTENTSIZE (sizeof(VOLUME_DISK_EXTENTS) + (MAXEXTENTS * sizeof(DISK_EXTENT)))

// Property set declaration
//=========================

CWin32LogDiskToPartition win32LogDiskToPartition( PROPSET_NAME_LOGDISKtoPARTITION, IDS_CimWin32Namespace );


//////////////////////////////////////////////////////////////////////////////
//
//  logdiskpartition.cpp - Class implementation of CWin32LogDiskToPartition.
//
//  This class is intended to locate Win32 Logical Disks and create
//  associations between these logical disks and physical partitions on the
//  local hard disk(s).
//
//////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogDiskToPartition::CWin32LogDiskToPartition
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LogDiskToPartition::CWin32LogDiskToPartition( LPCWSTR strName, LPCWSTR pszNamespace /*=NULL*/ )
:   Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogDiskToPartition::~CWin32LogDiskToPartition
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LogDiskToPartition::~CWin32LogDiskToPartition()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32LogDiskToPartition::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32LogDiskToPartition::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    // Find the instance depending on platform id.
#if NTONLY >= 5
    return RefreshInstanceNT5(pInstance);
#endif

#if NTONLY == 4
    return RefreshInstanceNT(pInstance);
#endif

#ifdef WIN9XONLY
    return RefreshInstanceWin95(pInstance);
#endif

}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32LogDiskToPartition::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32LogDiskToPartition::EnumerateInstances( MethodContext* pMethodContext, long lFlags /*= 0L*/ )
{
    HRESULT     hr          =   WBEM_S_NO_ERROR;

    // Get the proper OS dependent instance

#ifdef NTONLY
    hr = AddDynamicInstancesNT( pMethodContext );
#endif

#ifdef WIN9XONLY
    hr = AddDynamicInstancesWin95( pMethodContext, NULL );
#endif

    return hr;

}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::AddDynamicInstancesNT
//
//  DESCRIPTION :   Queries the computer for run-time associations, each of
//                  which will have an instance created and saved.
//
//  INPUTS      :   none
//
//  OUTPUTS     :   none
//
//  RETURNS     :   DWORD       dwNumInstances - Number of instances located.
//
//  COMMENTS    :   Uses QueryDosDevice to find logical disks that are using
//                  "\device\harddisk" devices and associates them to their
//                  correct paritions.  At this time, this probably will
//                  not handle a "striped disk" (a disk spanning multiple
//                  partitions).
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32LogDiskToPartition::AddDynamicInstancesNT( MethodContext* pMethodContext )
{
    HRESULT hr;

    // Collections
    TRefPointerCollection<CInstance>    logicalDiskList;
    TRefPointerCollection<CInstance>    partitionList;

    // Perform queries
    //================

    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(_T("SELECT DeviceID FROM Win32_LogicalDisk Where DriveType = 3 or DriveType = 2"),
                                            &logicalDiskList,
                                            pMethodContext,
                                            IDS_CimWin32Namespace)) &&
        SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(_T("Select DeviceID, StartingOffset, Size, DiskIndex, Index from Win32_DiskPartition"),
                                            &partitionList,
                                            pMethodContext,
                                            IDS_CimWin32Namespace)))
    {
        REFPTRCOLLECTION_POSITION   pos;

        if ( logicalDiskList.BeginEnum( pos ) )
        {

            CInstancePtr pLogicalDisk;
#if NTONLY == 4
            LPBYTE t_pBuff = GetDiskKey();
            if (t_pBuff)
            {
                try
                {
#endif

                    for ( pLogicalDisk.Attach(logicalDiskList.GetNext( pos ));
                         (WBEM_S_NO_ERROR == hr) && (pLogicalDisk != NULL);
                         pLogicalDisk.Attach(logicalDiskList.GetNext( pos )) )
                    {
#if NTONLY >= 5
                        hr = EnumPartitionsForDiskNT5( pLogicalDisk, partitionList, pMethodContext );
#else
                        hr = EnumPartitionsForDiskNT( pLogicalDisk, partitionList, pMethodContext, t_pBuff );
#endif

                    }   // for GetNext

                    logicalDiskList.EndEnum();
#if NTONLY == 4
                }
                catch ( ... )
                {
                    delete [] t_pBuff;
                    throw;
                }
                delete [] t_pBuff;
            }

#endif

        }   // IF BeginEnum
    }

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::EnumPartitionsForDiskNT
//
//  DESCRIPTION :   Enumerates partitions from the supplied list, attemptng
//                  to find a partition matching the supplied logical disk.
//
//  INPUTS      :   CInstance*      pLogicalDisk - Logical Disk Drive
//                  TRefPointerCollection<CInstance>&   partitionList - Partition instances.
//                  MethodContext*  pMethodContext - Method Context.
//
//  OUTPUTS     :   none
//
//  RETURNS     :   DWORD       dwNumInstances - Number of instances located.
//
//  COMMENTS    :   At this time, this probably will not handle a "striped disk"
//                  (a disk spanning multiple partitions).
//
//////////////////////////////////////////////////////////////////////////////

#if NTONLY == 4
HRESULT CWin32LogDiskToPartition::EnumPartitionsForDiskNT(
                                 CInstance* pLogicalDisk,
                                 TRefPointerCollection<CInstance>& partitionList,
                                 MethodContext* pMethodContext,
                                 LPBYTE t_pBuff)
{
    HRESULT     hr = WBEM_S_NO_ERROR;
    DISK_EXTENT diskExtent[MAXEXTENTS];

    CInstancePtr pPartition;
    CHString    strLogicalDiskPath,
                strPartitionPath;
    CHString t_sDeviceID;

    pLogicalDisk->GetCHString(IDS_DeviceID, t_sDeviceID);
    DWORD dwExtents = GetExtentsForDrive(t_sDeviceID, t_pBuff, diskExtent);

    // Walk all the extents for this logical drive letter
    for (DWORD x=0; x < dwExtents; x++)
    {
        REFPTRCOLLECTION_POSITION   pos;

        // Compare the current extent against each of the partitions
        if ( partitionList.BeginEnum( pos ) )
        {
            for ( pPartition.Attach(partitionList.GetNext( pos )) ;
                  SUCCEEDED( hr ) && (pPartition != NULL) ;
                  pPartition.Attach(partitionList.GetNext( pos )) )
            {
                // If there is an association, create an instance from the method context
                //

                DWORD dwDisk = 0xffffffff;
                DWORD dwPartition = 0xffffffff;
                ULONGLONG i64Start, i64End;

                pPartition->GetDWORD(IDS_DiskIndex, dwDisk);
                pPartition->GetDWORD(IDS_Index, dwPartition);
                pPartition->GetWBEMINT64(IDS_StartingOffset, i64Start);
                pPartition->GetWBEMINT64(IDS_Size, i64End);

                i64End += i64Start;
                i64End -= 1;

                // i64Start and i64End are updated by this call
                if (IsRelatedNT(&diskExtent[x], dwDisk, dwPartition, i64Start, i64End ))
                {
                    CInstancePtr pInstance(CreateNewInstance( pMethodContext ), false);

                    // We got this far, there will be values for the Relative Path
                    // so don't worry about return failures here.

                    GetLocalInstancePath( pLogicalDisk, strLogicalDiskPath );
                    GetLocalInstancePath( pPartition, strPartitionPath );

                    pInstance->SetCHString( IDS_Dependent, strLogicalDiskPath );
                    pInstance->SetCHString( IDS_Antecedent, strPartitionPath );

                    pInstance->SetWBEMINT64( IDS_StartingAddress, i64Start );
                    pInstance->SetWBEMINT64( IDS_EndingAddress, i64End );

                    // This will invalidate the pointer
                    hr = pInstance->Commit(  );
                }
            }   // for GetNext

            partitionList.EndEnum();
        } // IF BeginEnum
    }

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::AddDynamicInstancesWin95
//
//  DESCRIPTION :   Queries the computer for run-time associations, each of
//                  which will have an instance created and saved.
//
//  INPUTS      :   none
//
//  OUTPUTS     :   none
//
//  RETURNS     :   DWORD       dwNumInstances - Number of instances located.
//
//  COMMENTS    :
//
//////////////////////////////////////////////////////////////////////////////

#ifdef WIN9XONLY
HRESULT CWin32LogDiskToPartition::AddDynamicInstancesWin95(MethodContext *pMethodContext,
                                                           LPCTSTR pszDrive, CInstance *pinstRefresh)
{
    CHString sDeviceID;
    TRefPointerCollection<CInstance> DiskPartitions;
    CHString sTemp, sPartitionPath, sDriveLetter;
    DWORD x, iWhere;
    ULONGLONG i64StartingAddress, i64Size;
    BYTE btBios;
    HRESULT hr = WBEM_S_NO_ERROR;

    struct _stMaps
    {
        BYTE btBiosUnit;
        ULONGLONG dmiPartitionStartRBA;
    } stMaps[sizeof(DWORD) * 8];  // I'm using 32 here since I'm not convinced that 26 is the max.  Since
    // GetLogicalDrives returns a DWORD, I'm using that size here.

    DRIVE_MAP_INFO stDriveMapInfo;

    memset(stMaps, '\0', sizeof(stMaps));

    // Walk all the logical drives
    DWORD dwDrives = GetLogicalDrives();

    // I'm only expecting 26, but who knows?
    for(x=0; (x < sizeof(DWORD) * 8); x++)
    {
        // If the bit is set, the drive letter is active
        if (dwDrives & (1<<x))
        {
            if (GetDriveMapInfo(&stDriveMapInfo, x+1))
            {
                stMaps[x].btBiosUnit = stDriveMapInfo.btInt13Unit;
                stMaps[x].dmiPartitionStartRBA = stDriveMapInfo.i64PartitionStartRBA * (ULONGLONG)BYTESPERSECTOR;
            }
        }
    }

    // Get all the instances of DiskPartition
      if SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"Select DeviceID, StartingOffset, Size, DiskIndex from Win32_DiskPartition",
          &DiskPartitions, pMethodContext))
    {
        REFPTRCOLLECTION_POSITION pos;
        CInstancePtr pDiskPartition;

        if (DiskPartitions.BeginEnum(pos))
        {
            // Walk all the disk partitions
            for (pDiskPartition.Attach(DiskPartitions.GetNext( pos ));
                 (pDiskPartition != NULL) && SUCCEEDED(hr) ;
                 pDiskPartition.Attach(DiskPartitions.GetNext( pos )))
            {
                pDiskPartition->GetCHString(IDS_DeviceID, sDeviceID) ;
                sDeviceID.MakeUpper();

                pDiskPartition->GetWBEMINT64(IDS_StartingOffset, i64StartingAddress);
                pDiskPartition->GetWBEMINT64(IDS_Size, i64Size);

                // Parse out the pnp id and partition number
                iWhere = sDeviceID.Find(L", PARTITION #");
                btBios = GetBiosUnitNumberFromPNPID(sDeviceID.Left(iWhere));

                // Now find the Logical drive that matches the bios unit/starting address
                for (x=0; x < sizeof(DWORD) * 8; x++)
                {
                    // Check to see if the drive letter is within this partition
                    if ((stMaps[x].btBiosUnit == btBios) &&
                        (stMaps[x].dmiPartitionStartRBA >= i64StartingAddress) &&
                        (stMaps[x].dmiPartitionStartRBA < i64StartingAddress + i64Size))
                    {
                        // Found one so create an instance
                        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                        // Create a LogicalDisk path
                        sTemp.Format(L"\\\\%s\\%s:Win32_LogicalDisk.DeviceID=\"%c:\"",
                            GetLocalComputerName(), IDS_CimWin32Namespace, x+'A');

                        // Use the path from pDiskPartition
                        GetLocalInstancePath(pDiskPartition, sPartitionPath);

                        pInstance->SetCHString(IDS_Antecedent, sPartitionPath);
                        pInstance->SetCHString(IDS_Dependent, sTemp);
                        pInstance->SetWBEMINT64(IDS_StartingAddress, stMaps[x].dmiPartitionStartRBA);

                        // If this disk starts at the beginning of the partition, it takes up the whole partition
                        if (stMaps[x].dmiPartitionStartRBA == i64StartingAddress)
                        {
                            pInstance->SetWBEMINT64(IDS_EndingAddress, i64StartingAddress + i64Size - (ULONGLONG)1);
                        }
                        else
                            // Otherwise, we are working with a logicaldisk on an extended partition.  Look up
                            // the size of the logical disk.
                        {
                            ExtGetDskFreSpcStruc stExtGetDskFreSpcStruc;
                            if (Get_ExtFreeSpace(x + 65, &stExtGetDskFreSpcStruc))
                            {
                                pInstance->SetWBEMINT64(IDS_EndingAddress, stMaps[x].dmiPartitionStartRBA + ((ULONGLONG)stExtGetDskFreSpcStruc.TotalPhysSectors * (ULONGLONG)stExtGetDskFreSpcStruc.BytesPerSector));
                            }
                        }

                        // Save the instance
                        hr = pInstance->Commit();
                    }
                }
            }
        }
    }

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::RefreshInstance
//
//  DESCRIPTION :   Called when we need to refresh values for the supplied
//                  paths.  Simply checks that the association is valid.
//
//  INPUTS      :   CInstance*      pInstance - Instance to refresh.
//
//  OUTPUTS     :   none.

//
//  RETURNS     :   BOOL        TRUE/FALSE - Success/Failure
//
//  COMMENTS    :   Uses QueryDosDevice to determine if the association is
//                  still valid.  Will not work for "striped drives".
//
//////////////////////////////////////////////////////////////////////////////

#if NTONLY == 4
HRESULT CWin32LogDiskToPartition::RefreshInstanceNT( CInstance* pInstance )
{
    HRESULT hres = WBEM_E_FAILED;

    CHString    strLogicalDiskPath,
                strPartitionPath;

    // Logical Disk and Partition Instances
    CInstancePtr pLogicalDisk;
    CInstancePtr pPartition;

    // We need these values to get the instances
    pInstance->GetCHString( IDS_Dependent, strLogicalDiskPath );
    pInstance->GetCHString( IDS_Antecedent, strPartitionPath );

    if (SUCCEEDED(hres = CWbemProviderGlue::GetInstanceByPath(strLogicalDiskPath,
        &pLogicalDisk)) &&
        SUCCEEDED(hres = CWbemProviderGlue::GetInstanceByPath(strPartitionPath,
        &pPartition)))
    {
        hres = WBEM_E_NOT_FOUND;

        CHString t_sDeviceID;
        DWORD dwDisk = 0xffffffff;
        DWORD dwPartition = 0xffffffff;
        ULONGLONG i64Start, i64End;

        pLogicalDisk->GetCHString(IDS_DeviceID, t_sDeviceID);
        LPBYTE t_pBuff = GetDiskKey();
        DISK_EXTENT diskExtent[MAXEXTENTS];
        DWORD dwExtents;

        try
        {
            dwExtents = GetExtentsForDrive(t_sDeviceID, t_pBuff, diskExtent);
        }
        catch ( ... )
        {
            delete [] t_pBuff;
            throw;
        }
        delete [] t_pBuff;

        pPartition->GetDWORD(IDS_DiskIndex, dwDisk);
        pPartition->GetDWORD(IDS_Index, dwPartition);
        pPartition->GetWBEMINT64(IDS_StartingOffset, i64Start);
        pPartition->GetWBEMINT64(IDS_Size, i64End);

        i64End += i64Start;
        i64End -= 1;

        // Walk all the extents looking for a match
        for (DWORD x=0; x < dwExtents; x++)
        {
            if (IsRelatedNT(&diskExtent[x], dwDisk, dwPartition, i64Start, i64End ))
            {
                pInstance->SetCHString( IDS_Dependent, strLogicalDiskPath );
                pInstance->SetCHString( IDS_Antecedent, strPartitionPath );

                pInstance->SetWBEMINT64( IDS_StartingAddress, i64Start );
                pInstance->SetWBEMINT64( IDS_EndingAddress, i64End );

                hres = WBEM_S_NO_ERROR;
                break;
            }
        }
    }   // IF Get both objects

    return hres;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::RefreshInstance
//
//  DESCRIPTION :   Called when we need to refresh values for the supplied
//                  paths.  Simply checks that the association is valid.
//
//  INPUTS      :   none.
//
//  OUTPUTS     :   none.

//
//  RETURNS     :   BOOL        TRUE/FALSE - Success/Failure
//
//  COMMENTS    :   Checks that the disk and the partition have the same
//                  volume serial number.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef WIN9XONLY
HRESULT CWin32LogDiskToPartition::RefreshInstanceWin95(CInstance *pInstance)
{
    HRESULT hres = WBEM_E_FAILED;
    CHString    strLogicalDiskPath,
        strPartitionPath,
        sDeviceID,
        sDriveLetter;
    DRIVE_MAP_INFO stDriveMapInfo;
    ULONGLONG i64StartingAddress, i64Size;
    DWORD iWhere;
    BYTE btBios;

    // Logical Disk and Partition Instances
    CInstancePtr pLogicalDisk;
    CInstancePtr pPartition;

    // We need these values to get the instances
    pInstance->GetCHString( IDS_Dependent, strLogicalDiskPath );
    pInstance->GetCHString( IDS_Antecedent, strPartitionPath );

    if (SUCCEEDED(hres = CWbemProviderGlue::GetInstanceByPath(strLogicalDiskPath,
        &pLogicalDisk)) &&
        SUCCEEDED(hres = CWbemProviderGlue::GetInstanceByPath(strPartitionPath,
        &pPartition)))
    {
        pLogicalDisk->GetCHString(IDS_DeviceID, sDriveLetter);
        sDriveLetter.MakeUpper();
        if (GetDriveMapInfo(&stDriveMapInfo, sDriveLetter[0]-'A'+1))
        {
            // Set up for failure
            hres = WBEM_E_NOT_FOUND;

            // Read properties off the partition instance
            pPartition->GetCHString(IDS_DeviceID, sDeviceID);
            sDeviceID.MakeUpper();

            pPartition->GetWBEMINT64(IDS_StartingOffset, i64StartingAddress);
            pPartition->GetWBEMINT64(IDS_Size, i64Size);

            // Get the bios unit number for this partition
            iWhere = sDeviceID.Find(L", PARTITION #");
            if (iWhere != -1)
            {
                btBios = GetBiosUnitNumberFromPNPID(sDeviceID.Left(iWhere));
            }
            else
            {
                btBios = -1;
            }

            ULONGLONG i64LogDriveStartingAddress = stDriveMapInfo.i64PartitionStartRBA * (ULONGLONG)BYTESPERSECTOR;

            // If the bios unit number is the same, and the starting offset is within the partition, this must be a match
            if ((stDriveMapInfo.btInt13Unit == btBios) &&
                (i64LogDriveStartingAddress >= i64StartingAddress) &&
                (i64LogDriveStartingAddress < i64StartingAddress + i64Size))
            {
                pInstance->SetWBEMINT64(IDS_StartingAddress, i64LogDriveStartingAddress);

                // If this disk starts at the beginning of the partition, it takes up the whole partition
                if (i64LogDriveStartingAddress == i64StartingAddress)
                {
                    pInstance->SetWBEMINT64(IDS_EndingAddress, i64StartingAddress + i64Size - (ULONGLONG)1);
                }
                else
                    // Otherwise, we are working with a logicaldisk on an extended partition.  Look up
                    // the size of the logical disk.
                {
                    ExtGetDskFreSpcStruc stExtGetDskFreSpcStruc;
                    if (Get_ExtFreeSpace(sDriveLetter[0], &stExtGetDskFreSpcStruc))
                    {
                        pInstance->SetWBEMINT64(IDS_EndingAddress, i64LogDriveStartingAddress + ((ULONGLONG)stExtGetDskFreSpcStruc.TotalPhysSectors * (ULONGLONG)stExtGetDskFreSpcStruc.BytesPerSector));
                    }
                }

                hres = WBEM_S_NO_ERROR;
            }
        }

    }   // IF Get both objects

    return hres;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::IsRelatedNT
//
//  DESCRIPTION :   Given Disk and Partition indices, and a Logical disk drive,
//                  this routine determines if they are related.
//
//  INPUTS      :   LPCWSTR First character must be the drive letter
//                  DWORD   Drive number
//                  DWORD   Partition number
//
//  OUTPUTS     :   none.
//
//  RETURNS     :   BOOL        TRUE/FALSE - Association exists/does not exist
//
//  COMMENTS    :   None.
//
//////////////////////////////////////////////////////////////////////////////

#if NTONLY == 4
BOOL CWin32LogDiskToPartition::IsRelatedNT(

    DISK_EXTENT *diskExtent,
    DWORD dwDrive,
    DWORD dwPartition,
    ULONGLONG &u64StartingAddress,
    ULONGLONG &u64EndingAddress
)
{
    BOOL bRet = FALSE;
    ULONGLONG ulExtendEndingAddress = diskExtent->StartingOffset.QuadPart + diskExtent->ExtentLength.QuadPart;
    ulExtendEndingAddress -= 1;

    if ( (diskExtent->DiskNumber == dwDrive) &&
        (diskExtent->StartingOffset.QuadPart >= u64StartingAddress) &&
        (ulExtendEndingAddress <= u64EndingAddress) )
    {
        u64StartingAddress = diskExtent->StartingOffset.QuadPart;
        u64EndingAddress = ulExtendEndingAddress;
        bRet = TRUE;
    }

    return bRet;
}

DWORD CWin32LogDiskToPartition::GetExtentsForDrive(
    LPCWSTR lpwszLogicalDisk,
    LPBYTE pBuff,
    DISK_EXTENT *diskExtent
)
{
    DWORD dwCount = 0;

    // If pBuff is not null, disk administrator has been run, and we potentially have striped sets.
    if (pBuff != NULL)
    {
        UCHAR cDriveLet = lpwszLogicalDisk[0];

        DISK_CONFIG_HEADER *pConfig = (DISK_CONFIG_HEADER *)pBuff;
        DISK_REGISTRY *pReg = (DISK_REGISTRY *)((LPBYTE)pConfig + pConfig->DiskInformationOffset);

        DISK_DESCRIPTION *pDisk = (DISK_DESCRIPTION *)(&pReg->Disks[0]);

        // First, find the offset of the disk they are requesting
        for (DWORD dwDisks = 0;
        dwDisks < pReg->NumberOfDisks;
        dwDisks++)
        {
            for (DWORD dwPartition = 0; dwPartition < pDisk->NumberOfPartitions; dwPartition++)
            {
                // Yup.  Now lets see if the drive letter matches
                if (pDisk->Partitions[dwPartition].DriveLetter == cDriveLet)
                {
                    diskExtent[dwCount].DiskNumber = dwDisks;
                    diskExtent[dwCount].StartingOffset.QuadPart = pDisk->Partitions[dwPartition].StartingOffset.QuadPart;
                    diskExtent[dwCount].ExtentLength.QuadPart = pDisk->Partitions[dwPartition].Length.QuadPart;
                    dwCount++;
                }
            }

            pDisk = (DISK_DESCRIPTION *)((LPBYTE)pDisk +
                (sizeof(DISK_DESCRIPTION) +
                (sizeof(DISK_PARTITION) * (pDisk->NumberOfPartitions - 1))));
        }
    }

    // If we didn't find it the other way, try the old fashioned way.  It won't work for striped sets, but if
    // it were a striped set, the other approach would have worked.
    if (dwCount == 0)
    {
        DWORD                   dwRead;
        PARTITION_INFORMATION   stPartition;

        CHString sDriveName;
        sDriveName.Format(L"\\\\.\\%s", lpwszLogicalDisk);

        // Open the drive
        SmartCloseHandle hDiskHandle = CreateFile(sDriveName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
            INVALID_HANDLE_VALUE);

        if (hDiskHandle != INVALID_HANDLE_VALUE)
        {
            WCHAR wcDrivePath[_MAX_PATH];
            if (QueryDosDevice(lpwszLogicalDisk, wcDrivePath, _MAX_PATH))
            {
                // Get partition info
                if (DeviceIoControl(hDiskHandle, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &stPartition, sizeof(stPartition), &dwRead, NULL))
                {
                    diskExtent[dwCount].DiskNumber = _wtoi(&wcDrivePath[16]);
                    diskExtent[dwCount].StartingOffset.QuadPart = stPartition.StartingOffset.QuadPart;
                    diskExtent[dwCount].ExtentLength.QuadPart = stPartition.PartitionLength.QuadPart;
                    dwCount++;
                }
            }
        }
    }

    return dwCount;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::EnumPartitionsForDiskNT5
//
//  DESCRIPTION :   Enumerates partitions from the supplied list, attemptng
//                  to find a partition matching the supplied logical disk.
//
//  INPUTS      :   CInstance*      pLogicalDisk - Logical Disk Drive
//                  TRefPointerCollection<CInstance>&   partitionList - Partition instances.
//                  MethodContext*  pMethodContext - Method Context.
//
//  OUTPUTS     :   none
//
//  RETURNS     :
//
//  COMMENTS    :   At this time, this probably will not handle a "striped disk"
//                  (a disk spanning multiple partitions).
//
//////////////////////////////////////////////////////////////////////////////

#if NTONLY >= 5
HRESULT CWin32LogDiskToPartition::EnumPartitionsForDiskNT5(

    CInstance* pLogicalDisk,
    TRefPointerCollection<CInstance>& partitionList,
    MethodContext* pMethodContext
)
{

    DWORD dwSize;
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString sDeviceID;

    VOLUME_DISK_EXTENTS *pExt = (VOLUME_DISK_EXTENTS *)new BYTE[MAXEXTENTSIZE];
    if (pExt == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
        memset(pExt, '\0', MAXEXTENTSIZE);

        // Format the name to \\.\c: format
        pLogicalDisk->GetCHString(IDS_DeviceID, sDeviceID);
        sDeviceID = _T("\\\\.\\") + sDeviceID;

        SmartCloseHandle fHan;
        // Open the drive
        fHan = CreateFile(sDeviceID,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        // If the open worked
        if (fHan != INVALID_HANDLE_VALUE)
        {
            // Try to get the partition info
            if (DeviceIoControl(fHan,
                            IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                            NULL,
                            0,
                            pExt,
                            MAXEXTENTSIZE,
                            &dwSize,
                            NULL))
            {
                // Now we walk the partitions from partitionList looking for the entries
                // we just got back from DeviceIoControl

                for (DWORD x=0; x < pExt->NumberOfDiskExtents; x++)
                {
                    REFPTRCOLLECTION_POSITION   pos;

                    if ( partitionList.BeginEnum( pos ) )
                    {
                        bool bFound = false;
                        CInstancePtr pPartition;
                        ULONGLONG i64StartingOffset, i64PartitionSize;
                        DWORD dwDisk;
                        CHString strLogicalDiskPath, strPartitionPath;
                        ULONGLONG i64Start, i64End;

                        for (pPartition.Attach(partitionList.GetNext( pos )) ;
                            (!bFound) && (pPartition != NULL ) ;
                             pPartition.Attach(partitionList.GetNext( pos )))
                        {
                            pPartition->GetWBEMINT64(IDS_StartingOffset, i64StartingOffset);
                            pPartition->GetWBEMINT64(IDS_Size, i64PartitionSize);
                            pPartition->GetDWORD(IDS_DiskIndex, dwDisk);

                            // If the disk numbers are the same, and the starting offset is within
                            // the disk partition, it's related
                            bFound = ((dwDisk == pExt->Extents[x].DiskNumber) &&
                                (pExt->Extents[x].StartingOffset.QuadPart >= i64StartingOffset) &&
                                (pExt->Extents[x].StartingOffset.QuadPart < i64StartingOffset + i64PartitionSize));

                            // Grab the path
                            if (bFound)
                            {
                                GetLocalInstancePath( pLogicalDisk, strLogicalDiskPath );
                                GetLocalInstancePath( pPartition, strPartitionPath );

                                i64Start = pExt->Extents[x].StartingOffset.QuadPart;
                                i64End = i64Start + pExt->Extents[x].ExtentLength.QuadPart;
                                i64End -= 1;

                            }
                        }

                        partitionList.EndEnum();

                        // If we found it, create an instance.
                        if (bFound)
                        {
                            CInstancePtr pInstance(CreateNewInstance( pMethodContext ), false);

                            pInstance->SetCHString( IDS_Dependent, strLogicalDiskPath );
                            pInstance->SetCHString( IDS_Antecedent, strPartitionPath );

                            pInstance->SetWBEMINT64( IDS_StartingAddress, i64Start );
                            pInstance->SetWBEMINT64( IDS_EndingAddress, i64End );

                            hr = pInstance->Commit(  );
                        }
                    }
                }
            }

        }
    }
    catch ( ... )
    {

        delete pExt;
        throw ;
    }

    delete pExt;

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32LogDiskToPartition::RefreshInstanceNT5
//
//  DESCRIPTION :
//
//  INPUTS      :   CInstance*      pInstance - Instance to refresh.
//
//  OUTPUTS     :   none.
//
//  RETURNS     :   BOOL        TRUE/FALSE - Success/Failure
//
//  COMMENTS    :   Will not work for "striped drives".
//
//////////////////////////////////////////////////////////////////////////////

#if NTONLY >= 5
HRESULT CWin32LogDiskToPartition::RefreshInstanceNT5( CInstance* pInstance )
{
    HRESULT hres = WBEM_E_FAILED;
    CHString    strLogicalDiskPath,
                strPartitionPath;

    // Logical Disk and Partition Instances
    CInstancePtr pLogicalDisk;
    CInstancePtr pPartition;

    // We need these values to get the instances
    pInstance->GetCHString( IDS_Dependent, strLogicalDiskPath );
    pInstance->GetCHString( IDS_Antecedent, strPartitionPath );

    if (SUCCEEDED(hres = CWbemProviderGlue::GetInstanceByPath(strLogicalDiskPath,
        &pLogicalDisk, pInstance->GetMethodContext())) &&
        SUCCEEDED(hres = CWbemProviderGlue::GetInstanceByPath(strPartitionPath,
            &pPartition, pInstance->GetMethodContext())))
    {
        DWORD dwLastError = 0;

        hres = WBEM_E_FAILED;

        // Format the name to \\.\c: format
        CHString sDeviceID;
        pLogicalDisk->GetCHString(IDS_DeviceID, sDeviceID);
        sDeviceID = _T("\\\\.\\") + sDeviceID;

        // Open the drive
        SmartCloseHandle fHan =
            CreateFile(sDeviceID,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

        // If the open worked
        if (fHan != INVALID_HANDLE_VALUE)
        {
            VOLUME_DISK_EXTENTS *pExt = (VOLUME_DISK_EXTENTS *)new BYTE[MAXEXTENTSIZE];
            if (pExt == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            try
            {
                memset(pExt, '\0', MAXEXTENTSIZE);

                // Try to get the partition info
                DWORD dwSize;
                if (DeviceIoControl(fHan,
                    IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                    NULL,
                    0,
                    pExt,
                    MAXEXTENTSIZE,
                    &dwSize,
                    NULL))
                {
                    ULONGLONG i64StartingOffset, i64Size;
                    DWORD dwDisk;

                    pPartition->GetWBEMINT64(IDS_StartingOffset, i64StartingOffset);
                    pPartition->GetWBEMINT64(IDS_Size, i64Size);
                    pPartition->GetDWORD(IDS_DiskIndex, dwDisk);

                    // If the disk numbers are the same, and the starting offset is within
                    // the disk partition, it's related
                    BOOL bFound = FALSE;
                    for (DWORD x=0; x < pExt->NumberOfDiskExtents && !bFound; x++)
                    {
                        bFound = ((dwDisk == pExt->Extents[x].DiskNumber) &&
                            (pExt->Extents[x].StartingOffset.QuadPart >= i64StartingOffset) &&
                            (pExt->Extents[x].StartingOffset.QuadPart < i64StartingOffset + i64Size));
                    }

                    if (bFound)
                    {
                        pInstance->SetWBEMINT64(IDS_StartingAddress, pExt->Extents[x-1].StartingOffset.QuadPart);
                        pInstance->SetWBEMINT64(IDS_EndingAddress, pExt->Extents[x-1].StartingOffset.QuadPart + pExt->Extents[x-1].ExtentLength.QuadPart - (ULONGLONG)1);

                        hres = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hres = WBEM_E_NOT_FOUND;
                    }
                }
                else
                {
                    dwLastError = GetLastError();
                }
            }
            catch ( ... )
            {
                delete [] pExt;
                throw;
            }

            delete [] pExt;
        }
        else
        {
            dwLastError = GetLastError();
        }

        // Either CreateFile or DeviceIOControl failed, so find out what
        // happened.
        if (hres == WBEM_E_FAILED)
            hres = WinErrorToWBEMhResult(dwLastError);
    }   // IF Get both objects

    return hres;
}
#endif

/* Info on how to read the 'disk' key in the nt4 registry from Cristian Teodorescu:
This is the basic information you need in order to "read" the FT volumes in NT 4.0

1. The FT volumes configuration information is stored in the registry under
"HKEY_LOCAL_MACHINE\ SYSTEM \ DISK : Information (binary value).

2. This binary value starts with a header of type DISK_CONFIG_HEADER (see "ntddft.h")

3. The interesting data for you is a structure of type DISK_REGISTRY starting at the
offset DISK_CONFIG_HEADER::DiskInformationOffset from the base of the binary value. The
length of the DISK_REGISTRY data is DISK_CONFIG_HEADER::DiskInformationSize.
Structure DISK_REGISTRY is defined in "ntdskreg.h"

4. You can get directly the DISK_REGISTRY structure by calling DiskRegistryGet (defined
in "ntdskreg.h").  So, at this moment you can forget about points 1-3 above.

5. DISK_REGISTRY contains the number of disks plus an array of DISK_DESCRIPTION. Every
DISK_DESCRIPTION contains the signature, the number of partitions and an array of DISK_PARTITION.
Every DISK_PARTITION corresponds to a partition on the physical disk.
Note: You should use the signatures to map the DISK_DESCRIPTION structures found in
the registry with the actual physical disks you'll find in the system. Then you have
to check for every disk  whether the DISK_PARTITION structures match or not with
the actual partitions you'll find on the physical disk

6. This is a short explanation of DISK_PARTITION (defined in "ntdskreg.h"):

FT_TYPE FtType;
The type of the FT set whose member is this partition. NotAnFtMember is used to
mark the "normal" partitions. For such "normal" (non FT) partitions many of the
following fields are not used

FT_PARTITION_STATE FtState;
The state of the partition (if it is a member of an FT set). It also gives you
the health of the whole FT set

LARGE_INTEGER StartingOffset;
The partition starting offset

LARGE_INTEGER      Length;
The partition length

LARGE_INTEGER      FtLength;
Not used

UCHAR DriveLetter;
The drive letter of the FT set. Use it only when FtMember == 0 and
AssignDriveLetter == TRUE

BOOLEAN  AssignDriveLetter;
This boolean indicates whether or not the field DriveLetter is valid and you
can use it as the drive letter of the FT set

USHORT LogicalNumber
I don't know what is this

USHORT FtGroup
This is a number identifying the FT set whose member is this partition.  An FT
set is identified uniquely using its FT_TYPE and this number.  Note that you
may found FT sets with the same number, but they must have different FT types
(E.g. Mirror #2 and Stripe #2, but never 2 mirrors with #2)

USHORT FtMember
Zero-based number identifying what member of the FT set is this partition.  E.g.
if the FT set is a stripe with 3 members then its members have FTMember equal
with 0, 1, 2

BOOLEAN            Modified;
Doesn't matter

7. Basically what you want to do is:
    For every disk description:
         For every partition description
        If FtType ==  NotAnFtMember
            continue;
        //This is member <FtMember> of the FT set identified by <FtType> + <FtGroup>.
        If you haven't create yet an object for this FT set then create it.
        Add this member to the FT set


8. I strongly recommend to take a look at the old WINDISK code: \\hx86fix\nt40src\private\utils\windisk .
Read the function InitializeFt from \src\ft.cxx to see how windisk "reads" the FT volumes.
Don't forget to match what you read from registry with what you actually find on the disks.

9. If you want to create / modify FT volumes then things get a little bit complicated.

*/

#if NTONLY == 4
LPBYTE CWin32LogDiskToPartition::GetDiskKey(void)
{
    CRegistry RegInfo;
    LPBYTE pBuff = NULL;

    DWORD dwRet = RegInfo.Open (

        HKEY_LOCAL_MACHINE,
        L"SYSTEM\\DISK",
        KEY_QUERY_VALUE
    ) ;

    if (dwRet == ERROR_SUCCESS)
    {
        DWORD dwSize = 0;
        if (RegInfo.GetCurrentBinaryKeyValue(L"Information", NULL, &dwSize) == ERROR_SUCCESS)
        {
            pBuff = new BYTE[dwSize];
            if (pBuff)
            {
                try
                {
                    if (RegInfo.GetCurrentBinaryKeyValue(L"Information", pBuff, &dwSize) != ERROR_SUCCESS)
                    {
						// The delete from here has been moved after Catch
                    }
                }
                catch ( ... )
                {
                    delete [] pBuff;
                    throw;
                }
				delete [] pBuff;
                pBuff = NULL;
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
    }

    ASSERT_BREAK(pBuff != NULL);

    return pBuff;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logdiskpartition.h ===
//=================================================================

//

// LogDiskPartition.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __ASSOC_LOGDISKPARTITION__
#define __ASSOC_LOGDISKPARTITION__

// Property set identification
//============================

#define	PROPSET_NAME_LOGDISKtoPARTITION	L"Win32_LogicalDiskToPartition"
#define BYTESPERSECTOR 512

class CWin32LogDiskToPartition : public Provider
{
public:

	// Constructor/destructor
	//=======================
	CWin32LogDiskToPartition(LPCWSTR strName, LPCWSTR pszNamespace = NULL ) ;
	~CWin32LogDiskToPartition() ;

	// Functions provide properties with current values
	//=================================================

	virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
	virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	// Utility
	//========

	// Utility function(s)
	//====================

private:
	// Utility function(s)
	//====================
#ifdef NTONLY
	HRESULT AddDynamicInstancesNT( MethodContext* pMethodContext );
#endif

#if NTONLY == 4
	// Windows NT Helpers
	HRESULT RefreshInstanceNT( CInstance* pInstance );
    LPBYTE GetDiskKey(void);
	HRESULT EnumPartitionsForDiskNT( CInstance* pLogicalDisk, TRefPointerCollection<CInstance>& partitionList, MethodContext* pMethodContext, LPBYTE pBuff );
    BOOL IsRelatedNT(

        DISK_EXTENT *diskExtent,
        DWORD dwDrive,
        DWORD dwPartition,
        ULONGLONG &u64StartingAddress,
        ULONGLONG &u64EndingAddress
    );
    DWORD GetExtentsForDrive(
        LPCWSTR lpwszLogicalDisk,
        LPBYTE pBuff,
        DISK_EXTENT *diskExtent
    );
#endif

#if NTONLY >= 5
	HRESULT EnumPartitionsForDiskNT5(CInstance* pLogicalDisk, TRefPointerCollection<CInstance>& partitionList, MethodContext* pMethodContext );
	HRESULT RefreshInstanceNT5( CInstance* pInstance );
#endif

#ifdef WIN9XONLY
	// Windows 95 Helpers
	HRESULT RefreshInstanceWin95( CInstance* pInstance );
	HRESULT AddDynamicInstancesWin95( MethodContext* pMethodContext, 
        LPCTSTR pszDrive, CInstance *pinstRefresh = NULL);
	HRESULT EnumPartitionsForDiskWin95( CInstance* pLogicalDisk, TRefPointerCollection<CInstance>& partitionList, MethodContext* pMethodContext );
#endif

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicaldisk.cpp ===
//=================================================================

//

// LogicalDisk.CPP -- Logical Disk property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//				09/10/97	a-sanjes		Added functions to differentiate
//											removeable media.
//
// Strings for ValueMaps for DriveType come from:
// \\trango\slmadd\src\shell\shell32\shel32.rc.  Search for
// IDS_DRIVES_REMOVABLE to find the clump.
//=================================================================
// following includes required for Getting if Volume is dirty 
// a property for chkdsk.

#include "precomp.h"
#include <assertbreak.h>
#include <winioctl.h>
#include "sid.h"
#include "implogonuser.h"
#include <frqueryex.h>
#include "resource.h"
#include "LogicalDisk.h"
#include "Kernel32Api.h"
#include <lmuse.h>
#include "DllWrapperBase.h"
#include "MprApi.h"
#include <initguid.h>
#include <DskQuota.h>
#include "..\dskquotaprovider\inc\DskQuotaCommon.h"

#include "AdvApi32Api.h"
#include "UserEnvApi.h"
#include "userhive.h"


#ifdef NTONLY
// for chkdisk dll exposed methods
#include <fmifs.h>
#include "mychkdsk.h"
#endif

#define LD_ALL_PROPS                        0xffffffff
#define LD_Name_BIT                         0x00000001
#define LD_Caption_BIT                      0x00000002
#define LD_DeviceID_BIT                     0x00000004
#define LD_Description_BIT                  0x00000008
#define LD_DriveType_BIT                    0x00000010
#define LD_SystemCreationClassName_BIT      0x00000020
#define LD_SystemName_BIT                   0x00000040
#define LD_MediaType_BIT                    0x00000080
#define LD_ProviderName_BIT                 0x00000100
#define LD_VolumeName_BIT                   0x00000200
#define LD_FileSystem_BIT                   0x00000400
#define LD_VolumeSerialNumber_BIT           0x00000800
#define LD_Compressed_BIT                   0x00001000
#define LD_SupportsFileBasedCompression_BIT 0x00002000
#define LD_MaximumComponentLength_BIT       0x00004000
#define LD_Size_BIT                         0x00008000
#define LD_FreeSpace_BIT                    0x00010000
// for dskQuotas
#define LD_SupportsDiskQuotas				0x00020000
#define LD_QuotasDisabled					0x00040000
#define LD_QuotasIncomplete					0x00080000
#define LD_QuotasRebuilding					0x00100000
//ForChkDsk
#define LD_VolumeDirty					0x00200000



#define LD_GET_VOL_INFO      (LD_VolumeName_BIT | \
                             LD_FileSystem_BIT | \
                             LD_VolumeSerialNumber_BIT | \
                             LD_Compressed_BIT | \
                             LD_SupportsFileBasedCompression_BIT | \
                             LD_MaximumComponentLength_BIT | \
                             LD_SupportsDiskQuotas | \
                             LD_QuotasDisabled | \
                             LD_QuotasIncomplete | \
                             LD_QuotasRebuilding | \
                             LD_VolumeDirty)


#define LD_SPIN_DISK        (LD_GET_VOL_INFO | \
                             LD_Size_BIT | \
                             LD_FreeSpace_BIT)

#ifdef NTONLY
std::map < DWORD, DWORD > mReturnVal;
#endif

// Property set declaration
//=========================
LogicalDisk MyLogicalDiskSet ( PROPSET_NAME_LOGDISK , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::LogicalDisk
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

LogicalDisk :: LogicalDisk (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
    m_ptrProperties.SetSize(22);

    m_ptrProperties[0] = ((LPVOID) IDS_Name);
    m_ptrProperties[1] = ((LPVOID) IDS_Caption);
    m_ptrProperties[2] = ((LPVOID) IDS_DeviceID);
    m_ptrProperties[3] = ((LPVOID) IDS_Description);
    m_ptrProperties[4] = ((LPVOID) IDS_DriveType);
    m_ptrProperties[5] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[7] = ((LPVOID) IDS_MediaType);
    m_ptrProperties[8] = ((LPVOID) IDS_ProviderName);
    m_ptrProperties[9] = ((LPVOID) IDS_VolumeName);
    m_ptrProperties[10] = ((LPVOID) IDS_FileSystem);
    m_ptrProperties[11] = ((LPVOID) IDS_VolumeSerialNumber);
    m_ptrProperties[12] = ((LPVOID) IDS_Compressed);
    m_ptrProperties[13] = ((LPVOID) IDS_SupportsFileBasedCompression);
    m_ptrProperties[14] = ((LPVOID) IDS_MaximumComponentLength);
    m_ptrProperties[15] = ((LPVOID) IDS_Size);
    m_ptrProperties[16] = ((LPVOID) IDS_FreeSpace);
	m_ptrProperties[17] = ((LPVOID) IDS_SupportsDiskQuotas);
	m_ptrProperties[18] = ((LPVOID) IDS_QuotasDisabled);
	m_ptrProperties[19] = ((LPVOID) IDS_QuotasIncomplete);
	m_ptrProperties[20] = ((LPVOID) IDS_QuotasRebuilding);
	m_ptrProperties[21] = ((LPVOID) IDS_VolumeDirty);
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::~LogicalDisk
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

LogicalDisk :: ~LogicalDisk ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::~LogicalDisk
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

HRESULT LogicalDisk :: ExecQuery (

	MethodContext *pMethodContext,
	CFrameworkQuery &pQuery,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Use the extended query type

    std::vector<int> vectorValues;
    DWORD dwTypeSize = 0;

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);

    // Find out what properties they asked for
    DWORD dwProperties = 0;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    // See if DriveType is part of the where clause
    pQuery2->GetValuesForProp(IDS_DriveType, vectorValues);
    dwTypeSize = vectorValues.size();

    // See if DeviceID is part of the where clause
    CHStringArray sDriveLetters;
    pQuery.GetValuesForProp ( IDS_DeviceID , sDriveLetters ) ;
    DWORD dwLetterSize = sDriveLetters.GetSize () ;

    // Format drives so they match what comes back from GetLogicalDriveStrings

    for ( DWORD x = 0 ; x < dwLetterSize ; x ++ )
    {
        sDriveLetters [ x ] += _T('\\') ;
    }

    // Get the LogicalDrive letters from the os

	TCHAR szDriveStrings [ 320 ] ;
    if ( GetLogicalDriveStrings ( ( sizeof(szDriveStrings)/sizeof(TCHAR)) - 1, szDriveStrings ) )
    {
        // Walk the drive letters
        for( TCHAR *pszCurrentDrive = szDriveStrings ; *pszCurrentDrive && SUCCEEDED ( hr ) ; pszCurrentDrive += (lstrlen(pszCurrentDrive) + 1))
        {
            bool bContinue = true;

            // If they specified a DriveType in the where clause
            if (dwTypeSize > 0)
            {

                // If we don't find a match, don't send back an instance
                bContinue = false;

                // Get the DriveType of the current loop
                DWORD dwDriveType = GetDriveType(pszCurrentDrive);

                // See if it matches any of the values required
                for ( DWORD x = 0; x < dwTypeSize ; x ++ )
                {
                    if ( vectorValues [ x ] == dwDriveType )
                    {
                        bContinue = true ;
                        break;
                    }
                }
            }

            // If DriveType failed, no point in continuing.
            // Otherwise, if they specified a DeviceID

            if ( ( bContinue ) && ( dwLetterSize > 0 ) )
            {
                // Even if DriveType matched, if they specified a DeviceID,
                // there's no point continuing if we don't find a match.

                bContinue = false;

                for ( DWORD x = 0 ; x < dwLetterSize ; x ++ )
                {
                    if ( sDriveLetters [ x ].CompareNoCase ( TOBSTRT ( pszCurrentDrive ) ) == 0 )
                    {
                        bContinue = true ;
                        break;
                    }
                }
            }

            // If the where clauses haven't filtered out this drive letter

            if ( bContinue )
            {
		        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false);
				CHString currentDrive ( pszCurrentDrive ) ;
				currentDrive.MakeUpper();

				pInstance->SetCHString(IDS_Name, currentDrive.SpanExcluding(L"\\"));
				pInstance->SetCHString(IDS_Caption, currentDrive.SpanExcluding(L"\\"));
				pInstance->SetCHString(IDS_DeviceID, currentDrive.SpanExcluding(L"\\"));

				GetLogicalDiskInfo ( pInstance, dwProperties ) ;

				hr = pInstance->Commit (  ) ;
            }
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT LogicalDisk :: GetObject (

	CInstance *pInstance,
	long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hRetCode = WBEM_E_NOT_FOUND;

    TCHAR szDriveStrings[320] ;
    if ( GetLogicalDriveStrings((sizeof(szDriveStrings) - 1) / sizeof(TCHAR), szDriveStrings ) )
	{
		CHString strName ;
		pInstance->GetCHString(IDS_DeviceID, strName);

        for (	TCHAR *pszCurrentDrive = szDriveStrings ;
				*pszCurrentDrive ;
				pszCurrentDrive += (lstrlen(pszCurrentDrive) + 1)
		)
		{
			CHString strDrive = pszCurrentDrive ;

			if ( 0 == strName.CompareNoCase( strDrive.SpanExcluding(L"\\") ) )
			{
				pInstance->SetCHString ( IDS_Name , strName ) ;
				pInstance->SetCHString ( IDS_Caption, strName ) ;

				// We will want expensive properties in this case

                CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);

                // Find out what properties they asked for
                DWORD dwProperties = 0;
                pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);
				GetLogicalDiskInfo ( pInstance , dwProperties ) ;

				hRetCode = WBEM_S_NO_ERROR;

				break ;
			}
        }
    }

    return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT LogicalDisk :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    TCHAR szDriveStrings[320] ;

	HRESULT hr = WBEM_S_NO_ERROR;
    if ( GetLogicalDriveStrings ( ( sizeof ( szDriveStrings ) / sizeof ( TCHAR ) ) - 1 , szDriveStrings ) )
	{
        for(	TCHAR *pszCurrentDrive = szDriveStrings ;
				*pszCurrentDrive && SUCCEEDED ( hr ) ;
				pszCurrentDrive += (lstrlen(pszCurrentDrive) + 1)
		)
		{
	        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
			CHString currentDrive ( pszCurrentDrive ) ;
			currentDrive.MakeUpper ();

			pInstance->SetCHString ( IDS_Name , currentDrive.SpanExcluding(L"\\"));
			pInstance->SetCHString ( IDS_Caption , currentDrive.SpanExcluding(L"\\"));
			pInstance->SetCHString ( IDS_DeviceID , currentDrive.SpanExcluding(L"\\"));

			GetLogicalDiskInfo ( pInstance , LD_ALL_PROPS ) ;

			hr = pInstance->Commit (  ) ;
        }
    }

    return hr;
}

#ifdef NTONLY

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::ExecMethod
*
*  DESCRIPTION :    Providing methods of chkdsk
*
*****************************************************************************/
HRESULT LogicalDisk::ExecMethod ( 

	const CInstance& Instance,
    const BSTR bstrMethodName,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags
) 
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	if ( ! pOutParams )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		// Do we recognize the method?
		if ( _wcsicmp ( bstrMethodName , METHOD_NAME_CHKDSK ) == 0 )
		{
			// This method is instance specific
			hRes = ExecChkDsk ( Instance , pInParams , pOutParams , lFlags ) ;	
		}
		else
		if ( _wcsicmp ( bstrMethodName , METHOD_NAME_SCHEDULEAUTOCHK ) == 0 )
		{
			// Following methods are static, i.e. not dependent on the instance
			hRes = ExecScheduleChkdsk ( pInParams , pOutParams,  lFlags ) ;
		}
		else
		if ( _wcsicmp ( bstrMethodName , METHOD_NAME_EXCLUDEFROMAUTOCHK ) == 0 )
		{
			hRes = ExecExcludeFromChkDsk ( pInParams , pOutParams, lFlags ) ;
		}
	}
		
	return hRes;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetLogicalDiskInfo
 *
 *  DESCRIPTION : Loads LOGDISK_INFO struct w/property values according to
 *                disk type
 *
 *  INPUTS      : BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void LogicalDisk :: GetLogicalDiskInfo (

	CInstance *pInstance,
	DWORD dwProperties
)
{
	CHString name;
	pInstance->GetCHString ( IDS_Name , name ) ;
	ASSERT_BREAK(!name.IsEmpty());

    TCHAR szTemp[10] ;
    lstrcpy(szTemp, TOBSTRT(name)) ;
	lstrcat(szTemp, _T("\\")) ;

	// We got a drive letter.  If the disk is fixed, removable, or
	// a CD-ROM, assume it must be installed.  For network drives
	// or RAM Disk, "installed" doesn't seem to be applicable.

	DWORD dwDriveType = GetDriveType ( szTemp ) ;
    switch(dwDriveType)
	{
        case DRIVE_FIXED:
		{
            GetFixedDriveInfo ( pInstance, szTemp, dwProperties ) ;
		}
		break ;

		case DRIVE_REMOVABLE :
		{
            GetRemoveableDriveInfo ( pInstance,  szTemp, dwProperties ) ;
		}
		break ;

        case DRIVE_REMOTE :
		{
            GetRemoteDriveInfo ( pInstance,  szTemp, dwProperties ) ;
		}
        break ;

        case DRIVE_CDROM :
		{
			GetCDROMDriveInfo ( pInstance,  szTemp, dwProperties ) ;
		}
        break ;

        case DRIVE_RAMDISK :
		{
            GetRAMDriveInfo ( pInstance,  szTemp, dwProperties ) ;
		}
        break ;

        default :
		{
            pInstance->SetWCHARSplat(IDS_Description, L"Unknown drive type");
		}
        break ;
	}

	pInstance->SetDWORD ( IDS_DriveType , dwDriveType ) ;

	SetCreationClassName ( pInstance ) ;

	pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

	pInstance->SetCHString ( IDS_SystemName, GetLocalComputerName () ) ;

}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetFixedDriveInfo
 *
 *  DESCRIPTION : Retrieves property values for fixed-media logical disk
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *					BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void LogicalDisk :: GetFixedDriveInfo (

	CInstance *pInstance,
	LPCTSTR pszName,
	DWORD dwProperties
)
{
	// Identify the drive type

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_LocalFixedDisk);

	pInstance->SetCHString ( IDS_Description , sTemp2 ) ;

    pInstance->SetDWORD ( IDS_MediaType , FixedMedia ) ;

    DWORD dwResult = 0 ;

	// Get Expensive properties now if appropriate.
	if ( dwProperties & LD_GET_VOL_INFO)
	{
		// Obtain volume information

		dwResult = GetDriveVolumeInformation ( pInstance , pszName ) ;
    }

    if (dwResult == 0)
    {
        if ( dwProperties &
            (LD_Size_BIT |
             LD_FreeSpace_BIT) )
		{
		    GetDriveFreeSpace ( pInstance , pszName ) ;
	    }
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetRemoveableDriveInfo
 *
 *  DESCRIPTION : Retrieves property values for removeable drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *					BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Separates call based on 95 or NT
 *
 *****************************************************************************/

void LogicalDisk :: GetRemoveableDriveInfo (

	CInstance *pInstance,
	LPCTSTR pszName,
	DWORD dwProperties
)
{

	// In case anything goes wrong, at least say we're working with
	// a removeable disk.

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_RemovableDisk);

	pInstance->SetCHString ( IDS_Description , sTemp2 ) ;

	// Obtaining removeable drive information requires the use of
	// the DeviceIoControl function.  To further complicate things,
	// the method of retrieval is different for NT and 95, so
	// let's just farm out the function calls now.

	BOOL t_MediaPresent = FALSE ;
#ifdef NTONLY
	GetRemoveableDriveInfoNT ( pInstance, pszName , t_MediaPresent, dwProperties );
#endif
#ifdef WIN9XONLY
	GetRemoveableDriveInfo95 ( pInstance, pszName , t_MediaPresent ) ;
#endif

    DWORD dwResult = 0 ;

	// Get Expensive properties now if appropriate.
	if ( t_MediaPresent &&
	     ( dwProperties & LD_GET_VOL_INFO ) )
	{
		dwResult = GetDriveVolumeInformation ( pInstance, pszName );
    }

    if (t_MediaPresent && dwResult == 0)
    {
        if ( dwProperties &
            (LD_Size_BIT |
             LD_FreeSpace_BIT) )
		{
		    GetDriveFreeSpace ( pInstance , pszName ) ;
	    }
    }

}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetRemoveableDriveInfoNT
 *
 *  DESCRIPTION : Retrieves property values for removeable drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Performs operation using DeviceIoControl in NT
 *
 *****************************************************************************/

#ifdef NTONLY
void LogicalDisk :: GetRemoveableDriveInfoNT (

	CInstance *pInstance,
	LPCTSTR pszName ,
	BOOL &a_MediaPresent,
    DWORD dwProperties
)
{
    // we have this set globally at system startup time.
    // SOMETHING is stepping on it on NT 3.51 *only*  This suggests
    // that a DLL we load is turning it off.
    if ( IsWinNT351 () )
    {
        UINT oldErrorMode = SetErrorMode ( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX ) ;
        SetErrorMode ( oldErrorMode | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX ) ;
    }

	// Convert the drive letter to a number (the indeces are 1 based)

	int nDrive = ( toupper(*pszName) - 'A' ) + 1;

	// The following code was lifted from Knowledge Base Article
	// Q163920.  The code uses DeviceIoControl to discover the
	// type of drive we are dealing with.

	TCHAR szDriveName[8];
	wsprintf(szDriveName, TEXT("\\\\.\\%c:"), TEXT('@') + nDrive);

    DWORD dwAccessMode;

    if (dwProperties & LD_SPIN_DISK)
    {
        dwAccessMode = FILE_READ_ACCESS;
    }
    else
    {
        dwAccessMode = FILE_ANY_ACCESS;
    }

	SmartCloseHandle hVMWIN32 = CreateFile (

		szDriveName,
		dwAccessMode,
		FILE_SHARE_WRITE | FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		0,
		0
	);

	if ( hVMWIN32 != INVALID_HANDLE_VALUE )
	{

/*
 * Verify media present
 */
        if (dwProperties & LD_SPIN_DISK)
        {
		    DWORD t_BytesReturned ;
		    a_MediaPresent = DeviceIoControl (

			    hVMWIN32,
#if NTONLY >= 5
			    IOCTL_STORAGE_CHECK_VERIFY ,
#else
                IOCTL_DISK_CHECK_VERIFY,
#endif
			    NULL,
			    0,
			    NULL,
			    0,
			    &t_BytesReturned,
			    0
		    ) ;

            if (!a_MediaPresent)
            {
		        DWORD t_GetLastError = GetLastError () ;
		        if ( t_GetLastError != ERROR_NOT_READY )
		        {
			        LogErrorMessage2(L"Device IO control returned unexpected error for Check verify: (%d)", t_GetLastError);
		        }
            }
        }
        else
        {
            a_MediaPresent = FALSE;
        }

/*
 * Get media types
 */

		DISK_GEOMETRY Geom[20];
		DWORD cb ;

		BOOL t_Status = DeviceIoControl (

			hVMWIN32,
			IOCTL_DISK_GET_MEDIA_TYPES,
			0,
			0,
			Geom,
			sizeof(Geom),
			&cb,
			0
		) ;

		if ( t_Status && cb > 0 )
		{
			int nGeometries = cb / sizeof(DISK_GEOMETRY) ;
			BOOL bFound = FALSE ;

			// Go through all geometries.  If we find any 3.5 ones,
			// put it in Geom[0].  This seems to happen on PC-98s.

			for ( int i = 0; i < nGeometries && ! bFound; i++ )
			{
				switch ( Geom [ i ].MediaType )
				{
					// Found something 'higher' than a 5.25 drive, so
					// move it into Geom[0] and get out.

					case RemovableMedia:
					case F3_1Pt44_512: // 3.5 1.44MB floppy
					case F3_2Pt88_512: // 3.5 2.88MB floppy
					case F3_20Pt8_512: // 3.5 20.8MB floppy
					case F3_720_512:   // 3.5 720K   floppy
					case F3_120M_512:  // 3.5 120MB  floppy
					{
						Geom[0].MediaType = Geom[i].MediaType ;

						bFound = TRUE;
					}
					break;

					default:
					{
					}
					break;
				}
			}

			pInstance->SetDWORD ( IDS_MediaType , Geom[0].MediaType ) ;

            CHString sTemp2;

			switch ( Geom [ 0 ].MediaType )
			{
				case F5_1Pt2_512: // 5.25 1.2MB floppy
				case F5_360_512:  // 5.25 360K  floppy
				case F5_320_512:  // 5.25 320K  floppy
				case F5_320_1024: // 5.25 320K  floppy
				case F5_180_512:  // 5.25 180K  floppy
				case F5_160_512:  // 5.25 160K  floppy
				{
                    LoadStringW(sTemp2, IDR_525Floppy);

				}
				break;

				case F3_1Pt44_512: // 3.5 1.44MB floppy
				case F3_2Pt88_512: // 3.5 2.88MB floppy
				case F3_20Pt8_512: // 3.5 20.8MB floppy
				case F3_720_512:   // 3.5 720K   floppy
				case F3_120M_512:  // 3.5 120MB  floppy
				{
                    LoadStringW(sTemp2, IDR_350Floppy);
				}
				break;

				default: // unknown already defaulted to "Removeable Disk"
				{
				}
				break;
			}

		    pInstance->SetCHString(IDS_Description, sTemp2);
		}
	}
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetRemoveableDriveInfo95
 *
 *  DESCRIPTION : Retrieves property values for removeable drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Performs operation using DeviceIoControl in NT
 *
 *****************************************************************************/

#ifdef WIN9XONLY
void LogicalDisk :: GetRemoveableDriveInfo95 (

	CInstance *pInstance,
	LPCTSTR pszName ,
	BOOL &a_MediaVerified
)
{
	pInstance->SetDWORD ( IDS_MediaType , Unknown ) ;

	// Convert the drive letter to a number (the indeces are 1 based)
	int nDrive = ( toupper(*pszName) - 'A' ) + 1;

	DEVICEPARMS dpb ;
	dpb.btSpecialFunctions = 0;  // return default type; do not hit disk

	// Make sure both DeviceIoControl and Int 21h succeeded.
	if ( GetDeviceParms ( & dpb, nDrive ) )
	{
		a_MediaVerified = TRUE ;

      // If the wSectorsPerTrack entry is 0, then the REAL SectorsPerTrack
      // is stored in dwSectorsPerTrack.

		DWORD dwActualSectorsPerTrack ;

		if (dpb.stBPB.wSectorsPerTrack > 0)
		{
			dwActualSectorsPerTrack = dpb.stBPB.wSectorsPerTrack ;
		}
		else
		{
			dwActualSectorsPerTrack = dpb.stBPB.dwSectorsPerTrack ;
		}

        CHString sTemp2;

		switch ( dpb.btDeviceType )
		{
			case 0: // 5.25 360K floppy
			{
                LoadStringW(sTemp2, IDR_525Floppy);
				if ( dpb.stBPB.wHeads == 1 )
				{
					if ( dwActualSectorsPerTrack == 8 )
					{
						pInstance->SetDWORD ( IDS_MediaType , F5_160_512 ) ;
					}
					else if ( dwActualSectorsPerTrack == 9 )
					{
						pInstance->SetDWORD ( IDS_MediaType , F5_180_512 ) ;
					}
				}
				else if ( dpb.stBPB.wHeads == 2 )
				{
					if ( dwActualSectorsPerTrack == 8 )
					{
						if (dpb.stBPB.wBytesPerSector == 512)
						{
							pInstance->SetDWORD ( IDS_MediaType , F5_320_512 );
						}
						else if (dpb.stBPB.wBytesPerSector == 1024)
						{
							pInstance->SetDWORD(IDS_MediaType, F5_320_1024);
						}
					}
					else if (dwActualSectorsPerTrack == 9)
					{
						pInstance->SetDWORD(IDS_MediaType, F5_360_512);
					}
				}
			}
            break;

			case 1: // 5.25 1.2MB floppy
			{
                LoadStringW(sTemp2, IDR_525Floppy);
				pInstance->SetDWORD ( IDS_MediaType , F5_1Pt2_512 ) ;
			}
			break;

			case 2: // 3.5  720K floppy
			{
                LoadStringW(sTemp2, IDR_350Floppy);
				pInstance->SetDWORD(IDS_MediaType, F3_720_512);
			}
            break;

			case 7: // 3.5  1.44MB floppy
			{
                LoadStringW(sTemp2, IDR_350Floppy);
				pInstance->SetDWORD(IDS_MediaType, F3_1Pt44_512);
			}
            break;

			case 9: // 3.5  2.88MB floppy
			{
                LoadStringW(sTemp2, IDR_350Floppy);
				pInstance->SetDWORD(IDS_MediaType, F3_2Pt88_512);
			}
			break;

			case 3: // 8" low-density floppy
			case 4: // 8" high-density floppy
			{
                LoadStringW(sTemp2, IDR_800Floppy);
			}
			break;

			default: // unknown already defaulted to "Removeable Disk"
			{
			}
			break;
		}

        if (!sTemp.IsEmpty())
        {
		    pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
        }
	}
}

#endif


/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetRemoteDriveInfo
 *
 *  DESCRIPTION : Retrieves property values for remote logical drives
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *					BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void LogicalDisk::GetRemoteDriveInfo (

	CInstance *pInstance,
	LPCTSTR pszName,
	DWORD dwProperties
)
{
	CMprApi *t_MprApi = ( CMprApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidMprApi, NULL ) ;
	if ( t_MprApi )
	{
		pInstance->SetDWORD ( IDS_MediaType , Unknown ) ;

        CHString sTemp2;

        LoadStringW(sTemp2, IDR_NetworkConnection);
		pInstance->SetCHString ( IDS_Description , sTemp2 ) ;

		// Get Expensive properties now if appropriate.
	    if ( dwProperties &
                (LD_SPIN_DISK |
                LD_ProviderName_BIT) )
    {
			// Use this class to impersonate the user logged onto the
			// desktop if we are running in Windows NT, since redirtected
			// drive APIs use logonID and not SID for access checks.

#ifdef NTONLY
			CImpersonateLoggedOnUser impersonateLoggedOnUser;

			if ( !impersonateLoggedOnUser.Begin() )
			{
			}
#endif

			try
			{
				if ( dwProperties & LD_ProviderName_BIT )
				{
					// Enumerate network resources to identify this drive's share
					//===========================================================

					// The enumeration will return drives identified by Drive Letter
					// and a colon (e.g. M:)

					TCHAR szTempDrive[_MAX_PATH] ;
					_stprintf(szTempDrive, _T("%c%c"), pszName[0], pszName[1]) ;

					TCHAR szProvName[_MAX_PATH];
					DWORD dwProvName = sizeof ( szProvName ) ;

					DWORD dwRetCode = t_MprApi->WNetGetConnection ( szTempDrive , szProvName , & dwProvName ) ;
					if (dwRetCode == NO_ERROR)
					{
						pInstance->SetCharSplat ( IDS_ProviderName , szProvName ) ;
					}
					else
					{
						dwRetCode = GetLastError();

						if ( ( dwRetCode == ERROR_MORE_DATA ) && (dwProvName > _MAX_PATH ) )
						{
							TCHAR *szNewProvName = new TCHAR[dwProvName];
							if (szNewProvName != NULL)
							{
								try
								{
									dwRetCode = t_MprApi->WNetGetConnection ( szTempDrive , szNewProvName , &dwProvName);
									if (dwRetCode == NO_ERROR)
									{
										pInstance->SetCharSplat(IDS_ProviderName, szNewProvName);
									}
								}
								catch ( ... )
								{
									delete [] szNewProvName ;

									throw ;
								}

								delete [] szNewProvName ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}

						}
					}
				}

				DWORD dwResult = 0 ;

				// Get Expensive properties now if appropriate.

            	if ( dwProperties & LD_GET_VOL_INFO )
				{
					// Obtain volume information
					dwResult = GetDriveVolumeInformation ( pInstance, pszName );
				}

				if ( dwResult == 0 )
				{
					if ( dwProperties &
						(LD_Size_BIT |
						 LD_FreeSpace_BIT) )
					{
						GetDriveFreeSpace ( pInstance , pszName );
					}
				}
			}
			catch ( ... )
			{
#ifdef NTONLY
				if ( !impersonateLoggedOnUser.End() )
				{
				}
#endif

				throw ;
			}

#ifdef NTONLY

			// Cleanup impersonation if appropriate
			if ( !impersonateLoggedOnUser.End() )
			{
			}
#endif

		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidMprApi , t_MprApi ) ;
	}
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetCDROMDriveInfo
 *
 *  DESCRIPTION : Retrieves property values for CD-ROM logical drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *					BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void LogicalDisk :: GetCDROMDriveInfo (

	CInstance *pInstance,
	LPCTSTR pszName,
	DWORD dwProperties
)
{
    CHString sTemp2;

    LoadStringW(sTemp2, IDR_CDRomDisk);

    pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
    pInstance->SetDWORD ( IDS_MediaType , RemovableMedia ) ;

	// Get Expensive properties now if appropriate.

	BOOL t_MediaPresent = FALSE ;
#ifdef NTONLY
	GetCDROMDriveInfoNT ( pInstance, pszName , t_MediaPresent, dwProperties );
#endif
#ifdef WIN9XONLY
	GetCDROMDriveInfo95 ( pInstance, pszName , t_MediaPresent) ;
#endif

    DWORD dwResult = 0 ;

	if ( t_MediaPresent &&
        ( dwProperties &  LD_GET_VOL_INFO ) )
    {
		// Obtain volume information
		dwResult = GetDriveVolumeInformation ( pInstance , pszName ) ;
    }

    if ( t_MediaPresent && dwResult == 0 )
    {
        if ( dwProperties &
            (LD_Size_BIT |
             LD_FreeSpace_BIT) )
		{
		    GetDriveFreeSpace(pInstance, pszName );
	    }
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetCDROMDriveInfoNT
 *
 *  DESCRIPTION : Retrieves property values for CDROM drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Performs operation using DeviceIoControl in NT
 *
 *****************************************************************************/

#ifdef NTONLY
void LogicalDisk :: GetCDROMDriveInfoNT (

	CInstance *pInstance,
	LPCTSTR pszName ,
	BOOL &a_MediaPresent,
    DWORD dwProperties
)
{
    // we have this set globally at system startup time.
    // SOMETHING is stepping on it on NT 3.51 *only*  This suggests
    // that a DLL we load is turning it off.
    if ( IsWinNT351 () )
    {
        UINT oldErrorMode = SetErrorMode ( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX ) ;
        SetErrorMode ( oldErrorMode | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX ) ;
    }

	// Convert the drive letter to a number (the indeces are 1 based)

	int nDrive = ( toupper(*pszName) - 'A' ) + 1;

	// The following code was lifted from Knowledge Base Article
	// Q163920.  The code uses DeviceIoControl to discover the
	// type of drive we are dealing with.

	TCHAR szDriveName[8];
	wsprintf(szDriveName, TEXT("\\\\.\\%c:"), TEXT('@') + nDrive);

    DWORD dwAccessMode;

    if (dwProperties & LD_SPIN_DISK)
    {
        dwAccessMode = FILE_READ_ACCESS;
    }
    else
    {
        dwAccessMode = FILE_ANY_ACCESS;
    }

	SmartCloseHandle hVMWIN32 = CreateFile (

		szDriveName,
		dwAccessMode,
		FILE_SHARE_WRITE | FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		0,
		0
	);

	if ( hVMWIN32 != INVALID_HANDLE_VALUE )
	{

/*
 * Verify media present
 */
        if (dwProperties & LD_SPIN_DISK)
        {
    		DWORD t_BytesReturned ;
		    a_MediaPresent = DeviceIoControl (

			    hVMWIN32,
#if NTONLY >= 5
			    IOCTL_STORAGE_CHECK_VERIFY ,
#else
                IOCTL_DISK_CHECK_VERIFY,
#endif
			    NULL,
			    0,
			    NULL,
			    0,
			    &t_BytesReturned,
			    0
		    ) ;

            if (!a_MediaPresent)
            {
		        DWORD t_GetLastError = GetLastError () ;
		        if ( t_GetLastError != ERROR_NOT_READY )
		        {
			        LogErrorMessage2(L"Device IO control returned unexpected error for Check verify: (%d)", t_GetLastError);
		        }
            }
        }
        else
        {
            a_MediaPresent = FALSE;
        }
	}
	else
	{
		a_MediaPresent = GetLastError() == ERROR_ACCESS_DENIED;
	}
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetCDROMDriveInfo95
 *
 *  DESCRIPTION : Retrieves property values for CDROM drive
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Performs operation using DeviceIoControl in NT
 *
 *****************************************************************************/

#ifdef WIN9XONLY
void LogicalDisk :: GetCDROMDriveInfo95 (

	CInstance *pInstance,
	LPCTSTR pszName ,
	BOOL &a_MediaVerified
)
{
	// Convert the drive letter to a number (the indeces are 1 based)
	int nDrive = ( toupper(*pszName) - 'A' ) + 1;

	DEVICEPARMS dpb ;
	dpb.btSpecialFunctions = 0;  // return default type; do not hit disk

	// Make sure both DeviceIoControl and Int 21h succeeded.
	if ( GetDeviceParms ( & dpb, nDrive ) )
	{
		a_MediaVerified = TRUE ;
	}
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetRAMDriveInfo
 *
 *  DESCRIPTION : Retrieves property values for RAM drives
 *
 *  INPUTS      : char*		pszName - Name of Drive to get info for.
 *					BOOL	fGetExpensiveProperties - Exp. Properties flag.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void LogicalDisk :: GetRAMDriveInfo (

	CInstance *pInstance,
	LPCTSTR pszName,
	DWORD dwProperties
)
{
    CHString sTemp2;

    LoadStringW(sTemp2, IDR_RAMDisk);

    pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
    pInstance->SetDWORD ( IDS_MediaType , Unknown ) ;

    DWORD dwResult = 0 ;

	// Get Expensive properties now if appropriate.
	if ( dwProperties & LD_GET_VOL_INFO )
	{
		// Obtain volume information
		dwResult = GetDriveVolumeInformation ( pInstance , pszName ) ;
    }

    if ( dwResult == 0 )
    {
        if ( dwProperties &
            (LD_Size_BIT |
             LD_FreeSpace_BIT) )
		{
		    GetDriveFreeSpace ( pInstance , pszName ) ;
	    }
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetDriveVolumeInformation
 *
 *  DESCRIPTION : Retrieves property values for fixed-media logical disk
 *
 *  INPUTS      : const char*	pszName - Name of volume to retrieve
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : BOOL			TRUE/FALSE - Able/Unable to perform
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

DWORD LogicalDisk :: GetDriveVolumeInformation (

	CInstance *pInstance,
	LPCTSTR pszName
)
{
#ifdef NTONLY

    // we have this set globally at system startup time.
    // SOMETHING is stepping on it on NT 3.51 *only*  This suggests
    // that a DLL we load is turning it off.

    if ( IsWinNT351 () )
    {
        UINT oldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
        SetErrorMode(oldErrorMode | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
    }

#endif

	DWORD dwReturn = 0 ;

	TCHAR szVolumeName[_MAX_PATH] ;
	TCHAR szFileSystem[_MAX_PATH] ;

    DWORD dwSerialNumber ;
	DWORD dwMaxComponentLength ;
	DWORD dwFSFlags ;

	BOOL fReturn = GetVolumeInformation (

		pszName,
		szVolumeName,
		sizeof(szVolumeName)/sizeof(TCHAR),
		&dwSerialNumber,
		&dwMaxComponentLength,
		&dwFSFlags,
		szFileSystem,
		sizeof(szFileSystem)/sizeof(TCHAR)
	) ;

    if ( fReturn )
	{
	// Win32 API will return volume information for all drive types.

        pInstance->SetCharSplat ( IDS_VolumeName , szVolumeName ) ;
        pInstance->SetCharSplat ( IDS_FileSystem , szFileSystem ) ;

        // Per raid 50801
        if (dwSerialNumber != 0)
        {
	        TCHAR szTemp[_MAX_PATH] ;
            _stprintf(szTemp, _T("%.8X"), dwSerialNumber) ;

            pInstance->SetCharSplat ( IDS_VolumeSerialNumber , szTemp ) ;
        }

		pInstance->Setbool ( IDS_Compressed , dwFSFlags & FS_VOL_IS_COMPRESSED ) ;
        pInstance->Setbool ( IDS_SupportsFileBasedCompression , dwFSFlags & FS_FILE_COMPRESSION ) ;
		pInstance->SetDWORD ( IDS_MaximumComponentLength , dwMaxComponentLength ) ;


#if NTONLY == 5

		pInstance->Setbool ( IDS_SupportsDiskQuotas,  dwFSFlags & FILE_VOLUME_QUOTAS ) ;

		IDiskQuotaControlPtr pIQuotaControl;

		// Here Get the State of the volume, we need to get the Interface pointer.
		if (  SUCCEEDED ( CoCreateInstance(
												CLSID_DiskQuotaControl,
												NULL,
												CLSCTX_INPROC_SERVER,
												IID_IDiskQuotaControl,
												(void **)&pIQuotaControl ) ) )
		{
			CHString t_VolumeName;
			HRESULT hRes = WBEM_S_NO_ERROR;
			pInstance->GetCHString ( IDS_DeviceID, t_VolumeName );

			WCHAR w_VolumePathName [ MAX_PATH + 1 ];

			BOOL bRetVal = GetVolumePathName(
									t_VolumeName.GetBuffer ( 0 ),           // file path
									w_VolumePathName,     // volume mount point
									MAX_PATH		  // Size of the Buffer
							 );
			if ( bRetVal )
			{
				if ( SUCCEEDED ( pIQuotaControl->Initialize (  w_VolumePathName, TRUE ) ) )
				{
					DWORD dwQuotaState;
					hRes = pIQuotaControl->GetQuotaState( &dwQuotaState );

					if ( SUCCEEDED ( hRes ) )
					{
						pInstance->Setbool ( IDS_QuotasIncomplete,  DISKQUOTA_FILE_INCOMPLETE ( dwQuotaState) ) ;
					
						pInstance->Setbool ( IDS_QuotasRebuilding,  DISKQUOTA_FILE_REBUILDING ( dwQuotaState) ) ;
				
						pInstance->Setbool ( IDS_QuotasDisabled,  DISKQUOTA_IS_DISABLED (dwQuotaState) );
					}
					else
					{
						dwReturn = GetLastError () ;
					}
				}
			}
		}
		else
		{
			dwReturn = GetLastError () ;
		}

#endif // NTONLY == 5

#ifdef NTONLY 

// for chkdsk VolumeDirty Property
	BOOLEAN bVolumeDirty = FALSE;
	BOOL bSuccess = FALSE;

	CHString t_DosDrive ( pszName );
	UNICODE_STRING string = { 0 };

    try
    {
	    if(RtlDosPathNameToNtPathName_U ( t_DosDrive .GetBuffer( 0 ), &string, NULL, NULL ) &&
            string.Buffer)
        {	    
            string.Buffer[string.Length/sizeof(WCHAR) - 1] = 0;
	        CHString nt_drive_name ( string.Buffer);

	        bSuccess = IsVolumeDirty ( nt_drive_name, &bVolumeDirty );

	        if ( bSuccess )
	        {
 		        pInstance->Setbool ( IDS_VolumeDirty,  bVolumeDirty);
	        }

            RtlFreeUnicodeString(&string);
            string.Buffer = NULL;
        }
        else
        {
            dwReturn = -1L;
        }
    }
    catch(...)
    {
        if(string.Buffer)
        {
            RtlFreeUnicodeString(&string);
            string.Buffer = NULL;
        }
        throw;
    }

#endif

    }
    else
    {
        dwReturn = GetLastError () ;
    }

    return dwReturn ;
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::GetDriveFreeSpace
 *
 *  DESCRIPTION : Retrieves Space Information for the specified Drive.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : BOOL		TRUE/FALSE - Able/Unable to perform
 *
 *  COMMENTS    : Uses GetDiskFreeSpaceEx if available.
 *
 *****************************************************************************/

BOOL LogicalDisk :: GetDriveFreeSpace (

	CInstance *pInstance,
	LPCTSTR pszName
)
{
	BOOL fReturn = FALSE ;

    // See if GetDiskFreeSpaceEx() is supported
    //=========================================

    CKernel32Api *pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
    if ( pKernel32 != NULL )
    {
		try
		{
			BOOL fRetval = FALSE;

			ULARGE_INTEGER uliTotalBytes ;
			ULARGE_INTEGER uliUserFreeBytes ;
			ULARGE_INTEGER uliTotalFreeBytes ;

			if ( pKernel32->GetDiskFreeSpaceEx ( pszName, &uliUserFreeBytes, &uliTotalBytes, & uliTotalFreeBytes, & fRetval ) )
			{
				if ( fRetval )
				{
					fReturn = TRUE ;

					pInstance->SetWBEMINT64(IDS_Size, uliTotalBytes.QuadPart);
					pInstance->SetWBEMINT64(IDS_FreeSpace, uliTotalFreeBytes.QuadPart);
				}
				else
				{
					// If we couldn't get extended info -- use old API
					// (known to be inaccurate on Win95 for >2G drives)
					//=================================================

					DWORD x = GetLastError();

					DWORD dwBytesPerSector ;
					DWORD dwSectorsPerCluster ;
					DWORD dwFreeClusters ;
					DWORD dwTotalClusters ;

					BOOL t_Status = GetDiskFreeSpace (

						pszName,
						&dwSectorsPerCluster,
						&dwBytesPerSector,
						&dwFreeClusters,
						&dwTotalClusters
					) ;

					if ( t_Status )
					{
						fReturn = TRUE ;

						__int64	i64Temp = (__int64) dwTotalClusters *
										(__int64) dwSectorsPerCluster *
										(__int64) dwBytesPerSector ;

						pInstance->SetWBEMINT64(IDS_Size, i64Temp);

						i64Temp = (__int64) dwFreeClusters *
								  (__int64) dwSectorsPerCluster *
								  (__int64) dwBytesPerSector ;

						pInstance->SetWBEMINT64( IDS_FreeSpace , i64Temp ) ;
					}
					else
					{
						DWORD x = GetLastError () ;

						fReturn = FALSE ;
					}
				}
			}
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);

			throw ;
		}

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
    }

    return fReturn;
}

/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::PutInstance
 *
 *  DESCRIPTION : Write changed instance
 *
 *  INPUTS      : pInstance to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT LogicalDisk :: PutInstance (

	const CInstance &pInstance,
	long lFlags /*= 0L*/
)
{
    // Tell the user we can't create a new logicaldisk (much as we might like to)

    if ( lFlags & WBEM_FLAG_CREATE_ONLY )
    {
	    return WBEM_E_UNSUPPORTED_PARAMETER ;
    }


    HRESULT hRet = WBEM_E_FAILED ;

    // See if we got a name we can recognize

    if ( ! pInstance.IsNull ( IDS_DeviceID ) )
    {
		CHString sName ;
	    pInstance.GetCHString ( IDS_DeviceID , sName ) ;
	    DWORD dwFind = sName.Find (':');

	    // Check for bad drive names

	    if ( ( dwFind == -1 ) || (dwFind != sName.GetLength () - 1 ) )
	    {
		    hRet = WBEM_E_INVALID_PARAMETER ;
	    }
	    else
	    {
		    sName = sName.Left(dwFind + 1);
		    sName += '\\';

		    DWORD dwDriveType = GetDriveType ( TOBSTRT(sName) ) ;
		    if ( ( dwDriveType == DRIVE_UNKNOWN ) || ( dwDriveType == DRIVE_NO_ROOT_DIR ) )
		    {
			    if ( lFlags & WBEM_FLAG_UPDATE_ONLY )
			    {
			        hRet = WBEM_E_NOT_FOUND ;
			    }
			    else
			    {
			        hRet = WBEM_E_UNSUPPORTED_PARAMETER;
			    }
		    }
		    else
		    {

			    hRet = WBEM_S_NO_ERROR;

			    if ( ! pInstance.IsNull ( IDS_VolumeName ) )
			    {
					CHString sVolume ;
			        pInstance.GetCHString ( IDS_VolumeName , sVolume ) ;

#ifdef WIN9XONLY
                    if ( sVolume.GetLength () > 11 )
					{
                        hRet = WBEM_E_INVALID_PARAMETER;
					}
                    else
#endif
                    {
			            if ( SetVolumeLabel ( TOBSTRT(sName), TOBSTRT(sVolume) ) )
			            {
				            hRet = WBEM_NO_ERROR ;
			            }
			            else
			            {
                            DWORD dwLastError = GetLastError();

				            if ( dwLastError == ERROR_ACCESS_DENIED )
                            {
                                hRet = WBEM_E_ACCESS_DENIED;
                            }
                            else
                            {
                                hRet = dwLastError | 0x80000000;
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
	    hRet = WBEM_E_ILLEGAL_NULL ;
    }

    return hRet;
}

#ifdef NTONLY

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::IsVolumeDirty
*
*  DESCRIPTION :    This routine opens the given nt drive and sends down
*					FSCTL_IS_VOLUME_DIRTY to determine the state of that volume's
*					dirty bit. 
*
*****************************************************************************/
BOOLEAN LogicalDisk::IsVolumeDirty(
    IN  CHString    &NtDriveName,
    OUT BOOLEAN     *Result
)
{
    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   obj;
    NTSTATUS            t_status;
    IO_STATUS_BLOCK     iosb;
    HANDLE              h = NULL;
    ULONG               r = 0;
	BOOLEAN				bRetVal = FALSE;

    u.Length = (USHORT) NtDriveName.GetLength() * sizeof(WCHAR);
    u.MaximumLength = u.Length;
    u.Buffer = NtDriveName.GetBuffer( 0 );

    InitializeObjectAttributes(&obj, &u, OBJ_CASE_INSENSITIVE, 0, 0);

    t_status = NtOpenFile(&h,
                        SYNCHRONIZE | FILE_READ_DATA,
                        &obj,
                        &iosb,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if ( NT_SUCCESS(t_status)) 
	{
		try
		{
			t_status = NtFsControlFile(h, NULL, NULL, NULL,
									 &iosb,
									 FSCTL_IS_VOLUME_DIRTY,
									 NULL, 0,
									 &r, sizeof(r));

			if ( NT_SUCCESS(t_status)) 
			{

#if(_WIN32_WINNT >= 0x0500)
				*Result = (BOOLEAN)(r & VOLUME_IS_DIRTY);
#else
				*Result = (BOOLEAN)r;
#endif
				bRetVal = TRUE;
			}
		}
		catch(...)
		{
			NtClose(h);
			h = NULL;
			throw;
		}

		NtClose(h);
		h = NULL;
	}
	
	return bRetVal;
}


/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::ExecChkDsk
*
*  DESCRIPTION :    This methods checks the disk, and if disk is locked 
*					Schedules it for autocheck on reboot, if requested by 
*					the user, by default it will not be scheduled for autocheck
*					unless specified by the user.
*
*****************************************************************************/
HRESULT LogicalDisk :: ExecChkDsk (

	const CInstance& a_Instance, 
	CInstance *a_InParams, 
	CInstance *a_OutParams,
	long lFlags 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	DWORD dwThreadId = GetCurrentThreadId();

	hRes = a_InParams && a_OutParams ? hRes : WBEM_E_INVALID_PARAMETER;
	UINT unRetVal = 0;

	mReturnVal [ dwThreadId ] = unRetVal;

	if ( SUCCEEDED ( hRes ) )
	{
		// Get the drivename from the instance which is the key of the Logical DIsk
		CHString t_DriveName;

		hRes = a_Instance.GetCHString ( IDS_DeviceID, t_DriveName ) ? hRes : WBEM_E_PROVIDER_FAILURE;

		if ( SUCCEEDED ( hRes ) )
		{
			// checking for the validity of the drive on whick checkdsk can be performed
			DWORD dwDriveType = GetDriveType ( t_DriveName );

			if ( unRetVal == 0 )
			{
				hRes = CheckParameters ( a_InParams );

				if ( SUCCEEDED ( hRes ) )
				{
					// now check for the file system type, since chkdsk is applicable only for 
					// NTFS/FAT volumes by loading the fmifs.dll which exposes a chkdsk method
					HINSTANCE hDLL = NULL;  
					QUERYFILESYSTEMNAME QueryFileSystemName = NULL;
					FMIFS_CALLBACK CallBackRoutine = NULL;

					hDLL = LoadLibrary( L"fmifs.dll" );

					if (hDLL != NULL)
					{
						try
						{
						   QueryFileSystemName =  (QUERYFILESYSTEMNAME)GetProcAddress(hDLL, "QueryFileSystemName");

						   if ( QueryFileSystemName )
						   {
								CHString t_FileSystemName; 
								unsigned char MajorVersion;
								unsigned char MinorVersion;
								LONG ExitStatus;
			
								if ( QueryFileSystemName ( 
											t_DriveName.GetBuffer ( 0 ), 
											t_FileSystemName.GetBuffer ( _MAX_PATH + 1 ), 
											&MajorVersion, 
											&MinorVersion, 
											&ExitStatus ) )
								{
									// we need to check for the Filesystem
									if ( ( t_FileSystemName.CompareNoCase ( L"FAT" ) == 0 ) || ( t_FileSystemName.CompareNoCase ( L"NTFS" )  == 0) )
									{
										bool bFixErrors = false;
										bool bVigorousIndexCheck = false;
										bool bSkipFolderCycle = false;
										bool bForceDismount = false;
										bool bRecoverBadSectors = false;
										bool bCheckAtBootUp = false;

										// Get all the parameters from the instance here;
										a_InParams->Getbool ( METHOD_ARG_NAME_FIXERRORS, bFixErrors );
										a_InParams->Getbool ( METHOD_ARG_NAME_VIGOROUSINDEXCHECK, bVigorousIndexCheck );
										a_InParams->Getbool ( METHOD_ARG_NAME_SKIPFOLDERCYCLE, bSkipFolderCycle );
										a_InParams->Getbool ( METHOD_ARG_NAME_FORCEDISMOUNT, bForceDismount );
										a_InParams->Getbool ( METHOD_ARG_NAME_RECOVERBADSECTORS, bRecoverBadSectors );
										a_InParams->Getbool ( METHOD_ARG_NAME_CHKDSKATBOOTUP, bCheckAtBootUp );

										// Set the parameters for making a call to chkdsk here
										PFMIFS_CHKDSKEX_ROUTINE ChkDskExRoutine = NULL;

										ChkDskExRoutine = ( PFMIFS_CHKDSKEX_ROUTINE ) GetProcAddress( hDLL,  "ChkdskEx" );

										if ( ChkDskExRoutine != NULL )
										{
											if ( bCheckAtBootUp )
											{
												CallBackRoutine = ScheduleAutoChkIfLocked;
											}
											else
											{
												CallBackRoutine = DontScheduleAutoChkIfLocked;
											}
											FMIFS_CHKDSKEX_PARAM Param;

											Param.Major = 1;
											Param.Minor = 0;
											Param.Flags = 0;  // For the Verbose Flag
											Param.Flags |= bRecoverBadSectors ? FMIFS_CHKDSK_RECOVER : 0;
											Param.Flags |= bForceDismount ? FMIFS_CHKDSK_FORCE : 0;
											Param.Flags |= bVigorousIndexCheck ? FMIFS_CHKDSK_SKIP_INDEX_SCAN : 0;
											Param.Flags |= bSkipFolderCycle ? FMIFS_CHKDSK_SKIP_CYCLE_SCAN : 0;

                                            if (bRecoverBadSectors || bForceDismount)
                                            {
                                                bFixErrors = true;
                                            }
						
											ChkDskExRoutine ( 
												t_DriveName.GetBuffer ( 0 ),
												t_FileSystemName.GetBuffer ( 0 ),
												bFixErrors,
												&Param,
												CallBackRoutine
											);
										}
										else
										{
											hRes = WBEM_E_FAILED;
										}
									}
									else
									{
										mReturnVal [ dwThreadId ] = CHKDSK_UNKNOWN_FS;
									}
								}
								else
								{
									mReturnVal [ dwThreadId ] = CHKDSK_UNKNOWN_FS;
								}
						   }
					   	}
						catch ( ... )
						{
							FreeLibrary(hDLL);  
							throw;
						}
						FreeLibrary(hDLL);  
					 }
					 else
					 {
						hRes = WBEM_E_FAILED;
					 }
				}
			}		
		}
	}
	// need to set the return value;
	if ( SUCCEEDED ( hRes ) )
	{
		a_OutParams->SetWORD ( METHOD_ARG_NAME_RETURNVALUE, mReturnVal [ dwThreadId ] ) ;
		//Initialize/Delete the valuemap entry for this thread 
		mReturnVal [ dwThreadId ] = 0;
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::ExecExcludeFromChkDsk
*
*  DESCRIPTION :    This method makes a chknts exe call to exclude the 
*					for autocheck on reboot
*
*****************************************************************************/
HRESULT LogicalDisk::ExecExcludeFromChkDsk(

	CInstance *a_InParams, 
	CInstance *a_OutParams,
	long lFlags 			
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_ChkNtFsCommand;
	DWORD dwRetVal = 0;

	// C for Schedule for autocheck on reboot
	hRes = GetChkNtfsCommand ( a_InParams, a_OutParams, L'X', t_ChkNtFsCommand, dwRetVal );

	// Making a call to execute an Chkntfs exe
	if ( SUCCEEDED ( hRes ) && ( dwRetVal == CHKDSKERR_NOERROR ) ) 
	{
		hRes = ExecuteCommand ( t_ChkNtFsCommand );
		if ( ( (HRESULT_FACILITY(hRes) == FACILITY_WIN32) ? HRESULT_CODE(hRes) : (hRes) ) == ERROR_ACCESS_DENIED )
		{
			hRes = WBEM_E_ACCESS_DENIED ;
		}
	}

	a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwRetVal );
	
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::ExecScheduleChkdsk
*
*  DESCRIPTION :    This method makes a chknts exe call to Schedule drives 
*					for autocheck on reboot
*
*****************************************************************************/
HRESULT LogicalDisk::ExecScheduleChkdsk(
		
	CInstance *a_InParams, 
	CInstance *a_OutParams, 
	long lFlags 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_ChkNtFsCommand;
	DWORD dwRetVal = NOERROR;

	// C for Exclude for autocheck on reboot
	hRes = GetChkNtfsCommand ( a_InParams, a_OutParams, L'C', t_ChkNtFsCommand, dwRetVal );

	// Making a call to execute an Chkntfs exe
	if ( SUCCEEDED ( hRes ) && ( dwRetVal == CHKDSKERR_NOERROR ) )
	{
		hRes = ExecuteCommand ( t_ChkNtFsCommand );
		if ( ( (HRESULT_FACILITY(hRes) == FACILITY_WIN32) ? HRESULT_CODE(hRes) : (hRes) ) == ERROR_ACCESS_DENIED )
		{
			hRes = WBEM_E_ACCESS_DENIED ;
		}
    }

    a_OutParams->SetWORD ( METHOD_ARG_NAME_RETURNVALUE , dwRetVal );

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::GetChkNtfsCommand
*
*  DESCRIPTION :    This method gets an array of input drives checks if chkntfs
*					can be applied to them and puts it in the form of the ChkNtfs 
*					System command, based on the chk mode, either schedule or 
*					Exclude.
*
*****************************************************************************/

HRESULT LogicalDisk :: GetChkNtfsCommand ( 

	CInstance *a_InParams, 
	CInstance *a_OutParams, 
	WCHAR w_Mode, 
	CHString &a_ChkNtfsCommand,
	DWORD & dwRetVal
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	SAFEARRAY *t_paDrives;
	dwRetVal = CHKDSKERR_DRIVE_REMOVABLE;

	a_ChkNtfsCommand.Format ( L"%s%s%c", CHKNTFS, L" /", w_Mode );

	if ( a_InParams->GetStringArray ( METHOD_ARG_NAME_LOGICALDISKARRAY, t_paDrives ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		try
		{
			UINT unDim = SafeArrayGetDim( t_paDrives );

			if ( unDim != 1 )
			{
				hRes = WBEM_E_INVALID_PARAMETER;
			}

			if ( SUCCEEDED ( hRes ) )
			{
				LONG lLbound;
				LONG lUbound;

				hRes = SafeArrayGetLBound( t_paDrives, unDim, &lLbound );

				if ( SUCCEEDED ( hRes ) )
				{
					hRes = SafeArrayGetUBound( t_paDrives, unDim, &lUbound );

					if ( SUCCEEDED ( hRes ) )
					{
						BSTR bstrElement;

						for ( LONG lLbound = 0; lLbound <= lUbound; lLbound++ )
						{
							// getting the drives and putting them in command form
							hRes = SafeArrayGetElement ( t_paDrives, &lLbound , &bstrElement );

							if ( SUCCEEDED ( hRes ) )
							{
								DWORD dwElementLen = SysStringLen ( bstrElement );
								if ( dwElementLen == 2 )
								{
									DWORD dwDriveType;
									CHString t_Drive ( bstrElement );
									dwDriveType = GetDriveType ( TOBSTRT ( t_Drive ) );

                                    switch (dwDriveType)
                                    {
                                        case DRIVE_REMOTE:
                                        {
                                            dwRetVal =  CHKDSKERR_REMOTE_DRIVE;
                                            break;
                                        }

                                        case DRIVE_REMOVABLE:
                                        {
    										dwRetVal = CHKDSKERR_DRIVE_REMOVABLE;
                                            break;
                                        }

                                        case DRIVE_UNKNOWN:
									    {
										    dwRetVal = CHKDSKERR_DRIVE_UNKNOWN;
                                            break;
									    }

                                        case DRIVE_NO_ROOT_DIR:
									    {
										    dwRetVal = CHKDSKERR_DRIVE_NO_ROOT_DIR ;
                                            break;
									    }

                                        case DRIVE_FIXED:
                                        {
                                            dwRetVal = CHKDSKERR_NOERROR;
                                            break;
                                        }

                                        default:
                                        {
                                            dwRetVal = CHKDSKERR_DRIVE_UNKNOWN;
                                            break;
                                        }
                                    }

                                    a_ChkNtfsCommand += L' ';
                                    a_ChkNtfsCommand += t_Drive;
								}
								else
								{
									hRes = WBEM_E_INVALID_PARAMETER;
									break;
								}	
							}
							else
							{
								hRes = WBEM_E_INVALID_PARAMETER;
								break;
							}
						}
					}
					else
					{
						hRes = WBEM_E_INVALID_PARAMETER;
					}
				}
				else
				{
					hRes = WBEM_E_INVALID_PARAMETER;
				}
			}
		}
		catch ( ... )
		{
			hRes = SafeArrayDestroy ( t_paDrives );
			throw;
		}
		if ( FAILED ( SafeArrayDestroy ( t_paDrives ) ) )
		{
			hRes = WBEM_E_FAILED;
		}	
	}
	return ( hRes );
}

/*****************************************************************************
*
*  FUNCTION    :    LogicalDisk::CheckParameters
*
*  DESCRIPTION :    This routine checks for the validity of the parameters
*					which are passed as parameters to ChkDsk Method
*
*****************************************************************************/
HRESULT LogicalDisk::CheckParameters ( 

	CInstance *a_InParams
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	if ( a_InParams == NULL )
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		VARTYPE t_Type ;
		bool t_Exists;
		
		if ( a_InParams->GetStatus ( METHOD_ARG_NAME_FIXERRORS , t_Exists , t_Type ) )
		{
			hRes = t_Exists && ( t_Type == VT_BOOL ) ? hRes : WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			hRes  = WBEM_E_INVALID_PARAMETER ;
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( a_InParams->GetStatus ( METHOD_ARG_NAME_VIGOROUSINDEXCHECK , t_Exists , t_Type ) )
			{
				hRes = t_Exists && ( t_Type == VT_BOOL ) ? hRes : WBEM_E_INVALID_PARAMETER;
			}
			else
			{
				hRes  = WBEM_E_INVALID_PARAMETER ;
			}
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( a_InParams->GetStatus ( METHOD_ARG_NAME_SKIPFOLDERCYCLE , t_Exists , t_Type ) )
			{
				hRes = t_Exists && ( t_Type == VT_BOOL ) ? hRes : WBEM_E_INVALID_PARAMETER;
			}
			else
			{
				hRes  = WBEM_E_INVALID_PARAMETER ;
			}
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( a_InParams->GetStatus ( METHOD_ARG_NAME_FORCEDISMOUNT , t_Exists , t_Type ) )
			{
				hRes = 	t_Exists && ( t_Type == VT_BOOL ) ? hRes : hRes  = WBEM_E_INVALID_PARAMETER ;
			}
			else
			{
				hRes  = WBEM_E_INVALID_PARAMETER ;
			}
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( a_InParams->GetStatus ( METHOD_ARG_NAME_RECOVERBADSECTORS , t_Exists , t_Type ) )
			{
				hRes = t_Exists && ( t_Type == VT_BOOL ) ? hRes : WBEM_E_INVALID_PARAMETER;
			}
			else
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( a_InParams->GetStatus ( METHOD_ARG_NAME_CHKDSKATBOOTUP , t_Exists , t_Type ) )
			{
				hRes = t_Exists && ( t_Type == VT_BOOL ) ? hRes : WBEM_E_INVALID_PARAMETER;
			}
			else
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
	}

	return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    DontScheduleAutoChkIfLocked
*
*  DESCRIPTION :    A callback routine, which is passed as a parameter to chkdsk method
*					a method exposed via FMIFS.h chkdsk interface.
*
*****************************************************************************/
BOOLEAN	DontScheduleAutoChkIfLocked( 
	
	FMIFS_PACKET_TYPE PacketType, 
	ULONG	PacketLength,
	PVOID	PacketData
)
{
	DWORD dwThreadId = GetCurrentThreadId();

	if ( PacketType == FmIfsCheckOnReboot  )
	{
		FMIFS_CHECKONREBOOT_INFORMATION *RebootResult;
		mReturnVal [ dwThreadId ] = CHKDSK_VOLUME_LOCKED;
		RebootResult = (  FMIFS_CHECKONREBOOT_INFORMATION * ) PacketData;
		RebootResult->QueryResult = 0;
	}
	else
	{
		ProcessInformation ( PacketType, PacketLength, PacketData );
	}

	return TRUE;
}

/*****************************************************************************
*
*  FUNCTION    :    ScheduleAutoChkIfLocked
*
*  DESCRIPTION :    A callback routine, which is passed as a parameter to chkdsk method
*					a method exposed via FMIFS.h chkdsk interface.
*
*****************************************************************************/
BOOLEAN	ScheduleAutoChkIfLocked( 
	
	FMIFS_PACKET_TYPE PacketType, 
	ULONG	PacketLength,
	PVOID	PacketData
)
{
	DWORD dwThreadId = GetCurrentThreadId();

	if ( PacketType == FmIfsCheckOnReboot  )
	{
		FMIFS_CHECKONREBOOT_INFORMATION *RebootResult;
		mReturnVal [ dwThreadId ] = CHKDSK_VOLUME_LOCKED;
		RebootResult = (  FMIFS_CHECKONREBOOT_INFORMATION * ) PacketData;
		RebootResult->QueryResult = 1;
	}
	else
	{
		ProcessInformation ( PacketType, PacketLength, PacketData );
	}

	return TRUE;
}

/*****************************************************************************
*
*  FUNCTION    :    ProcessInofrmation
*
*  DESCRIPTION :    Checks the the dsk and keeps track of the appropriate error 
*					messages.
*
*****************************************************************************/
BOOLEAN ProcessInformation ( 

	FMIFS_PACKET_TYPE PacketType, 
	ULONG	PacketLength,
	PVOID	PacketData
)
{
	int static unRetVal;

	DWORD dwThreadId = GetCurrentThreadId();


	switch ( PacketType )
	{	
	case FmIfsTextMessage :
			FMIFS_TEXT_MESSAGE *MessageText;

			MessageText =  ( FMIFS_TEXT_MESSAGE *) PacketData;

			// There is no way to access this message ids via a interface exposed hence cannot detect these errors.
			/*	if ( lstrcmp ( MessageText, MSGCHK_ERRORS_NOT_FIXED ) == 0 )
			{
				unRetVal = 2;
			}

			if ( lstrcmp ( MessageText, MSG_CHK_ERRORS_FIXED ) == 0 )
			{	
				unRetVal = 3;
			}
			*/
			break;

	case FmIfsFinished: 
			FMIFS_FINISHED_INFORMATION *Finish;
			Finish = ( FMIFS_FINISHED_INFORMATION *) PacketData;
			if ( Finish->Success )
			{
				mReturnVal [ dwThreadId ] = CHKDSKERR_NOERROR;
			}
			else
			{
                if (mReturnVal [ dwThreadId ] != CHKDSK_VOLUME_LOCKED)
                {
				    mReturnVal [ dwThreadId ] = CHKDSK_FAILED;
                }
			}
			break;

	// although follwoing are the additional message types, callback routine never gets these messages
	// hence the detailed code for each of these return type is not written.
/*
	case FmIfsIncompatibleFileSystem:
			break;

	case FmIfsAccessDenied:
			break;

	case FmIfsBadLabel:
			break;

	case FmIfsHiddenStatus:
			break;

	case FmIfsClusterSizeTooSmall:
			break;

	case FmIfsClusterSizeTooBig:
			break;

	case FmIfsVolumeTooSmall:
			break;

	case FmIfsVolumeTooBig:
			break;

	case FmIfsNoMediaInDevice:
			break;

	case FmIfsClustersCountBeyond32bits:
			break;

	case FmIfsIoError:
			FMIFS_IO_ERROR_INFORMATION *IoErrorInfo;
			IoErrorInfo = ( FMIFS_IO_ERROR_INFORMATION * ) PacketData;
			break;

	case FmIfsMediaWriteProtected:
			break;

	case FmIfsIncompatibleMedia:
			break;

	case FmIfsInsertDisk:
			FMIFS_INSERT_DISK_INFORMATION *InsertDiskInfo;
			InsertDiskInfo = ( FMIFS_INSERT_DISK_INFORMATION *) PacketData;
			unRetVal = 1;
			break;
*/

	}

	return TRUE;
}

HRESULT LogicalDisk::ExecuteCommand ( LPCWSTR wszCommand )
{
	HRESULT hRes = WBEM_E_FAILED;

	DWORD t_Status = ERROR_SUCCESS ;

	SmartCloseHandle t_TokenPrimaryHandle ;
	SmartCloseHandle t_TokenImpersonationHandle;

	BOOL t_TokenStatus = OpenThreadToken (

		GetCurrentThread () ,
		TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY  ,
		TRUE ,
		& t_TokenImpersonationHandle
	) ;

	if ( t_TokenStatus )
	{
		CAdvApi32Api *t_pAdvApi32 = NULL;
        if ( ( t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ) != NULL )
		{
		    t_pAdvApi32->DuplicateTokenEx (	t_TokenImpersonationHandle ,
			                                TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY ,
			                                NULL,
			                                SecurityImpersonation,
			                                TokenPrimary ,
			                                &t_TokenPrimaryHandle,
											&t_TokenStatus
										  );

		    CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
            t_pAdvApi32 = NULL;
        }
	}

	if ( t_TokenStatus )
	{
		CUserHive t_Hive ;
		CHString chsSID ;
		CHString t_Account ;

		DWORD dwCheckKeyPresentStatus = ERROR_SUCCESS ;
		TCHAR t_KeyName [ 1024 ]  = { L'\0' } ;

		TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;
		TOKEN_USER *t_TokenUser = NULL ;

		DWORD t_ReturnLength = 0L;

		t_TokenStatus = GetTokenInformation (

			t_TokenImpersonationHandle ,
			t_TokenInformationClass ,
			NULL ,
			0 ,
			& t_ReturnLength
		) ;

		if ( ! t_TokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
		{
			if ( ( t_TokenUser = ( TOKEN_USER * ) new UCHAR [ t_ReturnLength ] ) != NULL )
			{
				try
				{
					t_TokenStatus = GetTokenInformation (

						t_TokenImpersonationHandle ,
						t_TokenInformationClass ,
						( void * ) t_TokenUser ,
						t_ReturnLength ,
						& t_ReturnLength
					) ;

					if ( t_TokenStatus )
					{
						CSid t_Sid ( t_TokenUser->User.Sid ) ;
						if ( t_Sid.IsOK () )
						{
							chsSID = t_Sid.GetSidString () ;
							t_Account = t_Sid.GetAccountName () ;
						}
						else
						{
							t_Status = GetLastError () ;
						}
					}
					else
					{
						t_Status = GetLastError () ;
					}
				}
				catch ( ... )
				{
					if ( t_TokenUser )
					{
						delete [] ( UCHAR * ) t_TokenUser ;
						t_TokenUser = NULL ;
					}

					throw ;
				}

				if ( t_TokenUser )
				{
					delete [] ( UCHAR * ) t_TokenUser ;
					t_TokenUser = NULL ;
				}
			}
			else
			{
				t_Status = ERROR_NOT_ENOUGH_MEMORY;
			}
		}
		else
		{
			t_Status = ::GetLastError ();
		}

		if ( t_Status == ERROR_SUCCESS )
		{
			CRegistry Reg ;
			//check if SID already present under HKEY_USER ...
			dwCheckKeyPresentStatus = Reg.Open(HKEY_USERS, chsSID, KEY_READ) ;
			Reg.Close() ;

			if(dwCheckKeyPresentStatus != ERROR_SUCCESS)
			{
				t_Status = t_Hive.Load ( t_Account , t_KeyName ) ;
			}

			if ( t_Status == ERROR_FILE_NOT_FOUND )
			{
				t_Status = ERROR_SUCCESS ;
				dwCheckKeyPresentStatus = ERROR_SUCCESS ;
			}
		}

		if ( t_Status == ERROR_SUCCESS )
		{
			try
			{
				DWORD t_CreationFlags = 0 ;
				STARTUPINFO t_StartupInformation ;

				ZeroMemory ( &t_StartupInformation , sizeof ( t_StartupInformation ) ) ;
				t_StartupInformation.cb = sizeof ( STARTUPINFO ) ;
				t_StartupInformation.dwFlags = STARTF_USESHOWWINDOW;
				t_StartupInformation.wShowWindow  = SW_HIDE;

				t_CreationFlags = NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT ;

				PROCESS_INFORMATION t_ProcessInformation;

				CUserEnvApi *pUserEnv = NULL ;
				LPVOID t_Environment = NULL ;

				if ( ( pUserEnv = ( CUserEnvApi * ) CResourceManager::sm_TheResourceManager.GetResource ( g_guidUserEnvApi, NULL ) ) != NULL )
				{
					try
					{
						pUserEnv->CreateEnvironmentBlock (

							& t_Environment ,
							t_TokenPrimaryHandle ,
							FALSE
						);

						t_Status = CreateProcessAsUser (

							t_TokenPrimaryHandle ,
							NULL ,
							( LPTSTR ) wszCommand,
							NULL ,
							NULL ,
							FALSE ,
							t_CreationFlags ,
							( TCHAR * ) t_Environment ,
							NULL ,
							& t_StartupInformation ,
							& t_ProcessInformation
						) ;

						if ( t_Environment )
						{
							pUserEnv->DestroyEnvironmentBlock ( t_Environment ) ;
							t_Environment = NULL;
						}
					}
					catch ( ... )
					{
						CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidUserEnvApi, pUserEnv ) ;
						pUserEnv = NULL ;

						throw;
					}

					CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidUserEnvApi, pUserEnv ) ;
					pUserEnv = NULL ;

					if ( t_Status )
					{
						t_Status = ERROR_SUCCESS;

						if ( ::WaitForSingleObject ( t_ProcessInformation.hProcess, INFINITE ) == WAIT_OBJECT_0 )
						{
							DWORD t_ExitCode = 0L;
							if ( GetExitCodeProcess ( t_ProcessInformation.hProcess, &t_ExitCode ) )
							{
								if ( t_ExitCode == 2 )
								{
									//	from chkntfs file
									//
									//	EXIT:
									//	0   -- OK, dirty bit not set on drive or bit not checked
									//	1   -- OK, and dirty bit set on at least one drive
									//	2   -- Error

									hRes = WBEM_E_FAILED;
								}
								else
								{
									hRes = WBEM_S_NO_ERROR;
								}
							}

							::CloseHandle ( t_ProcessInformation.hProcess ) ;
						}
					}
					else
					{
						t_Status = ::GetLastError ();
					}
				}
			}
			catch ( ... )
			{
				if(dwCheckKeyPresentStatus != ERROR_SUCCESS)
				{
					t_Hive.Unload ( t_KeyName ) ;
				}

				throw;
			}

			if(dwCheckKeyPresentStatus != ERROR_SUCCESS)
			{
				t_Hive.Unload ( t_KeyName ) ;
			}
		}
	}

	if ( t_Status == ERROR_ACCESS_DENIED )
	{
		hRes = HRESULT_FROM_WIN32 ( t_Status );
	}

	return hRes;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicaldisk.h ===
//=================================================================

//

// LogicalDisk.h -- Logical disk property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//
//=================================================================

typedef BOOL (WINAPI *KERNEL32_DISK_FREESPACEEX) (LPCTSTR lpDirectoryName,
                                                  PULARGE_INTEGER lpFreeBytesAvailableToCaller,
                                                  PULARGE_INTEGER lpTotalNumberOfBytes,
                                                  PULARGE_INTEGER lpTotalNumberOfFreeBytes) ;

// Property set identification
//============================

#define  PROPSET_NAME_LOGDISK  L"Win32_LogicalDisk"

class LogicalDisk : public Provider
{
public:

    // Constructor/destructor
    //=======================

    LogicalDisk(LPCWSTR name, LPCWSTR pszNamespace);
   ~LogicalDisk() ;

    // Functions provide properties with current values
    //=================================================

	virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &pQuery);
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	virtual HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);
	virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );

#ifdef NTONLY
	HRESULT ExecMethod ( const CInstance& Instance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags ) ;
#endif


    // Utility
    //========

    void    GetLogicalDiskInfo				(CInstance* pInstance, DWORD dwProperties ) ;
    void    GetFixedDriveInfo				(CInstance* pInstance, LPCTSTR pszName, DWORD dwProperties ) ;
    void    GetRemoveableDriveInfo			(CInstance* pInstance, LPCTSTR pszName, DWORD dwProperties ) ;
    void    GetRemoveableDriveInfoNT		(CInstance* pInstance, LPCTSTR pszName, BOOL &a_MediaPresent, DWORD dwProperties ) ;
    void    GetRemoveableDriveInfo95		(CInstance* pInstance, LPCTSTR pszName, BOOL &a_MediaPresent ) ;
    void    GetCDROMDriveInfoNT				(CInstance* pInstance, LPCTSTR pszName, BOOL &a_MediaPresent, DWORD dwProperties ) ;
    void    GetCDROMDriveInfo95				(CInstance* pInstance, LPCTSTR pszName, BOOL &a_MediaPresent ) ;

    void    GetRemoteDriveInfo				(CInstance* pInstance, LPCTSTR pszName, DWORD dwProperties ) ;
    void    GetCDROMDriveInfo				(CInstance* pInstance, LPCTSTR pszName, DWORD dwProperties ) ;
    void    GetRAMDriveInfo					(CInstance* pInstance, LPCTSTR pszName, DWORD dwProperties ) ;

	// Drive space and volume information helpers

	DWORD   GetDriveVolumeInformation		(CInstance* pInstance, LPCTSTR pszName );
	BOOL	GetDriveFreeSpace				(CInstance* pInstance, LPCTSTR pszName );

private:

#ifdef NTONLY
	BOOLEAN IsVolumeDirty( IN  CHString    &NtDriveName, OUT BOOLEAN     *Result );

	HRESULT ExecChkDsk ( const CInstance& a_Instance, CInstance *a_InParams, CInstance *a_OutParams, long lFlags );
	HRESULT ExecChkDskMode ( const CInstance& a_Instance, CInstance *a_InParams,  CInstance *a_OutParams, LPWSTR DriveName, long lFlags );
	HRESULT ExecExcludeFromChkDsk( CInstance *a_InParams, CInstance *a_OutParams, long lFlags );
	HRESULT ExecScheduleChkdsk( CInstance *a_InParams,  CInstance *a_OutParams, long lFlags );
	HRESULT CheckChkDsk ( CInstance *a_InParams , CInstance *a_OutParams , LPWSTR DriveName, DWORD &a_Status );
	HRESULT GetChkNtfsCommand ( CInstance *a_InParams, CInstance *a_OutParams, WCHAR w_Mode,  CHString &a_ChkNtfsCommand, DWORD &dwRetVal);
	HRESULT CheckParameters ( CInstance *a_InParams );

	HRESULT ExecuteCommand ( LPCWSTR wszCommand );
#endif

    CHPtrArray m_ptrProperties;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileaccess.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#define  LOGICAL_FILE_ACCESS_NAME "Win32_LogicalFileAccess" 

// provider provided for test provisions
class CWin32LogicalFileAccess: public Provider
{
	private:
    public:	
		CWin32LogicalFileAccess(const CHString& setName, const WCHAR* pszNamespace );
		~CWin32LogicalFileAccess();

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileaccess.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "securefile.h"
#include "logicalfileaccess.h"


typedef std::vector<_bstr_t> BSTRTVEC;


CWin32LogicalFileAccess LogicalFileAccess( LOGICAL_FILE_ACCESS_NAME, IDS_CimWin32Namespace );

/*
    [Dynamic, Association: ToInstance]
class Win32_LogicalFileAccess : Win32_SecuritySettingAccess
{
    Win32_LogicalFileSecuritySetting ref SecuritySetting;

    Win32_SID ref Trustee;
};
*/

CWin32LogicalFileAccess::CWin32LogicalFileAccess( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalFileAccess::~CWin32LogicalFileAccess()
{
}

HRESULT CWin32LogicalFileAccess::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY

	if(pInstance != NULL)
	{
		CInstancePtr pLogicalFileInstance;

		// get instance by path on Win32_LogicalFileSecuritySetting part
		CHString chsLogicalFileSecurityPath;
		pInstance->GetCHString(_T("SecuritySetting"), chsLogicalFileSecurityPath);
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsLogicalFileSecurityPath, &pLogicalFileInstance, pMethodContext)) &&
           pLogicalFileInstance != NULL)
		{
			CHString chsFilePath;

			pLogicalFileInstance->GetCHString(IDS_Path, chsFilePath);

			CSecureFile secFile(chsFilePath, FALSE);  // Don't need SACL
			CDACL dacl;
			secFile.GetDACL(dacl);

			// walk DACL looking for the sid path passed in....
            // First need merged acl to work with...
            CAccessEntryList t_cael;
            if(dacl.GetMergedACL(t_cael))
            {
			    ACLPOSITION aclPos;
			    if(t_cael.BeginEnum(aclPos))
                {
			        CAccessEntry ACE;
			        CSid sidTrustee;
                    bool fFoundIt = false;
			        while(t_cael.GetNext(aclPos, ACE ) && !fFoundIt)
			        {
				        ACE.GetSID(sidTrustee);
				        CHString chsTrustee = sidTrustee.GetSidString();

				        CInstancePtr pSIDInstance;
				        CHString chstrSIDPath;
				        pInstance->GetCHString(_T("Trustee"), chstrSIDPath);
		                //CHString chstrFullSIDPath;
                        //chstrFullSIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                        //             GetLocalComputerName(),
                        //             IDS_CimWin32Namespace,
                        //             (LPCTSTR)chstrSIDPath);
			  	        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrSIDPath, &pSIDInstance, pInstance->GetMethodContext())))
				        {
					        if(pSIDInstance != NULL)
					        {
						        CHString chsInstanceSID;
						        pSIDInstance->GetCHString(_T("SID"), chsInstanceSID);
						        if(chsTrustee.CompareNoCase(chsInstanceSID) == 0)
						        {
							        hr = WBEM_S_NO_ERROR;
                                    fFoundIt = true;
						        }
					        }
				        }
			        }
			        t_cael.EndEnum(aclPos);
                }
            }
		}
	}

#endif

	return(hr);
}


HRESULT CWin32LogicalFileAccess::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

    // We optimize for one scenario only:  the query specified one or more SecuritySettings, requesting associations with the Trustees of
    // each; if the query specified one or more Trustees, we would have to enumerate all instances of cim_logicalfile and
    // determine the Trustees of each, so we don't support that "optimization".
    BSTRTVEC vectorSecuritySettings;
    BSTRTVEC vectorTrustees;
    pQuery.GetValuesForProp(IDS_SecuritySetting, vectorSecuritySettings);
    pQuery.GetValuesForProp(IDS_Trustee, vectorTrustees);
    DWORD dwSettings = vectorSecuritySettings.size();
    DWORD dwTrustees = vectorTrustees.size();
    if(dwSettings >= 1 && dwTrustees == 0)
    {
        CInstancePtr pSecSetting;
        for(LONG m = 0; m < dwSettings && SUCCEEDED(hr); m++)
        {
            CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
            pSecSetting = NULL;
            chstrLFSSPath.Format(_T("\\\\%s\\%s:%s"),
                                 (LPCTSTR)GetLocalComputerName(),
                                 IDS_CimWin32Namespace,
                                 (LPCTSTR)CHString((WCHAR*)vectorSecuritySettings[m]));

            if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting, pMethodContext)))
            {
                if(pSecSetting != NULL)
                {
                    CHString chstrSSPath; // SecuritySetting path
                    pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                    if(!chstrSSPath.IsEmpty())
                    {
                        CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
                        // Get the DACL and for each entry create an instance of this association...
			            CDACL dacl;
                        CSid sidTrustee;
                        ACLPOSITION aclPos;
                        CAccessEntry ACE;
			            secFile.GetDACL(dacl);
                        // First need merged list
                        CAccessEntryList t_cael;
                        if(dacl.GetMergedACL(t_cael))
                        {
                            if(t_cael.BeginEnum(aclPos))
                            {
                                while(t_cael.GetNext(aclPos, ACE) && SUCCEEDED(hr))
			                    {
                                    ACE.GetSID(sidTrustee);
                                    if(sidTrustee.IsValid())
                                    {
                                        CInstancePtr pNewAssocInst;
                                        pNewAssocInst.Attach(CreateNewInstance(pMethodContext));
                                        if(pNewAssocInst != NULL)
                                        {
                                            // Set the SecuritySetting property of the association instance.
                                            pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                            // Set the Trustee property of the association instance.
                                            CHString chstrFullWin32SIDPath;
                                            chstrFullWin32SIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                                                                         (LPCTSTR)GetLocalComputerName(),
                                                                         IDS_CimWin32Namespace,
                                                                         (LPCTSTR)sidTrustee.GetSidString());
                                            pNewAssocInst->SetCHString(IDS_Trustee, chstrFullWin32SIDPath);
                                            hr = pNewAssocInst->Commit();
                                        }
                                    }
                                }
                                t_cael.EndEnum(aclPos);
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
        // hr = EnumerateInstances(pMethodContext, lFlags);
        // commented out since some other classes may support exec queries of this type, and returning provider not
        // capable from this class results in some instances (from other classes) being returned, followed by an abort
        // of the enumeration due to this class's returning provider not capable.
    }

#endif

    return hr;
}


HRESULT CWin32LogicalFileAccess::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
/*	HRESULT hr = WBEM_S_NO_ERROR;

    if(m_dwPlatformID != VER_PLATFORM_WIN32_NT)
    {
		return(hr);
	}

    TRefPointerCollection<CInstance> LCIMLogicalFiles;

    CHString chstrAllFilesQuery;
    chstrAllFilesQuery = _T("SELECT __PATH FROM CIM_LogicalFile");
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrAllFilesQuery,
                                                        &LCIMLogicalFiles,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))

    {
        REFPTRCOLLECTION_POSITION pos;
        if(LCIMLogicalFiles.BeginEnum(pos))
        {
            CInstance* pinstCIMLogicalFile = NULL;
            CInstance* pSecSetting = NULL;
            //CInstance* pW32SID = NULL;
            while((SUCCEEDED(hr)) && (pinstCIMLogicalFile = LCIMLogicalFiles.GetNext(pos)))
            {
                if(pinstCIMLogicalFile != NULL)
                {
                    // For each logicalfile instance, need to create an association instance.
                    // For each association instance, need to fill in two properties: Trustee and SecuritySetting.

                    // Get and set the SecuritySetting property:
                    // First get the name property of the CIM_LogicalFile instance:
                    CHString chstrCLFName;
                    pinstCIMLogicalFile->GetCHString(IDS_Name, chstrCLFName);
                    CHString chstrDblEscCLFName;
                    EscapeBackslashes(chstrCLFName, chstrDblEscCLFName);
                    CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
                    pSecSetting = NULL;
                    chstrLFSSPath.Format(_T("\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\""),
                                         (LPCTSTR)GetLocalComputerName(),
                                         IDS_CimWin32Namespace,
                                         (LPCTSTR)chstrDblEscCLFName);

                    if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting)))
                    {
                        if(pSecSetting != NULL)
                        {
                            CHString chstrSSPath; // SecuritySetting path
                            pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                            if(!chstrSSPath.IsEmpty())
                            {
                                CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
                                // Get the DACL and for each entry create an instance of this association...
			                    CDACL dacl;
                                CSid sidTrustee;
                                ACLPOSITION aclPos;
                                CAccessEntry ACE;
			                    secFile.GetDACL(dacl);
                                if(dacl.BeginEnum(aclPos))
                                {
                                    while(dacl.GetNext(aclPos, ACE))
			                        {
                                        ACE.GetSID(sidTrustee);
                                        if(sidTrustee.IsValid())
                                        {
                                            CInstance* pNewAssocInst = CreateNewInstance(pMethodContext);
                                            if(pNewAssocInst != NULL)
                                            {
                                                // Set the SecuritySetting property of the association instance.
                                                pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                                // Set the Trustee property of the association instance.
                                                CHString chstrFullWin32SIDPath;
                                                chstrFullWin32SIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                                                                             (LPCTSTR)GetLocalComputerName(),
                                                                             IDS_CimWin32Namespace,
                                                                             (LPCTSTR)sidTrustee.GetSidString());
                                                pNewAssocInst->SetCHString(IDS_Trustee, chstrFullWin32SIDPath);
                                                hr = Commit(pNewAssocInst);
                                            }
                                        }
                                    }
                                    dacl.EndEnum(aclPos);
                                }
                            }
                            pSecSetting->Release();
                            pSecSetting = NULL;
                        }
                    }
                    pinstCIMLogicalFile->Release();
                    pinstCIMLogicalFile = NULL;
                }
            }
            LCIMLogicalFiles.EndEnum();
        }
    }

	return hr;
*/
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileaudit.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#define  LOGICAL_FILE_AUDIT_NAME L"Win32_LogicalFileAuditing" 

// provider provided for test provisions
class CWin32LogicalFileAudit: public Provider
{
    private:
	public:	
		CWin32LogicalFileAudit(const CHString& setName, const WCHAR* pszNamespace );
		~CWin32LogicalFileAudit();

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfilegroup.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "securefile.h"
#include "logicalfilegroup.h"


typedef std::vector<_bstr_t> BSTRTVEC;



CWin32LogicalFileGroup LogicalFileGroup( LOGICAL_FILE_GROUP_NAME, IDS_CimWin32Namespace );

/*
    [Dynamic, Provider, Association: ToInstance]
class Win32_LogicalFileGroup : Win32_SecuritySettingGroup
{
    Win32_LogicalFileSecuritySetting ref SecuritySetting;

    Win32_SID ref Group;
};
*/

CWin32LogicalFileGroup::CWin32LogicalFileGroup( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalFileGroup::~CWin32LogicalFileGroup()
{
}

HRESULT CWin32LogicalFileGroup::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY

	if(pInstance != NULL)
	{
		CInstancePtr pLogicalFileInstance;

		// get instance by path on Win32_LogicalFileSecuritySetting part
		CHString chsLogicalFileSecurityPath;
		pInstance->GetCHString(_T("SecuritySetting"), chsLogicalFileSecurityPath);
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceKeysByPath(chsLogicalFileSecurityPath, &pLogicalFileInstance, pMethodContext)))
		{
			if(pLogicalFileInstance != NULL)
            {
                CHString chsFilePath;

			    pLogicalFileInstance->GetCHString(IDS_Path, chsFilePath);

			    CSecureFile secFile(chsFilePath, TRUE);
			    CSid sidGroup;
			    secFile.GetGroup(sidGroup);
			    CHString chsGroup = sidGroup.GetSidString();

			    CInstancePtr pSIDInstance;
			    CHString chstrSIDPath;
			    pInstance->GetCHString(_T("Group"), chstrSIDPath);
                //CHString chstrFullSIDPath;
                //chstrFullSIDPath.Format("\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                //             GetLocalComputerName(),
                //             IDS_CimWin32Namespace,
                //             (LPCTSTR)chstrSIDPath);

		  	    if (SUCCEEDED(CWbemProviderGlue::GetInstanceKeysByPath(chstrSIDPath, &pSIDInstance, pMethodContext)))
			    {
			        if(pSIDInstance != NULL)
                    {
            	        // compare SID
				        CHString chsSIDCompare;
				        pSIDInstance->GetCHString(_T("SID"), chsSIDCompare);

				        if (chsGroup.CompareNoCase(chsSIDCompare) == 0)
				        {
					        hr = WBEM_S_NO_ERROR;
				        }
                    }
			    }
            }
		}
	}

#endif

	return(hr);
}


HRESULT CWin32LogicalFileGroup::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

    // We optimize for one scenario only:  the query specified one or more SecuritySettings, requesting associations with the group of
    // each; if the query specified one or more Groups, for each we would have to enumerate all instances of cim_logicalfile and
    // determine the Group of each, so we don't support that "optimization".
    BSTRTVEC vectorSecuritySettings;
    BSTRTVEC vectorGroups;
    pQuery.GetValuesForProp(IDS_SecuritySetting, vectorSecuritySettings);
    pQuery.GetValuesForProp(IDS_Group, vectorGroups);
    DWORD dwSettings = vectorSecuritySettings.size();
    DWORD dwGroups = vectorGroups.size();
    if(dwSettings >= 1 && dwGroups == 0)
    {
        CInstancePtr pSecSetting;
        for(LONG m = 0; m < dwSettings && SUCCEEDED(hr); m++)
        {
            CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
            pSecSetting = NULL;
            chstrLFSSPath.Format(_T("\\\\%s\\%s:%s"),
                                 (LPCTSTR)GetLocalComputerName(),
                                 IDS_CimWin32Namespace,
                                 (LPCTSTR)CHString((WCHAR*)vectorSecuritySettings[m]));

            if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting, pMethodContext)))
            {
                if(pSecSetting != NULL)
                {
                    CHString chstrSSPath; // SecuritySetting path
                    pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                    if(!chstrSSPath.IsEmpty())
                    {
                        CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
			            CSid sidGroup;
			            secFile.GetGroup(sidGroup);
                        if(sidGroup.IsValid())
                        {
                            CInstancePtr pNewAssocInst;
                            pNewAssocInst.Attach(CreateNewInstance(pMethodContext));
                            if(pNewAssocInst != NULL)
                            {
                                // Set the SecuritySetting property of the association instance.
                                pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                // Set the Group property of the association instance.
                                CHString chstrFullWin32SIDPath;
                                chstrFullWin32SIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                                                             (LPCTSTR)GetLocalComputerName(),
                                                             IDS_CimWin32Namespace,
                                                             (LPCTSTR)sidGroup.GetSidString());
                                pNewAssocInst->SetCHString(IDS_Group, chstrFullWin32SIDPath);
                                hr = pNewAssocInst->Commit();
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
        // hr = EnumerateInstances(pMethodContext, lFlags);
        // commented out since some other classes may support exec queries of this type, and returning provider not
        // capable from this class results in some instances (from other classes) being returned, followed by an abort
        // of the enumeration due to this class's returning provider not capable.
    }

#endif

    return hr;
}


HRESULT CWin32LogicalFileGroup::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{/*
	HRESULT hr = WBEM_S_NO_ERROR;

    if(m_dwPlatformID != VER_PLATFORM_WIN32_NT)
    {
		return(hr);
	}

    TRefPointerCollection<CInstance> LCIMLogicalFiles;

    CHString chstrAllFilesQuery;
    chstrAllFilesQuery = _T("SELECT __PATH FROM CIM_LogicalFile");
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrAllFilesQuery,
                                                        &LCIMLogicalFiles,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))

    {
        REFPTRCOLLECTION_POSITION pos;
        if(LCIMLogicalFiles.BeginEnum(pos))
        {
            CInstance* pinstCIMLogicalFile = NULL;
            CInstance* pSecSetting = NULL;
            //CInstance* pW32SID = NULL;
            while((SUCCEEDED(hr)) && (pinstCIMLogicalFile = LCIMLogicalFiles.GetNext(pos)))
            {
                if(pinstCIMLogicalFile != NULL)
                {
                    // For each logicalfile instance, need to create an association instance.
                    // For each association instance, need to fill in two properties: Group and SecuritySetting.

                    // Get and set the SecuritySetting property:
                    // First get the name property of the CIM_LogicalFile instance:
                    CHString chstrCLFName;
                    pinstCIMLogicalFile->GetCHString(IDS_Name, chstrCLFName);
                    CHString chstrDblEscCLFName;
                    EscapeBackslashes(chstrCLFName, chstrDblEscCLFName);
                    CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
                    pSecSetting = NULL;
                    chstrLFSSPath.Format(_T("\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\""),
                                         (LPCTSTR)GetLocalComputerName(),
                                         IDS_CimWin32Namespace,
                                         (LPCTSTR)chstrDblEscCLFName);

                    if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting)))
                    {
                        if(pSecSetting != NULL)
                        {
                            CHString chstrSSPath; // SecuritySetting path
                            pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                            if(!chstrSSPath.IsEmpty())
                            {
                                CInstance* pNewAssocInst = CreateNewInstance(pMethodContext);
                                if(pNewAssocInst != NULL)
                                {
                                    // Set the SecuritySetting property of the association instance...
                                    pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                    // Now set the Group property...
                                    CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
			                        CSid sidGroup;
			                        secFile.GetGroup(sidGroup);
                                    if(sidGroup.IsValid())
                                    {
                                        CHString chstrFullWin32SIDPath;
                                        chstrFullWin32SIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                                                                     (LPCTSTR)GetLocalComputerName(),
                                                                     IDS_CimWin32Namespace,
                                                                     (LPCTSTR)sidGroup.GetSidString());
                                        pNewAssocInst->SetCHString(IDS_Group, chstrFullWin32SIDPath);
                                        hr = Commit(pNewAssocInst);
                                    }
                                }
                            }
                            pSecSetting->Release();
                            pSecSetting = NULL;
                        }
                    }
                    pinstCIMLogicalFile->Release();
                    pinstCIMLogicalFile = NULL;
                }
            }
            LCIMLogicalFiles.EndEnum();
        }
    }

	return hr;
*/
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfilegroup.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#define  LOGICAL_FILE_GROUP_NAME "Win32_LogicalFileGroup" 

// provider provided for test provisions
class CWin32LogicalFileGroup: public Provider
{
	private:
    public:	
		CWin32LogicalFileGroup(const CHString& setName, const WCHAR* pszNamespace );
		~CWin32LogicalFileGroup();

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileowner.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


#define  LOGICAL_FILE_OWNER_NAME "Win32_LogicalFileOwner" 

// provider provided for test provisions
class CWin32LogicalFileOwner: public Provider
{
    private:
	public:	
		CWin32LogicalFileOwner(const CHString& setName, const WCHAR* pszNamespace );
		~CWin32LogicalFileOwner();
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileaudit.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "securefile.h"
#include "logicalfileaudit.h"


typedef std::vector<_bstr_t> BSTRTVEC;


CWin32LogicalFileAudit LogicalFileAudit( LOGICAL_FILE_AUDIT_NAME, IDS_CimWin32Namespace );

/*
    [Dynamic, Association: ToInstance]
class Win32_LogicalFileAccess : Win32_SecuritySettingAccess
{
    Win32_LogicalFileSecuritySetting ref SecuritySetting;

    Win32_SID ref Trustee;
};
*/

CWin32LogicalFileAudit::CWin32LogicalFileAudit( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalFileAudit::~CWin32LogicalFileAudit()
{
}

HRESULT CWin32LogicalFileAudit::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY

	if(pInstance != NULL)
	{
		CInstancePtr pLogicalFileInstance;

		// get instance by path on Win32_LogicalFileSecuritySetting part
		CHString chsLogicalFileSecurityPath;
		pInstance->GetCHString(_T("SecuritySetting"), chsLogicalFileSecurityPath);
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsLogicalFileSecurityPath, &pLogicalFileInstance, pMethodContext)) &&
           pLogicalFileInstance != NULL)
		{
			CHString chsFilePath;

			pLogicalFileInstance->GetCHString(IDS_Path, chsFilePath);

			CSecureFile secFile(chsFilePath, TRUE); // Need SACL
			CSACL sacl;
			secFile.GetSACL(sacl);

			// walk SACL looking for the sid path passed in....
			ACLPOSITION aclPos;
            // Need merged list...
            CAccessEntryList t_ael;
            if(sacl.GetMergedACL(t_ael))
            {
			    if(t_ael.BeginEnum(aclPos))
                {
			        CAccessEntry ACE;
			        CSid sidTrustee;
                    bool fFoundIt = false;
			        while(t_ael.GetNext(aclPos, ACE ) && !fFoundIt)
			        {
				        ACE.GetSID(sidTrustee);
				        CHString chsTrustee = sidTrustee.GetSidString();

				        CInstancePtr pSIDInstance;
				        CHString chstrSIDPath;
				        pInstance->GetCHString(_T("Trustee"), chstrSIDPath);
		                //CHString chstrFullSIDPath;
                        //chstrFullSIDPath.Format("\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                        //             GetLocalComputerName(),
                        //             IDS_CimWin32Namespace,
                        //             (LPCTSTR)chstrSIDPath);
			  	        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrSIDPath, &pSIDInstance, pInstance->GetMethodContext())))
				        {
					        if(pSIDInstance != NULL)
					        {
						        CHString chsInstanceSID;
						        pSIDInstance->GetCHString(_T("SID"), chsInstanceSID);
						        if(chsTrustee.CompareNoCase(chsInstanceSID) == 0)
						        {
							        hr = WBEM_S_NO_ERROR;
                                    fFoundIt = true;
						        }
					        }
				        }
			        }
			        t_ael.EndEnum(aclPos);
                }
            }
		}
	}
#endif

	return(hr);
}


HRESULT CWin32LogicalFileAudit::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

    // We optimize for one scenario only:  the query specified one or more SecuritySettings, requesting associations with the Trustees of
    // each; if the query specified one or more Trustees, we would have to enumerate all instances of cim_logicalfile and
    // determine the Trustees of each, so we don't support that "optimization".
    BSTRTVEC vectorSecuritySettings;
    BSTRTVEC vectorTrustees;
    pQuery.GetValuesForProp(IDS_SecuritySetting, vectorSecuritySettings);
    pQuery.GetValuesForProp(IDS_Trustee, vectorTrustees);
    DWORD dwSettings = vectorSecuritySettings.size();
    DWORD dwTrustees = vectorTrustees.size();
    if(dwSettings >= 1 && dwTrustees == 0)
    {
        CInstancePtr pSecSetting;
        for(LONG m = 0; m < dwSettings && SUCCEEDED(hr); m++)
        {
            CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
            pSecSetting = NULL;
            chstrLFSSPath.Format(L"\\\\%s\\%s:%s",
                                 (LPCTSTR)GetLocalComputerName(),
                                 IDS_CimWin32Namespace,
                                 (LPCTSTR)CHString((WCHAR*)vectorSecuritySettings[m]));

            if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceKeysByPath(chstrLFSSPath, &pSecSetting, pMethodContext)))
            {
                if(pSecSetting != NULL)
                {
                    CHString chstrSSPath; // SecuritySetting path
                    pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                    if(!chstrSSPath.IsEmpty())
                    {
                        CSecureFile secFile(chstrSSPath, TRUE);  // need SACL
                        // Get the SACL and for each entry create an instance of this association...
			            CSACL sacl;
                        CSid sidTrustee;
                        ACLPOSITION aclPos;
                        CAccessEntry ACE;
			            secFile.GetSACL(sacl);
                        // Need merged list...
                        CAccessEntryList t_ael;
                        if(sacl.GetMergedACL(t_ael))
                        {
                            if(t_ael.BeginEnum(aclPos))
                            {
                                while(t_ael.GetNext(aclPos, ACE) && SUCCEEDED(hr))
			                    {
                                    ACE.GetSID(sidTrustee);
                                    if(sidTrustee.IsValid())
                                    {
                                        CInstancePtr pNewAssocInst;
                                        pNewAssocInst.Attach(CreateNewInstance(pMethodContext));
                                        if(pNewAssocInst != NULL)
                                        {
                                            // Set the SecuritySetting property of the association instance.
                                            pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                            // Set the Trustee property of the association instance.
                                            CHString chstrFullWin32SIDPath;
                                            chstrFullWin32SIDPath.Format(L"\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                                                                         (LPCTSTR)GetLocalComputerName(),
                                                                         IDS_CimWin32Namespace,
                                                                         (LPCTSTR)sidTrustee.GetSidString());
                                            pNewAssocInst->SetCHString(IDS_Trustee, chstrFullWin32SIDPath);
                                            hr = pNewAssocInst->Commit();
                                        }
                                    }
                                }
                                t_ael.EndEnum(aclPos);
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
        // hr = EnumerateInstances(pMethodContext, lFlags);
        // commented out since some other classes may support exec queries of this type, and returning provider not
        // capable from this class results in some instances (from other classes) being returned, followed by an abort
        // of the enumeration due to this class's returning provider not capable.
    }

#endif

    return hr;
}


HRESULT CWin32LogicalFileAudit::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
/*	HRESULT hr = WBEM_S_NO_ERROR;

    if(m_dwPlatformID != VER_PLATFORM_WIN32_NT)
    {
		return(hr);
	}

    TRefPointerCollection<CInstance> LCIMLogicalFiles;

    CHString chstrAllFilesQuery;
    chstrAllFilesQuery = L"SELECT __PATH FROM CIM_LogicalFile";
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrAllFilesQuery,
                                                        &LCIMLogicalFiles,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))

    {
        REFPTRCOLLECTION_POSITION pos;
        if(LCIMLogicalFiles.BeginEnum(pos))
        {
            CInstance* pinstCIMLogicalFile = NULL;
            CInstance* pSecSetting = NULL;
            while((SUCCEEDED(hr)) && (pinstCIMLogicalFile = LCIMLogicalFiles.GetNext(pos)))
            {
                if(pinstCIMLogicalFile != NULL)
                {
                    // For each logicalfile instance, need to create an association instance.
                    // For each association instance, need to fill in two properties: Trustee and SecuritySetting.

                    // Get and set the SecuritySetting property:
                    // First get the name property of the CIM_LogicalFile instance:
                    CHString chstrCLFName;
                    pinstCIMLogicalFile->GetCHString(IDS_Name, chstrCLFName);
                    CHString chstrDblEscCLFName;
                    EscapeBackslashes(chstrCLFName, chstrDblEscCLFName);
                    CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
                    pSecSetting = NULL;
                    chstrLFSSPath.Format(L"\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\"",
                                         (LPCTSTR)GetLocalComputerName(),
                                         IDS_CimWin32Namespace,
                                         (LPCTSTR)chstrDblEscCLFName);

                    if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting)))
                    {
                        if(pSecSetting != NULL)
                        {
                            CHString chstrSSPath; // SecuritySetting path
                            pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                            if(!chstrSSPath.IsEmpty())
                            {
                                CSecureFile secFile(chstrSSPath, TRUE);  // need SACL
                                // Get the SACL and for each entry create an instance of this association...
			                    CSACL sacl;
                                CSid sidTrustee;
                                ACLPOSITION aclPos;
                                CAccessEntry ACE;
			                    secFile.GetSACL(sacl);
                                if(sacl.BeginEnum(aclPos))
                                {
                                    while(sacl.GetNext(aclPos, ACE))
			                        {
                                        ACE.GetSID(sidTrustee);
                                        if(sidTrustee.IsValid())
                                        {
                                            CInstance* pNewAssocInst = CreateNewInstance(pMethodContext);
                                            if(pNewAssocInst != NULL)
                                            {
                                                // Set the SecuritySetting property of the association instance.
                                                pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                                // Set the Trustee property of the association instance.
                                                CHString chstrFullWin32SIDPath;
                                                chstrFullWin32SIDPath.Format(L"\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                                                                             (LPCTSTR)GetLocalComputerName(),
                                                                             IDS_CimWin32Namespace,
                                                                             (LPCTSTR)sidTrustee.GetSidString());
                                                pNewAssocInst->SetCHString(IDS_Trustee, chstrFullWin32SIDPath);
                                                hr = Commit(pNewAssocInst);
                                            }
                                        }
                                    }
                                    sacl.EndEnum(aclPos);
                                }
                            }
                            pSecSetting->Release();
                            pSecSetting = NULL;
                        }
                    }
                    pinstCIMLogicalFile->Release();
                    pinstCIMLogicalFile = NULL;
                }
            }
            LCIMLogicalFiles.EndEnum();
        }
    }

	return hr;
*/
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalfileowner.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "securefile.h"
#include "logicalfileowner.h"

typedef std::vector<_bstr_t> BSTRTVEC;

CWin32LogicalFileOwner LogicalFileOwner( LOGICAL_FILE_OWNER_NAME, IDS_CimWin32Namespace );

/*
    [Dynamic, Association: ToInstance]
class Win32_LogicalFileOwner : Win32_SecuritySettingOwner
{
    Win32_LogicalFileSecuritySetting ref SecuritySetting;

    Win32_SID ref Owner;
};
*/

CWin32LogicalFileOwner::CWin32LogicalFileOwner( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalFileOwner::~CWin32LogicalFileOwner()
{
}

HRESULT CWin32LogicalFileOwner::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY

	if(pInstance != NULL)
	{
		CInstancePtr pLogicalFileInstance;

		// get instance by path on Win32_LogicalFileSecuritySetting part
		CHString chsLogicalFileSecurityPath;
		pInstance->GetCHString(L"SecuritySetting", chsLogicalFileSecurityPath);
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsLogicalFileSecurityPath, &pLogicalFileInstance, pMethodContext)))
		{
            if(pLogicalFileInstance != NULL)
            {
			    CHString chsFilePath;
			    pLogicalFileInstance->GetCHString(IDS_Path, chsFilePath);

			    CSecureFile secFile(chsFilePath, TRUE);
			    CSid sidOwner;
			    secFile.GetOwner(sidOwner);
			    CHString chsOwner = sidOwner.GetSidString();

			    CInstancePtr pSIDInstance ;
			    CHString chstrSIDPath;
			    pInstance->GetCHString(L"Owner", chstrSIDPath);
                //CHString chstrFullSIDPath;
                //chstrFullSIDPath.Format(_T("\\\\%s\\%s:Win32_SID.SID=\"%s\""),
                //             GetLocalComputerName(),
                //             IDS_CimWin32Namespace,
                //             (LPCTSTR)chstrSIDPath);

		  	    if (SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrSIDPath, &pSIDInstance, pInstance->GetMethodContext())))
			    {
			        if(pSIDInstance != NULL)
                    {
                        // compare SID
				        CHString chsSIDCompare;
				        pSIDInstance->GetCHString(L"SID", chsSIDCompare);
				        if (0 == chsOwner.CompareNoCase(chsSIDCompare))
				        {
					        hr = WBEM_S_NO_ERROR;
				        }
                    }
			    }
            }
		}
	}

#endif

	return(hr);
}


HRESULT CWin32LogicalFileOwner::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

    // We optimize for one scenario only:  the query specified one or more SecuritySettings, requesting associations with the owner of
    // each; if the query specified one or more Owners, for each we would have to enumerate all instances of cim_logicalfile and
    // determine the owner of each, so we don't support that "optimization".
    BSTRTVEC vectorSecuritySettings;
    BSTRTVEC vectorOwners;
    pQuery.GetValuesForProp(IDS_SecuritySetting, vectorSecuritySettings);
    pQuery.GetValuesForProp(IDS_Owner, vectorOwners);
    DWORD dwSettings = vectorSecuritySettings.size();
    DWORD dwOwners = vectorOwners.size();
    if(dwSettings >= 1 && dwOwners == 0)
    {
        CInstancePtr pSecSetting;
        for(LONG m = 0; m < dwSettings && SUCCEEDED(hr); m++)
        {
            CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
            pSecSetting = NULL;
            chstrLFSSPath.Format(L"\\\\%s\\%s:%s",
                                 (LPCTSTR)GetLocalComputerName(),
                                 IDS_CimWin32Namespace,
                                 (LPCTSTR)CHString((WCHAR*)vectorSecuritySettings[m]));

            if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceKeysByPath(chstrLFSSPath, &pSecSetting, pMethodContext)))
            {
                if(pSecSetting != NULL)
                {
                    CHString chstrSSPath; // SecuritySetting path
                    pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                    if(!chstrSSPath.IsEmpty())
                    {
                        CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
			            CSid sidOwner;
			            secFile.GetOwner(sidOwner);
                        if(sidOwner.IsValid())
                        {
                            CInstancePtr pNewAssocInst;
                            pNewAssocInst.Attach(CreateNewInstance(pMethodContext));
                            if(pNewAssocInst != NULL)
                            {
                                // Set the SecuritySetting property of the association instance.
                                pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                // Set the Owner property of the association instance.
                                //CInstance* pW32SID = NULL;
                                //if(SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pMethodContext, "Win32_SID", &pW32SID)))
			                    //{
                                //    if(pW32SID != NULL)
                                //    {
                                //        hr = FillW32SIDFromSid(pW32SID, sidOwner);
                                //        if(SUCCEEDED(hr))
                                //        {
                                //            pNewAssocInst->SetEmbeddedObject(IDS_Owner, *pW32SID);
                                //            hr = Commit(pNewAssocInst);
                                //        }
                                //        pW32SID->Release();
                                //    }
                                //}
                                CHString chstrFullWin32SIDPath;
                                chstrFullWin32SIDPath.Format(L"\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                                                             (LPCTSTR)GetLocalComputerName(),
                                                             IDS_CimWin32Namespace,
                                                             (LPCTSTR)sidOwner.GetSidString());
                                pNewAssocInst->SetCHString(IDS_Owner, chstrFullWin32SIDPath);
                                hr = pNewAssocInst->Commit();
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
        // hr = EnumerateInstances(pMethodContext, lFlags);
        // commented out since some other classes may support exec queries of this type, and returning provider not
        // capable from this class results in some instances (from other classes) being returned, followed by an abort
        // of the enumeration due to this class's returning provider not capable.
    }

#endif

    return hr;
}



HRESULT CWin32LogicalFileOwner::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{/*
	HRESULT hr = WBEM_S_NO_ERROR;

    if(m_dwPlatformID != VER_PLATFORM_WIN32_NT)
    {
		return(hr);
	}

    TRefPointerCollection<CInstance> LCIMLogicalFiles;

    CHString chstrAllFilesQuery;
    chstrAllFilesQuery = L"SELECT __PATH FROM CIM_LogicalFile";
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrAllFilesQuery,
                                                        &LCIMLogicalFiles,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))

    {
        REFPTRCOLLECTION_POSITION pos;
        if(LCIMLogicalFiles.BeginEnum(pos))
        {
            CInstance* pinstCIMLogicalFile = NULL;
            CInstance* pSecSetting = NULL;
            //CInstance* pW32SID = NULL;
            while((SUCCEEDED(hr)) && (pinstCIMLogicalFile = LCIMLogicalFiles.GetNext(pos)))
            {
                if(pinstCIMLogicalFile != NULL)
                {
                    // For each logicalfile instance, need to create an association instance.
                    // For each association instance, need to fill in two properties: Owner and SecuritySetting.

                    // Get and set the SecuritySetting property:
                    // First get the name property of the CIM_LogicalFile instance:
                    CHString chstrCLFName;
                    pinstCIMLogicalFile->GetCHString(IDS_Name, chstrCLFName);
                    CHString chstrDblEscCLFName;
                    EscapeBackslashes(chstrCLFName, chstrDblEscCLFName);
                    CHString chstrLFSSPath;  // LogicalFileSecuritySetting path
                    pSecSetting = NULL;
                    chstrLFSSPath.Format(L"\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\"",
                                         (LPCTSTR)GetLocalComputerName(),
                                         IDS_CimWin32Namespace,
                                         (LPCTSTR)chstrDblEscCLFName);

                    if(SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(chstrLFSSPath, &pSecSetting)))
                    {
                        if(pSecSetting != NULL)
                        {
                            CHString chstrSSPath; // SecuritySetting path
                            pSecSetting->GetCHString(IDS_Path, chstrSSPath);
                            if(!chstrSSPath.IsEmpty())
                            {
                                CInstance* pNewAssocInst = CreateNewInstance(pMethodContext);
                                if(pNewAssocInst != NULL)
                                {
                                    // Set the SecuritySetting property of the association instance...
                                    pNewAssocInst->SetCHString(IDS_SecuritySetting, chstrLFSSPath);
                                    // Now set the Owner property...
                                    CSecureFile secFile(chstrSSPath, FALSE);  // don't need SACL
			                        CSid sidOwner;
			                        secFile.GetOwner(sidOwner);
                                    if(sidOwner.IsValid())
                                    {
                                        CHString chstrFullWin32SIDPath;
                                        chstrFullWin32SIDPath.Format(L"\\\\%s\\%s:Win32_SID.SID=\"%s\"",
                                                                     (LPCTSTR)GetLocalComputerName(),
                                                                     IDS_CimWin32Namespace,
                                                                     (LPCTSTR)sidOwner.GetSidString());
                                        pNewAssocInst->SetCHString(IDS_Owner, chstrFullWin32SIDPath);
                                        hr = Commit(pNewAssocInst);
                                    }
                                }
                            }
                            pSecSetting->Release();
                        }
                    }
                    pinstCIMLogicalFile->Release();
                }
            }
            LCIMLogicalFiles.EndEnum();
        }
    }

	return hr;
*/
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalmemory.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// logicalmemory.h        	

//                                                                  

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//                                                                   
//  9/05/96     jennymc     Updated to meet current standards
//                                                                   
///////////////////////////////////////////////////////////////////////

#define	PROPSET_NAME_LOGMEM	L"Win32_LogicalMemoryConfiguration"

/////////////////////////////////////////////////////////////////////
#define LOGMEM_REGISTRY_KEY L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
#define PAGING_FILES _T("PagingFiles")
#define REFRESH 1
#define INITIAL_ASSIGN 2

class CWin32LogicalMemoryConfig : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32LogicalMemoryConfig(LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32LogicalMemoryConfig() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	private:

        // Utility function(s)
        //====================

        void AssignMemoryStatus( CInstance* pInstance );
        BOOL GetWinntSwapFileName( CHString & chsTmp );
        BOOL GetWin95SwapFileName( CHString & chsTmp );

        BOOL GetWin95Instance( CInstance* pInstance );
        BOOL RefreshWin95Instance( CInstance* pInstance );

        BOOL GetNTInstance( CInstance* pInstance );
        BOOL RefreshNTInstance( CInstance* pInstance );

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalmemory.cpp ===
/////////////////////////////////////////////////////////////////

//

// logmem.cpp -- Implementation of MO Provider for Logical Memory

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  9/03/96     jennymc     Updated to meet current standards
//
/////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <cregcls.h>
#include "logicalmemory.h"
#include "resource.h"
#include "Kernel32Api.h"

typedef BOOL (WINAPI *lpKERNEL32_GlobalMemoryStatusEx) (IN OUT LPMEMORYSTATUSEX lpBuffer);

// Property set declaration
//=========================

CWin32LogicalMemoryConfig win32LogicalMemConfig ( PROPSET_NAME_LOGMEM , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LogicalMemoryConfig :: CWin32LogicalMemoryConfig (

	LPCWSTR strName,
	LPCWSTR pszNamespace

) : Provider ( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::~CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LogicalMemoryConfig :: ~CWin32LogicalMemoryConfig ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

HRESULT CWin32LogicalMemoryConfig :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
	// Find the instance depending on platform id.

	CHString chsKey;
	pInstance->GetCHString ( IDS_Name , chsKey ) ;
	if ( chsKey.CompareNoCase ( L"LogicalMemoryConfiguration" ) == 0 )
    {
#ifdef NTONLY

		hr = RefreshNTInstance ( pInstance ) ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND ;

#endif

#ifdef WIN9XONLY

		hr = RefreshWin95Instance ( pInstance ) ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND ;

#endif

    }

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

HRESULT CWin32LogicalMemoryConfig :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr;

	CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
	// Get the proper OS dependent instance

#ifdef NTONLY
	BOOL fReturn = GetNTInstance ( pInstance ) ;
#endif

#ifdef WIN9XONLY
	BOOL fReturn = GetWin95Instance ( pInstance ) ;
#endif

	// Commit the instance if'n we got it.

	if ( fReturn )
	{
		hr = pInstance->Commit (  ) ;
	}
    else
    {
        hr = WBEM_E_FAILED;
    }

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef WIN9XONLY

BOOL CWin32LogicalMemoryConfig :: GetWin95Instance ( CInstance *pInstance )
{
    AssignMemoryStatus ( pInstance );

    return TRUE;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef WIN9XONLY

BOOL CWin32LogicalMemoryConfig :: RefreshWin95Instance ( CInstance *pInstance )
{
	// We used to get this value, but we don't appear to be doing
	// anything with it.  Because I'm superstitous, I'm leaving
	// this call in.

    CHString chsTmp ;
    GetWin95SwapFileName ( chsTmp ) ;

	AssignMemoryStatus ( pInstance );

    return TRUE;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY

BOOL CWin32LogicalMemoryConfig :: GetNTInstance ( CInstance *pInstance )
{
    AssignMemoryStatus ( pInstance ) ;

    return TRUE;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY

BOOL CWin32LogicalMemoryConfig :: RefreshNTInstance ( CInstance *pInstance )
{
	// We used to get this value, but we don't appear to be doing
	// anything with it.  Because I'm superstitous, I'm leaving
	// this call in.

    CHString chsTmp;
    GetWinntSwapFileName ( chsTmp ) ;

	AssignMemoryStatus ( pInstance ) ;

    return TRUE;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

void CWin32LogicalMemoryConfig::AssignMemoryStatus( CInstance* pInstance )
{
	// We really only have one logical configuration to concern our little
	// heads with.

    pInstance->SetCharSplat( IDS_Name, L"LogicalMemoryConfiguration" );
	pInstance->SetCharSplat( L"SettingID", L"LogicalMemoryConfiguration" );

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_LogicalMemoryConfiguration);

    pInstance->SetCHString( IDS_Caption,     sTemp2);
	pInstance->SetCHString( IDS_Description, sTemp2);

	// By setting the length, we tell GlobalMemoryStatus()
	// how much info we want
	//====================================================

	MEMORYSTATUS MemoryStatus;
	MemoryStatus.dwLength = sizeof (MEMORYSTATUS);

	// Get the amount of memory both physical and
	// pagefile
	//===========================================
#ifdef NTONLY

	if( IsWinNT5() )
	{
		CKernel32Api* pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
        if(pKernel32 != NULL)
        {
			try
			{
				MEMORYSTATUSEX	stMemoryVLM;
				stMemoryVLM.dwLength = sizeof( MEMORYSTATUSEX );

				BOOL fRet = FALSE;
				if ( pKernel32->GlobalMemoryStatusEx ( &stMemoryVLM, &fRet) && fRet )
				{

   					// Value current in bytes, to convert to k >> 10 (divide by 1024)
					//***************************************************************

					DWORDLONG ullTotalVirtual	= stMemoryVLM.ullTotalVirtual>>10;
					DWORDLONG ullTotalPhys		= stMemoryVLM.ullTotalPhys>>10;
					DWORDLONG ullTotalPageFile	= stMemoryVLM.ullTotalPageFile>>10;
					DWORDLONG ullAvailVirtual	= stMemoryVLM.ullAvailVirtual>>10;

					pInstance->SetDWORD( IDS_TotalVirtualMemory, (DWORD)(stMemoryVLM.ullTotalPhys + stMemoryVLM.ullTotalPageFile ) / 1024 );
					pInstance->SetDWORD( IDS_TotalPhysicalMemory, (DWORD)ullTotalPhys );
					pInstance->SetDWORD( IDS_TotalPageFileSpace, (DWORD)ullTotalPageFile );
					pInstance->SetDWORD( IDS_AvailableVirtualMemory, (DWORD)( stMemoryVLM.ullAvailPhys + stMemoryVLM.ullAvailPageFile ) / 1024 );
				}
			}
			catch ( ... )
			{
				CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);

				throw ;
			}

			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
			pKernel32 = NULL;

		}
	}
	else
#endif
	{
		GlobalMemoryStatus ( & MemoryStatus );

  		// Value current in bytes, to convert to k >> 10 (divide by 1024)
		//***************************************************************

		pInstance->SetDWORD( IDS_TotalVirtualMemory, ( MemoryStatus.dwTotalPhys + MemoryStatus.dwTotalPageFile )/10 );
		pInstance->SetDWORD( IDS_TotalPhysicalMemory, MemoryStatus.dwTotalPhys>>10 );
		pInstance->SetDWORD( IDS_TotalPageFileSpace, MemoryStatus.dwTotalPageFile>>10 );
		pInstance->SetDWORD( IDS_AvailableVirtualMemory, ( MemoryStatus.dwAvailPhys + MemoryStatus.dwAvailPageFile )/10 );
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL CWin32LogicalMemoryConfig :: GetWin95SwapFileName ( CHString &chsTmp )
{
	char szBuf [ _MAX_PATH + 2 ] ;

    DEVIOCTL_REGISTERS reg;
	memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

    reg.reg_EAX = 0x440D;            // IOCTL for block devices
    reg.reg_ECX = 0x486e;           // Get Swap file name
    reg.reg_EDX = (DWORD) szBuf;   // receives media identifier information
    reg.reg_Flags = 0x0001;         // assume error (carry flag is set)

	BOOL fRc;

    BOOL fResult = VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL);
    if ( ! fResult || ( reg.reg_Flags & 0x0001 ) )
	{
        fRc = FALSE;
	}
	else
	{
		fRc = TRUE;
		chsTmp = szBuf;
	}

    return fRc;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalMemoryConfig::CWin32LogicalMemoryConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CWin32LogicalMemoryConfig :: GetWinntSwapFileName ( CHString &chsTmp )
{
    CRegistry PrimaryReg ;

	BOOL bRet = PrimaryReg.OpenLocalMachineKeyAndReadValue (

		LOGMEM_REGISTRY_KEY,
        PAGING_FILES,
		chsTmp
	) ;

    if ( bRet == ERROR_SUCCESS )
	{
		// keep the text preceeding the space
		int ndex = chsTmp.Find(' ');

		if (ndex != -1)
		{
			chsTmp = chsTmp.Left(ndex);
		}
	}
	else
	{
        LogEnumValueError( _T(__FILE__), __LINE__,PAGING_FILES,LOGMEM_REGISTRY_KEY);
	}

	return bRet ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalprogramgroupitem.h ===
//=================================================================

//

// LogicalProgramGroupItem.h -- Logical Program group item property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-kevhu       Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_LOGICALPRGGROUPITEM   L"Win32_LogicalProgramGroupItem"


class CWin32LogProgramGroupItem : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32LogProgramGroupItem(LPCWSTR name, LPCWSTR pszNameSpace);
       ~CWin32LogProgramGroupItem() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);



    private:
        HRESULT QueryForSubItemsAndCommit(CHString& chstrUserAccount,
                                          CHString& chstrQuery,
                                          MethodContext* pMethodContext,
                                          bool fOnNTFS);

        VOID RemoveDoubleBackslashes(CHString& chstring);

		HRESULT SetCreationDate
        (
            CHString &a_chsPGIName, 
            CHString &a_chsUserName,
            CInstance *a_pInstance,
            bool fOnNTFS
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalshareaccess.h ===
//=================================================================

//

// LogicalShareAccess.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __LOGICALSHAREACCESS_H__
#define __LOGICALSHAREACCESS_H__

#define  LOGICAL_SHARE_ACCESS_NAME L"Win32_LogicalShareAccess"

// provider provided for test provisions
class CWin32LogicalShareAccess: public Provider
{
	public:	
		CWin32LogicalShareAccess(LPCWSTR setName, LPCWSTR pszNamespace );
		~CWin32LogicalShareAccess();

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
		HRESULT CWin32LogicalShareAccess::FillSidInstance(CInstance* pInstance, CSid& sid) ;
		HRESULT CWin32LogicalShareAccess::GetEmptyInstanceHelper(CHString chsClassName, CInstance**ppInstance, MethodContext* pMethodContext ) ;
		HRESULT CWin32LogicalShareAccess::FillProperties(CInstance* pInstance, CAccessEntry& ACE ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalprogramgroupitem.cpp ===
//=================================================================

//

// PrgGroup.CPP -- Program group item property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/19/98   a-kevhu     created
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>

#include "UserHive.h"
#include <io.h>

#include "LogicalProgramGroupItem.h"
#include "LogicalProgramGroup.h"

// Property set declaration
//=========================

CWin32LogProgramGroupItem MyCWin32LogProgramGroupItemSet ( PROPSET_NAME_LOGICALPRGGROUPITEM , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogProgramGroupItem::CWin32LogProgramGroupItem
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LogProgramGroupItem :: CWin32LogProgramGroupItem (

	LPCWSTR name,
	LPCWSTR pszNameSpace

) : Provider ( name , pszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogProgramGroupItem::~CWin32LogProgramGroupItem
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LogProgramGroupItem :: ~CWin32LogProgramGroupItem ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogProgramGroupItem::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_NOT_FOUND ;

    CHString chstrSuppliedName ;
	pInstance->GetCHString(IDS_Name, chstrSuppliedName);

    CHString chstrSuppliedFilenameExt = chstrSuppliedName.Mid(chstrSuppliedName.ReverseFind(_T('\\'))+1);
    CHString chstrSuppliedProgGrpItemProgGrp = chstrSuppliedName.Left(chstrSuppliedName.ReverseFind(_T('\\')));

    // chstrSuppliedProgGrpItemProgGrp contents need to be double escaped (even though they will get
    // double escaped again below, since they will need to be quadrouple escaped for the query of the association proggroup to dir)

    CHString chstrDblEscSuppliedProgGrpItemProgGrp;
    EscapeBackslashes ( chstrSuppliedProgGrpItemProgGrp , chstrDblEscSuppliedProgGrpItemProgGrp ) ;

    CHString chstrDirAntecedent ;
    chstrDirAntecedent.Format (

		L"\\\\%s\\%s:%s.Name=\"%s\"",
		GetLocalComputerName(),
		IDS_CimWin32Namespace,
		PROPSET_NAME_LOGICALPRGGROUP,
		chstrDblEscSuppliedProgGrpItemProgGrp
	) ;

    CHString chstrDblEscPGName ;
    EscapeBackslashes ( chstrDirAntecedent , chstrDblEscPGName ) ;

    CHString chstrDblEscPGNameAndEscQuotes ;
    EscapeQuotes ( chstrDblEscPGName , chstrDblEscPGNameAndEscQuotes ) ;

    CHString chstrProgGroupDirQuery ;
    chstrProgGroupDirQuery.Format (

		L"SELECT * FROM Win32_LogicalProgramGroupDirectory WHERE Antecedent = \"%s\"",
		chstrDblEscPGNameAndEscQuotes
	);

    TRefPointerCollection<CInstance> GroupDirs;

    HRESULT t_Result = CWbemProviderGlue::GetInstancesByQuery (

		chstrProgGroupDirQuery,
        &GroupDirs,
        pInstance->GetMethodContext(),
        IDS_CimWin32Namespace
	) ;

    if ( SUCCEEDED ( t_Result ) )
    {
		REFPTRCOLLECTION_POSITION pos;

		if(GroupDirs.BeginEnum(pos))
		{
            CHString chstrAntecedent;
            CHString chstrProgroupName;
            CHString chstrDependent;
            CHString chstrFullFileName;

			CInstancePtr pProgramGroupDirInstance;

            // We're going to need to know whether the file system of the drive
            // on which the start menu folder resides is ntfs or not so that
            // we can accurately report the installtime property.
            bool fOnNTFS;
#ifdef WIN9XONLY
            fOnNTFS = false;
#endif
#ifdef NTONLY
            fOnNTFS = true;
            TCHAR tstrRoot[4] = _T("");
            TCHAR tstrFSName[_MAX_PATH] = _T("");
            TCHAR tstrWindowsDir[_MAX_PATH];
            if(GetWindowsDirectory(tstrWindowsDir, sizeof(tstrWindowsDir)/sizeof(TCHAR)))
            {
                _tcsncpy(tstrRoot, tstrWindowsDir, 3);
                GetVolumeInformation(tstrRoot, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                if(tstrFSName != NULL && _tcslen(tstrFSName) > 0)
                {
                    if(_tcsicmp(tstrFSName,_T("FAT")) == 0 || _tcsicmp(tstrFSName,_T("FAT32")) == 0)
                    {
                        fOnNTFS = false;
                    }
                }
            }
#endif

            for (pProgramGroupDirInstance.Attach(GroupDirs.GetNext ( pos ));
                 pProgramGroupDirInstance != NULL;
                 pProgramGroupDirInstance.Attach(GroupDirs.GetNext ( pos )))
			{
				pProgramGroupDirInstance->GetCHString ( IDS_Antecedent , chstrAntecedent ) ;
				pProgramGroupDirInstance->GetCHString ( IDS_Dependent , chstrDependent ) ;

				// See if the program group name matches the supplied program group item name minus the filename

                chstrProgroupName = chstrAntecedent.Mid ( chstrAntecedent.Find ( _T('=')) + 2 ) ;

                // The name we were supplied with did not have escaped backslashes, so remove them from the one coming from the antecedent...

                RemoveDoubleBackslashes ( chstrProgroupName ) ;
                chstrProgroupName = chstrProgroupName.Left ( chstrProgroupName.GetLength () - 1 ) ;

                if(chstrSuppliedProgGrpItemProgGrp == chstrProgroupName)
                {
                    // See if there is a file of that name on the file system
                    chstrFullFileName = chstrDependent.Mid ( chstrDependent.Find ( _T('=') ) + 2 ) ;
                    chstrFullFileName = chstrFullFileName.Left ( chstrFullFileName.GetLength () - 1 ) ;
                    RemoveDoubleBackslashes ( chstrFullFileName ) ;

					CHString chstrTemp ;
                    chstrTemp.Format (

						L"%s\\%s",
						chstrFullFileName,
						chstrSuppliedFilenameExt
					) ;

                    HANDLE hFile = CreateFile (

						TOBSTRT(chstrTemp),
						GENERIC_READ,
						FILE_SHARE_READ,
						NULL,
						OPEN_EXISTING,
						0,
						NULL
					) ;

                    if ( hFile != INVALID_HANDLE_VALUE )
                    {
                        hr = WBEM_S_NO_ERROR ;
                        CloseHandle ( hFile ) ;

						// Set the creation date...
						CHString chstrUserName = chstrSuppliedProgGrpItemProgGrp.SpanExcluding(L":");
                        CHString chstrPGIPart = chstrSuppliedProgGrpItemProgGrp.Right(chstrSuppliedProgGrpItemProgGrp.GetLength() - chstrUserName.GetLength() - 1);
                        chstrPGIPart += L"\\";
                        chstrPGIPart += chstrSuppliedFilenameExt;

						SetCreationDate(chstrPGIPart, chstrUserName, pInstance, fOnNTFS);

                        CHString chstrTmp2;
                        chstrTmp2.Format(L"Logical program group item \'%s\\%s\'", (LPCWSTR) chstrProgroupName, (LPCWSTR) chstrSuppliedFilenameExt);
                        pInstance->SetCHString(L"Description" , chstrTmp2) ;
                        pInstance->SetCHString(L"Caption" , chstrTmp2) ;

						break ;
                    }
                }
            }

			GroupDirs.EndEnum();

		}	// IF BeginEnum
	}
	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogProgramGroupItem::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
    // Step 1: Get an enumeration of all the ProgramGroupDirectory association class instances

    TRefPointerCollection<CInstance> ProgGroupDirs;

    HRESULT hr = CWbemProviderGlue::GetAllInstances (

		L"Win32_LogicalProgramGroupDirectory",
		&ProgGroupDirs,
		IDS_CimWin32Namespace,
		pMethodContext
	) ;

    if ( SUCCEEDED ( hr ) )
    {
	    REFPTRCOLLECTION_POSITION pos ;
	    if ( ProgGroupDirs.BeginEnum ( pos ) )
	    {
            CHString chstrDependent;
            CHString chstrFullPathName;
            CHString chstrPath;
            CHString chstrDrive;
            CHString chstrAntecedent;
            CHString chstrUserAccount;
            CHString chstrSearchPath;

		    CInstancePtr pProgramGroupDirInstance;

            // We're going to need to know whether the file system of the drive
            // on which the start menu folder resides is ntfs or not so that
            // we can accurately report the installtime property.
            bool fOnNTFS;
#ifdef WIN9XONLY
            fOnNTFS = false;
#endif
#ifdef NTONLY
            fOnNTFS = true;
            TCHAR tstrRoot[4] = _T("");
            TCHAR tstrFSName[_MAX_PATH] = _T("");
            TCHAR tstrWindowsDir[_MAX_PATH];

            if(GetWindowsDirectory(tstrWindowsDir, sizeof(tstrWindowsDir)/sizeof(TCHAR)))
            {
                _tcsncpy(tstrRoot, tstrWindowsDir, 3);
                GetVolumeInformation(tstrRoot, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                if(tstrFSName != NULL && _tcslen(tstrFSName) > 0)
                {
                    if(_tcsicmp(tstrFSName,_T("FAT")) == 0 || _tcsicmp(tstrFSName,_T("FAT32")) == 0)
                    {
                        fOnNTFS = false;
                    }
                }
            }
#endif

            for (pProgramGroupDirInstance.Attach(ProgGroupDirs.GetNext ( pos ));
                 (pProgramGroupDirInstance != NULL) && SUCCEEDED ( hr );
                 pProgramGroupDirInstance.Attach(ProgGroupDirs.GetNext ( pos )))
			{
				// Step 2: For each program group, get the drive and path associated on disk with it:

				pProgramGroupDirInstance->GetCHString(IDS_Dependent, chstrDependent);
				chstrFullPathName = chstrDependent.Mid(chstrDependent.Find(_T('='))+1);
				chstrDrive = chstrFullPathName.Mid(1,2);
				chstrPath = chstrFullPathName.Mid(3);
				chstrPath = chstrPath.Left(chstrPath.GetLength() - 1);
				chstrPath += _T("\\\\");

				// Steo 3: For each program group, get the user account it is associated with:

				pProgramGroupDirInstance->GetCHString(IDS_Antecedent, chstrAntecedent);
				chstrUserAccount = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
				chstrUserAccount = chstrUserAccount.Left(chstrUserAccount.GetLength() - 1);

				// Step 4: Query that directory for all the CIM_DataFile instances (of any type) it contains:

				chstrSearchPath.Format(L"%s%s",chstrDrive,chstrPath);

				// The user account has the backslashes escaped, which is not correct.  So unescape them:

				RemoveDoubleBackslashes(chstrUserAccount);

				// The function QueryForSubItemsAndCommit needs a search string with single backslashes...

				RemoveDoubleBackslashes(chstrSearchPath);
				hr = QueryForSubItemsAndCommit(chstrUserAccount, chstrSearchPath, pMethodContext, fOnNTFS);

			}

            ProgGroupDirs.EndEnum();
        }
    }

    return hr;
}




/*****************************************************************************
 *
 *  FUNCTION    : QueryForSubItemsAndCommit
 *
 *  DESCRIPTION : Helper to fill property and commit instances of prog group items
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogProgramGroupItem :: QueryForSubItemsAndCommit (

	CHString &chstrUserAccount,
    CHString &chstrQuery,
    MethodContext *pMethodContext,
    bool fOnNTFS
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
    {
        // we're on NT

        WIN32_FIND_DATAW stFindData;
        ZeroMemory ( & stFindData , sizeof ( stFindData ) ) ;

        _bstr_t bstrtSearchString ( ( LPCTSTR ) chstrQuery ) ;

		WCHAR wstrDriveAndPath[_MAX_PATH];
        wcscpy ( wstrDriveAndPath, ( wchar_t * ) bstrtSearchString ) ;

        bstrtSearchString += L"*.*" ;

        SmartFindClose hFind = FindFirstFileW (

			( wchar_t * ) bstrtSearchString,
			&stFindData
		) ;

        DWORD dw = GetLastError();
        if ( hFind == INVALID_HANDLE_VALUE || dw != ERROR_SUCCESS )
        {
            hr = WinErrorToWBEMhResult ( dw ) ;
        }

        if ( hr == WBEM_E_ACCESS_DENIED )  // keep going - might have access to others
        {
            hr = WBEM_S_NO_ERROR ;
        }


        do
        {
            if(!(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
               (wcscmp(stFindData.cFileName, L".") != 0) &&
               (wcscmp(stFindData.cFileName, L"..") != 0))
            {
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                _bstr_t bstrtName((LPCTSTR)chstrUserAccount);
                bstrtName += L"\\";
                bstrtName += stFindData.cFileName;
                pInstance->SetWCHARSplat(IDS_Name, (wchar_t*)bstrtName);

                if(fOnNTFS)
                {
                    pInstance->SetDateTime(IDS_InstallDate, WBEMTime(stFindData.ftCreationTime));
                }
                else
                {
                    WBEMTime wbt(stFindData.ftCreationTime);
                    BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                    if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                    {
                        pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                        SysFreeString(bstrRealTime);
                    }
                }

                CHString chstrTmp2;
                chstrTmp2.Format(L"Logical program group item \'%s\'", (LPCWSTR) bstrtName);
                pInstance->SetCHString(L"Description" , chstrTmp2) ;
                pInstance->SetCHString(L"Caption" , chstrTmp2) ;

                hr = pInstance->Commit();
            }
            if(hr == WBEM_E_ACCESS_DENIED)  // keep going - might have access to others
            {
                hr = WBEM_S_NO_ERROR;
            }
        }while((FindNextFileW(hFind, &stFindData)) && (SUCCEEDED(hr)));

    }
#endif
#ifdef WIN9XONLY
    {
        // we're on 9x
        WIN32_FIND_DATA stFindData;
        ZeroMemory(&stFindData,sizeof(stFindData));

        SmartFindClose hFind;

        CHString chstrSearchString;
        CHString chstrDriveAndPath(chstrQuery);

        chstrSearchString.Format(L"%s*.*",chstrQuery);

        hFind = FindFirstFile(TOBSTRT(chstrSearchString), &stFindData);
        DWORD dw = GetLastError();
        if (hFind == INVALID_HANDLE_VALUE || dw != ERROR_SUCCESS)
        {
            hr = WinErrorToWBEMhResult(GetLastError());
        }

        if(hr == WBEM_E_ACCESS_DENIED)  // keep going - might have access to others
        {
            hr = WBEM_S_NO_ERROR;
        }

        do
        {
            if(!(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
               (_tcscmp(stFindData.cFileName, _T(".")) != 0) &&
               (_tcscmp(stFindData.cFileName, _T("..")) != 0))
            {
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                CHString chstrName;
                chstrName.Format(L"%s\\%s", (LPCWSTR)chstrUserAccount, (LPCWSTR) TOBSTRT(stFindData.cFileName));
                pInstance->SetCHString(IDS_Name, chstrName);

                // we know we are not on NTFS, so...
                WBEMTime wbt(stFindData.ftCreationTime);
                BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                {
                    pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                    SysFreeString(bstrRealTime);
                }

                CHString chstrTmp2;
                chstrTmp2.Format(L"Logical program group item \'%s\'", (LPCWSTR) chstrName);
                pInstance->SetCHString(L"Description" , chstrTmp2) ;
                pInstance->SetCHString(L"Caption" , chstrTmp2) ;

                hr = pInstance->Commit();
            }
            if(hr == WBEM_E_ACCESS_DENIED)  // keep going - might have access to others
            {
                hr = WBEM_S_NO_ERROR;
            }
        }while((FindNextFile(hFind, &stFindData)) && (SUCCEEDED(hr)));

    }
#endif
    return(hr);
}

/*****************************************************************************
 *
 *  FUNCTION    : RemoveDoubleBackslashes
 *
 *  DESCRIPTION : Helper to change double backslashes to single backslashes
 *
 *  INPUTS      : CHString& containing the string with double backslashes,
 *                which will be changed by this function to the new string.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

VOID CWin32LogProgramGroupItem :: RemoveDoubleBackslashes ( CHString &chstrIn )
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;

    BOOL fDone = FALSE;
    while ( ! fDone )
    {


	    LONG lPos = chstrInCopy.Find(L"\\\\");
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += L"\\";

            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }

    chstrIn = chstrBuildString;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogProgramGroupItem::SetCreationDate
 *
 *  DESCRIPTION : Sets the CreationDate property
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32LogProgramGroupItem::SetCreationDate
(
    CHString &a_chstrPGIName,
    CHString &a_chstrUserName,
    CInstance *a_pInstance,
    bool fOnNTFS
)
{
	HRESULT t_hr = WBEM_S_NO_ERROR;
	CHString t_chstrUserNameUpr(a_chstrUserName);
	t_chstrUserNameUpr.MakeUpper();
    CHString t_chstrStartMenuFullPath;
    CHString t_chstrPGIFullPath;
	CHString t_chstrDefaultUserName;
	CHString t_chstrAllUsersName;
	CHString t_chstrProfilesDir;
	CHString t_chstrTemp;

#ifdef WIN9XONLY
    CRegistry t_RegInfo;
	DWORD t_dwRet = t_RegInfo.OpenCurrentUser(
                               L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                               KEY_READ);

    if(t_dwRet == ERROR_SUCCESS)
    {
		t_RegInfo.GetCurrentKeyValue(L"Start Menu" ,t_chstrStartMenuFullPath);
        t_RegInfo.Close();
    }
    // Trim off the part that says "\\Start Menu"... (or whatever the user may have changed it to...)
    t_chstrStartMenuFullPath = t_chstrStartMenuFullPath.Left(t_chstrStartMenuFullPath.ReverseFind(L'\\'));
	t_chstrPGIFullPath.Format(L"%s\\%s",(LPCWSTR) t_chstrStartMenuFullPath, (LPCWSTR) a_chstrPGIName);
#endif


#ifdef NTONLY
	bool t_fGotMatchedUser = false;
	CRegistry t_RegInfo;
	TCHAR t_tstrProfileImagePath[_MAX_PATH];
	ZeroMemory(t_tstrProfileImagePath , sizeof(t_tstrProfileImagePath));


#if NTONLY >= 5
    // Default user doesn't show up under profiles
	DWORD t_dwRet = t_RegInfo.Open(HKEY_LOCAL_MACHINE,
								   _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),
								   KEY_READ);

    if(t_dwRet == ERROR_SUCCESS)
    {
        t_RegInfo.GetCurrentKeyValue( _T("DefaultUserProfile") , t_chstrDefaultUserName);
		t_chstrDefaultUserName.MakeUpper();
		if(t_chstrUserNameUpr.Find(t_chstrDefaultUserName) != -1)
		{
			t_fGotMatchedUser = true;

			if(t_RegInfo.GetCurrentKeyValue ( _T("ProfilesDirectory") , t_chstrTemp) == ERROR_SUCCESS)
			{
				// chstrTemp contains something like "%SystemRoot\Profiles%".  Need to expand the environment variable...


				t_dwRet = ExpandEnvironmentStrings( t_chstrTemp , t_tstrProfileImagePath , _MAX_PATH );
				if ( t_dwRet != 0 && t_dwRet < _MAX_PATH )
				{
					t_chstrPGIFullPath.Format(_T("%s\\%s\\%s"),
										     t_tstrProfileImagePath,
											 (LPCTSTR)t_chstrDefaultUserName,
											 (LPCTSTR)a_chstrPGIName);
				}
			}
		}
		t_RegInfo.Close();
    }
	else
	{
		if(t_dwRet == ERROR_ACCESS_DENIED)
        {
			t_hr = WBEM_E_ACCESS_DENIED;
        }
	}
#endif
#if NTONLY == 4
    // NT 4 just has to be different...
    DWORD t_dwRet = t_RegInfo.Open(HKEY_USERS,
					               _T(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
					               KEY_READ);

    if(t_dwRet == ERROR_SUCCESS)
    {
        CHString t_chstrProfileImagePath;
		if(t_RegInfo.GetCurrentKeyValue(_T("Programs"), t_chstrProfileImagePath) == ERROR_SUCCESS)
        {
            // sTemp looks like c:\\winnt\\profiles\\default user\\start menu\\programs.
            // Don't want the programs dir on the end, so hack it off...
            int t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
            if(t_iLastWhackPos > -1)
            {
                t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
                // We also don't want the "start menu" on the end, so hack it off too...
                t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
                if(t_iLastWhackPos > -1)
                {
                    t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
                    // We also want to extract the name of the "Default User" directory...
                    t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
                    if(t_iLastWhackPos > -1)
                    {
                        t_chstrDefaultUserName = t_chstrProfileImagePath.Right(t_chstrProfileImagePath.GetLength() - t_iLastWhackPos -1);
						t_chstrDefaultUserName.MakeUpper();
						if(t_chstrUserNameUpr.Find(t_chstrDefaultUserName) != -1)
						{
							t_fGotMatchedUser = true;
							t_chstrPGIFullPath.Format(_T("%s\\%s"),
													 t_chstrProfileImagePath,
													 (LPCTSTR)a_chstrPGIName);
						}
                    }
                }
            }
        }
		t_RegInfo.Close();
    }
	else
	{
		if ( t_dwRet == ERROR_ACCESS_DENIED )
        {
			t_hr = WBEM_E_ACCESS_DENIED ;
        }
	}
#endif

    if(!t_fGotMatchedUser)
	{
		// Neither does All Users.  The following works for all users for both nt 4 and 5.
		DWORD t_dwRet = t_RegInfo.Open(HKEY_LOCAL_MACHINE,
									   _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
									   KEY_READ);

		if(t_dwRet == ERROR_SUCCESS)
		{
			CHString t_chstrProfileImagePath;
			if(t_RegInfo.GetCurrentKeyValue(_T("Common Programs"), t_chstrProfileImagePath) == ERROR_SUCCESS)
			{
				// we do want to start in the Start Menu subdir, not the Programs dir under it
				int t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
				if(t_iLastWhackPos > -1)
				{
					t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
					// We also don't want the "start menu" on the end, so hack it off too...
                    t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
                    if(t_iLastWhackPos > -1)
                    {
                        t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
					    // We also want to extract the name of the "All Users" directory...
					    t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
					    if(t_iLastWhackPos > -1)
					    {
							t_chstrAllUsersName = t_chstrProfileImagePath.Right(t_chstrProfileImagePath.GetLength() - t_iLastWhackPos -1);
							t_chstrAllUsersName.MakeUpper();
							if(t_chstrUserNameUpr.Find(t_chstrAllUsersName) != -1)
							{
								t_fGotMatchedUser = true;
								t_chstrPGIFullPath.Format(_T("%s\\%s"),
														 t_chstrProfileImagePath,
														 (LPCTSTR)a_chstrPGIName);
							}
					    }
                    }
				}
			}
			t_RegInfo.Close();
		}
		else
		{
			if ( t_dwRet == ERROR_ACCESS_DENIED )
			{
				t_hr = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

	if(!t_fGotMatchedUser)
	{
		// Now walk the registry looking for the rest
		CRegistry t_regProfileList;
		DWORD t_dwRet = t_regProfileList.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
																 IDS_RegNTProfileList,
																 KEY_READ);

		if(t_dwRet == ERROR_SUCCESS)
		{
			CUserHive t_UserHive ;
			CHString t_chstrProfile, t_chstrUserName, t_chstrKeyName2;

			for(int i = 0; t_regProfileList.GetCurrentSubKeyName(t_chstrProfile) == ERROR_SUCCESS && !t_fGotMatchedUser; i++)
			{
				// Try to load the hive.  If the user has been deleted, but the directory
				// is still there, this will return ERROR_NO_SUCH_USER
				if(t_UserHive.LoadProfile(t_chstrProfile, t_chstrUserName) == ERROR_SUCCESS && 
                            t_chstrUserName.GetLength() > 0 )
				{
					try
					{
					    t_chstrUserName.MakeUpper();
					    if(t_chstrUserNameUpr.Find(t_chstrUserName) != -1)
					    {
						    t_fGotMatchedUser = true;
							t_chstrKeyName2 = t_chstrProfile + _T("\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");

							if(t_RegInfo.Open(HKEY_USERS, t_chstrKeyName2, KEY_READ) == ERROR_SUCCESS)
							{
								if(t_RegInfo.GetCurrentKeyValue(_T("Programs"), t_chstrTemp) == ERROR_SUCCESS)
								{
									// wack off the "Programs" directory...
									int t_iLastWhackPos = t_chstrTemp.ReverseFind(_T('\\'));
									if(t_iLastWhackPos > -1)
									{
										t_chstrTemp = t_chstrTemp.Left(t_iLastWhackPos);
                                        // wack off the "start menu" part too...
                                        t_iLastWhackPos = t_chstrTemp.ReverseFind(_T('\\'));
									    if(t_iLastWhackPos > -1)
									    {
										    t_chstrTemp = t_chstrTemp.Left(t_iLastWhackPos);
										    t_chstrPGIFullPath.Format(_T("%s\\%s"),
														     t_chstrTemp,
														     (LPCTSTR)a_chstrPGIName);
                                        }
									}
								}
								t_RegInfo.Close();
							}
    					}
					}
					catch ( ... )
					{
						t_UserHive.Unload(t_chstrProfile) ;
						throw ;
					}
					t_UserHive.Unload(t_chstrProfile) ;
				}
				t_regProfileList.NextSubKey();
			}
			t_regProfileList.Close();
		}
		else
		{
			if ( t_dwRet == ERROR_ACCESS_DENIED )
			{
				t_hr = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

#endif

	// Finally we can start the real work.  Check that we have the full path
	// to the element...
	if(t_chstrPGIFullPath.GetLength() > 0)
	{
		// We have a path.  Open it up and get the creation date...
#ifdef NTONLY
		WIN32_FIND_DATAW t_stFindData;
        SmartFindClose t_hFind = FindFirstFileW(TOBSTRT(t_chstrPGIFullPath), &t_stFindData) ;
#endif
#ifdef WIN9XONLY
		WIN32_FIND_DATA t_stFindData;
        SmartFindClose t_hFind = FindFirstFile(TOBSTRT(t_chstrPGIFullPath), &t_stFindData) ;
#endif

        DWORD t_dw = GetLastError();
        if (t_hFind == INVALID_HANDLE_VALUE || t_dw != ERROR_SUCCESS)
        {
            t_hr = WinErrorToWBEMhResult(GetLastError());
        }
		else
		{
			// How we set it depends on whether we are on NTFS or not.
            if(fOnNTFS)
            {
                a_pInstance->SetDateTime(IDS_InstallDate, WBEMTime(t_stFindData.ftCreationTime));
            }
            else
            {
                WBEMTime wbt(t_stFindData.ftCreationTime);
                BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                {
                    a_pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                    SysFreeString(bstrRealTime);
                }
            }
		}
    }

    return t_hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalshareaccess.cpp ===
//=================================================================

//

// LogicalShareAccess.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "secureshare.h"
#include "logicalshareaccess.h"


CWin32LogicalShareAccess LogicalShareAccess( LOGICAL_SHARE_ACCESS_NAME, IDS_CimWin32Namespace );

//const LPCTSTR IDS_SecuritySetting		=	"SecuritySetting" ;
//const LPCTSTR IDS_BinaryRepresentation	=	"BinaryRepresentation" ;

/*

    [Dynamic, Provider, Association: ToInstance]
class Win32_LogicalShareAccess : Win32_SecuritySettingAccess
{
    Win32_LogicalShareSecuritySetting ref SecuritySetting;

    Win32_SID ref Trustee;
};

*/

CWin32LogicalShareAccess::CWin32LogicalShareAccess(LPCWSTR setName, LPCWSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalShareAccess::~CWin32LogicalShareAccess()
{
}

HRESULT CWin32LogicalShareAccess::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
	if (pInstance)
	{
		CInstancePtr pLogicalShareSecurityInstance  , pTrustee ;

		// get instance by path on CIM_LogicalFile part
		CHString chsTrusteePath,chsSecuritySettingPath;

		pInstance->GetCHString(IDS_Trustee, chsTrusteePath);
		pInstance->GetCHString(IDS_SecuritySetting, chsSecuritySettingPath);


		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsSecuritySettingPath, &pLogicalShareSecurityInstance, pMethodContext) ) )
		{
			if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsTrusteePath, &pTrustee, pMethodContext) ) )
			{

				CHString chsShareName ;
				pLogicalShareSecurityInstance->GetCHString(IDS_Name,chsShareName) ;

				CSecureShare secShare(chsShareName);
				CDACL dacl;
				secShare.GetDACL(dacl);

				// walk DACL looking for the sid path passed in....
				ACLPOSITION aclPos;
                // Need merged list...
                CAccessEntryList t_ael;
                if(dacl.GetMergedACL(t_ael))
                {
				    t_ael.BeginEnum(aclPos);
				    CAccessEntry ACE;
				    CSid sidTrustee;

				    while (t_ael.GetNext(aclPos, ACE ))
				    {
					    ACE.GetSID(sidTrustee);
					    //CHString chsTrustee = sidTrustee.GetSidString();
					    CHString chsPath;

					    CInstancePtr pSID ;

			  		    if (SUCCEEDED(GetEmptyInstanceHelper(_T("Win32_SID"), &pSID, pInstance->GetMethodContext() ) ) )
					    {
						    FillSidInstance( pSID, sidTrustee);
						    GetLocalInstancePath(pSID,chsPath) ;

						    if (0 == chsTrusteePath.CompareNoCase(chsPath))
						    {
							    hr = WBEM_S_NO_ERROR;
							    FillProperties(pInstance, ACE) ;
							    break ;
						    }

					    }
				    }//while

				    t_ael.EndEnum(aclPos);
                }
			}

		}
	}
#endif

	return(hr);
}


HRESULT CWin32LogicalShareAccess::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
	TRefPointerCollection<CInstance> SecuritySettingsList;

	hr = CWbemProviderGlue::GetAllInstances(_T("Win32_LogicalShareSecuritySetting"),
											&SecuritySettingsList,
											NULL,
											pMethodContext) ;

	if( SUCCEEDED(hr) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		if( SecuritySettingsList.BeginEnum(pos) )
		{

			CInstancePtr pSetting  ;
			CHString chsShareName ;
			for (	pSetting.Attach ( SecuritySettingsList.GetNext ( pos ) ) ;
					( pSetting != NULL ) && SUCCEEDED ( hr ) ;
					pSetting.Attach ( SecuritySettingsList.GetNext ( pos ) )
				)
			{

				pSetting->GetCHString(IDS_Name, chsShareName);
				CSecureShare secShare(chsShareName);
				CDACL dacl;
				secShare.GetDACL(dacl);

				// walk DACL & create new instance for each ACE....
				ACLPOSITION aclPos;
                // Need merged list...
                CAccessEntryList t_ael;
                if(dacl.GetMergedACL(t_ael))
                {
				    t_ael.BeginEnum(aclPos);
				    CAccessEntry ACE;
				    CSid sidTrustee;

				    while (t_ael.GetNext(aclPos, ACE ) && SUCCEEDED(hr))
				    {
					    ACE.GetSID(sidTrustee);
					    CHString chsPath;
					    CHString chsSettingPath ;
					    CInstancePtr pSID ;

			  		    if (SUCCEEDED(GetEmptyInstanceHelper(_T("Win32_SID"), &pSID, pMethodContext ) ) )
					    {
						    FillSidInstance( pSID, sidTrustee);
						    GetLocalInstancePath(pSID,chsPath) ;

						    GetLocalInstancePath(pSetting,chsSettingPath) ;
						    CInstancePtr pInstance ( CreateNewInstance( pMethodContext ), false ) ;
                            if ( pInstance != NULL )
                            {
						        pInstance->SetCHString(IDS_SecuritySetting, chsSettingPath) ;
						        pInstance->SetCHString(IDS_Trustee, chsPath) ;
						        FillProperties(pInstance, ACE) ;

						        hr = pInstance->Commit () ;
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
					    }
				    }

				    t_ael.EndEnum(aclPos);
                }
			} //while

			SecuritySettingsList.EndEnum() ;
		}
	} //if( SUCCEEDED(hr) )
#endif

return hr ;

}


HRESULT CWin32LogicalShareAccess::FillSidInstance(CInstance* pInstance, CSid& sid)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY
	if (sid.IsValid())
	{
		//set the key
		CHString chsSid = sid.GetSidString() ;
		pInstance->SetCHString(IDS_SID, chsSid) ;

		// get account name
		CHString chsAccount = sid.GetAccountName();
		pInstance->SetCHString(IDS_AccountName, chsAccount);

		// get domain name
		CHString chsDomain = sid.GetDomainName();
		pInstance->SetCHString(IDS_ReferencedDomainName, chsDomain);

		PSID pSid = sid.GetPSid();

		// set the UINT8 array for the pSid
		DWORD dwSidLength = sid.GetLength();
//			BYTE bByte;

		SAFEARRAYBOUND rgsabound[1];
		rgsabound[0].cElements = dwSidLength;
		rgsabound[0].lLbound = 0;

		variant_t vValue;
		void* pVoid = NULL ;

        V_ARRAY(&vValue) = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if ( V_ARRAY ( &vValue ) == NULL )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		V_VT(&vValue) = VT_UI1 | VT_ARRAY;

		// Get a pointer to read the data into
  		SafeArrayAccessData ( V_ARRAY ( &vValue ), &pVoid ) ;
  		memcpy ( pVoid, pSid, rgsabound[0].cElements ) ;
  		SafeArrayUnaccessData ( V_ARRAY ( &vValue ) ) ;

		// Put the safearray into a variant, and send it off
		pInstance->SetVariant(IDS_BinaryRepresentation, vValue);
		CHString chsPath ;
		GetLocalInstancePath(pInstance,chsPath) ;
	}	// end if
#endif
	return(hr);
}

#ifdef NTONLY
HRESULT CWin32LogicalShareAccess::GetEmptyInstanceHelper(CHString chsClassName, CInstance **ppInstance, MethodContext* pMethodContext )
{
 	CHString chsServer ;
	CHString chsPath ;
	HRESULT hr = S_OK ;

	chsServer = GetLocalComputerName() ;

	chsPath = _T("\\\\") + chsServer + _T("\\") + IDS_CimWin32Namespace + _T(":") + chsClassName ;

	CInstancePtr  pClassInstance ;
	if(SUCCEEDED( hr = CWbemProviderGlue::GetInstanceByPath(chsPath, &pClassInstance, pMethodContext) ) )
	{
		IWbemClassObjectPtr pClassObject ( pClassInstance->GetClassObjectInterface(), false ) ;

		IWbemClassObjectPtr piClone = NULL ;
		if(SUCCEEDED(hr = pClassObject->SpawnInstance(0, &piClone) ) )
		{
			*ppInstance = new CInstance ( piClone, pMethodContext ) ;
		}
	}

	return hr ;
}
#endif


#ifdef NTONLY
HRESULT CWin32LogicalShareAccess::FillProperties(CInstance* pInstance, CAccessEntry& ACE )
{

	pInstance->SetDWORD(IDS_AccessMask, ACE.GetAccessMask() ) ;
	pInstance->SetDWORD(IDS_Inheritance, (DWORD) ACE.GetACEFlags() ) ;
	pInstance->SetDWORD(IDS_Type, (DWORD) ACE.GetACEType() ) ;

	return S_OK ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalshareaudit.cpp ===
//=================================================================

//

// LogicalShareAudit.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "secureshare.h"
#include "logicalshareaudit.h"

CWin32LogicalShareAudit LogicalShareAudit( LOGICAL_SHARE_AUDIT_NAME, IDS_CimWin32Namespace );

//const LPCWSTR IDS_SecuritySetting		=	"SecuritySetting" ;
//const LPCWSTR IDS_BinaryRepresentation	=	"BinaryRepresentation" ;

/*

    [Dynamic, Provider("cimwin33"), Association: ToInstance]
class Win32_LogicalShareAuditing : Win32_SecuritySettingAuditing
{
    Win32_LogicalShareSecuritySetting ref SecuritySetting;

    Win32_SID ref Trustee;
};

*/

CWin32LogicalShareAudit::CWin32LogicalShareAudit(LPCWSTR setName, LPCWSTR pszNameSpace /*=NULL*/)
:	Provider( setName, pszNameSpace )
{
}

CWin32LogicalShareAudit::~CWin32LogicalShareAudit()
{
}

HRESULT CWin32LogicalShareAudit::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
	if (pInstance)
	{
		CInstancePtr pLogicalShareSecurityInstance  , pTrustee ;

		// get instance by path on CIM_LogicalFile part
		CHString chsTrusteePath,chsSecuritySettingPath;

		pInstance->GetCHString(IDS_Trustee, chsTrusteePath);
		pInstance->GetCHString(IDS_SecuritySetting, chsSecuritySettingPath);


		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsSecuritySettingPath, &pLogicalShareSecurityInstance, pMethodContext) ) )
		{
			if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsTrusteePath, &pTrustee, pMethodContext) ) )
			{

				CHString chsShareName ;
				pLogicalShareSecurityInstance->GetCHString(IDS_Name,chsShareName) ;

				CSecureShare secShare(chsShareName);
				CSACL sacl;
				secShare.GetSACL(sacl);

				// walk DACL looking for the sid path passed in....
				ACLPOSITION aclPos;
                // Need merged list...
                CAccessEntryList t_ael;
                if(sacl.GetMergedACL(t_ael))
                {
				    t_ael.BeginEnum(aclPos);
				    CAccessEntry ACE;
				    CSid sidTrustee;

				    while (t_ael.GetNext(aclPos, ACE ))
				    {
					    ACE.GetSID(sidTrustee);
					    //CHString chsTrustee = sidTrustee.GetSidString();
					    CHString chsPath;

					    CInstancePtr pSID ;

			  		    if (SUCCEEDED(GetEmptyInstanceHelper(L"Win32_SID", &pSID, pInstance->GetMethodContext() ) ) )
					    {
						    FillSidInstance( pSID, sidTrustee);
						    GetLocalInstancePath(pSID,chsPath) ;

						    if (0 == chsTrusteePath.CompareNoCase(chsPath))
						    {
							    hr = WBEM_S_NO_ERROR;
							    FillProperties(pInstance, ACE) ;
							    break ;
						    }

					    }
				    }//while

				    t_ael.EndEnum(aclPos);
                }
			}

		}
	}
#endif

	return(hr);
}


HRESULT CWin32LogicalShareAudit::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
	TRefPointerCollection<CInstance> SecuritySettingsList;

	hr = CWbemProviderGlue::GetAllInstances(_T("Win32_LogicalShareSecuritySetting"),
											&SecuritySettingsList,
											NULL,
											pMethodContext) ;

	if( SUCCEEDED(hr) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		if( SecuritySettingsList.BeginEnum(pos) )
		{

			CInstancePtr pSetting ;
			CHString chsShareName ;
			for (	pSetting.Attach ( SecuritySettingsList.GetNext(pos) ) ;
					( pSetting != NULL ) && SUCCEEDED(hr) ;
					pSetting.Attach ( SecuritySettingsList.GetNext(pos) )
				)
			{

				pSetting->GetCHString(IDS_Name, chsShareName);
				CSecureShare secShare(chsShareName);
				CSACL sacl;
				secShare.GetSACL(sacl);

				// walk DACL & create new instance for each ACE....
				ACLPOSITION aclPos;
                // Need merged list...
                CAccessEntryList t_ael;
                if(sacl.GetMergedACL(t_ael))
                {
				    t_ael.BeginEnum(aclPos);
				    CAccessEntry ACE;
				    CSid sidTrustee;

				    while (t_ael.GetNext(aclPos, ACE ) && SUCCEEDED(hr))
				    {
					    ACE.GetSID(sidTrustee);
					    CHString chsPath;
					    CHString chsSettingPath ;
					    CInstancePtr pSID ;

			  		    if (SUCCEEDED(GetEmptyInstanceHelper(_T("Win32_SID"), &pSID, pMethodContext ) ) )
					    {
						    FillSidInstance( pSID, sidTrustee);
						    GetLocalInstancePath(pSID,chsPath) ;

						    GetLocalInstancePath(pSetting,chsSettingPath) ;
						    CInstancePtr pInstance ( CreateNewInstance( pMethodContext ), false ) ;
                            if(pInstance != NULL)
                            {
						        pInstance->SetCHString(IDS_SecuritySetting, chsSettingPath) ;
						        pInstance->SetCHString(IDS_Trustee, chsPath) ;

						        FillProperties(pInstance, ACE) ;
						        hr = pInstance->Commit () ;
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }

					    }
				    }

				    t_ael.EndEnum(aclPos);
                }
			} //while

			SecuritySettingsList.EndEnum() ;
		}
	} //if( SUCCEEDED(hr) )
#endif

return hr ;

}


#ifdef NTONLY
HRESULT CWin32LogicalShareAudit::FillSidInstance(CInstance* pInstance, CSid& sid)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	if (sid.IsValid())
	{
		//set the key
		CHString chsSid = sid.GetSidString() ;
		pInstance->SetCHString(IDS_SID, chsSid) ;

		// get account name
		CHString chsAccount = sid.GetAccountName();
		pInstance->SetCHString(IDS_AccountName, chsAccount);

		// get domain name
		CHString chsDomain = sid.GetDomainName();
		pInstance->SetCHString(IDS_ReferencedDomainName, chsDomain);

		PSID pSid = sid.GetPSid();

		// set the UINT8 array for the pSid
		DWORD dwSidLength = sid.GetLength();
//			BYTE bByte;
		SAFEARRAYBOUND rgsabound[1];
		rgsabound[0].cElements = dwSidLength;
		rgsabound[0].lLbound = 0;

		variant_t vValue;
		void* pVoid = NULL ;


		V_ARRAY(&vValue) = SafeArrayCreate(VT_UI1, 1, rgsabound);
		if ( V_ARRAY ( &vValue ) == NULL )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		V_VT(&vValue) = VT_UI1 | VT_ARRAY;

		     // Get a pointer to read the data into
  		SafeArrayAccessData ( V_ARRAY ( &vValue ), &pVoid ) ;
  		memcpy(pVoid, pSid, rgsabound[0].cElements);
  		SafeArrayUnaccessData ( V_ARRAY ( &vValue ) ) ;

		// Put the safearray into a variant, and send it off
		pInstance->SetVariant(IDS_BinaryRepresentation, vValue);
		CHString chsPath ;
		GetLocalInstancePath(pInstance,chsPath) ;
	}	// end if
	return(hr);
}
#endif

#ifdef NTONLY
HRESULT CWin32LogicalShareAudit::GetEmptyInstanceHelper(CHString chsClassName, CInstance**ppInstance, MethodContext* pMethodContext )
{
	CHString chsServer ;
	CHString chsPath ;
	HRESULT hr = S_OK ;

	chsServer = GetLocalComputerName() ;

	chsPath = _T("\\\\") + chsServer + _T("\\") + IDS_CimWin32Namespace + _T(":") + chsClassName ;

	CInstancePtr pClassInstance ;
	if(SUCCEEDED( hr = CWbemProviderGlue::GetInstanceByPath(chsPath, &pClassInstance, pMethodContext) ) )
	{
		IWbemClassObjectPtr pClassObject( pClassInstance->GetClassObjectInterface(), false ) ;

		IWbemClassObjectPtr piClone = NULL ;
		if(SUCCEEDED(hr = pClassObject->SpawnInstance(0, &piClone) ) )
		{
			*ppInstance = new CInstance(piClone, pMethodContext ) ;
		}
	}

	return hr ;
}
#endif

#ifdef NTONLY
HRESULT CWin32LogicalShareAudit::FillProperties(CInstance* pInstance, CAccessEntry& ACE )
{

	pInstance->SetDWORD(IDS_AccessMask, ACE.GetAccessMask() ) ;
	pInstance->SetDWORD(IDS_Inheritance, (DWORD) ACE.GetACEFlags() ) ;
	pInstance->SetDWORD(IDS_Type, (DWORD) ACE.GetACEType() ) ;

	return S_OK ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalprogramgroup.h ===
//=================================================================

//

// LogicalProgramGroup.h -- Logical Program group property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/19/98 a-kevhu created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_LOGICALPRGGROUP   L"Win32_LogicalProgramGroup"           


class CWin32LogicalProgramGroup : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32LogicalProgramGroup(LPCWSTR name, LPCWSTR pszNameSpace);
       ~CWin32LogicalProgramGroup() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);



    private:
        // Utility function(s)
        //====================

        HRESULT CreateSubDirInstances(LPCTSTR pszUserName,
                                      LPCTSTR pszBaseDirectory,
                                      LPCTSTR pszParentDirectory,
                                      MethodContext* pMethodContext,
                                      bool fOnNTFS) ;

        HRESULT CreateThisDirInstance 
        (
	        LPCTSTR pszUserName,
            LPCTSTR pszBaseDirectory,
            MethodContext *pMethodContext,
            bool fOnNTFS
        );

        HRESULT EnumerateGroupsTheHardWay(MethodContext* pMethodContext) ;

        HRESULT InstanceHardWayGroups(LPCWSTR pszUserName, 
                                      LPCWSTR pszRegistryKeyName,
                                      MethodContext* pMethodContext) ;

        HRESULT SetCreationDate
        (
            CHString &a_chsPGName, 
            CHString &a_chsUserName,
            CInstance *a_pInstance,
            bool fOnNTFS
        );
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalprogramgroup.cpp ===
//=================================================================

//

// LogicalProgramGroup.CPP -- Logical Program group property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/19/98  a-kevhu created
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>

#include "UserHive.h"
#include <io.h>

#include "LogicalProgramGroup.h"
#include "wbemnetapi32.h"
#include "user.h"

// Property set declaration
//=========================
CWin32LogicalProgramGroup MyCWin32LogicalProgramGroupSet ( PROPSET_NAME_LOGICALPRGGROUP , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::CWin32LogicalProgramGroup
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LogicalProgramGroup :: CWin32LogicalProgramGroup (

	LPCWSTR name,
	LPCWSTR pszNameSpace

) : Provider ( name , pszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::~CWin32LogicalProgramGroup
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LogicalProgramGroup :: ~CWin32LogicalProgramGroup ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogicalProgramGroup :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	TRefPointerCollection<CInstance> Groups;


	HRESULT	hr = CWbemProviderGlue :: GetAllInstances (

		PROPSET_NAME_LOGICALPRGGROUP,
		&Groups,
		IDS_CimWin32Namespace,
		pInstance->GetMethodContext ()
	) ;

	if ( SUCCEEDED (hr ) )
	{
		REFPTRCOLLECTION_POSITION pos;

		CInstancePtr pProgramGroupInstance;
		if ( Groups.BeginEnum ( pos ) )
		{
            hr = WBEM_E_NOT_FOUND;

			CHString Name;
			pInstance->GetCHString( IDS_Name , Name);

            // We're going to need to know whether the file system of the drive
            // on which the start menu folder resides is ntfs or not so that
            // we can accurately report the installtime property.
            bool fOnNTFS;
#ifdef WIN9XONLY
            fOnNTFS = false;
#endif
#ifdef NTONLY
            fOnNTFS = true;
            TCHAR tstrRoot[4] = _T("");
            TCHAR tstrFSName[_MAX_PATH] = _T("");
            TCHAR tstrWindowsDir[_MAX_PATH];
            if(GetWindowsDirectory(tstrWindowsDir, sizeof(tstrWindowsDir)/sizeof(TCHAR)))
            {
                _tcsncpy(tstrRoot, tstrWindowsDir, 3);
                GetVolumeInformation(tstrRoot, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                if(tstrFSName != NULL && _tcslen(tstrFSName) > 0)
                {
                    if(_tcsicmp(tstrFSName,_T("FAT")) == 0 || _tcsicmp(tstrFSName,_T("FAT32")) == 0)
                    {
                        fOnNTFS = false;
                    }
                }
            }
#endif


            for (pProgramGroupInstance.Attach(Groups.GetNext( pos ));
                 pProgramGroupInstance != NULL;
                 pProgramGroupInstance.Attach(Groups.GetNext( pos )))
			{
				CHString chsCompName ;

				pProgramGroupInstance->GetCHString ( IDS_Name , chsCompName ) ;

				if ( chsCompName.CompareNoCase ( Name ) == 0 )
				{
                    // Parse out the user name

					CHString chsUserName = chsCompName.SpanExcluding ( L":" ) ;
			    	pInstance->SetCHString ( IDS_UserName, chsUserName ) ;

                    // Parse out the group
					int nUserLength = ( chsUserName.GetLength () + 1 ) ;
					int nGroupLength = chsCompName.GetLength() - nUserLength ;

					CHString chsGroupName = chsCompName.Right ( nGroupLength ) ;
					pInstance->SetCHString ( IDS_GroupName, chsGroupName ) ;


                    SetCreationDate(chsGroupName, chsUserName, pInstance, fOnNTFS);

                    CHString chstrTmp2;
                    chstrTmp2.Format(L"Logical program group \"%s\"", (LPCWSTR) Name);
                    pInstance->SetCHString(L"Description" , chstrTmp2) ;
                    pInstance->SetCHString(L"Caption" , chstrTmp2) ;

                    hr = WBEM_S_NO_ERROR ;

                    break;
				}

			}	// WHILE GetNext

			Groups.EndEnum() ;

		}	// IF BeginEnum

	}

	return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogicalProgramGroup :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_FAILED;

    CHString sTemp;

    TCHAR szWindowsDir[_MAX_PATH];
    if ( GetWindowsDirectory ( szWindowsDir , sizeof ( szWindowsDir ) / sizeof(TCHAR)) )
    {
		CRegistry RegInfo ;

        // We're going to need to know whether the file system of the drive
        // on which the start menu folder resides is ntfs or not so that
        // we can accurately report the installtime property.
        bool fOnNTFS;
#ifdef WIN9XONLY
        fOnNTFS = false;
#endif
#ifdef NTONLY
        fOnNTFS = true;
        TCHAR tstrRoot[4] = _T("");
        TCHAR tstrFSName[_MAX_PATH] = _T("");
        _tcsncpy(tstrRoot, szWindowsDir, 3);
        GetVolumeInformation(tstrRoot, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
        if(tstrFSName != NULL && _tcslen(tstrFSName) > 0)
        {
            if(_tcsicmp(tstrFSName,_T("FAT")) == 0 || _tcsicmp(tstrFSName,_T("FAT32")) == 0)
            {
                fOnNTFS = false;
            }
        }
#endif


#ifdef WIN9XONLY
        {

            DWORD dwRet = RegInfo.OpenCurrentUser (

                L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                KEY_READ
			) ;

            if ( dwRet == ERROR_SUCCESS )
            {
				if ( RegInfo.GetCurrentKeyValue ( L"Start Menu" , sTemp ) == ERROR_SUCCESS )
                {
                    hr = CreateThisDirInstance(_T("All Users"), TOBSTRT(sTemp), pMethodContext, fOnNTFS);

                    hr = CreateSubDirInstances (
						_T("All Users"),
						TOBSTRT(sTemp),
						_T("."),
						pMethodContext,
                        fOnNTFS
					) ;
                }

                RegInfo.Close () ;
            }
        }
#endif

#ifdef NTONLY
        {
            DWORD dwMajVer = GetPlatformMajorVersion();
            if ( dwMajVer < 4 )
            {
                hr = EnumerateGroupsTheHardWay ( pMethodContext ) ;
            }
            else
            {
                if(dwMajVer >= 5)
                {
                    // Default user doesn't show up under profiles
				    DWORD dwRet = RegInfo.Open (

					    HKEY_LOCAL_MACHINE,
					    _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),
					    KEY_READ
				    ) ;

                    if ( dwRet == ERROR_SUCCESS )
                    {
                        if ( RegInfo.GetCurrentKeyValue ( _T("DefaultUserProfile") , sTemp ) == ERROR_SUCCESS )
                        {
                            CHString sTemp2 ;
                            if ( RegInfo.GetCurrentKeyValue ( _T("ProfilesDirectory") , sTemp2 ) == ERROR_SUCCESS )
                            {
                                // sTemp2 contains something like "%SystemRoot\Profiles%".  Need to expand the environment variable...

                                TCHAR tstrProfileImagePath [ _MAX_PATH ] ;
                                ZeroMemory ( tstrProfileImagePath , sizeof ( tstrProfileImagePath ) ) ;

                                dwRet = ExpandEnvironmentStrings ( sTemp2 , tstrProfileImagePath , _MAX_PATH ) ;
                                if ( dwRet != 0 && dwRet < _MAX_PATH )
                                {
                                    CHString sTemp3 ;
                                    sTemp3.Format (

									    _T("%s\\%s\\%s"),
									    tstrProfileImagePath,
									    sTemp,
									    IDS_Start_Menu
								    ) ;
                                    hr = CreateThisDirInstance(sTemp, sTemp3, pMethodContext, fOnNTFS);
                                    hr = CreateSubDirInstances(

									    sTemp,
									    sTemp3,
									    _T("."),
									    pMethodContext,
                                        fOnNTFS
								    ) ;


                                }
                            }
                        }
						RegInfo.Close();
                    }
				    else
				    {
					    if ( dwRet == ERROR_ACCESS_DENIED )
                        {
						    hr = WBEM_E_ACCESS_DENIED ;
                        }
				    }
                }
                // NT 4 just has to be different...
                if(dwMajVer == 4)
                {
                    DWORD dwRet = RegInfo.Open(HKEY_USERS,
					                           _T(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
					                           KEY_READ);

                    if(dwRet == ERROR_SUCCESS)
                    {
                        if(RegInfo.GetCurrentKeyValue(_T("Programs"), sTemp) == ERROR_SUCCESS)
                        {
                            // sTemp looks like c:\\winnt\\profiles\\default user\\start menu\\programs.
                            // Don't want the programs dir on the end, so hack it off...
                            int iLastWhackPos = sTemp.ReverseFind(_T('\\'));
                            if(iLastWhackPos > -1)
                            {
                                sTemp = sTemp.Left(iLastWhackPos);
                                // We also want to extract the name of the "Default User" directory...
                                CHString sTemp2;
                                iLastWhackPos = sTemp.ReverseFind(_T('\\'));
                                if(iLastWhackPos > -1)
                                {
                                    sTemp2 = sTemp.Left(iLastWhackPos);
                                    iLastWhackPos = sTemp2.ReverseFind(_T('\\'));
                                    if(iLastWhackPos > -1)
                                    {
                                        sTemp2 = sTemp2.Right(sTemp2.GetLength() - iLastWhackPos -1);
                                        hr = CreateThisDirInstance(sTemp2, sTemp, pMethodContext, fOnNTFS);
                                        hr = CreateSubDirInstances(sTemp2,
							                                       sTemp,
							                                       _T("."),
							                                       pMethodContext,
                                                                   fOnNTFS);


                                    }
                                }
                            }
                        }
						RegInfo.Close();
                    }
				    else
				    {
					    if ( dwRet == ERROR_ACCESS_DENIED )
                        {
						    hr = WBEM_E_ACCESS_DENIED ;
                        }
				    }
                }


                // Neither does All Users.  The following works for all users for both nt 4 and 5.
				DWORD dwRet = RegInfo.Open (

					HKEY_LOCAL_MACHINE,
					_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
					KEY_READ
				) ;

                if ( dwRet == ERROR_SUCCESS )
                {
                    if ( RegInfo.GetCurrentKeyValue ( _T("Common Programs") , sTemp ) == ERROR_SUCCESS )
                    {
                        // we do want to start in the Start Menu subdir, not the Programs dir under it
                        int iLastWhackPos = sTemp.ReverseFind(_T('\\'));
                        if(iLastWhackPos > -1)
                        {
                            sTemp = sTemp.Left(iLastWhackPos);

							// We also want to extract the name of the "All Users" directory...
                            CHString sTemp2;
                            iLastWhackPos = sTemp.ReverseFind(_T('\\'));
                            if(iLastWhackPos > -1)
                            {
                                sTemp2 = sTemp.Left(iLastWhackPos);
                                iLastWhackPos = sTemp2.ReverseFind(_T('\\'));
                                if(iLastWhackPos > -1)
                                {
                                    sTemp2 = sTemp2.Right(sTemp2.GetLength() - iLastWhackPos -1);
									hr = CreateThisDirInstance(sTemp2, sTemp, pMethodContext, fOnNTFS);
                                    hr = CreateSubDirInstances(sTemp2,
															   sTemp,
															   _T("."),
															   pMethodContext,
                                                               fOnNTFS);


								}
							}
                        }
                    }
					RegInfo.Close();
                }
				else
				{
					if ( dwRet == ERROR_ACCESS_DENIED )
                    {
						hr = WBEM_E_ACCESS_DENIED ;
                    }
				}


                // Now walk the registry looking for the rest
                CRegistry regProfileList;
				dwRet = regProfileList.OpenAndEnumerateSubKeys (

					HKEY_LOCAL_MACHINE,
					IDS_RegNTProfileList,
					KEY_READ
				) ;

                if ( dwRet == ERROR_SUCCESS )
                {
                    CUserHive UserHive ;
                    CHString strProfile, strUserName, sKeyName2;

		            for ( int i = 0 ; regProfileList.GetCurrentSubKeyName ( strProfile ) == ERROR_SUCCESS ; i++ )
		            {
                        // Try to load the hive.  If the user has been deleted, but the directory
                        // is still there, this will return ERROR_NO_SUCH_USER

		                if ( UserHive.LoadProfile ( strProfile, strUserName ) == ERROR_SUCCESS && 
                            strUserName.GetLength() > 0 )
		                {
                            try
                            {
                                sKeyName2 = strProfile + _T("\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");

                                if(RegInfo.Open(HKEY_USERS, sKeyName2, KEY_READ) == ERROR_SUCCESS)
                                {
                                    if(RegInfo.GetCurrentKeyValue(_T("Programs"), sTemp) == ERROR_SUCCESS)
                                    {
                                        // wack off the "Programs" directory...
                                        int iLastWhackPos = sTemp.ReverseFind(_T('\\'));
                                        if(iLastWhackPos > -1)
                                        {
                                            sTemp = sTemp.Left(iLastWhackPos);
                                            hr = CreateThisDirInstance(strUserName, sTemp, pMethodContext, fOnNTFS);
                                            hr = CreateSubDirInstances(strUserName,
										                               sTemp,
										                               _T("."),
										                               pMethodContext,
                                                                       fOnNTFS);


                                        }
                                    }
                                    RegInfo.Close();
                                }
                            }
                            catch ( ... )
                            {
                                UserHive.Unload(strProfile) ;
                                throw ;
                            }

                            UserHive.Unload(strProfile) ;
                        }
			            regProfileList.NextSubKey();
		            }
		            regProfileList.Close();
                }
				else
				{
					if ( dwRet == ERROR_ACCESS_DENIED )
					{
						hr = WBEM_E_ACCESS_DENIED ;
					}
				}
            }
        }
#endif
    }

    return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::CreateSubDirInstances
 *
 *  DESCRIPTION : Creates instance of property set for each directory
 *                beneath the one passed in
 *
 *  INPUTS      : pszBaseDirectory    : Windows directory + "Profiles\<user>\Start Menu"
 *                pszParentDirectory  : Parent directory to enumerate
 *
 *  OUTPUTS     : pdwInstanceCount : incremented for each instance created
 *
 *  RETURNS     : Zip
 *
 *  COMMENTS    : Recursive descent thru profile directories
 *
 *****************************************************************************/

HRESULT CWin32LogicalProgramGroup :: CreateSubDirInstances (

	LPCTSTR pszUserName,
    LPCTSTR pszBaseDirectory,
    LPCTSTR pszParentDirectory,
    MethodContext *pMethodContext,
    bool fOnNTFS
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#if (defined(UNICODE) || defined(_UNICODE))
    WIN32_FIND_DATAW FindData ;
#else
    WIN32_FIND_DATA FindData ;
#endif

    // Put together search spec for this level
    //========================================

	TCHAR szDirSpec[_MAX_PATH] ;
    _stprintf(szDirSpec, _T("%s\\%s\\*.*"), pszBaseDirectory, pszParentDirectory) ;

    // We're also going to need the name of the Start Menu directory (the default
    // is 'Start Menu'; however, the user may have changed it).  pszBaseDirectory
    // contains the name of the Start Menu directory after the final backslash.
    CHString chstrStartMenuDir(pszBaseDirectory);
    chstrStartMenuDir = chstrStartMenuDir.Mid(chstrStartMenuDir.ReverseFind(_T('\\')) + 1);

    // Enumerate subdirectories ( == program groups)
    //==============================================

    SmartFindClose lFindHandle = FindFirstFile(szDirSpec, &FindData) ;
    bool fContinue = true;
    while ( lFindHandle != INVALID_HANDLE_VALUE && SUCCEEDED ( hr ) && fContinue )
    {
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY && _tcscmp(FindData.cFileName, _T(".")) && _tcscmp(FindData.cFileName, _T("..")))
        {
            CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
			TCHAR szTemp[_MAX_PATH] ;
			_stprintf(szTemp, _T("%s\\%s"), pszParentDirectory, FindData.cFileName ) ;

			TCHAR *pszGroupName = _tcschr(szTemp, _T('\\')) + 1 ;
            pInstance->SetCHString(L"UserName" , pszUserName);

            CHString chstrTmp;
            chstrTmp.Format(L"%s\\%s", (LPCWSTR)chstrStartMenuDir, (LPCWSTR)TOBSTRT(pszGroupName));
			pInstance->SetCHString(L"GroupName" , chstrTmp);

            chstrTmp.Format(L"%s:%s\\%s", (LPCWSTR)TOBSTRT(pszUserName), (LPCWSTR)chstrStartMenuDir, (LPCWSTR)TOBSTRT(pszGroupName));
			pInstance->SetCHString(L"Name" , chstrTmp) ;

            // How we set it depends on whether we are on NTFS or not.
            if(fOnNTFS)
            {
                pInstance->SetDateTime(IDS_InstallDate, WBEMTime(FindData.ftCreationTime));
            }
            else
            {
                WBEMTime wbt(FindData.ftCreationTime);
                BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                {
                    pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                    SysFreeString(bstrRealTime);
                }
            }

            CHString chstrTmp2;
            chstrTmp2.Format(L"Logical program group \"%s\"", (LPCWSTR) chstrTmp);
            pInstance->SetCHString(L"Description" , chstrTmp2) ;
            pInstance->SetCHString(L"Caption" , chstrTmp2) ;

			hr = pInstance->Commit (  ) ;

            // Enumerate directories sub to this one
            //======================================

            _stprintf ( szDirSpec, _T("%s\\%s"), pszParentDirectory, FindData.cFileName) ;

            CreateSubDirInstances (

				pszUserName,
				pszBaseDirectory,
				szDirSpec,
				pMethodContext,
                fOnNTFS
			) ;
        }

        fContinue = FindNextFile(lFindHandle, &FindData) ;
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::CreateThisDirInstance
 *
 *  DESCRIPTION : Creates instance of property set for the directory passed in.
 *
 *  INPUTS      : pszBaseDirectory    : Windows directory + "Profiles\<user>\Start Menu"
 *                pszParentDirectory  : Parent directory to enumerate
 *
 *  OUTPUTS     : pdwInstanceCount : incremented for each instance created
 *
 *  RETURNS     : Zip
 *
 *  COMMENTS    : Recursive descent thru profile directories
 *
 *****************************************************************************/

HRESULT CWin32LogicalProgramGroup :: CreateThisDirInstance
(
	LPCTSTR pszUserName,
    LPCTSTR pszBaseDirectory,
    MethodContext *pMethodContext,
    bool fOnNTFS
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#if (defined(UNICODE) || defined(_UNICODE))
    WIN32_FIND_DATAW FindData ;
#else
    WIN32_FIND_DATA FindData ;
#endif

    // Put together search spec for this level
    //========================================

	TCHAR szDirSpec[_MAX_PATH] ;
    _stprintf(szDirSpec, _T("%s"), pszBaseDirectory) ;

    // Enumerate subdirectories ( == program groups)
    //==============================================

    SmartFindClose lFindHandle = FindFirstFile(szDirSpec, &FindData) ;
    if( lFindHandle != INVALID_HANDLE_VALUE)
    {
        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
		TCHAR *pszGroupName = _tcsrchr(pszBaseDirectory, _T('\\')) + 1 ;

		pInstance->SetCHString ( L"UserName" , pszUserName );
		pInstance->SetCHString ( L"GroupName" , pszGroupName );

        CHString chstrTmp;
        chstrTmp.Format(L"%s:%s", (LPCWSTR)TOBSTRT(pszUserName), (LPCWSTR)TOBSTRT(pszGroupName));
		pInstance->SetCHString ( L"Name" , chstrTmp ) ;

        // How we set it depends on whether we are on NTFS or not.
        if(fOnNTFS)
        {
            pInstance->SetDateTime(IDS_InstallDate, WBEMTime(FindData.ftCreationTime));
        }
        else
        {
            WBEMTime wbt(FindData.ftCreationTime);
            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
            {
                pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                SysFreeString(bstrRealTime);
            }
        }

        CHString chstrTmp2;
        chstrTmp2.Format(L"Logical program group \"%s\"", (LPCWSTR) chstrTmp);
        pInstance->SetCHString(L"Description" , chstrTmp2) ;
        pInstance->SetCHString(L"Caption" , chstrTmp2) ;

		hr = pInstance->Commit ( ) ;

    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::EnumerateGroupsTheHardWay
 *
 *  DESCRIPTION : Creates instances for program groups by drilling into
 *                user profiles
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : dwInstanceCount receives the total number of instances created
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32LogicalProgramGroup :: EnumerateGroupsTheHardWay (

	MethodContext *pMethodContext
)
{
    HRESULT hr = WBEM_E_FAILED;


    // Get default user first
    //=======================

    InstanceHardWayGroups ( L"Default User", L".DEFAULT", pMethodContext) ;

    // Get the users first
    //====================
        // Create instances for each user
    //===============================

	TRefPointerCollection<CInstance> users ;

	hr = CWbemProviderGlue :: GetAllInstances (

		PROPSET_NAME_USER,
		&users,
		IDS_CimWin32Namespace,
		pMethodContext
	) ;

	if ( SUCCEEDED ( hr ) )
	{
		REFPTRCOLLECTION_POSITION pos ;

		if ( users.BeginEnum ( pos ) )
		{
            hr = WBEM_S_NO_ERROR ;

			CUserHive UserHive ;

			CInstancePtr pUser ;

            for (pUser.Attach(users.GetNext ( pos ));
                 pUser != NULL;
                 pUser.Attach(users.GetNext ( pos )))
			{
    				// Look up the user's account info
					//================================

				CHString userName;
				pUser->GetCHString(IDS_Name, userName) ;

				WCHAR szKeyName[_MAX_PATH] ;

				if ( UserHive.Load ( userName , szKeyName ) == ERROR_SUCCESS )
				{
                    try
                    {
    					InstanceHardWayGroups ( userName , szKeyName , pMethodContext ) ;
                    }
                    catch ( ... )
                    {
    					UserHive.Unload ( szKeyName ) ;
                        throw;
                    }

    				UserHive.Unload ( szKeyName ) ;
				}
			}

			users.EndEnum();
		}
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::InstanceHardWayGroups
 *
 *  DESCRIPTION : Creates instances of program groups for specified user
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : dwInstanceCount receives the total number of instances created
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LogicalProgramGroup :: InstanceHardWayGroups (

	LPCWSTR pszUserName ,
    LPCWSTR pszRegistryKeyName ,
    MethodContext * pMethodContext
)
{
    HRESULT hr= WBEM_S_NO_ERROR;

    // UNICODE groups
    //===============

    WCHAR szTemp[_MAX_PATH] ;
    swprintf (

		szTemp ,
		L"%s\\%s\\UNICODE Groups",
		pszRegistryKeyName,
		IDS_BASE_REG_KEY
	) ;

    CRegistry Reg ;

	LONG lRet = Reg.Open(HKEY_USERS, szTemp, KEY_READ) ;
    if( lRet == ERROR_SUCCESS)
	{
        for ( DWORD i = 0 ; i < Reg.GetValueCount () && SUCCEEDED(hr); i++)
		{
			WCHAR *pValueName = NULL ;
			BYTE *pValueData = NULL ;

            DWORD dwRetCode = Reg.EnumerateAndGetValues ( i , pValueName , pValueData ) ;
            if ( dwRetCode == ERROR_SUCCESS )
			{
				try
				{
					CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
					pInstance->SetCHString ( L"UserName" , pszUserName ) ;
					pInstance->SetCHString ( L"GroupName", (LPCTSTR) pValueData ) ;
					pInstance->SetCHString ( L"Name", CHString(pszUserName) + CHString(_T(":")) + CHString((TCHAR)pValueData ) );

					hr = pInstance->Commit ( ) ;
				}
				catch ( ... )
				{
					delete [] pValueName ;
					delete [] pValueData ;

					throw ;
				}

				delete [] pValueName ;
				delete [] pValueData ;
			}
        }

        Reg.Close() ;
    }

    // Get the Common Groups
    //======================

    swprintf (

		szTemp,
		L"%s\\%s\\Common Groups",
		pszRegistryKeyName,
		IDS_BASE_REG_KEY
	) ;

	lRet = Reg.Open(HKEY_USERS, szTemp, KEY_READ) ;
    if ( lRet == ERROR_SUCCESS )
	{
        for ( DWORD i = 0 ; i < Reg.GetValueCount() && SUCCEEDED(hr); i++)
		{
			WCHAR *pValueName = NULL ;
			BYTE *pValueData = NULL ;

            DWORD dwRetCode = Reg.EnumerateAndGetValues ( i , pValueName , pValueData ) ;
            if ( dwRetCode == ERROR_SUCCESS )
			{
				try
				{
					// Scan past window coord info (7 decimal #s)
					//===========================================

					WCHAR *c = wcschr ( ( WCHAR * ) pValueData , ' ') ;
					for ( int j = 0 ; j < 6 ; j++ )
					{

						if( c == NULL)
						{
							break ;
						}

						c = wcschr ( c + 1 , ' ' ) ; // L10N OK
					}

					// Check conformance to expected format
					//=====================================

					if ( c != NULL )
					{
						CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
						pInstance->SetCHString ( L"UserName" , pszUserName ) ;
						pInstance->SetCHString ( L"GroupName" , c+1);
						pInstance->SetCHString ( L"Name" , CHString ( pszUserName ) + CHString ( L":" ) + CHString ( c + 1 ) ) ;

						hr = pInstance->Commit (  ) ;
					}
				}
				catch ( ... )
				{
					delete [] pValueName ;
					delete [] pValueData ;

					throw ;
				}

				delete [] pValueName ;
				delete [] pValueData ;
			}
        }

        Reg.Close() ;
    }

	if ( lRet == ERROR_ACCESS_DENIED )
	{
		hr = WBEM_E_ACCESS_DENIED ;
	}

    return hr ;
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32LogicalProgramGroup::SetCreationDate
 *
 *  DESCRIPTION : Sets the CreationDate property
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32LogicalProgramGroup::SetCreationDate
(
    CHString &a_chstrPGName,
    CHString &a_chstrUserName,
    CInstance *a_pInstance,
    bool fOnNTFS
)
{
	HRESULT t_hr = WBEM_S_NO_ERROR;
	CHString t_chstrUserNameUpr(a_chstrUserName);
	t_chstrUserNameUpr.MakeUpper();
    CHString t_chstrStartMenuFullPath;
    CHString t_chstrPGFullPath;
	CHString t_chstrDefaultUserName;
	CHString t_chstrAllUsersName;
	CHString t_chstrProfilesDir;
	CHString t_chstrTemp;

#ifdef WIN9XONLY
    CRegistry t_RegInfo;
	DWORD t_dwRet = t_RegInfo.OpenCurrentUser(
                               L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                               KEY_READ);

    if(t_dwRet == ERROR_SUCCESS)
    {
		t_RegInfo.GetCurrentKeyValue(L"Start Menu" ,t_chstrStartMenuFullPath);
        t_RegInfo.Close();
    }
    // We also don't want the "start menu" on the end, so hack it off too...
    int t_iLastWhackPos = t_chstrStartMenuFullPath.ReverseFind(_T('\\'));
    if(t_iLastWhackPos > -1)
    {
        t_chstrStartMenuFullPath = t_chstrStartMenuFullPath.Left(t_iLastWhackPos);
    }
	t_chstrPGFullPath.Format(L"%s\\%s",(LPCWSTR) t_chstrStartMenuFullPath, (LPCWSTR) a_chstrPGName);
#endif


#ifdef NTONLY
	bool t_fGotMatchedUser = false;
	CRegistry t_RegInfo;
	TCHAR t_tstrProfileImagePath[_MAX_PATH];
	ZeroMemory(t_tstrProfileImagePath , sizeof(t_tstrProfileImagePath));


#if NTONLY >= 5
    // Default user doesn't show up under profiles
	DWORD t_dwRet = t_RegInfo.Open(HKEY_LOCAL_MACHINE,
								   _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),
								   KEY_READ);

    if(t_dwRet == ERROR_SUCCESS)
    {
        t_RegInfo.GetCurrentKeyValue( _T("DefaultUserProfile") , t_chstrDefaultUserName);
		t_chstrDefaultUserName.MakeUpper();
		if(t_chstrUserNameUpr.Find(t_chstrDefaultUserName) != -1)
		{
			t_fGotMatchedUser = true;

			if(t_RegInfo.GetCurrentKeyValue ( _T("ProfilesDirectory") , t_chstrTemp) == ERROR_SUCCESS)
			{
				// chstrTemp contains something like "%SystemRoot\Profiles%".  Need to expand the environment variable...


				t_dwRet = ExpandEnvironmentStrings( t_chstrTemp , t_tstrProfileImagePath , _MAX_PATH );
				if ( t_dwRet != 0 && t_dwRet < _MAX_PATH )
				{
					t_chstrPGFullPath.Format(_T("%s\\%s\\%s"),
										     t_tstrProfileImagePath,
											 (LPCTSTR)t_chstrDefaultUserName,
											 (LPCTSTR)a_chstrPGName);
				}
			}
		}
		t_RegInfo.Close();
    }
	else
	{
		if(t_dwRet == ERROR_ACCESS_DENIED)
        {
			t_hr = WBEM_E_ACCESS_DENIED;
        }
	}
#endif
#if NTONLY == 4
    // NT 4 just has to be different...
    DWORD t_dwRet = t_RegInfo.Open(HKEY_USERS,
					               _T(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
					               KEY_READ);

    if(t_dwRet == ERROR_SUCCESS)
    {
        CHString t_chstrProfileImagePath;
		if(t_RegInfo.GetCurrentKeyValue(_T("Programs"), t_chstrProfileImagePath) == ERROR_SUCCESS)
        {
            // sTemp looks like c:\\winnt\\profiles\\default user\\start menu\\programs.
            // Don't want the programs dir on the end, so hack it off...
            int t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
            if(t_iLastWhackPos > -1)
            {
                t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
                // We also don't want the "start menu" on the end, so hack it off too...
                t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
                if(t_iLastWhackPos > -1)
                {
                    t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
                    // We also want to extract the name of the "Default User" directory...
                    t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
                    if(t_iLastWhackPos > -1)
                    {
                        t_chstrDefaultUserName = t_chstrProfileImagePath.Right(t_chstrProfileImagePath.GetLength() - t_iLastWhackPos -1);
						t_chstrDefaultUserName.MakeUpper();
						if(t_chstrUserNameUpr.Find(t_chstrDefaultUserName) != -1)
						{
							t_fGotMatchedUser = true;
							t_chstrPGFullPath.Format(_T("%s\\%s"),
													 t_chstrProfileImagePath,
													 (LPCTSTR)a_chstrPGName);
						}
                    }
                }
            }
        }
		t_RegInfo.Close();
    }
	else
	{
		if ( t_dwRet == ERROR_ACCESS_DENIED )
        {
			t_hr = WBEM_E_ACCESS_DENIED ;
        }
	}
#endif

    if(!t_fGotMatchedUser)
	{
		// Neither does All Users.  The following works for all users for both nt 4 and 5.
		DWORD t_dwRet = t_RegInfo.Open(HKEY_LOCAL_MACHINE,
									   _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
									   KEY_READ);

		if(t_dwRet == ERROR_SUCCESS)
		{
			CHString t_chstrProfileImagePath;
			if(t_RegInfo.GetCurrentKeyValue(_T("Common Programs"), t_chstrProfileImagePath) == ERROR_SUCCESS)
			{
				// we do want to start in the Start Menu subdir, not the Programs dir under it
				int t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
				if(t_iLastWhackPos > -1)
				{
					t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
					// We also don't want the "start menu" on the end, so hack it off too...
					t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
					if(t_iLastWhackPos > -1)
					{
						t_chstrProfileImagePath = t_chstrProfileImagePath.Left(t_iLastWhackPos);
                        // We also want to extract the name of the "All Users" directory...
						t_iLastWhackPos = t_chstrProfileImagePath.ReverseFind(_T('\\'));
						if(t_iLastWhackPos > -1)
						{
							t_chstrAllUsersName = t_chstrProfileImagePath.Right(t_chstrProfileImagePath.GetLength() - t_iLastWhackPos -1);
							t_chstrAllUsersName.MakeUpper();
							if(t_chstrUserNameUpr.Find(t_chstrAllUsersName) != -1)
							{
								t_fGotMatchedUser = true;
								t_chstrPGFullPath.Format(_T("%s\\%s"),
														 t_chstrProfileImagePath,
														 (LPCTSTR)a_chstrPGName);
							}
						}
					}
				}
			}
			t_RegInfo.Close();
		}
		else
		{
			if ( t_dwRet == ERROR_ACCESS_DENIED )
			{
				t_hr = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

	if(!t_fGotMatchedUser)
	{
		// Now walk the registry looking for the rest
		CRegistry t_regProfileList;
		DWORD t_dwRet = t_regProfileList.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
																 IDS_RegNTProfileList,
																 KEY_READ);

		if(t_dwRet == ERROR_SUCCESS)
		{
			CUserHive t_UserHive ;
			CHString t_chstrProfile, t_chstrUserName, t_chstrKeyName2;

			for(int i = 0; t_regProfileList.GetCurrentSubKeyName(t_chstrProfile) == ERROR_SUCCESS && !t_fGotMatchedUser; i++)
			{
				// Try to load the hive.  If the user has been deleted, but the directory
				// is still there, this will return ERROR_NO_SUCH_USER
				if(t_UserHive.LoadProfile(t_chstrProfile, t_chstrUserName) == ERROR_SUCCESS && 
                            t_chstrUserName.GetLength() > 0 )
				{
				    try
				    {
					    t_chstrUserName.MakeUpper();
					    if(t_chstrUserNameUpr.Find(t_chstrUserName) != -1)
					    {
						    t_fGotMatchedUser = true;
							t_chstrKeyName2 = t_chstrProfile + _T("\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");

							if(t_RegInfo.Open(HKEY_USERS, t_chstrKeyName2, KEY_READ) == ERROR_SUCCESS)
							{
								if(t_RegInfo.GetCurrentKeyValue(_T("Programs"), t_chstrTemp) == ERROR_SUCCESS)
								{
									// wack off the "Programs" directory...
									int t_iLastWhackPos = t_chstrTemp.ReverseFind(_T('\\'));
									if(t_iLastWhackPos > -1)
									{
										t_chstrTemp = t_chstrTemp.Left(t_iLastWhackPos);
                                        // wack off the "start menu" part too...
                                        t_iLastWhackPos = t_chstrTemp.ReverseFind(_T('\\'));
									    if(t_iLastWhackPos > -1)
									    {
										    t_chstrTemp = t_chstrTemp.Left(t_iLastWhackPos);
										    t_chstrPGFullPath.Format(_T("%s\\%s"),
														     t_chstrTemp,
														     (LPCTSTR)a_chstrPGName);
                                        }
									}
								}
								t_RegInfo.Close();
							}
    					}
				    }
				    catch ( ... )
				    {
					    t_UserHive.Unload(t_chstrProfile) ;
					    throw ;
				    }
					t_UserHive.Unload(t_chstrProfile) ;
				}
				t_regProfileList.NextSubKey();
			}
			t_regProfileList.Close();
		}
		else
		{
			if ( t_dwRet == ERROR_ACCESS_DENIED )
			{
				t_hr = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

#endif

	// Finally we can start the real work.  Check that we have the full path
	// to the element...
	if(t_chstrPGFullPath.GetLength() > 0)
	{
		// We have a path.  Open it up and get the creation date...
#if (defined(UNICODE) || defined(_UNICODE))
		WIN32_FIND_DATAW t_FindData ;
#else
		WIN32_FIND_DATA t_FindData ;
#endif

		SmartFindClose lFindHandle = FindFirstFile((LPTSTR)(LPCTSTR)TOBSTRT(t_chstrPGFullPath), &t_FindData) ;

		if(lFindHandle != INVALID_HANDLE_VALUE)
		{
			// How we set it depends on whether we are on NTFS or not.
            if(fOnNTFS)
            {
                a_pInstance->SetDateTime(IDS_InstallDate, WBEMTime(t_FindData.ftCreationTime));
            }
            else
            {
                WBEMTime wbt(t_FindData.ftCreationTime);
                BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                {
                    a_pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                    SysFreeString(bstrRealTime);
                }
            }
		}
		else
		{
			t_hr = WBEM_E_NOT_FOUND;
		}

    }

    return t_hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logicalshareaudit.h ===
//=================================================================

//

// LogicalShareAudit.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __LOGICALSHAREACCESS_H__
#define __LOGICALSHAREACCESS_H__

#define  LOGICAL_SHARE_AUDIT_NAME L"Win32_LogicalShareAuditing"

// provider provided for test provisions
class CWin32LogicalShareAudit: public Provider
{
	public:	
		CWin32LogicalShareAudit(LPCWSTR setName, LPCWSTR pszNamespace );
		~CWin32LogicalShareAudit();

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/);
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags /*= 0L*/ );
		HRESULT CWin32LogicalShareAudit::FillSidInstance(CInstance* pInstance, CSid& sid) ;
		HRESULT CWin32LogicalShareAudit::GetEmptyInstanceHelper(CHString chsClassName, CInstance**ppInstance, MethodContext* pMethodContext ) ;
		HRESULT CWin32LogicalShareAudit::FillProperties(CInstance* pInstance, CAccessEntry& ACE ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\loginprofile.cpp ===
//=================================================================

//

// LogProf.CPP -- Network login profile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				04/29/98	a-brads		Hacked Logon Hours
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>

#include "wbemnetapi32.h"
#include "LoginProfile.h"
#include <time.h>
#include "UserHive.h"
#include "sid.h"
// Property set declaration
//=========================
CWin32NetworkLoginProfile MyCWin32NetworkLoginProfileSet(PROPSET_NAME_USERPROF, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkLoginProfile::CWin32NetworkLoginProfile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32NetworkLoginProfile::CWin32NetworkLoginProfile(LPCWSTR name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkLoginProfile::~CWin32NetworkLoginProfile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32NetworkLoginProfile::~CWin32NetworkLoginProfile()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32NetworkLoginProfile::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
	CHString chsKey;

	pInstance->GetCHString(IDS_Name, chsKey);

#ifdef NTONLY
        hr = RefreshInstanceNT(pInstance) ;
#endif
#ifdef WIN9XONLY
    CRegistry RegInfo ;
    DWORD dwUser ;
    CHString sTemp ;

        // We aren't getting anything but the key value "Name"
        // so don't do anything;
//        hr = WBEM_S_NO_ERROR;

//////////////////////////////

	    //if(RegInfo.Open(HKEY_USERS, L"", KEY_READ) == ERROR_SUCCESS)  -> See 49192
        if(RegInfo.Open(HKEY_LOCAL_MACHINE,L"Software\\Microsoft\\Windows\\CurrentVersion\\ProfileList", KEY_READ) == ERROR_SUCCESS)
	    {
	        dwUser = RegInfo.GetCurrentSubKeyCount() ;
	        for(dwUser = 0 ; dwUser < RegInfo.GetCurrentSubKeyCount() ; dwUser++)
	        {
	            if(RegInfo.GetCurrentSubKeyName(sTemp) == ERROR_SUCCESS)
	            {
					CHString chstrNamePart = chsKey.Mid(chsKey.Find(L'\\')+1);
                    if (0 == sTemp.CompareNoCase(chstrNamePart))
					{
						GetUserDetails(pInstance,sTemp);
						hr = WBEM_S_NO_ERROR;
						break;
					}
	            }

	            if(RegInfo.NextSubKey() == ERROR_NO_MORE_ITEMS)
	            {
	                break ;
	            }
	        }
	    }
#endif
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32NetworkLoginProfile::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY
        hr = EnumInstancesNT(pMethodContext) ;
#endif
#ifdef WIN9XONLY
        hr = EnumInstancesWin9X(pMethodContext);
#endif
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumInstancesNT
 *
 *  DESCRIPTION : Creates instance for all known local users (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT CWin32NetworkLoginProfile::EnumInstancesNT(MethodContext * pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    NET_API_STATUS nRetCode, nModalRetCode ;
    USER_INFO_3 *pUserInfo = NULL ;
	USER_MODALS_INFO_0 *pUserModal = NULL ;
    CUserHive UserHive;
    CHString chstrProfile;
    CHString chstrUserName;
    CNetAPI32 NetAPI;

	try
	{
		// Get NETAPI32.DLL entry points
		if(NetAPI.Init() == ERROR_SUCCESS)
		{
			nModalRetCode = NetAPI.NetUserModalsGet(NULL, 0, (LPBYTE*) &pUserModal);

			if(nModalRetCode != NERR_Success)
			{
				pUserModal = NULL;
			}

            CRegistry regProfileList;
	        DWORD dwErr = regProfileList.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
		                                                         IDS_RegNTProfileList,
		                                                         KEY_READ);

            CHString chstrLocalCompName = GetLocalComputerName();
            // Open the ProfileList key so we know which profiles to load up.
	        if(dwErr == ERROR_SUCCESS)
	        {
                CHString chstrDomainName;
		        for(int i = 0; regProfileList.GetCurrentSubKeyName(chstrProfile) == ERROR_SUCCESS && SUCCEEDED(hr); i++)
		        {
			        // Get user name out of user hive...
                    if((dwErr = UserHive.LoadProfile(chstrProfile, chstrUserName)) == ERROR_SUCCESS)
                    {
                        // Get the logon server from the registry to find
                        // out where we should go to resolve the sid to 
                        // domain/account.  Only bother if we don't have
                        // the username already.
                        if(chstrUserName.GetLength() == 0)
                        {
                            CRegistry regLogonServer;
                            CHString chstrLogonServerKey;
                            CHString chstrLogonServerName;
                        
                            chstrLogonServerKey.Format(
                                L"%s\\Volatile Environment",
                                (LPCWSTR)chstrProfile);

                            if(regLogonServer.Open(HKEY_USERS,
                                chstrLogonServerKey,
                                KEY_READ) == ERROR_SUCCESS)
                            {
                                if(regLogonServer.GetCurrentKeyValue(
                                    L"LOGONSERVER",
                                    chstrLogonServerName) == ERROR_SUCCESS)
                                {
                                    PSID psidUserName = NULL;
                                    try
                                    {
                                        psidUserName = StrToSID(chstrProfile);
                                        if(psidUserName != NULL)
                                        {
                                            CSid sidUserName(psidUserName, chstrLogonServerName);
                                            if(sidUserName.IsValid() && sidUserName.IsOK())
                                            {
                                                chstrUserName = sidUserName.GetAccountName();
                                                chstrUserName += L"\\";
                                                chstrUserName += sidUserName.GetDomainName();
                                            }
                                        }
                                    }
                                    catch(...)
                                    {
                                        if(psidUserName != NULL)
                                        {
                                            ::FreeSid(psidUserName);
                                            psidUserName = NULL;
                                        }
                                        throw;
                                    }
                                    
                                    ::FreeSid(psidUserName);
                                    psidUserName = NULL;
                                }
                            }
                        }
                        
                        // Now get net info on that user...
                        // First break their name into domain and name pieces...
                        int pos = chstrUserName.Find(L'\\');
                        CHString chstrNamePart = chstrUserName.Mid(pos+1);
                        CHString chstrDomainPart = chstrUserName.Left(pos);

                        // If it is not a local profile, then...
                        if(chstrDomainPart.CompareNoCase(chstrLocalCompName) != 0)
                        {
                            GetDomainName(chstrDomainName);

                            // 1) try to get the info off of the dc
                            nRetCode = NetAPI.NetUserGetInfo(chstrDomainName, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                            // 2) If couldn't get the info from the dc, try the logon server...
                            if(nRetCode != NERR_Success)
                            {
                                GetLogonServer(chstrDomainName);
                                nRetCode = NetAPI.NetUserGetInfo(chstrDomainName, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                            }
                        }
                        else  // the profile should exist on the local machine, given the name
                        {
                            // If couldn't get the info from the logon server, try the local machine...
                            nRetCode = NetAPI.NetUserGetInfo(NULL, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                        }

                        // Then fill out their values...
                        if(nRetCode == NERR_Success)
                        {
                            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                            
                            LoadLogProfValuesForNT(chstrUserName, pUserInfo, pUserModal, pInstance, TRUE);
                            hr = pInstance->Commit();
                        }
                        else
                        {
                            // we couldn't get any details, but we should still commit an instance...
                            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                          
                            pInstance->SetCHString(_T("Name"), chstrUserName);
                            pInstance->SetCHString(_T("Caption"), chstrUserName);
                            CHString chstrTmp;
                            CHString chstrTmp2 = chstrUserName.SpanExcluding(L"\\");
                            chstrTmp.Format(L"Network login profile settings for %s on %s", (LPCWSTR)chstrNamePart, (LPCWSTR)chstrTmp2);
                            pInstance->SetCHString(_T("Description"), chstrTmp);
                            hr = pInstance->Commit();
                        }
                        UserHive.Unload(chstrProfile);
                    }
			        regProfileList.NextSubKey();
		        }
                regProfileList.Close();
	        }
	        else
	        {
		        hr = WinErrorToWBEMhResult(dwErr);
	        }

		}
	}
	catch ( ... )
	{
		if ( pUserInfo )
		{
			NetAPI.NetApiBufferFree ( pUserInfo ) ;
			pUserInfo = NULL ;
		}

		if ( pUserModal )
		{
			NetAPI.NetApiBufferFree ( pUserModal ) ;
			pUserModal = NULL ;
		}

		throw ;
	}

	if(pUserInfo != NULL)
    {
        NetAPI.NetApiBufferFree(pUserInfo);
        pUserInfo = NULL;
    }

	if(pUserModal != NULL)
	{
		NetAPI.NetApiBufferFree(pUserModal);
		pUserModal = NULL;
	}

	return hr;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : RefreshInstanceNT
 *
 *  DESCRIPTION : Loads property values according to key value set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT CWin32NetworkLoginProfile::RefreshInstanceNT(CInstance * pInstance)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    NET_API_STATUS nRetCode, nModalRetCode ;
    USER_INFO_3 *pUserInfo = NULL ;
	USER_MODALS_INFO_0 *pUserModal = NULL ;
    CNetAPI32 NetAPI ;
    CHString Name;
    CUserHive UserHive;
    bool fUserIsInProfiles = false;
    CHString chstrUserName;
    CHStringArray profiles;
    int p;

    pInstance->GetCHString(_T("Name"),Name);

	try
	{
		// First get the names of everyone under the profiles key
        CRegistry regProfileList ;

	    DWORD dwErr = regProfileList.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
		                                                     IDS_RegNTProfileList,
		                                                     KEY_READ);

        // Open the ProfileList key so we know which profiles to load up.
	    if ( dwErr == ERROR_SUCCESS )
	    {
		    profiles.SetSize(regProfileList.GetCurrentSubKeyCount(), 5);

		    CHString strProfile ;
		    for(p = 0; regProfileList.GetCurrentSubKeyName(strProfile) == ERROR_SUCCESS; p++)
		    {
			    profiles.SetAt(p, strProfile);
			    regProfileList.NextSubKey();
		    }
		    regProfileList.Close() ;

            // Use the userhive to convert to user names; see if a user in the subkeys matches us...
            int j = profiles.GetSize();
            for(p = 0; p < j && !fUserIsInProfiles; p++)
            {
                dwErr = UserHive.LoadProfile(profiles[p], chstrUserName);
                if(dwErr == ERROR_SUCCESS)
                {
                    // Get the logon server from the registry to find
                    // out where we should go to resolve the sid to 
                    // domain/account.  Only bother if we don't have
                    // the username already.
                    if(chstrUserName.GetLength() == 0)
                    {
                        CRegistry regLogonServer;
                        CHString chstrLogonServerKey;
                        CHString chstrLogonServerName;
                    
                        chstrLogonServerKey.Format(
                            L"%s\\Volatile Environment",
                            (LPCWSTR)profiles[p]);

                        if(regLogonServer.Open(HKEY_USERS,
                            chstrLogonServerKey,
                            KEY_READ) == ERROR_SUCCESS)
                        {
                            if(regLogonServer.GetCurrentKeyValue(
                                L"LOGONSERVER",
                                chstrLogonServerName) == ERROR_SUCCESS)
                            {
                                PSID psidUserName = NULL;
                                try
                                {
                                    psidUserName = StrToSID(profiles[p]);
                                    if(psidUserName != NULL)
                                    {
                                        CSid sidUserName(psidUserName, chstrLogonServerName);
                                        if(sidUserName.IsValid() && sidUserName.IsOK())
                                        {
                                            chstrUserName = sidUserName.GetAccountName();
                                            chstrUserName += L"\\";
                                            chstrUserName += sidUserName.GetDomainName();
                                        }
                                    }
                                }
                                catch(...)
                                {
                                    if(psidUserName != NULL)
                                    {
                                        ::FreeSid(psidUserName);
                                        psidUserName = NULL;
                                    }
                                    throw;
                                }
                                
                                ::FreeSid(psidUserName);
                                psidUserName = NULL;
                            }
                        }
                    }

                    
                    if(chstrUserName.CompareNoCase(Name) == 0)
                    {
                        fUserIsInProfiles = true;
                    }

                    UserHive.Unload(profiles[p]);
                }
            }

            if(fUserIsInProfiles)
            {
                if(NetAPI.Init() == ERROR_SUCCESS)
		        {
   			        nModalRetCode = NetAPI.NetUserModalsGet(NULL, 0, (LPBYTE *) &pUserModal);
			        if (nModalRetCode != NERR_Success)
			        {
				        pUserModal = NULL;
			        }

                    // Now get net info on that user...
                    // First break their name into domain and name pieces...
                    int pos = chstrUserName.Find(L'\\');
                    CHString chstrNamePart = chstrUserName.Mid(pos+1);
                    CHString chstrDomainPart = chstrUserName.Left(pos);
                    CHString chstrDomainName;

                    // If it is not a local profile, then...
                    if(chstrDomainPart.CompareNoCase(GetLocalComputerName()) != 0)
                    {
                        GetDomainName(chstrDomainName);

                        // 1) try to get the info off of the dc
                        nRetCode = NetAPI.NetUserGetInfo(chstrDomainName, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                        // 2) If couldn't get the info from the dc, try the logon server...
                        if(nRetCode != NERR_Success)
                        {
                            GetLogonServer(chstrDomainName);
                            nRetCode = NetAPI.NetUserGetInfo(chstrDomainName, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                        }
                    }
                    else  // the profile should exist on the local machine, given the name
                    {
                        // If couldn't get the info from the logon server, try the local machine...
                        nRetCode = NetAPI.NetUserGetInfo(NULL, chstrNamePart, 3, (LPBYTE*) &pUserInfo);
                    }

                    // If we got the logon info, fill it out...
                    if(nRetCode == NERR_Success)
                    {
                        CHString chstrNamePart = Name.Mid(Name.Find(L'\\')+1);
                        if(pUserInfo->usri3_flags & UF_NORMAL_ACCOUNT &&
							(0 == chstrNamePart.CompareNoCase(CHString(pUserInfo->usri3_name))))
                        {
							LoadLogProfValuesForNT(chstrUserName, pUserInfo, pUserModal, pInstance, FALSE);
							pInstance->SetCHString(IDS_Caption, pUserInfo->usri3_name);
							hr = WBEM_S_NO_ERROR;
						}
                    }
                    else
                    {
                        // we couldn't get any details, but we should still commit an instance...
                        pInstance->SetCHString(_T("Name"), chstrUserName);
                        pInstance->SetCHString(_T("Caption"), chstrUserName);
                        CHString chstrTmp;
                        CHString chstrTmp2 = chstrUserName.SpanExcluding(L"\\");
                        chstrTmp.Format(L"Network login profile settings for %s on %s", (LPCWSTR)chstrNamePart, (LPCWSTR)chstrTmp2);
                        pInstance->SetCHString(_T("Description"), chstrTmp);
                        hr = pInstance->Commit();
                    }
                }
            }
        }
	}

	catch ( ... )
	{
		if ( pUserInfo )
		{
			NetAPI.NetApiBufferFree ( pUserInfo ) ;
			pUserInfo = NULL ;
		}

		if ( pUserModal )
		{
			NetAPI.NetApiBufferFree ( pUserModal ) ;
			pUserModal = NULL ;
		}

		throw ;
	}

	if ( pUserInfo )
	{
		NetAPI.NetApiBufferFree ( pUserInfo ) ;
		pUserInfo = NULL ;
	}

    if(pUserModal != NULL)
    {
        NetAPI.NetApiBufferFree(pUserModal);
		pUserModal = NULL;
    }

    return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : LoadLogProfValuesNT
 *
 *  DESCRIPTION : Loads property values according to passed user name
 *
 *  INPUTS      : pUserInfo : pointer to USER_INFO_3 struct
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : zip
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
void CWin32NetworkLoginProfile::LoadLogProfValuesForNT(CHString &chstrUserDomainName,
                                                USER_INFO_3 *pUserInfo,
												USER_MODALS_INFO_0 *pUserModal,
                                                CInstance * pInstance,
                                                BOOL fAssignKey)
{

   TCHAR szBuff[32];

    //========================================================
    // Assign NT properties -- string values are unassigned if
    // NULL or empty
    //========================================================
    if( fAssignKey ){
        //pInstance->SetCHString(_T("Name"), pUserInfo->usri3_name);
        pInstance->SetCHString(_T("Name"), chstrUserDomainName);
	}

    pInstance->SetCHString(_T("Caption"), pUserInfo->usri3_name);

    CHString chstrTemp, chstrTemp2;
    chstrTemp.Format(L"Network login profile settings for %s", pUserInfo->usri3_full_name);
    CHString chstrDomainName = chstrUserDomainName.SpanExcluding(L"\\");
    chstrTemp2.Format(L" on %s", (LPCWSTR)chstrDomainName);
    chstrTemp += chstrTemp2;
    pInstance->SetCHString(IDS_Description,chstrTemp);


    if(pUserInfo->usri3_home_dir && pUserInfo->usri3_home_dir[0]) {
        pInstance->SetCHString(_T("HomeDirectory"),pUserInfo->usri3_home_dir);
    }
	else {
        pInstance->SetCHString(_T("HomeDirectory"),_T(""));
	}

    if(pUserInfo->usri3_comment && pUserInfo->usri3_comment[0]) {
        pInstance->SetCHString(_T("Comment"),pUserInfo->usri3_comment);
    }
	else {
        pInstance->SetCHString(_T("Comment"),_T(""));
	}

    if(pUserInfo->usri3_script_path && pUserInfo->usri3_script_path[0]) {
        pInstance->SetCHString(_T("ScriptPath"),pUserInfo->usri3_script_path);
    }
	else {
        pInstance->SetCHString(_T("ScriptPath"),_T(""));
	}

    if(pUserInfo->usri3_full_name && pUserInfo->usri3_full_name[0]) {
        pInstance->SetCHString(_T("FullName"),pUserInfo->usri3_full_name) ;
    }
	else {
        pInstance->SetCHString(_T("FullName"),_T(""));
	}

    if(pUserInfo->usri3_usr_comment && pUserInfo->usri3_usr_comment[0]) {
        pInstance->SetCHString(_T("UserComment"),pUserInfo->usri3_usr_comment );
    }
	else {
        pInstance->SetCHString(_T("UserComment"),_T(""));
	}

    if(pUserInfo->usri3_workstations && pUserInfo->usri3_workstations[0]) {
        pInstance->SetCHString(_T("Workstations"),pUserInfo->usri3_workstations );
    }
	else {
        pInstance->SetCHString(_T("Workstations"),_T(""));
	}

    if(pUserInfo->usri3_logon_server && pUserInfo->usri3_logon_server[0]) {
        pInstance->SetCHString(_T("LogonServer"),pUserInfo->usri3_logon_server );
    }
	else {
        pInstance->SetCHString(_T("LogonServer"),_T(""));
	}

    if(pUserInfo->usri3_profile && pUserInfo->usri3_profile[0]) {
        pInstance->SetCHString(_T("Profile"),pUserInfo->usri3_profile );
    }
	else {
        pInstance->SetCHString(_T("Profile"),_T(""));
	}

    if(pUserInfo->usri3_parms && pUserInfo->usri3_parms[0]) {
        pInstance->SetCHString(_T("Parameters"),pUserInfo->usri3_parms);
    }
	else {
        pInstance->SetCHString(_T("Parameters"),_T(""));
	}

    if(pUserInfo->usri3_home_dir_drive && pUserInfo->usri3_home_dir_drive[0]) {
        pInstance->SetCHString(_T("HomeDirectoryDrive"),pUserInfo->usri3_home_dir_drive );
    }
	else {
        pInstance->SetCHString(_T("HomeDirectoryDrive"),_T(""));
	}

    if(pUserInfo->usri3_flags & UF_NORMAL_ACCOUNT) {
        pInstance->SetCHString(_T("UserType"),L"Normal Account") ;
    }
    else if(pUserInfo->usri3_flags & UF_TEMP_DUPLICATE_ACCOUNT) {
        pInstance->SetCHString(_T("UserType"),L"Duplicate Account") ;
    }
    else if(pUserInfo->usri3_flags & UF_WORKSTATION_TRUST_ACCOUNT) {
        pInstance->SetCHString(_T("UserType"),L"Workstation Trust Account" );
    }
    else if(pUserInfo->usri3_flags & UF_SERVER_TRUST_ACCOUNT) {
        pInstance->SetCHString(_T("UserType"),L"Server Trust Account") ;
    }
    else if(pUserInfo->usri3_flags & UF_INTERDOMAIN_TRUST_ACCOUNT) {
        pInstance->SetCHString(_T("UserType"),L"Interdomain Trust Account") ;
    }
    else {
        pInstance->SetCHString(_T("UserType"),L"Unknown") ;
    }

#if (defined(UNICODE) || defined(_UNICODE))
    pInstance->SetWBEMINT64(L"MaximumStorage", _i64tow(pUserInfo->usri3_max_storage, szBuff, 10) );
#else
    pInstance->SetWBEMINT64("MaximumStorage", _i64toa(pUserInfo->usri3_max_storage, szBuff, 10) );
#endif
    pInstance->SetDWORD(_T("CountryCode"), pUserInfo->usri3_country_code) ;
    pInstance->SetDWORD(_T("CodePage"), pUserInfo->usri3_code_page) ;
    pInstance->SetDWORD(_T("UserId"), pUserInfo->usri3_user_id );
    pInstance->SetDWORD(_T("PrimaryGroupId"),pUserInfo->usri3_primary_group_id );

	if (0 != pUserInfo->usri3_last_logon)
	{
		pInstance->SetDateTime(_T("LastLogon"), (WBEMTime)pUserInfo->usri3_last_logon );
	}
	else
	{
		pInstance->SetCHString(_T("LastLogon"), StartEndTimeToDMTF(pUserInfo->usri3_last_logon));
	}

	if (0 != pUserInfo->usri3_last_logoff)
	{
		pInstance->SetDateTime(_T("LastLogoff"), (WBEMTime)pUserInfo->usri3_last_logoff );
	}
	else
	{
		pInstance->SetCHString(_T("LastLogoff"), StartEndTimeToDMTF(pUserInfo->usri3_last_logoff));
	}

	time_t timevar = pUserInfo->usri3_acct_expires;

	if (TIMEQ_FOREVER != timevar)
	{
		pInstance->SetDateTime(_T("AccountExpires"), (WBEMTime)pUserInfo->usri3_acct_expires );
	}
//	else
//	{
//		pInstance->SetCHString("AccountExpires", StartEndTimeToDMTF(0));
//	}



    // The following properties are buried in the usri3_flags and usri3_auth_flags
    // fields and should be broken out individually.  Returning the flag values
    // is all but meaningless.
    //============================================================================

//    ScriptExecuted      = pUserInfo->usri3_flags & UF_SCRIPT                ? TRUE  : FALSE ;
//    AccountDisabled     = pUserInfo->usri3_flags & UF_ACCOUNTDISABLE        ? TRUE  : FALSE ;
//    PWRequired          = pUserInfo->usri3_flags & UF_PASSWD_NOTREQD        ? FALSE : TRUE  ;
//    PWUserChangeable    = pUserInfo->usri3_flags & UF_PASSWD_CANT_CHANGE    ? FALSE : TRUE  ;
//    AccountLockOut           = pUserInfo->usri3_flags & UF_LOCKOUT               ? TRUE  : FALSE ;
//    PrintOperator       = pUserInfo->usri3_auth_flags & AF_OP_PRINT         ? TRUE  : FALSE ;
//    ServerOperator      = pUserInfo->usri3_auth_flags & AF_OP_SERVER        ? TRUE  : FALSE ;
//    AccountOperator     = pUserInfo->usri3_auth_flags & AF_OP_ACCOUNTS      ? TRUE  : FALSE ;

    pInstance->SetDWORD(_T("Flags"),pUserInfo->usri3_flags );
    pInstance->SetDWORD(_T("AuthorizationFlags"), pUserInfo->usri3_auth_flags );
//    pInstance->Setbool("PasswordExpires", pUserInfo->usri3_password_expired                 ? TRUE  : FALSE );
	if (pUserModal)
	{
		time_t modaltime, timetoexpire, currenttime, expirationtime;
		timevar = pUserInfo->usri3_password_age;
		modaltime = pUserModal->usrmod0_max_passwd_age;
		if (TIMEQ_FOREVER != modaltime && !(pUserInfo->usri3_flags & UF_DONT_EXPIRE_PASSWD))
		{
			timetoexpire = modaltime - timevar;
			time(&currenttime);
			expirationtime = currenttime + timetoexpire;
			pInstance->SetDateTime(_T("PasswordExpires"), (WBEMTime)expirationtime);
		}
	}

	time_t passwordage = pUserInfo->usri3_password_age;
	if (0 != passwordage)
	{
		if (TIMEQ_FOREVER != passwordage)
		{
            WBEMTimeSpan wts = GetPasswordAgeAsWbemTimeSpan(pUserInfo->usri3_password_age);
            pInstance->SetTimeSpan (_T("PasswordAge"), wts);
		}	// end if
	}
    pInstance->SetDWORD(_T("Privileges"),pUserInfo->usri3_priv);
    pInstance->SetDWORD(_T("UnitsPerWeek"),pUserInfo->usri3_units_per_week);
//    pInstance->SetCHString("Password",pUserInfo->usri3_password) ;

	if (pUserInfo->usri3_logon_hours == NULL)
	{
		pInstance->SetCHString(_T("LogonHours"), _T("Disabled"));
	}
	else
	{
		CHString chsLogonHours;
		GetLogonHoursString(pUserInfo->usri3_logon_hours, chsLogonHours);
		pInstance->SetCHString(_T("LogonHours"), chsLogonHours);
	}	// end else

    pInstance->SetDWORD(_T("BadPasswordCount"),pUserInfo->usri3_bad_pw_count);
    pInstance->SetDWORD(_T("NumberOfLogons"),pUserInfo->usri3_num_logons);
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : EnumInstancesWin9X(MethodContext * pMethodContext)
 *
 *  DESCRIPTION : Creates instance for all known local users (Win95)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : pdwInstanceCount -- receives count of all instances created
 *
 *  RETURNS     : yes
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef WIN9XONLY
HRESULT CWin32NetworkLoginProfile::EnumInstancesWin9X(MethodContext * pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRegistry RegInfo ;
    DWORD dwUser ;
    CHString sTemp ;

    //if(RegInfo.Open(HKEY_USERS, L"", KEY_READ) == ERROR_SUCCESS)  -> See 49192
    if(RegInfo.Open(HKEY_LOCAL_MACHINE,L"Software\\Microsoft\\Windows\\CurrentVersion\\ProfileList", KEY_READ) == ERROR_SUCCESS)
    {
        dwUser = RegInfo.GetCurrentSubKeyCount() ;
        for(dwUser = 0 ; dwUser < RegInfo.GetCurrentSubKeyCount() && SUCCEEDED(hr); dwUser++)
		{
            if(RegInfo.GetCurrentSubKeyName(sTemp) == ERROR_SUCCESS)
			{
                hr = WBEM_S_NO_ERROR;
                CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
          
				GetUserDetails(pInstance,sTemp);
				hr = pInstance->Commit () ;
            }

            if(RegInfo.NextSubKey() == ERROR_NO_MORE_ITEMS)
			{
                break ;
            }
        }
    }
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}
    return hr;
}
#endif

#ifdef WIN9XONLY
void CWin32NetworkLoginProfile::GetUserDetails( CInstance* pInstance, CHString Name )
{
//    GetWin9XUserInfo1 p1;
	ULONG fRc;
//    GetWin9XUserInfo2 p2;

    pInstance->SetCHString(L"Caption", Name);
    pInstance->SetCHString(L"Name",Name);
	CCim32NetApi* t_pCim32Net = NULL ;

	try
	{
		t_pCim32Net = HoldSingleCim32NetPtr::GetCim32NetApiPtr();
		if( t_pCim32Net != NULL)
		{
			char HomeDirectory[_MAX_PATH];
			char Comment[_MAX_PATH];
			char ScriptPath[_MAX_PATH];
			ULONG PasswordAge=0;
			USHORT Privileges=0;
			USHORT Flags =0;
			memset(HomeDirectory,NULL,_MAX_PATH);
			memset(Comment,NULL,_MAX_PATH);
			memset(ScriptPath,NULL,_MAX_PATH);

            // Need to obtain the name of the domain of the user.  If we get a domain name not associated
            // with a user, none of the following info will be obtained.  On the other hand, without a domain
            // name, none would be obtained either, since the call to NetGetDCName may not return the actual
            // controller we logged into (which is the one where the required info resides), but return the
            // PDC instead, to which this info may not have been replicated. If we can't get it, we pass
            // an empty string for the domain name instead, hoping that the PDC actually has the infol
            CHString chstrDomainName;
            GetDomainName(chstrDomainName);
            CHString chstrDomainAndUserName;
            if(chstrDomainName.GetLength() > 0)
            {
                fRc=(t_pCim32Net->GetWin9XUserInfo1Ex)((char*)TOBSTRT(chstrDomainName),(char*)TOBSTRT(Name), TRUE, HomeDirectory,Comment,ScriptPath,&PasswordAge,&Privileges,&Flags);
                if( fRc != 0 ) // 0 is NERR_Success
			    {
                    // try it again on the local computer...
                    fRc=(t_pCim32Net->GetWin9XUserInfo1Ex)(NULL,(char*)TOBSTRT(Name), FALSE, HomeDirectory,Comment,ScriptPath,&PasswordAge,&Privileges,&Flags);
                    chstrDomainAndUserName.Format(L"%s\\%s",(LPCWSTR)GetLocalComputerName(),(LPCWSTR)Name);
                    pInstance->SetCHString(L"Name",chstrDomainAndUserName);
                }
                else
                {
                    // overwrite the name with better info
                    chstrDomainAndUserName.Format(L"%s\\%s",(LPCWSTR)chstrDomainName,(LPCWSTR)Name);
                    pInstance->SetCHString(L"Name",chstrDomainAndUserName);
                }
            }
            else
            {
                fRc=(t_pCim32Net->GetWin9XUserInfo1Ex)(NULL,(char*)TOBSTRT(Name), FALSE, HomeDirectory,Comment,ScriptPath,&PasswordAge,&Privileges,&Flags);
                CHString chstrDomainAndUserName;
                chstrDomainAndUserName.Format(L"%s\\%s",(LPCWSTR)GetLocalComputerName(),(LPCWSTR)Name);
                pInstance->SetCHString(L"Name",chstrDomainAndUserName);
            }


            if(fRc == 0)
            {
				pInstance->SetCHString(L"HomeDirectory",HomeDirectory);
				pInstance->SetCHString(L"Comment",Comment);
				pInstance->SetCHString(L"ScriptPath",ScriptPath);

				if (0 != PasswordAge)
				{
					if (TIMEQ_FOREVER != PasswordAge)
					{
						WBEMTimeSpan wts = GetPasswordAgeAsWbemTimeSpan(PasswordAge);
                        pInstance->SetTimeSpan(L"PasswordAge", wts );
					}	// end if
				}

				pInstance->SetDWORD(L"Privileges",Privileges);
				pInstance->SetDWORD(L"Flags",Flags);
				if(Flags & UF_NORMAL_ACCOUNT) {
					pInstance->SetCHString(L"UserType",L"Normal Account") ;
				}
				else if(Flags & UF_TEMP_DUPLICATE_ACCOUNT) {
					pInstance->SetCHString(L"UserType",L"Duplicate Account") ;
				}
				else if(Flags & UF_WORKSTATION_TRUST_ACCOUNT) {
					pInstance->SetCHString(L"UserType",L"Workstation Trust Account" );
				}
				else if(Flags & UF_SERVER_TRUST_ACCOUNT) {
					pInstance->SetCHString(L"UserType",L"Server Trust Account") ;
				}
				else if(Flags & UF_INTERDOMAIN_TRUST_ACCOUNT) {
					pInstance->SetCHString(L"UserType",L"Interdomain Trust Account") ;
				}
				else {
					pInstance->SetCHString(L"UserType",L"Unknown") ;
				}
			}

			{
				char FullName[_MAX_PATH];
				memset( &FullName, NULL, _MAX_PATH ) ;

				char UserComment[_MAX_PATH];
				memset( &UserComment, NULL, _MAX_PATH ) ;

				TCHAR szBuff[_MAX_PATH];
				memset( &szBuff, NULL, _MAX_PATH ) ;

				char Parameters[_MAX_PATH];
				memset( &Parameters, NULL, _MAX_PATH ) ;

				char Workstations[_MAX_PATH];
				memset( &Workstations, NULL, _MAX_PATH ) ;

				char LogonServer[_MAX_PATH];
				memset( &LogonServer, NULL, _MAX_PATH ) ;

				LOGONDETAILS LogonDetails;
				memset(&LogonDetails,NULL,sizeof(LogonDetails));

                if(chstrDomainName.GetLength() > 0)
                {
                    fRc = (t_pCim32Net->GetWin9XUserInfo2Ex)((char*)TOBSTRT(chstrDomainName),(char*)TOBSTRT(Name),TRUE,FullName,
                    		                    UserComment, Parameters, Workstations,
							                    LogonServer, &LogonDetails );
                    // If that failed, try on local computer
                    if(fRc != 0)
                    {
                        (t_pCim32Net->GetWin9XUserInfo2Ex)(NULL,(char*)TOBSTRT(Name),FALSE,FullName,
                    		                        UserComment, Parameters, Workstations,
							                        LogonServer, &LogonDetails );
                    }
                }
                else
                {
                    (t_pCim32Net->GetWin9XUserInfo2Ex)(NULL,(char*)TOBSTRT(Name),FALSE,FullName,
                    		                        UserComment, Parameters, Workstations,
							                        LogonServer, &LogonDetails );
                }

				if( fRc == 0)
                {   // 0 is NERR_Success
					pInstance->SetCHString(L"FullName",FullName);

                    CHString chstrTemp, chstrTemp2;
                    if(strlen(FullName) > 0)
                    {
                        chstrTemp.Format(L"Network login profile settings for %s", (LPCWSTR)TOBSTRT(FullName));
                    }
                    if(chstrDomainName.GetLength() > 0)
                    {
                        chstrTemp2.Format(L" on %s", (LPCWSTR)chstrDomainName);
                        chstrTemp += chstrTemp2;
                    }
                    pInstance->SetCHString(IDS_Description,chstrTemp);

					pInstance->SetCHString(L"UserComment",UserComment);
					pInstance->SetCHString(L"Parameters",Parameters);
					pInstance->SetCHString(L"Workstations",Workstations);
					pInstance->SetCHString(L"LogonServer",LogonServer);
					pInstance->SetDWORD(L"AuthorizationFlags",LogonDetails.AuthorizationFlags);
                    if (TIMEQ_FOREVER != LogonDetails.LastLogon && 0 != LogonDetails.LastLogon)
                    {
					    pInstance->SetDateTime(L"LastLogon", (WBEMTime)LogonDetails.LastLogon);
                    }
                    if (TIMEQ_FOREVER != LogonDetails.LastLogoff && 0 != LogonDetails.LastLogoff)
                    {
					    pInstance->SetDateTime(L"LastLogoff", (WBEMTime)LogonDetails.LastLogoff );
                    }
					if (TIMEQ_FOREVER != LogonDetails.AccountExpires && 0 != LogonDetails.AccountExpires)
                    {
                        pInstance->SetDateTime(L"AccountExpires", (WBEMTime)LogonDetails.AccountExpires );
                    }

					pInstance->SetWBEMINT64(L"MaximumStorage", _i64tot(LogonDetails.MaximumStorage, szBuff, 10) );
					pInstance->SetDWORD(L"UnitsPerWeek",LogonDetails.UnitsPerWeek);
					CHString chsLogonHours;
					GetLogonHoursString(LogonDetails.LogonHours, chsLogonHours);
					pInstance->SetCHString(L"LogonHours", chsLogonHours);

					pInstance->SetDWORD(L"BadPasswordCount",LogonDetails.BadPasswordCount);
					pInstance->SetDWORD(L"NumberOfLogons",LogonDetails.NumberOfLogons);

					pInstance->SetDWORD(L"CountryCode", LogonDetails.CountryCode) ;
					pInstance->SetDWORD(L"CodePage", LogonDetails.CodePage) ;
				}
                else
                {
                    // still set the description...
                    CHString chstrTemp, chstrTemp2;
                    if( Name.GetLength() > 0)
                    {
                        chstrTemp.Format(L"Network login profile settings for %s", (LPCWSTR)TOBSTRT(Name));
                    }
                    if(chstrDomainName.GetLength() > 0)
                    {
                        CHString chstrTemp3 = chstrDomainAndUserName.SpanExcluding(L"\\");
                        chstrTemp2.Format(L" on %s", (LPCWSTR)chstrTemp3);
                        chstrTemp += chstrTemp2;
                    }
                    pInstance->SetCHString(IDS_Description,chstrTemp);

                }
			}
		}

	}
	catch ( ... )
	{
		if( t_pCim32Net != NULL )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net);
			t_pCim32Net = NULL;
		}

		throw ;
	}

	if( t_pCim32Net != NULL )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net);
		t_pCim32Net = NULL;
	}
}
#endif

void CWin32NetworkLoginProfile::GetLogonHoursString (PBYTE pLogonHours, CHString& chsProperty)
{
	CHString chsDayString;
	CHString chsTime;
	PBYTE pLogonBytes = pLogonHours;

	// copy the first byte into it's own spot.
	int iSaturdayByte = *pLogonHours;

	// advance the pointer to the first byte of Sunday.
	pLogonBytes++;

	int iBool, iByte, x, i, iBit;
	bool bLimited = false;
	bool bAccessDenied = true;
	DWORD dwByte = *pLogonHours;
	UINT nDayIndex = 0;
	WCHAR* rgDays[7] =
	{
		L"Saturday:",
		L"Sunday:",
		L"Monday:",
		L"Tuesday:",
		L"Wednesday:",
		L"Thursday:",
		L"Friday:"
	};

	int iLogonByte;
	bool rgHours[24];

	for (x=1;x<7 ;x++ )
	{
		// skip saturday until the end
		bLimited = false;
		bAccessDenied = true;
		for (i=0;i<24 ;i++ )
		{
			rgHours[i] = true;
		}

		iBool = 0;
		for (iByte=0; iByte<3; ++iByte)
		{
			iLogonByte = *pLogonBytes++;
			for (iBit=0; iBit<8; ++iBit)
			{
				rgHours[iBool] = iLogonByte & 1;
				iLogonByte >>= 1;
				++iBool;
			}
		}
		chsDayString = _T("");
		chsDayString += rgDays[x];
		chsDayString += _T(" ");

		for (i=0;i<24 ;i++ )
		{
			if (!rgHours[i])
			{
				bLimited = true;
			}
			else
			{
				bAccessDenied = false;
				chsTime = _T("");
				chsTime.Format(L"%d", i);
				chsTime = chsTime + _T("00, ");
				chsDayString += chsTime;
			}
		}
		if (!bLimited)
		{
			chsDayString = _T("");
			chsDayString += rgDays[x];
			chsDayString += _T(" ");
			chsDayString += _T("No Limit");
		}

		if (bAccessDenied)
		{
			chsDayString = _T("");
			chsDayString += rgDays[x];
			chsDayString += _T(" ");
			chsDayString += _T("Access Denied");
		}

		if (x < 7)
			chsDayString += _T(" -- ");

		chsProperty += chsDayString;
	}	// end stepping through week

	// now, we've got to do Saturday
	// step through the first byte ()
	iBool = 0;
//	iLogonByte = *pLogonBytes--;
	for (iByte=1;iByte<3 ;++iByte )
	{
		iLogonByte = *pLogonBytes++;
		for (iBit=0; iBit<8; ++iBit)
		{
			rgHours[iBool] = iLogonByte & 1;
			iLogonByte >>= 1;
			++iBool;
		}
	}

	// now step through the last byte that we held onto at the
	// beginning.
	for (iBit=0;iBit<8 ;++iBit )
	{
		rgHours[iBool] = iSaturdayByte & 1;
		iSaturdayByte >>=1;
		++iBool;
	}	// end for loop for last byte of Saturday

	// now, fill in day string with Saturday data
		chsDayString = _T("");
		chsDayString += rgDays[0];
		chsDayString += _T(" ");
		// reinitialize bLimited for Saturday
		bLimited = false;
		bAccessDenied = true;
		for (i=0;i<24 ;i++ )
		{
			if (!rgHours[i])
			{
				bLimited = true;
			}
			else
			{
				bAccessDenied = false;
				chsTime = _T("");
				chsTime.Format(L"%d", i);
				chsTime = chsTime + _T("00, ");
				chsDayString += chsTime;
			}
		}
		if (!bLimited)
		{
			chsDayString = _T("");
			chsDayString += rgDays[0];
			chsDayString += _T(" ");
			chsDayString += _T("No Limit");
		}

		if (bAccessDenied)
		{
			chsDayString = _T("");
			chsDayString += rgDays[0];
			chsDayString += _T(" ");
			chsDayString += _T("Access Denied");
		}

		chsProperty += chsDayString;
}

// converts the start and end time DWORDS from the USER_INFO_3 to CHStrings
// the dwords APPEAR to be minutes from midnight GMT.
CHString CWin32NetworkLoginProfile::StartEndTimeToDMTF(DWORD time)
{
	CHString gazotta;
	if ((time == 0))
	{
		gazotta = _T("**************.******+***");
	}
	else
	{
		int hour, minute;
		hour = time / 60;
		minute = time % 60;

		/************************
		_tzset();
		long tmptz = _timezone;

		// remove 60 minutes from the timezone if  daylight savings time
		if(_daylight) //NOTE: THIS WILL NOT WORK NEED TO USE tm struct's tm_isdst
		{
			tmptz -= 3600;
		}
		// convert to minutes
		tmptz /= 60;

		// what's your sign?
		char sign = '-';
		if (tmptz < 0)
		{
			tmptz = tmptz * -1;
			sign = '+';
		}
		***************************/

		//gazotta.Format("********%02d%02d00.000000%c%03d", hour, minute, sign, tmptz);
		gazotta.Format(L"********%02d%02d00.000000+000", hour, minute);
	}
	return gazotta;
}

WBEMTimeSpan CWin32NetworkLoginProfile::GetPasswordAgeAsWbemTimeSpan (DWORD dwSeconds)
{
	int nDays = 0;
	int nHours = 0;
	int nMinutes = 0;
	int nSeconds = 0;
	div_t time;

	if (dwSeconds > 60)
	{
		time = div(dwSeconds, 60);
		nMinutes = time.quot;
		nSeconds = time.rem;

		if (nMinutes > 60)
		{
			time = div(nMinutes, 60);
			nHours = time.quot;
			nMinutes = time.rem;

			if (nHours > 24)
			{
				time = div(nHours, 24);
				nDays = time.quot;
				nHours = time.rem;
			}
		}
	}

	// Create a WBEMTimeSpan with the above information
	return WBEMTimeSpan(nDays, nHours, nMinutes, nSeconds, 0, 0, 0);
}


bool CWin32NetworkLoginProfile::GetDomainName(CHString &a_chstrDomainName)
{
    bool t_fRet = false;
#ifdef WIN9XONLY
    CHString t_RegistryValue ;
	CRegistry t_RegInfo ;


	DWORD t_RegistryStatus = t_RegInfo.Open (

		HKEY_LOCAL_MACHINE,
		IDS_RegNetworkLogon,
		KEY_READ
	) ;

	if ( t_RegistryStatus == ERROR_SUCCESS )
	{
		t_RegistryStatus = t_RegInfo.GetCurrentKeyValue ( IDS_RegPrimaryProvider , t_RegistryValue ) ;
		if ( ! t_RegistryStatus )
		{
			if ( t_RegistryValue.CompareNoCase ( IDS_MicrosoftNetwork ) == 0 )
			{
// Microsoft Network is the primary provider

				t_RegistryStatus = t_RegInfo.Open (

					HKEY_LOCAL_MACHINE,
					IDS_RegNetworkProvider,
					KEY_READ
				) ;

				if ( t_RegistryStatus == ERROR_SUCCESS )
				{
					t_RegistryStatus = t_RegInfo.GetCurrentKeyValue ( IDS_RegAuthenticatingAgent , t_RegistryValue ) ;
					if ( ! t_RegistryStatus )
					{
						a_chstrDomainName = t_RegistryValue ;
                        t_fRet = true;
					}
				}
			}
		}
		else
		{
// We have no knowledge of other providers.
		}

		t_RegInfo.Close() ;
	}
#endif
#ifdef NTONLY
    CNetAPI32 NetAPI;
    DWORD dwError;
    if(NetAPI.Init() == ERROR_SUCCESS)
    {
#if NTONLY < 5
        LPBYTE lpbBuff = NULL;
        try
        {
            dwError = NetAPI.NetGetDCName(NULL, NULL, &lpbBuff);
        }
        catch(...)
        {
            if(lpbBuff != NULL)
            {
                NetAPI.NetApiBufferFree(lpbBuff);
                lpbBuff = NULL;
            }
            throw;
        }
        if(dwError == NO_ERROR)
        {
            a_chstrDomainName = (LPCWSTR)lpbBuff;
            NetAPI.NetApiBufferFree(lpbBuff);
            lpbBuff = NULL;
            t_fRet = true;
        }

#else
        PDOMAIN_CONTROLLER_INFO pDomInfo = NULL;
        try
        {
            dwError = NetAPI.DsGetDcName(NULL, NULL, NULL, NULL, DS_PDC_REQUIRED, &pDomInfo);
            if(dwError != NO_ERROR)
            {
                dwError = NetAPI.DsGetDcName(NULL, NULL, NULL, NULL, DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY, &pDomInfo);
            }
        }
        catch(...)
        {
            if(pDomInfo != NULL)
            {
                NetAPI.NetApiBufferFree(pDomInfo);
                pDomInfo = NULL;
            }
            throw;
        }
        if(dwError == NO_ERROR)
        {
            a_chstrDomainName = pDomInfo->DomainControllerName;
            NetAPI.NetApiBufferFree(pDomInfo);
            pDomInfo = NULL;
            t_fRet = true;
        }
#endif
    }
#endif
    return t_fRet;
}

#ifdef NTONLY
bool CWin32NetworkLoginProfile::GetLogonServer(CHString &a_chstrLogonServer)
{
    CRegistry RegInfo;
    CHString chstrTemp;
    bool fRet = false;



    DWORD dwRegStat = RegInfo.OpenCurrentUser(
		                           L"Volatile Environment",
		                           KEY_READ);
    if(dwRegStat == ERROR_SUCCESS)
    {
        dwRegStat = RegInfo.GetCurrentKeyValue(L"LOGONSERVER", chstrTemp);
        if(dwRegStat == ERROR_SUCCESS)
        {
            a_chstrLogonServer = chstrTemp;
            fRet = true;
        }
    }
    RegInfo.Close();

    return fRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\loginprofile.h ===
//=================================================================

//

// LogProf.h -- Network login profile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/24/97    jennymc        Moved to new framework
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_USERPROF L"Win32_NetworkLoginProfile"

typedef NET_API_STATUS (WINAPI *FREEBUFF) (LPVOID) ;
typedef NET_API_STATUS (WINAPI *ENUMUSER) (LPWSTR, DWORD, DWORD, LPBYTE *,
                                           DWORD, LPDWORD, LPDWORD, LPDWORD) ;   

class CWin32NetworkLoginProfile : public Provider{

    public:

        // Constructor/destructor
        //=======================

        CWin32NetworkLoginProfile(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32NetworkLoginProfile() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		void GetLogonHoursString (PBYTE pLogonHours, CHString& chsProperty);
		CHString StartEndTimeToDMTF(DWORD time);
		WBEMTimeSpan GetPasswordAgeAsWbemTimeSpan (DWORD dwSeconds);
        bool GetDomainName(CHString &a_chstrDomainName);
        
        // Utility
        //========
    private:
#ifdef WIN9XONLY
        HRESULT EnumInstancesWin9X(MethodContext * pMethodContext);
		void GetUserDetails( CInstance * pInstance,CHString Name );
#endif
#ifdef NTONLY
        void LoadLogProfValuesForNT(CHString &chstrUserDomainName, USER_INFO_3 *pUserInfo, USER_MODALS_INFO_0 * pUserModal, CInstance * pInstance, BOOL fAssignKey);
        HRESULT RefreshInstanceNT(CInstance * pInstance);
        HRESULT EnumInstancesNT(MethodContext * pMethodContext);
        bool GetLogonServer(CHString &a_chstrLogonServer);
#endif

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logonsession.h ===
//***************************************************************************

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  LogonSession.h
//
//  Purpose: Logon session property set provider
//
//***************************************************************************

#ifndef _LOGON_SESSION_H
#define _LOGON_SESSION_H

// into strings.h
extern LPCWSTR IDS_LogonId ;
extern LPCWSTR IDS_StartTime ;

//==================================
#define  PROPSET_NAME_LOGONSESSION      L"Win32_LogonSession"
#define  METHOD_NAME_TERMINATESESSION   L"TerminateSession"
#define  METHOD_ARG_NAME_RETURNVALUE	L"ReturnValue"


#define WIN32_LOGOFFOPTIONS (EWX_FORCE | EWX_FORCEIFHUNG)



// PROPERTY SET
//=============
class CWin32_LogonSession: public Provider
{
private:

	// property names 
    CHPtrArray m_pProps ;

	void SetPropertyTable() ; 
    
	HRESULT CWin32_LogonSession::GetSessionInfo(

		__int64		a_LUID,
		CInstance	*a_pInst,
		DWORD		a_dwProps,
        CUserSessionCollection& usc
	) ;

	HRESULT EnumerateInstances(

		MethodContext	*a_pMethodContext,
		long			a_Flags,
		DWORD			a_dwProps
	) ;



public:

    // Constructor/destructor
    //=======================

    CWin32_LogonSession( LPCWSTR a_Name, LPCWSTR a_Namespace ) ;
   ~CWin32_LogonSession() ;

    // Functions that provide properties with current values
    //======================================================

    HRESULT GetObject ( 
		
		CInstance *a_Instance,
		long a_Flags,
		CFrameworkQuery &a_rQuery
	) ;

    HRESULT EnumerateInstances ( 

		MethodContext *a_pMethodContext, 
		long a_Flags = 0L 
	) ;


	HRESULT ExecQuery ( 

		MethodContext *a_pMethodContext, 
		CFrameworkQuery &a_rQuery, 
		long a_Flags = 0L
	) ;

    

	// Property offset defines
	enum ePropertyIDs { 
		e_LogonId,						// Win32_LogonSession
		e_StartTime,					// Win32_Session
		e_Caption,						// CIM_ManagedSystemElement						
		e_Description,
		e_InstallDate,
		e_Name,						
		e_Status,
		e_End_Property_Marker,			// end marker
		e_32bit = 32					// gens compiler error if additions to this set >= 32 
	};
};

#endif // _LOGON_SESSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\main.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#define _WIN32_WINNT 0x0400
#include "precomp.h"
#include <objbase.h>
#include <locale.h>
#include "FactoryRouter.h"
#include <stdio.h>

extern BOOL APIENTRY DllMain (

	HINSTANCE hinstDLL,
	DWORD fdwReason,
	LPVOID lpReserved
) ;

// {d63a5850-8f16-11cf-9f47-00aa00bf345c}
DEFINE_GUID(CLSID_CimWinProvider,
0xd63a5850, 0x8f16, 0x11cf, 0x9f, 0x47, 0x0, 0xaa, 0x0, 0xbf, 0x34, 0x5c);

DWORD g_InstanceRegister = 0 ;
DWORD g_EventRegister = 0 ;

STDAPI DllRegisterServer () ;
STDAPI DllUnregisterServer () ;

BOOL s_Exiting = FALSE ;

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	long t_rc = 0 ;

	switch ( a_message )
	{
        case WM_CLOSE:
        {
            s_Exiting = TRUE ;
        }
        break ;

		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"Win32 Provider" ;

	WNDCLASS  t_wc ;

	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;

	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	ShowWindow ( t_HWnd, SW_SHOWMINIMIZED ) ;
//	ShowWindow ( t_HWnd, SW_HIDE ) ;

	return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
	CoUninitialize () ;
	DestroyWindow ( a_HWnd ) ;
}

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = NULL ;
	if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
	{
    }

	return t_HWnd ;
}

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;

        if ( s_Exiting )
            return ;
	}
}

HRESULT UninitComServer ()
{
	if ( g_InstanceRegister )
		CoRevokeClassObject ( g_InstanceRegister );

	if ( g_EventRegister )
		CoRevokeClassObject ( g_EventRegister );

	CFactoryRouter::UninitComServer() ;

	CoUninitialize () ;

	return S_OK ;
}

HRESULT InitInstanceProvider ()
{
	IUnknown *t_ClassFactory = new CWbemGlueFactory ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject (

		CLSID_CimWinProvider ,
		t_ClassFactory,
        t_ClassContext,
		t_Flags,
		&g_InstanceRegister
	);

	return t_Result ;
}

HRESULT InitEventProvider ()
{
	return t_Result ;
}

HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

		0,
		COINIT_MULTITHREADED
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CoInitializeSecurity (

			NULL,
			-1,
			NULL,
			NULL,
			a_AuthenticationLevel,
			a_ImpersonationLevel,
			NULL,
			EOAC_NONE,
			0
		);

		if ( FAILED ( t_Result ) )
		{
			CoUninitialize () ;
			return t_Result ;
		}

	}

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitInstanceProvider () ;

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitEventProvider () ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CFactoryRouter::InitComServer() ;
	}

	if ( FAILED ( t_Result ) )
	{
		UninitComServer () ;
	}

	return t_Result  ;
}

HRESULT Process ()
{
#if 1
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
#else
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTITY ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE ;
#endif

	HRESULT t_Result = InitComServer ( t_ImpersonationLevel , t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WindowsDispatch () ;
		UninitComServer () ;
	}

	return t_Result ;
}

BOOL ParseCommandLine ()
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;
		if ( t_Arg )
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllRegisterServer () ;
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllUnregisterServer () ;
			}
		}
	}

	return t_Exit ;
}

int WINAPI WinMain (

    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
	BOOL t_Status = DllMain (

		hInstance,
		DLL_PROCESS_ATTACH ,
		NULL
	) ;

	BOOL t_Exit = ParseCommandLine () ;
	if ( ! t_Exit )
	{
		HWND hWnd = WindowsStart ( hInstance ) ;

		HRESULT t_Result = Process () ;

		WindowsStop ( hWnd ) ;
	}

	t_Status = DllMain (

		hInstance,
		DLL_PROCESS_DETACH ,
		NULL
	) ;

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\modem.cpp ===
///////////////////////////////////////////////////////////////////////

//

// MODEM.CPP

//

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//  9/05/96     jennymc     Updated to meet current standards
//  1/11/98     a-brads		Updated to CIMOM V2 standards
//
///////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <cominit.h>
#include <cregcls.h>

#define TAPI_CURRENT_VERSION 0x00030000
#include <tapi.h>

#include <lockwrap.h>
#include "DllWrapperBase.h"
#include "TapiApi.h"

#include "Modem.h"

///////////////////////////////////////////////////////////////////////
CWin32Modem MyModemSet(PROPSET_NAME_MODEM, IDS_CimWin32Namespace);

///////////////////////////////////////////////////////////////////////
VOID FAR PASCAL lineCallback(	DWORD dwDevice,
								DWORD dwMsg,
                                DWORD_PTR dwCallbackInst,
								DWORD_PTR dwParam1,
                                DWORD_PTR dwParam2,
								DWORD_PTR dwParam3){};

//////////////////////////////////////////////////////////////////
//
//  Function:      CWin32Modem
//
//  Description:   This function is the constructor, adds a
//                 few more properties to the class, identifies
//                 the key, and logs into the framework
//
//  Return:        None
//
//  History:
//         jennymc  11/21/96    Documentation/Optimization
//
//////////////////////////////////////////////////////////////////
CWin32Modem::CWin32Modem (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider (name , pszNamespace)
{
}

//////////////////////////////////////////////////////////////////
CWin32Modem::~CWin32Modem()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Modem::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32Modem::ExecQuery (

	MethodContext *pMethodContext,
	CFrameworkQuery &query,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

   	CTapi32Api *pTapi32Api = (CTapi32Api *)CResourceManager::sm_TheResourceManager.GetResource (g_guidTapi32Api, NULL) ;
	if (pTapi32Api)
	{
		if (query.KeysOnly())
		{
			hr =
                GetModemInfo (
				    *pTapi32Api ,
				    ENUMERATE_INSTANCES | QUERY_KEYS_ONLY,
				    pMethodContext,
				    NULL,
                    NULL) ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
		}
		else
		{
			hr = WBEM_E_PROVIDER_NOT_CAPABLE;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidTapi32Api , pTapi32Api) ;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////
//
//  Function:      GetObject
//
//  Description:   This function assigns values to properties
//                 in our set for a single instance.
//
//  Return:        HRESULT
//
//  History:
//         jennymc  11/21/96    Documentation/Optimization
//
//////////////////////////////////////////////////////////////////

HRESULT CWin32Modem::GetObject (CInstance *pInstance, long lFlags, CFrameworkQuery &query)
{
	BOOL bRetCode = FALSE;
	HRESULT t_Result = WBEM_S_NO_ERROR ;
    DWORD dwParms;

	if (query.KeysOnly())
    {
        dwParms = REFRESH_INSTANCE | QUERY_KEYS_ONLY;
    }
    else
    {
        dwParms = REFRESH_INSTANCE;
    }

  	CTapi32Api *pTapi32Api = (CTapi32Api *) CResourceManager::sm_TheResourceManager.GetResource (g_guidTapi32Api, NULL) ;
	if (pTapi32Api)
	{
		CHString deviceID;
		if (pInstance->GetCHString (IDS_DeviceID , deviceID))
		{
			bRetCode = GetModemInfo (

				*pTapi32Api ,
				dwParms,
				NULL,
				pInstance,
				deviceID
			) ;
		}

		if (bRetCode)
		{
			t_Result = WBEM_S_NO_ERROR ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidTapi32Api , pTapi32Api) ;
	}

	return t_Result ;
}

//////////////////////////////////////////////////////////////////
//
//  Function:      CWin32Modem::EnumerateInstances
//
//  Description:   This function gets info for all modems
//
//  Return:        Number of instances
//
//  History:
//         jennymc  11/21/96    Documentation/Optimization
//
//////////////////////////////////////////////////////////////////
HRESULT CWin32Modem::EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	BOOL bRetCode = FALSE;

  	CTapi32Api *pTapi32Api = (CTapi32Api *) CResourceManager::sm_TheResourceManager.GetResource (g_guidTapi32Api, NULL) ;
	if (pTapi32Api)
	{

	// Note that we don't get the tapi stuff here since that is considered
	// 'expensive.'

		bRetCode = GetModemInfo (

			*pTapi32Api,
			ENUMERATE_INSTANCES,
			pMethodContext,
			NULL,
            NULL
		) ;

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidTapi32Api , pTapi32Api) ;
	}

	if (bRetCode)
	{
		return WBEM_S_NO_ERROR ;
	}
	else
	{
		return WBEM_E_NOT_FOUND ;
	}
}

//////////////////////////////////////////////////////////////////

#ifdef WIN9XONLY
#define MODEM_KEY   WIN95_MODEM_REGISTRY_KEY
#endif
#ifdef NTONLY
#define MODEM_KEY   WINNT_MODEM_REGISTRY_KEY
#endif

BOOL CWin32Modem::GetModemInfo (

	CTapi32Api &a_Tapi32Api ,
	DWORD dwWhatToDo,
	MethodContext *pMethodContext,
	CInstance *pParmInstance,
	LPCWSTR szDeviceID
)
{
    BOOL        bRet = FALSE,
                bDone,
                bAnother;
    CRegistry   regModem;
    CInstancePtr
                pInstance;
	HRESULT     hr = WBEM_S_NO_ERROR;
    int         iModem = 0;

	// regModem will contain one entry for each modem.
	if (regModem.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, MODEM_KEY, KEY_READ) != ERROR_SUCCESS)
	{
		return FALSE;
	}

	// bDone is for GetObject when we have found the correct entry
	// bAnother indicates if there is another entry in the registry
	bDone = FALSE;
	bAnother = (regModem.GetCurrentSubKeyCount() > 0);
	for ( ;
        !bDone && bAnother && SUCCEEDED(hr);
        bAnother = (regModem.NextSubKey() == ERROR_SUCCESS))
	{
        DWORD    dwModemIndex;
        CHString strKey,
	             strDriverName,	    // ConfigMngr key name
	             strDriverNumber,	// driver number
                 strPortName,       // Used for PCMCIA modems (won't have AttachedTo).
	             strDeviceID;	    // deviceID returned from ConfigManager

		regModem.GetCurrentSubKeyPath(strKey);
		dwModemIndex = _wtol(strKey.Right(4));
		strDriverNumber = strKey.Right(4);

#ifdef WIN9XONLY
        strDriverName = L"MODEM\\";
#endif
#ifdef NTONLY
		strDriverName = WINNT_MODEM_CLSID;
		strDriverName += L"\\";
#endif
		strDriverName += strDriverNumber;	// this should be a 4 digit number

		// now, using this data, get the values out of the configmanager.
		CConfigManager      configMngr;
		CDeviceCollection   devCollection;
        CConfigMgrDevicePtr pDevice;

		if (configMngr.GetDeviceListFilterByDriver(devCollection, strDriverName))
		{
			REFPTR_POSITION pos;

			devCollection.BeginEnum(pos);

			for (pDevice.Attach(devCollection.GetNext(pos));
                pDevice != NULL;
                pDevice.Attach(devCollection.GetNext(pos)))
			{
				pDevice->GetDeviceID(strDeviceID);
                pDevice->GetRegStringProperty( L"PORTNAME", strPortName);

                break;
			}
		}

        // If we don't have a device ID (like in the case where the modem is
        // installed but config mgr isn't reporting it), make up a device ID.
        if (strDeviceID.IsEmpty())
            strDeviceID.Format(L"Modem%d", iModem++);

        CRegistry regPrimary,
                  regSettings;

		if (regPrimary.Open(HKEY_LOCAL_MACHINE, strKey, KEY_READ) != ERROR_SUCCESS)
		{
			return FALSE;
		}

        strKey += L"\\Settings";

		if (regSettings.Open(HKEY_LOCAL_MACHINE, strKey, KEY_READ) != ERROR_SUCCESS)
		{
			return FALSE;
		}

        // If we are doing GetObject and this is the Object
		if (dwWhatToDo & REFRESH_INSTANCE)
		{
            // Don't do an attach here.  We need the addref()
			pInstance = pParmInstance ;

			if (0 == strDeviceID.CompareNoCase(szDeviceID))
			{
				pInstance->SetDWORD(IDS_Index, dwModemIndex);

				bDone = TRUE;
                bRet = TRUE;
			}
			else
			{
				continue;
			}
		}
		else
		{
			// We are doing an enum, create a new instance
			pInstance.Attach (CreateNewInstance (pMethodContext)) ;
			if (pInstance != NULL)
            {
			    bRet = TRUE;
                pInstance->SetDWORD(IDS_Index, dwModemIndex);
                pInstance->SetCHString(L"DeviceID", strDeviceID);
            }
            else
                bRet = FALSE;
		}

		// The nt and win95 registries contain different info
        if (bRet && !(dwWhatToDo & QUERY_KEYS_ONLY))
        {
#ifdef WIN9XONLY
            bRet =
                Win95SpecificRegistryValues(
                    pInstance,
                    &regPrimary,
                    &regSettings);
#endif
#ifdef NTONLY
            bRet =
                NTSpecificRegistryValues(
                    pInstance,
                    &regPrimary,
                    &regSettings);
#endif
        }

		// Some registry entries are the same
        if (bRet && !(dwWhatToDo & QUERY_KEYS_ONLY))
		{
			AssignCommonFields(pInstance, &regPrimary, &regSettings);

            // Call this even if pDevice is NULL.
            AssignCfgMgrFields(pInstance, pDevice);

            // PCMCIA modems don't have the 'AttachedTo' registry string,
            // so use the 'PortName' string instead.
            if (!strPortName.IsEmpty())
			{
                pInstance->SetCharSplat(L"AttachedTo", strPortName);
			}

            // Only get the expensive ones if we have to.
			if (!(dwWhatToDo & QUERY_KEYS_ONLY))
			{
	   			GetFieldsFromTAPI ( a_Tapi32Api , pInstance ) ;
			}
		}

		// If enum and if everything went all right, commit
		if (dwWhatToDo & ENUMERATE_INSTANCES)
		{
			if (bRet)
			{
				hr = pInstance->Commit();
			}
		}
	}	// end for loop

	// If getobject and didn't find it
	if ((dwWhatToDo & REFRESH_INSTANCE) && !bRet)
	{
		return FALSE;
	}

	return SUCCEEDED(hr);
}

///////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32Modem::NTSpecificRegistryValues(

	CInstance *pInstance,
	CRegistry *pregPrimary,
	CRegistry *regSettings
)
{
    CHString strTmp;
    CRegistry reg;
	DWORD dwSpeed;

    // Compatibility Flags
    if (pregPrimary->GetCurrentBinaryKeyValue(COMPATIBILITY_FLAGS, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_CompatibilityFlags, strTmp);

    if (pregPrimary->GetCurrentKeyValue(L"MaximumPortSpeed", dwSpeed) == ERROR_SUCCESS)
    {
        pInstance->SetDWORD(IDS_MaxTransmissionSpeed, dwSpeed);
    }
    else
    {
        // The default is 115200, which the os will use
        // until a user changes the port speed.  If the
        // user changes the speed, the MaximumPortSpeed
        // key is added.  Until the speed is changed,
        // however, there is no such key and the default
        // value of 115200 is used.  Hence, if we don't
        // see the key, report the default ourselves...
        pInstance->SetDWORD(IDS_MaxTransmissionSpeed, 115200);
    }

    // ResponsesKeyName
    if (pregPrimary->GetCurrentKeyValue(RESPONSESKEYNAME, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ResponsesKeyName, strTmp);

    // Name
    if (pregPrimary->GetCurrentKeyValue(FRIENDLY_NAME, strTmp) == ERROR_SUCCESS)
		pInstance->SetCHString(IDS_Name, strTmp);

    return TRUE;
}
#endif

//////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
BOOL CWin32Modem::Win95SpecificRegistryValues (

    CInstance *pInstance,
    CRegistry *pregPrimary,
    CRegistry *pregSettings
)
{
    CHString strTemp;

    // DevLoader
    if (pregPrimary->GetCurrentKeyValue(DEV_LOADER, strTemp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_DeviceLoader, strTemp);

    // Name
    if (pregPrimary->GetCurrentKeyValue(FRIENDLY_DRIVER, strTemp) == ERROR_SUCCESS)
		pInstance->SetCHString(IDS_Name, strTemp);

    return TRUE;
}
#endif

//////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::AssignCommonDeviceType (

	CInstance *pInstance,
	CRegistry *regPrimary,
	CRegistry *regSettings
)
{
    DWORD		dwValue = 0;
    CHString	strTmp;

    if (regPrimary->GetCurrentBinaryKeyValue(DEVICE_TYPE_STR, strTmp) != ERROR_SUCCESS)
        return FALSE;

	// The string MUST be in the format: "0n", where n is a digit 0 - 3.

	// Set the Modem device type if it is known, otherwise just drop out
	// with an error.

	BOOL fKnownType = TRUE;

	if (strTmp.CompareNoCase(DT_NULL_MODEM) == 0)
	{
		 pInstance->SetCHString(IDS_DeviceType, NULL_MODEM);
	}
	else if (strTmp.CompareNoCase(DT_INTERNAL_MODEM) == 0)
	{
		 pInstance->SetCHString(IDS_DeviceType, INTERNAL_MODEM);
	}
	else if (strTmp.CompareNoCase(DT_EXTERNAL_MODEM) == 0)
	{
		 pInstance->SetCHString(IDS_DeviceType, EXTERNAL_MODEM);
	}
	else if (strTmp.CompareNoCase(PCMCIA_MODEM) == 0)
	{
		 pInstance->SetCHString(IDS_DeviceType, PCMCIA_MODEM);
	}
	else
	{
		fKnownType = FALSE;
        LogErrorMessage(ERR_INVALID_MODEM_DEVICE_TYPE);
		pInstance->SetCHString(IDS_DeviceType, UNKNOWN_MODEM);
	}

    return fKnownType;
}

//////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::AssignCommonFields (

	CInstance *pInstance,
	CRegistry *pregPrimary,
	CRegistry *pregSettings
)
{
    CHString strTmp;
    CRegistry reg;
    void *vptr;

    ///////////////////////////////////////////////////////
    // Fields from the Settings subkey

    // Prefix
    if (pregSettings->GetCurrentKeyValue(PREFIX, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Prefix, strTmp);

    // Pulse
    if (pregSettings->GetCurrentKeyValue(PULSE, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Pulse, strTmp);

    // Terminator
    if (pregSettings->GetCurrentKeyValue(TERMINATOR, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Terminator, strTmp);

    // Tone
    if (pregSettings->GetCurrentKeyValue(TONE, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Tone, strTmp);

    // Blind_Off
    if (pregSettings->GetCurrentKeyValue(BLIND_OFF, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_BlindOff, strTmp);

    // Blind_On
    if (pregSettings->GetCurrentKeyValue(BLIND_ON, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_BlindOn, strTmp);

    // InactivityTimeout
    if (pregSettings->GetCurrentKeyValue(INACTIVITYTIMEOUT, strTmp) == ERROR_SUCCESS)
    {
        INT i = _wtoi(strTmp);
        // per spec -1 isn't supported.  Not sure if this ever really gets put in the
        // registry, but whatever.
        if (i != -1)
        {
            pInstance->SetDWORD(IDS_InactivityTimeout, i);
        }
    }

    // Modulation_Bell
    if (pregSettings->GetCurrentKeyValue(MODULATION_BELL, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ModulationBell, strTmp);

    // Modulation_CCITT
    if (pregSettings->GetCurrentKeyValue(MODULATION_CCITT, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ModulationCCITT, strTmp);

    // SpeakerMode_Dial
    if (pregSettings->GetCurrentKeyValue(SPEAKERMODE_DIAL, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerModeDial, strTmp);

    // SpeakerMode_Off
    if (pregSettings->GetCurrentKeyValue(SPEAKERMODE_OFF, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerModeOff, strTmp);

    // SpeakerMode_On
    if (pregSettings->GetCurrentKeyValue(SPEAKERMODE_ON, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerModeOn, strTmp);

    // SpeakerMode_Setup
    if (pregSettings->GetCurrentKeyValue(SPEAKERMODE_SETUP, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerModeSetup, strTmp);

    // SpeakerMode_High
    if (pregSettings->GetCurrentKeyValue(SPEAKERVOLUME_HIGH, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerVolumeHigh, strTmp);

    // SpeakerMode_Low
    if (pregSettings->GetCurrentKeyValue(SPEAKERVOLUME_LOW, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerVolumeLow, strTmp);

    // SpeakerMode_Med
    if (pregSettings->GetCurrentKeyValue(SPEAKERVOLUME_MED, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_SpeakerVolumeMed, strTmp);

    // Compression_On
    if (pregSettings->GetCurrentKeyValue(COMPRESSION_ON, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_CompressionOn, strTmp);

    // Compression_Off
    if (pregSettings->GetCurrentKeyValue(COMPRESSION_OFF, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_CompressionOff, strTmp);

    // ErrorControl_Forced
    if (pregSettings->GetCurrentKeyValue(ERRORCONTROL_FORCED, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ErrorControlForced, strTmp);

    // ErrorControl_Off
    if (pregSettings->GetCurrentKeyValue(ERRORCONTROL_OFF, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ErrorControlOff, strTmp);

    // ErrorControl_On
    if (pregSettings->GetCurrentKeyValue(ERRORCONTROL_ON, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ErrorControlOn, strTmp);

    // FlowControl_Hard
    if (pregSettings->GetCurrentKeyValue(FLOWCONTROL_HARD, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_FlowControlHard, strTmp);

    // FlowControl_Off
    if (pregSettings->GetCurrentKeyValue(FLOWCONTROL_OFF, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_FlowControlOff, strTmp);

    // FlowControl_Soft
    if (pregSettings->GetCurrentKeyValue(FLOWCONTROL_SOFT, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_FlowControlSoft, strTmp);

    ///////////////////////////////////////////////////////
    // Fields from the primary key

    // DriverDate
    if (pregPrimary->GetCurrentKeyValue(DRIVER_DATE, strTmp) == ERROR_SUCCESS)
	{
		CHString strDate;

        if (ToWbemTime(strTmp, strDate))
			pInstance->SetCharSplat(IDS_DriverDate, strDate);
	}

    // InactivityScale
    if (pregPrimary->GetCurrentBinaryKeyValue(INACTIVITY_SCALE, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_InactivityScale, strTmp);

    // ProviderName
    if (pregPrimary->GetCurrentKeyValue(PROVIDERNAME, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ProviderName, strTmp);

    // InfPath
    if (pregPrimary->GetCurrentKeyValue(INFPATH, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ModemInfPath, strTmp);

    // InfSection
    if (pregPrimary->GetCurrentKeyValue(INFSECTION, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ModemInfSection, strTmp);

    // Model
    if (pregPrimary->GetCurrentKeyValue(MODEL, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Model, strTmp);

    // PortSubClass
    if (pregPrimary->GetCurrentBinaryKeyValue(PORTSUBCLASS, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_PortSubClass, strTmp);

    // VoiceSwitchFeature
    if (pregPrimary->GetCurrentBinaryKeyValue(VOICE_SWITCH_FEATURE, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_VoiceSwitchFeature, strTmp);

    // Properties
    if (pregPrimary->GetCurrentKeyValue(PROPERTIES, strTmp) == ERROR_SUCCESS)
	{
        _variant_t      vValue;
        SAFEARRAYBOUND  rgsabound[1];

        // Create the array
        rgsabound[0].cElements = strTmp.GetLength();
        rgsabound[0].lLbound = 0;

        V_ARRAY(&vValue) = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (V_ARRAY (&vValue) == NULL)
		{
			throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR) ;
		}

		V_VT(&vValue) = VT_UI1 | VT_ARRAY;

        // Put the data in
        SafeArrayAccessData(V_ARRAY(&vValue), &vptr);
        memcpy(vptr, strTmp, rgsabound[0].cElements);
        SafeArrayUnaccessData(V_ARRAY(&vValue));

        pInstance->SetVariant(IDS_Properties, vValue);
    }

    // Reset
    if (pregPrimary->GetCurrentKeyValue(RESET, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_Reset, strTmp);

    // Description
    if (pregPrimary->GetCurrentKeyValue(DRIVER_DESC, strTmp) == ERROR_SUCCESS)
    {
        pInstance->SetCHString(IDS_Description, strTmp);
        pInstance->SetCHString(IDS_Caption, strTmp);
    }

    // AttachedTo
    if (pregPrimary->GetCurrentKeyValue(ATTACHED_TO, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_AttachedTo, strTmp);

    // Config Dialog
    if (pregPrimary->GetCurrentKeyValue(CONFIG_DIALOG, strTmp) == ERROR_SUCCESS)
        pInstance->SetCHString(IDS_ConfigurationDialog, strTmp);

    // DCB
    if (pregPrimary->GetCurrentKeyValue(_DCB, strTmp) == ERROR_SUCCESS)
	{
        variant_t      vValue;
        SAFEARRAYBOUND rgsabound[1];

        // Create the array
        rgsabound[0].cElements = strTmp.GetLength();
        rgsabound[0].lLbound = 0;


        V_ARRAY(&vValue) = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (V_ARRAY (&vValue) == NULL)
		{
			throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR) ;
		}

		V_VT(&vValue) = VT_UI1 | VT_ARRAY;

        // Put the data in
        SafeArrayAccessData(V_ARRAY(&vValue), &vptr);
        memcpy(vptr, strTmp, rgsabound[0].cElements);
        SafeArrayUnaccessData(V_ARRAY(&vValue));

        pInstance->SetVariant(IDS_DCB, vValue);
    }

    // Default
    if (pregPrimary->GetCurrentKeyValue(DEFAULT, strTmp) == ERROR_SUCCESS)
	{
        variant_t      vValue;
        SAFEARRAYBOUND rgsabound[1];

		// Create the array
        rgsabound[0].cElements = strTmp.GetLength();
        rgsabound[0].lLbound = 0;


        V_ARRAY(&vValue) = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (V_ARRAY (&vValue) == NULL)
		{
			throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR) ;
		}

		V_VT(&vValue) = VT_UI1 | VT_ARRAY;

        // Put the data in
        SafeArrayAccessData(V_ARRAY(&vValue), &vptr);
        memcpy(vptr, strTmp, rgsabound[0].cElements);
        SafeArrayUnaccessData(V_ARRAY(&vValue));

        pInstance->SetVariant(IDS_Default, vValue);
    }

    // DeviceType
    AssignCommonDeviceType(pInstance, pregPrimary, pregSettings);

    // Easy properties
    pInstance->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
	pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());
	SetCreationClassName(pInstance);
	pInstance->Setbool(IDS_PowerManagementSupported, FALSE);

    // Country
    DWORD dwID;

    if (reg.Open(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations",
        KEY_READ) == ERROR_SUCCESS &&
        reg.GetCurrentKeyValue(L"CurrentID", dwID) == ERROR_SUCCESS)
    {
        CHString    strKey;
        DWORD       dwCountry;

#if !defined(NTONLY) || NTONLY < 5
        // Everyone but NT5 subtracts 1 from this ID first.
        dwID--;
#endif

        strKey.Format(
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"
            L"\\Location%d", dwID);

        if (reg.Open(
            HKEY_LOCAL_MACHINE,
            strKey,
            KEY_READ) == ERROR_SUCCESS &&
            reg.GetCurrentKeyValue(L"Country", dwCountry) == ERROR_SUCCESS)
        {
            CHString strCountry;

            strKey.Format(
                L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\"
                L"Country List\\%d", dwCountry);

            if (reg.OpenLocalMachineKeyAndReadValue(
                strKey,
                L"Name",
                strCountry) == ERROR_SUCCESS)
            	pInstance->SetCHString(L"CountrySelected", strCountry);
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::AssignCfgMgrFields (

    CInstance *pInstance,
    CConfigMgrDevice *pDevice
)
{
    // 2 means we don't know if the device is enabled or not.
    DWORD       dwStatusInfo = 2;
    CHString    strInfo = L"Unknown";

    if (pDevice)
    {
        CHString strTemp;

        SetConfigMgrProperties(pDevice, pInstance);

	    if (pDevice->GetStatus(strInfo))
	    {
	        if (strInfo == L"OK")
		    {
                // Means the device is enabled.
                dwStatusInfo = 3;
	        }
        }
    }

    pInstance->SetCHString(L"Status", strInfo);
    pInstance->SetDWORD(L"StatusInfo", dwStatusInfo);

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::GetFieldsFromTAPI (

	CTapi32Api &a_Tapi32Api ,
	CInstance *pInstance
)
{
    HLINEAPP      hLineApp = NULL;
    LINEDEVCAPS * pLineDevCaps = NULL;
    BOOL bRet = FALSE;

	try
	{
		CHString t_DeviceIdentifier ;

        // Can't use GetCHString directly because it ASSERTs and records an
        // error if the value is null.
        if (pInstance->IsNull(L"AttachedTo"))
		{
			return FALSE;
		}

		pInstance->GetCHString(L"AttachedTo", t_DeviceIdentifier);
		DWORD t_NumberOfTapiDevices ;

		if ( InitializeTAPI ( a_Tapi32Api , &hLineApp , t_NumberOfTapiDevices ) )
		{
			if ( GetModemInfoFromTAPI ( a_Tapi32Api, & hLineApp, t_DeviceIdentifier , t_NumberOfTapiDevices , pLineDevCaps ) )
			{
			  // TAPI field:  MaxSpeed

				pInstance->SetDWORD ( IDS_MaxTransmissionSpeedToPhone , pLineDevCaps->dwMaxRate ) ;

			  // TAPI field:  StringFormat

				switch ( pLineDevCaps->dwStringFormat )
				{
					case STRINGFORMAT_ASCII:
					{
						pInstance->SetCharSplat(IDS_StringFormat, ASCII_STRING);
					}
					break;

					case STRINGFORMAT_DBCS:
					{
						pInstance->SetCharSplat(IDS_StringFormat, DBCS_STRING);
					}
					break;

					case STRINGFORMAT_UNICODE:
					{
						pInstance->SetCharSplat(IDS_StringFormat, UNICODE_STRING);
					}
					break;
				}

				bRet = TRUE;
			}
		}
	}
	catch (...)
	{
		if (hLineApp)
		{
			ShutDownLine (a_Tapi32Api , & hLineApp) ;
			hLineApp = NULL ;
		}

		if (pLineDevCaps)
		{
			delete [] ((char *) pLineDevCaps) ;
			pLineDevCaps = NULL ;
		}

		throw ;
	}

	if (hLineApp)
	{
		ShutDownLine (a_Tapi32Api , & hLineApp) ;
		hLineApp = NULL ;
	}

	if (pLineDevCaps)
	{
		delete [] (PCHAR) pLineDevCaps ;
		pLineDevCaps = NULL ;
	}

	return bRet ;
}

///////////////////////////////////////////////////////////////////////
//  The TAPI Stuff
///////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::InitializeTAPI (

	CTapi32Api &a_Tapi32Api ,
	HLINEAPP *hLineApp ,
	DWORD &a_NumberOfTapiDevices
)
{
	LONG lRc;
	HMODULE hInstance = GetModuleHandle (NULL);
    char szAppName[20] = "modem"; // DONOT change to TCHAR.
    BOOL bTryReInit = TRUE;

    // initialize application's use of the telephone API
	//==================================================
    do
	{
		lRc = a_Tapi32Api.lineInitialize (

			hLineApp,
			hInstance,
			lineCallback,
            szAppName,
			&a_NumberOfTapiDevices
		) ;

		// If we get this error, its because some other app has yet
        // to respond to the REINIT message.  Wait 5 seconds and try
        // again.  If it still doesn't respond, tell the user.
		//===========================================================
        if (lRc == LINEERR_REINIT)
		{
             if (bTryReInit)
			 {
                  Sleep(5000);
                  bTryReInit = FALSE;
                  continue;
             }
			 else
			 {
				 LogErrorMessage(ERR_TAPI_REINIT);
                 return(FALSE);
			 }
        }
		else if (lRc  == LINEERR_NODEVICE)
		{
            return FALSE;
		}
		else if (lRc < 0)
		{
			if (IsErrorLoggingEnabled())
			{
				CHString msg;
				msg.Format(ERR_TAPI_INIT, lRc);
				LogErrorMessage(msg);
			}

            return FALSE;
		}
		else
		{
            return TRUE;
		}

	} while (lRc != 0);

    return TRUE;
}

///////////////////////////////////////////////////////////////////////
void CWin32Modem::ShutDownLine (

	CTapi32Api &a_Tapi32Api ,
	HLINEAPP *phLineApp
)
{
    long lRc;

    if (*phLineApp)
	{
	    lRc = a_Tapi32Api.lineShutdown (*phLineApp);
        if (lRc < 0)
		{
			if (IsErrorLoggingEnabled())
			{
				CHString foo;
				foo.Format(ERR_TAPI_SHUTDOWN, lRc);
				LogErrorMessage(foo);
			}
        }
        *phLineApp = 0;
    }
}

///////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::GetModemInfoFromTAPI (

	CTapi32Api &a_Tapi32Api ,
	HLINEAPP *a_LineApp,
	CHString &a_DeviceIdentifier ,
	DWORD &a_NumberOfTapiDevices,
	LINEDEVCAPS *&ppLineDevCaps
)
{
    BOOL bRet = FALSE ;

	// negotiate the line API version

	for ( DWORD t_Index = 0 ; t_Index < a_NumberOfTapiDevices ; t_Index ++ )
	{
		LINEEXTENSIONID t_LineExtension;
		DWORD t_Version = 0;

		LONG lRc = a_Tapi32Api.lineNegotiateAPIVersion (

			*a_LineApp,
			t_Index,
			APILOWVERSION,
			APIHIVERSION,
			& t_Version ,
			& t_LineExtension
		) ;

		if ( lRc == 0 )
		{
			// Get the modem capability values into an allocated block of memory. The memory block
			// is at the size of dwNeededSize which guaranties to receive all of the information from
			// the call to the lineGetDevCaps.

		   ppLineDevCaps = GetModemCapabilityInfoFromTAPI (

			   a_Tapi32Api,
			   a_LineApp,
			   t_Index,
			   t_Version
			) ;

			if ( ppLineDevCaps )
			{
				try
				{
					if ( ppLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM )
					{
						HLINE t_Line ;

						LONG t_Status = a_Tapi32Api.TapilineOpen (

							*a_LineApp,
							t_Index ,
							& t_Line ,
							t_Version,
							0,
							0 ,
							LINECALLPRIVILEGE_NONE ,
							LINEMEDIAMODE_DATAMODEM,
							NULL
						);

						if ( t_Status == 0 )
						{
							VARSTRING *t_VarString = ( VARSTRING * ) new BYTE [ sizeof ( VARSTRING ) + 1024 ] ;
							if ( t_VarString )
							{
								try
								{
									t_VarString->dwTotalSize = sizeof ( VARSTRING ) + 1024 ;

									t_Status = a_Tapi32Api.TapilineGetID (

										t_Line,
										0,
										0,
										LINECALLSELECT_LINE ,
										t_VarString ,
										_T("comm/datamodem/portname")
									);

									if ( t_Status == 0 )
									{
										CHString t_Port ( ( char * ) ( ( BYTE * ) t_VarString + t_VarString->dwStringOffset ) ) ;

										if ( a_DeviceIdentifier.CompareNoCase ( t_Port ) == 0 )
										{
											delete [] ((BYTE *)t_VarString) ;
											t_VarString = NULL ;

											return TRUE;
										}
									}
								}
								catch ( ... )
								{
									if ( t_VarString )
									{
										delete [] ((BYTE *)t_VarString) ;
									}

									throw ;
								}

								delete [] ((BYTE *)t_VarString) ;
								t_VarString = NULL ;
							}
							else
							{
								throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR) ;
							}
						}
					}
				}
				catch ( ... )
				{
					delete [] ((char *)ppLineDevCaps) ;
					ppLineDevCaps = NULL;
					throw ;
				}
			}
			else
			{
				if ( IsErrorLoggingEnabled())
				{
					CHString foo;
					foo.Format(ERR_LINE_GET_DEVCAPS, lRc, t_Index);
					LogErrorMessage(foo);

					bRet = FALSE;
					break ;
				}
			}

			delete [] ((char *)ppLineDevCaps) ;
			ppLineDevCaps = NULL;
		}
		else
		{
			if ( IsErrorLoggingEnabled () )
			{
				CHString foo;
				foo.Format(ERR_TAPI_NEGOTIATE, lRc, t_Index);
				LogErrorMessage(foo);

				break ;
			}
		}
	}

	return bRet ;
}

///////////////////////////////////////////////////////////////////////
LINEDEVCAPS *CWin32Modem::GetModemCapabilityInfoFromTAPI (

	CTapi32Api &a_Tapi32Api ,
	HLINEAPP *phLineApp,
	DWORD dwIndex,
	DWORD dwVerAPI
)
{
    // Allocate enough space for the structure plus 1024.
	DWORD dwLineDevCaps = sizeof (LINEDEVCAPS) + 1024;
    LONG lRc;
    LINEDEVCAPS *pLineDevCaps = NULL ;

	try
	{
		// Continue this loop until the structure is big enough.
		while(TRUE)
		{
			pLineDevCaps = (LINEDEVCAPS *) new char [dwLineDevCaps];
			if (!pLineDevCaps)
			{
				LogErrorMessage(ERR_LOW_MEMORY);
				throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR) ;
			}

			pLineDevCaps->dwTotalSize = dwLineDevCaps;

			// Make the call to fill the structure.
			do
			{
				lRc = a_Tapi32Api.TapilineGetDevCaps (

					*phLineApp,
					dwIndex,
					dwVerAPI,
					0,
					pLineDevCaps
				) ;

				if (HandleLineErr(lRc))
				{
					continue;
				}
				else
				{
					delete [] (PCHAR) pLineDevCaps ;
					pLineDevCaps = NULL ;
					return NULL;
				}
			}
			while (lRc != 0);

			// If the buffer was big enough, then succeed.
			if ((pLineDevCaps->dwNeededSize) <= (pLineDevCaps->dwTotalSize))
				break;

			// Buffer wasn't big enough.  Make it bigger and try again.
			dwLineDevCaps = pLineDevCaps->dwNeededSize;
		}
		return pLineDevCaps;

	}
	catch (...)
	{
		if (pLineDevCaps)
		{
			delete [] (PCHAR) pLineDevCaps ;
			pLineDevCaps = NULL ;
		}

		throw ;
	}
}

///////////////////////////////////////////////////////////////////////
BOOL CWin32Modem::HandleLineErr(long lLineErr)
{
    BOOL bRet = FALSE;

    // lLineErr is really an async request ID, not an error.
    if (lLineErr > 0)
        return bRet;

    // All we do is dispatch the correct error handler.
    switch(lLineErr)
    {
		case LINEERR_INCOMPATIBLEAPIVERSION:
            LogErrorMessage(L"Incompatible api version.\n");
		break;

		case LINEERR_OPERATIONFAILED:
            LogErrorMessage(L"Operation failed.\n");
		break;

		case LINEERR_INCOMPATIBLEEXTVERSION:
            LogErrorMessage(L"Incompatible ext version.\n");
		break;

		case LINEERR_INVALAPPHANDLE:
            LogErrorMessage(L"Invalid app handle.\n");
		break;

		case LINEERR_STRUCTURETOOSMALL:
            LogErrorMessage(L"structure too small.\n");
			bRet = TRUE;
		break;

		case LINEERR_INVALPOINTER:
            LogErrorMessage(L"Invalid pointer.\n");
		break;

		case LINEERR_UNINITIALIZED:
            LogErrorMessage(L"Unitialized.\n");
		break;

		case LINEERR_NODRIVER:
            LogErrorMessage(L"No driver.\n");
		break;

		case LINEERR_OPERATIONUNAVAIL:
            LogErrorMessage(L"Operation unavailable.\n");
		break;

		case LINEERR_NODEVICE:
            LogErrorMessage(L"No device ID.\n");
		break;

		case LINEERR_BADDEVICEID:
            LogErrorMessage(L"Bad device ID.\n");
		break;

        case 0:
            bRet = TRUE;
        break;

        case LINEERR_INVALCARD:
        case LINEERR_INVALLOCATION:
        case LINEERR_INIFILECORRUPT:
            LogErrorMessage(L"The values in the INI file are invalid.\n");
        break;

        case LINEERR_REINIT:
            LogErrorMessage(L"LineReinit err.\n");
        break;

        case LINEERR_NOMULTIPLEINSTANCE:
            LogErrorMessage(L"Remove one of your copies of your Telephony driver.\n");
        break;

        case LINEERR_NOMEM:
            LogErrorMessage(L"Out of memory. Cancelling action.\n");
        break;

        case LINEERR_RESOURCEUNAVAIL:
            LogErrorMessage(L"A TAPI resource is unavailable at this time.\n");
        break;

        // Unhandled errors fail.
        default:
            LogErrorMessage(L"Unhandled and unknown TAPI error.\n");
        break;
    }

    return bRet;
}


//
// Converts a string in the "mm-dd-yyyy" "mm/dd/yyyy" "mm-dd/yyyy" "mm/dd-yyyy"
// format to a WBEMTime object. Returns false if the conversion was not successful
//
BOOL CWin32Modem::ToWbemTime(LPCWSTR szDate, CHString &strRet)
{
    CHString strDate = szDate;
    int      iSlash1 = -1,
	         iSlash2 = -1 ;
    BOOL     bRet;

    if ( ( iSlash1 = strDate.Find ('-') ) == -1 )
	{
		iSlash1 = strDate.Find ( '//' );
	}

	if ( ( iSlash2 = strDate.ReverseFind ('-') ) == -1 )
	{
		iSlash2 = strDate.ReverseFind ( '//' );
	}

    if (iSlash1 != -1 && iSlash2 != -1 && iSlash1 != iSlash2 )
	{
	    int iMonth,
            iDay,
            iYear;

		iMonth  = _wtoi(strDate.Left(iSlash1));
		iYear = _wtoi(strDate.Mid(iSlash2 + 1));
        if (iYear < 100)
            iYear += 1900;

        iDay = _wtoi(strDate.Mid(iSlash1 + 1, iSlash2 - iSlash1 - 1)) ;

		// Convert to the DMTF format and send it in
        strRet.Format(
            L"%d%02d%02d******.******+***",
            iYear,
            iMonth,
            iDay);

        bRet = TRUE;
	}
    else
        bRet = FALSE;

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\logonsession.cpp ===
//***************************************************************************

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  LogonSession.cpp
//
//  Purpose: Logon session property set provider
//
//***************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
//#include <ntlsa.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <frqueryex.h>

#include <Session.h>
#include "LogonSession.h"
#include "AdvApi32Api.h"
#include "cominit.h"
#include <CreateMutexAsProcess.h>


#define MAX_PROPS			CWin32_LogonSession::e_End_Property_Marker
#define MAX_PROP_IN_BYTES	MAX_PROPS/8 + 1


// Property set declaration
//=========================
CWin32_LogonSession s_Win32_LogonSession( PROPSET_NAME_LOGONSESSION , IDS_CimWin32Namespace ) ;


/*****************************************************************************
 *
 *  FUNCTION    : CWin32_LogonSession::CWin32_LogonSession
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_LogonSession::CWin32_LogonSession (

LPCWSTR a_Name,
LPCWSTR a_Namespace
)
: Provider(a_Name, a_Namespace)
{
	SetPropertyTable() ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_LogonSession::~CWin32_LogonSession
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_LogonSession :: ~CWin32_LogonSession()
{
}

//
void CWin32_LogonSession::SetPropertyTable()
{
	// property set names for query optimization
	m_pProps.SetSize( MAX_PROPS ) ;

	// Win32_LogonSession
	m_pProps[e_LogonId]		=(LPVOID) IDS_LogonId;

	// Win32_Session
	m_pProps[e_StartTime]	=(LPVOID) IDS_StartTime ;

	// CIM_ManagedSystemElement
	m_pProps[e_Caption]		=(LPVOID) IDS_Caption ;
	m_pProps[e_Description]	=(LPVOID) IDS_Description ;
	m_pProps[e_InstallDate]	=(LPVOID) IDS_InstallDate ;
	m_pProps[e_Status]		=(LPVOID) IDS_Status ;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_LogonSession::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The calling function will commit the instance.
//
////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT CWin32_LogonSession::GetObject(

CInstance *a_pInstance,
long a_Flags,
CFrameworkQuery &a_rQuery
)
{
	return WBEM_S_NO_ERROR;
}
#endif

#ifdef NTONLY
HRESULT CWin32_LogonSession::GetObject(

CInstance *a_pInstance,
long a_Flags,
CFrameworkQuery &a_rQuery
)
{
	HRESULT					t_hResult = WBEM_E_NOT_FOUND ;
	
	CHString				t_chsLogonId ;
	DWORD					t_dwBits ;
	CFrameworkQueryEx		*t_pQuery2 ;
	CUserSessionCollection	t_oSessionColl ;

	// object key
	a_pInstance->GetCHString( IDS_LogonId, t_chsLogonId ) ;
	
	if( !t_chsLogonId.IsEmpty() )
	{					
		//  locate the session 
        // The logonid string could have had non-numeric
        // characters in it.  The _wtoi64 function will
        // convert numeric characters to numbers UNTIL
        // A NON-NUMERIC CHARACTER IS ENCOUNTERED!  This
        // means that "123" will give the same value as
        // "123-foo".  We should reject the latter as an
        // invalid logon it.  Hence the following logic:
        CSession sesTmp;

        if(sesTmp.IsSessionIDValid(t_chsLogonId))
        {
		    __int64 t_i64LuidKey = _wtoi64( t_chsLogonId ) ;

		    if( t_oSessionColl.IsSessionMapped( t_i64LuidKey ) )
		    {
			    // properties required
			    t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_rQuery ) ;
			    t_pQuery2->GetPropertyBitMask( m_pProps, &t_dwBits ) ;

			    t_hResult = GetSessionInfo(	t_i64LuidKey,
										    a_pInstance,
										    t_dwBits,
                                            t_oSessionColl ) ;
		    }
        }
	}

	return t_hResult ;
}
#endif

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_LogonSession::EnumerateInstances
//
//  Inputs:     MethodContext*  a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT CWin32_LogonSession::EnumerateInstances(

MethodContext *a_pMethodContext,
long a_Flags
)
{
	return WBEM_S_NO_ERROR;
}
#endif

#ifdef NTONLY
HRESULT CWin32_LogonSession::EnumerateInstances(

MethodContext *a_pMethodContext,
long a_Flags
)
{
	// Property mask -- include all
	DWORD t_dwBits = 0xffffffff;

	return EnumerateInstances(	a_pMethodContext,
								a_Flags,
								t_dwBits ) ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_LogonSession::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef WIN9XONLY
HRESULT CWin32_LogonSession::ExecQuery(

MethodContext *a_pMethodContext,
CFrameworkQuery &a_rQuery,
long a_lFlags
)
{
	return WBEM_S_NO_ERROR;
}
#endif

#ifdef NTONLY
HRESULT CWin32_LogonSession::ExecQuery(

MethodContext *a_pMethodContext,
CFrameworkQuery &a_rQuery,
long a_lFlags
)
{
    HRESULT					t_hResult = WBEM_S_NO_ERROR ;
	DWORD					t_dwBits ;
	CFrameworkQueryEx		*t_pQuery2 ;
	std::vector<_bstr_t>	t_vectorReqSessions ;


	// properties required
	t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_rQuery ) ;
	t_pQuery2->GetPropertyBitMask( m_pProps, &t_dwBits ) ;

	// keys supplied
	a_rQuery.GetValuesForProp( IDS_Name, t_vectorReqSessions ) ;

	// General enum if query is ambigious
	if( !t_vectorReqSessions.size() )
	{
		t_hResult = EnumerateInstances( a_pMethodContext,
										a_lFlags,
										t_dwBits ) ;
	}
	else
	{
		CUserSessionCollection	t_oSessionColl ;

		// smart ptr
		CInstancePtr t_pInst;

	
		// by query list
		for ( UINT t_uS = 0; t_uS < t_vectorReqSessions.size(); t_uS++ )
		{	
			//  locate the session 
			__int64 t_i64LuidKey = _wtoi64( t_vectorReqSessions[t_uS] ) ;
			
			if( t_oSessionColl.IsSessionMapped( t_i64LuidKey ) )
			{
				t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;
					
				t_hResult = GetSessionInfo(	t_i64LuidKey,
											t_pInst,
											t_dwBits,
                                            t_oSessionColl ) ;
				if( SUCCEEDED( t_hResult ) )
				{
					// the key
					t_pInst->SetCHString( 
                        IDS_LogonId, 
                        (wchar_t*)t_vectorReqSessions[t_uS] ) ;

					t_hResult = t_pInst->Commit() ;
				}
			}
		}
	}

    return t_hResult ;
}
#endif

//
#ifdef NTONLY
HRESULT CWin32_LogonSession::EnumerateInstances(

MethodContext	*a_pMethodContext,
long			a_Flags,
DWORD			a_dwProps
)
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR ;
	WCHAR	t_buff[MAXI64TOA] ;
	
	CUserSessionCollection	t_oSessionColl ;
	__int64					t_i64LuidKey ;

	// smart ptr
	CInstancePtr t_pInst ;
    USER_SESSION_ITERATOR sesiter;
    SmartDelete<CSession> pses;

	// emumerate sessions	
	pses = t_oSessionColl.GetFirstSession( sesiter ) ;

	while( pses )
	{								
        t_i64LuidKey = pses->GetLUIDint64();
        t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;
		
		t_hResult = GetSessionInfo(	t_i64LuidKey,
									t_pInst,
									a_dwProps,
                                    t_oSessionColl ) ;

		if( SUCCEEDED( t_hResult ) )
		{
			// the key
			_i64tow( t_i64LuidKey, t_buff, 10 ) ;		
			t_pInst->SetCHString( IDS_LogonId, t_buff ) ;

			t_hResult = t_pInst->Commit() ;
		}
		else
		{
			break ;
		}

		pses = t_oSessionColl.GetNextSession( sesiter ) ;
	}

	return t_hResult ;
}
#endif

//
#ifdef NTONLY
HRESULT CWin32_LogonSession::GetSessionInfo(

__int64		i64LUID,
CInstance	*pInst,
DWORD		dwProps,
CUserSessionCollection& usc
)
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR ;

	// REVIEW: the following for population
	
	//	e_StartTime, IDS_StartTime
	//	e_InstallDate, IDS_InstallDate
	//	e_Status, IDS_Status;
	//  e_Name, IDS_Name;
	//  e_Caption, IDS_Caption ;
	//  e_Description, IDS_Description ;

    SmartDelete<CSession> sesPtr;

    sesPtr = usc.FindSession(
        i64LUID);

    if(sesPtr)
    {
        // Load Authentication package...
        pInst->SetCHString(
            IDS_AuthenticationPackage,
            sesPtr->GetAuthenticationPkg());

        // Load Logontype...
        pInst->SetDWORD(
            IDS_LogonType,
            sesPtr->GetLogonType());

        // Load LogonTime...
        __int64 i64LogonTime = 
            sesPtr->GetLogonTime();

        FILETIME* ft = 
            static_cast<FILETIME*>(
                static_cast<PVOID>(&i64LogonTime));

        pInst->SetDateTime(
            IDS_StartTime,
            *ft);
    }

	return t_hResult ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\modem.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// MOMODEM.h 

//                                                                  

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   
//  9/05/96     jennymc     Updated to meet current standards
//                                                                   
///////////////////////////////////////////////////////////////////////

#define PROPSET_NAME_MODEM L"Win32_PotsModem"

/////////////////////////////////////////////////////////////////////
#define WIN95_MODEM_REGISTRY_KEY L"SYSTEM\\CurrentControlSet\\Services\\Class\\Modem"
#define WINNT_MODEM_REGISTRY_KEY L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}"
#define WINNT_MODEM_KEY L"SYSTEM\\CurrentControlSet\\Control\\Class\\"
#define WINNT_MODEM_CLSID L"{4D36E96D-E325-11CE-BFC1-08002BE10318}"
#define REFRESH_INSTANCE         1
#define ENUMERATE_INSTANCES      2
#define QUERY_KEYS_ONLY          4
#define MODEM_CLASS              L"Modem"
#define CLASS                    L"Class"
#define NULL_MODEM               L"Null Modem"
#define INTERNAL_MODEM           L"Internal Modem"
#define EXTERNAL_MODEM           L"External Modem"
#define PCMCIA_MODEM             L"PCMCIA Modem"
#define UNKNOWN_MODEM            L"Unknown"
#define DRIVER_DESC              L"DriverDesc"
#define HARDWARE_ID              L"HardwareID"
#define MFG                      L"Mfg"
#define MANUFACTURER             L"Manufacturer"
#define FRIENDLY_NAME            L"FriendlyName"
#define DEVICE_TYPE_STR          L"DeviceType"
#define ID                       L"ID"
#define MODEM                    L"Modem"
#define ATTACHED_TO              L"AttachedTo"
#define COMPATIBILITY_FLAGS      L"CompatibilityFlags"
#define CONFIG_DIALOG            L"ConfigDialog"
#define _DCB                     L"DCB"
#define DEFAULT                  L"Default"
#define INACTIVITY_SCALE         L"InactivityScale"
#define INFPATH                  L"InfPath"
#define INFSECTION               L"InfSection"
#define MODEL                    L"Model"
#define PORTSUBCLASS             L"PortSubClass"
#define PROPERTIES               L"Properties"
#define PROVIDERNAME             L"ProviderName"
#define RESET                    L"Reset"
#define RESPONSESKEYNAME         L"ResponsesKeyName"
#define INACTIVITYTIMEOUT        L"InactivityTimeout"
#define MODULATION_BELL          L"Modulation_Bell"
#define MODULATION_CCITT         L"Modulation_CCITT"
#define PREFIX                   L"Prefix"
#define PULSE                    L"Pulse"
#define SPEAKERMODE_DIAL         L"SpeakerMode_Dial"
#define SPEAKERMODE_OFF          L"SpeakerMode_Off"
#define SPEAKERMODE_ON           L"SpeakerMode_On"
#define SPEAKERMODE_SETUP        L"SpeakerMode_Setup"
#define SPEAKERVOLUME_HIGH       L"SpeakerVolume_High"
#define SPEAKERVOLUME_LOW        L"SpeakerVolume_Low"
#define SPEAKERVOLUME_MED        L"SpeakerVolume_Med"
#define TERMINATOR               L"Terminator"
#define TONE                     L"Tone"
#define BLIND_OFF                L"Blind_Off"
#define BLIND_ON                 L"Blind_On"
#define COMPRESSION_ON           L"Compression_On"
#define COMPRESSION_OFF          L"Compression_Off"
#define DIALPREFIX               L"DialPrefix"
#define DIALSUFFIX               L"DialSuffix"
#define ERRORCONTROL_FORCED      L"ErrorControl_Forced"
#define ERRORCONTROL_OFF         L"ErrorControl_Off"
#define ERRORCONTROL_ON          L"ErrorControl_On"
#define FLOWCONTROL_HARD         L"FlowControl_Hard"
#define FLOWCONTROL_OFF          L"FlowControl_Off"
#define FLOWCONTROL_SOFT         L"FlowControl_Soft"
#define ASCII_STRING             L"ASCII string format"
#define DBCS_STRING              L"DBCS string format"
#define UNICODE_STRING           L"UNICODE string format"
#define CALLSETUPFAILTIMER       L"CallSetupFailTimer"
#define SETTINGS                 L"\\Settings"
#define DRIVER_DATE              L"DriverDate"
#define DEV_LOADER               L"DevLoader"
#define VOICE_SWITCH_FEATURE     L"VoiceSwitchFeatures"
#define FRIENDLY_DRIVER          L"FriendlyDriver"

#define ERR_PLATFORM_NOT_SUPPORTED       L"Platform not supported"
#define ERR_INSUFFICIENT_BUFFER          L"Insufficient buffer"
#define ERR_TAPI_REINIT                  L"A telephony application need to relinquish its use of Telephony."
#define ERR_TAPI_INIT                    L"Error <0x%lX> in initializing TAPI API"
#define ERR_TAPI_NEGOTIATE               L"Error <0x%lX> in negotiating API version for line #%d"
#define ERR_LOW_MEMORY                   L"Low in memory"
#define ERR_LINE_GET_DEVCAPS             L"Error <0x%lX> in getting line device capabilities of line #%d"
#define ERR_TAPI_SHUTDOWN                L"Error <0x%lX> in shutting down the applicatiomn usage of TAPI API"
#define ERR_INVALID_MODEM_DEVICE_TYPE    L"Invalid Modem device type"
#define ERR_INVALID_MODEM_SPEAKER_MODE   L"Invalid speaker mode <0x%lX>"
#define ERR_INVALID_MODEM_SPEAKER_VOLUME L"Invalid speaker volume <0x%lX>"
#define APIHIVERSION    0x00030000              // 2.2
#define APILOWVERSION   0x00010001              // 1.1 
#define DT_NULL_MODEM      L"\"00\""
#define DT_EXTERNAL_MODEM  L"\"01\""
#define DT_INTERNAL_MODEM  L"\"02\""
#define DT_PCMCIA_MODEM    L"\"03\""

//////////////////////////////////////////////////////////////////////
class CWin32Modem: public Provider
{
private:
        // Common to both platforms
        BOOL AssignCommonDeviceType (

			CInstance *pInstance, 
			CRegistry *pregPrimary,
            CRegistry *pregSettings
		);

        BOOL AssignCommonFields(

			CInstance *pInstance, 
			CRegistry *pregPrimary,
            CRegistry *pregSettings
		);

        BOOL AssignCfgMgrFields(

			CInstance *pInstance, 
            CConfigMgrDevice *pDevice
		);

        BOOL GetFieldsFromTAPI(

			CTapi32Api &a_Tapi32Api ,
			CInstance *pInstance
		);

        BOOL GetModemInfo(
			CTapi32Api &a_Tapi32Api , 
			DWORD dwWhatToDo, 
			MethodContext *pMethodContext, 
			CInstance *pInstance, 
			LPCWSTR szDeviceID
		);

        // Win95 Private

#ifdef WIN9XONLY
        BOOL GetWin95Instance ( CInstance *pInstance ) ;
        BOOL RefreshWin95Instance ( CInstance *pInstance ) ;

        BOOL Win95SpecificRegistryValues ( 
			CInstance *pInstance, 
			CRegistry *CPrimaryReg,
            CRegistry *pregSettings);
#endif

#ifdef NTONLY
        // WinNT Private
        BOOL GetNTInstance(CInstance *pInstance);
        BOOL RefreshNTInstance(CInstance *pInstance);

        BOOL NTSpecificRegistryValues(
			CInstance *pInstance, 
			CRegistry *CPrimaryReg,
            CRegistry *pregSettings);
#endif

        ///////////////////////////////////////////////////////////////////////
        //  The TAPI Stuff
        ///////////////////////////////////////////////////////////////////////

        BOOL InitializeTAPI ( CTapi32Api &a_Tapi32Api , HLINEAPP *hLineApp , DWORD &a_NumberOfTapiDevices ) ;
        void ShutDownLine ( CTapi32Api &a_Tapi32Api , HLINEAPP *phLineApp ) ;
        BOOL OpenClassInfo ();

        BOOL GetModemInfoFromTAPI (

			CTapi32Api &a_Tapi32Api ,
			HLINEAPP *phLineApp, 
			CHString &a_DeviceIdentifier ,
			DWORD &a_NumberOfTapiDevices,
			LINEDEVCAPS *&pLineDevCaps
		) ;

        LINEDEVCAPS *GetModemCapabilityInfoFromTAPI (

			CTapi32Api &a_Tapi32Api ,
			HLINEAPP *phLineApp, 
			DWORD dwIndex, 
			DWORD dwVerAPI
		);

        BOOL HandleLineErr ( long lLineErr ) ;
  
		// A utility function to convert from a "mm-dd-yyyy" format to WbemTime
        BOOL ToWbemTime(LPCWSTR mmddyy, CHString &strRet);

public:

      virtual HRESULT GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery &pQuery);// Refresh the property set propeties     
      virtual HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L);
      virtual HRESULT ExecQuery ( MethodContext *pMethodContext, CFrameworkQuery &pQuery, long lFlags /*= 0L*/ );

      // Constructor sets the name and description of the property set
      // and initializes the properties to their startup values

       CWin32Modem(LPCWSTR name, LPCWSTR pszNamespace);  
      ~CWin32Modem();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\motherboard.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// MBoard.h -- System property set description for WBEM MO       	

//                                                                  

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   
// 10/18/95     a-skaja     Prototype                                
//  9/03/96     jennymc     Updated to meet current standards
// 10/23/97		a-hhance	updated to new framework paradigm
//	1/15/98		a-brads		added CommonInstance function
//                                                                   
///////////////////////////////////////////////////////////////////////

#define     PROPSET_NAME_MOTHERBOARD L"Win32_MotherBoardDevice"
//#define     PROPSET_UUID_MOTHERBOARD "{fdecc210-09aa-11cf-921b-00aa00a74d1b}"

///////////////////////////////////////////////////////////////////////////////////////
#define WIN95_MOTHERBOARD_REGISTRY_KEY L"Enum\\Root\\*PNP0C01\\0000"
#define WINNT_MOTHERBOARD_REGISTRY_KEY L"HARDWARE\\Description\\System"
#define REVISION L"Revision"
#define ADAPTER L"Adapter"
#define BUSTYPE L"BusType"
#define IDENTIFIER L"Identifier"
//#define QUOTE L("\"")
#define	BIOS	L"BIOS"

///////////////////////////////////////////////////////////////////////////////////////
class MotherBoard:public Provider
{
    private:
		HRESULT GetCommonInstance(CInstance* pInstance);
        HRESULT GetWin95Instance(CInstance* pInstance);
        HRESULT GetNTInstance(CInstance* pInstance);

    public:
        //**********************************************
        // Constructor/destructor -- constructor 
        // initializes property values, enumerating them 
        // into property set.
        //**********************************************
        MotherBoard(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~MotherBoard() {  }

        //**********************************************
        // Function provides properties with current 
        // values (REQUIRED)
        //**********************************************
   		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

        //**********************************************
        // This class has dynamic instances
        //**********************************************
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\motherboard.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  MBoard.CPP -- system managed object implementation

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//  10/16/95    a-skaja     Prototype for demo
//  09/03/96    jennymc     Updated to meet current standards
//                          Removed custom registry access to use the
//                          standard CRegCls
// 10/23/97		a-hhance	updated to new framework paradigm
//	1/15/98		a-brads		updated to V2 MOF
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <ole2.h>
#include <conio.h>
//#include <commonutil.h>

#include "MotherBoard.h"
#include "resource.h"

// For CBusList
#include "bus.h"

//////////////////////////////////////////////////////////////////////
// Declare the property set
//////////////////////////////////////////////////////////////////////
MotherBoard MyMotherBoardSet(PROPSET_NAME_MOTHERBOARD, IDS_CimWin32Namespace);

 //////////////////////////////////////////////////////////////////
//
//  Function:      Motherboard
//
//  Description:   This function is the constructor
//
//  Return:        None
//
//  History:
//         jennymc  11/21/96    Documentation/Optimization
//
//////////////////////////////////////////////////////////////////
MotherBoard::MotherBoard(LPCWSTR name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

HRESULT MotherBoard::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
	HRESULT hr;
    CHString sObj;

    pInstance->GetCHString(IDS_DeviceID, sObj);

    if (sObj.CompareNoCase(L"Motherboard") == 0)
    {

	    hr = GetCommonInstance(pInstance);
#ifdef NTONLY
		    hr = GetNTInstance(pInstance);
#endif
#ifdef WIN9XONLY
	        hr = GetWin95Instance(pInstance);
#endif
    } else
    {
        hr = WBEM_E_NOT_FOUND;
    }

	return hr;
}

HRESULT MotherBoard::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_E_FAILED;

	CInstancePtr pInstance ( CreateNewInstance(pMethodContext), false ) ;

	if (pInstance != NULL )
	{
		hr = GetCommonInstance(pInstance);

#ifdef NTONLY
			hr = GetNTInstance(pInstance);
#endif
#ifdef WIN9XONLY
			hr = GetWin95Instance(pInstance);
#endif

		if (SUCCEEDED(hr))
		{
			hr = pInstance->Commit () ;
		}
	}

	return hr;
}

HRESULT MotherBoard::GetCommonInstance(CInstance* pInstance )
{
	SetCreationClassName(pInstance);
	pInstance->SetCharSplat(IDS_DeviceID, _T("Motherboard"));

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_Motherboard);

	pInstance->SetCHString(IDS_Name, sTemp2);
	pInstance->SetCHString(IDS_Caption, sTemp2);
	pInstance->SetCHString(IDS_Description, sTemp2);
	pInstance->SetCharSplat(IDS_SystemCreationClassName, _T("Win32_ComputerSystem"));
//	pInstance->Setbool(IDS_HotSwappable, FALSE);
	pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());
	return(WBEM_S_NO_ERROR);

}

#ifdef WIN9XONLY
///////////////////////////////////////////////////////////////////////
HRESULT MotherBoard::GetWin95Instance(CInstance* pInstance )
{
    CRegistry   PrimaryReg;
    CHString    strBus1,
                strBus2,
		        strTmp;

	if (PrimaryReg.Open(HKEY_LOCAL_MACHINE, WIN95_MOTHERBOARD_REGISTRY_KEY, KEY_READ) == ERROR_SUCCESS)
	{
        PrimaryReg.GetCurrentKeyValue(BUSTYPE, strBus1);

        if (PrimaryReg.GetCurrentBinaryKeyValue(L"Revision", strTmp) == ERROR_SUCCESS)
		{
		    // number seems to come back including quotes, which look funny.
			// too late in the game to change GetCurrentBinaryKeyValue - I'll strip them here.

			if (strTmp[0] == '"')
				strTmp = strTmp.Mid(1);
			if (strTmp[strTmp.GetLength() -1] == '"')
				strTmp = strTmp.Left(strTmp.GetLength() -1);

			pInstance->SetCHString(IDS_RevisionNumber, strTmp);
		}
	}

    // Now see if we have a PCI bus, unless that was our primary bus from above.
    if (strBus1 != L"PCI")
    {
        CBusList    list;
        int         nItems = list.GetListSize();

        for (int i = 0; i < nItems; i++)
        {
            list.GetListMemberDeviceID(i, strTmp);
            if (strTmp.Find(L"PCI") != -1)
            {
                // To be consistent with other OSs, we'll assume PCI is the primary
                // bus if PCI is present.
                strBus2 = strBus1;
                strBus1 = L"PCI";

                // As soon as we find one, get out.
                break;
            }
        }
    }

	if (strBus1.GetLength())
        pInstance->SetCHString(IDS_PrimaryBusType, strBus1);

	if (strBus2.GetLength())
        pInstance->SetCHString(IDS_SecondaryBusType, strBus2);

    return WBEM_S_NO_ERROR;
}
#endif

#ifdef NTONLY
////////////////////////////////////////////////////////////////////
HRESULT MotherBoard::GetNTInstance(CInstance* pInstance)
{
    CRegistry   regAdapters;
	CHString    strPrimarySubKey;
	HRESULT     hRc = WBEM_E_FAILED;
	DWORD       dwPrimaryRc;

    //****************************************
    //  Open the registry
    //****************************************
    if (regAdapters.OpenAndEnumerateSubKeys(
        HKEY_LOCAL_MACHINE,
        WINNT_MOTHERBOARD_REGISTRY_KEY,
        KEY_READ ) != ERROR_SUCCESS)
		return WBEM_E_FAILED;

	// Holders for BIOS bus types we might encounter, so if we find no
	// other more common bus types, we'll go ahead and use these
    // values, since they are still reported as BUS types.
	CHString    strFirstBIOSBusType,
				strSecondBIOSBusType,
				strFirstBusType,
                strSecondBusType;
	BOOL		bDone = FALSE;


    //****************************************
    //  Our goal is to find any subkey that
    //  has the string "Adapter" in it and
    //  then read the "Identifier" value.
    //****************************************
    for ( ;
        !bDone && ((dwPrimaryRc = regAdapters.GetCurrentSubKeyName(strPrimarySubKey))
            == ERROR_SUCCESS);
        regAdapters.NextSubKey())
    {
        //************************************
        // If this is one of the keys we want
        // since it has "Adapter" in it
        // then get the "Identifier" value
        //************************************
		if (wcsstr(strPrimarySubKey, ADAPTER))
        {
            WCHAR		szKey[_MAX_PATH];
			CRegistry	reg;

            swprintf(
				szKey,
				L"%s\\%s",
                WINNT_MOTHERBOARD_REGISTRY_KEY,
				(LPCWSTR) strPrimarySubKey);

            if (reg.OpenAndEnumerateSubKeys(
                HKEY_LOCAL_MACHINE,
                szKey,
                KEY_READ) == ERROR_SUCCESS)
            {
				CHString strSubKey;

                //************************************
        	    // Enumerate the  system components
                // (like 0,1....)
                //************************************
                for ( ;
                    reg.GetCurrentSubKeyName(strSubKey) == ERROR_SUCCESS;
                    reg.NextSubKey())
                {
                    CHString strBus;

                    //****************************************
                    // PrimaryBusType - KEY
                    // SecondaryBusType
                    //****************************************
                    if (reg.GetCurrentSubKeyValue(IDENTIFIER, strBus) ==
                        ERROR_SUCCESS)
                    {
				        // Give precedence to PCI, ISA and EISA.
				        if (strBus == L"PCI" || strBus == L"ISA" ||
							strBus == L"EISA")
				        {
					        if (strFirstBusType.IsEmpty())
					        {
						        // Save the type of this first BUS to prevent
                                // duplicates.
						        strFirstBusType = strBus;
					        }
					        // Beware of duplicates
                            else if (strFirstBusType != strBus)
					        {
						        strSecondBusType = strBus;

								// Always let PCI be the 'primary' bus to
								// be consistent with other platforms.
								if (strSecondBusType == L"PCI")
								{
									strSecondBusType = strFirstBusType;
									strFirstBusType = L"PCI";
								}

                                // We got both buses, so get out.
								bDone = TRUE;
                                break;
					        }
				        }
				        else if (strFirstBIOSBusType.IsEmpty())
				        {
					        strFirstBIOSBusType = strBus;
				        }
				        else if (strSecondBIOSBusType.IsEmpty())
				        {
					        strSecondBIOSBusType = strBus;
				        }
                    }
                }
            }
        }
    }

	// If we're missing either bus type, fill them in using stored BIOS bus
    // types if we can.
	if (strFirstBusType.IsEmpty())
    {
		strFirstBusType = strFirstBIOSBusType;
        strSecondBusType = strSecondBIOSBusType;
	}
    else if (strSecondBusType.IsEmpty())
    {
		strSecondBusType = strSecondBIOSBusType;
    }

	if (!strFirstBusType.IsEmpty())
	{
		pInstance->SetCHString(IDS_PrimaryBusType, strFirstBusType);

		if (!strSecondBusType.IsEmpty())
			pInstance->SetCHString(IDS_SecondaryBusType,
				strSecondBusType);
	}


    // Return no error if everything went OK.
    if (dwPrimaryRc == ERROR_NO_MORE_ITEMS || dwPrimaryRc == ERROR_SUCCESS)
        hRc = WBEM_S_NO_ERROR;

    return hRc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\maindll.cpp ===
///***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WBEM Framework Instance provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <initguid.h>
#include "FactoryRouter.h"
#include "ResourceManager.h"
#include "timerqueue.h"
#include <powermanagement.h>
#include <systemconfigchange.h>
#ifdef NTONLY
#include "ntlastboottime.h"
#include <diskguid.h>
#endif

HMODULE ghModule;

// {d63a5850-8f16-11cf-9f47-00aa00bf345c}
DEFINE_GUID(CLSID_CimWinProvider,
0xd63a5850, 0x8f16, 0x11cf, 0x9f, 0x47, 0x0, 0xaa, 0x0, 0xbf, 0x34, 0x5c);
// {3DD82D10-E6F1-11d2-B139-00105A1F77A1}
DEFINE_GUID(CLSID_PowerEventProvider,0x3DD82D10, 0xE6F1, 0x11d2, 0xB1, 0x39, 0x0, 0x10, 0x5A, 0x1F, 0x77, 0xA1);
// {D31B6A3F-9350-40de-A3FC-A7EDEB9B7C63}
DEFINE_GUID(CLSID_SystemConfigChangeEventProvider, 
0xd31b6a3f, 0x9350, 0x40de, 0xa3, 0xfc, 0xa7, 0xed, 0xeb, 0x9b, 0x7c, 0x63);
#define PROVIDER_NAME L"CimWin32"

// initialize class globals
CFactoryRouterData          g_FactoryRouterData;
CPowerEventFactory*         gp_PowerEventFactory = NULL;
CSystemConfigChangeFactory* gp_SystemConfigChangeFactory = NULL;

CTimerQueue CTimerQueue :: s_TimerQueue ;
CResourceManager CResourceManager::sm_TheResourceManager ;

//Count number of objects and number of locks.
long g_cLock = 0;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;

    try
    {
        if ( CLSID_CimWinProvider == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else
        {
            hr = g_FactoryRouterData.DllGetClassObject( rclsid, riid, ppv );
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow()
{
    SCODE sc = S_FALSE;

    try
    {
        // It is OK to unload if there are no locks on the
        // class factory and the framework allows us to go.
        if (g_FactoryRouterData.DllCanUnloadNow())
        {
            sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
        }

        if ( sc == S_OK )
        {
            CTimerQueue::s_TimerQueue.OnShutDown();
            CResourceManager::sm_TheResourceManager.ForcibleCleanUp () ;

#ifdef WIN9XONLY
            HoldSingleCim32NetPtr::FreeCim32NetApiPtr() ;
#endif
        }
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("WBEM Framework Instance Provider"), CLSID_CimWinProvider ) ;
        if( NOERROR == t_status )
        {
            t_status = g_FactoryRouterData.DllRegisterServer() ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_CimWinProvider ) ;
        if( NOERROR == t_status )
        {
            t_status = g_FactoryRouterData.DllUnregisterServer() ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL InitializeEventFactories(void)
{
	BOOL fRet = FALSE;

	gp_PowerEventFactory = new CPowerEventFactory( CLSID_PowerEventProvider, POWER_EVENT_CLASS ) ;
	if( gp_PowerEventFactory )
	{
		gp_SystemConfigChangeFactory = new CSystemConfigChangeFactory(CLSID_SystemConfigChangeEventProvider, SYSTEM_CONFIG_EVENT) ;
		if( gp_SystemConfigChangeFactory )
		{
			fRet = TRUE;
		}
	}
	return fRet;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
void CleanupEventFactories(void)
{
	if( gp_PowerEventFactory )
	{
		delete gp_PowerEventFactory;
		gp_PowerEventFactory = NULL;
	}
	if( gp_SystemConfigChangeFactory )
	{
		delete gp_SystemConfigChangeFactory;
		gp_SystemConfigChangeFactory = NULL;
	}
}
//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;

	try
	{
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
#ifdef NTONLY
				InitializeCriticalSection(&CNTLastBootTime::m_cs);
#endif
				if( bRet )
				{
					bRet = InitializeEventFactories();
				}
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
				CleanupEventFactories();
				// Perform any necessary cleanup.
				LogMessage( L"DLL_PROCESS_DETACH" );
#ifdef NTONLY
				DeleteCriticalSection(&CNTLastBootTime::m_cs);
#endif
			}
			break;
		}
	}
	catch ( ... )
	{
		bRet = FALSE;
	}

    return bRet;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\msinfo_cdrom.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MSInfo_CDRom.cpp
//
//  Purpose: Routines from msinfo for transfer rate and drive integrity
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>


#include <stack>
#include "msinfo_cdrom.h"
#include "mmsystem.h"
#include <io.h>

//-----------------------------------------------------------------------------
// Find the next CD-ROM drive after the cCurrentDrive parameter. If
// cCurrentDrive is '\0', find the first CD-ROM drive. Return '\0' if there
// are no more CD drives.
//-----------------------------------------------------------------------------

#define FIRST_DRIVE	'C'
#define LAST_DRIVE	'Z'

char FindNextCDDrive(char cCurrentDrive)
{
	//CHString	strDriveRoot;
    TCHAR   szDriveRoot[10];
	char	cDrive = '\0';
	char	cStart = (cCurrentDrive == '\0') ? FIRST_DRIVE : (char) ((int)cCurrentDrive + 1);

	for (char c = cStart; c <= LAST_DRIVE; c++)
	{
		_stprintf(szDriveRoot, _T("%c:\\"), c);
		if (GetDriveType(szDriveRoot) == DRIVE_CDROM)
		{
			cDrive = c;
			break;
		}
	}

	return (cDrive);
}

//-----------------------------------------------------------------------------
// Get the total space on the CD-ROM drive. This code comes from version
// 2.51 of MSInfo. Returns zero if the information can not be found.
//-----------------------------------------------------------------------------

DWORD GetTotalSpace(LPCTSTR szRoot)
{
    DWORD dwSectorsPerCluster, dwBytesPerSector, dwFreeClusters, dwTotalClusters;
	DWORD dwTotalSpace = 0;

    BOOL bOK = GetDiskFreeSpace(szRoot, &dwSectorsPerCluster, &dwBytesPerSector,
                                &dwFreeClusters, &dwTotalClusters);
	if (bOK)
		dwTotalSpace = (dwTotalClusters * dwSectorsPerCluster * dwBytesPerSector);

	return (dwTotalSpace);
}

//-----------------------------------------------------------------------------
// These two functions are used to determine the transfer and integrity files
// for testing the CD-ROM drive.
//-----------------------------------------------------------------------------

#define MEGABYTE (1024 * 1024)

CHString GetIntegrityFile(LPCTSTR szRoot)
{
	return FindFileBySize(szRoot, _T("*.*"), MEGABYTE * 3/4, MEGABYTE * 2, TRUE);
}

CHString GetTransferFile(LPCTSTR szRoot)
{
	DWORD	dwMinSize = MEGABYTE, dwMaxSize;

	// Information from MSInfo 2.51:
	// Due to a problem disabling the file cache under Windows 95, the size of
	// the file must be greater than the supplemental cache used in the CD file
	// system (CDFS). This value is determined from the following:
	//
	// HLM\System\CurrentControlSet\Control\FileSystem\CDFS: CacheSize=<reg binary>

    // TODO: ADD THIS IDS TO STRINGG.CPP & H:
    //const char* IDS_REG_KEY_CD_CACHE = "System\\CurrentControlSet\\Control\\FileSystem\\CDFS";
    //const char* IDS_REG_VAL_CD_CACHE = "CacheSize";

#ifdef WIN9XONLY
	{
		CHString	strKeyName, strValName;
		DWORD	dwCacheSize = 0, dwType, dwSize = sizeof(DWORD);
		HKEY	hkey;

		//strKeyName.LoadString(IDS_REG_KEY_CD_CACHE);
		//strValName.LoadString(IDS_REG_VAL_CD_CACHE);

		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, /* strKeyName */ IDT_REG_KEY_CD_CACHE, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
        {
			if (RegQueryValueEx(hkey, /* strValName */ IDT_REG_VAL_CD_CACHE, 0, &dwType, (LPBYTE) &dwCacheSize, &dwSize) == ERROR_SUCCESS)
			{
				dwCacheSize = dwCacheSize * 2 * 1024;	// convert to bytes, reg value is half actual value
				dwCacheSize += (128 * 1024);			// pad the cache size when looking for file
				if (dwCacheSize > dwMinSize) dwMinSize = dwCacheSize;
			}

            RegCloseKey(hkey);
        }
	}
#endif

	dwMaxSize = ((dwMinSize > MEGABYTE) ? dwMinSize : MEGABYTE) * 2;
	return FindFileBySize(szRoot, _T("*.*"), dwMinSize, dwMaxSize, TRUE);
}

//-----------------------------------------------------------------------------
// This function (mostly lifted from the 2.51 version) is used to find a file
// in the specified directory tree which meets the specified size requirements.
//-----------------------------------------------------------------------------

CHString FindFileBySize(LPCTSTR szDirectory, LPCTSTR szFileSpec, DWORD dwMinSize, DWORD dwMaxSize, BOOL bRecursive)
{
	//CStringList		listSubdir;
    std::stack<CHString> stackchstrSubdirList;
    WIN32_FIND_DATA		ffd;
	CHString			strReturnFile, strDirSpec;
	BOOL				bMore = TRUE;
	DWORD				dwAttr;

	// Find the first available file to match the file specifications.

	strDirSpec = MakePath(szDirectory, szFileSpec);
    HANDLE hFindFile = FindFirstFile(TOBSTRT(strDirSpec), &ffd);
    if (hFindFile == INVALID_HANDLE_VALUE)
		return strReturnFile;

	// Then check each file in the directory. Add any subdirectories found to the
	// string list, so we can process them after we've done all the files (so this
	// is a breadth-first search). In this loop we check for non-system files, and
	// for files which fit the size requirements.

	while (bMore)
	{
        if (bRecursive && ((ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY))
        {
			if ((lstrcmp(ffd.cFileName, _T(".")) != 0) && (lstrcmp(ffd.cFileName, _T("..")) != 0))
            {
				//listSubdir.AddTail(ffd.cFileName);
                CHString chstrTemp = ffd.cFileName;
                stackchstrSubdirList.push(chstrTemp);
            }
        }

		dwAttr = ffd.dwFileAttributes;
		if (((dwAttr & FILE_ATTRIBUTE_SYSTEM) == 0) && ((dwAttr & FILE_ATTRIBUTE_HIDDEN) == 0))
        {
			if ((dwMinSize <= ffd.nFileSizeLow) && (ffd.nFileSizeLow <= dwMaxSize))
			{
				strReturnFile = MakePath(szDirectory, ffd.cFileName);
				break;
			}
        }
        bMore = FindNextFile(hFindFile, &ffd);
	}

    FindClose(hFindFile);

	// If we haven't found a suitable file (strReturnFile is empty), then call this
	// function recursively on all of the sub-directories.

	while (strReturnFile.IsEmpty() && !stackchstrSubdirList.empty())
	{
		CHString strSubdir = MakePath(szDirectory, TOBSTRT(stackchstrSubdirList.top()));
        stackchstrSubdirList.pop();
		strReturnFile = FindFileBySize(TOBSTRT(strSubdir), szFileSpec, dwMinSize, dwMaxSize, bRecursive);
	}

	// Well, the destructor should take care of this, but it's good to be tidy...

	// listSubdir.RemoveAll();	 well, we're not that tidy

	return strReturnFile;
}

//-----------------------------------------------------------------------------
// This simple little function combines two strings together into a path.
// It will make sure that the backslash is placed correctly (and only one).
//-----------------------------------------------------------------------------

CHString MakePath(LPCTSTR szFirst, LPCTSTR szSecond)
{
	CHString	strFirst(szFirst), strSecond(szSecond);

	if (strFirst.Right(1) == CHString(_T("\\")))
		strFirst = strFirst.Left(strFirst.GetLength() - 1);

	if (strSecond.Left(1) == CHString(_T("\\")))
		strSecond = strFirst.Right(strSecond.GetLength() - 1);

	strFirst += CHString(_T("\\")) + strSecond;
	return strFirst;
}

//=============================================================================
// NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
//
// The following code is lifted from version 2.51 (and 2.5) of MSInfo. It's
// been modified only enough to get it to compile in this environment. It seems
// to have worked in the older version, so it should work here.
//=============================================================================

// IMPLEMENT_DYNAMIC(CCdTest, CObject);

//#if defined(_DEBUG)
//#define new DEBUG_NEW
//#endif

#if !defined(HKEY_DYN_DATA)
	#define HKEY_DYN_DATA	((HKEY)0x80000006)
#endif

LPCTSTR szDOT_DOT = _T("..");                              // for common.h
TCHAR cFIRST_DRIVE = _T('C');
TCHAR cLAST_DRIVE = _T('Z');
LPCTSTR szPERF_STATS_DATA_KEY = _T("PerfStats\\StatData");
LPCTSTR szCPU_USAGE = _T("KERNEL\\CPUUsage");

DWORD MyGetFileSize(LPCTSTR pszFile, BOOL bSystemFile);
CONST DWORD dwINVALID_SIZE = 0xFFFFFFFF;

DWORD MyGetFileSize (LPCTSTR pszFile, BOOL bSystemFile)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("MyGetFileSize(%s, %d)\n"), pszFile, bSystemFile));
    DWORD dwSize = dwINVALID_SIZE;

#if defined(WIN32)
    DWORD dwFileAttributes = bSystemFile ? FILE_ATTRIBUTE_SYSTEM : FILE_ATTRIBUTE_NORMAL;
    HANDLE hFile = CreateFile(pszFile,                      // full pathname
                      0,                                    // access mode: just query attributes
                      FILE_SHARE_READ | FILE_SHARE_WRITE,   // share mode
                      NULL,                                 // security attributes
                      OPEN_EXISTING,                        // how to create
                      FILE_ATTRIBUTE_SYSTEM,                // file attributes
                      NULL);                                // template file
    if (ValidHandle(hFile))
        {
        dwSize = GetFileSize(hFile, NULL);
        CloseHandle(hFile);
        hFile = NULL;
        }

    if (dwSize == dwINVALID_SIZE)
        {
        DEBUG_OUTF(TL_BASIC, (_T("MyGetFileSize: error %lu when getting size of %s\n"),
                               GetLastError(), pszFile));
        }
#endif

    return (dwSize);
}

//-----------------------------------------------------------------------------
//	CCdTest class implementation
//-----------------------------------------------------------------------------

//	Constuct an instance of a CdTest class. This initializes the instance
//	and allocates memory for the file buffers, aligned on a CD sector boundary.
//
CCdTest::CCdTest (VOID)
{
	DEBUG_OUTF(TL_VERBOSE, _T("CCdTest::CCdTest()\n"));
	//	Allocate memory for the file buffers.
	m_pBufferSrcStart = new BYTE[nCD_SECTOR_SIZE + dwBUFFER_SIZE];
	if ( ! m_pBufferSrcStart )
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	m_pBufferDestStart = new BYTE[nCD_SECTOR_SIZE + dwBUFFER_SIZE];
	if ( ! m_pBufferDestStart )
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	//	Align buffers on a sector boundary. This is a requirement for using
	//	Win32 nonbuffered I/O.
	m_pBufferSrc = (PBYTE)AlignPointer(m_pBufferSrcStart, nCD_SECTOR_SIZE);
	m_pBufferDest = (PBYTE)AlignPointer(m_pBufferDestStart, nCD_SECTOR_SIZE);
	m_dwBufferSize = dwBUFFER_SIZE;
    m_hFileSrc = NULL;
    m_hFileDest = NULL;
	Reset();
}


//	Destruct an instance of a CdTest class. This frees memory used by the file buffers.
//
CCdTest::~CCdTest (VOID)
{
	DEBUG_OUTF(TL_VERBOSE, _T("CCdTest::~CCdTest()\n"));
	if (m_pBufferSrcStart)
	{
		delete [] m_pBufferSrcStart;
	}
	if (m_pBufferDestStart)
	{
		delete [] m_pBufferDestStart;
	}
	//_ASSERT(m_fileSrc.m_hFile == CFile::hFileNull);
	//_ASSERT(m_fileDest.m_hFile == CFile::hFileNull);
    //_ASSERT(m_hFileSrc == NULL);
	//_ASSERT(m_hFileDest == NULL);
    if(m_hFileSrc != NULL)
    {
        CloseHandle(m_hFileSrc);
        m_hFileSrc = NULL;
    }
    if(m_hFileDest != NULL)
    {
        CloseHandle(m_hFileDest);
        m_hFileDest = NULL;
    }
}


BOOL KeepBusy (DWORD dwNumMilliSecs)
{
    DEBUG_OUTF(TL_GARRULOUS, (_T("KeepBusy(%lu)\n"), dwNumMilliSecs));
    DWORD dwStart = GetTickCount();
    while ((GetTickCount() - dwStart) < dwNumMilliSecs)
    {
		DWORD dwNum = GetTickCount();
		dwNum *= 2;
    }
    return (TRUE);
}


//	Reset the test results
//
//	TODO: flush the disk cache
//
VOID CCdTest::Reset (VOID)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::Reset()\n")));
	m_cDrive = cNULL;
	m_rTransferRate = 0.0;
	m_rCpuUtil = 0.0;
	m_dwTotalTime = 0;
	m_dwTotalBusy = 0;
	m_dwTotalBytes = 0;
	m_dwTotalCPU = 0;
	m_nNumSamples = 0;
	m_dwFileSize = 0;
}


//	Read a block of data from the drive, maintaining timing stats.
//
BOOL CCdTest::ProfileBlockRead (DWORD dwBlockSize, BOOL bIgnoreTrial /* = FALSE */)
{
	BOOL bOK = FALSE;
	try
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::ProfileBlockRead(%lu, %d): offset=%lu\n"),
							    dwBlockSize, bIgnoreTrial, m_fileSrc.GetPosition()));
		ASSERT_BREAK(dwBlockSize <= m_dwBufferSize);

		//	Initialize the trial: for example, set up a high priority for the timing
		//	interval.
		HANDLE hThread = GetCurrentThread();
		DWORD dwOldPriority = GetThreadPriority(hThread);
		SetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL);
		DWORD dwStartTime = GetTickCount();

		//	Read in the next block from the drive
		//DWORD dwNum = m_fileSrc.Read(m_pBufferSrc, dwBlockSize);
        DWORD dwNum = 0;
        ReadFile(m_hFileSrc,m_pBufferSrc, dwBlockSize, &dwNum, NULL);
		bOK = (dwNum == dwBlockSize);

		//	Determine the time for the trial; restore the priority
		DWORD dwEndTime = GetTickCount();
		DWORD dwTime = (dwEndTime - dwStartTime);
#if TRUE
		DWORD dwWorkLeft = 0;
		if (m_bDoPacing)
			{
			INT nExtra = (INT)m_dwExpTimePerBlock - dwTime;
			nExtra = max(0, nExtra);
			dwWorkLeft = nExtra;
			KeepBusy(dwWorkLeft);
			}
#endif

		SetThreadPriority(hThread, dwOldPriority);
		DEBUG_OUTF(TL_GARRULOUS, (_T("Time: (%lu, %lu); Block Size: %lu; Num Read: %lu\n"),
							  	   dwStartTime, dwEndTime, dwBlockSize, dwNum));
        DWORD dwBytesPerMs = (dwTime > 0) ? (dwBlockSize / dwTime) : -1;
		DEBUG_OUTF(TL_VERBOSE, (_T("Time: %lu (%lu B/ms)\n"), dwTime, dwBytesPerMs));

		//	Accumulate the statistics
		if (!bIgnoreTrial)
			{
			m_dwTotalTime += dwTime;
			m_dwTotalBusy += dwWorkLeft;
			//m_dwTotalCPU += dwCpuUtil;
			m_dwTotalBytes += dwBlockSize;
			m_nNumSamples++;
			}
		}

	catch (...)
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("Exception during block read\n")));
		bOK = FALSE;
		}

	return (bOK);
}


//	Prepare to start profiling the CD drive: The test file for checking transfer rate
//	is opened.
//
BOOL CCdTest::InitProfiling (LPCTSTR pszCdTestFile)
{
	BOOL bOK = FALSE;

	try
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::InitProfiling(%s)\n"),
							    F1(pszCdTestFile)));

		//	Determine expected time per block, etc (in milliseconds)
		m_dwExpTimePerBlock = (dwBLOCK_SIZE * 1000) / dwEXP_RATE;

	    //  Determine the location on the hard drive where to copy it
//		ASSERT_BREAK(FileExists(pszCdTestFile));
	    m_dwFileSize = MyGetFileSize(pszCdTestFile, FALSE);      // not a system file
		if (m_dwFileSize < dwBLOCK_SIZE)
			{
			DEBUG_OUTF(TL_BASIC, (_T("File too small (< %lu) to profile\n"),
								  F1(pszCdTestFile), dwBLOCK_SIZE));
			return (FALSE);
			}
		DEBUG_OUTF(TL_DETAILED, (_T("Reading %s of size %lu\n"), pszCdTestFile, m_dwFileSize));

		//	Open the file
		HANDLE hFile = OpenFileNonbuffered(pszCdTestFile);
		//m_fileSrc.m_hFile = (UINT)hFile;
        m_hFileSrc = hFile;
		bOK = (ValidHandle(hFile));
		}

	catch (...)
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("Exception during profiling initialization\n")));
		bOK = FALSE;
		}

	return (bOK);
}


//  Profile the CD drive's speed and check its integrity.
//	Pacing is used to determine CPU util at 300KB/sec. Then the drive is
//	let loose to determine raw throughput.
//
BOOL CCdTest::ProfileDrive (LPCTSTR pszCdTestFile)
{
	BOOL bOK = TRUE;

	try
	{
		DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::ProfileCdDrive(%s)\n"),
							    F1(pszCdTestFile)));

		if (!InitProfiling(pszCdTestFile))
		{
			return (FALSE);
		}
		ASSERT_BREAK(m_dwFileSize > 0);

		//	Determine the number of samples
		DWORD dwNumBlocks = m_dwFileSize / dwBLOCK_SIZE;
		DWORD dwExtraSize = m_dwFileSize % dwBLOCK_SIZE;
		m_bDoPacing = FALSE;

		//	Read a block of data to prime the drive
		dwNumBlocks--;
		ProfileBlockRead(dwBLOCK_SIZE, TRUE);		// discard stats

		//	Read the first half of the file and maintain stats for nonpaced reads
		DWORD dwNumPacedSamples = dwNumBlocks/2;
		for (DWORD b = 0; (bOK) && (b < dwNumPacedSamples); b++)
		{
			bOK = ProfileBlockRead(dwBLOCK_SIZE);
		}

	    //  Determine the drive performance
		if (bOK)
		{
			DEBUG_OUTF(TL_DETAILED, (_T("ProfileCdDrive NonPaced Totals: Time=%lu Samples=%lu Bytes=%lu\n"),
									 m_dwTotalTime, m_nNumSamples, m_dwTotalBytes));
			if ((m_nNumSamples > 0) && (m_dwTotalTime > 0))
			{
	    		m_rTransferRate = ((DOUBLE)m_dwTotalBytes / 1024) / m_dwTotalTime;  // rate in KB/ms
	    		m_rTransferRate *= 1000;                                  			// rate in KB/s
			}
		}

		//	Read the remaining the blocks and maintain stats during
		//	paced reads
		m_bDoPacing = TRUE;
		m_dwTotalTime = 0;
		m_dwTotalBytes = 0;
		m_nNumSamples = 0;
		for (; (bOK) && (b < dwNumBlocks); b++)
		{
			bOK = ProfileBlockRead(dwBLOCK_SIZE);
		}
		if (bOK)
		{
			DEBUG_OUTF(TL_DETAILED, (_T("ProfileCdDrive Paced Totals: CdTime=%lu WorkloadTime=%lu Samples=%lu Bytes=%lu\n"),
									 m_dwTotalTime, m_dwTotalBusy, m_nNumSamples, m_dwTotalBytes));
			if ((m_nNumSamples > 0) && (m_dwTotalTime > 0))
			{
				DOUBLE dMaxExpTime = ((DOUBLE)m_nNumSamples * m_dwExpTimePerBlock);
				ASSERT_BREAK(dMaxExpTime > 0);
				m_rCpuUtil = ((DOUBLE)m_dwTotalTime * 100.0) / dMaxExpTime;
			}
		}

		//	Complain if things went wrong
		if (!bOK)
		{
			DEBUG_OUTF(TL_DETAILED, (_T("The test results are vacuous\n")));
			bOK = FALSE;
		}
		//m_fileSrc.Close();
        CloseHandle(m_hFileSrc);
        m_hFileSrc = NULL;
#if TRUE
		//	Clean up after the test (eg, delete the large temporary file)
		if (FileExists(TOBSTRT(m_sTempFileSpec)))
		{
			SetFileAttributes(TOBSTRT(m_sTempFileSpec), FILE_ATTRIBUTE_NORMAL);
			DeleteFile(TOBSTRT(m_sTempFileSpec));
		}
#endif

    }
	catch (...)
	{
		DEBUG_OUTF(TL_VERBOSE, (_T("Exception during profiling\n")));
		bOK = FALSE;
	}
    return bOK;
}


//	Initialize for the integrity checks. Copy the test file to the hard drive,
//	and then open both versions of the file for a subsequent comparison.
//
BOOL CCdTest::InitIntegrityCheck (LPCTSTR pszCdTestFile)
{
	BOOL bOK = FALSE;

	m_dwFileSize = MyGetFileSize(pszCdTestFile, FALSE);      // not a system file

	//	Derive name for temp file to contain a copy of the CD file
	//	TODO: delete the file after the test is done
    TCHAR szTempFileSpec[MAX_PATH];
    if (!GetTempDirectory(szTempFileSpec, STR_LEN(szTempFileSpec)))
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("Failed to GetTempDirectory\n")));
		return (FALSE);
		}

    LPTSTR pszFileName = szTempFileSpec + StringLength(szTempFileSpec);
    _tsplitpath(pszCdTestFile, NULL, NULL, pszFileName, NULL);
    LPTSTR pszExt = pszFileName + StringLength(pszFileName);
    _tsplitpath(pszCdTestFile, NULL, NULL, NULL, pszExt);
#if TRUE
	m_sTempFileSpec = szTempFileSpec;
#endif

	//	If the temp file already exists, delete it
	if (FileExists(szTempFileSpec))
		{
		SetFileAttributes(szTempFileSpec, FILE_ATTRIBUTE_NORMAL);
		BOOL bDeleteOK = DeleteFile(szTempFileSpec);
		if (!bDeleteOK)
			{
			DEBUG_OUTF(TL_BASIC, (_T("Error %lu deleting %s\n"),
							  	  GetLastError(), szTempFileSpec));
			}
		}

	//	Copy the file to the temporary directory
	BOOL bCopyOK = CopyFile(pszCdTestFile, szTempFileSpec, FALSE);    // overwrites if source exists
	if (!bCopyOK)
		{
		DEBUG_MSGF(TL_BASIC, (_T("Error %lu copying %s to %s\n"),
							  GetLastError(), pszCdTestFile, szTempFileSpec));
		return (FALSE);
		}

	//	Open the two files for a subsequent binary comparison
	try
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::InitIntegrityCheck(%s)\n"),
							    F1(pszCdTestFile)));

	    //  Determine the location on the hard drive where to copy it
		ASSERT_BREAK(FileExists(pszCdTestFile));
		ASSERT_BREAK(FileExists(szTempFileSpec));

		//	Open the files
#if FALSE
		bOK = m_fileSrc.Open(pszCdTestFile, CFile::modeRead | CFile::shareCompat);
		bOK = bOK && m_fileDest.Open(szTempFileSpec, CFile::modeRead | CFile::shareCompat);
#else
		//	Open the files w/o any buffering whatsoever
		HANDLE hSource = OpenFileNonbuffered(pszCdTestFile);
		//m_fileSrc.m_hFile = (UINT)hSource;
        m_hFileSrc = hSource;
		HANDLE hDest = OpenFileNonbuffered(szTempFileSpec);
		//m_fileDest.m_hFile = (UINT)hDest;
        m_hFileDest = hDest;
		bOK = (ValidHandle(hSource) && ValidHandle(hDest));
#endif
		}

	catch (...)
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("Exception during integrity check initialization\n")));
		bOK = FALSE;
		}

	//	Clean up after a failure
	if (!bOK)
	{
		//if (ValidHandle((HANDLE)m_fileSrc.m_hFile))
		//{
		//	m_fileSrc.Close();
		//}
		//if (ValidHandle((HANDLE)m_fileDest.m_hFile))
		//{
		//	m_fileDest.Close();
		//}
        if(ValidHandle((HANDLE)m_hFileSrc))
		{
			CloseHandle(m_hFileSrc);
            m_hFileSrc = NULL;
		}
		if(ValidHandle((HANDLE)m_hFileDest))
		{
			CloseHandle(m_hFileDest);
            m_hFileDest = NULL;
		}
	}

	return (bOK);
}


//	Compare the next blocks from the test file and its copy during the integrity check.
//
BOOL CCdTest::CompareBlocks ()
{
	DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::CompareBlocks(): block size = %lu\n"),
							dwBLOCK_SIZE));
	BOOL bOK = TRUE;

	// Perform a blockwise comparison of the files
	DWORD dwNumBlocks = (m_dwFileSize + dwBLOCK_SIZE - 1) / dwBLOCK_SIZE;
	for (DWORD dwBlock = 1; dwBlock <= dwNumBlocks; dwBlock++)
		{
		DEBUG_OUTF(TL_GARRULOUS, (_T("Testing block %lu; offset = %lu\n"), dwBlock, m_fileSrc.GetPosition()));

		//	Read in the next block from the drive
		//DWORD dwNumSrc = m_fileSrc.Read(m_pBufferSrc, dwBLOCK_SIZE);
		//DWORD dwNumDest = m_fileDest.Read(m_pBufferDest, dwBLOCK_SIZE);
        DWORD dwNumSrc = 0;
        DWORD dwNumDest = 0;
        ReadFile(m_hFileSrc, m_pBufferSrc, dwBLOCK_SIZE, &dwNumSrc, NULL);
		ReadFile(m_hFileDest, m_pBufferDest, dwBLOCK_SIZE, &dwNumDest, NULL);
		if (dwNumSrc != dwNumDest)
		{
			DEBUG_OUTF(TL_DETAILED, (_T("Num bytes read differ for block %lu (%lu vs %lu)\n"),
								    dwBlock, dwNumSrc, dwNumDest));
			bOK = FALSE;
			break;
		}

		//	Make sure that both blocks were read successfully
		if ((dwNumSrc != dwBLOCK_SIZE) && (dwBlock != dwNumBlocks))
		{
			DEBUG_OUTF(TL_DETAILED, (_T("Only %lu bytes were read for block %lu\n"),
								    dwNumSrc, dwBlock));
			bOK = FALSE;
			break;
		}

		//	Make sure that the blocks are identical
		if (CompareMemory(m_pBufferSrc, m_pBufferDest, dwNumSrc) != 0)
			{
			DEBUG_OUTF(TL_DETAILED, (_T("The files differ at block %lu\n"),
								    dwBlock));
			bOK = FALSE;
			break;
			}
		}
	if (bOK && (dwBlock <= dwNumBlocks))
		{
		ASSERT_BREAK(dwBlock != dwNumBlocks);
		DEBUG_OUTF(TL_DETAILED, (_T("Only %lu of %lu blocks were read/compared\n"),
								dwBlock, dwNumBlocks));
		bOK = FALSE;
		}

	return (bOK);
}


//  Profile the CD drive's speed and check its integrity
//
BOOL CCdTest::TestDriveIntegrity (LPCTSTR pszCdTestFile)
{
	BOOL bOK = FALSE;

	try
	{
		DEBUG_OUTF(TL_VERBOSE, (_T("CCdTest::TestDriveIntegrity(%s)\n"),
							    F1(pszCdTestFile)));

		bOK = InitIntegrityCheck(pszCdTestFile);
		if (bOK)
		{
			bOK = CompareBlocks();
			//m_fileSrc.Close();
			//m_fileDest.Close();
            CloseHandle(m_hFileSrc);
            m_hFileSrc = NULL;
			CloseHandle(m_hFileDest);
            m_hFileDest = NULL;
		}
#if TRUE
		//	Clean up after the test (eg, delete the large temporary file)
		if (FileExists(TOBSTRT(m_sTempFileSpec)))
		{
			SetFileAttributes(TOBSTRT(m_sTempFileSpec), FILE_ATTRIBUTE_NORMAL);
			DeleteFile(TOBSTRT(m_sTempFileSpec));
		}
#endif

	    //  Note that the drive passed or failed
		m_bIntegityOK = bOK;
	}

	catch (...)
		{
		DEBUG_OUTF(TL_VERBOSE, (_T("Exception during integrity checks\n")));
		bOK = FALSE;
		}

	return (bOK);
}


//-----------------------------------------------------------------------------
//	Utility functions
//-----------------------------------------------------------------------------


//	Obsolete function for determining the CPU utilization. This only works
//	under Windows 95.
//
DWORD GetCpuUtil (VOID)
{
    DWORD dwUtil = 0;

    if (IsWin95Running())
        {
        GetRegistryBinary(HKEY_DYN_DATA, (LPTSTR)szPERF_STATS_DATA_KEY, (LPTSTR)szCPU_USAGE,
                          &dwUtil, sizeof(dwUtil));
        }

    return (dwUtil);
}


//	OLDFindFileBySize: find the first file in the given directory branch matching
//	the size contraints.
//
CHString OLDFindFileBySize (LPCTSTR pszDirectory, LPCTSTR pszFileSpec, DWORD dwMinSize, DWORD dwMaxSize, BOOL bRecursive)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("OLDFindFileBySize(%s, %s, %lu, %lu, %d)\n"),
    						F1(pszDirectory), F2(pszFileSpec), dwMinSize, dwMaxSize, bRecursive));
    WIN32_FIND_DATA ffd;
	CHString sFile;

	// Initialize the search
	CHString sDirSpec = MakePath(pszDirectory, pszFileSpec);
	//CHStringList listSubdir;
    std::stack<CHString> stackchstrSubdirList;
    HANDLE hFindFile = FindFirstFile(TOBSTRT(sDirSpec), &ffd);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        DEBUG_OUTF(TL_DETAILED, (_T("OLDFindFileBySize: FindFirstFile('%s',...) failed with code %lu\n"),
                                 F1(sDirSpec), GetLastError()));
		return (sFile);
    }

	//	Check each file in the directory
	BOOL bMore = TRUE;
    while (bMore)
    {
    	//  Postpone checking subdirectories until current direcoty processed
        if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
        {
			if (bRecursive)
			{
				//	Add the directory unless its one of the special ones ('.' and '..')
				if ((StringCompare(ffd.cFileName, szDOT) != 0)
					&& (StringCompare(ffd.cFileName, szDOT_DOT) != 0))
				{
					// listSubdir.AddTail(ffd.cFileName);
                    CHString chstrTemp = ffd.cFileName;
                    stackchstrSubdirList.push(chstrTemp);
				}
			}
        }

		//	Ignore system files
        if (((ffd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) == FILE_ATTRIBUTE_SYSTEM)
			|| ((ffd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) == FILE_ATTRIBUTE_HIDDEN))
		{
			//	do nothing
		}

		//	See if the file size contraints are met
        else if ((dwMinSize <= ffd.nFileSizeLow) && (ffd.nFileSizeLow <= dwMaxSize))
		{
			//sFile.Format("%s\\%s", pszDirectory, ffd.cFileName);
			sFile = MakePath(pszDirectory, ffd.cFileName);
			break;
		}

        bMore = FindNextFile(hFindFile, &ffd);
    }

	//	If subdirectories should be checked, traverse each one until a right-sized file
	//	is encountered.
	if (sFile.IsEmpty())
	{
		ASSERT_BREAK(bRecursive || stackchstrSubdirList.empty());
		while (!stackchstrSubdirList.empty())
		{
			//CHString sSubdir = MakePath(pszDirectory, listSubdir.RemoveHead());
            CHString sSubdir = MakePath(pszDirectory, TOBSTRT(stackchstrSubdirList.top()));
            stackchstrSubdirList.pop();
			sFile = OLDFindFileBySize(TOBSTRT(sSubdir), pszFileSpec, dwMinSize, dwMaxSize, bRecursive);
			if (!sFile.IsEmpty())
			{
				break;
			}
		}
	}

	//	Cleanup after the search
	// listSubdir.RemoveAll();	// done for us with std::stack

	return (sFile);
}


//	Determine whether the specified logical drive is for a CD ROM.
//
BOOL IsCdDrive (CHAR cDrive)
{
	CHString sDriveRoot = MakeRootPath(cDrive);

    UINT uDriveType = GetDriveType(TOBSTRT(sDriveRoot));
    DEBUG_OUTF(TL_GARRULOUS, (_T("%u <= GetDriveType(%s)\n"), uDriveType, (LPCTSTR)sDriveRoot));
	return (uDriveType == DRIVE_CDROM);
}


//	Determine whether the specified logical drive is a local drive.
//
BOOL IsLocalDrive (CHAR cDrive)
{
	CHString sDriveRoot = MakeRootPath(cDrive);

    UINT uDriveType = GetDriveType(TOBSTRT(sDriveRoot));
    DEBUG_OUTF(TL_GARRULOUS, (_T("%u <= GetDriveType(%s)\n"), uDriveType, (LPCTSTR)sDriveRoot));
	return ((uDriveType != DRIVE_REMOTE)
			&& (uDriveType != DRIVE_UNKNOWN)
			&& (uDriveType != DRIVE_NO_ROOT_DIR));
}


//	Find the next CD drive in the system after the specified logical drive. If the
//	drive specified is empty, the first CD drive will be returned.
//
CHAR FindNextCdDrive (CHAR cCurrentDrive)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("FindNextCdDrive(%x)\n"), cCurrentDrive));

    //  Find the next CD rom drive
    CHAR cCdDrive = cNULL;
	CHAR cStart = (cCurrentDrive == cNULL)
					? cFIRST_DRIVE
					: (cCurrentDrive + 1);

	for (CHAR cDrive = cStart; (cDrive <= cLAST_DRIVE); cDrive++)
		{
		if (IsCdDrive(cDrive))
            {
            cCdDrive = cDrive;
            break;
            }
        }

	return (cCdDrive);
}


//	Find the next local drive in the system after the specified logical drive. If the
//	drive specified is empty, the first local drive will be returned.
//
CHAR FindNextLocalDrive (CHAR cCurrentDrive)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("FindNextCdDrive(%x)\n"), cCurrentDrive));

    //  Find the next local drive
    CHAR cLocalDrive = cNULL;
	CHAR cStart = (cCurrentDrive == cNULL)
					? cFIRST_DRIVE
					: (cCurrentDrive + 1);

	for (CHAR cDrive = cStart; (cDrive <= cLAST_DRIVE); cDrive++)
		{
		if (IsLocalDrive(cDrive))
			{
			cLocalDrive = cDrive;
			break;
			}
		}

	return (cLocalDrive);
}


//	Find the next local drive in the system after the specified logical drive. If the
//	drive specified is empty, the first local drive will be returned.
//
CHAR FindDriveByVolume (CHString sVolume)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("FindDriveByVolume(%s)\n"), F(sVolume)));

    //  Find the next local drive
    CHAR cDrive = cNULL;
	for (CHAR cCurrent = cFIRST_DRIVE; (cCurrent <= cLAST_DRIVE); cCurrent++)
		{
		CHString sRootDir = MakeRootPath(cCurrent);
		CHString sDriveVolume = GetVolumeName(TOBSTRT(sRootDir));
		if (sDriveVolume.CompareNoCase(sVolume) == 0)
			{
			cDrive = cCurrent;
			break;
			}
		}

	return (cDrive);
}


//	Open a binary file with access depending on several boolean switches, such as
//	whether the file should be created if new.
//
HANDLE OpenBinaryFile (LPCTSTR pszFile, BOOL bNew, BOOL bBuffered, BOOL bWritable)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;

    DWORD dwCreate = bNew ? CREATE_ALWAYS : OPEN_ALWAYS;
	DWORD dwAccess = GENERIC_READ;
	DWORD dwAttrsAndFlags = FILE_ATTRIBUTE_NORMAL;
	if (bWritable)
		{
		dwAccess |= GENERIC_WRITE;
		}
	if (!bBuffered)
		{
		dwAttrsAndFlags |= (FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING);
		}
    hFile = CreateFile(pszFile,                         // full pathname
                       dwAccess,    					// access mode
                       FILE_SHARE_READ,                 // share mode
                       NULL,                            // security attributes
                       dwCreate,                        // how to create
                       dwAttrsAndFlags,           		// file attributes
                       NULL);                           // template file
	return (hFile);
}


//	Open an existing (binary) file for nonbuffered read-only access.
//
HANDLE OpenFileNonbuffered (LPCTSTR pszFile)
{
	return (OpenBinaryFile(pszFile, 	// name
						   FALSE,		// must exist
						   FALSE,		// non-buffered I/O
						   FALSE));		// not for write access
}


//	Return a pointer that is aligned on a given boundary. That is, the pointer
//	must be a integer multiple of the alignment factor (eg, 8192 for 512 alignment).
//
PVOID AlignPointer (PVOID pData, INT nAlignment)
{
	PBYTE pStart = (PBYTE)pData;
	DWORD_PTR dwStart = (DWORD_PTR)pData;
	INT nOffset = (dwStart % nAlignment);
	if (nOffset > 0)
		{
		dwStart = (dwStart + nAlignment - nOffset);
		}
	ASSERT_BREAK((dwStart % nAlignment) == 0);

	return ((PVOID)dwStart);
}

BOOL FileExists (LPCTSTR pszFile) //, POFSTRUCT pofs)
{
//    ASSERT_BREAK(pofs);

    //  Make sure that annoying error message boxes don't pop up
    // this is done in the core, right now.
    // UINT uPrevErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);


#if TRUE
	TCHAR szFile[MAX_PATH];
	if (pszFile[0] == cDOUBLE_QUOTE)
		{
		ParseString(pszFile, szFile, STR_LEN(szFile));
		pszFile = szFile;
		}
#endif
    //BOOL bExists = (OpenFile(pszFile, pofs, OF_EXIST) != HFILE_ERROR);
    BOOL bExists = _taccess(pszFile, 0) != -1;
    DEBUG_OUTF(TL_VERBOSE, (_T("%d <= FileExists(%s)\n"), bExists, pszFile));

    //  Restore the error state
    // this is done in the core, global to the process.
    // SetErrorMode(uPrevErrorMode);

    return (bExists);
}

BOOL GetTempDirectory (LPTSTR pszTempDir, INT nMaxLen)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("GetTempDirectory(%08lx,%d)\n"), pszTempDir, nMaxLen));
    BOOL bOK = FALSE;

#if defined(WIN32)

    DWORD dwLen = GetTempPath(nMaxLen, pszTempDir);
    bOK = (dwLen > 0);
    if (!bOK)
    	{
        DEBUG_OUTF(TL_BASIC, (_T("GetTempDirectory: error %lu from GetTempPath(%d,%08lx)\n"),
                              GetLastError(), nMaxLen, pszTempDir));
    	}

#else

    bOK = GetEnvironmentVar(szTEMP, pszTempDir, nMaxLen);

#endif

    return (bOK);
}

BOOL GetRegistryBinary (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                        PVOID pData, DWORD dwMaxDataLen)
{
    DWORD dwType;
    BOOL bOK = GetRegistryValue(hBaseKey, pszSubKey, pszValue, &dwType, pData, dwMaxDataLen);
    if (bOK)
    {
        ASSERT_BREAK(IsRegBinaryType(dwType)
               || ((dwMaxDataLen == sizeof(DWORD)) && IsRegNumberType(dwType)));
    }

    return (bOK);
}

BOOL GetRegistryValue (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                       PDWORD pdwValueType, PVOID pData, DWORD dwMaxDataLen)
{
    DEBUG_OUTF(TL_GARRULOUS, (_T("GetRegistryValue(%x,%s,%s,%x,%x,%lu)\n"),
                            hBaseKey, pszSubKey, pszValue,
                            pdwValueType, pData, dwMaxDataLen));
    ASSERT_BREAK(pszSubKey);
    ASSERT_BREAK(pszValue);
    ASSERT_BREAK(pdwValueType);
    ASSERT_BREAK(pData);
    ASSERT_BREAK(dwMaxDataLen > 0);

    //  Initialize variables
    HKEY hSubKey = NULL;
    BOOL bOK = FALSE;
    *pdwValueType = REG_NONE;

    //  Open the section for the specified key (eg, HLM: SYSTEM\CurrentControlSet)
    LONG lStatus = RegOpenKeyEx(hBaseKey,   // handle of open parent key
                           pszSubKey,       // address of name of subkey to open
                           0,               // reserved (must be zero)
                           KEY_READ,        // security access mask
                           &hSubKey);       // address of handle of open key
    if (lStatus != ERROR_SUCCESS)
    {
        DEBUG_OUTF(TL_BASIC, (_T("Error %ld opening registry key %s\n"), lStatus, pszSubKey));
    }
    else
    {
        //  Read in the requested value
        LPTSTR pszValueName = (LPTSTR)pszValue;     // shameless cast required by RegQueryValueEx
        lStatus = RegQueryValueEx(hSubKey,          // handle of key to query
                                  pszValueName,     // address of value name for query
                                  NULL,             // reserved
                                  pdwValueType,     // address of buffer for value type
                                  (PBYTE)pData,     // address of data buffer
                                  &dwMaxDataLen);   // address of data buffer size
        if (lStatus != ERROR_SUCCESS)
        {
            DEBUG_OUTF(TL_BASIC, (_T("Error %ld reading data for registry value %s (of %s)\n"),
                                     lStatus, pszValueName, pszSubKey));
        }
        else
        {
            bOK = TRUE;
        }
    }

    if (ValidHandle(hSubKey))
    {
        RegCloseKey(hSubKey);
    }

    DEBUG_OUTF(TL_GARRULOUS, (_T("GetRegistryValue => %d (pData => %s; pdwValueType => %lu)\n"),
                            bOK,
                            (IsRegStringType(*pdwValueType) ? (LPCTSTR)pData : szBINARY),
                            *pdwValueType));
    return (bOK);
}

CHString GetVolumeName (LPCTSTR pszRootPath)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("GetVolumeName(%s): "), F1(pszRootPath)));
	CHString    sVolumeName;
    TCHAR       szBuff[MAX_PATH] = _T("");

	//DWORD dwF
//	LPTSTR pszVolume = sVolumeName.GetBuffer(MAX_PATH);
	GetVolumeInformation(pszRootPath, szBuff, MAX_PATH, NULL, NULL, NULL, NULL, 0);
//	sVolumeName.ReleaseBuffer();
    sVolumeName = szBuff;
	DEBUG_OUTF(TL_VERBOSE, (L"%s\n", F1(sVolumeName)));

	return (sVolumeName);
}


LPCTSTR ParseString (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    )
{
    pszSource = SkipSpaces((LPTSTR) pszSource);
    if (IsQuoteChar(*pszSource))
    	{
        pszSource = ParseQuotedString(pszSource, pszBuffer, nLen);
    	}
    else
    	{
        pszSource = ParseToken(pszSource, pszBuffer, nLen);
    	}

    return (pszSource);
}

LPCTSTR ParseToken (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    )
{
    ASSERT_BREAK(pszSource);
    ASSERT_BREAK(pszBuffer);

    //  Skip any leading whitespace, and then accumulate a token char run
    pszSource = SkipSpaces((LPTSTR) pszSource);

	// If this is for DBCS, the string needs to be scanned with a little more care.
	// This is from the Japanese version. (a-jammar, 5/10/96, japanese)

#ifdef DBCS
	while (*pszSource && (nLen > 0) && (IsDBCSLeadByte(*pszSource) || IsTokenChar(*pszSource)))
#else
	while (*pszSource && (nLen > 0) && IsTokenChar(*pszSource))
#endif
   	{
        *pszBuffer = *pszSource;

		#ifdef DBCS
	  		if(IsDBCSLeadByte(*pszBuffer))
	  		{
	  			*(pszBuffer + 1) = *(pszSource + 1);
	  			nLen--;
	  		}
		#endif

        pszBuffer = PszAdvance(pszBuffer);
        pszSource = PcszAdvance(pszSource);
        nLen--;
    }
    *pszBuffer = cNULL;

    return (pszSource);
}

LPCTSTR ParseQuotedString (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    )
{
    LPCTSTR pszStart = pszSource;

    //  Skip leading whitespace, and then check for optional quote
    CHAR cEndQuote = cNULL;
    pszSource = SkipSpaces(pszSource);
    if (IsQuoteChar(*pszSource))
    	{
        cEndQuote = *pszSource;
        pszSource = PcszAdvance(pszSource);
    	}

    //  Accumulate a run of chars until closing quote encounted (or EOS)
    while (*pszSource && (nLen > 0))
    	{

        //  Check for the matching quote character
        if (*pszSource == cEndQuote)
        	{
            ASSERT_BREAK(IsQuoteChar(*pszSource));

            //  Check for an escaped quote (works w/ DBCS: first quote not lead byte)
            if (*(pszSource + 1) == cEndQuote)
            	{
                //  Ignore the first quote and let second be added to text below
                pszSource = PcszAdvance(pszSource);
                }
            else
            	{
                break;
                }
            }

        //  Add the character to the string
        CopyCharAdvance(pszBuffer, pszSource, nLen);
        }

    //  Terminate the return buffer and check for truncation
    *pszBuffer = cNULL;
    if ((nLen == 0) && *pszSource)
    	{
        DEBUG_OUTF(TL_BASIC, (_T("Buffer insufficient in ParseQuotedString\n")));
        }

    //  Advance past the closing quote, if found
    if (*pszSource == cEndQuote)
    	{
        pszSource = PcszAdvance(pszSource);
        }
    else
    	{
        DEBUG_OUTF(TL_DETAILED, (_T("ParseQuotedString: Ending quote character (%c) not found in string %s\n"),
                                 cEndQuote, pszStart));
        }

    return (pszSource);
}

BOOL FindCdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("FindCdRomDriveInfo(%c, %x, %x)\n"), cDrive, &sDriver, &sDescription));
	BOOL bOK = FALSE;

	if (IsWin95Running())
		{
		bOK = FindWin95CdRomDriveInfo(cDrive, sDriver, sDescription);
		}
    else if (IsNtRunning())
        {
		bOK = FindNtCdRomDriveInfo(cDrive, sDriver, sDescription);
        }

	return (bOK);
}


LPCWSTR apszENUM_BRANCH[]	= 		{
								 L"EISA",		// Extended ISA bus devices
								 L"ESDI",
								 L"MF",
								 L"PCI", 		// PCI bus devices
								 L"SCSI",		// SCSI devices
								 L"ROOT",		// legacy devices
#if defined(_DEBUG)
								 L"ISAPNP",		// ISA plug n' play
								 L"FLOP",		// floppy devices
#endif
								 };
WCHAR szBRANCH_KEY_FMT[] =		L"Enum\\%s";
TCHAR szCURRENT_DRIVE[] =		_T("CurrentDriveLetterAssignment");
//CHAR szDRIVER[] =				"Driver";
TCHAR szDEVICE_DESC[] =			_T("DeviceDesc");


//	This inefficient function tries to locate the information about the
//	specified CD drive in the HKEY_LOCAL_MACHINE\Enum branch of the Windows 95
//	registry. Instead of using a generic (but more inefficient) recursive search,
//	this just checks at a particular depth (namely 2) from the start for the
//	CurrentDriveLetterAssignment & Class values. This depth corresponds to keys
//	of the form ENUM\enumerator\device-id\instance
//
//	An example follows:
//
//  HKEY_LOCAL_MACHINE\Enum
//		SCSI
//			NEC_____CD-ROM_DRIVE:5002
//				PCI&VEN_1000&DEV_0001&BUS_00&DEV_0F&FUNC_0020
//					CurrentDriveLetterAssignment	E
//					Class							CDROM
//					Driver							CDROM\0000
//					DeviceDesc						NEC CD-ROM DRIVE:500
//
//	See the Plug N' Play documentation from the Win95 DDK for details on the
//	Enum branch layout.
//
//	TODO: see if there are Plug N' Play functions for doing this
//
BOOL FindWin95CdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("FindWin95RomDriveInfo(%c, %x, %x)\n"), cDrive, &sDriver, &sDescription));
	BOOL bOK = FALSE;

	cDrive = ToUpper(cDrive);

	//	Check each plug & play enumerator that might contain a CD ROM device.
	//	This includes SCSI, PCI, ROOT and ESDI.
	for (INT i = 0; i < NUM_ELEMENTS(apszENUM_BRANCH); i++)
		{
		CHString sEnumBranch;
		sEnumBranch.Format(szBRANCH_KEY_FMT, apszENUM_BRANCH[i]);
		CHStringArray sBranchSubkeys;

		//	Walk each of the device ID sections for the enumerator.
		BOOL bHasSubkeys = GetRegistrySubkeys(HKEY_LOCAL_MACHINE, TOBSTRT(sEnumBranch), sBranchSubkeys);
		for (INT j = 0; j < sBranchSubkeys.GetSize(); j++)
			{
			CHString sEnumBranchSubkey = MakePath(TOBSTRT(sEnumBranch), TOBSTRT(sBranchSubkeys[j]));
			CHStringArray sBranchSubsubkeys;

			//	Enumerate the instances for the device
			BOOL bHasSubsubkeys = GetRegistrySubkeys(HKEY_LOCAL_MACHINE, TOBSTRT(sEnumBranchSubkey), sBranchSubsubkeys);
			for (INT k = 0; k < sBranchSubsubkeys.GetSize(); k++)
				{
				//	See if the device's letter assignment matches the given drive
				CHString sSubsubkey = MakePath(TOBSTRT(sEnumBranchSubkey), TOBSTRT(sBranchSubsubkeys[k]));
				CHString sDrive = GetRegistryString(HKEY_LOCAL_MACHINE, TOBSTRT(sSubsubkey), szCURRENT_DRIVE);
				if (!sDrive.IsEmpty() && (ToUpper(sDrive[0]) == cDrive))
					{
					bOK = TRUE;
					sDriver = GetRegistryString(HKEY_LOCAL_MACHINE, TOBSTRT(sSubsubkey), szDRIVER);
					sDescription = GetRegistryString(HKEY_LOCAL_MACHINE, TOBSTRT(sSubsubkey), szDEVICE_DESC);
					break;
					}
				}
			}
		}

	return (bOK);
}

BOOL GetRegistrySubkeys (HKEY hBaseKey, LPCTSTR pszKey, CHStringArray& asSubkeys)
{
	DEBUG_OUTF(TL_VERBOSE, (_T("GetRegistrySubkeys(%x, %s, %x)\n"),
							hBaseKey, pszKey, &asSubkeys));

	asSubkeys.RemoveAll();

    //  Open the section for the specified key (eg, HLM: SYSTEM\CurrentControlSet)
    HKEY hKey = NULL;
    LONG lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, // handle of open parent key
                           		pszKey,       	 	// address of name of subkey to open
                           		0,               	// reserved (must be zero)
                           		KEY_ALL_ACCESS,  	// security access mask
                           		&hKey);       		// address of handle of open key
    if (lStatus != ERROR_SUCCESS)
        {
        DEBUG_OUTF(TL_BASIC, (_T("Error %ld opening registry key %s\n"), lStatus, pszKey));
		return (FALSE);
        }

	for (INT nSubKey = 0; ; nSubKey++)
		{
		//	Determine the next subkey's name
		TCHAR szSubKey[MAX_PATH] = { cNULL };
		lStatus = RegEnumKey(hKey, nSubKey, szSubKey, STR_LEN(szSubKey));
		if (lStatus != ERROR_SUCCESS)
			{
			break;
			}

		asSubkeys.Add(TOBSTRT(szSubKey));
		}

	return (TRUE);
}


//  Get a string value from the registry, returning it as a CHString.
//
CHString GetRegistryString (HKEY hBaseKey, LPCTSTR pszSubkey, LPCTSTR pszValueName)
{
	CHString    sValue;
    TCHAR       szBuffer[nTEXT_BUFFER_MAX];

//	LPTSTR pszBuffer = sValue.GetBuffer(nTEXT_BUFFER_MAX);
	GetRegistryString(hBaseKey, pszSubkey, pszValueName, szBuffer, nTEXT_BUFFER_MAX);
    sValue = szBuffer;
//	sValue.ReleaseBuffer();

	return (sValue);
}

//	Retrieve the drive information associated with the logical drive specification
//	(a DOS device name). This is only applicable to NT.
//
BOOL FindNtCdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription)
{
    DEBUG_OUTF(TL_VERBOSE, (_T("FindWin95RomDriveInfo(%c, %x, %x)\n"), cDrive, &sDriver, &sDescription));
	BOOL bOK = FALSE;

	cDrive = ToUpper(cDrive);
//    CHString sDevice;
//    sDevice.Format(szDOS_DEVICE_FMT, cDrive);
    TCHAR szDevice[100];

    wsprintf(szDevice, szDOS_DEVICE_FMT, cDrive);

    TCHAR szNtDeviceName[MAX_PATH];
    DWORD dwLen = QueryDosDevice(szDevice, szNtDeviceName, STR_LEN(szNtDeviceName));
    if (dwLen > 0)
        {
        sDriver = szNtDeviceName;
        bOK = TRUE;
        }

	return (bOK);
}

BOOL GetRegistryString (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                        LPTSTR pszData, DWORD dwMaxDataLen)
{
    DWORD dwType;
    BOOL bOK = GetRegistryValue(hBaseKey, pszSubKey, pszValue, &dwType, pszData, dwMaxDataLen);
    if (bOK)
    {
        ASSERT_BREAK(IsRegStringType(dwType));
    }

    return (bOK);
}





////////// the great main //////////////////////////////
//void main(void)
//{
//    CCdTest cd;
//    // Need drive letter of cd drive:
//    CHAR cCDDrive = FindNextCdDrive('C');
//    CHString chstrCDDrive;
//    chstrCDDrive.Format("%c:\\", cCDDrive);
//    // Need to find a file of adequate size for use in profiling:
//    CHString chstrTransferFile = GetTransferFile(chstrCDDrive);
//    // Need to find a file correct for integrity check:
//    CHString chstrIntegrityFile = GetIntegrityFile(chstrCDDrive);
//    cd.ProfileDrive(cCDDrive, chstrTransferFile);
//    cd.TestDriveIntegrity(cCDDrive, chstrIntegrityFile);
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\multimonitor.cpp ===
//=================================================================

//

// MultiMonitor.CPP -- Performance Data Helper class

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:	11/23/97    a-sanjes		Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "multimonitor.h"

// This will get us the multi-monitor stubs.
#define COMPILE_MULTIMON_STUBS

#include <multimon.h>

// Static Initialization
//////////////////////////////////////////////////////////
//
//	Function:	CMultiMonitor::CMultiMonitor
//
//	Default constructor
//
//	Inputs:
//				None
//
//	Outputs:
//				None
//
//	Returns:
//				None
//
//	Comments:
//
//////////////////////////////////////////////////////////

CMultiMonitor::CMultiMonitor()
{
	Init();
}

//////////////////////////////////////////////////////////
//
//	Function:	CMultiMonitor::~CMultiMonitor
//
//	Destructor
//
//	Inputs:
//				None
//
//	Outputs:
//				None
//
//	Returns:
//				None
//
//	Comments:
//
//////////////////////////////////////////////////////////

CMultiMonitor::~CMultiMonitor()
{
}

void CMultiMonitor::Init()
{
#if defined(WIN9XONLY) || NTONLY >= 5
    CConfigManager cfgManager;

    cfgManager.GetDeviceListFilterByClass(m_listAdapters, L"Display");
#else
    // NT4 behaves badly.  It may have several cfg mgr objects of type
    // "Display", or none at all.  So, we'll use the registry to try to find
    // the cfg mgr device for the display adapter.  There can only be one on
    // NT4.

    CRegistry reg;

    // The key is always in the same place on NT4 and lower.
    reg.OpenLocalMachineKeyAndReadValue(
	    L"HARDWARE\\DEVICEMAP\\VIDEO",
		L"\\Device\\Video0",
		m_strSettingsKey);


    // \REGISTRY\Machine\System\ControlSet001\Services\mga64\Device0
    // We need to strip off the \REGISTRY\Machine stuff.
    TrimRawSettingsKey(m_strSettingsKey);


    // Parse out just the service name.  The key currently looks like
    // System\ControlSet001\Services\mga64\Device0
    // and we only want the 'mga64' part.
    int iBegin = m_strSettingsKey.Find(L"SERVICES\\");
	if (iBegin != -1)
	{
        CConfigManager cfgManager;

	    // This will get us past the SERVICES\\.
		m_strService = m_strSettingsKey.Mid(iBegin +
                           sizeof(_T("SERVICES"))/sizeof(TCHAR));
		m_strService = m_strService.SpanExcluding(L"\\");

        // Now try to find the cfg mgr device.
        cfgManager.GetDeviceListFilterByService(m_listAdapters, m_strService);
    }
#endif
}

BOOL CMultiMonitor::GetAdapterDevice(int iWhich, CConfigMgrDevice** ppDeviceAdapter)
{
	BOOL bRet = FALSE;

	// Don't use GetNumAdapters() here because GetNumAdapters() isn't necessarily
    // the same as the size of the adapters list (especially for NT4).
    if (ppDeviceAdapter && iWhich < m_listAdapters.GetSize())
	{
        // Assuming a 1 to 1 correspondence between the monitors returned by the
        // multi-monitor apis and the monitors returned by Config Manager.
        CConfigMgrDevice *pDevice = m_listAdapters.GetAt(iWhich);

        if (pDevice)
        {
            // Don't AddRef or release the device here, because we're just
            // passing the device through.
            *ppDeviceAdapter = pDevice;
            bRet = TRUE;
		}
	}

	return bRet;
}

BOOL CMultiMonitor::GetMonitorDevice(int iWhich, CConfigMgrDevice** ppDeviceMonitor)
{
    CConfigMgrDevicePtr pDeviceAdapter;
    BOOL                bRet = FALSE;

    if (ppDeviceMonitor && GetAdapterDevice(iWhich, &pDeviceAdapter))
    {
        bRet = pDeviceAdapter->GetChild(ppDeviceMonitor);
    }

    return bRet;
}

BOOL CMultiMonitor::GetAdapterDisplayName(int iWhich, CHString &strName)
{
    BOOL bRet = FALSE;

    if (iWhich >= 0 || iWhich < GetNumAdapters())
    {
#ifdef WIN9XONLY
        if (!IsWin98())
        {
            strName = L"DISPLAY";
        }
        else
        {
            strName.Format(L"\\\\.\\Display%d", iWhich + 1);
        }
#endif

#if NTONLY == 4
        strName = L"DISPLAY";
#endif

#if NTONLY >= 5
        strName.Format(L"\\\\.\\Display%d", iWhich + 1);
#endif
        bRet = TRUE;
    }

    return bRet;
}

DWORD CMultiMonitor::GetNumAdapters()
{
#if defined(WIN9XONLY) || NTONLY >= 5
    return m_listAdapters.GetSize();
#else
    return 1;
#endif
}

#if NTONLY == 4
void CMultiMonitor::GetAdapterServiceName(CHString &strName)
{
    strName = m_strService;
}
#endif

#ifdef NTONLY
BOOL CMultiMonitor::GetAdapterSettingsKey(
    int iWhich,
    CHString &strKey)
{
    BOOL     bRet = FALSE;
#if NTONLY == 4
    if (iWhich == 1)
    {
        strKey = m_strSettingsKey;

        bRet = TRUE;
    }
#else
    CHString strName;

    if (GetAdapterDisplayName(iWhich, strName))
    {
        // Get it from EnumDisplayDevices.
        // We can't just use iWhich in EnumDisplayDevices because more
        // than just display adapters show up from this call.  So, enum
        // them and stop when we find a matching PNPID.
        DISPLAY_DEVICE device = { sizeof(device) };

        for (int i = 0;
            EnumDisplayDevices(NULL, i, &device, 0);
            i++)
        {
            // Match up the display name (like \\.\Display#)
            if (!_wcsicmp(device.DeviceName, strName))
            {
                strKey = device.DeviceKey;
                TrimRawSettingsKey(strKey);

                bRet = TRUE;

                break;
            }
        }
    }

#endif
    return bRet;
}
#endif // #ifdef NTONLY

#ifdef NTONLY
void CMultiMonitor::TrimRawSettingsKey(CHString &strKey)
{
    // Key looks like:
    // \REGISTRY\Machine\System\ControlSet001\Services\mga64\Device0
    // We need to strip off the \REGISTRY\Machine stuff.
    int iBegin;

    strKey.MakeUpper();
    iBegin = strKey.Find(L"\\SYSTEM");

    if (iBegin != -1)
        strKey = strKey.Mid(iBegin + 1);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\mychkdsk.h ===
#ifndef _MYCHKDSKLOGDISK_H
#define _MYCHKDSKLOGDISK_H

// ChkDisk Method Return type
#define CHKDSKERR_NOERROR						0
#define CHKDSKERR_REMOTE_DRIVE					1
#define CHKDSKERR_DRIVE_REMOVABLE				2
#define CHKDSKERR_DRIVE_UNKNOWN					4
#define CHKDSKERR_DRIVE_NO_ROOT_DIR				3

#define	CHKDSK_VOLUME_LOCKED					1
#define CHKDSK_UNKNOWN_FS						2
#define CHKDSK_FAILED							3

// Method Names
#define METHOD_NAME_CHKDSK							L"chkdsk"
#define METHOD_NAME_SCHEDULEAUTOCHK					L"ScheduleAutoChk"
#define METHOD_NAME_EXCLUDEFROMAUTOCHK				L"ExcludeFromAutochk"

// argument names to the methods
#define METHOD_ARG_NAME_RETURNVALUE					L"ReturnValue"
#define METHOD_ARG_NAME_LOSTCLUSTERTREATMENT		L"LostClusterTreatMent"
#define METHOD_ARG_NAME_FIXERRORS					L"FixErrors"
#define METHOD_ARG_NAME_PHYSICALINTEGRITYCHECK		L"PhysicalIntegrityCheck"
#define METHOD_ARG_NAME_VIGOROUSINDEXCHECK			L"VigorousIndexCheck"
#define METHOD_ARG_NAME_SKIPFOLDERCYCLE				L"SkipFolderCycle"
#define METHOD_ARG_NAME_FORCEDISMOUNT				L"ForceDismount"
#define METHOD_ARG_NAME_RECOVERBADSECTORS			L"RecoverBadSectors"
#define METHOD_ARG_NAME_CHKDSKATBOOTUP				L"OkToRunAtBootup"
#define METHOD_ARG_NAME_LOGICALDISKARRAY			L"LogicalDisk"


#define CHKNTFS								L"ChkNtfs"

#ifdef NTONLY

// Definition for ChkDsk Call Back routines
typedef BOOLEAN (* QUERYFILESYSTEMNAME )(PWSTR, PWSTR, PUCHAR, PUCHAR, PNTSTATUS);

// This method is given as a callback routine to schedule on boot if the volume is locked.
BOOLEAN ScheduleAutoChkIfLocked( FMIFS_PACKET_TYPE PacketType, ULONG PacketLenght, PVOID PacketData );
// This is given as a callback routine to chkdsk to not to schedule for autochkdsk on boot up 
//if the volume is Lock
BOOLEAN DontScheduleAutoChkIfLocked( FMIFS_PACKET_TYPE PacketType, ULONG PacketLenght, PVOID PacketData );

BOOLEAN ProcessInformation ( FMIFS_PACKET_TYPE PacketType, ULONG	PacketLength, PVOID	PacketData );
// this variable is required to get the return value from the call back routine.

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\msinfo_cdrom.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MSInfo_CDRom.h
//
//  Purpose: Routines from msinfo for transfer rate and drive integrity
//
//***************************************************************************

#ifndef _MSINFO_CDROM_H
#define _MSINFO_CDROM_H





extern char FindNextCDDrive(char cCurrentDrive);
extern DWORD GetTotalSpace(LPCTSTR szRoot);
extern CHString FindFileBySize(LPCTSTR szDirectory, LPCTSTR szFileSpec, DWORD dwMinSize, DWORD dwMaxSize, BOOL bRecursive);
extern CHString MakePath(LPCTSTR szFirst, LPCTSTR szSecond);
extern CHString GetIntegrityFile(LPCTSTR szRoot);
extern CHString GetTransferFile(LPCTSTR szRoot);

//=============================================================================
// The following is for a class lifted from version 2.51 (and 2.5).
// First, we need to do some #define's to make this code compile.
//=============================================================================


//#define VOID			void
#define DEBUG_OUTF(X,Y)
#define DEBUG_MSGF(X,Y)	
//#define CHAR			char
//#define CONST			const
#define INLINE			inline
//#define Assert			ASSERT
#define cNULL			'\0'

//#ifndef BYTE
//	#define BYTE			unsigned char
//#endif

//#ifndef PBYTE
//	#define PBYTE			unsigned char *
//#endif

//#if !defined(_CDTEST_H)
//#define _CDTEST_H

///* These don't work with UNICODE, so we'll use the TCHAR typedefs.
#if !defined(PSZ)
typedef CHAR*           PSZ;
#endif
#if !defined(LPCTSTR)
typedef CONST TCHAR*     LPCTSTR;
#endif
//*/

INLINE BOOL ValidHandle (HANDLE handle)
{
    return ((handle != NULL) && (handle != INVALID_HANDLE_VALUE));
}

#ifdef _WIN32
#ifndef _WINMM_
#define	WINMMAPI	DECLSPEC_IMPORT
#else
#define	WINMMAPI
#endif
#define _loadds
#define _huge
#else
#define	WINMMAPI
#endif

//WINMMAPI DWORD WINAPI timeGetTime(void);

BOOL FileExists (LPCTSTR pszFile); //, POFSTRUCT pofs);
/*
INLINE BOOL FileDoesExist (LPCTSTR pszFile)
{
//    OFSTRUCT ofs;
    return (FileExists((LPCTSTR)pszFile));
}
*/

BOOL GetTempDirectory (LPTSTR pszTempDir, INT nMaxLen);

typedef double DOUBLE;

#define NUM_ELEMENTS(arr)       (sizeof(arr)/sizeof(arr[0]))
#define STR_LEN(str)            (NUM_ELEMENTS(str) - 1)

INLINE INT StringLength (LPCTSTR psz)
{
    return (lstrlen(psz));
}

#define PCVOID		const void *

INLINE INT CompareMemory (PCVOID pBlock1, PCVOID pBlock2, DWORD dwSize)
{
	return (memcmp(pBlock1, pBlock2, dwSize));
}

typedef enum _OS
{
    OS_WINDOWS95,
    OS_WIN32S,
    OS_WINNT
}
OS_TYPE;
CONST DWORD dwWIN32S_BIT =  0x80000000;
CONST DWORD dwWIN95_BIT =   0x40000000;

INLINE OS_TYPE GetOperatingSystem (VOID)
{
    DWORD dwVersion = GetVersion();
//    DEBUG_OUTF(TL_GARRULOUS, ("dwVersion = 0x%08lx\n", dwVersion));
    OS_TYPE os = ((dwVersion & dwWIN95_BIT) ?    OS_WINDOWS95 :
                  (dwVersion & dwWIN32S_BIT) ?   OS_WIN32S :
                                                 OS_WINNT);
    return (os);
}


#define szDOT _T(".")

CHString GetVolumeName (LPCTSTR pszRootPath);

INLINE BOOL IsWin95Running (VOID)
{
    BOOL bRunningWin95 = (GetOperatingSystem() == OS_WINDOWS95);

    return (bRunningWin95);
}

INLINE BOOL IsRegBinaryType (DWORD dwType)
{
    return (dwType == REG_BINARY);
}

INLINE BOOL IsRegStringType (DWORD dwType)
{
    return ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ)|| (dwType == REG_MULTI_SZ));
}

INLINE BOOL IsRegNumberType (DWORD dwType)
{
    return (dwType == REG_DWORD);
}

BOOL GetRegistryBinary (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue, 
                        PVOID pData, DWORD dwMaxDataLen);
BOOL GetRegistryValue (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                       PDWORD pdwValueType, PVOID pData, DWORD dwMaxDataLen);

CONST CHAR  cDOUBLE_QUOTE = '"';
CONST CHAR  cSINGLE_QUOTE = '\'';
CONST CHAR  cCOMMA =        ',';

INLINE BOOL IsSpace (CHAR c)        { return (isspace(c) != 0); }

INLINE BOOL IsTokenChar (CHAR c)    { return (!IsSpace(c) && (c != cCOMMA)); }

INLINE INT StringCompare (LPCTSTR psz1, LPCTSTR psz2)
{
    return (lstrcmp(psz1, psz2));
}

//CONST DWORD dwBLOCK_SIZE = 4096;
CONST INT nCD_SECTOR_SIZE = 2048;
//CONST DWORD dwBLOCK_SIZE = 24 * 1024;
CONST DWORD dwBLOCK_SIZE = 12 * nCD_SECTOR_SIZE;
CONST DWORD dwBUFFER_SIZE = 2 * dwBLOCK_SIZE;
//CONST DWORD dwMIN_RATE = 150 * 1024;
CONST DWORD dwEXP_RATE = 300 * 1024;
//CONST DWORD dwMAX_TIME_PER_BLOCK = dwMIN_RATE / dwBLOCK_SIZE;
CONST DWORD dwEXP_TIME_PER_BLOCK = dwEXP_RATE / dwBLOCK_SIZE;
CONST WCHAR szDRIVE_FMT[] = L"%c:\\";

INLINE LPTSTR PszAdvance (LPTSTR pszSource)
{
#if defined(DBCS)
    return AnsiNext(pszSource);
#else
    return (pszSource + 1);
#endif
}

INLINE LPCTSTR PcszAdvance (LPCTSTR pszSource)
{
#if defined(DBCS)
    return AnsiNext(pszSource);
#else
    return (pszSource + 1);
#endif
}

INLINE VOID CopyCharAdvance (LPTSTR& pszBuffer, LPCTSTR& pszSource, INT& nMax)
{
#if defined(DBCS)
    //  If the current character is a lead byte, copy it and advance pointers
    if (IsDBCSLeadByte(*pszSource))
    {
       *pszBuffer++ = *pszSource++;
       nMax--;
    }  
#endif
    //  Copy the current character and advance the pointers
    *pszBuffer++ = *pszSource++;
    nMax--;
}

#if defined(WIN32)
CONST INT nTEXT_BUFFER_MAX =    2048;
#else
CONST INT nTEXT_BUFFER_MAX =    512;
#endif

CONST TCHAR szDOS_DEVICE_FMT[] =         _T("%c:");
CONST TCHAR szDRIVER[] = 			_T("Driver");

BOOL FindCdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription);
BOOL FindWin95CdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription);
BOOL GetRegistrySubkeys (HKEY hBaseKey, LPCTSTR pszKey, CHStringArray& asSubkeys);
//BOOL GetRegistrySubkeys (HKEY hBaseKey, LPCTSTR pszKey, std::vector<CHString>& asSubkeys);
CHString GetRegistryString (HKEY hBaseKey, LPCTSTR pszSubkey, LPCTSTR pszValueName);
BOOL FindNtCdRomDriveInfo (TCHAR cDrive, CHString& sDriver, CHString& sDescription);
BOOL GetRegistryString (HKEY hBaseKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                        LPTSTR pszData, DWORD dwMaxDataLen);

INLINE BOOL IsQuoteChar (CHAR c)
{
    return ((c == cDOUBLE_QUOTE) || (c == cSINGLE_QUOTE));
}

INLINE LPCTSTR SkipSpaces (LPCTSTR pszSource)
{
    while (IsSpace(*pszSource))
    {
        pszSource = PcszAdvance(pszSource);
    }

    return (pszSource);
}

LPCTSTR ParseString (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    );
LPCTSTR ParseToken (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    );
LPCTSTR ParseQuotedString (
    LPCTSTR pszSource,
    LPTSTR pszBuffer,
    INT nLen
    );

INLINE BOOL IsNtRunning (VOID)
{
    BOOL bRunningNT = (GetOperatingSystem() == OS_WINNT);

    return (bRunningNT);
}

INLINE CHAR IntToChar (INT nChar)
{
    return ((CHAR)nChar);
}

INLINE CHAR ToUpper (CHAR c)        { return (IntToChar(toupper(c))); }

class CCdTest // : public CObject
{
//	DECLARE_DYNAMIC(CCdTest);

	//	Construction
public:
	CCdTest();
	//CCdTest (CHAR cDrive, LPCTSTR pszFile);
	~CCdTest();

	//	Implementation
public:
	CHAR m_cDrive;						// letter for CD drive
	CHString m_sCdTestFile;				// file to test
	CHString m_sTempFileSpec;			// file for temporary storage
	DOUBLE m_rTransferRate;				// profiled transfer rate
	DOUBLE m_rCpuUtil;					// est. CPU usage during the test
	DWORD m_dwExpTimePerBlock;			// time per block based on expected rate
	PBYTE m_pBufferSrc;					// main buffer for file transfers
	PBYTE m_pBufferDest;				// another buffer for file transfers
	PBYTE m_pBufferSrcStart;			// start of buffer for file transfers
	PBYTE m_pBufferDestStart;			// start of another buffer for file transfers
	DWORD m_dwBufferSize;				// size of the buffers
	//CFile m_fileSrc;					// file for the profiling & intregrity tests
	//CFile m_fileDest;					// additional file for the integrity test
    HANDLE m_hFileSrc;					// file handle for the profiling & intregrity tests
	HANDLE m_hFileDest;					// additional file handle for the integrity test
	DWORD m_dwTotalTime;				// total time spent blocked
	DWORD m_dwTotalBusy;				// total time during which the CD drive was busy
	BOOL m_bDoPacing;					// should the reads be paced at the expeected rate
	DWORD m_dwTotalBytes;				// total bytes read (so far)
	DWORD m_dwTotalCPU;					// total CPU time (sum of samples)
	INT m_nNumSamples;					// number of samples (blocks read)
	DWORD m_dwFileSize;					// size of the file (bytes)
	BOOL m_bIntegityOK;					// true unless integrity checks fail

	//	Attributes
	DOUBLE GetTransferRate (VOID)		{ return (m_rTransferRate); }
	DOUBLE GetCpuUsage (VOID)			{ return (m_rCpuUtil); }

	//	Operations
public:
	VOID Reset (VOID);
	BOOL ProfileBlockRead (DWORD dwBlockSize, BOOL bIgnoreTrial = FALSE);
	BOOL ProfileDrive (LPCTSTR pszFile);
	BOOL TestDriveIntegrity (LPCTSTR pszCdTestFile);
private:
	BOOL InitProfiling (LPCTSTR pszFile);
	BOOL InitIntegrityCheck (LPCTSTR pszFile);
	BOOL CompareBlocks (VOID);
};


//	Utility functions
//
DWORD GetCpuUtil (VOID);
CHString OLDFindFileBySize (LPCTSTR pszDirectory, LPCTSTR pszFileSpec, DWORD dwMinSize, DWORD dwMaxSize, BOOL bRecursive);
BOOL IsCdDrive (CHAR cDrive);
BOOL IsLocalDrive (CHAR cDrive);
CHAR FindNextCdDrive (CHAR cCurrent);
CHAR FindNextLocalDrive (CHAR cCurrentDrive);
CHAR FindDriveByVolume (CHString sVolume);
HANDLE OpenBinaryFile (LPCTSTR pszFile, BOOL bNew, BOOL bBuffered, BOOL bWritable);
HANDLE OpenFileNonbuffered (LPCTSTR pszFile);
PVOID AlignPointer (PVOID pData, INT nAlignment);


INLINE CHString MakeRootPath (CHAR cDrive)
{
    CHString sRootPath;
    sRootPath.Format(szDRIVE_FMT, cDrive);
    return (sRootPath);
}


#endif	// !defined(MSINFO_CDROM_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\multimonitor.h ===
//============================================================

//

// Multimonitor.h - Multiple Monitor API helper class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 11/23/97     a-sanjes     created
//
//============================================================

#ifndef __MULTIMONITOR_H__
#define __MULTIMONITOR_H__

// Forward class definitions
class CConfigMgrDevice;
class CDeviceCollection;

class CMultiMonitor
{
public:
    CMultiMonitor();
    ~CMultiMonitor();

    BOOL GetMonitorDevice(
        int iWhich, 
        CConfigMgrDevice** ppDeviceMonitor);

    BOOL GetAdapterDevice(
        int iWhich, 
        CConfigMgrDevice** ppDeviceAdapter);

    DWORD GetNumAdapters();
    BOOL GetAdapterDisplayName(int iWhich, CHString &strName);

#if NTONLY == 4
    void GetAdapterServiceName(CHString &strName);
#endif

#ifdef NTONLY
    BOOL GetAdapterSettingsKey(int iWhich, CHString &strKey);
#endif

protected:
	void Init();
	
	CDeviceCollection m_listAdapters;

#if NTONLY == 4
    CHString m_strService,
             m_strSettingsKey;
#endif

    void TrimRawSettingsKey(CHString &strKey);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\netadapter.h ===
//=================================================================

//

// NetAdapt.h -- Network adapter card property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//
//=================================================================
#define	NTOS_PERF_DATA_SYSTEM_INDEX_STR		_T("2")
#define	NTOS_PERF_DATA_SYSTEM_INDEX			2
#define	NTOS_PERF_DATA_SYSTEMUPTIME_INDEX	674

// Property set identification
//============================

#define	PROPSET_NAME_NETADAPTER	L"Win32_NetworkAdapter"

// Utility defines
//================

typedef struct _NDIS_MEDIA_DESCRIPTION {
    
    DWORD		dwIDR_;
    NDIS_OID    NDISOid ;
    
} NDIS_MEDIA_DESCRIPTION ;


// Comparison class required for imap
// costructor involving non-standard key
// type (i.e., a LPWSTR) in the map.
class CWSTRComp
{
public:
    CWSTRComp() {}
    virtual ~CWSTRComp() {}

    // return true if p < q lexicographically...
    bool operator()(
        const LPWSTR& p,
        const LPWSTR& q) const
    {
        return (wcscmp(p, q) < 0);
    }
};

class NCPROP
{
public:
    NCPROP() {}
    NCPROP(
        LPCWSTR wstrNCID,
        DWORD dwNCStatus)
    {
        m_bstrtNCID = wstrNCID;
        m_dwNCStatus = dwNCStatus;
    }

    NCPROP(const NCPROP& ncpRight)
    {
        m_bstrtNCID = ncpRight.m_bstrtNCID;
        m_dwNCStatus = ncpRight.m_dwNCStatus;    
    }

    virtual ~NCPROP() {}

    _bstr_t m_bstrtNCID;
    DWORD m_dwNCStatus;
};


typedef std::map<_bstr_t,NCPROP,CWSTRComp> BSTRT2NCPROPMAP;


// Property set identification
//============================

class CWin32NetworkAdapter : public Provider
{
	private:

			// Utility functions
			//==================
		#ifdef WIN9XONLY
			HRESULT GetNetworkAdapterInfoWin95( MethodContext *a_pMethodContext, CInstance *a_pInst ) ;
		#endif

		#ifdef NTONLY
			HRESULT GetNetworkAdapterInfoNT( MethodContext *pMethodContext, CInstance *a_pInst ) ;
		#endif
			BOOL GetNetInfoOutOfRegistry(	CInstance *a_pInst, 
											ComNet &a_NetCom,
											CHString &a_ServiceName,
											CHString &a_Owner ) ;

			void GetStatusInfo( CHString a_sTemp, CInstance *a_pInst ) ;

		#ifdef NTONLY

			HRESULT DoItNT4Way( CInstance *a_pInst, DWORD a_dwIndex, CRegistry &a_RegInfo ) ;
			HRESULT GetCommonNTStuff( CInstance *a_pInst, CHString a_chsService ) ;

			// PNP DeviceID helpers
			void GetWinNT4PNPDeviceID( CInstance *a_pInst, LPCTSTR a_pszServiceName ) ;
			void GetWinNT5PNPDeviceID( CInstance *a_pInst, LPCTSTR a_pszDriver ) ;

			BOOL fGetMacAddressAndType(
										CHString &a_rDeviceName,
										BYTE a_MACAddress[ 6 ],
										CHString &a_rTypeName, 
                                        short& a_sNetAdapterTypeID ) ;
		#endif

			BOOL fCreateSymbolicLink( CHString &a_rDeviceName ) ;
			BOOL fDeleteSymbolicLink(  CHString &a_rDeviceName ) ; 

			void vSetCaption( CInstance *a_pInst, CHString &a_rchsDesc, DWORD a_dwIndex, int a_iFormatSize ) ;
    public:

        // Constructor/destructor
			//=======================

			CWin32NetworkAdapter(LPCWSTR a_strName, LPCWSTR a_pszNamespace ) ;
		   ~CWin32NetworkAdapter() ;

			// Functions provide properties with current values
			//=================================================

			virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
			virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
		
		#if NTONLY >= 5
			virtual HRESULT EnumNetAdaptersInNT5(
                MethodContext *a_pMethodContext,
                BSTRT2NCPROPMAP& mapNCProps);

			HRESULT GetNetCardInfoForNT5(
                CW2kAdapterInstance *a_pAdapterInst, 
                CInstance *a_pInst,
                BSTRT2NCPROPMAP& mapNCProps);

			HRESULT GetObjectNT5( 
                CInstance *a_pInst,
                BSTRT2NCPROPMAP& mapNCProps);

            void GetNetConnectionProps(
                BSTRT2NCPROPMAP& mapNCProps);

            void SetNetConnectionProps(
                CInstance* pInst,
                CHString& chstrNetConInstID, 
                BSTRT2NCPROPMAP& mapNCProps);
		#endif
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\netadapter.cpp ===
//=================================================================

//

// NetAdapt.CPP -- Network Adapter Card property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   08/28/96    a-jmoon        Created
//
//				03/03/99				Added graceful exit on SEH and memory failures,
//											syntactic clean up
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "resource.h"
#include <cregcls.h>
#include <devioctl.h>
#include <ntddndis.h>
#include "chwres.h"
#include "netcom.h"
#include "W2kEnum.h"
#include "NetAdapter.h"
#include "perfdata.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "ntlastboottime.h"

#include "netcon.h"

// BA126AD1-2166-11D1-B1D0-00805FC1270E     CLSID_ConnectionManager
DEFINE_GUID(CLSID_ConnectionManager,          
0xBA126AD1,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);



#define NTINVALID 1
#define NT4 2
#define NT5 3
// Property set declaration
//=========================
CWin32NetworkAdapter	win32NetworkAdapter( PROPSET_NAME_NETADAPTER, IDS_CimWin32Namespace ) ;

static NDIS_MEDIA_DESCRIPTION g_NDISMedia[] =  {

    { IDR_NdisMedium802_3,		OID_802_3_CURRENT_ADDRESS	},
    { IDR_NdisMedium802_5,		OID_802_5_CURRENT_ADDRESS	},
    { IDR_NdisMediumFddi,		OID_FDDI_LONG_CURRENT_ADDR	},
    { IDR_NdisMediumWan,		OID_WAN_CURRENT_ADDRESS		},
    { IDR_NdisMediumLocalTalk,	OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumDix,		OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumArcnetRaw,	OID_ARCNET_CURRENT_ADDRESS	},
	{ IDR_NdisMediumArcnet878_2,OID_ARCNET_CURRENT_ADDRESS	},
	{ IDR_NdisMediumAtm,		OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumWirelessWan,OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumIrda,		OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumBpc,		OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMediumCoWan,		OID_802_3_CURRENT_ADDRESS	},
	{ IDR_NdisMedium1394,		OID_802_3_CURRENT_ADDRESS	}
} ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapter::CWin32NetworkAdapter
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for provider.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32NetworkAdapter::CWin32NetworkAdapter(LPCWSTR a_strName, LPCWSTR a_pszNamespace /*=NULL*/ )
:	Provider( a_strName, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapter::~CWin32NetworkAdapter
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32NetworkAdapter::~CWin32NetworkAdapter()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32NetworkAdapter::GetObject
//
//	Inputs:		CInstance*		a_pInst - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32NetworkAdapter::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{

    HRESULT t_hResult ;

	#ifdef WIN9XONLY
        t_hResult = GetNetworkAdapterInfoWin95( NULL, a_pInst ) ;
	#endif

	#ifdef NTONLY
		#if NTONLY >= 5
		{
			BSTRT2NCPROPMAP mapNCProps;
            GetNetConnectionProps(
                mapNCProps);
            t_hResult = GetObjectNT5( 
                a_pInst,
                mapNCProps ) ;
		}
		#else
		{
			t_hResult = GetNetworkAdapterInfoNT( NULL, a_pInst ) ;
		}
		#endif
	#endif
    return t_hResult ;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32NetworkAdapter::EnumerateInstances
//
//	Inputs:		MethodContext   *pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32NetworkAdapter::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
    HRESULT t_hResult;

	#ifdef WIN9XONLY
        t_hResult = GetNetworkAdapterInfoWin95( a_pMethodContext,NULL ) ;
	#endif

	#ifdef NTONLY
		#if NTONLY >= 5
		{
			BSTRT2NCPROPMAP mapNCProps;
            GetNetConnectionProps(
                mapNCProps);
            t_hResult = EnumNetAdaptersInNT5( 
                a_pMethodContext,
                mapNCProps) ;
		}
		#else
		{
			t_hResult = GetNetworkAdapterInfoNT( a_pMethodContext, NULL ) ;
		}
		#endif
	#endif

    return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapter::GetStatusInfo
 *
 *  DESCRIPTION : Loads property values according to passed network card index
 *
 *  INPUTS      : DWORD Index -- index of desired network card
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if indicated card was found, FALSE otherwise
 *
 *  COMMENTS    : The return code is based solely on the ability to discover
 *                the indicated card.  Any properties not found are simply not
 *                available
 *
 *****************************************************************************/
#ifdef NTONLY
void CWin32NetworkAdapter::GetStatusInfo( CHString a_sTemp, CInstance *a_pInst )
{
	CHString	t_chsKey,
				t_chsTmp;
	CRegistry	t_Reg;

	t_chsKey = _T("System\\CurrentControlSet\\Services\\") + a_sTemp + _T("\\Enum" ) ;

	if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
	{
		if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("0"), t_chsTmp ) )
		{
			t_chsKey = _T("System\\CurrentControlSet\\Enum\\") + t_chsTmp ;

			if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
			{
				DWORD t_dwTmp ;

				if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("StatusFlags"), t_dwTmp ) )
				{
    				ConfigStatusToCimStatus ( t_dwTmp , t_chsTmp ) ;

					a_pInst->SetCHString(IDS_Status, t_chsTmp ) ;

                    if ( t_chsTmp.CompareNoCase( IDS_STATUS_OK ) == 0)
					{
    					a_pInst->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
					    a_pInst->SetWBEMINT16( IDS_Availability, 3 ) ;

                    }
					else if ( t_chsTmp.CompareNoCase( IDS_STATUS_Degraded ) == 0 )
					{
    					a_pInst->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
					    a_pInst->SetWBEMINT16( IDS_Availability, 10 ) ;
                    }
					else if ( t_chsTmp.CompareNoCase( IDS_STATUS_Error ) == 0 )
					{
    					a_pInst->SetWBEMINT16( IDS_StatusInfo, 4 ) ;
					    a_pInst->SetWBEMINT16( IDS_Availability, 4 ) ;
                    }
					else
					{
					    a_pInst->SetWBEMINT16( IDS_Availability, 2 ) ;
    					a_pInst->SetWBEMINT16( IDS_StatusInfo, 2 ) ;
                    }
				}
			}
		}
	}
}
#endif

//
#ifdef NTONLY
HRESULT CWin32NetworkAdapter::DoItNT4Way( CInstance *a_pInst, DWORD dwIndex, CRegistry &a_RegInfo )
{
    CHString	t_sTemp,
				t_chsKey,
				t_chsService ;
    CRegistry	t_Reg ;
    BOOL		t_fRc = FALSE ;
	FILETIME	t_ft ;

	a_pInst->SetDWORD( IDS_Index,dwIndex ) ;

	if( a_RegInfo.GetCurrentKeyValue( _T("ProductName"), t_sTemp ) == ERROR_SUCCESS )
	{
		//========================================================
		//  if we are going for a specific device here, let us
		//  check and see if it is the correct one.
		//========================================================

		// Pull up our Device ID.
		GetWinNT4PNPDeviceID( a_pInst, t_sTemp ) ;

		// Note: Under nt4 ProductName is a ServiceName and
		// ServiceName is a ProductName
		a_pInst->SetCHString( IDS_ServiceName, t_sTemp ) ;

		GetStatusInfo( t_sTemp,a_pInst ) ;
	}

	SetCreationClassName( a_pInst ) ;
	a_pInst->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;

	a_pInst->Setbool( IDS_PowerManagementSupported, FALSE ) ;

//	a_pInst->Setbool( IDS_PowerManagementEnabled, FALSE ) ;
 	a_pInst->SetDWORD( IDS_MaxNumberControlled,0 ) ;

	// Get the last boot time
	CNTLastBootTime	t_ntLastBootTime ;

	if ( t_ntLastBootTime.GetLastBootTime( t_ft ) )
	{
		a_pInst->SetDateTime( IDS_TimeOfLastReset, WBEMTime(t_ft) ) ;
	}

	if( a_RegInfo.GetCurrentKeyValue(_T("Title"), t_sTemp) == ERROR_SUCCESS )
	{
    	// NOTE: For NT4 we need not call vSetCaption() to build
		// an instance description _T("Title") has the instance prepended.
		a_pInst->SetCHString( IDS_Caption, t_sTemp ) ;

		a_pInst->SetCHString( IDS_Name, t_sTemp ) ;
		t_sTemp.MakeUpper() ;
	}

    if( a_RegInfo.GetCurrentKeyValue( _T("ServiceName"), t_chsService ) == ERROR_SUCCESS )
	{
	    a_pInst->SetCHString( IDS_DeviceID, t_chsService ) ;
        t_fRc = TRUE ;
    }
    if( a_RegInfo.GetCurrentKeyValue( _T("Manufacturer"), t_sTemp ) == ERROR_SUCCESS)
	{
        a_pInst->SetCHString( IDS_Manufacturer, t_sTemp ) ;
	}

	WBEMTime	t_wbemtime ;
    DWORD		t_dwTemp ;

    if( a_RegInfo.GetCurrentKeyValue( _T("InstallDate"), t_dwTemp ) == ERROR_SUCCESS )
	{
        t_wbemtime = t_dwTemp ;
		a_pInst->SetDateTime( IDS_InstallationDate, t_wbemtime ) ;
	}


	CHString t_csDescription ;
	if( a_RegInfo.GetCurrentKeyValue( _T("Description"), t_csDescription ) == ERROR_SUCCESS )
	{
	    a_pInst->SetCHString( IDS_Description, t_csDescription ) ;
	}

	// Retrieve the adapter MAC address
	BYTE t_MACAddress[ 6 ] ;
	CHString t_csAdapterType ;
    short t_sAdapterTypeID;

	if( fGetMacAddressAndType( t_chsService, t_MACAddress, t_csAdapterType, t_sAdapterTypeID ) )
	{
		CHString	t_chsMACAddress;
					t_chsMACAddress.Format( _T("%02X:%02X:%02X:%02X:%02X:%02X"),
											t_MACAddress[ 0 ], t_MACAddress[ 1 ],
											t_MACAddress[ 2 ], t_MACAddress[ 3 ],
											t_MACAddress[ 4 ], t_MACAddress[ 5 ] ) ;

		a_pInst->SetCHString( IDS_MACAddress, t_chsMACAddress ) ;
	}

	// AdapterType
	if( !t_csAdapterType.IsEmpty() )
	{
		a_pInst->SetCHString( IDS_AdapterType, t_csAdapterType ) ;
        a_pInst->SetWBEMINT16( IDS_AdapterTypeID, t_sAdapterTypeID );
	}




	return GetCommonNTStuff( a_pInst, t_chsService ) ;
}
#endif

////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT CWin32NetworkAdapter::GetCommonNTStuff( CInstance *a_pInst, CHString a_chsService )
{
	TCHAR	t_szTemp[ _MAX_PATH ] ;
			t_szTemp[ 0 ] = NULL ;

	// Note: Under nt4 ProductName is a ServiceName and
	// ServiceName is a ProductName
	a_pInst->SetCHString( IDS_ProductName, a_chsService ) ;

	a_pInst->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;

	SetCreationClassName( a_pInst ) ;

	a_pInst->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;

    return WBEM_S_NO_ERROR ;
}
#endif

/*******************************************************************
    NAME:       fGetMacAddressAndType

    SYNOPSIS:	retrieves the MAC address from the adapter driver.


    ENTRY:      BYTE* MACAddress[6]		:
				CHString& rDeviceName		:


    HISTORY:
                  08-Aug-1998     Created
********************************************************************/
#ifdef NTONLY
BOOL CWin32NetworkAdapter::fGetMacAddressAndType(
CHString &a_rDeviceName,
BYTE a_MACAddress[ 6 ],
CHString &a_rAdapterType,
short& a_sAdapterTypeID )
{
	BOOL t_fRet = FALSE;

	BOOL	t_fCreatedSymLink = fCreateSymbolicLink( a_rDeviceName ) ;
	SmartCloseHandle	t_hMAC;

	try
	{
		//
		// Construct a device name to pass to CreateFile
		//
		CHString t_chsAdapterPathName(_T("\\\\.\\") ) ;
				 t_chsAdapterPathName += a_rDeviceName;

		t_hMAC = CreateFile(
					t_chsAdapterPathName,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					0,
					INVALID_HANDLE_VALUE
					 ) ;

		do	// breakout
		{
			if( INVALID_HANDLE_VALUE == t_hMAC )
			{
				break;
			}

			//
			// We successfully opened the driver, format the
			// IOCTL to pass the driver.
			//
			UCHAR       t_OidData[ 4096 ] ;
			NDIS_OID    t_OidCode ;
			DWORD       t_ReturnedCount ;

			// get the supported media types
			t_OidCode = OID_GEN_MEDIA_IN_USE ;

			if( DeviceIoControl(
								t_hMAC,
								IOCTL_NDIS_QUERY_GLOBAL_STATS,
								&t_OidCode,
								sizeof( t_OidCode ),
								t_OidData,
								sizeof( t_OidData ),
								&t_ReturnedCount,
								NULL
								) && (4 <= t_ReturnedCount ) )
			{


				// Seek out the media type for MAC address reporting.
				// Since this adapter may support more than one media type we'll use
				// the enumeration preference order. In most all cases only one type
				// will be current.

				_NDIS_MEDIUM *t_pTypes = (_NDIS_MEDIUM*)&t_OidData ;
				_NDIS_MEDIUM t_eMedium = t_pTypes[ 0 ] ;

				for( DWORD t_dwtypes = 1; t_dwtypes < t_ReturnedCount / 4; t_dwtypes++ )
				{
					if( t_eMedium > t_pTypes[ t_dwtypes ] )
					{
						t_eMedium = t_pTypes[ t_dwtypes ] ;
					}
				}

				// map to current address OID and medium type string
				if( t_eMedium < sizeof( g_NDISMedia ) / sizeof( g_NDISMedia[0] ) )
				{
					LoadStringW( a_rAdapterType, g_NDISMedia[ t_eMedium ].dwIDR_ ) ;
                    a_sAdapterTypeID = t_eMedium;

					t_OidCode = g_NDISMedia[ t_eMedium ].NDISOid ;
				}
				else
				{
					t_OidCode = OID_802_3_CURRENT_ADDRESS ;
				}
			}
			else
			{
				t_OidCode = OID_802_3_CURRENT_ADDRESS ;
			}

			if( !DeviceIoControl(
									t_hMAC,
									IOCTL_NDIS_QUERY_GLOBAL_STATS,
									&t_OidCode,
									sizeof( t_OidCode ),
									t_OidData,
									sizeof( t_OidData ),
									&t_ReturnedCount,
									NULL  ) )
			{
				break ;
			}

			if( 6 != t_ReturnedCount )
			{
				break;
			}

			memcpy( a_MACAddress, &t_OidData, 6 ) ;

			t_fRet = TRUE;

		} while( FALSE ) ;

	}
	catch( ... )
	{
		if( t_fCreatedSymLink )
		{
			fDeleteSymbolicLink( a_rDeviceName ) ;
		}

		throw ;
	}

	if( t_fCreatedSymLink )
	{
		fDeleteSymbolicLink( a_rDeviceName ) ;
		t_fCreatedSymLink = FALSE ;
	}
 	return t_fRet ;
}
#endif

/*******************************************************************
    NAME:       fCreateSymbolicLink

    SYNOPSIS:	Tests for and creates if necessary a symbolic device link.


    ENTRY:      CHString& rDeviceName		: device name

	NOTES:		Unsupported for Win95

	HISTORY:
                  08-Aug-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapter::fCreateSymbolicLink( CHString &a_rDeviceName )
{
	TCHAR	t_LinkName[ 512 ] ;

	// Check to see if the DOS name for the device already exists.
	// Its not created automatically in version 3.1 but may be later.
	//
	if( !QueryDosDevice( TOBSTRT( a_rDeviceName ), (LPTSTR) t_LinkName, sizeof( t_LinkName ) / sizeof( TCHAR ) ) )
	{
		// On any error other than "file not found" return
		if( ERROR_FILE_NOT_FOUND != GetLastError() )
		{
			return FALSE ;
		}

		//
		// It doesn't exist so create it.
		//
		CHString t_chsTargetPath = _T("\\Device\\") ;
				 t_chsTargetPath += a_rDeviceName ;

		if( !DefineDosDevice( DDD_RAW_TARGET_PATH, TOBSTRT( a_rDeviceName ), TOBSTRT( t_chsTargetPath ) ) )
		{
			return FALSE ;
		}

		return TRUE ;
	}
	return FALSE ;
}

/*******************************************************************
    NAME:       fDeleteSymbolicLink

    SYNOPSIS:	deletes a symbolic device name.


    ENTRY:      CHString& rSymDeviceName	: symbolic device name

	NOTES:		Unsupported for Win95

    HISTORY:
                  08-Aug-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapter::fDeleteSymbolicLink(  CHString &a_rDeviceName )
{
	//
	// The driver wasn't visible in the Win32 name space so we created
	// a link.  Now we have to delete it.
	//
	CHString t_chsTargetPath = L"\\Device\\" ;
			 t_chsTargetPath += a_rDeviceName ;

	if( !DefineDosDevice(
							DDD_RAW_TARGET_PATH |
							DDD_REMOVE_DEFINITION |
							DDD_EXACT_MATCH_ON_REMOVE,
							TOBSTRT( a_rDeviceName ),
							TOBSTRT( t_chsTargetPath ) ) )
	{
		return FALSE ;
	}

	return TRUE ;
}

//////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT CWin32NetworkAdapter::GetNetworkAdapterInfoNT( MethodContext	*a_pMethodContext,
													   CInstance		*a_pSpecificInstance )
{
    HRESULT		t_hResult;
	DWORD		t_dwIndex = 0 ;
    CHString	t_chsService ;
	CRegistry	t_Reg ;
	CHString	t_sTmp ;

   	// smart ptr
	CInstancePtr t_pInst ;


	if (a_pMethodContext)
    {
        t_hResult = WBEM_S_NO_ERROR;
    }
    else
    {
        t_hResult = WBEM_E_NOT_FOUND;
    }

    if( ERROR_SUCCESS == t_Reg.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE,
														_T("Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards"),
														KEY_READ ) )
	{
		for( int t_i = 0; t_i < t_Reg.GetCurrentSubKeyCount(); t_i++ )
		{
		    if( ERROR_SUCCESS == t_Reg.GetCurrentSubKeyName( t_sTmp ) )
			{
				t_dwIndex = _ttoi( t_sTmp ) ;

				CRegistry t_SubKeyReg ;

				if( t_SubKeyReg.Open( t_Reg.GethKey(), t_sTmp, KEY_READ ) == ERROR_SUCCESS )
				{
				    CHString	t_chsDeviceId,
								t_chsTmp ;

                    // Getobject
					if( !a_pMethodContext )
					{
					    t_pInst = a_pSpecificInstance ;

						t_pInst->GetCHString( IDS_DeviceID, t_chsDeviceId ) ;

						if( t_SubKeyReg.GetCurrentKeyValue( _T("ServiceName" ), t_chsTmp ) == ERROR_SUCCESS )
						{
							if( t_chsTmp.CompareNoCase( t_chsDeviceId ) == 0 )
							{
								t_hResult = DoItNT4Way( t_pInst, t_dwIndex, t_SubKeyReg ) ;

								break ;
							}
						}
					}
					else
					{
                        // Enumerate
				    	t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

						t_hResult = DoItNT4Way( t_pInst, t_dwIndex, t_SubKeyReg ) ;

						if( SUCCEEDED( t_hResult ) )
				        {
				        	t_hResult = t_pInst->Commit() ;
					    }

						if( !SUCCEEDED( t_hResult ) )
						{
							break;
						}
					}
				}
			}

			t_Reg.NextSubKey() ;
		}
	}

	return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapter::GetNetInfoOutOfRegistry
 *
 *  DESCRIPTION : Loads property values according to passed network card index
 *
 *  INPUTS      : DWORD Index -- index of desired network card
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if indicated card was found, FALSE otherwise
 *
 *  COMMENTS    : The return code is based solely on the ability to discover
 *                the indicated card.  Any properties not found are simply not
 *                available
 *
 *****************************************************************************/
/////////////////////////////////////////////////////////////////////////
BOOL CWin32NetworkAdapter::GetNetInfoOutOfRegistry( CInstance	*a_pInst,
													ComNet		&a_NetCom,
													CHString	&a_ServiceName,
													CHString	&a_Owner )
{
    BOOL		t_fRc = FALSE ;
	CHString	t_chsTmp ;
	CHString	t_chsPNPDeviceID ;

    if( a_NetCom.GetDeviceDesc( a_pInst, _T("Description"), a_Owner ) )
    {
		a_pInst->SetCHString( L"ProductName", a_Owner ) ;
		a_pInst->SetCHString( IDS_Name, a_Owner ) ;

		a_NetCom.GetMfg( a_pInst ) ;

		a_pInst->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;

		a_NetCom.GetCfgMgrId( t_chsPNPDeviceID ) ;

		CConfigManager		t_Cfg ;
		CConfigMgrDevicePtr t_pNetDevice;

		if( t_Cfg.LocateDevice ( t_chsPNPDeviceID, &t_pNetDevice ) )
		{
			SetConfigMgrProperties( t_pNetDevice, a_pInst ) ;

			if( t_pNetDevice->GetStatus( t_chsTmp ) )
			{
				a_pInst->SetCHString( IDS_Status, t_chsTmp ) ;

				if ( t_chsTmp.CompareNoCase( IDS_STATUS_OK ) == 0)
				{
    				a_pInst->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
					a_pInst->SetWBEMINT16(IDS_Availability, 3 ) ;
				}
				else if ( t_chsTmp.CompareNoCase( IDS_STATUS_Degraded ) == 0)
				{
    				a_pInst->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
					a_pInst->SetWBEMINT16( IDS_Availability, 10 ) ;
				}
				else if ( t_chsTmp.CompareNoCase( IDS_STATUS_Error ) == 0)
				{
    				a_pInst->SetWBEMINT16( IDS_StatusInfo, 4 ) ;
					a_pInst->SetWBEMINT16( IDS_Availability, 4 ) ;
				}
				else
				{
    				a_pInst->SetWBEMINT16( IDS_StatusInfo, 2 ) ;
					a_pInst->SetWBEMINT16( IDS_Availability, 2 ) ;
				}
			}
		}
		else if( !t_chsPNPDeviceID.IsEmpty() )
		{
			a_pInst->SetCHString( IDS_PNPDeviceID, t_chsPNPDeviceID ) ;
		}

		a_pInst->Setbool( IDS_PowerManagementSupported, FALSE ) ;

//		a_pInst->Setbool( IDS_PowerManagementEnabled, FALSE ) ;
		a_pInst->SetDWORD(IDS_MaxNumberControlled,0 ) ;

        t_fRc = TRUE ;

        if( a_NetCom.OpenDriver() )
		{
   			a_NetCom.GetDriverDate( a_pInst ) ;
            a_NetCom.GetDeviceVXDs( a_pInst, a_ServiceName ) ;
        }
    }
    return t_fRc;
}

#ifdef WIN9XONLY
HRESULT CWin32NetworkAdapter::GetNetworkAdapterInfoWin95(	MethodContext	*a_pMethodContext,
															CInstance		*a_pSpecificInstance )
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	DWORD		t_dwIndex = 0 ;
	CHString	t_chsGenDeviceID ;
	ComNet		t_oNetCom ;

	// smart ptr
	CInstancePtr t_pInst;

	if( !t_oNetCom.SearchForNetKeys() )
	{
		if( a_pSpecificInstance )
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}

		return t_hResult;
	}

	while( SUCCEEDED( t_hResult ) )
	{
		DWORD	t_dwRegInstance ;
		BOOL	t_fNetComValid = FALSE;

		// exhaust the registry adapters
		if( !t_oNetCom.OpenNetKey() )
		{
			if( a_pSpecificInstance )
			{
				t_hResult = WBEM_E_NOT_FOUND ;
			}
			break;
		}

		// zero based registry enumeration index
		int t_iCtrIndex = t_oNetCom.GetNetInstance( t_dwRegInstance ) ;

		if( 0 > t_iCtrIndex )
		{
			continue;	// invalid net driver instance
		}

		t_chsGenDeviceID.Format( L"%u", t_dwRegInstance ) ;

		//=====================================================
        //  If we are enumerating, then create a new instance
        //=====================================================
        if( a_pMethodContext )
		{
            t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

			if ( NULL == t_pInst )
			{
                return WBEM_E_FAILED ;
			}

			t_pInst->SetCHString( IDS_DeviceID, t_chsGenDeviceID ) ;
        }
		else
		{
			t_pInst = a_pSpecificInstance ;

			CHString t_chsDevice ;
			t_pInst->GetCHString( IDS_DeviceID, t_chsDevice ) ;

			if( t_chsDevice.CompareNoCase( t_chsGenDeviceID ) != 0 )
			{
                continue ;
            }
		}

		// Commenting this will disable associations to NetworkAdapterConfiguration.
		// Because of the current difficulty in binding a registry represented adapter
		// with a TDI kernal adapter associations between the two will not be supported
		// at this time under Win9x
		//t_pInst->SetDWORD( IDS_Index, t_iCtrIndex ) ;

		CHString	t_ServiceName,
					t_Owner ;

		SetCreationClassName( t_pInst ) ;

		t_pInst->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;
		t_pInst->SetWCHARSplat( IDS_Status, IDS_STATUS_OK ) ;
		t_pInst->SetDWORD( IDS_StatusInfo, 2 ) ;

 		GetNetInfoOutOfRegistry( t_pInst, t_oNetCom, t_ServiceName, t_Owner ) ;

		vSetCaption( t_pInst, t_Owner, t_dwRegInstance, 4 ) ;

		t_pInst->SetDWORD( L"MaxNumberControlled", 0 ) ;

		if( a_pMethodContext )
		{
            t_hResult = t_pInst->Commit() ;
        }
		else
		{
			break;
		}
    }

    return t_hResult;
}
#endif

#if NTONLY >= 5
HRESULT CWin32NetworkAdapter::EnumNetAdaptersInNT5(
    MethodContext *a_pMethodContext,
    BSTRT2NCPROPMAP& mapNCProps)
{
	HRESULT				t_hResult = WBEM_S_NO_ERROR ;
	CW2kAdapterEnum		t_oAdapterEnum ;
	CW2kAdapterInstance *t_pAdapterInst ;

	// smart ptr
	CInstancePtr t_pInst;

	// loop through the W2k identified instances
	for( int t_iCtrIndex = 0 ; t_iCtrIndex < t_oAdapterEnum.GetSize() ; t_iCtrIndex++ )
	{
		if( !( t_pAdapterInst = (CW2kAdapterInstance*) t_oAdapterEnum.GetAt( t_iCtrIndex ) ) )
		{
			continue;
		}

		t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

		// Drop out nicely if the Instance allocation fails
		if ( NULL != t_pInst )
		{
			// set the association index
			t_pInst->SetDWORD( _T("Index"), t_pAdapterInst->dwIndex ) ;

			CHString	t_chsIndex ;
						t_chsIndex.Format(_T("%u"), t_pAdapterInst->dwIndex ) ;

			// primary key
			t_pInst->SetCHString( IDS_DeviceID, t_chsIndex ) ;

			// We load adapter data here.
			t_hResult = GetNetCardInfoForNT5(
                t_pAdapterInst, 
                t_pInst,
                mapNCProps) ;

			if (SUCCEEDED( t_hResult ) )
			{
				t_hResult = t_pInst->Commit() ;
			}
			else
			{
				break ;
			}
		}
	}

	return t_hResult ;
}
#endif

#if NTONLY >= 5
HRESULT CWin32NetworkAdapter::GetNetCardInfoForNT5(
    CW2kAdapterInstance *a_pAdapterInst,
    CInstance	*a_pInst,
    BSTRT2NCPROPMAP& mapNCProps)
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR;
	FILETIME	t_ft ;
	CHString	t_sTemp ;

	// PNP deviceID
	CHString t_strDriver(_T("{4D36E972-E325-11CE-BFC1-08002BE10318}\\") ) ;

	t_strDriver += a_pAdapterInst->chsPrimaryKey ;

	GetWinNT5PNPDeviceID( a_pInst, t_strDriver ) ;

	// descriptions
	CHString t_csDeviceID( a_pAdapterInst->chsCaption ) ;
	CHString t_csDescription( a_pAdapterInst->chsDescription ) ;

	// in the event one of the descriptions is missing as with NT5 bld 1991
	if( t_csDescription.IsEmpty() )
	{
		t_csDescription = t_csDeviceID;
	}
	else if( t_csDeviceID.IsEmpty() )
	{
		t_csDeviceID = t_csDescription;
	}

	// Caption/Description
	vSetCaption( a_pInst, t_csDeviceID, a_pAdapterInst->dwIndex, 8 ) ;

	a_pInst->SetCHString( IDS_Description, t_csDescription ) ;
	a_pInst->SetCHString( IDS_Name, t_csDescription ) ;
	a_pInst->SetCHString( IDS_ProductName, t_csDescription ) ;
	a_pInst->SetCHString( _T("SystemName"), GetLocalComputerName() ) ;

	SetCreationClassName( a_pInst ) ;

	a_pInst->SetWBEMINT16( IDS_Availability, 3 ) ;

	a_pInst->Setbool( IDS_Installed, true ) ;


	// CIM
	a_pInst->Setbool( IDS_PowerManagementSupported, FALSE ) ;
	a_pInst->SetDWORD( IDS_MaxNumberControlled,0 ) ;
	a_pInst->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;

	// Get the last boot time
	CNTLastBootTime	t_ntLastBootTime;

	if ( t_ntLastBootTime.GetLastBootTime( t_ft ) )
	{
		a_pInst->SetDateTime( IDS_TimeOfLastReset, WBEMTime(t_ft) ) ;
	}

	// Retrieve the adapter MAC address
	CHString t_csAdapterType ;
	BYTE t_MACAddress[ 6 ] ;
    short t_sAdapterTypeID;

	if( fGetMacAddressAndType( a_pAdapterInst->chsNetCfgInstanceID , t_MACAddress, t_csAdapterType, t_sAdapterTypeID ) )
	{
		CHString	t_chsMACAddress;
					t_chsMACAddress.Format( _T("%02X:%02X:%02X:%02X:%02X:%02X"),
											t_MACAddress[ 0 ], t_MACAddress[ 1 ],
											t_MACAddress[ 2 ], t_MACAddress[ 3 ],
											t_MACAddress[ 4 ], t_MACAddress[ 5 ] ) ;

		a_pInst->SetCHString( IDS_MACAddress, t_chsMACAddress ) ;
	}

	// AdapterType
	if( !t_csAdapterType.IsEmpty() )
	{
		a_pInst->SetCHString( IDS_AdapterType, t_csAdapterType ) ;
        a_pInst->SetWBEMINT16( IDS_AdapterTypeID, t_sAdapterTypeID );
	}

    // NetConnectionID
    SetNetConnectionProps(
        a_pInst,
        a_pAdapterInst->chsNetCfgInstanceID,
        mapNCProps);

	return t_hResult ;
}
#endif

#if NTONLY >= 5
HRESULT CWin32NetworkAdapter::GetObjectNT5(
    CInstance* a_pInst,
    BSTRT2NCPROPMAP& mapNCProps)
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;
	CW2kAdapterEnum		t_oAdapterEnum ;
	CW2kAdapterInstance *t_pAdapterInst ;
	DWORD				t_dwTestIndex = 0 ;
	CHString			t_csPassedInKey ;

	// key
	a_pInst->GetCHString( IDS_DeviceID, t_csPassedInKey ) ;

	// check to see if the key is numeric
	if ( !t_csPassedInKey.IsEmpty() )
	{
		int t_nStrLength = t_csPassedInKey.GetLength() ;
		for ( int t_i = 0; t_i < t_nStrLength ; t_i++ )
		{
			if (!isdigit( t_csPassedInKey.GetAt( t_i ) ) )
			{
				return t_hResult ;
			}
		}

		t_dwTestIndex = _ttol( t_csPassedInKey.GetBuffer( 0 ) ) ;
	}
	else
	{
		return t_hResult ;
	}

	// loop through the W2k identified instances
	for( int t_iCtrIndex = 0 ; t_iCtrIndex < t_oAdapterEnum.GetSize() ; t_iCtrIndex++ )
	{
		if( !( t_pAdapterInst = (CW2kAdapterInstance*) t_oAdapterEnum.GetAt( t_iCtrIndex ) ) )
		{
			continue;
		}

		// match to instance
		if ( t_dwTestIndex != t_pAdapterInst->dwIndex )
		{
			continue ;
		}

		// set the association index
		a_pInst->SetDWORD(IDS_Index, t_pAdapterInst->dwIndex ) ;

		// We load adapter data here.
		t_hResult = GetNetCardInfoForNT5( 
            t_pAdapterInst, 
            a_pInst,
            mapNCProps ) ;

		break;
	}

	return t_hResult ;
}
#endif


// WinNT4.  Use the service name to get the device and from there get it's
// PNP Device ID.

#ifdef NTONLY
void CWin32NetworkAdapter::GetWinNT4PNPDeviceID( CInstance *a_pInst, LPCTSTR t_pszServiceName )
{
	CConfigManager		t_cfgmgr ;
	CDeviceCollection	t_deviceList ;
	BOOL				t_fGotList = FALSE ;

	// On NT filter by the service name _T("of the net card
	if ( t_cfgmgr.GetDeviceListFilterByService( t_deviceList, t_pszServiceName ) )
	{
		// On NT 4, just get at 0.  If we ever have to deal with multiple
		// net cards under the same service, this must change.  However, this
		// class will have to change, since it's using the service name as
		// the key.

		// smart ptr
		CConfigMgrDevicePtr t_pNetAdapter( t_deviceList.GetAt( 0 ), false );

		if ( NULL != t_pNetAdapter )
		{
			SetConfigMgrProperties( t_pNetAdapter, a_pInst ) ;

            // Get the service name while we're here
            CHString t_sServiceName ;

			t_pNetAdapter->GetService( t_sServiceName ) ;

            a_pInst->SetCHString( IDS_ServiceName, t_sServiceName ) ;
		}
	}
}
#endif

// WinNT5.  Use the Driver key name to get the device and from there get it's PNP Device ID.
#ifdef NTONLY
void CWin32NetworkAdapter::GetWinNT5PNPDeviceID( CInstance *a_pInst, LPCTSTR a_pszDriver )
{
	CConfigManager		t_cfgmgr ;
	CDeviceCollection	t_deviceList ;
	BOOL				t_fGotList = FALSE ;

	// On NT filter by the driver key name for the net card
	if ( t_cfgmgr.GetDeviceListFilterByDriver( t_deviceList, a_pszDriver ) )
	{
		// smart ptr
		CConfigMgrDevicePtr t_pNetAdapter( t_deviceList.GetAt( 0 ), false );

		if ( NULL != t_pNetAdapter )
        {
			SetConfigMgrProperties( t_pNetAdapter, a_pInst ) ;

            CHString t_Manufacturer ;

			if ( t_pNetAdapter->GetMfg ( t_Manufacturer ) )
			{
				a_pInst->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
			}

			// Get the service name while we're here
            CHString t_sServiceName ;

			t_pNetAdapter->GetService( t_sServiceName ) ;

			a_pInst->SetCHString( IDS_ServiceName, t_sServiceName ) ;
        }
	}
}
#endif

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  void CWin32NetworkAdapter::vSetCaption( CInstance* a_pInst, CHString& rchsDesc, DWORD dwIndex, int iFormatSize )

 Description: Lays in the registry index instance id into the caption property.
			  Then concats the description
			  This will be used with the view provider to associacte WDM NDIS class instances
			  with an instance of this class

 Arguments:	a_pInst [IN], rchsDesc [IN], dwIndex [IN], iFormatSize [IN]
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					  02-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CWin32NetworkAdapter::vSetCaption( CInstance	*a_pInst,
										CHString	&a_rchsDesc,
										DWORD		a_dwIndex,
										int			a_iFormatSize )
{
	CHString t_chsFormat;
			 t_chsFormat.Format( L"%%0%uu", a_iFormatSize ) ;

	CHString t_chsRegInstance;
			 t_chsRegInstance.Format( t_chsFormat, a_dwIndex ) ;

	CHString t_chsCaption(_T("[") ) ;
			 t_chsCaption += t_chsRegInstance ;
			 t_chsCaption += _T("] " ) ;
			 t_chsCaption += a_rchsDesc ;

	a_pInst->SetCHString( IDS_Caption, t_chsCaption ) ;
}


#if NTONLY >= 5
void CWin32NetworkAdapter::GetNetConnectionProps(
    BSTRT2NCPROPMAP& mapNCProps)
{
    HRESULT hr = S_OK;

    INetConnectionManager* pconmgr = NULL;
    IEnumNetConnection* pnetenum = NULL;
    INetConnection* pinet = NULL;
    ULONG ulFetched = 0L;
    LPWSTR wstrTemp = NULL;    

    try
    {
        hr = ::CoCreateInstance(
            CLSID_ConnectionManager,
            NULL,
            CLSCTX_ALL,
            __uuidof(INetConnectionManager),
            (void**) &pconmgr);

        if(SUCCEEDED(hr) && pconmgr)
        {
            hr = pconmgr->EnumConnections(
                NCME_DEFAULT,
                &pnetenum);
        }

        if(SUCCEEDED(hr) && pnetenum)
        {
            hr = pnetenum->Next(
                1,
                &pinet,
                &ulFetched);
        }

        while(SUCCEEDED(hr) && pinet != NULL)
        {
            NETCON_PROPERTIES* pprops = NULL;

            hr = pinet->GetProperties(
                &pprops);

            if(SUCCEEDED(hr) && pprops != NULL)
            {
                hr = ::StringFromCLSID(
                    pprops->guidId, 
                    &wstrTemp);

                if(SUCCEEDED(hr))
                {
                    NCPROP ncp(pprops->pszwName, pprops->Status);
            
                    mapNCProps.insert(
                        BSTRT2NCPROPMAP::value_type(
                            wstrTemp, 
                            ncp));

                    ::CoTaskMemFree(wstrTemp);
                    wstrTemp = NULL;
                }
            }

            hr = pnetenum->Next(
                1,
                &pinet,
                &ulFetched);
        }

        if(pnetenum)
        {
            pnetenum->Release(); pnetenum = NULL;
        }
        if(pinet)
        {
            pinet->Release(); pinet = NULL;
        }
        if(pconmgr)
        {
            pconmgr->Release(); pconmgr = NULL;
        }
    }
    catch(...)
    {
        if(wstrTemp)
        {
            ::CoTaskMemFree(wstrTemp);
            wstrTemp = NULL;
        }
        if(pnetenum)
        {
            pnetenum->Release(); pnetenum = NULL;
        }
        if(pinet)
        {
            pinet->Release(); pinet = NULL;
        }
        if(pconmgr)
        {
            pconmgr->Release(); pconmgr = NULL;
        }

        throw;
    }
}
#endif


#if NTONLY >= 5
// Finds the proper netconnectionid by looking
// it up in the map using pInst->"Name".
void CWin32NetworkAdapter::SetNetConnectionProps(
    CInstance* pInst,
    CHString& chstrNetConInstID,  
    BSTRT2NCPROPMAP& mapNCProps)
{
    _bstr_t bstrtNetConInstID = chstrNetConInstID;
    BSTRT2NCPROPMAP::iterator iterFound = NULL;
    iterFound = mapNCProps.find(
        bstrtNetConInstID);
    if(iterFound != mapNCProps.end())
    {
        pInst->SetWCHARSplat(
            L"NetConnectionID",
            (LPWSTR) iterFound->second.m_bstrtNCID);

        pInst->SetDWORD(
            L"NetConnectionStatus",
            iterFound->second.m_dwNCStatus);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\netadaptercfg.cpp ===
//=================================================================
//
// NetAdaptCfg.CPP -- Network Card configuration property set provider
//
//  Copyright (c) 1996-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//
//              10/23/97    jennymc         Changed to new framework
//
//				7/23/98					Added the following NT4 support:
//												DHCP configuration
//												DNS configuration
//												WINS configuration
//												TCP/IP configuration
//												IP configuration
//												IPX configuration
//
//				09/03/98		        Major rewrite to virtually all of this provider
//											regarding the resolution adapters and MAC adresses.
//											This to correct for OS deficiencies in resolving adapters
//											and the adapter's relationship to the registry.
//
//				03/03/99				Added graceful exit on SEH and memory failures,
//											syntactic clean up
//
//=================================================================
#include "precomp.h"

#ifndef MAX_INTERFACE_NAME_LEN
#define MAX_INTERFACE_NAME_LEN  256
#endif

#include <iphlpapi.h>

#include <cregcls.h>

#include <devioctl.h>
#include <ntddndis.h>
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include "chwres.h"
#include "netcom.h"

typedef LONG NTSTATUS;
#include "nbtioctl.h"

#include "chptrarr.h"
#include "wsock32api.h"
#include "CAdapters.h"
#include "irq.h"

#include "ntdevtosvcsearch.h"
#include "nt4svctoresmap.h"

#include "dhcpinfo.h"
#include <wchar.h>
#include <tchar.h>
#include "DhcpcsvcApi.h"
#include "CNdisApi.h"
#include "W2kEnum.h"

#include "NetAdapterCfg.h"


#define ZERO_ADDRESS    _T("0.0.0.0")
#define FF_ADDRESS		_T("255.0.0.0")

#define ConvertIPDword(dwIPOrSubnet)    ((dwIPOrSubnet[3]<<24) | (dwIPOrSubnet[2]<<16) | (dwIPOrSubnet[1]<<8) | (dwIPOrSubnet[0]))

// Property set declaration
//=========================
CWin32NetworkAdapterConfig	MyCWin32NetworkAdapterConfig( PROPSET_NAME_NETADAPTERCFG, IDS_CimWin32Namespace  ) ;

/*******************************************************************

    NAME:       saAutoClean, constructor and destructor

    SYNOPSIS:   Used for block scope cleanup of SAFEARRAYs

    ENTRY:      SAFEARRAY** ppArray		: on construction

    HISTORY:
                  19-Jul-1998     Created

********************************************************************/
saAutoClean::saAutoClean( SAFEARRAY	**a_ppArray )
{ m_ppArray = a_ppArray;}

saAutoClean::~saAutoClean()
{
	if( m_ppArray && *m_ppArray )
	{
		SafeArrayDestroy( *m_ppArray ) ;
		*m_ppArray = NULL ;
	}
}

/*******************************************************************

    NAME:       CMParms, constructor

    SYNOPSIS:   Sets up a parameter class for method calls from the framework.

    ENTRY:      CInstance& a_Instance,
				const BSTR a_MethodName,
				CInstance *a_InParams,
				CInstance *a_OutParams,
				long lFlags

    HISTORY:
                  19-Jul-1998     Created

********************************************************************/
CMParms::CMParms()
{
	m_pInst				= NULL;
	m_pbstrMethodName	= NULL;
	m_pInParams			= NULL;
	m_pOutParams		= NULL;
	m_lFlags			= NULL;
}

CMParms::CMParms( const CInstance &a_rInstance )
{
	CMParms( ) ;
	m_pInst	= (CInstance*) &a_rInstance;
}

CMParms::CMParms( const CInstance &a_rInstance, const CInstance &a_rInParams )
{
	CMParms( ) ;
	m_pInst		= (CInstance*) &a_rInstance ;
	m_pInParams	= (CInstance*) &a_rInParams ;
}

CMParms::CMParms( const CInstance &a_rInstance, const BSTR &a_rbstrMethodName,
						    CInstance *a_pInParams, CInstance *a_pOutParams, long a_lFlags )
{
	m_pInst				= (CInstance*) &a_rInstance;
	m_pbstrMethodName	= (BSTR*) &a_rbstrMethodName;
	m_pInParams			= a_pInParams;
	m_pOutParams		= a_pOutParams;
	m_lFlags			= a_lFlags;

	// Initialize Win32_NetworkAdapterConfigReturn
	if( m_pOutParams )
	{
		hSetResult( E_RET_UNKNOWN_FAILURE  ) ;
	}
}

CMParms::~CMParms()
{}

//
// TIME_ADJUST - DHCP uses seconds since 1980 as its time value; the C run-time
// uses seconds since 1970. To get the C run-times to produce the correct time
// given a DHCP time value, we need to add on the number of seconds elapsed
// between 1970 and 1980, which includes allowance for 2 leap years (1972 and 1976)
//

#define TIME_ADJUST(t)  ((time_t)(t) + ((time_t)(((10L * 365L) + 2L) * 24L * 60L * 60L)))

///////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapterConfig::CWin32NetworkAdapterConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
CWin32NetworkAdapterConfig::CWin32NetworkAdapterConfig( LPCWSTR a_name, LPCWSTR a_pszNamespace )
: Provider( a_name, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapterConfig::~CWin32NetworkAdapterConfig
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/
CWin32NetworkAdapterConfig::~CWin32NetworkAdapterConfig()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32NetworkAdapterConfig::ExecMethod(	const CInstance &a_Instance, const BSTR a_MethodName,
												CInstance *a_InParams, CInstance *a_OutParams, long a_Flags )
{
	if ( !a_OutParams )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// package these parameters
	CMParms t_oMParms( a_Instance, a_MethodName, a_InParams, a_OutParams, a_Flags  ) ;

	// Do we recognize the method?
	if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableHCP ) )
	{
		return hEnableDHCP( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableStatic ) )
	{
		return hEnableStatic( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_RenewDHCPLease ) )
	{
		return hRenewDHCPLease( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_RenewDHCPLeaseAll ) )
	{
		return hRenewDHCPLeaseAll( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_ReleaseDHCPLease ) )
	{
		return hReleaseDHCPLease( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_ReleaseDHCPLeaseAll ) )
	{
		return hReleaseDHCPLeaseAll( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetGateways ) )
	{
		return hSetGateways( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableDNS ) )
	{
		return hEnableDNS( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDNSDomain ) )
	{
		return hSetDNSDomain( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDNSSuffixSearchOrder ) )
	{
		return hSetDNSSuffixSearchOrder( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDNSServerSearchOrder ) )
	{
		return hSetDNSServerSearchOrder( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetWINSServer ) )
	{
		return hEnableWINSServer( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableWINS ) )
	{
		return hEnableWINS( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableIPFilterSec ) )
	{
		return hEnableIPFilterSec( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_EnableIPSec ) )
	{
		return hEnableIPSec( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_DisableIPSec ) )
	{
		return hDisableIPSec( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_IPXVirtualNetNum ) )
	{
		return hSetVirtualNetNum( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_IPXSetFrameNetPairs ) )
	{
		return hSetFrameNetPairs( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDBPath ) )
	{
		return hSetDBPath( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetIPUseZero ) )
	{
		return hSetIPUseZero( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetArpAlwaysSource ) )
	{
		return hSetArpAlwaysSource( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetArpUseEtherSNAP ) )
	{
		return hSetArpUseEtherSNAP( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTOS ) )
	{
		return hSetTOS( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTTL ) )
	{
		return hSetTTL( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDeadGWDetect ) )
	{
		return hSetDeadGWDetect( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetPMTUBHDetect ) )
	{
		return hSetPMTUBHDetect( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetPMTUDiscovery ) )
	{
		return hSetPMTUDiscovery( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetForwardBufMem ) )
	{
		return hSetForwardBufMem( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetIGMPLevel ) )
	{
		return hSetIGMPLevel( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetKeepAliveInt ) )
	{
		return hSetKeepAliveInt( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetKeepAliveTime ) )
	{
		return hSetKeepAliveTime( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetMTU ) )
	{
		return hSetMTU( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetNumForwardPkts ) )
	{
		return hSetNumForwardPkts( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpMaxConRetrans ) )
	{
		return hSetTcpMaxConRetrans( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpMaxDataRetrans ) )
	{
		return hSetTcpMaxDataRetrans( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpNumCons ) )
	{
		return hSetTcpNumCons( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpUseRFC1122UP ) )
	{
		return hSetTcpUseRFC1122UP( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpWindowSize ) )
	{
		return hSetTcpWindowSize( t_oMParms ) ;
	}

	// W2k SP1 additions
#if NTONLY >= 5
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetDynamicDNSRegistration ) )
	{
		return hSetDynamicDNSRegistration( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetIPConnectionMetric ) )
	{
		return hSetIPConnectionMetric( t_oMParms ) ;
	}
	else if( !_wcsicmp ( a_MethodName , METHOD_NAME_SetTcpipNetbios ) )
	{
		return hSetTcpipNetbios( t_oMParms ) ;
	}
#endif
	// end additions

	return WBEM_E_INVALID_METHOD ;
}
/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32NetworkAdapterConfig::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
    HRESULT		t_hResult = WBEM_E_FAILED ;
    DWORD		t_i ;
	CAdapters	t_oAdapters ;
    DWORD       dwAdapterStartupError = t_oAdapters.GetStartupError();

    if(dwAdapterStartupError == ERROR_SUCCESS)
    {
        a_pInst->GetDWORD( L"Index", t_i ) ;

	    #ifdef WIN9XONLY
			    t_hResult = GetNetCardConfigInfoWin95( NULL, a_pInst, t_i, t_oAdapters ) ;
	    #endif

	    #ifdef NTONLY

		    #if NTONLY >= 5
		    {
			    t_hResult = GetNetAdapterInNT5( a_pInst, t_oAdapters ) ;
		    }
		    #else	// NT4 and below
		    {
			    t_hResult = GetNetCardConfigInfoNT( NULL, a_pInst, t_i, t_oAdapters ) ;
		    }
		    #endif
	    #endif
    }
    else
    {
        t_hResult = WinErrorToWBEMhResult(dwAdapterStartupError);
    }

    return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapterConfig::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32NetworkAdapterConfig::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR ;
    CAdapters	t_oAdapters ;  // don't care about startup errors in enum function - just won't return any instances

	#ifdef WIN9XONLY
			t_hResult = GetNetCardConfigInfoWin95( a_pMethodContext, NULL, 0, t_oAdapters ) ;
	#endif

	#ifdef NTONLY

		#if NTONLY >= 5
		{
			t_hResult = EnumNetAdaptersInNT5( a_pMethodContext, t_oAdapters ) ;
		}
		#else	// NT4 and below
		{
			CRegistry	t_Registry ;
			CHString	t_csAdapterKey ;

			TCHAR t_szKey[ MAX_PATH + 2 ] ;

			_stprintf( t_szKey, _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards") ) ;

			if( ERROR_SUCCESS == t_Registry.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_szKey, KEY_READ ) )
			{
				// smart ptr
				CInstancePtr t_pInst ;

				// Walk through each instance under this key.
				while (	( ERROR_SUCCESS == t_Registry.GetCurrentSubKeyName( t_csAdapterKey )) &&
						SUCCEEDED( t_hResult ) )
				{
					DWORD t_dwIndex = _ttol( t_csAdapterKey.GetBuffer(0) ) ;

					t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

					if( NULL != t_pInst )
					{
						t_hResult = GetNetCardConfigInfoNT( a_pMethodContext, t_pInst, t_dwIndex, t_oAdapters ) ;

						if( SUCCEEDED( t_hResult ) )
						{
            				t_hResult = t_pInst->Commit() ;
						}

						t_Registry.NextSubKey() ;
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}
			}
		}
		#endif
	#endif

    return t_hResult ;
}

//
BOOL CWin32NetworkAdapterConfig::GetServiceName(DWORD a_dwIndex,
                                                CInstance *a_pInst,
                                                CHString &a_ServiceName )
{
    CRegistry	t_RegInfo ;
    BOOL		t_fRc = FALSE ;
    WCHAR		t_szTemp[ MAX_PATH + 2 ] ;
	CHString	t_chsServiceName ;
    CHString	t_sTemp ;

    // If we can't open this key, the card doesn't exist
    //==================================================
    swprintf( t_szTemp, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards\\%d", a_dwIndex ) ;

	if( t_RegInfo.Open(HKEY_LOCAL_MACHINE, t_szTemp, KEY_READ ) == ERROR_SUCCESS )
	{
        if( t_RegInfo.GetCurrentKeyValue( L"Description", t_sTemp ) == ERROR_SUCCESS )
		{
			a_pInst->SetCHString( IDS_Description, t_sTemp ) ;
		}

        if( t_RegInfo.GetCurrentKeyValue( L"Title", t_sTemp ) == ERROR_SUCCESS )
		{
        	// NOTE: For NT4 we need not call vSetCaption() to build
			// an instance description. "Title" has the instance prepended.
			a_pInst->SetCHString( IDS_Caption, t_sTemp ) ;
		}

		// Extract other values from registry
        //===================================
        if( t_RegInfo.GetCurrentKeyValue( L"ServiceName", t_chsServiceName ) == ERROR_SUCCESS )
		{
            a_ServiceName = t_chsServiceName ;
            t_fRc = TRUE ;
        }

        t_RegInfo.Close() ;
    }
    return t_fRc ;
}
//////////////////////////////////////////////////////////////////////////
// NT4 and NT3.51 only helper function (could work on NT 5 if needed)
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::GetNTBusInfo( LPCTSTR a_pszServiceName, CInstance *a_pInst )
{
	BOOL	t_fReturn = FALSE ;

#ifdef _OPAL_DISCDLL
	return(true) ;
#else


	CHString					t_strBusType = _T("UNKNOWN_BUS_TYPE") ;
	CNT4ServiceToResourceMap	t_serviceMap ;

	// If our service is shown to be using resources, the resources will show a
	// bus type, which we can convert to a human readable string.

	if ( t_serviceMap.NumServiceResources( a_pszServiceName ) > 0 )
	{
		LPRESOURCE_DESCRIPTOR	t_pResource = t_serviceMap.GetServiceResource( a_pszServiceName, 0 ) ;

		if ( NULL != t_pResource )
		{
			// Convert to human readable form.
			t_fReturn = StringFromInterfaceType( t_pResource->InterfaceType, t_strBusType ) ;
		}
	}
#endif
    return t_fReturn ;
}
#endif

/////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::GetIPInfoNT(CInstance *a_pInst, LPCTSTR a_szKey, CAdapters &a_rAdapters )
{
	CRegistry	t_Registry ;
	CHString	t_chsValue ;
	DWORD		t_dwDHCPBool ;
	BOOL		t_fIPEnabled = false ;

	// IP interface location
	if ( ERROR_SUCCESS == t_Registry.Open(HKEY_LOCAL_MACHINE, a_szKey, KEY_READ))
	{
		if( IsWinNT351() )
		{
			t_fIPEnabled = GetIPInfoNT351( a_pInst, t_Registry ) ;
		}
		else
		{
			t_fIPEnabled = GetIPInfoNT4orBetter( a_pInst, t_Registry, a_rAdapters ) ;
		}

		// DHCP enabled
		t_Registry.GetCurrentKeyValue( _T("EnableDHCP"), t_dwDHCPBool ) ;
		a_pInst->Setbool( _T("DHCPEnabled"), (bool)t_dwDHCPBool ) ;

		if( t_fIPEnabled  )
		{
			// DHCP Leases
			if( t_dwDHCPBool )
			{
				// DHCP LeaseTerminatesTime
				t_Registry.GetCurrentKeyValue( _T("LeaseTerminatesTime"), t_chsValue ) ;
				DWORD t_dwTimeTerm = _ttol( t_chsValue.GetBuffer( 0 ) ) ;

				// DHCP LeaseObtainedTime
				t_Registry.GetCurrentKeyValue( _T("LeaseObtainedTime"), t_chsValue ) ;
				DWORD t_dwTimeObtained = _ttol( t_chsValue.GetBuffer( 0 ) ) ;

				// reflect lease times only if both are valid
				if( t_dwTimeTerm && t_dwTimeObtained )
				{
					a_pInst->SetDateTime( _T("DHCPLeaseExpires"), WBEMTime( t_dwTimeTerm ) ) ;
					a_pInst->SetDateTime( _T("DHCPLeaseObtained"), WBEMTime( t_dwTimeObtained ) ) ;
				}

				// DHCPServer
				t_Registry.GetCurrentKeyValue( _T("DhcpServer"), t_chsValue ) ;
				a_pInst->SetCHString( _T("DHCPServer"), t_chsValue ) ;
			}

			// IP interface metric
            DWORD dwMinMetric = 0xFFFFFFFF;
#if NTONLY >= 5
            int iIndex = GetCAdapterIndexViaInterfaceContext(t_Registry, a_rAdapters);
            _ADAPTER_INFO* pAdapterInfo = NULL;

		    if(( pAdapterInfo = (_ADAPTER_INFO*) a_rAdapters.GetAt(iIndex)) != NULL)
            {
                DWORD dwIPCount = pAdapterInfo->aIPInfo.GetSize();
                if(dwIPCount > 0)
                {
                    for(int n = 0; n < dwIPCount; n++)
                    {
                        _IP_INFO* pIPInfo = (_IP_INFO*) pAdapterInfo->aIPInfo.GetAt(n);
                        if(pIPInfo != NULL)
                        {
                            if(pIPInfo->dwCostMetric < dwMinMetric)
                            {
                                dwMinMetric = pIPInfo->dwCostMetric;
                            }
                        }
                    }
                }
            }
#endif

            // If ip is enabled, and we didn't get the metric via the adapter info, try to set the metric from the registry.
			if( t_fIPEnabled )
			{
				DWORD t_dwRegistryInterfaceMetric ;
				
                // Only if we couldn't get the metric from the adapter info then set from the registry.
                if(dwMinMetric == 0xFFFFFFFF)
                {
                    if( ERROR_SUCCESS == t_Registry.GetCurrentKeyValue( RVAL_ConnectionMetric, t_dwRegistryInterfaceMetric ) )
				    {
					    dwMinMetric = t_dwRegistryInterfaceMetric;
				    }
                }
			}

            // Change default value to what the schema specifies.
            if(dwMinMetric == 0xFFFFFFFF)
            {
                dwMinMetric = 1; // default value
            }

			a_pInst->SetDWORD( IP_CONNECTION_METRIC, dwMinMetric ) ;
		}
	}	// end open binding key

	return t_fIPEnabled ;
}
#endif
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32NetworkAdapterConfig::GetIPInfoNT351(CInstance *a_pInst, CRegistry& rRegistry )

 Description: extracts IP info specific to NT3.51

 Arguments:	a_pInst [IN], rRegistry [IN]
 Returns:	returns TRUE is the protocol has an IP address
 Inputs:
 Outputs:
 Caveats:	This method is used since we are unable to get the required info
			using the default NT extraction method
 Raid:
 History:					  05-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::GetIPInfoNT351(CInstance *a_pInst, CRegistry &a_rRegistry )
{
	BOOL			t_IsEnabled = FALSE ;

	CRegistry		t_Registry ;
	DWORD			t_dwDHCPBool = FALSE ;
	DWORD			t_dwRAS = FALSE ;
	CHStringArray	t_chsIPGateways ;
	CHStringArray	t_chsIPAddresses ;
	CHString		t_chsAddress ;
	CHString		t_chsValue ;
	CHString		t_chsSubnet ;

	// smart ptr
	variant_t		t_vValue ;

	SAFEARRAYBOUND	t_rgsabound[ 1 ] ;
	DWORD			t_dwSize ;
	long			t_ix[ 1 ] ;

	// DHCPEnabled
	a_rRegistry.GetCurrentKeyValue( _T("EnableDHCP"), t_dwDHCPBool ) ;

	// RAS swaps into DHCP IPs and masks
	if( !t_dwDHCPBool )
	{
		CHStringArray t_chsIPAddrs;
		a_rRegistry.GetCurrentKeyValue( _T("IPAddress"), t_chsIPAddrs ) ;

		CHString t_chsIPAddress = t_chsIPAddrs.GetAt( 0 ) ;

		if( t_chsAddress == ZERO_ADDRESS )
		{
			t_dwRAS = TRUE ;
		}
	}

	if ( t_dwDHCPBool )
	{
		a_rRegistry.GetCurrentKeyValue( _T("DhcpDefaultGateway"), t_chsIPGateways ) ;
	}
	else
	{
		a_rRegistry.GetCurrentKeyValue( _T("DefaultGateway"), t_chsIPGateways ) ;
	}

	// load up the gateways
	SAFEARRAY *t_saIPGateways ;
	t_dwSize				= t_chsIPGateways.GetSize() ;
	t_rgsabound->cElements	= t_dwSize;
	t_rgsabound->lLbound	= 0;
	t_ix[0]					= 0 ;

	if( !( t_saIPGateways = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saIPGateways ;

	for ( int t_i = 0; t_i < t_dwSize ; t_i++ )
	{
		t_ix[ 0 ] = t_i ;
		bstr_t t_bstrBuf( t_chsIPGateways.GetAt( t_i ) ) ;

		SafeArrayPutElement( t_saIPGateways, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
	}

	// finished walking array
	a_pInst->SetVariant( _T("DefaultIPGateway"), t_vValue ) ;

	if ( t_dwDHCPBool || t_dwRAS )
	{
		a_rRegistry.GetCurrentKeyValue( _T("DhcpIPAddress"), t_chsAddress ) ;
		t_chsIPAddresses.Add( t_chsAddress ) ;
	}
	else
	{
		a_rRegistry.GetCurrentKeyValue( _T("IPAddress"), t_chsIPAddresses ) ;
	}

	// load up the IPAddresses
	VariantClear( &t_vValue ) ;

	SAFEARRAY *t_saIPAddresses ;
	t_dwSize = t_chsIPAddresses.GetSize() ;
	t_rgsabound->cElements = t_dwSize ;
	t_rgsabound->lLbound = 0 ;
	t_ix[ 0 ] = 0 ;

	if( !( t_saIPAddresses = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saIPAddresses ;

	for ( t_i = 0; t_i < t_dwSize ; t_i++ )
	{
		t_ix[ 0 ] = t_i ;
		bstr_t t_bstrBuf( t_chsIPAddresses.GetAt( t_i ) ) ;

		SafeArrayPutElement( t_saIPAddresses, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
	}

	// Enabled if an IP address exists
	if( t_dwSize )
	{
		t_IsEnabled = TRUE ;
	}

	// finished walking array
	a_pInst->SetVariant( _T("IPAddress"), t_vValue ) ;

	CHStringArray t_chsSubnets ;

	if ( t_dwDHCPBool || t_dwRAS )
	{
		a_rRegistry.GetCurrentKeyValue( _T("DhcpSubnetMask"), t_chsSubnet ) ;
		t_chsSubnets.Add( t_chsSubnet ) ;
	}
	else
	{
		a_rRegistry.GetCurrentKeyValue( _T("SubnetMask"), t_chsSubnets ) ;
	}

	// IPSubnets
	VariantClear( &t_vValue ) ;
	SAFEARRAY	*t_saSubnets ;

	t_dwSize = t_chsSubnets.GetSize() ;

	t_rgsabound->cElements = t_dwSize ;
	t_rgsabound->lLbound = 0 ;
	t_ix[ 0 ] = 0 ;

		if( !( t_saSubnets = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saSubnets;

	for ( t_i = 0; t_i < t_dwSize; t_i++ )
	{
		t_ix[ 0 ] = t_i ;
		bstr_t t_bstrBuf( t_chsSubnets.GetAt( t_i ) ) ;

		SafeArrayPutElement( t_saSubnets, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
	}

	a_pInst->SetVariant( _T("IPSubnet"), t_vValue ) ;

	return t_IsEnabled ;
}
#endif

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  void CWin32NetworkAdapterConfig::IsInterfaceContextAvailable( CRegistry& rRegistry, CAdapters& rAdapters )

 Description: Extracts IP info specific for NT greater than NT3.51

 Arguments:	 rRegistry [IN], rAdapters [IN]
 Returns:
 Inputs:
 Outputs:	index to the TDI adapter in question,
			-1 if a context binding could not be established.
 Caveats:
 Raid:
 History:					  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
#define CONTEXT_LIST_LEN	1000
#ifdef NTONLY
int CWin32NetworkAdapterConfig::GetCAdapterIndexViaInterfaceContext(

CRegistry &a_rRegistry,
CAdapters &a_rAdapters )
{
	DWORD	t_dwContextList[ CONTEXT_LIST_LEN ] ;
	int		t_iContextListLen = CONTEXT_LIST_LEN ;

	// extract the IP context(s)
	if( IsWinNT5() )
	{
		if( ERROR_SUCCESS != ReadRegistryList( a_rRegistry.GethKey(),
												_T("NTEContextList"),
												&t_dwContextList[ 0 ],
												&t_iContextListLen ) )
		{
			t_iContextListLen = 0 ;
		}
	}
	else // NT4
	{
		if( ERROR_SUCCESS == a_rRegistry.GetCurrentKeyValue( _T("IPInterfaceContext"), (DWORD&) t_dwContextList ) )
		{
			t_iContextListLen = 1 ;
		}
		else
		{
			t_iContextListLen = 0 ;
		}
	}

	if( t_iContextListLen )
	{
		// bind the adapter via the TDI IP context
		_ADAPTER_INFO *t_pAdapterInfo ;
		for( int t_iCtrIndex = 0 ; t_iCtrIndex < a_rAdapters.GetSize() ; t_iCtrIndex++ )
		{
			if( !( t_pAdapterInfo = (_ADAPTER_INFO*) a_rAdapters.GetAt( t_iCtrIndex ) ) )
			{
				continue;
			}

			_IP_INFO *t_pIPInfo ;
			for (int t_iIPIndex = 0 ; t_iIPIndex < t_pAdapterInfo->aIPInfo.GetSize() ; t_iIPIndex++ )
			{
				if( !( t_pIPInfo = (_IP_INFO*) t_pAdapterInfo->aIPInfo.GetAt( t_iIPIndex ) ) )
				{
					continue;
				}

				if( IsContextIncluded( t_pIPInfo->dwContext, &t_dwContextList[ 0 ], t_iContextListLen ) )
				{
					// found the adapter
					return t_iCtrIndex;
				}
			}
		}
	}
	return -1 ;
}
#endif

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32NetworkAdapterConfig::GetIPInfoNT4orBetter(CInstance *a_pInst, CRegistry& rRegistry,CAdapters& rAdapters )

 Description: Extracts IP info specific for NT greater than NT3.51

 Arguments:	a_pInst [IN], rRegistry [IN], rAdapters [IN]
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					  05-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::GetIPInfoNT4orBetter(	CInstance *a_pInst,
														CRegistry &a_rRegistry,
														CAdapters &a_rAdapters )
{
	BOOL t_fIPEnabled = FALSE ;

	int t_iCtrIndex = GetCAdapterIndexViaInterfaceContext( a_rRegistry, a_rAdapters ) ;

	if( -1 != t_iCtrIndex )
	{
		// bind the adapter via the TDI IP context
		_ADAPTER_INFO *t_pAdapterInfo ;

		if( t_pAdapterInfo = (_ADAPTER_INFO*) a_rAdapters.GetAt( t_iCtrIndex ) )
		{
			// this is our adapter
			if( fSetIPBindingInfo( a_pInst, t_pAdapterInfo ) )
			{
				t_fIPEnabled = TRUE ;
			}

			// MAC address
			if(	t_pAdapterInfo->AddressLength )
			{
				// NOTE: the MAC address overrides the address obtained
				// earlier from the adapter driver. In the case of a RAS
				// dialup connection the driver will report something
				// different. We correct for that here by reporting what
				// TDI has.
				CHString t_chsMACAddress ;

				t_chsMACAddress.Format( _T("%02X:%02X:%02X:%02X:%02X:%02X"),
						t_pAdapterInfo->Address[ 0 ], t_pAdapterInfo->Address[ 1 ],
						t_pAdapterInfo->Address[ 2 ], t_pAdapterInfo->Address[ 3 ],
						t_pAdapterInfo->Address[ 4 ], t_pAdapterInfo->Address[ 5 ] ) ;

				a_pInst->SetCHString( _T("MACAddress"), t_chsMACAddress ) ;

				// Override the IPX address using CAdapter's IPX - adapter
				// relationship. A match was previously attempted using the
				// adapter driver's MAC address to bind an IPX address. This
				// may have failed in the RAS case since the driver's MAC address
				// may be wrong. We correct for it here using an IPContext binding
				// to get from the registry to the TDI adapter. This adapter object
				// has knowledge of IPX adapter bindings.
				if( t_pAdapterInfo->IPXEnabled )
				{
					// IPX address
					if(	!t_pAdapterInfo->IPXAddress.IsEmpty() )
						a_pInst->SetCHString( _T("IPXAddress"), t_pAdapterInfo->IPXAddress ) ;
				}
			}

			// found the adapter
			return t_fIPEnabled ;
		}
	}

	// if we are unable to get TDI adapter INFO ...
	// fall back to the old standby - the registry.
	//return GetIPInfoNT351( a_pInst,  a_rRegistry ) ;
	return FALSE ;
}
#endif

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  void CWin32NetworkAdapterConfig::fSetIPBindingInfo(CInstance *a_pInst, _ADAPTER_INFO* pAdapterInfo )

 Description: Sets IP extracted info from TDI.

 Arguments:	a_pInst [IN], pAdapterInfo [IN]
 Returns:
 Inputs:
 Outputs:
 Caveats:	NT4 or greater
 Raid:
 History:					  05-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
BOOL CWin32NetworkAdapterConfig::fSetIPBindingInfo( CInstance *a_pInst, _ADAPTER_INFO *a_pAdapterInfo )
{
	BOOL	t_fIsIpEnabled = FALSE ;

	if( !a_pAdapterInfo )
	{
		return FALSE;
	}

	a_pInst->SetCHString( IDS_Description, a_pAdapterInfo->Description ) ;

	// IP address and mask info
	VARIANT			t_vValue;
	SAFEARRAYBOUND	t_rgsabound[ 1 ] ;

	t_rgsabound->lLbound = 0;
	t_rgsabound->cElements = a_pAdapterInfo->aIPInfo.GetSize() ;

	if( t_rgsabound->cElements )
	{
		// if at least one address is available, IP is Enabled.
		// 0.0.0.0 although invalid is used to maintain IP
		t_fIsIpEnabled = TRUE ;

		SAFEARRAY *t_saIPAddresses	= SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ;
		SAFEARRAY *t_saIPMasks		= SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ;
		saAutoClean t_acIPAddr( &t_saIPAddresses ) ;	// block scope cleanup
		saAutoClean t_acIPMask( &t_saIPMasks ) ;

		// the addresses come in reverse order
		long lIpOrder = 0;

		_IP_INFO *t_pIPInfo;
		for( long t_lIPIndex = t_rgsabound->cElements - 1; t_lIPIndex >= 0; t_lIPIndex-- )
		{
			if( !( t_pIPInfo = (_IP_INFO*) a_pAdapterInfo->aIPInfo.GetAt( t_lIPIndex ) ) )
			{
				continue;
			}

			// if not 0.0.0.0 add it
			if( t_pIPInfo->dwIPAddress )
			{
				// IP address
				bstr_t t_bstrIPBuf( t_pIPInfo->chsIPAddress ) ;
				SafeArrayPutElement( t_saIPAddresses, &lIpOrder, (wchar_t*)t_bstrIPBuf ) ;

				// IP Mask
				bstr_t t_bstrMaskBuf( t_pIPInfo->chsIPMask ) ;
				SafeArrayPutElement( t_saIPMasks, &lIpOrder, (wchar_t*)t_bstrMaskBuf ) ;

				lIpOrder++ ;
			}
            else // bugs 161362 (and 183951 to some extent)
            {
                bstr_t t_bstrIPBuf(L"0.0.0.0") ;
				SafeArrayPutElement( t_saIPAddresses, &lIpOrder, (wchar_t*)t_bstrIPBuf ) ;

				lIpOrder++ ;
            }
		}

		V_VT( &t_vValue) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saIPAddresses ;
		a_pInst->SetVariant(L"IPAddress", t_vValue) ;

		V_VT( &t_vValue) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue) = t_saIPMasks ;
		a_pInst->SetVariant(L"IPSubnet", t_vValue) ;
	}

	// IP gateway info
	t_rgsabound->lLbound = 0;
	t_rgsabound->cElements = a_pAdapterInfo->aGatewayInfo.GetSize() ;

	if( t_rgsabound->cElements )
	{
		SAFEARRAY *t_saGateways = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ;
		saAutoClean t_acGateways( &t_saGateways ) ;	// block scope cleanup

		SAFEARRAY *t_saCostMetric = SafeArrayCreate( VT_I4, 1, t_rgsabound ) ;
		saAutoClean t_acCostMetric( &t_saCostMetric ) ;	// block scope cleanup

		_IP_INFO* t_pIPGatewayInfo;
		for( long t_lIPGateway = 0; t_lIPGateway < t_rgsabound->cElements; t_lIPGateway++ )
		{
			if( !( t_pIPGatewayInfo = (_IP_INFO*)a_pAdapterInfo->aGatewayInfo.GetAt( t_lIPGateway ) ) )
			{
				continue;
			}

			bstr_t t_bstrBuf( t_pIPGatewayInfo->chsIPAddress ) ;
			SafeArrayPutElement( t_saGateways, &t_lIPGateway, (wchar_t*)t_bstrBuf ) ;

#ifdef NTONLY
			if( IsWinNT5() )
			{
				SafeArrayPutElement( t_saCostMetric, &t_lIPGateway, &t_pIPGatewayInfo->dwCostMetric ) ;
			}
#endif
		}

		V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saGateways ;
		a_pInst->SetVariant( L"DefaultIPGateway", t_vValue ) ;

		V_VT( &t_vValue ) = VT_I4 | VT_ARRAY; V_ARRAY( &t_vValue ) = t_saCostMetric ;
		a_pInst->SetVariant( L"GatewayCostMetric", t_vValue ) ;
	}

	return t_fIsIpEnabled ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapterConfig::GetNetCardConfigInfoNT
 *
 *  DESCRIPTION : Loads property values according to passed network card index
 *
 *  INPUTS      : DWORD Index -- index of desired network card
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if indicated card was found, FALSE otherwise
 *
 *  COMMENTS    : The return code is based solely on the ability to discover
 *                the indicated card.  Any properties not found are simply not
 *                available
 *
 *****************************************************************************/
#ifdef NTONLY
#if NTONLY < 5
HRESULT CWin32NetworkAdapterConfig::GetNetCardConfigInfoNT( MethodContext *a_pMethodContext,
															CInstance *a_pInst,
															DWORD a_dwIndex,
															CAdapters &a_rAdapters )
{
    HRESULT		t_hResult = WBEM_E_NOT_FOUND;
    TCHAR		t_szKey[ _MAX_PATH + 2 ] ;

    CHString	t_sTemp ;
    CRegistry	t_RegInfo ;
    CHString	t_ServiceName;
	LPTSTR		t_szIPKey = NULL;
	bool		t_fIPXEnabled	= false ;
	bool		t_fIPEnabled	= false ;

    if( a_pMethodContext )
	{
        a_pInst->SetDWORD( _T("Index"), a_dwIndex ) ;
    }

    //initialize to false
	a_pInst->Setbool( _T("DHCPEnabled"), false)  ;

	GetSettingID( a_pInst, a_dwIndex ) ;

	if( GetServiceName( a_dwIndex, a_pInst, t_ServiceName) )
	{
        // Use service name to open handle to adapter
        //===========================================
        if( !CHString( t_ServiceName ).IsEmpty() )
		{
            a_pInst->SetCHString( _T("ServiceName"), t_ServiceName) ;

			// Retrieve the adapter MAC address
			BYTE t_MACAddress[ 6 ] ;

			if( fGetMacAddress( t_MACAddress, t_ServiceName ) )
			{
				CHString	t_chsMACAddress ;
							t_chsMACAddress.Format( _T("%02X:%02X:%02X:%02X:%02X:%02X" ),
							t_MACAddress[ 0 ], t_MACAddress[ 1 ], t_MACAddress[ 2 ],
							t_MACAddress[ 3 ], t_MACAddress[ 4 ], t_MACAddress[ 5 ]) ;

				a_pInst->SetCHString( _T("MACAddress"), t_chsMACAddress ) ;

				// get IPX address for this card
				if( GetIPXAddresses( a_pInst, t_MACAddress ) )
				{
					t_fIPXEnabled = true ;

					// IPX info
					hGetIPXGeneral( a_pInst, a_dwIndex ) ;
				}
			}

			// This used to be what GetOpenParameters did for us.
		    _stprintf( t_szKey, _T("System\\CurrentControlSet\\Services\\%s\\Parameters"), (LPCTSTR) t_ServiceName ) ;

			t_szIPKey = _tcscat( t_szKey, _T("\\Tcpip") ) ;
			if ( t_szIPKey )
			{
				// test to see if this adapter is bound to tcpip
				CRegistry	t_oReg ;
				CHString	t_chsSKey( _T("System\\CurrentControlSet\\Services\\Tcpip\\Linkage") ) ;

				BOOL t_fBound = FALSE ;
				if ( ERROR_SUCCESS == t_oReg.Open( HKEY_LOCAL_MACHINE, t_chsSKey, KEY_READ ) )
				{
					CHStringArray t_achsRoutes ;
					t_oReg.GetCurrentKeyValue( _T("Route"), t_achsRoutes ) ;

					for( int t_i = 0; t_i < t_achsRoutes.GetSize() ; t_i++ )
					{
						CHString t_chsRoute = t_achsRoutes.GetAt( t_i ) ;
						if(-1 != t_chsRoute.Find( t_ServiceName ) )
						{
							t_fBound = TRUE ;
							break ;
						}
					}
				}

				if( t_fBound )
				{
					if( GetIPInfoNT( a_pInst, t_szIPKey, a_rAdapters ) )
					{
						t_fIPEnabled = true ;

						hGetNtIpSec( a_pInst, t_szIPKey ) ;

						// WINS
						t_hResult = hGetWinsNT( a_pInst, a_dwIndex  ) ;

						// DNS
						t_hResult = hGetDNS( a_pInst, a_dwIndex ) ;

						// TCP/IP general
						t_hResult = hGetTcpipGeneral( a_pInst ) ;

					}
				}
			}// end if

	        // Now go into the registry and based on the service name we have, get the
	        // REAL device service name.

	        CNTDeviceToServiceSearch	t_devSearch ;
	        CHString					t_strAdaptorServiceName ;

			// If we get the adaptor service name from service name, this name can
			// be used to get bus type for the card.
        	if ( t_devSearch.Find( t_ServiceName, t_strAdaptorServiceName ) )
			{
				// We can do this the same way for NT 3.51 and NT 4
				//GetNTBusInfo( strAdaptorServiceName, a_pInst  ) ;

				// If we got the name, we should the be able to find an IRQ and
		        // an IOAddress using the Adaptor's Service Name

//                GetIRQ( a_pInst,strAdaptorServiceName ) ;
	        }
		}
		t_hResult = WBEM_S_NO_ERROR ;

		//
		a_pInst->Setbool( _T("IPXEnabled"), t_fIPXEnabled ) ;
		a_pInst->Setbool( _T("IPEnabled"), t_fIPEnabled ) ;
    }

    return t_hResult ;
}
#endif
#endif

/*******************************************************************
    NAME:       fGetMacAddress

    SYNOPSIS:	retrieves the MAC address from the adapter driver.


    ENTRY:      BYTE* MACAddress[6]		:
				CHString& rDeviceName		:


    HISTORY:
                  08-Aug-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fGetMacAddress( BYTE a_MACAddress[ 6 ], CHString &a_rDeviceName )
{
	BOOL t_fRet = FALSE;

	BOOL t_fCreatedSymLink = fCreateSymbolicLink( a_rDeviceName  ) ;

	SmartCloseHandle t_hMAC;

	try
	{
		//
		// Construct a device name to pass to CreateFile
		//
		CHString t_chsAdapterPathName( _T("\\\\.\\") ) ;
				 t_chsAdapterPathName += a_rDeviceName;

		t_hMAC = CreateFile(
                    TOBSTRT( t_chsAdapterPathName ),
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					0,
					INVALID_HANDLE_VALUE
					) ;

		do	// breakout
		{
			if( INVALID_HANDLE_VALUE == t_hMAC )
			{
				break ;
			}

			//
			// We successfully opened the driver, format the
			// IOCTL to pass the driver.
			//
			UCHAR       t_OidData[ 4096 ] ;
			NDIS_OID    t_OidCode ;
			DWORD       t_ReturnedCount ;

			// get the supported media types
			t_OidCode = OID_GEN_MEDIA_IN_USE ;

			if( DeviceIoControl(
					t_hMAC,
					IOCTL_NDIS_QUERY_GLOBAL_STATS,
					&t_OidCode,
					sizeof( t_OidCode ),
					t_OidData,
					sizeof( t_OidData ),
					&t_ReturnedCount,
					NULL
					) && ( 4 <= t_ReturnedCount ) )
			{


				// Seek out the media type for MAC address reporting.
				// Since this adapter may support more than one media type we'll use
				// the enumeration preference order. In most all cases only one type
				// will be current.

				_NDIS_MEDIUM *t_pTypes = (_NDIS_MEDIUM*)&t_OidData;
				_NDIS_MEDIUM t_eMedium = t_pTypes[0 ] ;

				for( DWORD t_dwtypes = 1; t_dwtypes < t_ReturnedCount/4; t_dwtypes++ )
				{
					if( t_eMedium > t_pTypes[ t_dwtypes ] )
					{
						t_eMedium = t_pTypes[ t_dwtypes ] ;
					}
				}

				switch( t_eMedium )
				{
					default:
					case NdisMedium802_3:
						t_OidCode = OID_802_3_CURRENT_ADDRESS ;
						break;
					case NdisMedium802_5:
						t_OidCode = OID_802_5_CURRENT_ADDRESS ;
						break;
					case NdisMediumFddi:
						t_OidCode = OID_FDDI_LONG_CURRENT_ADDR ;
						break;
					case NdisMediumWan:
						t_OidCode = OID_WAN_CURRENT_ADDRESS ;
						break;
				}
			}
			else
			{
				t_OidCode = OID_802_3_CURRENT_ADDRESS ;
			}

			if(!DeviceIoControl(
					t_hMAC,
					IOCTL_NDIS_QUERY_GLOBAL_STATS,
					&t_OidCode,
					sizeof( t_OidCode ),
					t_OidData,
					sizeof( t_OidData ),
					&t_ReturnedCount,
					NULL
					) )
			{
				break ;
			}

			if( 6 != t_ReturnedCount )
			{
				break ;
			}

			memcpy( a_MACAddress, &t_OidData, 6 ) ;

			t_fRet = TRUE;

		} while( FALSE ) ;

	}
	catch( ... )
	{
		if( t_fCreatedSymLink )
		{
			fDeleteSymbolicLink( a_rDeviceName  ) ;
		}

		throw ;
	}

	if( t_fCreatedSymLink )
	{
		fDeleteSymbolicLink( a_rDeviceName  ) ;
		t_fCreatedSymLink = FALSE ;
	}

 	return t_fRet ;

}

/*******************************************************************
    NAME:       fCreateSymbolicLink

    SYNOPSIS:	Tests for and creates if necessary a symbolic device link.


    ENTRY:      CHString& rDeviceName		: device name

	NOTES:		Unsupported for Win95

	HISTORY:
                  08-Aug-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fCreateSymbolicLink( CHString &a_rDeviceName )
{
	TCHAR t_LinkName[ 512 ] ;

	// Check to see if the DOS name for the device already exists.
	// Its not created automatically in version 3.1 but may be later.
	//
	if(!QueryDosDevice( TOBSTRT( a_rDeviceName ), (LPTSTR)t_LinkName, sizeof( t_LinkName ) / sizeof( TCHAR ) ) )
	{
		// On any error other than "file not found" return
		if( ERROR_FILE_NOT_FOUND != GetLastError() )
		{
			return FALSE;
		}

		//
		// It doesn't exist so create it.
		//
		CHString t_chsTargetPath = _T("\\Device\\" ) ;
				 t_chsTargetPath += a_rDeviceName ;

		if( !DefineDosDevice( DDD_RAW_TARGET_PATH, TOBSTRT( a_rDeviceName ), TOBSTRT( t_chsTargetPath ) ) )
		{
			return FALSE ;
		}
		return TRUE ;
	}
	return FALSE ;
}

/*******************************************************************
    NAME:       fDeleteSymbolicLink

    SYNOPSIS:	deletes a symbolic device name.


    ENTRY:      CHString& rSymDeviceName	: symbolic device name

	NOTES:		Unsupported for Win95

    HISTORY:
                  08-Aug-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fDeleteSymbolicLink(  CHString &a_rDeviceName )
{
	//
	// The driver wasn't visible in the Win32 name space so we created
	// a link.  Now we have to delete it.
	//
	CHString t_chsTargetPath = _T("\\Device\\" ) ;
			 t_chsTargetPath += a_rDeviceName ;

	if( !DefineDosDevice(
							DDD_RAW_TARGET_PATH |
							DDD_REMOVE_DEFINITION |
							DDD_EXACT_MATCH_ON_REMOVE,
							TOBSTRT( a_rDeviceName ),
							TOBSTRT( t_chsTargetPath ) )
							)
	{
		return FALSE ;
	}
	return TRUE;
}

/*******************************************************************
    NAME:       fGetWinsServers

    SYNOPSIS:	retrieves the WINS Servers from the kernel driver


    ENTRY:      CHString& rDeviceName	:
				CHString& chsPrimary	:
				CHString& chsSecondary  :


    HISTORY:
                  09-Sep-1998     Created
********************************************************************/
// seems that if WINS addresses not specified, NetBT reports 127.0.0.0 so if
// this value is returned, we won't display them
#define LOCAL_WINS_ADDRESS  0x7f000000  // 127.0.0.0

#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::fGetWinsServers(	CHString &a_rDeviceName,
													CHString &a_chsPrimary,
													CHString &a_chsSecondary )
{
	BOOL			t_fRet = FALSE ;
	DWORD			t_ReturnedCount ;
	tWINS_ADDRESSES t_oWINs ;

    HANDLE          t_hnbt = INVALID_HANDLE_VALUE;
	BOOL			t_fCreatedSymLink = FALSE ;
	CHString		t_chsDeviceName ;

	try
	{
		t_chsDeviceName = _T("NetBT_") ;
		t_chsDeviceName	+= a_rDeviceName;

		t_fCreatedSymLink = fCreateSymbolicLink( t_chsDeviceName  ) ;

		//
		// Construct a device name to pass to CreateFile
		//
		CHString t_chsNBTAdapterPathName( _T("\\Device\\") ) ;
				 t_chsNBTAdapterPathName += t_chsDeviceName ;

        NTDriverIO myio(const_cast<LPWSTR>(static_cast<LPCWSTR>(t_chsNBTAdapterPathName)));

		do	// breakout
		{
            if((t_hnbt = myio.GetHandle()) == INVALID_HANDLE_VALUE)
            {
                break;
            }

			//
			// We successfully opened the driver, format the
			// IOCTL to pass the driver.
			//
			if( !DeviceIoControl(
					t_hnbt,
					IOCTL_NETBT_GET_WINS_ADDR,
					NULL,
					0,
					&t_oWINs,
					sizeof( t_oWINs ),
					&t_ReturnedCount,
					NULL
					))
			{
				break ;
			}

			// if we get 127.0.0.0 back then convert it to the NULL address.
			// See ASSUMES in function header
			if( t_oWINs.PrimaryWinsServer == LOCAL_WINS_ADDRESS )
			{
				t_oWINs.PrimaryWinsServer = 0 ;
			}

			if( t_oWINs.BackupWinsServer == LOCAL_WINS_ADDRESS )
			{
				t_oWINs.BackupWinsServer = 0;
			}
			DWORD t_ardwIP[ 4 ] ;

			if( t_oWINs.PrimaryWinsServer )
			{
				t_ardwIP[3] =  t_oWINs.PrimaryWinsServer        & 0xff ;
				t_ardwIP[2] = (t_oWINs.PrimaryWinsServer >>  8) & 0xff ;
				t_ardwIP[1] = (t_oWINs.PrimaryWinsServer >> 16) & 0xff ;
				t_ardwIP[0] = (t_oWINs.PrimaryWinsServer >> 24) & 0xff ;

				vBuildIP( t_ardwIP, a_chsPrimary ) ;
			}

			if( t_oWINs.BackupWinsServer )
			{
				t_ardwIP[3] =  t_oWINs.BackupWinsServer	       & 0xff ;
				t_ardwIP[2] = (t_oWINs.BackupWinsServer >>  8) & 0xff ;
				t_ardwIP[1] = (t_oWINs.BackupWinsServer >> 16) & 0xff ;
				t_ardwIP[0] = (t_oWINs.BackupWinsServer >> 24) & 0xff ;

				vBuildIP( t_ardwIP, a_chsSecondary  ) ;
			}

			t_fRet = TRUE;

		} while( FALSE ) ;

	}
	catch( ... )
	{
		if( t_fCreatedSymLink )
		{
			fDeleteSymbolicLink( t_chsDeviceName  ) ;
		}
		throw ;
	}

	if( t_fCreatedSymLink )
	{
		fDeleteSymbolicLink( t_chsDeviceName  ) ;
		t_fCreatedSymLink = FALSE ;
	}
 	return t_fRet ;
}
#endif

#ifdef WIN9XONLY
//
BOOL CWin32NetworkAdapterConfig::fGetWinsServers9x(

DWORD		a_dwIPAddress,
CHString	&a_chsPrimary,
CHString	&a_chsSecondary )
{

	SmartCloseHandle		t_hVxdHandle;

	CHString	t_chsVxdPath( "\\\\.\\VNBT" ) ;

	tIPCONFIG_INFO *t_pWinsInfoPtr = NULL;
	BYTE			t_WinsInfo[sizeof(tIPCONFIG_INFO) + 256];    // +256 arb. for ScopeId
	DWORD			t_dwBytesRead ;
	BOOL			t_bHaveWins = FALSE ;

    // reject any or none
	if (( INADDR_ANY == a_dwIPAddress ) || ( INADDR_NONE == a_dwIPAddress ) )
	{
        return t_bHaveWins ;
    }

	// Swap the IP address key into network order
	DWORD t_dwNetOrderIPAddress ;

	t_dwNetOrderIPAddress  = ( a_dwIPAddress & 0x000000ff ) << 24 ;
	t_dwNetOrderIPAddress |= ( a_dwIPAddress & 0x0000ff00 ) <<  8 ;
	t_dwNetOrderIPAddress |= ( a_dwIPAddress & 0x00ff0000 ) >>  8 ;
	t_dwNetOrderIPAddress |= ( a_dwIPAddress & 0xff000000 ) >> 24 ;
	//
	//  Open the device.
	//
	//  First try the name without the .VXD extension.  This will
	//  cause CreateFile to connect with the VxD if it is already
	//  loaded (CreateFile will not load the VxD in this case).

	t_hVxdHandle = CreateFile( bstr_t( t_chsVxdPath ),
							GENERIC_READ | GENERIC_WRITE,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							NULL,
							OPEN_EXISTING,
							FILE_FLAG_DELETE_ON_CLOSE,
							NULL );

	if( t_hVxdHandle == INVALID_HANDLE_VALUE )
	{
		//
		//  Not found.  Append the .VXD extension and try again.
		//  This will cause CreateFile to load the VxD.

		t_chsVxdPath += ".VXD" ;
		t_hVxdHandle = CreateFile( bstr_t( t_chsVxdPath ),
								GENERIC_READ | GENERIC_WRITE,
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								OPEN_EXISTING,
								FILE_FLAG_DELETE_ON_CLOSE,
								NULL );
	}

	DWORD t_dwResult = 0 ;
	if( t_hVxdHandle != INVALID_HANDLE_VALUE )
	{
		// populate this structure
		//
		if( !DeviceIoControl( t_hVxdHandle,
								116, //IOCTL_NETBT_IPCONFIG_INFO,
								&t_WinsInfo,
								sizeof( t_WinsInfo ),
								t_WinsInfo,
								sizeof( t_WinsInfo ),
								&t_dwBytesRead,
								NULL ) )
		{
			t_dwResult = GetLastError() ;
		}
		else
		{
			t_pWinsInfoPtr = (tIPCONFIG_INFO*)&t_WinsInfo;

			for ( int i = 0; i < t_pWinsInfoPtr->NumLanas; ++i)
			{
				if (t_pWinsInfoPtr->LanaInfo[i].IpAddress == t_dwNetOrderIPAddress )
				{

					// if we get 127.0.0.0 back then convert it to the NULL address.
					// See ASSUMES in function header
					if( t_pWinsInfoPtr->LanaInfo[i].NameServerAddress == LOCAL_WINS_ADDRESS )
					{
						t_pWinsInfoPtr->LanaInfo[i].NameServerAddress = 0 ;
					}

					if( t_pWinsInfoPtr->LanaInfo[i].BackupServer == LOCAL_WINS_ADDRESS )
					{
						t_pWinsInfoPtr->LanaInfo[i].BackupServer = 0;
					}

					DWORD t_ardwIP[ 4 ] ;

					if( t_pWinsInfoPtr->LanaInfo[i].NameServerAddress )
					{
						t_ardwIP[3] =  t_pWinsInfoPtr->LanaInfo[i].NameServerAddress        & 0xff ;
						t_ardwIP[2] = (t_pWinsInfoPtr->LanaInfo[i].NameServerAddress >>  8) & 0xff ;
						t_ardwIP[1] = (t_pWinsInfoPtr->LanaInfo[i].NameServerAddress >> 16) & 0xff ;
						t_ardwIP[0] = (t_pWinsInfoPtr->LanaInfo[i].NameServerAddress >> 24) & 0xff ;

						vBuildIP( t_ardwIP, a_chsPrimary ) ;
						t_bHaveWins = TRUE ;
					}

					if( t_pWinsInfoPtr->LanaInfo[i].BackupServer )
					{
						t_ardwIP[3] =  t_pWinsInfoPtr->LanaInfo[i].BackupServer	       & 0xff ;
						t_ardwIP[2] = (t_pWinsInfoPtr->LanaInfo[i].BackupServer >>  8) & 0xff ;
						t_ardwIP[1] = (t_pWinsInfoPtr->LanaInfo[i].BackupServer >> 16) & 0xff ;
						t_ardwIP[0] = (t_pWinsInfoPtr->LanaInfo[i].BackupServer >> 24) & 0xff ;

						vBuildIP( t_ardwIP, a_chsSecondary ) ;
						t_bHaveWins = TRUE ;
					}

					break;
				}
			}
		}
	}

	return t_bHaveWins ;
}

#endif

/*******************************************************************
    NAME:       fSetWinsServers

    SYNOPSIS:	Sets the WINS Servers via the kernel driver


    ENTRY:      CHString& rDeviceName	:
				CHString& chsPrimary	:
				CHString& chsSecondary  :


    HISTORY:
                  09-Sep-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fSetWinsServers(	CHString &a_rDeviceName,
													CHString &a_chsPrimary,
													CHString &a_chsSecondary )
{
	// TODO: This is a post release DCR.
	//		 We'll need to test further what servers are to be updated; DHCP or NCPA overrides.
	//		 Test also for the vulgarities between DNS, DHCP and WINS by comparing active
	//		 updating verses reboot.
	return FALSE ;	// Until then ...
/*

	BOOL				t_fRet = FALSE ;
	DWORD				t_ReturnedCount = 0 ;
	NETBT_SET_WINS_ADDR t_oWINs ;
	DWORD				t_ardwIP[ 4 ] ;

	CHString			t_chsDeviceName ;
	BOOL				t_fCreatedSymLink = FALSE ;
	SmartCloseHandle	t_hnbt;


	try
	{
		if( !fGetNodeNum( a_chsPrimary, t_ardwIP ) )
		{
			t_oWINs.PrimaryWinsAddr = LOCAL_WINS_ADDRESS ;
		}
		else
		{
			t_oWINs.PrimaryWinsAddr = t_ardwIP[ 3 ] |
								  ( ( t_ardwIP[ 2 ] & 0xff ) << 8 )  |
								  ( ( t_ardwIP[ 1 ] & 0xff ) << 16 ) |
								  ( ( t_ardwIP[ 0 ] & 0xff ) << 24 ) ;
		}
		if( !fGetNodeNum( a_chsSecondary, t_ardwIP ) )
		{
			t_oWINs.SecondaryWinsAddr = LOCAL_WINS_ADDRESS ;
		}
		else
		{
			t_oWINs.SecondaryWinsAddr =   t_ardwIP[ 3 ] |
									  ( ( t_ardwIP[ 2 ] & 0xff ) << 8 )  |
									  ( ( t_ardwIP[ 1 ] & 0xff ) << 16 ) |
									  ( ( t_ardwIP[ 0 ] & 0xff ) << 24 ) ;
		}


		t_chsDeviceName = _T("NetBT_") ;
		t_chsDeviceName += a_rDeviceName;

		t_fCreatedSymLink = fCreateSymbolicLink( t_chsDeviceName  ) ;

		//
		// Construct a device name to pass to CreateFile
		//
		CHString t_chsNBTAdapterPathName( _T("\\\\.\\") ) ;
				 t_chsNBTAdapterPathName += t_chsDeviceName;


		t_hnbt = CreateFile(
					TOBSTRT( t_chsNBTAdapterPathName ),
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					0,
					INVALID_HANDLE_VALUE
					 ) ;

		do	// breakout
		{
			if( INVALID_HANDLE_VALUE == t_hnbt )
			{
				break;
			}

			//
			// We successfully opened the driver, format the
			// IOCTL to pass the driver.
			//
			if( !DeviceIoControl(
					t_hnbt,
					IOCTL_NETBT_SET_WINS_ADDRESS,
					&t_oWINs,
					sizeof( t_oWINs ),
					NULL,
					0,
					&t_ReturnedCount,
					NULL
					))
			{
				break ;
			}
			t_fRet = TRUE;

		} while( FALSE ) ;

	}
	catch( ... )
	{
		if( t_fCreatedSymLink )
		{
			fDeleteSymbolicLink( t_chsDeviceName ) ;
		}

		throw ;
	}

	if( t_fCreatedSymLink )
	{
		fDeleteSymbolicLink( t_chsDeviceName  ) ;
		t_fCreatedSymLink = FALSE ;
	}
 	return t_fRet ;
*/
}

/////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT  CWin32NetworkAdapterConfig::GetNetCardConfigInfoWin95( MethodContext *a_pMethodContext,
																CInstance *a_pSpecificInstance,
																DWORD a_dwIndex,
																CAdapters& a_rAdapters )
{
    HRESULT			t_hResult = WBEM_S_NO_ERROR ;
	BOOL			t_bSpecificInstanceFound = TRUE ;
 	CDHCPInfo		t_DHCPInfo ;	// loads a DHCPInfoObject with all DCHP information in it.
	_ADAPTER_INFO	*t_pAdapterInfo ;

	// smart ptr
	CInstancePtr	t_pInst ;

	if( a_pSpecificInstance )
	{
		t_bSpecificInstanceFound = FALSE ;
	}

	for( int t_iCtrIndex = 0; t_iCtrIndex < a_rAdapters.GetSize() && SUCCEEDED( t_hResult ) ; t_iCtrIndex++ )
	{
		DWORD t_dwRegInstance = t_iCtrIndex ;

		t_pAdapterInfo = (_ADAPTER_INFO*)a_rAdapters.GetAt( t_iCtrIndex ) ;

		//=====================================================
        //  If we are enumerating, then create a new instance
        //=====================================================
        if( a_pMethodContext )
		{
            t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

            if( NULL != t_pInst )
            {
                t_pInst->SetDWORD( L"Index", t_iCtrIndex ) ;
            }
            else
            {
                t_hResult = WBEM_E_FAILED;
                break;
            }
        }
        //=====================================================
        //  Otherwise, we are going for a specific index
        //=====================================================
        else{
            if( t_iCtrIndex != a_dwIndex )
			{
                continue;
            }
			else
			{
				t_bSpecificInstanceFound = TRUE ;
            }

			t_pInst = a_pSpecificInstance ;
        }

		bool t_fIPEnabled		= false;
		bool t_fIPXEnabled		= false;
		bool t_fDHCPEnabled		= false;

		GetSettingID( t_pInst, t_iCtrIndex ) ;

		// adapter info
		if( t_pAdapterInfo )
		{
			// Adapter description
			if( !t_pAdapterInfo->Description.IsEmpty() )
			{
				vSetCaption( t_pInst, t_pAdapterInfo->Description, t_dwRegInstance, 4  ) ;
				t_pInst->SetCHString( IDS_Description, t_pAdapterInfo->Description ) ;
			}

			// MAC address
			if(	t_pAdapterInfo->AddressLength )
			{
				CHString	t_chsMACAddress ;
							t_chsMACAddress.Format( L"%02X:%02X:%02X:%02X:%02X:%02X",
									t_pAdapterInfo->Address[ 0 ], t_pAdapterInfo->Address[ 1 ],
									t_pAdapterInfo->Address[ 2 ], t_pAdapterInfo->Address[ 3 ],
									t_pAdapterInfo->Address[ 4 ], t_pAdapterInfo->Address[ 5 ] ) ;

				t_pInst->SetCHString(L"MACAddress", t_chsMACAddress ) ;
			}

			// IP info
			if( t_pAdapterInfo->IPEnabled )
			{
				// returns true if at least one IP address exists, enabling the IP
				if( fSetIPBindingInfo( t_pInst, t_pAdapterInfo  ) )
				{
					t_fIPEnabled = true ;

					// DHCP info
					if( t_DHCPInfo.GetDHCPInfo((BYTE*) &t_pAdapterInfo->Address ) )
					{
						CHString t_chsServer;
						t_DHCPInfo.GetDHCPServer( t_chsServer ) ;

						t_pInst->SetCHString( L"DHCPServer", t_chsServer ) ;

						// DNS Domain ( may be overwritten by DNS specific settings
						CHString t_chsDnsDomain ;
						t_DHCPInfo.GetDnsDomain( t_chsDnsDomain ) ;

						if( !t_chsDnsDomain.IsEmpty() )
						{
							t_pInst->SetCHString( DNS_DOMAIN, t_chsDnsDomain ) ;
						}

						// supply the host name as well
						t_pInst->SetCHString( DNS_HOSTNAME, GetLocalComputerName() ) ;

						// DNS Server ( may be overwritten by DNS specific settings
						CHStringArray *t_pchsaGetDnsServerList ;
						t_DHCPInfo.GetDnsServerList( &t_pchsaGetDnsServerList ) ;

						DWORD t_dwSize = t_pchsaGetDnsServerList->GetSize() ;

						if( t_dwSize )
						{
							SAFEARRAYBOUND	t_rgsabound[ 1 ] ;
							long			t_ix[ 1 ] ;

							SAFEARRAY		*t_pArray	= NULL ;
							saAutoClean acFrameType( &t_pArray ) ;	// stack scope cleanup

							t_rgsabound->cElements = t_dwSize ;
							t_rgsabound->lLbound = 0 ;

							if( !( t_pArray = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
							{
								throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
							}

							for (int t_i = 0; t_i < t_dwSize; t_i++ )
							{
								t_ix[ 0 ] = t_i;
								bstr_t t_bstrBuf( t_pchsaGetDnsServerList->GetAt( t_i ) );

								SafeArrayPutElement( t_pArray, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
							}


							VARIANT t_vValue ;

							V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_pArray ;
							if( !t_pInst->SetVariant( DNS_SERVERSEARCHORDER, t_vValue ) )
							{
								return WBEM_E_FAILED ;
							}
						}

						t_fDHCPEnabled = true;

						// DHCP LeaseTerminatesTime
						DWORD t_dwTimeTerm = t_DHCPInfo.GetLeaseExpiresDate() ;

						// DHCP LeaseObtainedTime
						DWORD t_dwTimeObtained = t_DHCPInfo.GetLeaseObtainedDate() ;

						// reflect lease times only if both are valid
						if( ( TIME_ADJUST( 0 ) < t_dwTimeTerm ) && ( TIME_ADJUST( 0 ) < t_dwTimeObtained ) )
						{
							// Under Win9x DHCP lease times are reported as local. SetDateTime()
							// expects to extract from WBEMTime a local time.
							// However, the WBEMTime arg expects the time to be UTC. Thus a conversion
							// from local to UTC is made here. Daylight savings can be safely ignored
							// since dwTimeTerm is will be interpreted by DHCP as local regardless of
							// the local time conditions in effect.
							// The times shown will match those relected by Winipcfg.

							_tzset() ;

							t_dwTimeTerm		+= _timezone;
							t_dwTimeObtained	+= _timezone;

							t_pInst->SetDateTime( L"DHCPLeaseExpires", (WBEMTime) t_dwTimeTerm ) ;
							t_pInst->SetDateTime( L"DHCPLeaseObtained", (WBEMTime) t_dwTimeObtained ) ;
						}
					}	// end if GetDHCPInfo

					//
					hGetDNS( t_pInst, t_iCtrIndex ) ;


					// Win servers from the WINS vxd

					if( t_pAdapterInfo->aIPInfo.GetSize() )
					{
						_IP_INFO *t_pIPInfo = (_IP_INFO*) t_pAdapterInfo->aIPInfo.GetAt( 0 ) ;

						if( t_pIPInfo )
						{
							CHString	t_chPrimaryWINSServer ;
							CHString	t_chSecondaryWINSServer ;

							// key on the IP address
							if( fGetWinsServers9x( t_pIPInfo->dwIPAddress, t_chPrimaryWINSServer, t_chSecondaryWINSServer ) )
							{
								// load up the instance
								if( !t_pInst->SetCHString( PRIMARY_WINS_SERVER, t_chPrimaryWINSServer) )
								{
									return WBEM_E_FAILED;
								}

								if(	!t_pInst->SetCHString( SECONDARY_WINS_SERVER, t_chSecondaryWINSServer) )
								{
									return WBEM_E_FAILED;
								}
							}
						}
					}
				}
			}

			// IPX enabled
			t_fIPXEnabled = t_pAdapterInfo->IPXEnabled ;

			// IPX address
			if(	t_fIPXEnabled && !t_pAdapterInfo->IPXAddress.IsEmpty() )
			{
				t_pInst->SetCHString( L"IPXAddress", t_pAdapterInfo->IPXAddress ) ;
			}
		}

		t_pInst->Setbool( L"IPEnabled",  t_fIPEnabled ) ;
		t_pInst->Setbool( L"IPXEnabled", t_fIPXEnabled ) ;
		t_pInst->Setbool( L"DHCPEnabled",t_fDHCPEnabled ) ;

		if( a_pMethodContext )
		{
            t_hResult = t_pInst->Commit() ;
        }

        //t_hResult = WBEM_S_NO_ERROR;
    }

	if( !t_bSpecificInstanceFound )
	{
		t_hResult = WBEM_E_NOT_FOUND ;
    }

	return t_hResult ;
}
#endif

#if NTONLY >= 5
HRESULT CWin32NetworkAdapterConfig::EnumNetAdaptersInNT5(MethodContext *a_pMethodContext, CAdapters &a_rAdapters )
{
	HRESULT				t_hResult = WBEM_S_NO_ERROR ;
	CW2kAdapterEnum		t_oAdapterEnum ;
	CW2kAdapterInstance *t_pAdapterInst ;

	// smart ptr
	CInstancePtr t_pInst ;

	// loop through the W2k identified instances
	for( int t_iCtrIndex = 0 ; t_iCtrIndex < t_oAdapterEnum.GetSize() ; t_iCtrIndex++ )
	{
		if( !( t_pAdapterInst = (CW2kAdapterInstance*) t_oAdapterEnum.GetAt( t_iCtrIndex ) ) )
		{
			continue;
		}

		t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

		// Drop out nicely if the Instance allocation fails
		if ( NULL != t_pInst )
		{
			// set the index since we will NEVER return to this key
			// the index is the key...for some ungodly reason.
			t_pInst->SetDWORD( _T("Index"), t_pAdapterInst->dwIndex ) ;

			// We load adapter data here.
			t_hResult = GetNetCardConfigForNT5( t_pAdapterInst,
												t_pInst,
												a_rAdapters ) ;

			if (SUCCEEDED( t_hResult ) )
			{
				t_hResult = t_pInst->Commit() ;
			}
			else
			{
				break ;
			}
		}
	}

	return t_hResult ;
}
#endif

#if NTONLY >= 5
HRESULT CWin32NetworkAdapterConfig::GetNetCardConfigForNT5 (	CW2kAdapterInstance *a_pAdapterInst,
																CInstance *a_pInst,
																CAdapters &a_rAdapters )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR;
	bool	t_fIPXEnabled	= false ;
	bool	t_fIPEnabled	= false ;

	// initialize to false
	a_pInst->Setbool(_T("DHCPEnabled"), false ) ;

	// Retrieve the adapter MAC address
	BYTE t_MACAddress[ 6 ] ;

	if( fGetMacAddress( t_MACAddress, a_pAdapterInst->chsNetCfgInstanceID ) )
	{
		CHString	t_chsMACAddress ;
					t_chsMACAddress.Format( _T("%02X:%02X:%02X:%02X:%02X:%02X"),
											t_MACAddress[ 0 ], t_MACAddress[ 1 ],
											t_MACAddress[ 2 ], t_MACAddress[ 3 ],
											t_MACAddress[ 4 ], t_MACAddress[ 5 ] ) ;

		a_pInst->SetCHString( _T("MACAddress"), t_chsMACAddress ) ;

		// get IPX address for this card, key by mac address
		if( GetIPXAddresses( a_pInst, t_MACAddress ) )
		{
			t_fIPXEnabled = true ;

			// IPX info
			hGetIPXGeneral( a_pInst, a_pAdapterInst->dwIndex ) ;
		}
	}

	//
	GetSettingID( a_pInst, a_pAdapterInst->dwIndex ) ;

	// descriptions
	CHString t_chsCaption( a_pAdapterInst->chsCaption ) ;
	CHString t_chsDescription( a_pAdapterInst->chsDescription ) ;

	// in the event one of the descriptions is missing as with NT5 bld 1991
	if( t_chsDescription.IsEmpty() )
	{
		t_chsDescription = t_chsCaption ;
	}
	else if( t_chsCaption.IsEmpty() )
	{
		t_chsCaption = t_chsDescription ;
	}

	vSetCaption( a_pInst, t_chsCaption, a_pAdapterInst->dwIndex, 8  ) ;
	a_pInst->SetCHString( IDS_Description, t_chsDescription ) ;

	// service name
	a_pInst->SetCHString(_T("ServiceName"), a_pAdapterInst->chsService ) ;


	if( !a_pAdapterInst->chsIpInterfaceKey.IsEmpty() )
	{
		if( GetIPInfoNT( a_pInst, a_pAdapterInst->chsIpInterfaceKey, a_rAdapters ) )
		{
			t_fIPEnabled = true ;

			hGetNtIpSec( a_pInst, a_pAdapterInst->chsIpInterfaceKey ) ;

			// WINS
			hGetWinsW2K(
                a_pInst, 
                a_pAdapterInst->dwIndex,
                a_pAdapterInst->chsRootdevice,
                a_pAdapterInst->chsIpInterfaceKey);

			// DNS
			t_hResult = hGetDNSW2K(
                a_pInst, 
                a_pAdapterInst->dwIndex,
                a_pAdapterInst->chsRootdevice,
                a_pAdapterInst->chsIpInterfaceKey);

			// TCP/IP general
			t_hResult = hGetTcpipGeneral( a_pInst ) ;
		}
	}

	// note the state of the protocols
	a_pInst->Setbool( _T("IPXEnabled"), t_fIPXEnabled ) ;
	a_pInst->Setbool( _T("IPEnabled"), t_fIPEnabled ) ;

	return( t_hResult ) ;
}
#endif

#if NTONLY >= 5
HRESULT CWin32NetworkAdapterConfig::GetNetAdapterInNT5(CInstance *a_pInst, CAdapters &a_rAdapters )
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;
	CW2kAdapterEnum		t_oAdapterEnum ;
	CW2kAdapterInstance *t_pAdapterInst ;
	DWORD				t_dwTestIndex = 0 ;

	// check the index to see if it is a match
	a_pInst->GetDWORD( _T("Index"), t_dwTestIndex ) ;

	// loop through the W2k identified instances
	for( int t_iCtrIndex = 0 ; t_iCtrIndex < t_oAdapterEnum.GetSize() ; t_iCtrIndex++ )
	{
		if( !( t_pAdapterInst = (CW2kAdapterInstance*) t_oAdapterEnum.GetAt( t_iCtrIndex ) ) )
		{
			continue;
		}

		// match to instance
		if ( t_dwTestIndex != t_pAdapterInst->dwIndex )
		{
			continue ;
		}

		// We load adapter data here.
		t_hResult = GetNetCardConfigForNT5( t_pAdapterInst,
											a_pInst,
											a_rAdapters ) ;
		break;
	}

	return t_hResult ;
}
#endif

BOOL CWin32NetworkAdapterConfig::GetIPXAddresses( CInstance *a_pInst, BYTE a_bMACAddress[ 6 ] )
{
	BOOL t_fRet = FALSE ;

	CWsock32Api *t_pwsock32api = (CWsock32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWsock32Api, NULL);
	if ( t_pwsock32api )
	{
		CHString		t_chsAddress ;
		CHString		t_chsNum ;
		WSADATA			t_wsaData ;
		int				t_cAdapters,
						t_res,
						t_cbOpt  = sizeof( t_cAdapters ),
						t_cbAddr = sizeof( SOCKADDR_IPX  ) ;
		SOCKADDR_IPX	t_Addr ;

		// guarded resource
		SOCKET			t_s = INVALID_SOCKET ;

		if( !t_pwsock32api->WsWSAStartup( 0x0101, &t_wsaData ) )
		{
			try
			{
				// Create IPX socket.
				t_s = t_pwsock32api->Wssocket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX  ) ;

				if( INVALID_SOCKET != t_s )
				{
					// Socket must be bound prior to calling IPX_MAX_ADAPTER_NUM.
					memset( &t_Addr, 0, sizeof( t_Addr ) ) ;
					t_Addr.sa_family = AF_IPX ;

					t_res = t_pwsock32api->Wsbind( t_s, (SOCKADDR*) &t_Addr, t_cbAddr ) ;

					// Get the number of adapters => cAdapters.
					t_res = t_pwsock32api->Wsgetsockopt( (SOCKET) t_s,
										NSPROTO_IPX,
										IPX_MAX_ADAPTER_NUM,
										(char *) &t_cAdapters,
										&t_cbOpt  ) ;

					int t_cIndex = 0 ;

					do
					{
						IPX_ADDRESS_DATA  t_IpxData ;

						memset( &t_IpxData, 0, sizeof( t_IpxData ) ) ;

						// Specify which adapter to check.
						t_IpxData.adapternum = t_cIndex ;
						t_cbOpt = sizeof( t_IpxData  ) ;

						// Get information for the current adapter.
						t_res = t_pwsock32api->Wsgetsockopt( t_s,
											NSPROTO_IPX,
											IPX_ADDRESS,
											(char*) &t_IpxData,
											&t_cbOpt ) ;

						// end of adapter array
						if ( t_res != 0 || t_IpxData.adapternum != t_cIndex )
						{
							break;
						}

						// is this the right adapter?
						bool t_fRightAdapter = true ;

						for( int t_j = 0; t_j < 6; t_j++ )
						{
							if( a_bMACAddress[ t_j ] != t_IpxData.nodenum[ t_j ] )
							{
								t_fRightAdapter = false ;
							}
						}

						if( t_fRightAdapter )
						{
							// IpxData contains the address for the current adapter.
							int t_i;
							for ( t_i = 0; t_i < 4; t_i++ )
							{
								t_chsNum.Format( L"%02X", t_IpxData.netnum[ t_i ] ) ;
								t_chsAddress += t_chsNum ;
							}
							t_chsAddress += _T(":" ) ;

							for ( t_i = 0; t_i < 5; t_i++ )
							{
								t_chsNum.Format( L"%02X", t_IpxData.nodenum[ t_i ] ) ;
								t_chsAddress += t_chsNum ;
							}

							t_chsNum.Format( L"%02X", t_IpxData.nodenum[ t_i ] ) ;
							t_chsAddress += t_chsNum ;

							a_pInst->SetCHString( L"IPXAddress", t_chsAddress ) ;

							t_fRet = true ;

							break;
						}
					}
					while( ++t_cIndex  ) ;

				}

			}
			catch( ... )
			{
				if( INVALID_SOCKET != t_s )
				{
					t_pwsock32api->Wsclosesocket( t_s ) ;
				}
				t_pwsock32api->WsWSACleanup() ;

				throw ;
			}

			if ( t_s != INVALID_SOCKET )
			{
				t_pwsock32api->Wsclosesocket( t_s ) ;
				t_s = INVALID_SOCKET ;
			}

			t_pwsock32api->WsWSACleanup() ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWsock32Api, t_pwsock32api);
	}
	return t_fRet ;
}

// max length of REG_MULTI_SZ.
#define MAX_VALUE 132
LONG CWin32NetworkAdapterConfig::ReadRegistryList(	HKEY a_hKey,
													LPCTSTR a_ParameterName,
													DWORD a_NumList[],
													int *a_MaxList )
{
	LONG	t_err ;
	DWORD	t_valueType ;
	BYTE	t_Buffer[ MAX_VALUE ] ;
	DWORD	t_BufferLength = MAX_VALUE ;

	BYTE	*t_pBuffer = t_Buffer ;
	BYTE	*t_pHeapBuffer = NULL ;

	int		t_k = 0 ;

	try
	{
		t_err = RegQueryValueEx(	a_hKey,
									a_ParameterName,
									NULL,
									&t_valueType,
									t_pBuffer,
									&t_BufferLength ) ;

		// then allocate off the heap
		if( t_err == ERROR_MORE_DATA )
		{
			t_pHeapBuffer = new BYTE[ t_BufferLength ] ;

			if( !t_pHeapBuffer )
			{
				throw ;
			}
			t_pBuffer = t_pHeapBuffer ;

			t_err = RegQueryValueEx(a_hKey,
									a_ParameterName,
									NULL,
									&t_valueType,
									t_pBuffer,
									&t_BufferLength ) ;
		}


		if( ( t_err == ERROR_SUCCESS ) && ( t_valueType == REG_MULTI_SZ ) )
		{
			TCHAR* t_NumValue = (TCHAR*) t_pBuffer;

			while( *t_NumValue && ( t_k < ( *a_MaxList ) ) )
			{
				a_NumList[ t_k++ ] = _tcstoul( t_NumValue, NULL, 0 ) ;
				t_NumValue += _tcslen( t_NumValue ) + 1 ;
			}

			*a_MaxList = t_k ;
		}
		else
		{
			*a_MaxList = 0 ;
			t_err = !ERROR_SUCCESS ;
		}

	}
	catch( ... )
	{
		if( t_pHeapBuffer )
		{
			delete t_pHeapBuffer ;
		}

		throw ;
	}

	if( t_pHeapBuffer )
	{
		delete t_pHeapBuffer ;
		t_pHeapBuffer = NULL ;
	}

	return t_err ;
}

//
BOOL CWin32NetworkAdapterConfig::IsContextIncluded( DWORD a_dwContext,
													DWORD a_dwContextList[],
													int a_iContextListLen )
{
	for( int t_i = 0; t_i < a_iContextListLen; t_i++ )
	{
		if( a_dwContext == a_dwContextList[ t_i ] )
		{
			return TRUE;
		}
	}
	return FALSE ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetworkAdapterConfig::RegPutString
 *
 *  DESCRIPTION : Wrapper for RegQueryValueEx for the case where the registry
 *                value is in actuality a REG_MULTI_SZ and we don't
 *                necessarily want all of the strings.
 *
 *  INPUTS      : HKEY   hKey           : opened registry key
 *                char  *pszTarget      : desired entry
 *                char  *pszDestBuffer  : buffer to receive result
 *                DWORD  dwBufferSize   : size of output buffer
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : RegQueryValueEx error/success code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/


LONG CWin32NetworkAdapterConfig::RegPutStringArray(	HKEY a_hKey,
													LPCTSTR a_pszTarget,
													SAFEARRAY &a_strArray,
													TCHAR a_cDelimiter )
{
    LONG	t_lRetCode = ERROR_BADKEY;
	WCHAR	*t_Buffer = NULL ;

	try
	{
		if ( SafeArrayGetDim ( &a_strArray ) == 1 )
		{
			LONG t_Dimension = 1 ;

			LONG t_LowerBound ;
			SafeArrayGetLBound ( &a_strArray, t_Dimension , & t_LowerBound ) ;

			LONG t_UpperBound ;
			SafeArrayGetUBound ( &a_strArray, t_Dimension , &t_UpperBound ) ;

			LONG t_Count = ( t_UpperBound - t_LowerBound ) + 1 ;

			DWORD t_BufferLength = 0 ;

			for ( LONG t_Index = t_LowerBound; t_Index <= t_UpperBound; t_Index++ )
			{
				BSTR t_bstr = NULL ;
				SafeArrayGetElement ( &a_strArray, &t_Index, &t_bstr ) ;

				bstr_t t_bstrElement( t_bstr, FALSE ) ;

				t_BufferLength += t_bstrElement.length() + 1 ;
			}

			t_BufferLength++ ;

			t_Buffer = new WCHAR [ t_BufferLength ] ;
			if( !t_Buffer )
			{
				throw ;
			}

			memset( t_Buffer, 0, sizeof( WCHAR ) * t_BufferLength ) ;

			DWORD t_BufferPos = 0 ;
			for ( t_Index = t_LowerBound; t_Index <= t_UpperBound; t_Index ++ )
			{
				BSTR t_bstr = NULL ;
				SafeArrayGetElement ( &a_strArray, &t_Index, &t_bstr ) ;

				bstr_t t_bstrElement( t_bstr, FALSE ) ;

				CHString t_String ;

				if( t_Index != t_LowerBound && a_cDelimiter )
				{
					t_String += a_cDelimiter;
				}

				t_String += (wchar_t*)t_bstrElement;

				lstrcpyW( &t_Buffer[ t_BufferPos ] , t_String ) ;

				t_BufferPos += t_String.GetLength() + !a_cDelimiter;
			}

			t_Buffer[ t_BufferPos ] = 0 ;

			DWORD t_BufferType ;

			if( NULL == a_cDelimiter )
			{
				t_BufferType = REG_MULTI_SZ ;
			}
			else
			{
				t_BufferType = REG_SZ ;
				t_BufferLength--;
			}

			t_lRetCode = RegSetValueEx(
										a_hKey ,
										a_pszTarget,
										0,
										t_BufferType ,
										( LPBYTE ) t_Buffer,
										t_BufferLength * sizeof( WCHAR ) ) ;
		}

	}
	catch( ... )
	{
		if( t_Buffer )
		{
			delete t_Buffer ;
		}

		throw ;
	}

	if( t_Buffer )
	{
		delete t_Buffer ;
		t_Buffer = NULL;
	}

    return t_lRetCode ;
}

/*******************************************************************
    NAME:       RegPutINTtoStringArray

    SYNOPSIS:   Update the registry with an array of uint converted character strings

    ENTRY:      CRegistry& rRegistry	:
				char* szSubKey			:
				SAFEARRAY** a_Array		:	this is a VT_4 array
				CHString chsFormat		:	output format
				int iMaxOutSize			:	maximum per element output size

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
LONG CWin32NetworkAdapterConfig::RegPutINTtoStringArray(	HKEY a_hKey,
															LPCTSTR a_pszTarget,
															SAFEARRAY *a_strArray,
															CHString& a_chsFormat,
															int a_iMaxOutSize )
 {
    LONG	t_lRetCode = ERROR_BADKEY ;
	WCHAR	*t_Buffer = NULL ;

	try
	{
		if ( SafeArrayGetDim ( a_strArray ) == 1 )
		{
			LONG t_Dimension = 1 ;
			LONG t_LowerBound ;
			LONG t_UpperBound ;

			SafeArrayGetLBound( a_strArray , t_Dimension , & t_LowerBound ) ;
			SafeArrayGetUBound( a_strArray , t_Dimension , & t_UpperBound ) ;

			LONG t_Count = ( t_UpperBound - t_LowerBound ) + 1 ;

			//iMaxOutSize includes space for the NULL after every integer string
			DWORD t_BufferLength = t_Count * ( a_iMaxOutSize ) ;

			//one for the double null at the end
			t_BufferLength++ ;

			t_Buffer = new WCHAR [ t_BufferLength ] ;

			if( !t_Buffer )
			{
				throw ;
			}

			//no need to add the terminating NULL
			memset( (void*) t_Buffer, 0, t_BufferLength * sizeof( WCHAR ) ) ;

			t_BufferLength = 0 ;
			WCHAR *t_ptr = t_Buffer ;

			for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
			{
				int t_iElement ;
				SafeArrayGetElement ( a_strArray , &t_Index , &t_iElement ) ;

				CHString t_temp ;
				t_temp.Format( a_chsFormat, t_iElement ) ;

				lstrcpyW( t_ptr, t_temp ) ;

				DWORD t_offset = t_temp.GetLength() + 1 ;

				t_BufferLength	+= t_offset ;
				t_ptr			+= t_offset ;
			}
			t_BufferLength++;	// Double NULL

			DWORD t_BufferType = REG_MULTI_SZ ;

			t_lRetCode = RegSetValueEx(
										a_hKey ,
										a_pszTarget,
										0,
										t_BufferType,
										( LPBYTE ) t_Buffer,
										t_BufferLength * sizeof( WCHAR ) ) ;
		}

	}
	catch( ... )
	{
		if( t_Buffer )
		{
			delete t_Buffer ;
		}

		throw ;
	}

	if( t_Buffer )
	{
		delete t_Buffer ;
		t_Buffer = NULL;
	}

    return t_lRetCode ;
}
/*******************************************************************
    NAME:       RegGetStringArray

    SYNOPSIS:   Retrieve an array of strings from the registry

    ENTRY:      CRegistry& rRegistry	:
				char* szSubKey			:
				SAFEARRAY** a_Array		:

    HISTORY:
                  19-Jul-1998     Created
********************************************************************/

LONG CWin32NetworkAdapterConfig::RegGetStringArray(	CRegistry &a_rRegistry,
													LPCWSTR a_szSubKey,
													SAFEARRAY** a_Array,
													TCHAR a_cDelimiter )
{
	CRegistry		t_Registry ;
	CHString		t_chsTemp ;
	LONG			t_lRetCode ;
	SAFEARRAYBOUND	t_rgsabound[1 ] ;
	DWORD			t_dwSize = 0;
	long			t_ix[ 1 ] ;

	if( NULL == a_cDelimiter )
	{
		CHStringArray t_chsMZArray ;

		if( ERROR_SUCCESS != ( t_lRetCode = a_rRegistry.GetCurrentKeyValue( a_szSubKey, t_chsMZArray ) ) )
		{
			return t_lRetCode ;
		}

		t_dwSize = t_chsMZArray.GetSize( ) ;

		if( t_dwSize )
		{
			t_rgsabound->cElements = t_dwSize ;
			t_rgsabound->lLbound = 0 ;

			if( !( *a_Array = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
			{
				throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
			}

			for (int t_i = 0; t_i < t_dwSize; t_i++ )
			{
				t_ix[ 0 ] = t_i;
				bstr_t t_bstrBuf( t_chsMZArray.GetAt( t_i ) );

				SafeArrayPutElement( *a_Array, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
			}
		}
	}
	else
	{
		CHString t_chsArray;
		if( ERROR_SUCCESS != ( t_lRetCode = a_rRegistry.GetCurrentKeyValue( a_szSubKey, t_chsArray ) ) )
		{
			return t_lRetCode;
		}

		int t_iTokLen ;

		// count the elements
		CHString t_strTok = t_chsArray;

		while( TRUE )
		{
			t_iTokLen = t_strTok.Find( a_cDelimiter  ) ;
			if( -1 == t_iTokLen )
				break;

			t_dwSize++ ;
			t_strTok = t_strTok.Mid( t_iTokLen + 1  ) ;
		}

		// may not be t_cDelimiter postpended for a single element
		if(!t_strTok.IsEmpty() )
		{
			t_dwSize++ ;
		}

		if( t_dwSize )
		{
			t_rgsabound->cElements = t_dwSize;
			t_rgsabound->lLbound = 0 ;

			if( !( *a_Array = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
			{
				throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
			}

			int t_i = 0 ;
			t_strTok = t_chsArray ;

			do
			{
				t_iTokLen = t_strTok.Find( a_cDelimiter ) ;

				if( -1 != t_iTokLen )
				{
					t_chsTemp = t_strTok.Left( t_iTokLen ) ;
				}
				else
				{
					t_chsTemp = t_strTok ;
				}

				t_ix[ 0 ] = t_i ;
				bstr_t t_bstrBuf( t_chsTemp ) ;

				SafeArrayPutElement( *a_Array, &t_ix[0], (wchar_t*)t_bstrBuf ) ;

				if( -1 == t_iTokLen )
				{
					break;
				}

				t_strTok = t_strTok.Mid( t_iTokLen + 1  ) ;

			} while( ++t_i ) ;
		}
	}
	return t_lRetCode ;
}



/*******************************************************************
    NAME:       RegGetStringArrayEx

    SYNOPSIS:   Retrieve an array of strings from the registry. 
                Checks for comma in string and if present, parses
                based on that.  Otherwise, assumes space based
                parsing.

    ENTRY:      CRegistry& rRegistry	:
				char* szSubKey			:
				SAFEARRAY** a_Array		:

    HISTORY:
                  24-Aug-20008     Created
********************************************************************/

LONG CWin32NetworkAdapterConfig::RegGetStringArrayEx(CRegistry &a_rRegistry,
													LPCWSTR a_szSubKey,
													SAFEARRAY** a_Array )
{
	CRegistry		t_Registry ;
	CHString		t_chsTemp ;
	LONG			t_lRetCode ;
	SAFEARRAYBOUND	t_rgsabound[1 ] ;
	DWORD			t_dwSize = 0;
	long			t_ix[ 1 ] ;
    WCHAR           t_cDelimiter = L',';

	CHString t_chsArray;
	if( ERROR_SUCCESS != ( t_lRetCode = a_rRegistry.GetCurrentKeyValue( a_szSubKey, t_chsArray ) ) )
	{
		return t_lRetCode;
	}

	int t_iTokLen ;

	// count the elements
	CHString t_strTok = t_chsArray;

    // See if we have a comma delimiter...
    if(wcschr(t_strTok, t_cDelimiter) == NULL)
    {
        t_cDelimiter = L' ';
    }

	while( TRUE )
	{
		t_iTokLen = t_strTok.Find( t_cDelimiter  ) ;
		if( -1 == t_iTokLen )
			break;

		t_dwSize++ ;
		t_strTok = t_strTok.Mid( t_iTokLen + 1  ) ;
	}

	// may not be t_cDelimiter postpended for a single element
	if(!t_strTok.IsEmpty() )
	{
		t_dwSize++ ;
	}

	if( t_dwSize )
	{
		t_rgsabound->cElements = t_dwSize;
		t_rgsabound->lLbound = 0 ;

		if( !( *a_Array = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		int t_i = 0 ;
		t_strTok = t_chsArray ;

		do
		{
			t_iTokLen = t_strTok.Find( t_cDelimiter ) ;

			if( -1 != t_iTokLen )
			{
				t_chsTemp = t_strTok.Left( t_iTokLen ) ;
			}
			else
			{
				t_chsTemp = t_strTok ;
			}

			t_ix[ 0 ] = t_i ;
			bstr_t t_bstrBuf( t_chsTemp ) ;

			SafeArrayPutElement( *a_Array, &t_ix[0], (wchar_t*)t_bstrBuf ) ;

			if( -1 == t_iTokLen )
			{
				break;
			}

			t_strTok = t_strTok.Mid( t_iTokLen + 1  ) ;

		} while( ++t_i ) ;
	}
	return t_lRetCode ;
}


/*******************************************************************
    NAME:       RegGetHEXtoINTArray

    SYNOPSIS:   Retrieve an array of ints converted from HEX strings in the registry.

    ENTRY:      CRegistry& rRegistry	:
				char* szSubKey			:
				SAFEARRAY** a_Array		:

    HISTORY:
                  19-Jul-1998     Created
********************************************************************/

LONG CWin32NetworkAdapterConfig::RegGetHEXtoINTArray(	CRegistry &a_rRegistry,
														LPCTSTR a_szSubKey,
														SAFEARRAY **a_Array )
{
	CRegistry		t_Registry ;
	CHStringArray	t_chsArray ;
	LONG			t_lRetCode ;

	if( ERROR_SUCCESS != ( t_lRetCode = a_rRegistry.GetCurrentKeyValue( TOBSTRT( a_szSubKey ), t_chsArray ) ) )
	{
		return t_lRetCode;
	}

	// walk array adding to the safe array
	SAFEARRAYBOUND	t_rgsabound[ 1 ] ;
	DWORD			t_dwSize ;
	long			t_ix[ 1 ] ;

	t_dwSize = t_chsArray.GetSize() ;
	t_rgsabound->cElements = t_dwSize ;
	t_rgsabound->lLbound = 0 ;

	if( !( *a_Array = SafeArrayCreate( VT_I4, 1, t_rgsabound ) ) )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	t_ix[ 0 ] = 0 ;

	for ( int t_i = 0; t_i < t_dwSize ; t_i++ )
	{
		t_ix[ 0 ] = t_i ;

		// HEX char to int
		int t_iElement = wcstoul( t_chsArray.GetAt( t_i ), NULL, 16 ) ;

		SafeArrayPutElement( *a_Array, &t_ix[0], &t_iElement ) ;
	}

	return t_lRetCode ;
}

/*******************************************************************
    NAME:       fCreateArrayEntry

    SYNOPSIS:   Adds the string to the array. If the safearray does not exist
				it will be created.

    ENTRY:      SAFEARRAY** a_Array		:
				CHString& chsStr		:
    HISTORY:
                  31-Jul-1998     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fCreateAddEntry( SAFEARRAY **a_Array, CHString &a_chsStr )
{
	if( !*a_Array )
	{

		SAFEARRAYBOUND t_rgsabound[ 1 ] ;
		t_rgsabound->cElements	= 1 ;
		t_rgsabound->lLbound	= 0 ;

		if( !( *a_Array = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}
	}

	long	t_ix[ 1 ] ;
			t_ix[ 0 ] = 0;

	bstr_t t_bstrBuf( a_chsStr ) ;

	HRESULT t_hRes = SafeArrayPutElement( *a_Array, &t_ix[0], (wchar_t*)t_bstrBuf ) ;

	if( S_OK != t_hRes )
	{
		return FALSE ;
	}

	return TRUE ;
}

/*******************************************************************
    NAME:       hSetDBPath

    SYNOPSIS:   Set TCP/IP database path
    ENTRY:      CMParms &a_rMParms	:

	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetDBPath( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the database path
	CHString t_chsDBPath ;
	if( !a_rMParms.pInParams()->GetCHString( DATA_BASE_PATH, t_chsDBPath ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// registry open
	HRESULT t_hRes = t_oReg.Open( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ), KEY_WRITE ) ;

	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_DB_PATH, t_chsDBPath ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetIPUseZero

    SYNOPSIS:   Set IP use zero broadcast
    ENTRY:      CMParms &a_rMParms	:

	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetIPUseZero( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, IP_USE_ZERO_BROADCAST, RVAL_ZERO_BROADCAST ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED  ) ;
	}

	return S_OK;
#endif
}

/*******************************************************************
    NAME:       hSetArpAlwaysSource

    SYNOPSIS:   Set ARP to transmit ARP queries with source routing on
				token ring networks
    ENTRY:      CMParms &a_rMParms	:

	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetArpAlwaysSource( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, ARP_ALWAYS_SOURCE_ROUTE, RVAL_ARP_ALWAYS_SOURCE ) )
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;

	return S_OK ;
#endif
}

/*******************************************************************
    NAME:       hSetArpUseEtherSNAP

    SYNOPSIS:   Set TCP/IP to use SNAP
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetArpUseEtherSNAP( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, ARP_USE_ETHER_SNAP, RVAL_USE_SNAP ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED  ) ;
	}

	return S_OK;
#endif
}

/*******************************************************************
    NAME:       hSetTOS

    SYNOPSIS:   Set default type of service
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTOS( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CRegistry t_oReg;
	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	// extract the Default TOS
	DWORD t_dwDefaultTOS = 0 ;
	if( !a_rMParms.pInParams()->GetByte( DEFAULT_TOS, (BYTE&)t_dwDefaultTOS ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}
	// on bogus
	if( 255 < t_dwDefaultTOS )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry entry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_DEFAULT_TOS, t_dwDefaultTOS ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetTTL

    SYNOPSIS:   Set default time to live
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTTL( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CRegistry t_oReg;
	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	// extract the Default TTL
	DWORD t_dwDefaultTTL = 0 ;
	if( !a_rMParms.pInParams()->GetByte( DEFAULT_TTL, (BYTE&)t_dwDefaultTTL ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// on bogus
	if( 255 < t_dwDefaultTTL  || !t_dwDefaultTTL )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry entry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_DEFAULT_TTL, t_dwDefaultTTL ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetDeadGWDetect

    SYNOPSIS:   Set the dead gateway detect flag
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetDeadGWDetect( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CHString t_chsSKey =  SERVICES_HOME;
			 t_chsSKey += TCPIP_PARAMETERS;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, ENABLE_DEAD_GW_DETECT, RVAL_DEAD_GW_DETECT ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
	}

	return S_OK;
#endif
}

/*******************************************************************
    NAME:       hSetPMTUBHDetect

    SYNOPSIS:   Set the black hole detect flag
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetPMTUBHDetect( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CHString t_chsSKey =  SERVICES_HOME ;
			 t_chsSKey += TCPIP_PARAMETERS ;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, ENABLE_PMTUBH_DETECT, RVAL_BLACK_HOLE_DETECT ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
	}

	return S_OK;
#endif
}

/*******************************************************************
    NAME:       hSetPMTUDiscovery

    SYNOPSIS:   Set the MTU discovery flag
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetPMTUDiscovery( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
	return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CHString t_chsSKey =  SERVICES_HOME;
			 t_chsSKey += TCPIP_PARAMETERS;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, ENABLE_PMTU_DISCOVERY, RVAL_MTU_DISCOVERY ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
	}

	return S_OK;
#endif
}

/*******************************************************************
    NAME:       hSetForwardBufMem

    SYNOPSIS:   Set IP forward memory buffer size
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetForwardBufMem( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the forward memory buffer size
	DWORD t_dwFMB;
	if( !a_rMParms.pInParams()->GetDWORD( FORWARD_BUFFER_MEMORY, t_dwFMB ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_FORWARD_MEM_BUFF, t_dwFMB ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetIGMPLevel

    SYNOPSIS:   Set IP multicasting parm
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetIGMPLevel( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the IP multicasting parm
	DWORD t_dwIGMPLevel = 0;
	if( !a_rMParms.pInParams()->GetByte( IGMP_LEVEL, (BYTE&)t_dwIGMPLevel ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// test the parameter
	if( 0 != t_dwIGMPLevel && 1 != t_dwIGMPLevel && 2 != t_dwIGMPLevel )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}
	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen(HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_IGMP_LEVEL, t_dwIGMPLevel ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetKeepAliveInt

    SYNOPSIS:   Set the IP keep alive interval
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetKeepAliveInt( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the keep alive interval
	DWORD t_dwKeepAliveInterval ;
	if( !a_rMParms.pInParams()->GetDWORD( KEEP_ALIVE_INTERVAL, t_dwKeepAliveInterval ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}
	// test the parameter
	if( !t_dwKeepAliveInterval )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen(HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_IP_KEEP_ALIVE_INT, t_dwKeepAliveInterval ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetKeepAliveTime

    SYNOPSIS:   Set the IP keep alive interval
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetKeepAliveTime( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop at this time
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the keep alive time
	DWORD t_dwKeepAliveTime ;
	if( !a_rMParms.pInParams()->GetDWORD( KEEP_ALIVE_TIME, t_dwKeepAliveTime ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// test the parameter
	if( !t_dwKeepAliveTime )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_IP_KEEP_ALIVE_TIME, t_dwKeepAliveTime ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetMTU

    SYNOPSIS:   Set the Max Transmission Unit
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetMTU( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the MTU
	DWORD t_dwMTU ;
	if( !a_rMParms.pInParams()->GetDWORD( MTU, t_dwMTU ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// test the parameter
	if( 68 > t_dwMTU )
	{
		return a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_MTU, t_dwMTU ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetNumForwardPkts

    SYNOPSIS:   Set the number of IP forward header packets
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetNumForwardPkts( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

	// Supported only for the NT4 drop at this time
#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the number of forward header packets
	DWORD t_dwFHP ;
	if( !a_rMParms.pInParams()->GetDWORD( NUM_FORWARD_PACKETS, t_dwFHP ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// test the parameter
	if( !t_dwFHP )
	{
		return a_rMParms.hSetResult(E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_NUM_FORWARD_PKTS, t_dwFHP ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetTcpMaxConRetrans

    SYNOPSIS:   Set the max connect retransmissions
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTcpMaxConRetrans( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the number of max connect retransmissions
	DWORD t_dwMCR ;
	if( !a_rMParms.pInParams()->GetDWORD( TCP_MAX_CONNECT_RETRANS, t_dwMCR ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen(HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_MAX_CON_TRANS, t_dwMCR ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetTcpMaxDataRetrans

    SYNOPSIS:   Set the max data retransmissions
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTcpMaxDataRetrans( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME;
				t_chsSKey += TCPIP_PARAMETERS;

	// extract the number of max data retransmissions
	DWORD t_dwMDR ;
	if( !a_rMParms.pInParams()->GetDWORD( TCP_MAX_DATA_RETRANS, t_dwMDR ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_MAX_DATA_TRANS, t_dwMDR ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetTcpNumCons

    SYNOPSIS:   Set the max data retransmissions
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTcpNumCons( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the max number of connections
	DWORD t_dwMaxConnections ;
	if( !a_rMParms.pInParams()->GetDWORD( TCP_NUM_CONNECTIONS, t_dwMaxConnections ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// test the parameter
	if( 0xfffffe < t_dwMaxConnections )
	{
		return a_rMParms.hSetResult(E_RET_PARAMETER_BOUNDS_ERROR ) ;
	}

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER ;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_NUM_CONNECTIONS, t_dwMaxConnections ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hSetTcpUseRFC1122UP

    SYNOPSIS:   Set the RFC1122 urgent pointer value
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTcpUseRFC1122UP( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	CHString t_chsSKey =  SERVICES_HOME;
			 t_chsSKey += TCPIP_PARAMETERS;

	if( fCreateBoolToReg( a_rMParms, t_chsSKey, TCP_USE_RFC1122_URG_PTR, RVAL_RFC_URGENT_PTR ) )
	{
		a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
	}

	return S_OK;
#endif
}

/*******************************************************************
    NAME:       hSetTcpWindowSize

    SYNOPSIS:   Set the TCP window size
    ENTRY:      CMParms &a_rMParms	:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetTcpWindowSize( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY

	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	// extract the TCP window size
	DWORD t_dwTCPWindowSize = 0 ;
	if( !a_rMParms.pInParams()->GetWORD( TCP_WINDOW_SIZE, (WORD&)t_dwTCPWindowSize ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// test the parameter
	if( 0xffff < t_dwTCPWindowSize )
		return a_rMParms.hSetResult(E_RET_PARAMETER_BOUNDS_ERROR ) ;

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen(HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_TCP_WINDOW_SIZE, t_dwTCPWindowSize ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       fCreateBoolToReg

    SYNOPSIS:   Set a boolean from the Inparms to the registry
				insuring the subkey is created if it is not already there.

    ENTRY:      CMParms &a_rMParms,
				CHString& oSKey,
				LPCTSTR pSource,
				LPCTSTR pTarget

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fCreateBoolToReg(	CMParms &a_rMParms,
													CHString &a_oSKey,
													LPCTSTR a_pSource,
													LPCTSTR a_pTarget )
{
	CRegistry t_oReg;

	// insure the key is there on open
	HRESULT t_hRes = t_oReg.CreateOpen(HKEY_LOCAL_MACHINE, a_oSKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return FALSE;
	}

	return fBoolToReg( a_rMParms, t_oReg, a_pSource, a_pTarget ) ;
}

/*******************************************************************
    NAME:       fBoolToReg

    SYNOPSIS:   Set a boolean from the Inparms to the registry

    ENTRY:      CMParms &a_rMParms,
				Registry& oReg,
				LPCTSTR pSource,
				LPCTSTR pTarget

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fBoolToReg(	CMParms &a_rMParms,
												CRegistry &a_rReg,
												LPCTSTR a_pSource,
												LPCTSTR a_pTarget )
{
	// extract the value
	bool	t_bValue ;
	DWORD	t_dwValue ;
	DWORD	t_dwRes ;

	if( !a_rMParms.pInParams()->Getbool( TOBSTRT( a_pSource ), t_bValue ) )
	{
		a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
		return FALSE ;
	}

	// load the registry
	t_dwValue = t_bValue ? 1 : 0 ;

	t_dwRes = a_rReg.SetCurrentKeyValue( TOBSTRT( a_pTarget ), t_dwValue ) ;
	if( fMapResError( a_rMParms, t_dwRes, E_RET_REGISTRY_FAILURE ) )
	{
		return FALSE;
	}

	a_rMParms.hSetResult( E_RET_OK ) ;

	return TRUE;
}

/*******************************************************************
    NAME:       hGetTcpipGeneral

    SYNOPSIS:   Retrieves the TCP/IP misc settings
    ENTRY:      CInstance *a_pInst	:

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
#ifdef NTONLY
HRESULT CWin32NetworkAdapterConfig::hGetTcpipGeneral( CInstance *a_pInst )
{
	CRegistry	t_oReg;
	CHString	t_csBindingKey =  SERVICES_HOME ;
				t_csBindingKey += TCPIP_PARAMETERS ;

	// open the registry
	long t_lRes = t_oReg.Open(HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_READ ) ;

	// on error map to WBEM
	HRESULT t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	// database path
	CHString t_chsDBPath;

	t_oReg.GetCurrentKeyValue( RVAL_DB_PATH, t_chsDBPath ) ;

	a_pInst->SetCHString(DATA_BASE_PATH, t_chsDBPath ) ;

	// extract the IP use zero source flag
	DWORD t_dwUseZeroBroadcast ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_ZERO_BROADCAST, t_dwUseZeroBroadcast ) )
	{
		a_pInst->Setbool( IP_USE_ZERO_BROADCAST, (bool)t_dwUseZeroBroadcast ) ;
	}

	// extract the Arp always source flag
	DWORD t_dwArpAlwaysSource ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_ARP_ALWAYS_SOURCE, t_dwArpAlwaysSource ) )
	{
		a_pInst->Setbool( ARP_ALWAYS_SOURCE_ROUTE, (bool)t_dwArpAlwaysSource  ) ;
	}

	// extract the Arp SNAP flag
	DWORD t_dwArpUseSNAP ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_USE_SNAP, t_dwArpUseSNAP ) )
	{
		a_pInst->Setbool( ARP_USE_ETHER_SNAP, t_dwArpUseSNAP ) ;
	}

	// extract the Default TOS
	DWORD t_dwDefaultTOS;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_DEFAULT_TOS, t_dwDefaultTOS ) )
	{
		a_pInst->SetByte( DEFAULT_TOS, (BYTE&) t_dwDefaultTOS ) ;
	}

	// extract the default TTL
	DWORD t_dwDefaultTTL ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_DEFAULT_TTL, t_dwDefaultTTL ) )
	{
		a_pInst->SetByte( DEFAULT_TTL, (BYTE)t_dwDefaultTTL ) ;
	}

	// extract the dead gateway detect flag
	DWORD t_dwDGEDetect ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_DEAD_GW_DETECT, t_dwDGEDetect ) )
	{
		a_pInst->Setbool( ENABLE_DEAD_GW_DETECT, (bool)t_dwDGEDetect ) ;
	}

	// extract the black hole detect flag
	DWORD t_dwBHDetect ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_BLACK_HOLE_DETECT, t_dwBHDetect ) )
	{
		a_pInst->Setbool( ENABLE_PMTUBH_DETECT, (bool)t_dwBHDetect ) ;
	}

	// extract the MTU discovery flag
	DWORD t_dwMTUDiscovery ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_MTU_DISCOVERY, t_dwMTUDiscovery ) )
	{
		a_pInst->Setbool( ENABLE_PMTU_DISCOVERY, (bool)t_dwMTUDiscovery ) ;
	}

	// extract the forward memory buffer size
	DWORD t_dwFMB;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_FORWARD_MEM_BUFF, t_dwFMB ) )
	{
		a_pInst->SetDWORD( FORWARD_BUFFER_MEMORY, t_dwFMB ) ;
	}

	// extract the IP multicasting parm
	DWORD t_dwIGMPLevel;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_IGMP_LEVEL, t_dwIGMPLevel ) )
	{
		a_pInst->SetByte( IGMP_LEVEL, (BYTE)t_dwIGMPLevel ) ;
	}

	// extract the keep alive interval
	DWORD t_dwKeepAliveInterval ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_IP_KEEP_ALIVE_INT, t_dwKeepAliveInterval ) )
	{
		a_pInst->SetDWORD( KEEP_ALIVE_INTERVAL, t_dwKeepAliveInterval  ) ;
	}

	// extract the keep alive time
	DWORD t_dwKeepAliveTime ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_IP_KEEP_ALIVE_TIME, t_dwKeepAliveTime ) )
	{
		a_pInst->SetDWORD( KEEP_ALIVE_TIME, t_dwKeepAliveTime ) ;
	}

	// extract the MTU
	DWORD t_dwMTU ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_MTU, t_dwMTU ) )
	{
		a_pInst->SetDWORD( MTU, t_dwMTU ) ;
	}

	// extract the number of forward header packets
	DWORD t_dwFHP ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_NUM_FORWARD_PKTS, t_dwFHP ) )
	{
		a_pInst->SetDWORD( NUM_FORWARD_PACKETS, t_dwFHP ) ;
	}

	// extract the number of max connect retransmissions
	DWORD t_dwMCR ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_MAX_CON_TRANS, t_dwMCR ) )
	{
		a_pInst->SetDWORD( TCP_MAX_CONNECT_RETRANS, t_dwMCR  ) ;
	}

	// extract the number of max data retransmissions
	DWORD t_dwMDR ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_MAX_DATA_TRANS, t_dwMDR ) )
	{
		a_pInst->SetDWORD( TCP_MAX_DATA_RETRANS, t_dwMDR  ) ;
	}

	// extract the max number of connections
	DWORD t_dwMaxConnections ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_NUM_CONNECTIONS, t_dwMaxConnections ) )
	{
		a_pInst->SetDWORD( TCP_NUM_CONNECTIONS, t_dwMaxConnections  ) ;
	}

	// extract the RFE1122 urgent pointer flag
	DWORD t_dwRFC1122 ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_RFC_URGENT_PTR, t_dwRFC1122 ) )
	{
		a_pInst->Setbool( TCP_USE_RFC1122_URG_PTR, (bool)t_dwRFC1122 ) ;
	}

	// extract the TCP window size
	DWORD t_dwTCPWindowSize ;
	if( ERROR_SUCCESS == t_oReg.GetCurrentKeyValue( RVAL_TCP_WINDOW_SIZE, t_dwTCPWindowSize ) )
	{
		a_pInst->SetWORD( TCP_WINDOW_SIZE, (WORD&)t_dwTCPWindowSize  ) ;
	}
	return S_OK ;
}
#endif

/*******************************************************************
    NAME:       hGetIPXGeneral

    SYNOPSIS:   Retrieve from the registry specific IPX info
    ENTRY:      CInstance *a_pInst	:

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
#ifdef NTONLY
HRESULT CWin32NetworkAdapterConfig::hGetIPXGeneral( CInstance *a_pInst, DWORD a_dwIndex )
{
	// Open IPX parms from the registry
	CHString t_csIPXParmsBindingKey =  SERVICES_HOME ;
			 t_csIPXParmsBindingKey += IPX ;
			 t_csIPXParmsBindingKey += PARAMETERS ;

	// open the registry
	CRegistry t_oRegIPX ;
	long t_lRes = t_oRegIPX.Open(HKEY_LOCAL_MACHINE, t_csIPXParmsBindingKey.GetBuffer( 0 ), KEY_READ ) ;

	// on error map to WBEM
	HRESULT t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError ;
	}

	// Get the virtual network number
	DWORD t_dwNetworkNum = 0 ;
	t_oRegIPX.GetCurrentKeyValue( RVAL_VIRTUAL_NET_NUM, t_dwNetworkNum ) ;

	CHString t_chsVirtualNum;
			 t_chsVirtualNum.Format( _T("%08X"), t_dwNetworkNum ) ;

	// update
	if( !a_pInst->SetCHString( IPX_VIRTUAL_NET_NUM, t_chsVirtualNum ) )
	{
		return WBEM_E_FAILED;
	}

	// Unable to locate MediaType under NT5
	if( !IsWinNT5() )
	{
		 // extract the service name
		CHString t_ServiceName ;
		a_pInst->GetCHString( _T("ServiceName"), t_ServiceName ) ;


		// default media type
		DWORD t_dwMediaType = ETHERNET_MEDIA ;

		// Open adapter specific IPX parms from the registry
		CHString t_csKey =  SERVICES_HOME ;
				 t_csKey += _T("\\" ) ;
				 t_csKey += t_ServiceName ;
				 t_csKey += PARAMETERS ;

		CRegistry t_oRegIPXAdapter ;
		t_lRes = t_oRegIPXAdapter.Open(HKEY_LOCAL_MACHINE, t_csKey.GetBuffer( 0 ), KEY_READ ) ;

		if( ERROR_SUCCESS == t_lRes )
		{
			// Media type
			t_oRegIPXAdapter.GetCurrentKeyValue( RVAL_MEDIA_TYPE, t_dwMediaType ) ;
		}
		else if( REGDB_E_KEYMISSING != t_lRes )
		{
			return WinErrorToWBEMhResult( t_lRes ) ;
		}


		if( !a_pInst->SetDWORD( IPX_MEDIATYPE, t_dwMediaType ) )
		{
			return WBEM_E_FAILED;
		}
	}

	// registry for adapter specific IPX binding
	CHString t_csIPXNetBindingKey ;
	CHString t_chsLink ;
	if( !fGetNtIpxRegAdapterKey( a_dwIndex, t_csIPXNetBindingKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtIpxRegAdapterKey failed");
        return E_RET_OBJECT_NOT_FOUND ;
	}

	SAFEARRAY *t_FrameType	= NULL ;
	SAFEARRAY *t_NetNumber	= NULL ;

	saAutoClean acFrameType( &t_FrameType ) ;	// stack scope cleanup
	saAutoClean acNetNumber( &t_NetNumber ) ;

	CRegistry t_oRegIPXNetDriver ;
	t_lRes = t_oRegIPXNetDriver.Open( HKEY_LOCAL_MACHINE, t_csIPXNetBindingKey.GetBuffer( 0 ), KEY_READ ) ;

	// determine if AUTO frame detection is in place
	BOOL t_bAuto = TRUE;
	if( ERROR_SUCCESS == t_lRes )
	{
		CHStringArray	t_chsArray ;

		if( ERROR_SUCCESS == t_oRegIPXNetDriver.GetCurrentKeyValue( TOBSTRT( RVAL_PKT_TYPE ), t_chsArray ) )
		{
			if( t_chsArray.GetSize()  )
			{
				// HEX char to int
				int t_iElement = wcstoul( t_chsArray.GetAt( 0 ), NULL, 16 ) ;

				// the 1st ( and only ) element will be 255 for AUTO
				if( 255 != t_iElement )
				{
					t_bAuto = FALSE;
				}
			}
		}
	}

	// Collect the frame type / net number pairs
	if( !t_bAuto )
	{
		// Frame type
		RegGetHEXtoINTArray( t_oRegIPXNetDriver, RVAL_PKT_TYPE, &t_FrameType  ) ;

		// network number
		RegGetStringArray( t_oRegIPXNetDriver, RVAL_NETWORK_NUMBER, &t_NetNumber, '\n' ) ;
	}
	// supply defaults
	else
	{
		//default frame type
		SAFEARRAYBOUND t_rgsabound[ 1 ] ;
		long t_ix[ 1 ] ;

		t_rgsabound->cElements = 1 ;
		t_rgsabound->lLbound = 0 ;

		if( !( t_FrameType = SafeArrayCreate( VT_I4, 1, t_rgsabound ) ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		t_ix[ 0 ] = 0 ;

		int t_iElement = AUTO ;

		SafeArrayPutElement( t_FrameType, &t_ix[0], &t_iElement ) ;

		// default network number
		if( !( t_NetNumber = SafeArrayCreate( VT_BSTR, 1, t_rgsabound ) ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		CHString t_chsNULL( _T("") ) ;
		bstr_t t_bstrBuf( t_chsNULL ) ;

		SafeArrayPutElement( t_NetNumber, &t_ix[0], (wchar_t*)t_bstrBuf ) ;
	}

	/* update the instance */

	VARIANT t_vValue;

	// frame type
	V_VT( &t_vValue ) = VT_I4 | VT_ARRAY; V_ARRAY( &t_vValue ) = t_FrameType;
	if( !a_pInst->SetVariant( IPX_FRAMETYPE, t_vValue ) )
	{
		return WBEM_E_FAILED;
	}

	// net number
	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_NetNumber;
	if( !a_pInst->SetVariant( IPX_NETNUMBER, t_vValue ) )
	{
		return WBEM_E_FAILED;
	}
	return S_OK;
}
#endif

/*******************************************************************
    NAME:       hSetVirtualNetNum

    SYNOPSIS:   Sets the virtual network number associated with IPX on
				this system

    ENTRY:      CMParms		:

	NOTES:		This is a static, instance independent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetVirtualNetNum( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	// Open IPX parms from the registry
	CHString t_csIPXParmsBindingKey =  SERVICES_HOME ;
			 t_csIPXParmsBindingKey += IPX ;
			 t_csIPXParmsBindingKey += PARAMETERS ;

	// registry open
	CRegistry	t_oRegIPX;
	HRESULT		t_hRes = t_oRegIPX.Open( HKEY_LOCAL_MACHINE, t_csIPXParmsBindingKey.GetBuffer( 0 ), KEY_WRITE  ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return a_rMParms.hSetResult( E_RET_IPX_NOT_ENABLED_ON_ADAPTER  ) ;;
	}

	// extract the virtual network number
	CHString t_chsVirtNetNum ;
	if( !a_rMParms.pInParams()->GetCHString( IPX_VIRTUAL_NET_NUM, t_chsVirtNetNum ) )
	{
		return a_rMParms.hSetResult( E_RET_INVALID_NETNUM  ) ;
	}

    // validate parameter...
    t_chsVirtNetNum.MakeUpper();
    int t_iLen = t_chsVirtNetNum.GetLength();
    if( t_iLen > 8 || t_iLen == 0)
	{
		return a_rMParms.hSetResult(E_RET_INVALID_NETNUM) ;
	}
    int t_iSpan = wcsspn( (LPCWSTR)t_chsVirtNetNum, L"0123456789ABCDEF" ) ;
	if( t_iLen != t_iSpan )
	{
		return a_rMParms.hSetResult(E_RET_INVALID_NETNUM) ;
	}
	// HEX char to int
	DWORD t_dwVirtNetNum = wcstoul( t_chsVirtNetNum, NULL, 16 ) ;

	// update to the registry
	t_oRegIPX.SetCurrentKeyValue( RVAL_VIRTUAL_NET_NUM, t_dwVirtNetNum ) ;


	E_RET t_eRet = E_RET_OK ;

#if NTONLY >= 5
	{
		// pnp notification
		CNdisApi t_oNdisApi ;
		if( !t_oNdisApi.PnpUpdateIpxGlobal() )
		{
			t_eRet = E_RET_OK_REBOOT_REQUIRED ;
		}
	}
#else
	{
		t_eRet = E_RET_OK_REBOOT_REQUIRED ;
	}
#endif

	return a_rMParms.hSetResult( t_eRet ) ;
#endif
}

/*******************************************************************
    NAME:       hSetFrameNetPairs

    SYNOPSIS:   Sets the frame type network number pairs for a specific
				IPX associated adapter

    ENTRY:      CMParms		:

	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetFrameNetPairs( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IPX must be enabled and bound to this adapter
	if( !fIsIPXEnabled( a_rMParms ) )
	{
		return S_OK;
	}

	SAFEARRAY *t_NetNumber	= NULL ;
	saAutoClean acNetNumber( &t_NetNumber ) ;	// stack scope cleanup

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// registry binding
	CHString t_csIPXNetBindingKey ;
	CHString t_chsLink ;
	if( !fGetNtIpxRegAdapterKey( t_dwIndex, t_csIPXNetBindingKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtIpxRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	// registry open
	CRegistry	t_oRegIPXNetDriver;
	HRESULT		t_hRes = t_oRegIPXNetDriver.Open( HKEY_LOCAL_MACHINE, t_csIPXNetBindingKey.GetBuffer( 0 ), KEY_WRITE ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	//	retrieve the frame type array
	VARIANT t_vFrametype;
	VariantInit( &t_vFrametype ) ;

	if( !a_rMParms.pInParams()->GetVariant( IPX_FRAMETYPE, t_vFrametype ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	if( t_vFrametype.vt != (VT_I4 | VT_ARRAY) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	//	And the network number array
	if(	!a_rMParms.pInParams()->GetStringArray( IPX_NETNUMBER, t_NetNumber ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// validate pairs
	BOOL t_fIsAuto ;
	if( !fValidFrameNetPairs( a_rMParms, t_vFrametype.parray, t_NetNumber, &t_fIsAuto ) )
	{
		return S_OK;
	}

	// update the registry
	if( ERROR_SUCCESS != RegPutStringArray( t_oRegIPXNetDriver, RVAL_NETWORK_NUMBER, *t_NetNumber, NULL ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	//maximum length is 3 characters e.g. "FF\0"
	CHString t_chsFormat( _T("%x") ) ;
	if( ERROR_SUCCESS != RegPutINTtoStringArray(	t_oRegIPXNetDriver,
													RVAL_PKT_TYPE,
													t_vFrametype.parray,
													t_chsFormat,
													3 ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE ) ;
	}

	VariantClear( &t_vFrametype ) ;

	E_RET t_eRet = E_RET_OK ;

#if NTONLY >= 5
	{
		// pnp notification
		CNdisApi t_oNdisApi ;
		if( !t_oNdisApi.PnpUpdateIpxAdapter( t_chsLink, t_fIsAuto ) )
		{
			t_eRet = E_RET_OK_REBOOT_REQUIRED ;
		}
	}
#else
	{
		t_eRet = E_RET_OK_REBOOT_REQUIRED ;
	}
#endif

	return a_rMParms.hSetResult( t_eRet ) ;
#endif
}

/*******************************************************************
    NAME:       fValidFrameNetPairs

    SYNOPSIS:   Given an array of frame types and net numbers validate
				the series.

    ENTRY:      CMParms &a_rMParms
				SAFEARRAY *t_FrameType
                SAFEARRAY *t_NetNumber

    HISTORY:
                  25-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fValidFrameNetPairs(	CMParms		&a_rMParms,
														SAFEARRAY	*a_FrameType,
														SAFEARRAY	*a_NetNumber,
														BOOL		*a_fIsAuto )
{
    LONG t_lFrameUBound		= 0;
	LONG t_lNetNumUBound	= 0;
	LONG t_lFrameLBound		= 0;
	LONG t_lNetNumLBound	= 0;
    BOOL t_fRet = TRUE;

	if( 1 != SafeArrayGetDim( a_FrameType ) ||
		1 != SafeArrayGetDim( a_NetNumber ))
	{
		a_rMParms.hSetResult( E_RET_FRAME_NETNUM_BOUNDS_ERR ) ;
        t_fRet = FALSE;
	}

    if(t_fRet)
    {
	    // one frame for each net number, minimum of 1 pair
	    if( S_OK != SafeArrayGetLBound( a_NetNumber, 1, &t_lNetNumLBound )	||
	        S_OK != SafeArrayGetUBound( a_NetNumber, 1, &t_lNetNumUBound )	||

		    S_OK != SafeArrayGetLBound( a_FrameType, 1, &t_lFrameLBound )		||
		    S_OK != SafeArrayGetUBound( a_FrameType, 1, &t_lFrameUBound )		||

		    ( t_lFrameUBound - t_lFrameLBound ) != ( t_lNetNumUBound - t_lNetNumLBound ) )
	    {
		    a_rMParms.hSetResult( E_RET_FRAME_NETNUM_BOUNDS_ERR ) ;
		    t_fRet = FALSE ;
	    }
    }

	// more that 4 entries?
    if(t_fRet)
    {
	    if( 4 <= (t_lFrameUBound - t_lFrameLBound) )
	    {
		    a_rMParms.hSetResult( E_RET_FRAME_NETNUM_BOUNDS_ERR ) ;
		    t_fRet = FALSE;
	    }
    }

	*a_fIsAuto = FALSE ;

	// loop through all the frame pairs testing for uniqueness
	// and validity
	for( LONG t_lOuter = t_lNetNumLBound; t_lOuter <= t_lNetNumUBound && t_fRet; t_lOuter++ )
	{
		BSTR t_bstr = NULL ;

		SafeArrayGetElement( a_NetNumber, &t_lOuter, &t_bstr ) ;

		bstr_t t_bstrNetNum( t_bstr, FALSE );

		// Network number test
		int t_iLen  = t_bstrNetNum.length( ) ;
		int t_iSpan = wcsspn( (wchar_t*)t_bstrNetNum, L"0123456789" ) ;
		if( t_iLen != t_iSpan )
		{
			a_rMParms.hSetResult( E_RET_INVALID_NETNUM ) ;
			t_fRet = FALSE ;
		}

        if(t_fRet)
        {
            // Check that the network number is
            // less than or equal to 4294967295
            // (0xFFFFFFFF)...
            if(((LPCWSTR)t_bstrNetNum != NULL) &&
                (wcslen(t_bstrNetNum) <= 10))
            {
                // Using i64 here should prevent any
                // overflow problems, as the check for
                // ten or fewer digits will catch us
                // well before that point...
                __int64 t_i64Tmp = _wtoi64(t_bstrNetNum);
                if(t_i64Tmp > 4294967295)
                {
			        a_rMParms.hSetResult( E_RET_INVALID_NETNUM ) ;
			        t_fRet = FALSE ;
                }
            }
            else
            {
			    a_rMParms.hSetResult( E_RET_INVALID_NETNUM ) ;
			    t_fRet = FALSE ;
            }
        }
        
        if(t_fRet)
        {
		    int		t_iFrameType;
		    LONG	t_lFrameIndex = t_lFrameLBound + ( t_lOuter - t_lNetNumLBound ) ;

		    SafeArrayGetElement( a_FrameType, &t_lFrameIndex, &t_iFrameType ) ;

		    // frame type test
		    if( ( 0 > t_iFrameType ) || ( 3 < t_iFrameType ) )
		    {
			    if( 255 == t_iFrameType )
			    {	//AUTO

				    // clear net number on AUTO detect
				    CHString t_chsZERO( _T("0") ) ;
				    bstr_t t_bstrBuf( t_chsZERO ) ;

				    SafeArrayPutElement( a_NetNumber, &t_lOuter, (wchar_t*)t_bstrBuf ) ;

				    *a_fIsAuto = TRUE ;
			    }
			    else
			    {
				    a_rMParms.hSetResult( E_RET_INVALID_FRAMETYPE ) ;
				    t_fRet = FALSE ;
			    }
		    }

		    // scan for duplicate network numbers
		    for( LONG t_lInner = t_lOuter + 1; t_lInner <= t_lNetNumUBound && t_fRet; t_lInner++ )
		    {
			    BSTR t_bstrtest = NULL ;

			    SafeArrayGetElement( a_NetNumber, &t_lInner, &t_bstrtest ) ;

			    bstr_t t_bstrIPtest( t_bstrtest, FALSE ) ;

			    // duplicate IP test
			    if( t_bstrNetNum == t_bstrIPtest )
			    {
				    a_rMParms.hSetResult( E_RET_DUPLICATE_NETNUM ) ;
				    t_fRet = FALSE ;
			    }
		    }
        }
    }
	return t_fRet ;
}


/*******************************************************************
    NAME:       eIsValidIPandSubnets

    SYNOPSIS:   Given an array of IP addresses and subnet masks, return a boolean
                to indicate whether the addresses are valid or not.

    ENTRY:      SAFEARRAY *t_IpAddressArray - IP addresses
                SAFEARRAY *t_IpMaskArray - Subnet Masks

    HISTORY:
                  19-Jul-1998     Created
********************************************************************/

E_RET CWin32NetworkAdapterConfig::eIsValidIPandSubnets( SAFEARRAY *a_IpAddressArray, SAFEARRAY *a_IpMaskArray )
{
    LONG t_lIP_UBound		= 0;
	LONG t_lMask_UBound		= 0;
	LONG t_lIP_LBound		= 0;
	LONG t_lMask_LBound		= 0;

	if( 1 != SafeArrayGetDim( a_IpAddressArray ) ||
		1 != SafeArrayGetDim( a_IpMaskArray ) )
	{
		return E_RET_INPARM_FAILURE ;
	}

	// get the array bounds
	if( S_OK != SafeArrayGetLBound( a_IpAddressArray, 1, &t_lIP_LBound )	||
		S_OK != SafeArrayGetUBound( a_IpAddressArray, 1, &t_lIP_UBound )	||

	    S_OK != SafeArrayGetLBound( a_IpMaskArray, 1, &t_lMask_LBound )	||
		S_OK != SafeArrayGetUBound( a_IpMaskArray, 1, &t_lMask_UBound ) )
	{
		return E_RET_PARAMETER_BOUNDS_ERROR ;
	}

	LONG t_lIPLen	= t_lIP_UBound - t_lIP_LBound + 1 ;
	LONG t_lMasklen	= t_lMask_UBound - t_lMask_LBound + 1 ;

	// one ip for each mask, minimum of 1 pair
	if( ( t_lIPLen != t_lMasklen ) || !t_lIPLen )
	{
		return E_RET_PARAMETER_BOUNDS_ERROR;
	}

	// loop through all IPs testing for uniqueness
	// and validity against its associated mask
	for( LONG t_lOuter = t_lIP_LBound; t_lOuter <= t_lIP_UBound; t_lOuter++ )
	{
		// collect up a str version of the the IP and Mask @ the lOuter element
		BSTR t_bsIP		= NULL ;
		BSTR t_bsMask	= NULL ;

		SafeArrayGetElement( a_IpAddressArray, &t_lOuter, &t_bsIP ) ;
		bstr_t t_bstrIP( t_bsIP, FALSE ) ;

		LONG t_lMaskIndex = t_lMask_LBound + ( t_lOuter - t_lIP_LBound ) ;

		SafeArrayGetElement( a_IpMaskArray,	&t_lMaskIndex, &t_bsMask ) ;
		bstr_t t_bstrMask( t_bsMask, FALSE ) ;

		// break the IP and Mask into 4 DWORDs
		DWORD t_ardwIP[ 4 ] ;
		if( !fGetNodeNum( CHString( (wchar_t*) t_bstrIP ), t_ardwIP ) )
		{
			return E_RET_IP_INVALID ;
		}

		DWORD t_ardwMask[ 4 ] ;
		if( !fGetNodeNum( CHString( (wchar_t*) t_bstrMask ), t_ardwMask ) )
		{
			return E_RET_IP_MASK_FAILURE ;
		}

		// IP, Mask validity
		E_RET t_eRet ;
		if( t_eRet = eIsValidIPandSubnet( t_ardwIP, t_ardwMask ) )
		{
			return t_eRet ;
		}

		// IP uniqueness across all IPs associated with this adapter
		for( LONG t_lInner = t_lOuter + 1; t_lInner <= t_lIP_UBound; t_lInner++ )
		{
			if( t_lInner > t_lOuter )
			{
				BSTR t_bstrtest = NULL ;

				SafeArrayGetElement( a_IpAddressArray,	&t_lInner, &t_bstrtest  ) ;
				bstr_t t_bstrIPtest( t_bstrtest, FALSE ) ;

				DWORD t_ardwIPtest[ 4 ] ;
				if( !fGetNodeNum( CHString( (wchar_t*) t_bstrIPtest ), t_ardwIPtest ) )
				{
					return E_RET_IP_INVALID ;
				}

				// duplicate IP test
				if( t_ardwIP[ 0 ] == t_ardwIPtest[ 0 ] &&
					t_ardwIP[ 1 ] == t_ardwIPtest[ 1 ] &&
					t_ardwIP[ 2 ] == t_ardwIPtest[ 2 ] &&
					t_ardwIP[ 3 ] == t_ardwIPtest[ 3 ] )
				{
					return E_RET_IP_INVALID ;
				}
			}
		}
	}
	return E_RET_OK ;
}

/*******************************************************************
    NAME:       fGetNodeNum

    SYNOPSIS:   Get an IP Address and return the 4 numbers in the IP address.

    ENTRY:      CHString & strIP - IP Address
                DWORD *dw1, *dw2, *dw3, *dw4 - the 4 numbers in the IP Address

    HISTORY:
                  19-Jul-1998     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fGetNodeNum( CHString &a_strIP, DWORD a_ardw[ 4 ] )
{
    TCHAR	t_DOT = '.' ;
	int		t_iOffSet = 0 ;
	int		t_iTokLen ;

	// string validatation
	if( a_strIP.IsEmpty() )
	{
		return FALSE;
	}

	int t_iLen  = a_strIP.GetLength( ) ;
	int t_iSpan = wcsspn(a_strIP, L"0123456789." ) ;

	if( t_iLen != t_iSpan )
	{
		return FALSE;
	}

	if( t_iLen > MAX_IP_SIZE - 1 )
	{
		return FALSE;
	}

    // Go through each node and get the number value
    for( int t_i = 0; t_i < 4; t_i++ )
	{
		CHString t_strTok( a_strIP.Mid( t_iOffSet ) ) ;

		if( 255 < ( a_ardw[ t_i ] = _wtol( t_strTok ) ) )
		{
			return FALSE;
		}

		t_iTokLen = t_strTok.Find( t_DOT ) ;

		// breakout to avoid the last loop test
		if( 3 == t_i )
		{
			break;
		}

		// too few nodes
		if( -1 == t_iTokLen )
		{
			return FALSE ;
		}

		t_iOffSet += t_iTokLen + 1 ;
	}

	if(-1 != t_iTokLen )
	{
		return FALSE;	// to many nodes
	}
	else
	{
		return TRUE ;
	}
}

/*******************************************************************
    NAME:       eIsValidIPandSubnet

    SYNOPSIS:   Given an IP address and subnet mask, return a boolean
                to indicate whether the addresses are valid or not.

    ENTRY:      DWORD[4] ardwIP - IP addresses
                DWORD[4] ardwMask - Subnet Mask

    HISTORY:
                  19-Jul-1998     Created
********************************************************************/

E_RET CWin32NetworkAdapterConfig::eIsValidIPandSubnet( DWORD a_ardwIP[ 4 ], DWORD a_ardwMask[ 4 ] )
{
    BOOL	t_fReturn = TRUE;

   	// test for contiguous mask
	{
		DWORD t_dwMask = (a_ardwMask[0] << 24) +
						 (a_ardwMask[1] << 16) +
						 (a_ardwMask[2] << 8)  +
						 a_ardwMask[3] ;

		// test for all Net but no Host
		if( 0xffffffff == t_dwMask )
		{
			return E_RET_IP_MASK_FAILURE ;
		}
		// test for all Host but no Net
		else if( 0x00 == t_dwMask )
		{
			return E_RET_IP_MASK_FAILURE ;
		}

		DWORD t_i, t_dwContiguousMask;

		// Find out where the first '1' is in binary going right to left
		t_dwContiguousMask = 0;
		for ( t_i = 0; t_i < sizeof( t_dwMask ) * 8; t_i++ )
		{
			t_dwContiguousMask |= 1 << t_i;

			if( t_dwContiguousMask & t_dwMask )
			{
				break ;
			}
		}

		// At this point, dwContiguousMask is 000...0111...  If we inverse it,
		// we get a mask that can be or'd with dwMask to fill in all of
		// the holes.
		t_dwContiguousMask = t_dwMask | ~t_dwContiguousMask ;

		// If the new mask is different, note it here
		if( t_dwMask != t_dwContiguousMask )
		{
			return E_RET_IP_MASK_FAILURE ;
		}
	}

	DWORD	t_ardwNetID[ 4 ] ;

    INT t_nFirstByte = a_ardwIP[ 0 ] & 0xFF ;

    // setup Net ID
    t_ardwNetID[ 0 ] = a_ardwIP[ 0 ] & a_ardwMask[ 0 ] & 0xFF ;
    t_ardwNetID[ 1 ] = a_ardwIP[ 1 ] & a_ardwMask[ 1 ] & 0xFF ;
    t_ardwNetID[ 2 ] = a_ardwIP[ 2 ] & a_ardwMask[ 2 ] & 0xFF ;
    t_ardwNetID[ 3 ] = a_ardwIP[ 3 ] & a_ardwMask[ 3 ] & 0xFF ;

    // setup Host ID
    DWORD t_ardwHostID[ 4 ] ;

    t_ardwHostID[ 0 ] = a_ardwIP[ 0 ] & ( ~( a_ardwMask[ 0 ] ) & 0xFF ) ;
    t_ardwHostID[ 1 ] = a_ardwIP[ 1 ] & ( ~( a_ardwMask[ 1 ] ) & 0xFF ) ;
    t_ardwHostID[ 2 ] = a_ardwIP[ 2 ] & ( ~( a_ardwMask[ 2 ] ) & 0xFF ) ;
    t_ardwHostID[ 3 ] = a_ardwIP[ 3 ] & ( ~( a_ardwMask[ 3 ] ) & 0xFF ) ;

    // check each case
    if ( ( ( t_nFirstByte & 0xF0 ) == 0xE0 )  || /* Class D */
         ( ( t_nFirstByte & 0xF0 ) == 0xF0 )  || /* Class E */
           ( t_ardwNetID[ 0 ] == 127 ) ||           /* NetID cannot be 127...*/
         ( ( t_ardwNetID[ 0 ] == 0 ) &&            /* netid cannot be 0.0.0.0 */
           ( t_ardwNetID[ 1 ] == 0 ) &&
           ( t_ardwNetID[ 2 ] == 0 ) &&
           ( t_ardwNetID[ 3 ] == 0 )) ||

		  /* netid cannot be equal to sub-net mask */
         ( ( t_ardwNetID[0] == a_ardwMask[ 0 ] ) &&
           ( t_ardwNetID[1] == a_ardwMask[ 1 ] ) &&
           ( t_ardwNetID[2] == a_ardwMask[ 2 ] ) &&
           ( t_ardwNetID[3] == a_ardwMask[ 3 ] )) ||

		  /* hostid cannot be 0.0.0.0 */
         ( ( t_ardwHostID[ 0 ] == 0 ) &&
           ( t_ardwHostID[ 1 ] == 0 ) &&
           ( t_ardwHostID[ 2 ] == 0 ) &&
           ( t_ardwHostID[ 3 ] == 0 ) ) ||

		  /* hostid cannot be 255.255.255.255 */
         ( ( t_ardwHostID[0] == 0xFF ) &&
           ( t_ardwHostID[1] == 0xFF ) &&
           ( t_ardwHostID[2] == 0xFF ) &&
           ( t_ardwHostID[3] == 0xFF ) ) ||

		  /* test for all 255 */
         ( ( a_ardwIP[ 0 ] == 0xFF ) &&
           ( a_ardwIP[ 1 ] == 0xFF ) &&
           ( a_ardwIP[ 2 ] == 0xFF ) &&
           ( a_ardwIP[ 3 ] == 0xFF ) ) )
    {
        return E_RET_IP_INVALID ;
    }

    return E_RET_OK ;
}

/*******************************************************************
    NAME:       fBuildIP

    SYNOPSIS:   Build a valid IP Address from DWORD[4] array

    ENTRY:      DWORD *dw1, *dw2, *dw3, *dw4 - the 4 numbers of the IP Address
				CHString & a_strIP - new IP Address
    HISTORY:
                  31-Jul-1998     Created
********************************************************************/

void CWin32NetworkAdapterConfig::vBuildIP( DWORD a_ardwIP[ 4 ], CHString &a_strIP )
{
	a_strIP.Format(L"%u.%u.%u.%u", a_ardwIP[ 0 ], a_ardwIP[ 1 ], a_ardwIP[ 2 ], a_ardwIP[ 3 ] ) ;
}

/*******************************************************************
    NAME:       hEnableDHCP

    SYNOPSIS:   Enables all DHCP settings supplied supplied with
				the framework method call

    ENTRY:      CMParms, framework return class

  	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableDHCP( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY
	DWORD t_dwError;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK;
	}

#if NTONLY < 5
	// If there is a client TCP/IP service is setup for auto start
	t_dwError = dwEnableService( _T("TCPIPSYS"), TRUE  ) ;

	if( ERROR_SUCCESS != t_dwError &&
		ERROR_SERVICE_DOES_NOT_EXIST != t_dwError )
	{
		return a_rMParms.hSetResult( E_RET_UNABLE_TO_CONFIG_TCPIP_SERVICE  ) ;
	}
#endif

	// same for DHCP
	t_dwError = dwEnableService( _T("DHCP"), TRUE  ) ;

	if( ERROR_SUCCESS != t_dwError &&
		ERROR_SERVICE_DOES_NOT_EXIST != t_dwError )
	{
        LogErrorMessage2(L"Unable to configure DHCP svc : 0x%x\n", t_dwError);
		return a_rMParms.hSetResult( E_RET_UNABLE_TO_CONFIG_DHCP_SERVICE ) ;
	}

    //call the function to reset to dhcp
    HRESULT t_hReturn =  hConfigDHCP( a_rMParms ) ;

    if (SUCCEEDED(t_hReturn))
    {
        // reset gateways to the default(bug 128101)
        if (!ResetGateways(a_rMParms.pInst()))
        {
            //is now dhcp with old gateways set i.e. possibly not the default for dhcp
            return a_rMParms.hSetResult( E_RET_PARTIAL_COMPLETION ) ;
        }
    }

    return t_hReturn ;
#endif
}

/*******************************************************************
    NAME:       hEnableStatic

    SYNOPSIS:

    ENTRY:      CMParms, framework return class

	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableStatic( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY

	SAFEARRAY *t_IpAddressArray = NULL ;
	SAFEARRAY *t_IpMaskArray	= NULL ;
    DWORD t_dwError;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acIPAddrs( &t_IpAddressArray ) ;
	saAutoClean acMasks( &t_IpMaskArray ) ;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	//	retrieve the IP arrays
	if(	!a_rMParms.pInParams()->GetStringArray( _T("IpAddress"), t_IpAddressArray ) ||
		!a_rMParms.pInParams()->GetStringArray( _T("SubnetMask"), t_IpMaskArray ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// validate IPs
	// validate addresses...
	E_RET t_eRet ;
	if( t_eRet = eIsValidIPandSubnets( t_IpAddressArray, t_IpMaskArray ) )
	{
		return a_rMParms.hSetResult( t_eRet ) ;
	}

#if NTONLY < 5
	// Autostart TCP/IP service. if there is a client version installed
	t_dwError = dwEnableService( _T("TCPIPSYS"), TRUE  ) ;

	if( ERROR_SUCCESS != t_dwError &&
		ERROR_SERVICE_DOES_NOT_EXIST != t_dwError )
	{
		return a_rMParms.hSetResult( E_RET_UNABLE_TO_CONFIG_TCPIP_SERVICE ) ;
	}
#endif

/* TODO: test for disable service
	loop through all adapters and if not DHCP enabled, disable service


	// disable  DHCP service
	if( ERROR_SERVICE_DOES_NOT_EXIST != dwEnableService( _T("DHCP"), FALSE ) )
		return a_rMParms.hSetResult( E_RET_UNABLE_TO_CONFIG_DHCP_SERVICE ) ;
	*/

	return hConfigDHCP( a_rMParms, t_IpAddressArray, t_IpMaskArray ) ;
#endif
}

/*******************************************************************
    NAME:       hConfigDHCP

    SYNOPSIS:	configures DHCP for service on this adapter or if an IP array
				is supplied configures for static addressing

    ENTRY:      CMParms &a_rMParms,					:
				SAFEARRAY * t_IpArray = NULL,		: static if supplied
				SAFEARRAY * t_MaskArray = NULL		: required for static addressing

    HISTORY:
                  23-Jul-1998     Created
				  02-May-1999     updated support for W2k
********************************************************************/

#if NTONLY >= 5
HRESULT CWin32NetworkAdapterConfig::hConfigDHCP(	CMParms &a_rMParms,
													SAFEARRAY *a_IpArray,
													SAFEARRAY *a_MaskArray )
{
	DWORD t_dwError = 0 ;

	// get the current DHCP enabled setting
	bool t_fDHCPCurrentlyActive = false ;
	if(	!a_rMParms.pInst()->Getbool( L"DHCPEnabled", t_fDHCPCurrentlyActive) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// retrieve the adapter identifier
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	// force wide char
	bstr_t t_bstrAdapter( t_chsLink ) ;

	// open the registry for update
	CRegistry	t_oRegistry ;

	HRESULT t_hRes = t_oRegistry.CreateOpen(HKEY_LOCAL_MACHINE, t_chsRegKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER ;
	}

	// DHCP and registry update
	DWORD t_dwSysError		= S_OK ;
	E_RET t_eMethodError	= E_RET_OK ;


    CDhcpcsvcApi *t_pdhcpcsvc = (CDhcpcsvcApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidDhcpcsvcApi, NULL ) ;

	if( !t_pdhcpcsvc )
	{
		throw ;
	}

	if( t_pdhcpcsvc != NULL )
    {
		// Static
		if( a_IpArray )
		{
			int i = 0 ;
			CHStringArray		t_RegIPList ;
			CHStringArray		t_RegMaskList ;

			CDhcpIP_InstructionList t_IP_InstList ;

			// Generate an IP instruction list to feed DhcpNotifyConfigChange
			if( E_RET_OK == (t_eMethodError = t_IP_InstList.BuildStaticIPInstructionList(
											a_rMParms,
											a_IpArray,
											a_MaskArray,
											t_oRegistry,
											t_fDHCPCurrentlyActive ) ) )
			{
				DWORD	t_dwIP[ 4 ] ;
                // We need to first update the registry, then update DHCP, because
                // with Whistler, DHCP now manages static ips as well as dynamic
                // ones, and in doing so, checks the registry for the set of
                // ips to modify.
                
                // Build up registry array...
                for( i = 0; i < t_IP_InstList.GetSize(); i++ )
				{
					CDhcpIP_Instruction *t_pInstruction = (CDhcpIP_Instruction *)t_IP_InstList.GetAt( i ) ;

					fGetNodeNum( t_pInstruction->chsIPAddress, t_dwIP ) ;
				    DWORD t_dwNewIP = ConvertIPDword( t_dwIP ) ;

					fGetNodeNum( t_pInstruction->chsIPMask, t_dwIP ) ;
				    DWORD t_dwNewMask = ConvertIPDword( t_dwIP ) ;
					
					// add to our registry list as we go
					if( t_dwNewIP )
					{
						t_RegIPList.Add( t_pInstruction->chsIPAddress ) ;
						t_RegMaskList.Add( t_pInstruction->chsIPMask ) ;
					}
				}
                
                // update the registry...
                // update successful additions/changes only
			    if( ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( _T("IpAddress"), t_RegIPList ) ||
				    ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( _T("SubnetMask"), t_RegMaskList ) )
			    {
				    t_eMethodError = E_RET_REGISTRY_FAILURE ;
			    }

			    // new adapter DHCP state
			    DWORD t_dwFALSE = FALSE ;
			    if( ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"EnableDHCP", t_dwFALSE ) )
			    {
				    t_eMethodError = E_RET_REGISTRY_FAILURE ;
			    }


                // Now notify dhcp...
				for( i = 0; i < t_IP_InstList.GetSize(); i++ )
				{
					CDhcpIP_Instruction *t_pInstruction = (CDhcpIP_Instruction *)t_IP_InstList.GetAt( i ) ;

					fGetNodeNum( t_pInstruction->chsIPAddress, t_dwIP ) ;
				    DWORD t_dwNewIP = ConvertIPDword( t_dwIP ) ;

					fGetNodeNum( t_pInstruction->chsIPMask, t_dwIP ) ;
				    DWORD t_dwNewMask = ConvertIPDword( t_dwIP ) ;

					if( t_pInstruction->bIsNewAddress )
					{
						// notify DHCP
						DWORD t_dwDHCPError = t_pdhcpcsvc->DhcpNotifyConfigChange(
												NULL,
												(wchar_t*)t_bstrAdapter,
												t_pInstruction->bIsNewAddress,
												t_pInstruction->dwIndex,
												t_dwNewIP,
												t_dwNewMask,
												t_pInstruction->eDhcpFlag ) ;
						// if for some reason t_pInstruction->bIsNewAddress is true, 
                        // but dhcp doesn't think so, we'll get this error; however, 
                        // we don't care about it.
                        if( t_dwDHCPError  && 
                            t_dwDHCPError != STATUS_DUPLICATE_OBJECTID)  
						{
							t_dwError = t_dwDHCPError;

							// bypass registry update for this failed
							// IP modification
							continue;
						}
					}
				}
			}

			// we have to post back to the NT4 registry area
			// in order to keep existing apps in the field running
			if( IsWinNT5() )
			{
				CRegistry	t_oNT4Reg ;
				CHString	t_csBindingKey = SERVICES_HOME ;
							t_csBindingKey += _T("\\" ) ;
							t_csBindingKey += t_chsLink ;
							t_csBindingKey += PARAMETERS_TCPIP ;

				// insure the key is there on open
				HRESULT t_hRes = t_oNT4Reg.CreateOpen( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ) ) ;
				if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
				{
					return TO_CALLER;
				}

				// update successful additions/changes only
				if( ERROR_SUCCESS != t_oNT4Reg.SetCurrentKeyValue( _T("IpAddress"), t_RegIPList ) ||
					ERROR_SUCCESS != t_oNT4Reg.SetCurrentKeyValue( _T("SubnetMask"), t_RegMaskList ) )
				{
					t_eMethodError = E_RET_REGISTRY_FAILURE ;
				}

				// new adapter DHCP state
				DWORD t_dwFALSE = FALSE ;
				if( ERROR_SUCCESS != t_oNT4Reg.SetCurrentKeyValue( L"EnableDHCP", t_dwFALSE ) )
				{
					t_eMethodError = E_RET_REGISTRY_FAILURE ;
				}
			}
		}

		/* Static -> DHCP */
		else if( !t_fDHCPCurrentlyActive && !a_IpArray )
		{
			// update registry
			CHStringArray t_chsaZERO ;
			CHStringArray t_chsaFF ;

			CHString t_chsZERO( ZERO_ADDRESS ) ;
			CHString t_chsFF( FF_ADDRESS ) ;

			t_chsaZERO.Add( t_chsZERO ) ;
			t_chsaFF.Add( t_chsFF ) ;

			if( ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"IpAddress", t_chsaZERO )	||
				ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"SubnetMask", t_chsaFF )	||
				ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"DhcpIPAddress", t_chsZERO )	||
				ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"DhcpSubnetMask", t_chsFF ) )
			{
				t_eMethodError = E_RET_REGISTRY_FAILURE ;
			}
			else
			{
				// notify DHCP
				if( !(t_dwError = t_pdhcpcsvc->DhcpNotifyConfigChange(	NULL,
																	(wchar_t*) t_bstrAdapter,
																	FALSE,
																	0,
																	0,
																	0,
																	DhcpEnable ) )  )
				{

					// new adapter DHCP state
					DWORD t_dwTRUE = TRUE ;
					if( ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"EnableDHCP", t_dwTRUE ) )
					{
						t_eMethodError = E_RET_REGISTRY_FAILURE ;
					}
				}
			}
		}


        CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidDhcpcsvcApi, t_pdhcpcsvc ) ;
        t_pdhcpcsvc = NULL;
    }

	// map any error
	if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_CONFIG_DHCP_SERVICE ) )
	{
        LogErrorMessage2(L"Unable to configure DHCP svc : 0x%x\n", t_dwError);
		return TO_CALLER ;
	}

	//
	if( E_RET_OK == t_eMethodError )
	{
		// if DHCP -> Static
		if( a_IpArray && t_fDHCPCurrentlyActive )
		{
			// switch to Netbios over TCP if NetBios was enabled via DHCP
			// ( to be consistant with NT Raid 206974 )
			DWORD t_dwNetBiosOptions ;
			if( a_rMParms.pInst()->GetDWORD( TCPIP_NETBIOS_OPTIONS,
									t_dwNetBiosOptions ) )
			{
				if( UNSET_Netbios == t_dwNetBiosOptions )
				{
					t_eMethodError = eSetNetBiosOptions( ENABLE_Netbios, t_dwIndex ) ;
				}
			}
		}

		// DNS notification
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}

	return a_rMParms.hSetResult( t_eMethodError ) ;

}
#endif

// non NT5 version
#if NTONLY == 4
HRESULT CWin32NetworkAdapterConfig::hConfigDHCP(	CMParms &a_rMParms,
													SAFEARRAY *a_IpArray,
													SAFEARRAY *a_MaskArray )
{
	DWORD			t_dwError = 0 ;
	SERVICE_ENABLE	t_seDhcpServiceAction ;

	// get the current DHCP enabled sttting
	bool t_fDHCPCurrentlyActive = false ;
	if(	!a_rMParms.pInst()->Getbool( L"DHCPEnabled", t_fDHCPCurrentlyActive) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// retrieve the adapter identifier
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	// force wide char
	bstr_t t_bstrAdapter( t_chsLink ) ;

	// open the registry for update
	CRegistry	t_oRegistry ;

	HRESULT t_hRes = t_oRegistry.CreateOpen(HKEY_LOCAL_MACHINE, t_chsRegKey.GetBuffer( 0 ) ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER ;
	}

	// DHCP and registry update
	DWORD t_dwSysError		= S_OK ;
	E_RET t_eMethodError	= E_RET_OK ;

    CDhcpcsvcApi *t_pdhcpcsvc = (CDhcpcsvcApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidDhcpcsvcApi, NULL ) ;

	if( !t_pdhcpcsvc )
	{
		throw ;
	}

	if( t_pdhcpcsvc != NULL )
    {
	    do	//breakout loop
	    {
		    // new adapter DHCP state
		    DWORD t_dwTRUE = a_IpArray ? FALSE : TRUE ;
		    if( ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"EnableDHCP", t_dwTRUE ) )
		    {
			    t_eMethodError = E_RET_REGISTRY_FAILURE ;
			    break ;
		    }

		    // if DHCP is not currently activated for this adapter
		    // clear out the old static IP/mask entries that DHCP knows about
		    if( !t_fDHCPCurrentlyActive )
		    {
			    CHStringArray t_chsIPAddresses ;
			    t_oRegistry.GetCurrentKeyValue( L"IPAddress", t_chsIPAddresses ) ;
			    DWORD t_dwSize = t_chsIPAddresses.GetSize( ) ;

			    // clear old IP / subnetmask entries from DHCP
			    for( DWORD t_dwIndex = 0; t_dwIndex < t_dwSize; t_dwIndex++ )
			    {
				    if( t_dwError = t_pdhcpcsvc->DhcpNotifyConfigChange(	NULL,
																			(wchar_t*)t_bstrAdapter,
																			TRUE,
																			t_dwIndex,
																			0L,				// clear IP
																			0xff000000,		// class A mask
																			IgnoreFlag ) ) break;
			    }
			    if( t_dwError )
				{
					break;
				}
		    }

		    /* Update */
		    if( !a_IpArray )	// request DHCP activatation
		    {
			    // if not currently active
			    if( !t_fDHCPCurrentlyActive )
			    {
				    // update registry
				    CHStringArray t_chsaZERO ;
				    CHStringArray t_chsaFF ;

				    CHString t_chsZERO( ZERO_ADDRESS ) ;
				    CHString t_chsFF( FF_ADDRESS ) ;

				    t_chsaZERO.Add( t_chsZERO ) ;
				    t_chsaFF.Add( t_chsFF ) ;

				    if( ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"IpAddress", t_chsaZERO )	||
					    ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"SubnetMask", t_chsaFF )	||
					    ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"DhcpIPAddress", t_chsZERO )	||
					    ERROR_SUCCESS != t_oRegistry.SetCurrentKeyValue( L"DhcpSubnetMask", t_chsFF ) )
				    {
					    t_eMethodError = E_RET_REGISTRY_FAILURE ;
					    break ;
				    }

				    // notify DHCP
				    if( t_dwError = t_pdhcpcsvc->DhcpNotifyConfigChange(	NULL,
																		(wchar_t*) t_bstrAdapter,
																		FALSE,
																		0,
																		0,
																		0,
																		DhcpEnable ) )
					{
					    break;
					}
			    }// else no-op
		    }
		    else	// if t_IpArray != NULL static addressing is assumed
		    {
			    // update registry
			    if( ERROR_SUCCESS != RegPutStringArray( t_oRegistry, _T("IpAddress") , *a_IpArray, NULL ) ||
				    ERROR_SUCCESS != RegPutStringArray( t_oRegistry, _T("SubnetMask") , *a_MaskArray, NULL ) )
			    {
				    t_eMethodError = E_RET_REGISTRY_FAILURE ;
				    break ;
			    }

			    // clean out the DHCP registry entries
			    fCleanDhcpReg( t_chsLink ) ;

			    // add in the new DHCP static entries
			    LONG t_lIpLbound = 0;
			    LONG t_lIpUbound = 0;
			    if( S_OK != SafeArrayGetLBound( a_IpArray, 1, &t_lIpLbound ) ||
				    S_OK != SafeArrayGetUBound( a_IpArray, 1, &t_lIpUbound ) )
			    {
				    t_eMethodError = E_RET_INPARM_FAILURE ;
				    break ;
			    }

			    // initial action for DHCP
			    if( t_fDHCPCurrentlyActive )
				{
				    t_seDhcpServiceAction = DhcpDisable ;
				}
				else
				{
				    t_seDhcpServiceAction = IgnoreFlag ;
				}

			    DWORD t_dwIndex = 0 ;
			    for( LONG t_lIndex = t_lIpLbound; t_lIndex <= t_lIpUbound; t_lIndex++ )
			    {
				    BSTR	t_bsIP		= NULL ;
					BSTR	t_bsMask	= NULL ;
				    DWORD	t_dwIP[ 4 ] ;

				    // new IP
				    SafeArrayGetElement( a_IpArray,	&t_lIndex, &t_bsIP ) ;
				   	bstr_t	t_bstrIP( t_bsIP, FALSE ) ;

				    fGetNodeNum( CHString( (wchar_t*) t_bstrIP ), t_dwIP ) ;
				    DWORD t_dwNewIP = ConvertIPDword( t_dwIP ) ;

				    // new mask
				    SafeArrayGetElement( a_MaskArray, &t_lIndex, &t_bsMask ) ;
				  	bstr_t	t_bstrMask( t_bsMask, FALSE ) ;

				    fGetNodeNum( CHString( (wchar_t*) t_bstrMask ), t_dwIP ) ;
				    DWORD t_dwNewMask = ConvertIPDword( t_dwIP ) ;

				    // notify DHCP
				    if( t_dwError = t_pdhcpcsvc->DhcpNotifyConfigChange(	NULL,
																			(wchar_t*)t_bstrAdapter,
																			TRUE,
																			t_dwIndex,
																			t_dwNewIP,
																			t_dwNewMask,
																			t_seDhcpServiceAction ) )
				    {
						break;
					}

				    t_seDhcpServiceAction = IgnoreFlag ;
				    t_dwIndex++ ;
			    }
			    if( t_dwError )
				{
				    break ;
				}
		    }
	    }	while( FALSE ) ;

         CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidDhcpcsvcApi, t_pdhcpcsvc ) ;
        t_pdhcpcsvc = NULL;
    }

	// map any error

	if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_CONFIG_DHCP_SERVICE ) )
	{
        LogErrorMessage2(L"Unable to configure DHCP svc : 0x%x\n", t_dwError);
		return TO_CALLER ;
	}
	return a_rMParms.hSetResult( t_eMethodError ) ;
}
#endif
/*******************************************************************
    NAME:       fCleanDhcpReg

    SYNOPSIS:	cleans out the DHCP registry entries no longer needed
				when enabling for static addressing

    ENTRY:      CHString& ServiceName

    HISTORY:
                  13-Oct-1998     Created
********************************************************************/
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::fCleanDhcpReg( CHString &t_chsLink )
{
	// open the registry for update
	CRegistry	t_oReg,
				t_RegOptionPath ;
	CHString	t_csOptKey ;
	CHString	t_csKey =  SERVICES_HOME ;
				t_csKey += DHCP ;
				t_csKey += PARAMETERS ;
				t_csKey += OPTIONS ;

	if( ERROR_SUCCESS == t_oReg.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_csKey, KEY_READ ) )
	{
		// Walk through each instance under this key.
		while (	( ERROR_SUCCESS == t_oReg.GetCurrentSubKeyPath( t_csOptKey )))
		{
			CHString t_chsLocation ;
			if( ERROR_SUCCESS ==
				t_RegOptionPath.OpenLocalMachineKeyAndReadValue( t_csOptKey, L"RegLocation", t_chsLocation ) )
			{
				int t_iToklen = t_chsLocation.Find('?' ) ;

				if( -1 != t_iToklen )
				{
					CHString t_chsDelLocation;
							 t_chsDelLocation  = t_chsLocation.Left( t_iToklen ) ;
							 t_chsDelLocation += t_chsLink;
							 t_chsDelLocation += t_chsLocation.Mid( t_iToklen + 1 ) ;

					fDeleteValuebyPath( t_chsDelLocation  ) ;
				}
			}
			t_oReg.NextSubKey() ;
		}

		// delete the registry unaware values
		fDeleteValuebyPath( CHString( RGAS_DHCP_OPTION_IPADDRESS ) ) ;
		fDeleteValuebyPath( CHString( RGAS_DHCP_OPTION_SUBNETMASK ) ) ;
		fDeleteValuebyPath( CHString( RGAS_DHCP_OPTION_NAMESERVERBACKUP ) ) ;
	}
	return TRUE ;
}
#endif
/*******************************************************************
    NAME:       fDeleteValuebyPath

    SYNOPSIS:	deletes the value in the path described by chsDelLocation

    ENTRY:      CHString& chsDelLocation

    HISTORY:
                  13-Oct-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fDeleteValuebyPath( CHString &a_chsDelLocation )
{
	CRegistry t_oReg ;

	int t_iTokLen = a_chsDelLocation.ReverseFind( '\\' ) ;

	if( -1 == t_iTokLen )
	{
		return FALSE ;
	}

	if( ERROR_SUCCESS == t_oReg.CreateOpen( HKEY_LOCAL_MACHINE, a_chsDelLocation.Left( t_iTokLen ) ) )
	{
		if( ERROR_SUCCESS == t_oReg.DeleteValue( a_chsDelLocation.Mid( t_iTokLen + 1 ) ) )
		{
			return TRUE ;
		}
	}
	return FALSE ;
}

/*******************************************************************
    NAME:       hSetIPConnectionMetric

    SYNOPSIS:   Sets IP connection metric, W2k only

    ENTRY:      CMParms

	NOTE:

	HISTORY:
                  21-Nov-1999     Created
********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hSetIPConnectionMetric( CMParms &a_rMParms )
{
#if NTONLY < 5
	return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;

#else

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	// extract the index key
	DWORD t_dwIndex ;
	if(	!a_rMParms.pInst()->GetDWORD(_T("Index"), t_dwIndex) )
	{
		return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// Get the instance interface location
	CHString t_chsLink;
	CHString t_csInterfaceBindingKey ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_csInterfaceBindingKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
	}

	// we have a network interface but, is it for a configurable adapter?
	if( !IsConfigurableTcpInterface( t_chsLink ) )
	{
		return a_rMParms.hSetResult( E_RET_INTERFACE_IS_NOT_CONFIGURABLE ) ;
	}


	// extract the connection metric
	DWORD t_dwConnectionMetric ;
	if(	!a_rMParms.pInParams()->GetDWORD( IP_CONNECTION_METRIC, t_dwConnectionMetric) )
	{
		t_dwConnectionMetric = 1;	// default
	}


	// have the parms
	CRegistry	t_oRegistry ;
	HRESULT		t_hRes ;

	// registry open and post
	if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csInterfaceBindingKey.GetBuffer( 0 ) ) ) )
	{
		t_hRes = t_oRegistry.SetCurrentKeyValue( RVAL_ConnectionMetric, t_dwConnectionMetric ) ;
	}

	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// NDIS notification
	CNdisApi t_oNdisApi ;
	if( !t_oNdisApi.PnpUpdateGateway( t_chsLink ) )
	{
		return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
	}
	else
	{
		// DNS notification
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;

#endif
}

/*******************************************************************
    NAME:       hRenewDHCPLease

    SYNOPSIS:   Renews a DHCP IP lease for a specific adapter

  	NOTES:		This is a non static, instance dependent method call

    ENTRY:      CMParms, framework return class

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hRenewDHCPLease( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop and NT5 at this time
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY
	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// retrieve the adapter identifier
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	E_RET t_eRet = hDHCPAcquire( a_rMParms, t_chsLink ) ;

	return a_rMParms.hSetResult( t_eRet ) ;

#endif
}

/*******************************************************************
    NAME:       hRenewDHCPLeaseAll

    SYNOPSIS:	Renews DHCP IP leases across all adapters

    ENTRY:      CMParms, framework return class

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hRenewDHCPLeaseAll( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop and NT5 at this time
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY
	CRegistry	t_RegAdapters ;
	CRegistry	t_RegService ;
	CHString	t_csAdapterKey ;
	CHString	t_chsServiceField ;
	E_RET		t_eRet = E_RET_OK ;
    short       sNumSuccesses = 0;
    short       sNumTotalTries = 0;
    E_RET       t_eTempRet = E_RET_OK;

	if( IsWinNT5() )
	{
		t_chsServiceField = _T("NetCfgInstanceID" ) ;
		t_csAdapterKey = _T("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}" ) ;
	}
	else // NT4 and below
	{
		t_chsServiceField = _T("ServiceName" ) ;
		t_csAdapterKey = _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards" ) ;
	}

	if( ERROR_SUCCESS == t_RegAdapters.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_csAdapterKey, KEY_READ ) )
	{
		// Walk through each instance under this key.
		while (	( ERROR_SUCCESS == t_RegAdapters.GetCurrentSubKeyPath( t_csAdapterKey ) ) )
		{
			CHString t_cshService ;
			t_RegService.OpenLocalMachineKeyAndReadValue( t_csAdapterKey, t_chsServiceField, t_cshService ) ;

			if( !t_cshService.IsEmpty() )
			{
				if( IsConfigurableTcpInterface( t_cshService ) )
				{
                    sNumTotalTries++;

                    t_eTempRet = hDHCPAcquire( a_rMParms, t_cshService ) ;

					// stow the error and continue
					if( E_RET_OK == t_eTempRet )
					{
						sNumSuccesses++;
					}
				}
			}
			t_RegAdapters.NextSubKey() ;
		}
	}

    // If we failed for every call to hDHCPAquire, and
    // at least called it once, report the actual error
    // that occured. Bug 161142 fix.
    if(sNumTotalTries > 0)
    {
        if(sNumSuccesses == 0)
        {
            t_eRet = t_eTempRet;
        }
        else
        {
            if(sNumSuccesses < sNumTotalTries)
            {
                t_eRet = E_RET_OK;
            }
        }
    }

	return a_rMParms.hSetResult( t_eRet ) ;
#endif
}

/*******************************************************************
    NAME:       hReleaseDHCPLease

    SYNOPSIS:   Releases a DHCP IP lease for a specific adapter

    ENTRY:      CMParms, framework return class

  	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hReleaseDHCPLease( CMParms &a_rMParms )
{
	// Supported only for the NT4 drop and NT5 at this time
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY
	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject(a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK;
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// retrieve the adapter identifier
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	E_RET t_eRet = hDHCPRelease( a_rMParms, t_chsLink ) ;

	return a_rMParms.hSetResult( t_eRet ) ;
#endif
}

/*******************************************************************
    NAME:       hReleaseDHCPLeaseAll

    SYNOPSIS:	Releases DHCP IP leases across all adapters

    ENTRY:      CMParms, framework return class

	NOTES:		This is a static, instance independent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hReleaseDHCPLeaseAll( CMParms &a_rMParms )
{
		// Supported only for the NT4 drop and NT5 at this time
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY
	CRegistry	t_RegAdapters ;
	CRegistry	t_RegService ;
	CHString	t_csAdapterKey ;
	CHString	t_chsServiceField ;
	E_RET		t_eRet = E_RET_OK ;
    short       sNumSuccesses = 0;
    short       sNumTotalTries = 0;
    E_RET       t_eTempRet = E_RET_OK;


	if( IsWinNT5() )
	{
		t_chsServiceField = _T("NetCfgInstanceID" ) ;
		t_csAdapterKey = _T("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}" ) ;
	}
	else	// NT4 and below
	{
		t_chsServiceField = _T("ServiceName" ) ;
		t_csAdapterKey = _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards" ) ;
	}


	if(ERROR_SUCCESS == t_RegAdapters.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE, t_csAdapterKey, KEY_READ ) )
	{
		// Walk through each instance under this key.
		while (	( ERROR_SUCCESS == t_RegAdapters.GetCurrentSubKeyPath( t_csAdapterKey ) ) )
		{
			CHString t_cshService ;
			t_RegService.OpenLocalMachineKeyAndReadValue( t_csAdapterKey, t_chsServiceField, t_cshService ) ;

			if( !t_cshService.IsEmpty() )
			{
				if( IsConfigurableTcpInterface( t_cshService ) )
				{
					sNumTotalTries++;

                    t_eTempRet = hDHCPRelease( a_rMParms, t_cshService ) ;

					// stow the error and continue
					if( E_RET_OK == t_eTempRet )
					{
						sNumSuccesses++;
					}
				}
			}
			t_RegAdapters.NextSubKey() ;
		}
	}

    // If we failed for every call to hDHCPAquire, and
    // at least called it once, report the actual error
    // that occured. Bug 161142 fix.
    if(sNumTotalTries > 0)
    {
        if(sNumSuccesses == 0)
        {
            t_eRet = t_eTempRet;
        }
        else
        {
            if(sNumSuccesses < sNumTotalTries)
            {
                t_eRet = E_RET_OK;
            }
        }
    }

	return a_rMParms.hSetResult( t_eRet ) ;
#endif
}


/*******************************************************************
    NAME:       hDHCPRelease

    SYNOPSIS:	Releases one or all DHCP enabled adapters

    ENTRY:      CMParms rMParms		: framework return class
				CHString chsAdapter	: empty for all adapters

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
E_RET CWin32NetworkAdapterConfig::hDHCPRelease( CMParms &a_rMParms, CHString &a_chsAdapter )
{
	DWORD t_dwError ;

    CDhcpcsvcApi *t_pdhcpcsvc = (CDhcpcsvcApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidDhcpcsvcApi, NULL ) ;

	if( t_pdhcpcsvc != NULL)
	{
		// force wide char
		bstr_t t_bstrAdapter( a_chsAdapter ) ;

		// call the DHCP Notification API
		t_dwError = t_pdhcpcsvc->DhcpReleaseParameters( (wchar_t*)t_bstrAdapter ) ;

		//FreeLibrary( hDll  ) ;
        CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidDhcpcsvcApi, t_pdhcpcsvc ) ;
        t_pdhcpcsvc = NULL;
	}
	else
		t_dwError = GetLastError( ) ;

	// map any error
	if( t_dwError )
	{
		return E_RET_UNABLE_TO_RELEASE_DHCP_LEASE ;
	}

	return E_RET_OK ;
}

/*******************************************************************
    NAME:       hDHCPAcquire

    SYNOPSIS:	Leases one or all DHCP enabled adapters

    ENTRY:      CMParms rMParms		: framework return class
				CHString chsAdapter	: empty for all adapters

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
E_RET CWin32NetworkAdapterConfig::hDHCPAcquire( CMParms &a_rMParms, CHString& a_chsAdapter )
{
	DWORD t_dwError ;

    CDhcpcsvcApi *t_pdhcpcsvc = (CDhcpcsvcApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidDhcpcsvcApi, NULL ) ;

	if( t_pdhcpcsvc != NULL )
	{
		// force wide char
		bstr_t t_bstrAdapter( a_chsAdapter ) ;

		// call the DHCP Notification API
		t_dwError = t_pdhcpcsvc->DhcpAcquireParameters( (wchar_t*)t_bstrAdapter ) ;

		//FreeLibrary( hDll  ) ;
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidDhcpcsvcApi, t_pdhcpcsvc ) ;
        t_pdhcpcsvc = NULL ;
	}
	else
		t_dwError = GetLastError( ) ;

	// map any error
	if( t_dwError )
	{
		return E_RET_UNABLE_TO_RENEW_DHCP_LEASE ;
	}

	return E_RET_OK ;
}

/*******************************************************************
    NAME:       hDHCPNotify

    SYNOPSIS:	Notifies DHCP of IP change to an adapter

    ENTRY:      CMParms &a_rMParms,					: Inparms
				CHString& chsAdapter,				: Adapter
				BOOL fIsNewIpAddress,				: TRUE if new IP
				DWORD dwIpIndex,					: Index of IP in the registry IP array ( zero based
				DWORD dwIpAddress,					: New IP
				DWORD dwSubnetMask,					: new subnet mask
				SERVICE_ENABLE DhcpServiceEnabled	: DhcpEnable, IgnoreFlag or DhcpDisable

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hDHCPNotify( CMParms &a_rMParms,
												 CHString &a_chsAdapter,
												 BOOL a_fIsNewIpAddress,
												 DWORD a_dwIpIndex,
												 DWORD a_dwIpAddress,
												 DWORD a_dwSubnetMask,
												 SERVICE_ENABLE a_DhcpServiceEnabled )
{
	DWORD t_dwError ;

    CDhcpcsvcApi *t_pdhcpcsvc = (CDhcpcsvcApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidDhcpcsvcApi, NULL ) ;

    if( t_pdhcpcsvc != NULL )
	{
		// force wide char
		bstr_t t_bstrAdapter( a_chsAdapter ) ;

		// call the DHCP Notification API
		t_dwError = t_pdhcpcsvc->DhcpNotifyConfigChange(NULL,				// name of server where this will be executed
								                        (wchar_t*)t_bstrAdapter,	// which adapter is going to be reconfigured?
								                        a_fIsNewIpAddress,	// is address new/ or address is same?
								                        a_dwIpIndex,			// index of addr for this adapter -- 0 ==> first interface...
								                        a_dwIpAddress,		// the ip address that is being set
								                        a_dwSubnetMask,		// corresponding subnet mask
								                        a_DhcpServiceEnabled	// DHCP Enable, disable or Ignore this flag
								                         ) ;

		//FreeLibrary( hDll  ) ;
        CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidDhcpcsvcApi, t_pdhcpcsvc ) ;
        t_pdhcpcsvc = NULL ;
	}
	else
		t_dwError = GetLastError( ) ;

	// map any error
	if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_CONFIG_DHCP_SERVICE ) )
	{
        LogErrorMessage2(L"Unable to configure DHCP svc : 0x%x\n", t_dwError);
		return TO_CALLER;
	}
	return a_rMParms.hSetResult( E_RET_OK ) ;
}

/*******************************************************************
    NAME:       hSetGateways

    SYNOPSIS:

    ENTRY:      CMParms, framework return class

  	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
HRESULT CWin32NetworkAdapterConfig::hSetGateways( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	TCHAR		t_cDelimiter = NULL ;
	SAFEARRAY	*t_IpGatewayArray		= NULL;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acGateway( &t_IpGatewayArray ) ;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK;
	}

	//	retrieve the IP gateway array
	if(	!a_rMParms.pInParams()->GetStringArray( _T("DefaultIpGateway"), t_IpGatewayArray ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// Gateway cost metric
	variant_t t_vCostMetric;

	if( IsWinNT5() )
	{
		t_vCostMetric.vt		= VT_I4 | VT_ARRAY ;
		t_vCostMetric.parray	= NULL ;
		a_rMParms.pInParams()->GetVariant( _T("GatewayCostMetric"), t_vCostMetric ) ;
	}

	// test IPs
	if( !t_IpGatewayArray )
	{
		CHString t_chsNULL(_T("") ) ;
		if( !fCreateAddEntry( &t_IpGatewayArray, t_chsNULL ) )
		{
			return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
		}
	}

	// validate gateway IPs
	if( !fValidateIPGateways( a_rMParms, t_IpGatewayArray, &t_vCostMetric.parray ) )
	{
		return S_OK ;
	}

	// OK to update, save to the registry

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// retrieve the adapter identifier
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	// registry open
	CRegistry	t_oRegTcpInterface ;
	HRESULT		t_hRes = t_oRegTcpInterface.Open( HKEY_LOCAL_MACHINE, t_chsRegKey, KEY_WRITE  ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// load the registry
	if( ERROR_SUCCESS != RegPutStringArray( t_oRegTcpInterface, _T("DefaultGateway") , *t_IpGatewayArray, t_cDelimiter ) )
	{
		return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
	}

	//
#if NTONLY >= 5
	{
		// cost metric
		if( t_vCostMetric.parray )
		{
			//maximum length is 6 characters e.g. "99999\0"
			CHString t_chsFormat( _T("%u") ) ;
			if( ERROR_SUCCESS != RegPutINTtoStringArray(	t_oRegTcpInterface,
															_T("DefaultGatewayMetric"),
															t_vCostMetric.parray,
															t_chsFormat,
															6 ) )
			{
				return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
			}
		}

		// we have to post back to the NT4 registry area
		// in order to keep existing apps in the field running

		CRegistry	t_oNT4Reg ;
		CHString	t_csBindingKey = SERVICES_HOME ;
					t_csBindingKey += _T("\\" ) ;
					t_csBindingKey += t_chsLink ;
					t_csBindingKey += PARAMETERS_TCPIP ;

		// insure the key is there on open
		HRESULT t_hRes = t_oNT4Reg.CreateOpen( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ) ) ;
		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}

		// load the registry entry
		if( ERROR_SUCCESS != RegPutStringArray( t_oNT4Reg, _T("DefaultGateway") , *t_IpGatewayArray, t_cDelimiter ) )
		{
			return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
		}

		// NDIS notification
		CNdisApi t_oNdisApi ;
		if( !t_oNdisApi.PnpUpdateGateway( t_chsLink ) )
		{
			return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
		}
		else
		{
			// DNS notification
			DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

			// map any error
			if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
			{
				return TO_CALLER ;
			}
		}
	}
#endif

	return a_rMParms.hSetResult( E_RET_OK ) ;
#endif
}

/*******************************************************************
    NAME:       hGetDNS

    SYNOPSIS:   Retrieves all DNS settings from the registry

    ENTRY:      CInstance

    HISTORY:
                  23-Jul-1998     Created

	NOTE:		This is not adapter specific.
				It retrieves from the common TCP/IP area.
********************************************************************/
#if NTONLY >= 5
HRESULT CWin32NetworkAdapterConfig::hGetDNSW2K(
    CInstance *a_pInst, 
    DWORD a_dwIndex,
    CHString& a_chstrRootDevice,
    CHString& a_chstrIpInterfaceKey)
{
	CRegistry	t_oRegistry;
	CHString	t_csBindingKey ;
	CHString	t_csHostName ;
	CHString	t_csDomain ;
	TCHAR		t_cDelimiter ;

	t_csBindingKey	=  SERVICES_HOME ;


	// NT4 is global with these setting across adapters
	t_csBindingKey	+= TCPIP_PARAMETERS ;

	// searchlist delimiter
	t_cDelimiter = ',' ;


	SAFEARRAY* t_DHCPNameServers = NULL;
	SAFEARRAY* t_ServerSearchOrder = NULL;
	SAFEARRAY* t_SuffixSearchOrder = NULL;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acDHCPServers( &t_DHCPNameServers ) ;
	saAutoClean acDefServers( &t_ServerSearchOrder ) ;
	saAutoClean acSuffix( &t_SuffixSearchOrder ) ;

	// registry open
	LONG t_lRes = t_oRegistry.Open( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_READ  ) ;

	// on error map to WBEM
	HRESULT t_hError = WinErrorToWBEMhResult( t_lRes ) ;

	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	t_oRegistry.GetCurrentKeyValue( RVAL_HOSTNAME, t_csHostName ) ;

	RegGetStringArray( t_oRegistry, RVAL_SEARCHLIST, &t_SuffixSearchOrder, t_cDelimiter  ) ;


	// On W2k the Domain and ServerSearchOrder are per adapter
	{
		// Get the instance interface location
		CHString t_chsLink;
        bool fGotTCPKey = false;

        fGotTCPKey = fGetNtTcpRegAdapterKey(a_dwIndex, t_csBindingKey, t_chsLink);
		// If it is a RAS connection, we need to look elsewhere...

        if(!fGotTCPKey)
        {
            if(a_chstrRootDevice.CompareNoCase(L"NdisWanIp") == 0)
            {
                int iPos = a_chstrIpInterfaceKey.Find(L"{");
                if(iPos != -1)
                {
                    t_chsLink = a_chstrIpInterfaceKey.Mid(iPos);

                    // Also fill in the BindingKey...
                    t_csBindingKey = SERVICES_HOME ;
			        t_csBindingKey += L"\\Tcpip\\Parameters\\Interfaces\\";
                    t_csBindingKey += t_chsLink;

                    fGotTCPKey = true;
                }     
            }
        }
        
        if(!fGotTCPKey)
		{
			LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
            return WBEM_E_NOT_FOUND ;
		}

		t_lRes = t_oRegistry.Open( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_READ ) ;


		// w2k strictly, dynamic DNS updates and domain registration
		DWORD t_dwDisableDynamicUpdate ;
		if( ERROR_SUCCESS == t_oRegistry.GetCurrentKeyValue( RVAL_DisableDynamicUpdate,
															 t_dwDisableDynamicUpdate ) )
		{
			if( !a_pInst->Setbool( FULL_DNS_REGISTRATION, (bool)( t_dwDisableDynamicUpdate ? false : true ) ) )
			{
				return WBEM_E_FAILED ;
			}

			DWORD t_dwDomainDNSRegistration ;
			if( ERROR_SUCCESS == t_oRegistry.GetCurrentKeyValue( RVAL_EnableAdapterDomainNameRegistration,
																 t_dwDomainDNSRegistration ) )
			{
				if( !a_pInst->Setbool( DOMAIN_DNS_REGISTRATION, (bool)( t_dwDomainDNSRegistration ? true : false ) ) )
				{
					return WBEM_E_FAILED ;
				}
			}
		}
	}

	DWORD	t_dwDHCPBool = 0L;
	BOOL	t_bExists = FALSE;

	t_bExists = ( t_oRegistry.GetCurrentKeyValue( _T("EnableDHCP"), t_dwDHCPBool ) == ERROR_SUCCESS );

	if ( t_bExists && t_dwDHCPBool )
	{
		RegGetStringArrayEx( t_oRegistry, RVAL_DHCPNAMESERVER, &t_DHCPNameServers ) ; // space delimited on all platforms
	}

#if NTONLY >= 5
    // on w2k, this list is space, not comma, delimeted...
    RegGetStringArrayEx( t_oRegistry, RVAL_NAMESERVER, &t_ServerSearchOrder);
#else
    RegGetStringArray( t_oRegistry, RVAL_NAMESERVER, &t_ServerSearchOrder, t_cDelimiter ) ;
#endif


	t_oRegistry.GetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;

	// get the DhcpDomain if override is not present
	if( t_csDomain.IsEmpty() )
	{
		t_oRegistry.GetCurrentKeyValue( RVAL_DHCPDOMAIN, t_csDomain ) ;
	}


	/* update */
	SAFEARRAY* t_NameServers = NULL;

	if ( t_bExists && t_dwDHCPBool )
	{
		// If override nameservers are present use them
		t_NameServers = t_ServerSearchOrder ? t_ServerSearchOrder : t_DHCPNameServers ;
	}
	else
	{
		t_NameServers = t_ServerSearchOrder ;
	}

	// update the instance
	if( !t_csHostName.IsEmpty() )
	{
		if( !a_pInst->SetCHString( DNS_HOSTNAME, t_csHostName ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	if( !t_csDomain.IsEmpty() )
	{
		if( !a_pInst->SetCHString( DNS_DOMAIN, t_csDomain ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	VARIANT t_vValue ;

	if( t_NameServers )
	{
		V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_NameServers ;
		if( !a_pInst->SetVariant( DNS_SERVERSEARCHORDER, t_vValue ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	if( t_SuffixSearchOrder )
	{
		V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_SuffixSearchOrder;
		if( !a_pInst->SetVariant( DNS_SUFFIXSEARCHORDER, t_vValue ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	return S_OK ;
}
#else
HRESULT CWin32NetworkAdapterConfig::hGetDNS( CInstance *a_pInst, DWORD a_dwIndex )
{
	CRegistry	t_oRegistry;
	CHString	t_csBindingKey ;
	CHString	t_csHostName ;
	CHString	t_csDomain ;
	TCHAR		t_cDelimiter ;

	t_csBindingKey	=  SERVICES_HOME ;

#ifdef NTONLY

	// NT4 is global with these setting across adapters
	t_csBindingKey	+= TCPIP_PARAMETERS ;

	// searchlist delimiter
	t_cDelimiter = ' ' ;

#else
	t_csBindingKey	+=  L"\\VxD\\MSTCP" ;
	t_cDelimiter	= ',' ;
#endif

	SAFEARRAY* t_DHCPNameServers = NULL;
	SAFEARRAY* t_ServerSearchOrder = NULL;
	SAFEARRAY* t_SuffixSearchOrder = NULL;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acDHCPServers( &t_DHCPNameServers ) ;
	saAutoClean acDefServers( &t_ServerSearchOrder ) ;
	saAutoClean acSuffix( &t_SuffixSearchOrder ) ;

	// registry open
	LONG t_lRes = t_oRegistry.Open( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_READ  ) ;

	// on error map to WBEM
	HRESULT t_hError = WinErrorToWBEMhResult( t_lRes ) ;

	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	t_oRegistry.GetCurrentKeyValue( RVAL_HOSTNAME, t_csHostName ) ;

	RegGetStringArray( t_oRegistry, RVAL_SEARCHLIST, &t_SuffixSearchOrder, t_cDelimiter  ) ;



	RegGetStringArrayEx( t_oRegistry, RVAL_DHCPNAMESERVER, &t_DHCPNameServers ) ; // space delimited on all platforms

#if NTONLY >= 5
    // on w2k, this list is space, not comma, delimeted...
    RegGetStringArrayEx( t_oRegistry, RVAL_NAMESERVER, &t_ServerSearchOrder);
#else
    RegGetStringArray( t_oRegistry, RVAL_NAMESERVER, &t_ServerSearchOrder, t_cDelimiter ) ;
#endif


	t_oRegistry.GetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;

	// get the DhcpDomain if override is not present
	if( t_csDomain.IsEmpty() )
	{
		t_oRegistry.GetCurrentKeyValue( RVAL_DHCPDOMAIN, t_csDomain ) ;
	}


	/* update */

	// If override nameservers are present use them
	SAFEARRAY* t_NameServers = t_ServerSearchOrder ? t_ServerSearchOrder : t_DHCPNameServers ;

	// update the instance
	if( !t_csHostName.IsEmpty() )
	{
		if( !a_pInst->SetCHString( DNS_HOSTNAME, t_csHostName ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	if( !t_csDomain.IsEmpty() )
	{
		if( !a_pInst->SetCHString( DNS_DOMAIN, t_csDomain ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	VARIANT t_vValue ;

	if( t_NameServers )
	{
		V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_NameServers ;
		if( !a_pInst->SetVariant( DNS_SERVERSEARCHORDER, t_vValue ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	if( t_SuffixSearchOrder )
	{
		V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_SuffixSearchOrder;
		if( !a_pInst->SetVariant( DNS_SUFFIXSEARCHORDER, t_vValue ) )
		{
			return WBEM_E_FAILED ;
		}
	}

	return S_OK ;
}
#endif
/*******************************************************************
    NAME:       hEnableDNS

    SYNOPSIS:   Sets all DNS properties to the registry

    ENTRY:      CMParms via CInstance depending on the context of the call

	HISTORY:
                  23-Jul-1998     Created
				  17-Jun-1999     added W2k changes

	NOTE:		Under NT4 these settings are global.
				Under W2k ServerSearchOrder and SuffixSearchOrder are
				adapter specific.

				In all cases of supported platforms this method replicates
				these setting across all adapters.
********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hEnableDNS( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY

	HRESULT		t_hRes ;
	CHString	t_csHostName ;
	CHString	t_csDomain ;
	SAFEARRAY	*t_ServerSearchOrder = NULL ;
	SAFEARRAY	*t_SuffixSearchOrder = NULL ;

	CHString	t_csParmBindingKey( SERVICES_HOME ) ;
				t_csParmBindingKey += TCPIP_PARAMETERS ;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acServer( &t_ServerSearchOrder ) ;
	saAutoClean acSuffix( &t_SuffixSearchOrder ) ;

	//
	DWORD t_dwValidBits = NULL ;
	E_RET t_eRet = fLoadAndValidateDNS_Settings(	a_rMParms,
													t_csHostName,
													t_csDomain,
													&t_ServerSearchOrder,
													&t_SuffixSearchOrder,
													&t_dwValidBits ) ;
	// bail on settings error
	if( E_RET_OK != t_eRet )
	{
		return a_rMParms.hSetResult( t_eRet ) ;
	}

	// These are global on all platforms
	CRegistry	t_oParmRegistry ;
	if( !(t_hRes = t_oParmRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csParmBindingKey.GetBuffer( 0 ) ) ) )
	{
		if( t_dwValidBits & 0x01 )
		{
			t_oParmRegistry.SetCurrentKeyValue( RVAL_HOSTNAME, t_csHostName ) ;
		}

		if( t_dwValidBits & 0x08 )
		{
			TCHAR t_cDelimiter = ' ' ;

			if( IsWinNT5() )
			{
				t_cDelimiter = ',' ;
			}

			t_hRes = RegPutStringArray( t_oParmRegistry, RVAL_SEARCHLIST , *t_SuffixSearchOrder, t_cDelimiter ) ;
		}
	}

	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// W2k is per adapter on domain and server search order
	if( IsWinNT5() && ( t_dwValidBits & 0x06 ) )
	{
		// master adapter list
		CHString t_csAdapterKey( "SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}" ) ;

		CRegistry t_oRegNetworks ;
		if( ERROR_SUCCESS == t_oRegNetworks.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_csAdapterKey, KEY_READ ) )
		{
			bool		t_fNotificationRequired = false ;
			CHString	t_csInterfaceBindingKey ;

			// Walk through each instance under this key.
			while (	( ERROR_SUCCESS == t_oRegNetworks.GetCurrentSubKeyName( t_csAdapterKey ) ) )
			{
				DWORD t_dwIndex = _ttol( t_csAdapterKey ) ;

				// Get the instance interface location
				CHString t_chsLink;
				if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_csInterfaceBindingKey, t_chsLink ) )
				{
					LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
                    return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
				}

				// we have a network interface but, is it for a configurable adapter?
				if( IsConfigurableTcpInterface( t_chsLink ) )
				{
					CRegistry	t_oRegInterface ;
					HRESULT		t_hRes ;

					// registry open
					if( !(t_hRes = t_oRegInterface.CreateOpen( HKEY_LOCAL_MACHINE, t_csInterfaceBindingKey.GetBuffer( 0 ) ) ) )
					{
						if( t_dwValidBits & 0x04 )
						{
							t_hRes = RegPutStringArray( t_oRegInterface, RVAL_NAMESERVER , *t_ServerSearchOrder, ',' ) ;
						}
					}

					if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
					{
						return TO_CALLER;
					}

					if( t_dwValidBits & 0x02 )
					{
						t_oRegInterface.SetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;
					}
					t_fNotificationRequired = true ;
				}

				t_oRegNetworks.NextSubKey() ;
			}

			// DNS pnp notifications
			if( t_fNotificationRequired )
			{
				DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

				// map any error
				if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
				{
					return TO_CALLER ;
				}
			}
		}
	}
	// NT4 is global across all adapters
	else if( t_dwValidBits & 0x06 )
	{
		if( t_dwValidBits & 0x04 )
		{
			t_hRes = RegPutStringArray( t_oParmRegistry, RVAL_NAMESERVER , *t_ServerSearchOrder ) ;

			if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
			{
				return TO_CALLER;
			}
		}

		if( t_dwValidBits & 0x02 )
		{
			t_oParmRegistry.SetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;
#endif
}

/*******************************************************************
    NAME:       hSetDNSDomain

    SYNOPSIS:   Sets the DNSDomain property to the registry

    ENTRY:      CMParms

	HISTORY:
                  17-Jun-1999    Created

	NOTE:		Under NT4 this settings are global.
				Under W2k DNSDomain is adapter specific.

********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hSetDNSDomain( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY

	HRESULT		t_hRes ;
	CHString	t_csDomain ;

	// DNSDomain
	a_rMParms.pInParams()->GetCHString( DNS_DOMAIN, t_csDomain ) ;

	// validate domain name
	if( !fIsValidateDNSDomain( t_csDomain ) )
	{
		return E_RET_INVALID_DOMAINNAME ;
	}

	// W2k is per adapter on domain
	if( IsWinNT5() )
	{
		// nonstatic method requires an instance
		if( !a_rMParms.pInst() )
		{
			return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
		}

		// collect the instance
		GetObject( a_rMParms.pInst() ) ;

		// IP must be enabled and bound to this adapter
		if( !fIsIPEnabled( a_rMParms ) )
		{
			return S_OK ;
		}

		// extract the index key
		DWORD t_dwIndex ;
		if(	!a_rMParms.pInst()->GetDWORD(_T("Index"), t_dwIndex) )
		{
			return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
		}

		// Get the instance interface location
		CHString t_chsLink;
		CHString t_csInterfaceBindingKey ;
		if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_csInterfaceBindingKey, t_chsLink ) )
		{
			LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
            return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
		}

		// we have a network interface but, is it for a configurable adapter?
		if( !IsConfigurableTcpInterface( t_chsLink ) )
		{
			return a_rMParms.hSetResult( E_RET_INTERFACE_IS_NOT_CONFIGURABLE ) ;
		}

		CRegistry	t_oRegistry ;
		HRESULT		t_hRes ;

		// registry open
		if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csInterfaceBindingKey.GetBuffer( 0 ) ) ) )
		{
			t_hRes = t_oRegistry.SetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;
		}

		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}

		// DNS pnp notifications
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}
	// NT4 is global across all adapters
	else
	{
		CRegistry	t_oRegistry ;
		CHString	t_csParmBindingKey( SERVICES_HOME ) ;
					t_csParmBindingKey += TCPIP_PARAMETERS ;

		if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csParmBindingKey.GetBuffer( 0 ) ) ) )
		{
			t_hRes = t_oRegistry.SetCurrentKeyValue( RVAL_DOMAIN, t_csDomain ) ;
		}

		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;
#endif
}

/*******************************************************************
    NAME:       hSetDNSSuffixSearchOrder

    SYNOPSIS:   Sets the DNS SuffixSearchOrder property to the registry

    ENTRY:      CMParms

	HISTORY:
                  17-Jun-1999     Created

	NOTE:		This method applies globally across adapters.

********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hSetDNSSuffixSearchOrder( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY

	HRESULT		t_hRes ;
	SAFEARRAY	*t_SuffixSearchOrder = NULL ;
	saAutoClean acSuffix( &t_SuffixSearchOrder ) ;

	// suffix order array
	a_rMParms.pInParams()->GetStringArray( DNS_SUFFIXSEARCHORDER, t_SuffixSearchOrder ) ;

	// test suffix
	if( !t_SuffixSearchOrder )
	{
		CHString t_chsNULL(_T("") ) ;
		if( !fCreateAddEntry( &t_SuffixSearchOrder, t_chsNULL ) )
		{
			return a_rMParms.hSetResult( E_RET_UNKNOWN_FAILURE );
		}
	}

	CRegistry	t_oRegistry ;
	CHString	t_csParmBindingKey( SERVICES_HOME ) ;
				t_csParmBindingKey += TCPIP_PARAMETERS ;

	if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csParmBindingKey.GetBuffer( 0 ) ) ) )
	{
		TCHAR t_cDelimiter = ' ' ;

		if( IsWinNT5() )
		{
			t_cDelimiter = ',' ;
		}

		t_hRes = t_hRes = RegPutStringArray( t_oRegistry, RVAL_SEARCHLIST , *t_SuffixSearchOrder, t_cDelimiter ) ;
	}

	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}


	// DNS pnp notifications
	if( IsWinNT5() )
	{
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;

#endif
}

/*******************************************************************
    NAME:       hSetDNSServerSearchOrder

    SYNOPSIS:   Sets the ServerSearchOrder property to the registry

    ENTRY:      CMParms

	HISTORY:
                  17-Jun-1999     Created

	NOTE:		Under NT4 these settings are global.
				Under W2k SuffixSearchOrder is	adapter specific.


********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hSetDNSServerSearchOrder( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY

	HRESULT		t_hRes ;
	SAFEARRAY	*t_ServerSearchOrder = NULL ;
	saAutoClean acSuffix( &t_ServerSearchOrder ) ;

	CHString t_chsNULL(_T("") ) ;

	//retrieve the DNS Server search order array
	a_rMParms.pInParams()->GetStringArray( DNS_SERVERSEARCHORDER, t_ServerSearchOrder ) ;

	// test IPs
	if( !t_ServerSearchOrder )
	{
		if( !fCreateAddEntry( &t_ServerSearchOrder, t_chsNULL ) )
		{
			return a_rMParms.hSetResult( E_RET_UNKNOWN_FAILURE ) ;
		}
	}
	else	{
		// validate search order IPs
		if( !fValidateIPs( t_ServerSearchOrder ) )
		{
			return a_rMParms.hSetResult( E_RET_IP_INVALID ) ;
		}
	}



	// W2k is per adapter on suffix order
	if( IsWinNT5() )
	{
		// nonstatic method requires an instance
		if( !a_rMParms.pInst() )
		{
			return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
		}

		// collect the instance
		GetObject( a_rMParms.pInst() ) ;

		// IP must be enabled and bound to this adapter
		if( !fIsIPEnabled( a_rMParms ) )
		{
			return S_OK ;
		}

		// extract the index key
		DWORD t_dwIndex ;
		if(	!a_rMParms.pInst()->GetDWORD(_T("Index"), t_dwIndex) )
		{
			return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
		}

		// Get the instance interface location
		CHString t_chsLink;
		CHString t_csInterfaceBindingKey ;
		if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_csInterfaceBindingKey, t_chsLink ) )
		{
			LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
            return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
		}

		// we have a network interface but, is it for a configurable adapter?
		if( !IsConfigurableTcpInterface( t_chsLink ) )
		{
			return a_rMParms.hSetResult( E_RET_INTERFACE_IS_NOT_CONFIGURABLE ) ;
		}

		CRegistry	t_oRegistry ;
		HRESULT		t_hRes ;

		// registry open
		if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csInterfaceBindingKey.GetBuffer( 0 ) ) ) )
		{
			t_hRes = RegPutStringArray( t_oRegistry, RVAL_NAMESERVER , *t_ServerSearchOrder, ',' ) ;
		}

		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}

		// DNS pnp notifications
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}
	// NT4 is global across all adapters
	else
	{
		CRegistry	t_oRegistry ;
		CHString	t_csParmBindingKey( SERVICES_HOME ) ;
					t_csParmBindingKey += TCPIP_PARAMETERS ;

		if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csParmBindingKey.GetBuffer( 0 ) ) ) )
		{
			t_hRes = t_hRes = RegPutStringArray( t_oRegistry, RVAL_NAMESERVER , *t_ServerSearchOrder ) ;
		}

		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}
	}

	// DNS pnp notifications
	if( IsWinNT5() )
	{
		DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

		// map any error
		if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
		{
			return TO_CALLER ;
		}
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;
#endif
}

/*******************************************************************
    NAME:       hSetDynamicDNSRegistration

    SYNOPSIS:   Sets DNS for dynamic registration under W2k

    ENTRY:      CMParms

	NOTE:

	HISTORY:
                  21-Nov-1999     Created
********************************************************************/

//
HRESULT CWin32NetworkAdapterConfig::hSetDynamicDNSRegistration( CMParms &a_rMParms )
{
#if NTONLY < 5
	return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;

#else
	bool t_fFullDnsRegistration		= false ;
	bool t_fDomainDNSRegistration	= false ;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	// extract the index key
	DWORD t_dwIndex ;
	if(	!a_rMParms.pInst()->GetDWORD(_T("Index"), t_dwIndex) )
	{
		return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// Get the instance interface location
	CHString t_chsLink;
	CHString t_csInterfaceBindingKey ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_csInterfaceBindingKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
	}

	// we have a network interface but, is it for a configurable adapter?
	if( !IsConfigurableTcpInterface( t_chsLink ) )
	{
		return a_rMParms.hSetResult( E_RET_INTERFACE_IS_NOT_CONFIGURABLE ) ;
	}


	// FullDNSRegistrationEnabled is required
	if( !a_rMParms.pInParams()->Getbool( FULL_DNS_REGISTRATION, t_fFullDnsRegistration ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}
	else
	{
		// DomainDNSRegistrationEnabled is optional
		if( t_fFullDnsRegistration )
		{
			if( !a_rMParms.pInParams()->Getbool( DOMAIN_DNS_REGISTRATION, t_fDomainDNSRegistration ) )
			{
				// default
				t_fDomainDNSRegistration = false ;
			}
		}
	}

	// have the parms
	CRegistry	t_oRegistry ;
	HRESULT		t_hRes ;

	// registry open and post
	if( !(t_hRes = t_oRegistry.CreateOpen( HKEY_LOCAL_MACHINE, t_csInterfaceBindingKey.GetBuffer( 0 ) ) ) )
	{
		// FullDnsRegistration
		DWORD t_dwDisableDnsRegistration = !t_fFullDnsRegistration ;
		if( !(t_hRes = t_oRegistry.SetCurrentKeyValue( RVAL_DisableDynamicUpdate,
													   t_dwDisableDnsRegistration ) ) )
		{
			// DomainDNSRegistration
			DWORD t_dwDomainDNSRegistration = t_fDomainDNSRegistration ;
			t_hRes = t_oRegistry.SetCurrentKeyValue( RVAL_EnableAdapterDomainNameRegistration,
													 t_dwDomainDNSRegistration ) ;
		}
	}

	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

	// DNS pnp notifications
	DWORD t_dwError = dwSendServiceControl( L"Dnscache", SERVICE_CONTROL_PARAMCHANGE ) ;

	// map any error
	if( t_dwError && fMapResError( a_rMParms, t_dwError, E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE ) )
	{
		return TO_CALLER ;
	}

	return a_rMParms.hSetResult( E_RET_OK ) ;

#endif
}

/*******************************************************************
    NAME:       fLoadAndValidateDNS_Settings

    SYNOPSIS:

    ENTRY:      CMParms		&a_rMParms,
				CHString	&a_csHostName,
				CHString	&a_csDomain,
				SAFEARRAY	*a_ServerSearchOrder,
				SAFEARRAY	*a_SuffixSearchOrder,
				DWORD		*a_dwValidBits

	HISTORY:
                  17-Jun-1999     Created

	NOTE:

********************************************************************/
#ifdef NTONLY
E_RET CWin32NetworkAdapterConfig::fLoadAndValidateDNS_Settings(
CMParms		&a_rMParms,
CHString	&a_csHostName,
CHString	&a_csDomain,
SAFEARRAY	**a_ServerSearchOrder,
SAFEARRAY	**a_SuffixSearchOrder,
DWORD		*a_dwValidBits
)
{
	*a_dwValidBits = NULL ;

	// under w2k the computername is preset and not otherwise useable
	// by DNS as an alternate computer identifier.
	if( !IsWinNT5() )
	{
		// extract the DNSHostName
		if( a_rMParms.pInParams()->GetCHString( DNS_HOSTNAME, a_csHostName ) )
		{
			// validate domain name
			if( !fIsValidateDNSHost( a_csHostName ) )
			{
				return E_RET_INVALID_HOSTNAME ;
			}
			*a_dwValidBits |= 0x01 ;
		}
	}

	// And the DNSDomain
	if( a_rMParms.pInParams()->GetCHString( DNS_DOMAIN, a_csDomain ) )
	{
		// validate domain name
		if( !fIsValidateDNSDomain( a_csDomain ) )
		{
			return E_RET_INVALID_DOMAINNAME ;
		}
		*a_dwValidBits |= 0x02 ;
	}

	//	retrieve the DNS Server search order array
	if( a_rMParms.pInParams()->GetStringArray( DNS_SERVERSEARCHORDER, *a_ServerSearchOrder ) )
	{
		// test IPs
		if( *a_ServerSearchOrder )
		{
			// validate search order IPs
			if( !fValidateIPs( *a_ServerSearchOrder ) )
			{
				return E_RET_IP_INVALID ;
			}
			*a_dwValidBits |= 0x04 ;
		}
	}

	// And the suffix order array
	if( a_rMParms.pInParams()->GetStringArray( DNS_SUFFIXSEARCHORDER, *a_SuffixSearchOrder ) )
	{
		if( *a_SuffixSearchOrder )
		{
			*a_dwValidBits |= 0x08 ;
		}
	}

	if( !*a_dwValidBits )
	{
		return E_RET_INPARM_FAILURE ;
	}

	return E_RET_OK ;
}
#endif

/*******************************************************************
    NAME:       fIsValidateDNSHost

    SYNOPSIS:   Validates a passed DMS host name

    ENTRY:      CHString

    HISTORY:
                  23-Jul-1998     modified
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fIsValidateDNSHost( CHString &a_rchHost )
{
    int		t_nLen ;
    BOOL	t_bResult = FALSE ;

    // hostname cannot be zero
	if (( t_nLen = a_rchHost.GetLength() ) != 0 )
    {
        //HOST_LIMIT is bytes not chartacters
		if ( t_nLen <= HOST_LIMIT )
        {
			WCHAR *t_ptr = a_rchHost.GetBuffer( 0 ) ;

			//first letter must be alpha-numeric
			t_bResult = _istalpha( *t_ptr ) || _istdigit( *t_ptr ) ;

			if ( t_bResult )
			{
				t_ptr++ ;

				while ( *t_ptr != '\0' )
				{
					// check each character is either a digit or a letter
					BOOL t_fAlNum = _istalpha( *t_ptr ) || _istdigit( *t_ptr ) ;

					if ( !t_fAlNum && ( *t_ptr != L'-' ) && ( *t_ptr != '_' ) )
					{
						// must be letter, digit, '-', '_'
						t_bResult = FALSE ;
						break ;
					}

					//t_ptr = _tcsinc(t_ptr ) ;
                    t_ptr++ ;

					if ( !t_fAlNum && ( *t_ptr == '\0') )
					{
						// last letter must be a letter or a digit
						t_bResult = FALSE;
					}
				}
			}

			a_rchHost.ReleaseBuffer() ;
        }
    }
    return t_bResult;
}

/*******************************************************************
    NAME:       fIsValidateDNSDomain

    SYNOPSIS:   Validates a passed DMS domain name

    ENTRY:      CHString

    HISTORY:
                  23-Jul-1998     modified from other source
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fIsValidateDNSDomain( CHString &a_rchDomain )
{
    int		t_nLen;
	BOOL	t_bResult = TRUE ;

	if ( ( t_nLen = a_rchDomain.GetLength()) != 0 )
    {
        //length in bytes
		if ( t_nLen < DOMAINNAME_LENGTH )
        {
			WCHAR *t_ptr = a_rchDomain.GetBuffer( 0 ) ;

			//first letter must be alpha-numeric
			t_bResult = _istalpha( *t_ptr ) || _istdigit( *t_ptr ) ;

			if ( t_bResult )
			{
				BOOL t_fLet_Dig = FALSE ;
				BOOL t_fDot = FALSE ;
				int t_cHostname = 0 ;

				//t_ptr = _tcsinc(t_ptr ) ;
                t_ptr++ ;

				while ( *t_ptr != '\0' )
				{
	                BOOL t_fAlNum = _istalpha( *t_ptr ) || _istdigit( *t_ptr ) ;

					if ( ( t_fDot && !t_fAlNum ) ||
							// first letter after dot must be a digit or a letter
						( !t_fAlNum && ( *t_ptr != '-' ) && ( *t_ptr != '.' ) && ( *t_ptr != '_' ) ) ||
							// must be letter, digit, - or "."
						( ( *t_ptr == '-' ) && ( !t_fLet_Dig ) ) )
							// must be letter or digit before '.'
					{
						t_bResult = FALSE ;
						break;
					}

					t_fLet_Dig = t_fAlNum ;
					t_fDot = *t_ptr == '.' ;

                    t_cHostname++ ;

					//in bytes
					if ( t_cHostname > HOSTNAME_LENGTH )
					{
						t_bResult = FALSE ;
						break ;
					}

					if ( t_fDot )
					{
						t_cHostname = 0 ;
					}

					t_ptr++ ;

					if (!t_fAlNum && ( *t_ptr == '\0' ) )
					{
						// last letter must be a letter or a digit
						t_bResult = FALSE ;
					}
				}
            }

			a_rchDomain.ReleaseBuffer() ;
        }
		else
		{
			t_bResult = FALSE ;
		}
    }
	else
	{
		t_bResult = TRUE ;
	}

    return TRUE ;
}


/*******************************************************************
    NAME:       hGetWinsNT

    SYNOPSIS:   Retrieves WINS info from the registry

    ENTRY:      CInstance

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
#ifdef NTONLY
#if NTONLY >= 5
HRESULT CWin32NetworkAdapterConfig::hGetWinsW2K(
    CInstance *a_pInst, 
    DWORD a_dwIndex,
    CHString& a_chstrRootDevice,
    CHString& a_chstrIpInterfaceKey)
{
	DWORD		t_dwDNSOverWINS = 0;
	DWORD		t_dwLMLookups	= 0;
	CHString	t_chPrimaryWINSServer ;
	CHString	t_chSecondaryWINSServer ;
	CHString	t_chScopeID ;
	LONG		t_lRes ;
	HRESULT		t_hError ;

	// link name for binding to the adapter
	CHString t_csNBInterfaceKey ;
	CHString t_csNBLink ;
    bool fGotNtNBKey = false;

	fGotNtNBKey = fGetNtNBRegAdapterKey(
        a_dwIndex, 
        t_csNBInterfaceKey, 
        t_csNBLink);

    // This may be a RAS connection, in which
    // case the NB info is in a different
    // location.  So try that before giving up...
    if(!fGotNtNBKey)
    {
        if(a_chstrRootDevice.CompareNoCase(L"NdisWanIp") == 0)
        {
            int iPos = a_chstrIpInterfaceKey.Find(L"{");
            if(iPos != -1)
            {
                t_csNBLink = L"Tcpip_";
                t_csNBLink += a_chstrIpInterfaceKey.Mid(iPos);

                // Also fill in the NBInterfaceKey...
                t_csNBInterfaceKey = SERVICES_HOME ;
			    t_csNBInterfaceKey += L"\\NetBT\\Parameters\\Interfaces\\";
                t_csNBInterfaceKey += t_csNBLink;

                fGotNtNBKey = true;
            }     
        }
    }

    if(!fGotNtNBKey)
	{
		LogErrorMessage(L"Call to fGetNtNBRegAdapterKey failed");
        return E_RET_OBJECT_NOT_FOUND ;
	}
	else
	{
		// Win servers from the WINS driver
		if( fGetWinsServers( t_csNBLink, t_chPrimaryWINSServer, t_chSecondaryWINSServer ) )
		{
			// load up the instance
			if(t_chPrimaryWINSServer.GetLength() > 0)
            {
               if( !a_pInst->SetCHString( PRIMARY_WINS_SERVER, t_chPrimaryWINSServer) )
			    {
				    return WBEM_E_FAILED;
			    }
            }

			if(t_chSecondaryWINSServer.GetLength() > 0)
            {
                if(	!a_pInst->SetCHString( SECONDARY_WINS_SERVER, t_chSecondaryWINSServer) )
			    {
				    return WBEM_E_FAILED;
			    }
            }
		}

		// Parameters\interfaces
		CRegistry t_oRegNBTInterface ;

		if( SUCCEEDED( t_oRegNBTInterface.Open( HKEY_LOCAL_MACHINE,
												t_csNBInterfaceKey.GetBuffer( 0 ),
												KEY_READ ) ) )
		{
			// NetbiosOptions
			DWORD t_dwNetBiosOptions ;
			if( ERROR_SUCCESS == t_oRegNBTInterface.GetCurrentKeyValue( RVAL_NETBT_NETBIOSOPTIONS,
																		t_dwNetBiosOptions ) )
			{
				if( !a_pInst->SetDWORD( TCPIP_NETBIOS_OPTIONS,
										t_dwNetBiosOptions ) )
				{
					return WBEM_E_FAILED;
				}
			}
		}
	}

	// Open registry for the NetBT parameters
	CHString	t_csNBTBindingKey =  SERVICES_HOME ;
				t_csNBTBindingKey += NETBT_PARAMETERS ;

	CRegistry t_oRegNBTParams ;

	t_lRes = t_oRegNBTParams.Open( HKEY_LOCAL_MACHINE, t_csNBTBindingKey.GetBuffer( 0 ), KEY_READ ) ;

	// on error map to WBEM
	t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	// load the registry
	t_oRegNBTParams.GetCurrentKeyValue( RVAL_DNS_ENABLE_WINS,	t_dwDNSOverWINS ) ;
	t_oRegNBTParams.GetCurrentKeyValue( RVAL_DNS_ENABLE_LMHOST,	t_dwLMLookups ) ;
	t_oRegNBTParams.GetCurrentKeyValue( RVAL_SCOPEID,			t_chScopeID ) ;

	if( !a_pInst->Setbool( DNS_OVER_WINS, (bool)( t_dwDNSOverWINS ? true : false ) ) )
	{
		return WBEM_E_FAILED;
	}

	if(	!a_pInst->Setbool( WINS_ENABLE_LMHOSTS, (bool)( t_dwLMLookups ? true : false ) ) )
	{
		return WBEM_E_FAILED;
	}

	if(	!a_pInst->SetCHString( SCOPE_ID, t_chScopeID ) )
	{
		return WBEM_E_FAILED;
	}

	return S_OK ;
}
#else // NT 4 version
HRESULT CWin32NetworkAdapterConfig::hGetWinsNT(
    CInstance *a_pInst, 
    DWORD a_dwIndex)
{
	DWORD		t_dwDNSOverWINS = 0;
	DWORD		t_dwLMLookups	= 0;
	CHString	t_chPrimaryWINSServer ;
	CHString	t_chSecondaryWINSServer ;
	CHString	t_chScopeID ;
	LONG		t_lRes ;
	HRESULT		t_hError ;

	// link name for binding to the adapter
	CHString t_csNBInterfaceKey ;
	CHString t_csNBLink ;

	if( !fGetNtNBRegAdapterKey( a_dwIndex, t_csNBInterfaceKey, t_csNBLink ) )
	{
		LogErrorMessage(L"Call to fGetNtNBRegAdapterKey failed");
        return E_RET_OBJECT_NOT_FOUND ;
	}
	else
	{
		// Win servers from the WINS driver
        if( fGetWinsServers( t_csNBLink, t_chPrimaryWINSServer, t_chSecondaryWINSServer ) )
		{
			// load up the instance
			if(t_chPrimaryWINSServer.GetLength() > 0)
            {
                if( !a_pInst->SetCHString( PRIMARY_WINS_SERVER, t_chPrimaryWINSServer) )
			    {
				    return WBEM_E_FAILED;
			    }
            }
			
            if(t_chSecondaryWINSServer.GetLength() > 0)
            {
                if(	!a_pInst->SetCHString( SECONDARY_WINS_SERVER, t_chSecondaryWINSServer) )
			    {
				    return WBEM_E_FAILED;
			    }
            }
		}
	}

	// Open registry for the NetBT parameters
	CHString	t_csNBTBindingKey =  SERVICES_HOME ;
				t_csNBTBindingKey += NETBT_PARAMETERS ;

	CRegistry t_oRegNBTParams ;

	t_lRes = t_oRegNBTParams.Open( HKEY_LOCAL_MACHINE, t_csNBTBindingKey.GetBuffer( 0 ), KEY_READ ) ;

	// on error map to WBEM
	t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	// load the registry
	t_oRegNBTParams.GetCurrentKeyValue( RVAL_DNS_ENABLE_WINS,	t_dwDNSOverWINS ) ;
	t_oRegNBTParams.GetCurrentKeyValue( RVAL_DNS_ENABLE_LMHOST,	t_dwLMLookups ) ;
	t_oRegNBTParams.GetCurrentKeyValue( RVAL_SCOPEID,			t_chScopeID ) ;

	if( !a_pInst->Setbool( DNS_OVER_WINS, (bool)( t_dwDNSOverWINS ? true : false ) ) )
	{
		return WBEM_E_FAILED;
	}

	if(	!a_pInst->Setbool( WINS_ENABLE_LMHOSTS, (bool)( t_dwLMLookups ? true : false ) ) )
	{
		return WBEM_E_FAILED;
	}

	if(	!a_pInst->SetCHString( SCOPE_ID, t_chScopeID ) )
	{
		return WBEM_E_FAILED;
	}

	return S_OK ;
}

#endif // if NTONLY >= 5
#endif // ifdef NTONLY



/*******************************************************************
    NAME:       hSetTcpipNetbios

    SYNOPSIS:   Sets Netbios options for W2k

    ENTRY:      CMParms		:

  	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  20-Nov-1999     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hSetTcpipNetbios( CMParms &a_rMParms )
{
#if NTONLY < 5
	return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;

#else

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK;
	}

	// obtain the Netbios option
	DWORD t_dwOption ;
	if( !a_rMParms.pInParams()->GetDWORD( TCPIP_NETBIOS_OPTIONS, t_dwOption ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// asking for Netbios setting via DHCP?
	if( UNSET_Netbios == t_dwOption )
	{
		// DHCP must be enabled for this adapter
		if( !fIsDhcpEnabled( a_rMParms ) )
		{
			return S_OK;
		}
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	return a_rMParms.hSetResult( eSetNetBiosOptions( t_dwOption, t_dwIndex ) ) ;

#endif
}

/*******************************************************************
    NAME:       eSetNetBiosOptions

    SYNOPSIS:   Sets Netbios options for W2k

    ENTRY:      WORD a_dwOption, DWORD a_dwIndex		:

  	NOTES:

    HISTORY:
                  20-Nov-1999     Created
********************************************************************/
#if NTONLY >= 5
E_RET CWin32NetworkAdapterConfig::eSetNetBiosOptions( DWORD a_dwOption, DWORD a_dwIndex )
{
	E_RET t_eRet ;

	if( ( UNSET_Netbios != a_dwOption ) &&
		( ENABLE_Netbios != a_dwOption ) &&
		( DISABLE_Netbios != a_dwOption ) )
	{
		t_eRet = E_RET_PARAMETER_BOUNDS_ERROR ;
	}
	else
	{
		// link name for binding to the adapter
		CHString t_csNBBindingKey ;
		CHString t_csNBLink ;
		if( !fGetNtNBRegAdapterKey( a_dwIndex, t_csNBBindingKey, t_csNBLink ) )
		{
			LogErrorMessage(L"Call to fGetNtNBRegAdapterKey failed");
            t_eRet = E_RET_OBJECT_NOT_FOUND ;
		}
		else
		{
			// registry open
			CRegistry	t_oRegNBTAdapter;
			HRESULT		t_hRes = t_oRegNBTAdapter.Open( HKEY_LOCAL_MACHINE,
														t_csNBBindingKey.GetBuffer( 0 ),
														KEY_WRITE  ) ;

			if( ERROR_SUCCESS == t_hRes )
			{
				t_hRes = t_oRegNBTAdapter.SetCurrentKeyValue( RVAL_NETBT_NETBIOSOPTIONS, a_dwOption ) ;
			}

			if( ERROR_SUCCESS != t_hRes )
			{
				t_eRet = E_RET_REGISTRY_FAILURE ;
			}
			else
			{
				// NDIS notification
				CNdisApi t_oNdisApi ;
				if( t_oNdisApi.PnpUpdateNbtAdapter( t_csNBLink ) )
				{
					t_eRet = E_RET_OK ;
				}
				else
				{
					t_eRet = E_RET_OK_REBOOT_REQUIRED ;
				}
			}
		}
	}

	return t_eRet ;
}

#endif

/*******************************************************************
    NAME:       hEnableWINSServer

    SYNOPSIS:   Sets all adapter independent WINS properties to the registry

    ENTRY:      CMParms		:

  	NOTES:		This is a non static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableWINSServer( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
	return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY

	CHString	t_chPrimaryWINSServer ;
	CHString	t_chSecondaryWINSServer ;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK;
	}

	// Collect up the primary and secondary server
	if( !a_rMParms.pInParams()->GetCHString( PRIMARY_WINS_SERVER, t_chPrimaryWINSServer ) ||
		!a_rMParms.pInParams()->GetCHString( SECONDARY_WINS_SERVER, t_chSecondaryWINSServer ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	/* Validate primary and secondary server */
	int t_iPLen = t_chPrimaryWINSServer.GetLength( ) ;
	int t_iSLen = t_chSecondaryWINSServer.GetLength( ) ;

	if( !t_iPLen && t_iSLen )
	{
		return a_rMParms.hSetResult( E_RET_WINS_SEC_NO_PRIME ) ;
	}

 	if( ( t_iPLen && !fIsValidIP( t_chPrimaryWINSServer ) ) ||
		( t_iSLen && !fIsValidIP( t_chSecondaryWINSServer ) ) )
	{
		return a_rMParms.hSetResult( E_RET_IP_INVALID  ) ;
	}

	// obtain the index key
	DWORD t_dwIndex ;
	if( !a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex ) )
	{
		return a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// link name for binding to the adapter
	CHString t_csNBBindingKey ;
	CHString t_csNBLink ;
	if( !fGetNtNBRegAdapterKey( t_dwIndex, t_csNBBindingKey, t_csNBLink ) )
	{
		LogErrorMessage(L"Call to fGetNtNBRegAdapterKey failed");
        return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
	}

	// registry open
	CRegistry	t_oRegNBTAdapter;
	HRESULT		t_hRes = t_oRegNBTAdapter.Open( HKEY_LOCAL_MACHINE, t_csNBBindingKey.GetBuffer( 0 ), KEY_WRITE  ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}

#if NTONLY >= 5
	{
		// Under W2k Wins Servers are in a MULTI_SZ
		CHStringArray	t_chsaServers ;

		t_chsaServers.Add( t_chPrimaryWINSServer ) ;
		t_chsaServers.Add( t_chSecondaryWINSServer ) ;

		t_oRegNBTAdapter.SetCurrentKeyValue( L"NameServerList", t_chsaServers ) ;

		// NDIS notification
		CNdisApi t_oNdisApi ;
		if( !t_oNdisApi.PnpUpdateNbtAdapter( t_csNBLink ) )
		{
			return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
		}
	}
#else
	{
		// load the registry
		t_oRegNBTAdapter.SetCurrentKeyValue( RVAL_PRIMARY_WINS,	t_chPrimaryWINSServer ) ;
		t_oRegNBTAdapter.SetCurrentKeyValue( RVAL_SECONDARY_WINS, t_chSecondaryWINSServer ) ;

		// Notify the WINS driver
		if( !fSetWinsServers( t_csNBLink, t_chPrimaryWINSServer, t_chSecondaryWINSServer ) )
		{
			return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
		}
	}
#endif

	return a_rMParms.hSetResult( E_RET_OK ) ;
#endif
}

/*******************************************************************
    NAME:       hEnableWINS

    SYNOPSIS:   Sets all adapter independent WINS properties to the registry

    ENTRY:      CMParms		:

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableWINS( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY

	CHString	t_csBindingKey;
	CRegistry	t_oRegNBTParams ;

	CHString	t_chWINSHostLookupFile ;
	CHString	t_chScopeID ;
	CHString	t_ServiceName ;
	DWORD		t_dwValidBits = NULL ;

	// DNS over WINS?
	bool t_fDNSOverWINS = false ;
	if( a_rMParms.pInParams()->Getbool( DNS_OVER_WINS, t_fDNSOverWINS ) )
	{
		t_dwValidBits |= 0x01 ;
	}

	// Lookup enabled?
	bool t_fLMLookups = false ;
	if( a_rMParms.pInParams()->Getbool( WINS_ENABLE_LMHOSTS, t_fLMLookups ) )
	{
		t_dwValidBits |= 0x02 ;
	}

	// Get the Lookup source file
	if( a_rMParms.pInParams()->GetCHString( WINS_HOST_LOOKUP_FILE, t_chWINSHostLookupFile) )
	{
		t_dwValidBits |= 0x04 ;
	}

	// Scope ID
	if( a_rMParms.pInParams()->GetCHString( SCOPE_ID, t_chScopeID ) )
	{
		t_dwValidBits |= 0x08 ;
	}

	if( !t_dwValidBits )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE  ) ;
	}

	// Open the NetBT registry if nessicary
	if( t_dwValidBits & ( 0x01 | 0x02 | 0x08 ) )
	{
		t_csBindingKey =  SERVICES_HOME ;
		t_csBindingKey += NETBT_PARAMETERS ;

		// registry open
		HRESULT t_hRes = t_oRegNBTParams.Open(HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_WRITE ) ;
		if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
		{
			return TO_CALLER;
		}
	}

	if( t_dwValidBits & 0x01 )
	{
		// load the registry
		DWORD t_dwDNSOverWINS = t_fDNSOverWINS ;
		t_oRegNBTParams.SetCurrentKeyValue( RVAL_DNS_ENABLE_WINS, t_dwDNSOverWINS ) ;
	}

	DWORD t_dwLMLookups ;
	if( t_dwValidBits & 0x02 )
	{
		t_dwLMLookups = t_fLMLookups ;
		t_oRegNBTParams.SetCurrentKeyValue( RVAL_DNS_ENABLE_LMHOST,	t_dwLMLookups ) ;
	}
	else
	{
		t_oRegNBTParams.GetCurrentKeyValue( RVAL_DNS_ENABLE_LMHOST,	t_dwLMLookups ) ;
	}


	if( t_dwValidBits & 0x04 )
	{
		// Try copy
		if( t_chWINSHostLookupFile.GetLength() )
		{
			CRegistry	t_oRegistry ;
			CHString	t_csBindingKey =  SERVICES_HOME ;
						t_csBindingKey += TCPIP_PARAMETERS ;

			// registry open
			HRESULT t_hRes = t_oRegistry.Open( HKEY_LOCAL_MACHINE, t_csBindingKey.GetBuffer( 0 ), KEY_READ  ) ;
			if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
			{
				return TO_CALLER ;
			}
			TCHAR t_szTemp[ 2 * MAX_PATH ] ;

			// database path
			CHString t_chsDBPath ;
			if( ERROR_SUCCESS == t_oRegistry.GetCurrentKeyValue( RVAL_DB_PATH, t_chsDBPath ) )
			{
				// expand system string(s)
				DWORD t_dwcount = ExpandEnvironmentStrings( t_chsDBPath.GetBuffer( 0 ), t_szTemp, 2 * MAX_PATH  ) ;
				if( !t_dwcount )
				{
					return a_rMParms.hSetResult( E_RET_SYSTEM_PATH_INVALID ) ;
				}
				t_chsDBPath = t_szTemp ;
			}
			else
			{
				// System path valid?
				if( !GetSystemDirectory( t_szTemp, 2 * MAX_PATH ) )	\
				{
					return a_rMParms.hSetResult( E_RET_SYSTEM_PATH_INVALID ) ;
				}
				t_chsDBPath = t_szTemp ;
				t_chsDBPath += LMHOSTS_PATH ;
			}
			t_chsDBPath += LMHOSTS_FILE ;

			// File valid?
			DWORD t_dwAttrib = GetFileAttributes( t_chWINSHostLookupFile.GetBuffer( 0 ) ) ;
			if( 0xFFFFFFFF == t_dwAttrib || FILE_ATTRIBUTE_DIRECTORY & t_dwAttrib )
			{
				return a_rMParms.hSetResult( E_RET_INVALID_FILE ) ;
			}

			// Copy ...
			if( !CopyFile( t_chWINSHostLookupFile.GetBuffer( 0 ), t_chsDBPath.GetBuffer( 0 ), FALSE ) )
			{
				// map error
				fMapResError( a_rMParms, GetLastError(), E_RET_FILE_COPY_FAILED ) ;
				return TO_CALLER ;
			}
		}
	}

	// Scope ID
	if( t_dwValidBits & 0x08 )
	{
		t_oRegNBTParams.SetCurrentKeyValue( RVAL_SCOPEID, t_chScopeID ) ;
	}

	E_RET t_eRet = E_RET_OK ;

#if NTONLY >= 5
	{
		// NDIS notification
		if( t_dwValidBits & ( 0x02 | 0x04 ) )
		{
			CNdisApi t_oNdisApi ;
			if( !t_oNdisApi.PnpUpdateNbtGlobal( t_dwLMLookups, t_dwValidBits & 0x04 ) )
			{
				t_eRet = E_RET_OK_REBOOT_REQUIRED ;
			}
		}
	}
#else
	{
		t_eRet = E_RET_OK_REBOOT_REQUIRED ;
	}
#endif

	return a_rMParms.hSetResult( t_eRet ) ;
#endif
}

/*******************************************************************
    NAME:       hGetNtIpSec

    SYNOPSIS:   Retrieves all IP Security settings from the registry

    ENTRY:      CInstance

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

#ifdef NTONLY
HRESULT CWin32NetworkAdapterConfig::hGetNtIpSec( CInstance *a_pInst, LPCTSTR a_szKey )
{
	DWORD		t_dwSecurityEnabled		= FALSE ;
	SAFEARRAY	*t_PermitTCPPorts		= NULL ;
	SAFEARRAY	*t_PermitUDPPorts		= NULL ;
	SAFEARRAY	*t_PermitIPProtocols	= NULL ;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acTCPPorts( &t_PermitTCPPorts ) ;
	saAutoClean acUDPPorts( &t_PermitUDPPorts ) ;
	saAutoClean acTCPProto( &t_PermitIPProtocols ) ;

	CRegistry	t_oTcpipReg;
	CHString	t_chsTcpipKey =  SERVICES_HOME ;
				t_chsTcpipKey += TCPIP_PARAMETERS ;

	// tcpip registry open
	LONG t_lRes = t_oTcpipReg.Open( HKEY_LOCAL_MACHINE, t_chsTcpipKey.GetBuffer( 0 ), KEY_READ  ) ;

	// on error map to WBEM
	HRESULT t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	// Global security setting
	t_dwSecurityEnabled = FALSE ;
	t_oTcpipReg.GetCurrentKeyValue( RVAL_SECURITY_ENABLE, t_dwSecurityEnabled ) ;

	// update the instance
	if(	!a_pInst->Setbool( IP_SECURITY_ENABLED, (bool)( t_dwSecurityEnabled ? true : false ) ) )
	{
		return WBEM_E_FAILED ;
	}

	CRegistry t_oRegistry;
	t_lRes = t_oRegistry.Open( HKEY_LOCAL_MACHINE, a_szKey, KEY_READ ) ;

	// on error map to WBEM
	t_hError = WinErrorToWBEMhResult( t_lRes ) ;
	if( WBEM_S_NO_ERROR != t_hError )
	{
		return t_hError;
	}

	RegGetStringArray( t_oRegistry, RVAL_SECURITY_TCP, &t_PermitTCPPorts, '\n' ) ;
	RegGetStringArray( t_oRegistry, RVAL_SECURITY_UDP, &t_PermitUDPPorts, '\n' ) ;
	RegGetStringArray( t_oRegistry, RVAL_SECURITY_IP, &t_PermitIPProtocols, '\n' ) ;

	// update the instance
	VARIANT t_vValue;

	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_PermitTCPPorts ;
	if( !a_pInst->SetVariant( PERMIT_TCP_PORTS, t_vValue ) )
	{
		return WBEM_E_FAILED ;
	}

	V_VT( &t_vValue) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_PermitUDPPorts ;
	if( !a_pInst->SetVariant( PERMIT_UDP_PORTS, t_vValue ) )
	{
		return WBEM_E_FAILED ;
	}

	V_VT( &t_vValue ) = VT_BSTR | VT_ARRAY; V_ARRAY( &t_vValue ) = t_PermitIPProtocols ;
	if( !a_pInst->SetVariant( PERMIT_IP_PROTOCOLS, t_vValue ) )
	{
		return WBEM_E_FAILED ;
	}

	return S_OK ;
}
#endif


/*******************************************************************
    NAME:       hEnableIPFilterSec

    SYNOPSIS:   Enables or disables IP Security across all IP bound adapters

    ENTRY:      CMParms

  	NOTES:		This is a static, instance independent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableIPFilterSec( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
		return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY
	CRegistry	t_oReg;
	CHString	t_chsSKey =  SERVICES_HOME ;
				t_chsSKey += TCPIP_PARAMETERS ;

	bool t_fIP_SecEnabled ;

	// IP security enabled globally?
	if( !a_rMParms.pInParams() ||
		!a_rMParms.pInParams()->Getbool( IP_SECURITY_ENABLED, t_fIP_SecEnabled ) )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// registry open
	HRESULT t_hRes = t_oReg.Open(HKEY_LOCAL_MACHINE, t_chsSKey.GetBuffer( 0 ), KEY_WRITE  ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER;
	}
	// load the registry
	DWORD t_dwSecurityEnabled = t_fIP_SecEnabled ;
	if( ERROR_SUCCESS != t_oReg.SetCurrentKeyValue( RVAL_SECURITY_ENABLE, t_dwSecurityEnabled ) )
	{
		return a_rMParms.hSetResult(E_RET_REGISTRY_FAILURE ) ;
	}

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hEnableIPSec

    SYNOPSIS:   Sets all IP Security properties to the registry

    ENTRY:      CMParms via CInstance depending on the context of the call

  	NOTES:		This is a non-static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hEnableIPSec( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED  ) ;
#endif

#ifdef NTONLY
	E_RET		t_eRet ;
	SAFEARRAY	*t_PermitTCPPorts		= NULL ;
	SAFEARRAY	*t_PermitUDPPorts		= NULL ;
	SAFEARRAY	*t_PermitIPProtocols	= NULL ;

	// register for stack scope cleanup of SAFEARRAYs
	saAutoClean acTCPPorts( &t_PermitTCPPorts ) ;
	saAutoClean acUDPPorts( &t_PermitUDPPorts ) ;
	saAutoClean acTCPProto( &t_PermitIPProtocols ) ;

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}
	// collect the instance
	GetObject( a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	//	retrieve the permited TCP ports
	if(	a_rMParms.pInParams()->GetStringArray( PERMIT_TCP_PORTS, t_PermitTCPPorts ) )
	{
		// validate
		t_eRet = eValidateIPSecParms( t_PermitTCPPorts, 65535 ) ;

		if( E_RET_OK != t_eRet )
		{
			return a_rMParms.hSetResult( t_eRet ) ;
		}
	}

	//	retrieve the permited UDP ports
	if(	a_rMParms.pInParams()->GetStringArray( PERMIT_UDP_PORTS, t_PermitUDPPorts ) )
	{
		// validate
		t_eRet = eValidateIPSecParms( t_PermitUDPPorts, 65535 ) ;

		if( E_RET_OK != t_eRet )
		{
			return a_rMParms.hSetResult( t_eRet ) ;
		}
	}

	//	retrieve the permited IP protocols
	if(	a_rMParms.pInParams()->GetStringArray( PERMIT_IP_PROTOCOLS, t_PermitIPProtocols ) )
	{
		// validate
		t_eRet = eValidateIPSecParms( t_PermitIPProtocols, 255 ) ;

		if( E_RET_OK != t_eRet )
		{
			return a_rMParms.hSetResult( t_eRet ) ;
		}
	}

	// on empty call
	if( !t_PermitTCPPorts && !t_PermitUDPPorts && !t_PermitIPProtocols )
	{
		return a_rMParms.hSetResult(E_RET_INVALID_SECURITY_PARM ) ;
	}

	// OK to update, save to the registry
	CRegistry t_oRegPut ;

	// extract the index key
	DWORD t_dwIndex ;
	if(	!a_rMParms.pInst()->GetDWORD(_T("Index"), t_dwIndex) )
	{
		return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// Registry open
	CHString t_chsRegKey;
	CHString t_chsLink;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;
	}

	HRESULT t_hRes = t_oRegPut.Open( HKEY_LOCAL_MACHINE, t_chsRegKey, KEY_WRITE  ) ;
	if( fMapResError( a_rMParms, t_hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER ;
	}

	if( t_PermitTCPPorts )
	{
		if( ERROR_SUCCESS != RegPutStringArray( t_oRegPut, RVAL_SECURITY_TCP, *t_PermitTCPPorts, NULL ) )
		{
			return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
		}
	}

	if( t_PermitUDPPorts )
	{
		if( ERROR_SUCCESS != RegPutStringArray( t_oRegPut, RVAL_SECURITY_UDP, *t_PermitUDPPorts, NULL ) )
		{
			return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
		}
	}

	if( t_PermitIPProtocols )
	{
		if(	ERROR_SUCCESS != RegPutStringArray( t_oRegPut, RVAL_SECURITY_IP, *t_PermitIPProtocols, NULL ) )
		{
			return a_rMParms.hSetResult( E_RET_REGISTRY_FAILURE  ) ;
		}
	}

	// TODO: notifications? what else ...
	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       hDisableIPSec

    SYNOPSIS:   Sets all IP Security properties to the registry

    ENTRY:      CMParms via CInstance depending on the context of the call

  	NOTES:		This is a non-static, instance dependent method call

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

HRESULT CWin32NetworkAdapterConfig::hDisableIPSec( CMParms &a_rMParms )
{
#ifdef WIN9XONLY
    return a_rMParms.hSetResult( E_RET_UNSUPPORTED ) ;
#endif

#ifdef NTONLY

	// nonstatic method requires an instance
	if( !a_rMParms.pInst() )
	{
		return a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
	}

	// collect the instance
	GetObject(a_rMParms.pInst() ) ;

	// IP must be enabled and bound to this adapter
	if( !fIsIPEnabled( a_rMParms ) )
	{
		return S_OK ;
	}

	// OK to update, save to the registry

	// extract the index key
	DWORD t_dwIndex ;
	if(	!a_rMParms.pInst()->GetDWORD( _T("Index"), t_dwIndex) )
	{
		return a_rMParms.hSetResult(E_RET_INSTANCE_CALL_FAILED ) ;
	}

	// Registry open
	CHString t_chsRegKey ;
	CHString t_chsLink ;
	if( !fGetNtTcpRegAdapterKey( t_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
        return a_rMParms.hSetResult( E_RET_OBJECT_NOT_FOUND ) ;
	}

	CRegistry t_oRegPut ;
	HRESULT hRes = t_oRegPut.Open(HKEY_LOCAL_MACHINE, t_chsRegKey, KEY_WRITE ) ;
	if( fMapResError( a_rMParms, hRes, E_RET_REGISTRY_FAILURE ) )
	{
		return TO_CALLER ;
	}

	// load the registry

	CHString		t_chsZero( _T("0") ) ;
	CHStringArray	t_chsaZero ;
					t_chsaZero.Add( t_chsZero ) ;

	t_oRegPut.SetCurrentKeyValue( RVAL_SECURITY_TCP, t_chsaZero ) ;
	t_oRegPut.SetCurrentKeyValue( RVAL_SECURITY_UDP, t_chsaZero ) ;
	t_oRegPut.SetCurrentKeyValue( RVAL_SECURITY_IP, t_chsaZero ) ;

	return a_rMParms.hSetResult( E_RET_OK_REBOOT_REQUIRED ) ;
#endif
}

/*******************************************************************
    NAME:       eValidateIPSecParms

    SYNOPSIS:   Tests each IP security parm for validity

    ENTRY:      SAFEARRAY*

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

E_RET CWin32NetworkAdapterConfig::eValidateIPSecParms( SAFEARRAY * a_IpArray, int a_iMax )
{
	// Get the IP bounds
	LONG t_uLBound = 0 ;
	LONG t_uUBound = 0 ;

	if( 1 != SafeArrayGetDim( a_IpArray ) )
	{
		return E_RET_INVALID_SECURITY_PARM ;
	}

	if( S_OK != SafeArrayGetLBound( a_IpArray, 1, &t_uLBound ) ||
		S_OK != SafeArrayGetUBound( a_IpArray, 1, &t_uUBound ) )
	{
		return E_RET_INVALID_SECURITY_PARM ;
	}

	// validate the IP ports
	for( LONG t_ldx = t_uLBound; t_ldx <= t_uUBound; t_ldx++ )
	{
		BSTR t_bsParm = NULL ;

		SafeArrayGetElement( a_IpArray,	&t_ldx, &t_bsParm ) ;
		bstr_t t_bstrParm( t_bsParm, FALSE ) ;

		int t_iLen  = t_bstrParm.length() ;

		// indicates no ports
		if( !t_iLen )
		{
			return E_RET_OK;
		}

		int t_iSpan = wcsspn( (wchar_t*)t_bstrParm, L"0123456789" ) ;
		if( t_iLen != t_iSpan )
		{
			return E_RET_PARAMETER_BOUNDS_ERROR ;
		}

		DWORD t_dwParm = _wtol( (wchar_t*)t_bstrParm ) ;

		// Single zero disables security
		if( ( t_uLBound == t_ldx ) && ( '0' == (char) t_dwParm ) )
		{
			return E_RET_OK ;
		}

		// max port or protocol size
		if( ( a_iMax < t_dwParm ) )
		{
			return E_RET_PARAMETER_BOUNDS_ERROR ;
		}
	}
	return E_RET_OK ;
}


/*******************************************************************
    NAME:       hValidateIPGateways

    SYNOPSIS:   Tests each IP gateway in the passed array for validity

    ENTRY:     	CMParms&,	SAFEARRAY*

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::fValidateIPGateways(

CMParms &a_rMParms,
SAFEARRAY *a_IpGatewayArray,
SAFEARRAY **a_CostMetric )
{
	// Get the Gateway bounds
	LONG t_uGatewayLBound = 0 ;
	LONG t_uGatewayUBound = 0 ;

	if( 1 != SafeArrayGetDim( a_IpGatewayArray ) )
	{
		a_rMParms.hSetResult( E_RET_GATEWAY_IP_INVALID ) ;
		return FALSE;
	}

	if( !fValidateIPs( a_IpGatewayArray ) )
	{
		a_rMParms.hSetResult( E_RET_GATEWAY_IP_INVALID ) ;
		return FALSE ;
	}

	if( S_OK != SafeArrayGetLBound( a_IpGatewayArray, 1, &t_uGatewayLBound ) ||
		S_OK != SafeArrayGetUBound( a_IpGatewayArray, 1, &t_uGatewayUBound ) )
	{
		a_rMParms.hSetResult( E_RET_GATEWAY_IP_INVALID ) ;
		return FALSE ;
	}

	// Gateway maximum is 5
	if( 5 < t_uGatewayUBound - t_uGatewayLBound + 1 )
	{
		a_rMParms.hSetResult( E_RET_MORE_THAN_FIVE_GATEWAYS ) ;
		return FALSE ;
	}

	// cost metric
	if( IsWinNT5() )
	{
		UINT t_uCostMetricElements	= 0 ;
		UINT t_uGatewayElements		= t_uGatewayUBound - t_uGatewayLBound + 1;

		// Get the cost metric bounds
		LONG t_uCostLBound = 0 ;
		LONG t_uCostUBound = 0 ;

		// either validate it
		if( *a_CostMetric )
		{
			if( S_OK != SafeArrayGetLBound( *a_CostMetric, 1, &t_uCostLBound ) ||
				S_OK != SafeArrayGetUBound( *a_CostMetric, 1, &t_uCostUBound ) )
			{
				a_rMParms.hSetResult( E_RET_INPARM_FAILURE ) ;
				return FALSE ;
			}
			t_uCostMetricElements = t_uCostUBound - t_uCostLBound + 1;

			// one to one correspondence
			if( t_uCostMetricElements != t_uGatewayElements )
			{
				a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
				return FALSE ;
			}

			// validate the cost metric array
			DWORD t_dwIndex = 0 ;
			for( LONG t_lIndex = t_uCostLBound; t_lIndex <= t_uCostUBound; t_lIndex++ )
			{
				DWORD t_dwCostMetric ;

				SafeArrayGetElement( *a_CostMetric,	&t_lIndex, &t_dwCostMetric ) ;

				if( !t_dwCostMetric || ( 9999 < t_dwCostMetric ) )
				{
					a_rMParms.hSetResult( E_RET_PARAMETER_BOUNDS_ERROR ) ;
					return FALSE ;
				}
			}
		}
		// or build it
		else
		{
			SAFEARRAYBOUND t_rgsabound[ 1 ] ;
			long t_ix[ 1 ] ;

			t_rgsabound->cElements	= t_uGatewayElements ;
			t_rgsabound->lLbound	= 0 ;

			if( !( *a_CostMetric = SafeArrayCreate( VT_I4, 1, t_rgsabound ) ) )
			{
				throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
			}

			UINT t_uMetric = 1 ;
			for( UINT t_u = 0; t_u < t_uGatewayElements; t_u++ )
			{
				t_ix[ 0 ] = t_u ;
				SafeArrayPutElement( *a_CostMetric, &t_ix[0], &t_uMetric ) ;
			}
		}
	}

	return TRUE ;
}
#endif

/*******************************************************************
    NAME:       hValidateIPs

    SYNOPSIS:   Tests each IP in the passed array for validity

    ENTRY:      CMParms&,	SAFEARRAY*

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fValidateIPs( SAFEARRAY *a_IpArray )
{
	// Get the IP bounds
	LONG t_uLBound = 0 ;
	LONG t_uUBound = 0 ;

	if( 1 != SafeArrayGetDim( a_IpArray ) )
	{
		return FALSE;
	}

	if( S_OK != SafeArrayGetLBound( a_IpArray, 1, &t_uLBound ) ||
		S_OK != SafeArrayGetUBound( a_IpArray, 1, &t_uUBound ) )
	{
		return FALSE ;
	}

	// validate the IPs
	for( LONG t_ldx = t_uLBound; t_ldx <= t_uUBound; t_ldx++ )
	{
		BSTR t_bsIP = NULL ;

		SafeArrayGetElement( a_IpArray,	&t_ldx, &t_bsIP  ) ;
		bstr_t t_bstrIP( t_bsIP, FALSE ) ;

		if( !fIsValidIP( CHString( (wchar_t*) t_bstrIP ) ) )
		{
			return FALSE ;
		}
	}
	return TRUE ;
}

/*******************************************************************
    NAME:       fIsValidIP

    SYNOPSIS:   Determine if a passed IP is valid

    ENTRY:      CHString&

    HISTORY:
********************************************************************/

BOOL CWin32NetworkAdapterConfig::fIsValidIP( CHString &a_strIP )
{
	DWORD t_ardwIP[ 4 ] ;

	if( !fGetNodeNum( a_strIP, t_ardwIP ) )
	{
		return FALSE ;
	}

	// Most significant node must be 1 <= x <= 223
	if( ( 0 == t_ardwIP[ 0 ] ) || ( 223 < t_ardwIP[ 0 ] ) )
	{
		return FALSE ;
	}

	// no other outrageous stuff
	for( int t_i = 1; t_i < 4; t_i++ )
	{
		if( 255 < t_ardwIP[ t_i ] )
		{
			return FALSE ;
		}
	}

	return TRUE;
}

/*******************************************************************
    NAME:       fIsIPEnabled

    SYNOPSIS:   Determines if IP is enabled for the specific instance

    ENTRY:      CMParms		:

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fIsIPEnabled( CMParms &a_rMParms )
{
	bool t_fIP_Enabled = false ;

	// IP stack enabled on this adapter?
	if( !a_rMParms.pInst() ||
		!a_rMParms.pInst()->Getbool( L"IPEnabled", t_fIP_Enabled ) )
	{
		a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
		return FALSE ;
	}

	if( !t_fIP_Enabled )
	{
		a_rMParms.hSetResult( E_RET_IP_NOT_ENABLED_ON_ADAPTER ) ;
		return FALSE ;
	}
	return TRUE ;
}

/*******************************************************************
    NAME:       fIsDhcpEnabled

    SYNOPSIS:   Determines if DHCP is enabled for the specific instance

    ENTRY:      CMParms		:

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fIsDhcpEnabled( CMParms &a_rMParms )
{
	bool t_fDHCP_Enabled = false ;

	// DHCP enabled on this adapter?
	if( !a_rMParms.pInst() ||
		!a_rMParms.pInst()->Getbool( L"DHCPEnabled", t_fDHCP_Enabled ) )
	{
		a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
		return FALSE ;
	}

	if( !t_fDHCP_Enabled )
	{
		a_rMParms.hSetResult( E_RET_DHCP_NOT_ENABLED_ON_ADAPTER ) ;
		return FALSE ;
	}
	return TRUE ;
}

/*******************************************************************
    NAME:       fIsIPXEnabled

    SYNOPSIS:   Determines if IPX is enabled for the specific instance

    ENTRY:      CMParms		:

    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fIsIPXEnabled( CMParms &a_rMParms )
{
	bool t_fIPX_Enabled = false ;

	// IP stack enabled on this adapter?
	if( !a_rMParms.pInst() ||
		!a_rMParms.pInst()->Getbool( L"IPXEnabled", t_fIPX_Enabled ) )
	{
		a_rMParms.hSetResult( E_RET_INSTANCE_CALL_FAILED ) ;
		return FALSE;
	}

	if( !t_fIPX_Enabled )
	{
		a_rMParms.hSetResult( E_RET_IPX_NOT_ENABLED_ON_ADAPTER ) ;
		return FALSE ;
	}
	return TRUE ;
}

//
DWORD CWin32NetworkAdapterConfig::dwEnableService( LPCTSTR a_lpServiceName, BOOL a_fEnable )
{
	DWORD		t_dwError		= ERROR_SUCCESS ;
	BOOL		t_fCheckError	= TRUE ;
	SC_HANDLE	t_hSCManager	= NULL ;
	SC_HANDLE	t_hService		= NULL ;
	SC_LOCK		t_hSMLock		= NULL ;

	try
	{
		do	{	// breakout loop

			if( !( t_hSCManager = OpenSCManager( NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS ) ) )
			{
				break ;
			}

			if( !( t_hSMLock = LockServiceDatabase( t_hSCManager ) ) )
			{
				break;
			}

			if( !( t_hService = OpenService(	t_hSCManager,
												a_lpServiceName,
												GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE ) ) )
			{
				break;
			}

			// change the startup configuration for this service
			if ( !ChangeServiceConfig(	t_hService,
										SERVICE_NO_CHANGE,
										a_fEnable ? SERVICE_AUTO_START : SERVICE_DISABLED,
										SERVICE_NO_CHANGE,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL ) )
			{
				 break;
			}

			t_fCheckError = FALSE ;

		} while( FALSE ) ;

		if( t_fCheckError )
		{
			t_dwError = GetLastError() ;
		}

	}
	catch( ... )
	{
		if( t_hSMLock )
		{
			UnlockServiceDatabase( t_hSMLock ) ;
		}
		if( t_hSCManager )
		{
			CloseServiceHandle( t_hSCManager ) ;
		}
		if( t_hService )
		{
			CloseServiceHandle( t_hService ) ;
		}

		throw ;
	}

	if( t_hSMLock )
	{
		if( !UnlockServiceDatabase( t_hSMLock ) )
		{
			t_dwError = GetLastError() ;
		}
		t_hSMLock = NULL ;
	}
	if( t_hSCManager )
	{
		if( !CloseServiceHandle( t_hSCManager ) )
		{
			t_dwError = GetLastError() ;
		}
		t_hSCManager = NULL ;
	}
	if( t_hService )
	{
		if( !CloseServiceHandle( t_hService ) )
		{
			t_dwError = GetLastError() ;
		}
		t_hService = NULL ;
	}

	return t_dwError ;
}

//
DWORD CWin32NetworkAdapterConfig::dwSendServiceControl( LPCTSTR a_lpServiceName, DWORD a_dwControl )
{
	DWORD		t_dwError		= ERROR_SUCCESS ;
	BOOL		t_fCheckError	= TRUE ;
	SC_HANDLE	t_hSCManager	= NULL ;
	SC_HANDLE	t_hService		= NULL ;

	try
	{
		do	{	// breakout loop

			if( !( t_hSCManager = OpenSCManager( NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS ) ) )
			{
				break ;
			}

			if( !( t_hService = OpenService(	t_hSCManager,
												a_lpServiceName,
												SERVICE_ALL_ACCESS ) ) )
			{
				break;
			}


			SERVICE_STATUS t_status ;
			if( !ControlService ( t_hService, a_dwControl, &t_status ) )
			{
				break;
			}

			t_fCheckError = FALSE ;

		} while( FALSE ) ;

		if( t_fCheckError )
		{
			t_dwError = GetLastError() ;
		}

	}
	catch( ... )
	{
		if( t_hSCManager )
		{
			CloseServiceHandle( t_hSCManager ) ;
		}
		if( t_hService )
		{
			CloseServiceHandle( t_hService ) ;
		}

		throw ;
	}

	if( t_hSCManager )
	{
		if( !CloseServiceHandle( t_hSCManager ) )
		{
			t_dwError = GetLastError() ;
		}
		t_hSCManager = NULL ;
	}
	if( t_hService )
	{
		if( !CloseServiceHandle( t_hService ) )
		{
			t_dwError = GetLastError() ;
		}
		t_hService = NULL ;
	}

	return t_dwError ;
}

/*******************************************************************
    NAME:       fMapResError

    SYNOPSIS:	tests and maps a HRESULT to a method error via the
				WBEM mapping.


    ENTRY:      CMParms &a_rMParms,		:
				LONG lError,			:
				E_RET eDefaultError		:


    HISTORY:
                  23-Jul-1998     Created
********************************************************************/
BOOL CWin32NetworkAdapterConfig::fMapResError( CMParms &a_rMParms, LONG a_lError, E_RET a_eDefaultError )
{
	HRESULT t_hError = WinErrorToWBEMhResult( a_lError ) ;

	switch ( t_hError )
	{
		case WBEM_S_NO_ERROR:	return FALSE ;

		default:
		case WBEM_E_FAILED:			{ a_rMParms.hSetResult( a_eDefaultError ) ;			break ; }
		case WBEM_E_ACCESS_DENIED:	{ a_rMParms.hSetResult(E_RET_ACCESS_DENIED ) ;		break ; }
		case WBEM_E_OUT_OF_MEMORY:	{ a_rMParms.hSetResult(E_RET_OUT_OF_MEMORY ) ;		break ; }
		case WBEM_E_ALREADY_EXISTS:	{ a_rMParms.hSetResult(E_RET_ALREADY_EXISTS ) ;		break ; }
		case WBEM_E_NOT_FOUND:		{ a_rMParms.hSetResult(E_RET_OBJECT_NOT_FOUND ) ;	break ; }
	}
	return TRUE ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  void CWin32NetworkAdapterConfig::vSetCaption( CInstance *a_pInst, CHString& rchsDesc, DWORD dwIndex, int iFormatSize )

 Description: Lays in the registry index instance id into the caption property.
			  Then concats the description
			  This will be used with the view provider to associacte WDM NDIS class instances
			  with an instance of this class

 Arguments:	a_pInst [IN], rchsDesc [IN], dwIndex [IN], iFormatSize [IN]
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					  02-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CWin32NetworkAdapterConfig::vSetCaption(	CInstance *a_pInst,
												CHString &a_rchsDesc,
												DWORD a_dwIndex,
												int a_iFormatSize )
{
	CHString t_chsFormat;
			 t_chsFormat.Format( L"[%%0%uu] %%s", a_iFormatSize  ) ;

	CHString t_chsCaption;
			 t_chsCaption.Format(	t_chsFormat, a_dwIndex, a_rchsDesc  ) ;

	a_pInst->SetCHString( IDS_Caption, t_chsCaption  ) ;

	return;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32NetworkAdapterConfig::GetSettingID( CInstance *a_pInst, DWORD a_dwIndex )

 Description: populates CIM's setting ID

 Arguments:	a_pInst [IN], a_dwIndex [IN]

 Notes:		under NT5 this will be the adapter GUID
			under NT4 this will be the adapter service name
			under 9x  this will be the adapter index ID
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					  19-May-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

BOOL CWin32NetworkAdapterConfig::GetSettingID( CInstance *a_pInst, DWORD a_dwIndex )
{
	BOOL		t_fRet = FALSE;
	CHString	t_chsLink ;

#ifdef NTONLY
	CHString t_chsRegKey ;

	if( fGetNtTcpRegAdapterKey( a_dwIndex, t_chsRegKey, t_chsLink ) )
	{
		t_fRet = TRUE ;
	}
    else
    {
        LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
    }

#else
	t_chsLink.Format( L"%04u", a_dwIndex  ) ;
	t_fRet = TRUE ;
#endif

	if( t_fRet )
	{
		a_pInst->SetCharSplat( L"SettingID", t_chsLink ) ;
	}

	return t_fRet ;
}

/*******************************************************************
    NAME:       fMapIndextoKey

    SYNOPSIS:   map the class key to the registry version of the adapter identifier

  	NOTES:

    ENTRY:       DWORD a_dwIndex, CHString &a_chsLinkKey

    HISTORY:
                  1-July-1999     Created
********************************************************************/
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::fMapIndextoKey(

DWORD a_dwIndex,
CHString &a_chsLinkKey
)
{
    CHString t_chsLinkField ;
	CHString t_chsAdapterKey ;
	CHString t_chsInstance ;
	BOOL	 t_fRc = FALSE ;

	if( IsWinNT5() )
	{
		t_chsLinkField = _T("NetCfgInstanceID" ) ;
		t_chsAdapterKey = _T("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\" ) ;
		t_chsInstance.Format( _T("%04u"), a_dwIndex  ) ;
	}
	else	// NT4 and below
	{
		t_chsLinkField = _T("ServiceName" ) ;
		t_chsAdapterKey = _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards\\" ) ;
		t_chsInstance.Format( _T("%u"), a_dwIndex ) ;
	}

	t_chsAdapterKey += t_chsInstance ;

	// obtain the link key for targeting the tcp adapter
	CRegistry t_Reg;
	if( t_Reg.OpenLocalMachineKeyAndReadValue( t_chsAdapterKey, t_chsLinkField, a_chsLinkKey ) == ERROR_SUCCESS )
	{
		t_fRc = TRUE ;
	}
    else
    {
        LogErrorMessage4(
            L"Failed to open registry key. \r\nchsAdapterKey=%s\r\nchsLinkField=%s\r\nchsLinkKey=%s",
            (LPCWSTR)t_chsAdapterKey,
            (LPCWSTR)t_chsLinkField,
            (LPCWSTR)a_chsLinkKey);
    }

	return t_fRc ;
}
#endif
/*******************************************************************
    NAME:       fGetNtTcpRegAdapterKey

    SYNOPSIS:   develops a registry path to the TCP adapter by index

  	NOTES:

    ENTRY:       DWORD dwIndex, CHString& chsRegKey, CHString& chsLinkKey

    HISTORY:
                  30-Nov-1998     Created
********************************************************************/
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::fGetNtTcpRegAdapterKey(	DWORD a_dwIndex,
															CHString &a_chsRegKey,
															CHString &a_chsLinkKey )
{
	BOOL t_fRc = FALSE ;

	if( fMapIndextoKey(	a_dwIndex, a_chsLinkKey ) )
	{
		if( IsWinNT5() )
		{
			a_chsRegKey = _T("SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\" ) ;
			a_chsRegKey += a_chsLinkKey;
		}
		else	// NT4 and below
		{
			a_chsRegKey = _T("System\\CurrentControlSet\\Services\\" ) ;
			a_chsRegKey += a_chsLinkKey;
			a_chsRegKey += PARAMETERS_TCPIP ;
		}

		t_fRc = TRUE ;
	}

	return t_fRc ;
}
#endif

/*******************************************************************
    NAME:       IsConfigurableTcpInterface

    SYNOPSIS:   Determines if a w2k interface is configurable
				by attempting to locate the interace in the Adapters section
				of the TCP

  	NOTES:		NdisWanIp will not show up as configurable, by design.

    ENTRY:      CHString a_chsLink

    HISTORY:
                  17-Jun-1999     Created
********************************************************************/
#ifdef NTONLY
bool CWin32NetworkAdapterConfig::IsConfigurableTcpInterface( CHString a_chsLink )
{
	bool		t_fRet = false ;
	CRegistry	t_Reg;
	CHString	t_chsRegParmKey ;

	if( IsWinNT5() )
	{
		t_chsRegParmKey = _T("SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters\\" ) ;
		t_chsRegParmKey	+= a_chsLink;
	}
	else
	{
		t_chsRegParmKey = _T("SYSTEM\\CurrentControlSet\\Services\\" ) ;
		t_chsRegParmKey	+= a_chsLink;
		t_chsRegParmKey	+= _T("\\Parameters\\Tcpip" ) ;
	}

	if( t_Reg.Open(HKEY_LOCAL_MACHINE, t_chsRegParmKey, KEY_READ ) == ERROR_SUCCESS )
	{
		t_fRet = true ;
	}

	return t_fRet ;
}
#endif

/*******************************************************************
    NAME:       fGetNtIpxRegAdapterKey

    SYNOPSIS:   develops a registry path to the IPX adapter by index

  	NOTES:

    ENTRY:       DWORD dwIndex, CHString& chsRegKey
    HISTORY:
                  03-MAR-1999     Created
********************************************************************/
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::fGetNtIpxRegAdapterKey(	DWORD a_dwIndex,
															CHString &a_csIPXNetBindingKey,
															CHString &a_chsLink )
{
	BOOL t_fRc = FALSE ;

	// retrieve the adapter identifier
	if( fMapIndextoKey( a_dwIndex, a_chsLink ) )
	{
		// build up the registry key
		a_csIPXNetBindingKey =  SERVICES_HOME ;
		a_csIPXNetBindingKey += IPX ;

		if( IsWinNT5() )
		{
			 a_csIPXNetBindingKey += _T("\\Parameters\\Adapters\\") ;
		}
		else	// NT4 and below
		{
			 a_csIPXNetBindingKey += NETCONFIG ;
			 a_csIPXNetBindingKey += _T("\\" ) ;
		}
		a_csIPXNetBindingKey += a_chsLink ;

		t_fRc = TRUE ;
	}

	return t_fRc ;
}
#endif

/*******************************************************************
    NAME:       fGetNtNBRegAdapterKey

    SYNOPSIS:   develops a registry path to the NetBios adapter by index

  	NOTES:

    ENTRY:       DWORD dwIndex, CHString& chsRegKey
    HISTORY:
                  03-MAR-1999     Created
********************************************************************/
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::fGetNtNBRegAdapterKey(	DWORD a_dwIndex,
														CHString &a_csNBBindingKey,
														CHString &a_chsLink )
{
	BOOL t_fRc = FALSE ;

	// retrieve the adapter identifier
	CHString t_chsKey ;
	if( fMapIndextoKey( a_dwIndex, t_chsKey ) )
	{
		// build up the registry key
		a_csNBBindingKey =  SERVICES_HOME ;

		if( IsWinNT5() )
		{
			 a_csNBBindingKey	+= _T("\\NetBT\\Parameters\\Interfaces\\") ;
			 a_chsLink			= _T("Tcpip_") ;
		}
		else	// NT4 and below
		{
			a_csNBBindingKey += NETBT_ADAPTERS ;
			a_csNBBindingKey += _T("\\" ) ;

			a_chsLink.Empty() ;
		}
		a_chsLink			+= t_chsKey ;
		a_csNBBindingKey	+= a_chsLink ;

		t_fRc = TRUE ;
	}

	return t_fRc ;
}
#endif


/*******************************************************************
    NAME:       ResetGateways

    SYNOPSIS:   makes sure that the registry values for default gateway
                are null.  c

  	NOTES:

    ENTRY:       
    HISTORY:
                 
********************************************************************/
#ifdef NTONLY
BOOL CWin32NetworkAdapterConfig::ResetGateways(CInstance *pInst)
{
    BOOL fRet = TRUE;
    if(!pInst)
    {
        fRet = FALSE;
    }

    if(fRet)
    {
        DWORD dwIndex;
	    if(!pInst->GetDWORD(L"Index", dwIndex))
	    {
		    fRet = FALSE;
	    }

        if(fRet)
        {
	        // load the registry
            SAFEARRAYBOUND rgsabound[1];
	        rgsabound[0].cElements = 1;
	        rgsabound[0].lLbound = 0;
            SAFEARRAY *psaIpGatewayArray = NULL;
            psaIpGatewayArray = ::SafeArrayCreate(
                                VT_BSTR, 
                                1, 
                                rgsabound);

	        // register for stack scope cleanup of SAFEARRAYs
	        if(psaIpGatewayArray)
            {
                saAutoClean acGateway(&psaIpGatewayArray);
                bstr_t bstrtEmptyStr(L"");
                long index = 0;

				if(SUCCEEDED(::SafeArrayPutElement(
                    psaIpGatewayArray, 
                    &index, 
                    (void*)(BSTR)bstrtEmptyStr)))
                {
                    // retrieve the adapter identifier
	                CHString chsRegKey;
	                CHString chsLink;
	                
                    if(!fGetNtTcpRegAdapterKey(
                        dwIndex, 
                        chsRegKey, 
                        chsLink))
	                {
		                LogErrorMessage(L"Call to fGetNtTcpRegAdapterKey failed");
                        fRet = FALSE;
	                }

                    if(fRet)
                    {
	                    CRegistry RegTcpInterface;
	                    
                        HRESULT	hRes = RegTcpInterface.Open(
                            HKEY_LOCAL_MACHINE, 
                            chsRegKey, 
                            KEY_WRITE);
	                    
                        if(FAILED(hRes))
	                    {
		                    fRet = FALSE;
	                    }

                        if(fRet)
                        {
	                        if(ERROR_SUCCESS != RegPutStringArray(
                                RegTcpInterface, 
                                L"DefaultGateway", 
                                *psaIpGatewayArray, 
                                NULL))
	                        {
		                        fRet = FALSE;
	                        }        
                        }
                    }

                    // Set the NT 4 area...
                    if(fRet)
                    {
                        CRegistry oNT4Reg ;
		                CHString csBindingKey = SERVICES_HOME;
					             csBindingKey += L"\\";
					             csBindingKey += chsLink;
					             csBindingKey += PARAMETERS_TCPIP;

		                // insure the key is there on open. 
                        // not an error if it isn't...
		                if(SUCCEEDED(oNT4Reg.CreateOpen( 
                            HKEY_LOCAL_MACHINE, 
                            csBindingKey.GetBuffer(0))))
		                {
		                    // load the registry entry
                            if(ERROR_SUCCESS != RegPutStringArray(
                                oNT4Reg, 
                                L"DefaultGateway", 
                                *psaIpGatewayArray, 
                                NULL))
		                    {
			                    fRet = FALSE;
		                    }
                        }
                    }
                }
                else
                {
                    fRet = FALSE;
                }
            }
        }
    }

    return fRet;
}
#endif


/*******************************************************************
    NAME:       CDhcpIP_InstructionList::BuildStaticIPInstructionList

    SYNOPSIS:   builds a static IP instruction list for DHCP notification

  	NOTES:

    ENTRY:
    HISTORY:
                  02-May-1999     Created
********************************************************************/
E_RET CDhcpIP_InstructionList::BuildStaticIPInstructionList(

CMParms				&a_rMParms,
SAFEARRAY			*a_IpArray,
SAFEARRAY			*a_MaskArray,
CRegistry			&a_Registry,
bool				t_fDHCPCurrentlyActive )
{
	E_RET	t_eMethodError	= E_RET_OK ;
	BSTR	t_bsIP			= NULL ;
	BSTR	t_bsMask		= NULL ;

	// new element bounds
	LONG t_lIpLbound = 0;
	LONG t_lIpUbound = 0;
	if( S_OK != SafeArrayGetLBound( a_IpArray, 1, &t_lIpLbound ) ||
		S_OK != SafeArrayGetUBound( a_IpArray, 1, &t_lIpUbound ) )
	{
		return E_RET_INPARM_FAILURE ;
	}

	// DHCP -> Static
	if( t_fDHCPCurrentlyActive )
	{

		DWORD t_dwIndex = 0 ;
		for( LONG t_lIndex = t_lIpLbound; t_lIndex <= t_lIpUbound; t_lIndex++ )
		{
			// new IP
			SafeArrayGetElement( a_IpArray,	&t_lIndex, &t_bsIP ) ;

			// new mask
			SafeArrayGetElement( a_MaskArray, &t_lIndex, &t_bsMask ) ;

			SERVICE_ENABLE	t_DhcpFlag		= t_dwIndex ? IgnoreFlag	: DhcpDisable ;
			DWORD			t_IndexAction	= t_dwIndex ? 0xFFFF		: 0 ;

			AddDhcpInstruction( t_bsIP, t_bsMask, TRUE, t_IndexAction, t_DhcpFlag ) ;

			t_dwIndex++ ;
		}
	}

	// Static -> Static
	else
	{
		// old lists
		CHStringArray t_RegIPList ;
		CHStringArray t_RegMaskList ;
		if( ERROR_SUCCESS != a_Registry.GetCurrentKeyValue( L"IpAddress", t_RegIPList ) ||
			ERROR_SUCCESS != a_Registry.GetCurrentKeyValue( L"SubnetMask", t_RegMaskList ) )
		{
			return E_RET_REGISTRY_FAILURE ;
		}

		LONG t_OldCount = t_RegIPList.GetSize() ;
		LONG t_NewCount = ( t_lIpUbound - t_lIpLbound ) + 1 ;

		// seek out the first update change
		for( int t_FirstChange = 0; t_FirstChange < min( t_OldCount, t_NewCount ); t_FirstChange++ )
		{
			CHString t_chsOldIPAddress	= t_RegIPList.GetAt( t_FirstChange ) ;
			CHString t_chsOldIPMask		= t_RegMaskList.GetAt( t_FirstChange ) ;

			LONG t_index = t_lIpLbound + t_FirstChange;

			// new IP
			SafeArrayGetElement( a_IpArray,	&t_index, &t_bsIP ) ;

			// new mask
			SafeArrayGetElement( a_MaskArray, &t_index, &t_bsMask ) ;

			if( t_chsOldIPAddress.CompareNoCase( t_bsIP ) ||
				t_chsOldIPMask.CompareNoCase( t_bsMask ) )
			{
				break ;
			}

			// for registry update only
			AddDhcpInstruction( t_bsIP, t_bsMask, FALSE, t_FirstChange, IgnoreFlag ) ;
		}

		// NOTE: For items below t_FirstChange we can avoid tearing down the connection for
		//		 a specific IP by noting that the IP and mask have not changed in the update.
		//		 As soon as a change is noted all subsequent IPs and masks must be removed and
		//		 then added from the new list. The logic of plumbing stack addresses and other
		//		 anomolies in maintaining the IP/Mask list prevent the network team from
		//		 a more elegant solution ( in the W2k RTM timeframe ).

		// remove the old or possibly changing addresses, in decending order
		for( int i = t_OldCount - 1; i >= t_FirstChange; i-- )
		{
			AddDhcpInstruction( bstr_t(ZERO_ADDRESS), bstr_t(ZERO_ADDRESS), TRUE, i, IgnoreFlag ) ;
		}

		// now added in the new changing items
		for( i = t_FirstChange; i < t_NewCount; i++ )
		{
			LONG t_index = t_lIpLbound + i ;

			// new IP
			SafeArrayGetElement( a_IpArray,	&t_index, &t_bsIP ) ;

			// new mask
			SafeArrayGetElement( a_MaskArray, &t_index, &t_bsMask ) ;

			int t_IndexAction = i ? 0xFFFF : 0 ;

			AddDhcpInstruction( t_bsIP, t_bsMask, TRUE, t_IndexAction, IgnoreFlag ) ;
		}
	}
	return t_eMethodError ;
}

/*******************************************************************
    NAME:       CDhcpIP_InstructionList::Add

    SYNOPSIS:   adds a static IP instruction for DHCP notification

  	NOTES:

    ENTRY:
    HISTORY:
                  02-May-1999     Created
********************************************************************/

void CDhcpIP_InstructionList::AddDhcpInstruction(

BSTR a_bstrIPAddr,
BSTR a_bstrIPMask,
BOOL a_bIsNewAddress,
DWORD a_dwIndex,
SERVICE_ENABLE a_eDhcpFlag
 )
{
	CDhcpIP_Instruction *t_pIPInstruction = new CDhcpIP_Instruction ;
	
	try
	{
		t_pIPInstruction->chsIPAddress = a_bstrIPAddr ;
		t_pIPInstruction->chsIPMask	   = a_bstrIPMask ;

		t_pIPInstruction->dwIndex		= a_dwIndex ;
		t_pIPInstruction->bIsNewAddress	= a_bIsNewAddress ;
		t_pIPInstruction->eDhcpFlag		= a_eDhcpFlag ;

		//will only throw before adding the element so need to catch this also.
		Add( t_pIPInstruction ) ;
	}
	catch (...)
	{
		delete t_pIPInstruction;
		t_pIPInstruction = NULL;
		throw;
	}

}

//
CDhcpIP_InstructionList::~CDhcpIP_InstructionList()
{
	CDhcpIP_Instruction *t_pchsDel ;

	for( int t_iar = 0; t_iar < GetSize(); t_iar++ )
	{
		if( ( t_pchsDel = (CDhcpIP_Instruction*)GetAt( t_iar ) ) )
		{
			delete t_pchsDel ;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\netclient.h ===
//=================================================================

//

// NetClient.h -- Network client property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/25/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_NETWORK_CLIENT L"Win32_NetworkClient"

class CWin32NetCli ;

class CWin32NetCli:public Provider {

    public:
        // Constructor/destructor
        //=======================

        CWin32NetCli(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32NetCli() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
#ifdef NTONLY
		virtual HRESULT GetNTObject(CInstance* pInstance, long lFlags = 0L);
#endif
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
#ifdef WIN9XONLY
		virtual HRESULT Get9XObject(CInstance* pInstance, long lFlags = 0L);
#endif

    private:
#ifdef WIN9XONLY
		HRESULT FillWin9xInstance(CInstance *pInstance, CHPtrArray& chsaList, CHPtrArray& chsaInstList, UINT nIndex, BOOL bEnumerate);
		HRESULT EnumerateWin9xInstances(MethodContext *&pMethodContext);
#endif
#ifdef NTONLY
        HRESULT EnumerateNTInstances(MethodContext *&pMethodContext);
		HRESULT FillNTInstance(CInstance* pInstance, CHString& chsClient);
#endif

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\netcom.cpp ===
//=================================================================

//

// NetCom.CPP -- Network Card common processing shared between

//				 NetworkAdapter and NetworkAdapterConfiguration

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:
//				11/4/97		jennymc		Created
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>
#include "netcom.h"
//=================================================================
//  Find the net key under HKLM\Enum, with a class of "Net"
//=================================================================
BOOL ComNet::SearchForNetKeys( )
{
    BOOL t_fRc = FALSE ;

    m_nIndex = 0 ;

    m_Search.SearchAndBuildList( _T("Enum"), m_chsaList,_T("Net"), _T("Class"), VALUE_SEARCH ) ;

    if( ( m_nTotal = m_chsaList.GetSize() ) > 0 )
	{
        t_fRc = TRUE ;
    }

    return t_fRc ;
}

//=================================================================
//  Find the net key under HKLM\Enum, with a class of "Net"
//=================================================================
BOOL ComNet::OpenNetKey( )
{
    BOOL t_fRc = FALSE;

    while( m_nIndex < m_nTotal )
	{
        //============================================================
        //  Get a candidate key
        //============================================================
        CHString *t_pchsTmp = ( CHString*) m_chsaList.GetAt( m_nIndex ) ;

		m_nIndex++ ;

        if( m_Reg.Open( HKEY_LOCAL_MACHINE, *t_pchsTmp, KEY_READ )== ERROR_SUCCESS )
		{
            t_fRc = TRUE ;

			//============================================
			//  ProtocolSupported
			//============================================
			// strip off the enum
			m_chsCfgMgrId = t_pchsTmp->Mid( 5 ) ;
			m_chsProtocol = m_chsCfgMgrId.SpanExcluding( L"\\" ) ;

			break ;
        }
    }
    return t_fRc ;
}

//=================================================================
//  Get DeviceDesc
//=================================================================
BOOL ComNet::GetDeviceDesc( CInstance *&a_pInst, LPCTSTR a_szName, CHString &a_Owner )
{
    CHString t_DeviceDesc ;

    if( m_Reg.GetCurrentKeyValue( L"DeviceDesc", t_DeviceDesc ) == ERROR_SUCCESS )
	{
		if( a_szName )
		{
			a_pInst->SetCHString( TOBSTRT( a_szName ), t_DeviceDesc ) ;
		}

		a_Owner = t_DeviceDesc ;

        return TRUE ;
    }

    return FALSE ;
}

//=================================================================
//  Manufacturer
//=================================================================
BOOL ComNet::GetHardwareId( CInstance *& pInstance )
{
    CHString chsTmp;

    if(m_Reg.GetCurrentKeyValue(L"HardwareId", chsTmp ) == ERROR_SUCCESS ){
        pInstance->SetCHString(L"ProductName",chsTmp);
        return TRUE;
    }
    return FALSE;
}

//=================================================================
//  Manufacturer
//=================================================================
BOOL ComNet::GetMfg( CInstance *&a_pInst )
{
    CHString t_Mfg ;

    if( m_Reg.GetCurrentKeyValue( L"Mfg", t_Mfg ) == ERROR_SUCCESS )
	{
        a_pInst->SetCHString( L"Manufacturer", t_Mfg ) ;

		return TRUE ;
    }
    return FALSE ;
}

//=================================================================
//  Manufacturer
//=================================================================
BOOL ComNet::GetCompatibleIds( CHString &a_chsTmp )
{
    if( m_Reg.GetCurrentKeyValue( L"CompatibleIds", a_chsTmp ) == ERROR_SUCCESS )
	{
        return TRUE ;
    }
    return FALSE ;
}

//=================================================================
//  Open the driver for info
//=================================================================
BOOL ComNet::OpenDriver()
{
    BOOL		t_fRc ;
    CHString	t_Driver ;
    WCHAR		t_szKey[ _MAX_PATH + 2 ] ;

    if( m_Reg.GetCurrentKeyValue( L"Driver", t_Driver ) == ERROR_SUCCESS )
	{
        swprintf( t_szKey, L"System\\CurrentControlSet\\Services\\Class\\%s",(LPCWSTR)t_Driver ) ;

        if( m_DriverReg.Open( HKEY_LOCAL_MACHINE, t_szKey, KEY_READ )== ERROR_SUCCESS )
		{
            t_fRc = TRUE ;
        }
    }
    return t_fRc ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  int ComNet::GetNetInstance( DWORD& rdwRegInstance )
 Description:
 Arguments:	rdwRegInstance, the registry instance identifier [OUT]
 Returns:	-1 on error or the zero based compressed order of occurrence of this adapter within the
			System\\CurrentControlSet\\Services\\Class\\Net subtree. This return value
			will correspond to the enumerated TDI adapters instances obtained via the
			CAdapters class.
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  28-Jul-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int ComNet::GetNetInstance( DWORD &a_rdwRegInstance )
{
    int			t_iError = -1 ;	// bogus value on registry error
    CHString	t_Driver ;

    if( m_Reg.GetCurrentKeyValue( L"Driver", t_Driver ) == ERROR_SUCCESS )
	{
		int t_iTokLen = t_Driver.Find( '\\' ) ;

		if( -1 != t_iTokLen )
		{
			// extract the net ID
			DWORD t_dwNetID = _wtol( t_Driver.Mid( t_iTokLen + 1 ) ) ;

			// branch over to the Net area and pick off the correct adapter instance
			CRegistry	t_RegNet ;
			CHString	t_chsNetKey( _T("System\\CurrentControlSet\\Services\\Class\\Net") ) ;

			if( ERROR_SUCCESS == t_RegNet.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_chsNetKey, KEY_READ ) )
			{
				DWORD		t_dwNetCount = 0 ;
				CHString	t_csAdapterKey ;

				// Walk through each instance under this key.  These are all
				// adapters that show up and are known to TDI
				while ( ERROR_SUCCESS == t_RegNet.GetCurrentSubKeyName( t_csAdapterKey ) )
				{
					DWORD t_dwNetIndex = _wtol( t_csAdapterKey.GetBuffer( 0 ) ) ;

					if( t_dwNetIndex == t_dwNetID )
					{
						a_rdwRegInstance = t_dwNetIndex ;
						return t_dwNetCount ;
					}
					t_dwNetCount++ ;

					t_RegNet.NextSubKey() ;
				}
			}
		}
	}

	return t_iError ;
}

//=================================================================
//  Get BusType
//=================================================================
BOOL ComNet::GetBusType( CHString &a_chsBus )
{
    CHString	t_BusType ;
	BOOL		t_fRc = FALSE ;

    if( m_DriverReg.GetCurrentKeyValue( L"BusType", t_BusType ) == ERROR_SUCCESS )
	{
        t_fRc = TRUE ;
    }
	else
	{
        //============================================================
        //  Get the current key we are on, we know it is:
		//    enum\???, we want the ???
        //============================================================
        CHString *t_pchsTmp = ( CHString*) m_chsaList.GetAt( m_nIndex - 1 ) ;
		CHString t_Tmp = t_pchsTmp->Mid( 5 ) ;

		a_chsBus = t_Tmp.SpanExcluding( L"\\" ) ;

        t_fRc = TRUE ;
	}

    return t_fRc ;
}
//=================================================================
//  Get AdapterType
//=================================================================
BOOL ComNet::GetAdapterType( CInstance *&a_pInst )
{
    CHString t_AdapterType ;

    if( m_DriverReg.GetCurrentKeyValue( L"AdapterType", t_AdapterType ) == ERROR_SUCCESS )
	{
        a_pInst->SetCHString( L"AdapterType", t_AdapterType ) ;
        return TRUE ;
    }

    return FALSE ;
}
//=================================================================
//  Get DriverDate
//=================================================================
BOOL ComNet::GetDriverDate( CInstance *&a_pInst )
{
    CHString	t_DriverDate ;
	struct tm	t_tmDate ;

    if( m_DriverReg.GetCurrentKeyValue( L"DriverDate", t_DriverDate ) == ERROR_SUCCESS )
    {
		memset( &t_tmDate, 0, sizeof( t_tmDate ) ) ;

		swscanf(	t_DriverDate,L"%d-%d-%d",
					&t_tmDate.tm_mon,
					&t_tmDate.tm_mday,
					&t_tmDate.tm_year ) ;

			//tm struct year is year - 1900...
			t_tmDate.tm_year = t_tmDate.tm_year - 1900 ;

			//and tm struct month is zero based...
			t_tmDate.tm_mon-- ;

		a_pInst->SetDateTime( IDS_InstallDate, (const struct tm) t_tmDate ) ;

        a_pInst->Setbool( L"Installed",TRUE ) ;

		return TRUE ;
    }
    a_pInst->Setbool( L"Installed", FALSE ) ;

    return FALSE ;
}
//=================================================================
//  Get DeviceVXDs
//=================================================================
BOOL ComNet::GetDeviceVXDs( CInstance *&a_pInst,CHString &a_ServiceName )
{
    CHString t_DeviceVXDs ;

    if( m_DriverReg.GetCurrentKeyValue( L"DeviceVXDs", t_DeviceVXDs ) == ERROR_SUCCESS )
	{
    	//===========================================
        // Strip out the .sys if it is there
        //===========================================
        a_ServiceName = t_DeviceVXDs.SpanExcluding( L".SYS" ) ;
        a_pInst->SetCHString( L"ServiceName", a_ServiceName ) ;

		return TRUE ;
    }
    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\netadaptercfg.h ===
//=================================================================

//

// NetAdaptCfg.h -- Network card configuration property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//               11/4/97     jennymc        moved to new framework
//                                          and rewrote Win95 stuff
//
//				09/15/98					extensive rewrite 
//
//				03/03/99				Added graceful exit on SEH and memory failures,
//											syntactic clean up		  
//
//
//=================================================================
#ifndef _NETADAPTERCFG_H_
#define _NETADAPTERCFG_H_





#define PROPSET_NAME_NETADAPTERCFG  L"Win32_NetworkAdapterConfiguration"


// NT4 registry key values
#define SERVICES_HOME		L"SYSTEM\\CurrentControlSet\\Services"
#define DHCP				L"\\DHCP"
#define PARAMETERS			L"\\Parameters"
#define OPTIONS				L"\\Options"
#define TCPIP_PARAMETERS	L"\\Tcpip\\Parameters"
#define PARAMETERS_TCPIP	L"\\Parameters\\Tcpip"
#define NETBT_PARAMETERS	L"\\Netbt\\Parameters"
#define NETBT_ADAPTERS		L"\\Netbt\\Adapters"
#define TCPIP				L"\\tcpip"
#define IPX					L"\\nwlnkipx"
#define NETCONFIG			L"\\NetConfig"

// DHCP special deletable values
#define RGAS_DHCP_OPTION_IPADDRESS  L"System\\CurrentControlSet\\Services\\?\\Parameters\\Tcpip\\DhcpIPAddress"
#define RGAS_DHCP_OPTION_SUBNETMASK L"System\\CurrentControlSet\\Services\\?\\Parameters\\Tcpip\\DhcpSubnetMask"
#define RGAS_DHCP_OPTION_NAMESERVERBACKUP L"System\\CurrentControlSet\\Services\\NetBT\\Adapters\\?\\DhcpNameServerBackup"

// NT4 DNS registry key items
#define RVAL_HOSTNAME		L"Hostname"
#define RVAL_DOMAIN			L"Domain"
#define RVAL_DHCPDOMAIN		L"DhcpDomain"
#define RVAL_NAMESERVER		L"NameServer"
#define RVAL_DHCPNAMESERVER L"DhcpNameServer" 
#define RVAL_SEARCHLIST		L"SearchList"

// NT5 DNS
#define RVAL_DisableDynamicUpdate					L"DisableDynamicUpdate"
#define RVAL_EnableAdapterDomainNameRegistration	L"EnableAdapterDomainNameRegistration"

// NT5 IP 
#define RVAL_ConnectionMetric	L"InterfaceMetric"

//NT4 WINS registry key values
#define RVAL_DNS_ENABLE_WINS    L"EnableDNS"
#define RVAL_PRIMARY_WINS       L"NameServer"
#define RVAL_SECONDARY_WINS     L"NameServerBackup"
#define RVAL_DNS_ENABLE_LMHOST	L"EnableLMHOSTS"
#define RVAL_SCOPEID            L"ScopeID"

#define RVAL_NETBT_NETBIOSOPTIONS   L"NetbiosOptions"

//NT4 IP Security key values
#define RVAL_SECURITY_TCP       L"TCPAllowedPorts"
#define RVAL_SECURITY_UDP       L"UDPAllowedPorts"
#define RVAL_SECURITY_IP        L"RawIPAllowedProtocols"
#define RVAL_SECURITY_ENABLE    L"EnableSecurityFilters"

//NT4 IPX key values
#define RVAL_VIRTUAL_NET_NUM	L"VirtualNetworkNumber"
#define RVAL_MEDIA_TYPE			L"MediaType"
#define RVAL_PKT_TYPE			L"PktType"
#define	RVAL_NETWORK_NUMBER		L"NetworkNumber"

//NT4 TCP/IP misc key values
#define RVAL_DB_PATH			L"DatabasePath"
#define RVAL_ZERO_BROADCAST		L"UseZeroBroadcast"
#define RVAL_ARP_ALWAYS_SOURCE	L"ArpAlwaysSourceRoute"
#define RVAL_USE_SNAP			L"ArpUseEtherSNAP"
#define RVAL_DEFAULT_TOS		L"DefaultTOS"
#define RVAL_DEFAULT_TTL		L"DefaultTTL"
#define RVAL_DEAD_GW_DETECT		L"EnableDeadGWDetect"
#define RVAL_BLACK_HOLE_DETECT	L"EnablePMTUBHDetect"
#define RVAL_MTU_DISCOVERY		L"EnablePMTUDiscovery"
#define RVAL_FORWARD_MEM_BUFF	L"ForwardBufferMemory"
#define RVAL_IGMP_LEVEL			L"IGMPLevel"
#define RVAL_IP_KEEP_ALIVE_INT	L"KeepAliveInterval"
#define RVAL_IP_KEEP_ALIVE_TIME	L"KeepAliveTime" 
#define RVAL_MTU				L"MTU" 
#define RVAL_NUM_FORWARD_PKTS	L"NumForwardPackets" 
#define RVAL_MAX_CON_TRANS		L"TcpMaxConnectRetransmissions" 
#define RVAL_MAX_DATA_TRANS		L"TcpMaxDataRetransmissions" 
#define RVAL_NUM_CONNECTIONS	L"TcpNumConnections" 
#define RVAL_RFC_URGENT_PTR		L"TcpUseRFC1122UrgentPointer" 
#define RVAL_TCP_WINDOW_SIZE	L"TcpWindowSize"

// NetBios Options ( win2k )
#define UNSET_Netbios	0x0
#define ENABLE_Netbios	0x01
#define DISABLE_Netbios	0x02

// IPX media types
#define ETHERNET_MEDIA  0x1
#define TOKEN_MEDIA     0x2
#define FDDI_MEDIA      0x3
#define ARCNET_MEDIA    0x8

// IPX frame types
#define	ETHERNET	0x0
#define	F802_3		0x1
#define	F802_2		0x2
#define SNAP		0x3
#define ARCNET		0x4
#define AUTO		0xff

// NT4.0 file paths
#define LMHOSTS_PATH			L"\\drivers\\etc"
#define LMHOSTS_FILE			L"\\lmhosts"

// framework class methods 
#define METHOD_NAME_EnableHCP			L"EnableDHCP"
#define METHOD_NAME_EnableStatic		L"EnableStatic"

#define METHOD_NAME_RenewDHCPLease		L"RenewDHCPLease"
#define METHOD_NAME_RenewDHCPLeaseAll	L"RenewDHCPLeaseAll"
#define METHOD_NAME_ReleaseDHCPLease	L"ReleaseDHCPLease"
#define METHOD_NAME_ReleaseDHCPLeaseAll	L"ReleaseDHCPLeaseAll"

#define METHOD_NAME_SetGateways			L"SetGateways"
#define METHOD_NAME_EnableDNS			L"EnableDNS"

#define METHOD_NAME_SetDNSDomain			L"SetDNSDomain"
#define METHOD_NAME_SetDNSSuffixSearchOrder	L"SetDNSSuffixSearchOrder"
#define METHOD_NAME_SetDNSServerSearchOrder	L"SetDNSServerSearchOrder"

// W2k SP1 additions
#define METHOD_NAME_SetDynamicDNSRegistration L"SetDynamicDNSRegistration" 
#define METHOD_NAME_SetIPConnectionMetric	L"SetIPConnectionMetric"
#define METHOD_NAME_SetTcpipNetbios			L"SetTcpipNetbios"
// end additions  

#define METHOD_NAME_SetDNSSearches		L"SetDNSSearches"
#define METHOD_NAME_SetWINSServer		L"SetWINSServer"
#define METHOD_NAME_EnableWINS			L"EnableWINS"
#define METHOD_NAME_EnableIPFilterSec	L"EnableIPFilterSec"
#define METHOD_NAME_EnableIPSec			L"EnableIPSec"
#define METHOD_NAME_DisableIPSec		L"DisableIPSec"
#define METHOD_NAME_IPXVirtualNetNum	L"SetIPXVirtualNetworkNumber"
#define METHOD_NAME_IPXSetFrameNetPairs	L"SetIPXFrameTypeNetworkPairs"

#define METHOD_NAME_SetDBPath			L"SetDatabasePath"
#define METHOD_NAME_SetIPUseZero		L"SetIPUseZeroBroadcast"
#define METHOD_NAME_SetArpAlwaysSource	L"SetArpAlwaysSourceRoute"
#define METHOD_NAME_SetArpUseEtherSNAP	L"SetArpUseEtherSNAP"
#define METHOD_NAME_SetTOS				L"SetDefaultTOS"
#define METHOD_NAME_SetTTL				L"SetDefaultTTL"
#define METHOD_NAME_SetDeadGWDetect		L"SetDeadGWDetect"
#define METHOD_NAME_SetPMTUBHDetect		L"SetPMTUBHDetect"
#define METHOD_NAME_SetPMTUDiscovery	L"SetPMTUDiscovery"
#define METHOD_NAME_SetForwardBufMem	L"SetForwardBufferMemory"
#define METHOD_NAME_SetIGMPLevel		L"SetIGMPLevel"
#define METHOD_NAME_SetKeepAliveInt		L"SetKeepAliveInterval"
#define METHOD_NAME_SetKeepAliveTime	L"SetKeepAliveTime"
#define METHOD_NAME_SetMTU				L"SetMTU"
#define METHOD_NAME_SetNumForwardPkts	L"SetNumForwardPackets"
#define METHOD_NAME_SetTcpMaxConRetrans	L"SetTcpMaxConnectRetransmissions"
#define METHOD_NAME_SetTcpMaxDataRetrans	L"SetTcpMaxDataRetransmissions"
#define METHOD_NAME_SetTcpNumCons		L"SetTcpNumConnections"
#define METHOD_NAME_SetTcpUseRFC1122UP	L"SetTcpUseRFC1122UrgentPointer"
#define METHOD_NAME_SetTcpWindowSize	L"SetTcpWindowSize"

//Win32_NetworkAdapterConfiguration property names ( matches method arguments ) 
#define ADAPTER_SERVICENAME		L"ServiceName"

#define DNS_HOSTNAME			L"DNSHostName"
#define DNS_DOMAIN				L"DNSDomain"
#define DNS_SERVERSEARCHORDER	L"DNSServerSearchOrder"
#define DNS_SUFFIXSEARCHORDER	L"DNSDomainSuffixSearchOrder"

#define DNS_OVER_WINS			L"DNSEnabledForWINSResolution"
#define PRIMARY_WINS_SERVER		L"WINSPrimaryServer"
#define SECONDARY_WINS_SERVER	L"WINSSecondaryServer"
#define SCOPE_ID				L"WINSScopeID"
#define WINS_ENABLE_LMHOSTS		L"WINSEnableLMHostsLookup"
#define	WINS_HOST_LOOKUP_FILE	L"WINSHostLookupFile"

// W2k SP1 additions
#define FULL_DNS_REGISTRATION	L"FullDNSRegistrationEnabled"
#define DOMAIN_DNS_REGISTRATION L"DomainDNSRegistrationEnabled"
#define IP_CONNECTION_METRIC	L"IPConnectionMetric"
#define TCPIP_NETBIOS_OPTIONS	L"TcpipNetbiosOptions"
// end additions

#define IP_SECURITY_ENABLED		L"IPFilterSecurityEnabled"
#define PERMIT_TCP_PORTS		L"IPSecPermitTCPPorts"
#define PERMIT_UDP_PORTS		L"IPSecPermitUDPPorts"
#define PERMIT_IP_PROTOCOLS		L"IPSecPermitIPProtocols"

#define IPX_VIRTUAL_NET_NUM		L"IPXVirtualNetNumber"
#define IPX_MEDIATYPE			L"IPXMediaType"
#define IPX_FRAMETYPE			L"IPXFrameType"
#define IPX_NETNUMBER			L"IPXNetworkNumber"

// TCP misc
#define DATA_BASE_PATH			L"DatabasePath"
#define IP_USE_ZERO_BROADCAST	L"IPUseZeroBroadcast"
#define ARP_ALWAYS_SOURCE_ROUTE	L"ArpAlwaysSourceRoute"
#define ARP_USE_ETHER_SNAP		L"ArpUseEtherSNAP"
#define DEFAULT_TOS				L"DefaultTOS"
#define DEFAULT_TTL				L"DefaultTTL"
#define ENABLE_DEAD_GW_DETECT	L"DeadGWDetectEnabled"
#define ENABLE_PMTUBH_DETECT	L"PMTUBHDetectEnabled"
#define ENABLE_PMTU_DISCOVERY	L"PMTUDiscoveryEnabled"
#define FORWARD_BUFFER_MEMORY	L"ForwardBufferMemory"
#define IGMP_LEVEL				L"IGMPLevel"
#define KEEP_ALIVE_INTERVAL		L"KeepAliveInterval"
#define KEEP_ALIVE_TIME			L"KeepAliveTime"
#define MTU						L"MTU"
#define NUM_FORWARD_PACKETS		L"NumForwardPackets"
#define TCP_MAX_CONNECT_RETRANS	L"TcpMaxConnectRetransmissions"
#define TCP_MAX_DATA_RETRANS	L"TcpMaxDataRetransmissions"
#define TCP_NUM_CONNECTIONS		L"TcpNumConnections"
#define TCP_USE_RFC1122_URG_PTR	L"TcpUseRFC1122UrgentPointer"
#define TCP_WINDOW_SIZE			L"TcpWindowSize"


// Win32_NetworkAdapterConfigReturn return values 
//		NOTE:	These enums are documented returns 
//				do not change or reorder.   
#define METHOD_ARG_NAME_METHODRESULT	L"ReturnValue"
enum E_RET	{
	E_RET_OK,
	E_RET_OK_REBOOT_REQUIRED,
	E_RET_UNSUPPORTED = 64,	// errors start here
	E_RET_UNKNOWN_FAILURE,
	E_RET_IP_MASK_FAILURE,
	E_RET_INSTANCE_CALL_FAILED,
	E_RET_INPARM_FAILURE,
	E_RET_MORE_THAN_FIVE_GATEWAYS,
	E_RET_IP_INVALID,
	E_RET_GATEWAY_IP_INVALID,	
	E_RET_REGISTRY_FAILURE,
	E_RET_INVALID_DOMAINNAME,
	E_RET_INVALID_HOSTNAME,
	E_RET_WINS_SEC_NO_PRIME,
	E_RET_INVALID_FILE,
	E_RET_SYSTEM_PATH_INVALID,
	E_RET_FILE_COPY_FAILED,
	E_RET_INVALID_SECURITY_PARM,
	E_RET_UNABLE_TO_CONFIG_TCPIP_SERVICE,
	E_RET_UNABLE_TO_CONFIG_DHCP_SERVICE,
	E_RET_UNABLE_TO_RENEW_DHCP_LEASE,
	E_RET_UNABLE_TO_RELEASE_DHCP_LEASE,
	E_RET_IP_NOT_ENABLED_ON_ADAPTER,
	E_RET_IPX_NOT_ENABLED_ON_ADAPTER,
	E_RET_FRAME_NETNUM_BOUNDS_ERR,
	E_RET_INVALID_FRAMETYPE,
	E_RET_INVALID_NETNUM,
	E_RET_DUPLICATE_NETNUM,
	E_RET_PARAMETER_BOUNDS_ERROR,
	E_RET_ACCESS_DENIED,
	E_RET_OUT_OF_MEMORY,
	E_RET_ALREADY_EXISTS,
	E_RET_OBJECT_NOT_FOUND,			// path, file or object
	E_RET_UNABLE_TO_NOTIFY_SERVICE,
	E_RET_UNABLE_TO_NOTIFY_DNS_SERVICE,
	E_RET_INTERFACE_IS_NOT_CONFIGURABLE,
	E_RET_PARTIAL_COMPLETION,
	E_RET_DHCP_NOT_ENABLED_ON_ADAPTER = 100
	};

// framework method returns
#define	TO_CALLER	S_OK;  


// misc defines
#define HOST_LIMIT				63
#define HOSTNAME_LENGTH         64
#define DOMAINNAME_LENGTH       255
#define MAX_IP_SIZE				16

#ifndef _ENUM_SERVICE_ENABLE_DEFINED
#define _ENUM_SERVICE_ENABLE_DEFINED
typedef enum _SERVICE_ENABLE {
    IgnoreFlag,
    DhcpEnable,
    DhcpDisable
} SERVICE_ENABLE, *LPSERVICE_ENABLE;
#endif

//DHCP defines and entry points into dhcpcsvc.dll
#define DHCP_DLL		_T("dhcpcsvc.dll")
#define DHCP_ACQUIRE	"DhcpAcquireParameters"
#define DHCP_RELEASE	"DhcpReleaseParameters"
#define DHCP_NOTIFY		"DhcpNotifyConfigChange"

typedef DWORD (APIENTRY *DHCP_ACQUIRE_ROUTINE)(LPWSTR) ;
typedef DWORD (APIENTRY *DHCP_RELEASE_ROUTINE)(LPWSTR) ;
typedef DWORD (APIENTRY *DHCP_NOTIFY_ROUTINE)(LPWSTR, LPWSTR, BOOL, DWORD, DWORD, DWORD, SERVICE_ENABLE) ;

class CMParms
{
	public:
        
		CInstance	*m_pInst;
		BSTR		*m_pbstrMethodName;
		CInstance	*m_pInParams;
		CInstance	*m_pOutParams;
		long		m_lFlags;
		
		//=================================================
        // Constructors/destructor
        //=================================================
        CMParms() ;
		CMParms( const CInstance& rInstance ) ;
		CMParms( const CInstance& rInstance, const CInstance& rInParams ) ;
		CMParms( const CInstance& rInstance, const BSTR& rbstrMethodName, 
					  CInstance* pInParams, CInstance* pOutParams, long lFlags ) ;
       ~CMParms() ;

		// operations

		CInstance* pInst()
			{ return m_pInst; }	
		
		CInstance* pInParams()
			{ return m_pInParams; }	

		HRESULT hSetResult( E_RET eValue )
			{ m_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, eValue ) ; return S_OK; }
};


// incapsulated SAFEARRAY* for garbage cleanup
class saAutoClean
{
protected:
	SAFEARRAY **m_ppArray;
public:	
	saAutoClean( SAFEARRAY **a_ppArray ) ;
	~saAutoClean() ;
};


// Provider class
class CWin32NetworkAdapterConfig : public Provider
{
	private:

        BOOL GetServiceName( DWORD a_dwIndex, CInstance *a_pInst, CHString &a_ServiceName ) ;

	#ifdef NTONLY
        BOOL GetNTBusInfo( LPCTSTR a_pszServiceName, CInstance *a_pInst ) ;
        
		BOOL GetIPInfoNT( CInstance *a_pInst, LPCTSTR a_szKey, CAdapters &a_rAdapters ) ;
		BOOL GetIPInfoNT351( CInstance *a_pInst, CRegistry &a_rRegistry ) ;
		BOOL GetIPInfoNT4orBetter( CInstance *a_pInst, CRegistry &a_rRegistry, CAdapters &a_rAdapters ) ;
        BOOL ResetGateways(CInstance *a_pInst);
	#endif
		
		BOOL fSetIPBindingInfo( CInstance *a_pInst, _ADAPTER_INFO *a_pAdapterInfo ) ;
		
	
    #ifdef NTONLY
        #if NTONLY >= 5
            HRESULT hGetDNSW2K(
                CInstance *a_pInst, 
                DWORD a_dwIndex,
                CHString& a_chstrRootDevice,
                CHString& a_chstrIpInterfaceKey);
        #else
            HRESULT hGetDNS( CInstance *a_pInst, DWORD a_dwIndex ) ;
        #endif
    #else
    	HRESULT hGetDNS( CInstance *a_pInst, DWORD a_dwIndex ) ;
	#endif
    



	#ifdef NTONLY

		E_RET fLoadAndValidateDNS_Settings( 
								CMParms		&a_rMParms,
								CHString	&a_csHostName, 
								CHString	&a_csDomain,
								SAFEARRAY	**a_ServerSearchOrder,
								SAFEARRAY	**a_SuffixSearchOrder,
								DWORD		*a_dwValidBits
								) ;

		HRESULT hGetNtIpSec(	CInstance *a_pInst, 
								LPCTSTR a_szKey ) ;
		
		bool	IsConfigurableTcpInterface( CHString a_chsLink ) ;
		
		int		GetCAdapterIndexViaInterfaceContext(

										CRegistry &a_rRegistry,
										CAdapters &a_rAdapters 
										) ;

		BOOL	fMapIndextoKey( 		DWORD a_dwIndex, 
										CHString &a_chsLinkKey
										) ;

		BOOL    fGetNtTcpRegAdapterKey( DWORD a_dwIndex,
										CHString &a_chsRegKey,
										CHString &a_chsLinkKey ) ;
		
		BOOL	fGetNtNBRegAdapterKey(	DWORD a_dwIndex, 
										CHString &a_csNBBindingKey, 
										CHString &a_chsLink ) ;

		BOOL	fGetNtIpxRegAdapterKey(	DWORD a_dwIndex, 
										CHString &a_csIPXNetBindingKey,
										CHString &a_chsLink ) ;
	#endif

        BOOL IsContextIncluded( DWORD a_Context, DWORD a_contextlist[], int a_len_contextlist ) ;

		LONG ReadRegistryList( HKEY a_Key, LPCTSTR a_ParameterName, DWORD a_NumList[], int *a_MaxList ) ;
		LONG RegQueryForString( HKEY a_hKey, LPCTSTR a_pszTarget, LPTSTR a_pszDestBuffer, DWORD a_dDestBufferSize ) ;
		
		LONG RegGetStringArray( CRegistry &a_rRegistry, LPCWSTR  a_szSubKey, SAFEARRAY **a_t_Array, TCHAR a_cDelimiter = ' ' ) ;
        LONG RegGetStringArrayEx(CRegistry &a_rRegistry,
								 LPCWSTR a_szSubKey,
								 SAFEARRAY** a_Array );

		LONG RegGetHEXtoINTArray( CRegistry &a_rRegistry, LPCTSTR a_szSubKey, SAFEARRAY **a_t_Array ) ;

		LONG RegPutStringArray(HKEY a_hKey, LPCTSTR a_pszTarget, SAFEARRAY &a_strArray,	TCHAR a_cDelimiter = ' ' ) ;
		LONG RegPutStringArray(CRegistry &a_rRegPut, LPCTSTR a_pszTarget, SAFEARRAY &a_strArray, TCHAR a_cDelimiter = ' ' )
			{ return RegPutStringArray( a_rRegPut.GethKey(), a_pszTarget, a_strArray, a_cDelimiter) ; };
		
		LONG RegPutINTtoStringArray(	HKEY a_hKey, 
										LPCTSTR a_pszTarget,
										SAFEARRAY *a_strArray, 
										CHString &a_chsFormat,
										int iMinOutSize ) ;
		
		LONG RegPutINTtoStringArray(	CRegistry &a_rRegPut,
										LPCTSTR a_pszTarget,
										SAFEARRAY *a_strArray, 
										CHString &a_chsFormat, 
										int a_iMinOutSize )
			{ return RegPutINTtoStringArray( a_rRegPut.GethKey(), a_pszTarget, a_strArray, a_chsFormat, a_iMinOutSize ) ; };
		

#ifdef NTONLY
#if NTONLY >= 5
		HRESULT hGetWinsW2K(
            CInstance *a_pInst, 
            DWORD a_dwIndex,
            CHString& a_chstrRootDevice,
            CHString& a_chstrIpInterfaceKey);
#else
        HRESULT hGetWinsNT( CInstance *a_pInst, DWORD a_dwIndex ) ;
#endif
		HRESULT hGetIPXGeneral( CInstance *a_pInst, DWORD a_dwIndex ) ;
		HRESULT hGetTcpipGeneral( CInstance *a_pInst ) ;
		BOOL	fValidateIPGateways( CMParms &a_rMParms, SAFEARRAY *a_IpGatewayArray, SAFEARRAY **a_CostMetric ) ;
#endif

      	// framework class methods
		HRESULT hEnableDHCP( CMParms &a_rMParms ) ;
		HRESULT hEnableStatic( CMParms &a_rMParms ) ;
		HRESULT hRenewDHCPLease( CMParms &a_rMParms ) ;
		HRESULT hRenewDHCPLeaseAll( CMParms &a_rMParms ) ;
		HRESULT hReleaseDHCPLease( CMParms &a_rMParms ) ;
		HRESULT hReleaseDHCPLeaseAll( CMParms &a_rMParms ) ;
		HRESULT hSetGateways( CMParms &a_rMParms ) ;
		HRESULT hEnableIPFilterSec( CMParms &a_rMParms ) ;
		HRESULT hEnableIPSec( CMParms &a_rMParms ) ;
		HRESULT hDisableIPSec( CMParms &a_rMParms ) ;			
		HRESULT hEnableWINSServer( CMParms &a_rMParms ) ;
		HRESULT hEnableWINS( CMParms &a_rMParms ) ;			
		HRESULT hEnableDNS( CMParms &a_rMParms ) ;

		HRESULT hSetDNSDomain( CMParms &a_rMParms ) ;
		HRESULT hSetDNSSuffixSearchOrder( CMParms &a_rMParms ) ;
		HRESULT hSetDNSServerSearchOrder( CMParms &a_rMParms ) ;
	
		HRESULT hSetVirtualNetNum( CMParms &a_rMParms ) ;
		HRESULT hSetFrameNetPairs( CMParms &a_rMParms ) ;
		HRESULT hSetDBPath( CMParms &a_rMParms ) ;
		HRESULT hSetIPUseZero( CMParms &a_rMParms ) ;
		HRESULT hSetArpAlwaysSource( CMParms &a_rMParms ) ;
		HRESULT hSetArpUseEtherSNAP( CMParms &a_rMParms ) ;
		HRESULT hSetTOS( CMParms &a_rMParms ) ;
		HRESULT hSetTTL( CMParms &a_rMParms ) ;
		HRESULT hSetDeadGWDetect( CMParms &a_rMParms ) ;
		HRESULT hSetPMTUBHDetect( CMParms &a_rMParms ) ;
		HRESULT hSetPMTUDiscovery( CMParms &a_rMParms ) ;
		HRESULT hSetForwardBufMem( CMParms &a_rMParms ) ;
		HRESULT hSetIGMPLevel( CMParms &a_rMParms ) ;
		HRESULT hSetKeepAliveInt( CMParms &a_rMParms ) ;
		HRESULT hSetKeepAliveTime( CMParms &a_rMParms ) ;
		HRESULT hSetMTU( CMParms &a_rMParms ) ;
		HRESULT hSetNumForwardPkts( CMParms &a_rMParms ) ;
		HRESULT hSetTcpMaxConRetrans( CMParms &a_rMParms ) ;
		HRESULT hSetTcpMaxDataRetrans( CMParms &a_rMParms ) ;
		HRESULT hSetTcpNumCons( CMParms &a_rMParms ) ;
		HRESULT hSetTcpUseRFC1122UP( CMParms &a_rMParms ) ;
		HRESULT hSetTcpWindowSize( CMParms &a_rMParms ) ;

		HRESULT hSetDynamicDNSRegistration( CMParms &a_rMParms ) ;
		HRESULT hSetTcpipNetbios( CMParms &a_rMParms ) ;
		HRESULT hSetIPConnectionMetric( CMParms &a_rMParms ) ;
		
		// utilities
		BOOL	fCreateAddEntry( SAFEARRAY **a_t_Array, CHString &a_chsStr ) ;
		BOOL	fCreateBoolToReg( CMParms &a_rMParms, CHString &a_oSKey, LPCTSTR a_pSource, LPCTSTR a_pTarget ) ;
		BOOL	fBoolToReg( CMParms &a_rMParms, CRegistry &a_oReg, LPCTSTR a_pSource, LPCTSTR a_pTarget ) ;

		E_RET eValidateIPSecParms( SAFEARRAY *a_IpArray, int a_iMax ) ;
		BOOL fValidateIPs( SAFEARRAY *a_IpArray ) ;
	
		BOOL fValidFrameNetPairs(	CMParms &a_rMParms,
									SAFEARRAY *a_FrameType,
									SAFEARRAY *a_NetNumber,
									BOOL *t_fIsAuto ) ;

		BOOL fIsValidIP( CHString &a_strIP ) ;
		BOOL fIsValidateDNSDomain( CHString &a_rchDomain ) ;
		BOOL fIsValidateDNSHost( CHString &a_rchHost ) ;
		BOOL fIsIPEnabled( CMParms &a_rMParms ) ;
		BOOL fIsIPXEnabled( CMParms &a_rMParms ) ;
		BOOL fIsDhcpEnabled( CMParms &a_rMParms ) ;
		E_RET eIsValidIPandSubnets( SAFEARRAY *a_IpAddressArray, SAFEARRAY *a_IpMaskArray ) ;
		E_RET eIsValidIPandSubnet( DWORD a_ardwIP[ 4 ], DWORD a_ardwMask[ 4 ] ) ;
		BOOL fGetNodeNum( CHString &a_strIP, DWORD a_ardw[ 4 ] ) ;
		void vBuildIP( DWORD a_ardwIP[ 4 ], CHString &a_strIP ) ;
		BOOL fValidateWINSLookupFile( CHString &a_rchsFile ) ;

		DWORD  dwEnableService( LPCTSTR a_lpServiceName, BOOL a_fEnable ) ;
		DWORD  dwSendServiceControl( LPCTSTR a_lpServiceName, DWORD a_dwControl ) ;

		HRESULT hConfigDHCP( CMParms &a_rMParms, SAFEARRAY *a_IpArray = NULL, SAFEARRAY *a_MaskArray = NULL ) ;
		E_RET   hDHCPAcquire( CMParms &a_rMParms, CHString &a_chsAdapter ) ;
		E_RET   hDHCPRelease( CMParms &a_rMParms, CHString &a_chsAdapter ) ;
		HRESULT hDHCPNotify(	CMParms &a_rMParms, 
								CHString &a_chsAdapter,
								BOOL a_fIsNewIpAddress,
								DWORD a_dwIpIndex,
								DWORD a_dwIpAddress,
								DWORD a_dwSubnetMask, 
								SERVICE_ENABLE a_DhcpServiceEnabled ) ;

		BOOL    fCleanDhcpReg( CHString &t_chsLink ) ;
		BOOL	fDeleteValuebyPath( CHString &a_chsDelLocation ) ;

#ifdef WIN9XONLY
		BOOL	fGetWinsServers9x( 
								DWORD		a_dwIPAddress,
								CHString	&a_chsPrimary,
								CHString	&a_chsSecondary ) ;
#endif
		
		BOOL fGetWinsServers( CHString &a_rDeviceName, CHString &a_chsPrimary, CHString &a_chsSecondary ) ; 
		BOOL fSetWinsServers( CHString &a_rDeviceName, CHString &a_chsPrimary, CHString &a_chsSecondary ) ; 
		BOOL fGetMacAddress( BYTE a_MACAddress[ 6 ], CHString &a_rDeviceName ) ;
		BOOL fCreateSymbolicLink( CHString &a_rDeviceName ) ;
		BOOL fDeleteSymbolicLink(  CHString &a_rDeviceName ) ; 
	
		BOOL fMapResError( CMParms &a_rMParms, LONG a_lError, E_RET a_eDefaultError ) ;
		void vSetCaption( CInstance *a_pInst, CHString &a_rchsDesc, DWORD a_dwIndex, int a_iFormatSize ) ;
		BOOL GetSettingID( CInstance *a_pInst, DWORD a_dwIndex ) ;

#if NTONLY >= 5
		E_RET eSetNetBiosOptions( DWORD a_dwOption, DWORD a_dwIndex ) ;
#endif   
	public:
        
        //=================================================
        // Constructor/destructor
        //=================================================

        CWin32NetworkAdapterConfig( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32NetworkAdapterConfig() ;

        //=================================================
        // Functions provide properties with current values
        //=================================================
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
		virtual HRESULT EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
		
		virtual	HRESULT ExecMethod(	const CInstance &a_Inst, const BSTR a_MethodName, 
									CInstance *a_InParams, CInstance *a_OutParams, long a_Flags = 0L ) ;


	#ifdef WIN9XONLY
        HRESULT GetNetCardConfigInfoWin95(	MethodContext *a_pMethodContext,
											CInstance *pSpecificInstance,
											DWORD a_dwIndex, 
											CAdapters &a_rAdapters ) ;
	#endif
	#ifdef NTONLY
        HRESULT GetNetCardConfigInfoNT( MethodContext *a_pMethodContext,
										CInstance *a_pSpecificInstance,
										DWORD a_dwIndex,
										CAdapters &a_rAdapters ) ;
	#endif

	#if NTONLY >= 5
	
		HRESULT EnumNetAdaptersInNT5(MethodContext *a_pMethodContext, CAdapters &a_rAdapters ) ;
		
		HRESULT GetNetCardConfigForNT5 (	CW2kAdapterInstance *a_pAdapterInst,
											CInstance *a_pInst, 
											CAdapters &a_rAdapters ) ;

		HRESULT GetNetAdapterInNT5( CInstance *a_pInst, CAdapters &a_rAdapters ) ;
	#endif

		BOOL GetIPXAddresses ( CInstance *a_pInst, BYTE a_MACAddress[ 6 ] ) ;
		//=================================================
		// Utility
		//=================================================
  	
} ;


//
class CDhcpIP_Instruction
{
public:
	CHString chsIPAddress;
	CHString chsIPMask;
	
	DWORD			dwIndex ;
	BOOL			bIsNewAddress ;
	SERVICE_ENABLE  eDhcpFlag ;
};

//
class CDhcpIP_InstructionList : public CHPtrArray
{

public:

		~CDhcpIP_InstructionList();

		E_RET BuildStaticIPInstructionList( 

			CMParms				&a_rMParms, 
			SAFEARRAY			*a_IpArray,
			SAFEARRAY			*a_MaskArray,
			CRegistry			&a_Registry,
			bool				t_fDHCPCurrentlyActive ) ;
		
		void AddDhcpInstruction(

			BSTR a_bstrIPAddr,
			BSTR a_bstrIPMask,
			BOOL a_bIsNewAddress,
			DWORD a_dwIndex,
			SERVICE_ENABLE a_eDhcpFlag ) ; 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\netcom.h ===
//=================================================================

//

// Netcom.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef NETCOM_H
#define NETCOM_H


class ComNet
{

	private:
		CHString m_chsProtocol ;
		CHString m_chsCfgMgrId ;

    public:
        ComNet(){}
        ~ComNet()   { m_Search.FreeSearchList( CSTRING_PTR, m_chsaList ) ;}

        int  GetIndex()             { return m_nIndex;}

        BOOL SearchForNetKeys() ;
        BOOL OpenNetKey() ;
        BOOL OpenDriver() ;
		int  GetNetInstance( DWORD &a_rdwRegInstance ) ;

        BOOL GetDeviceDesc( CInstance *&a_pInst,LPCTSTR szname,CHString & Owner ) ;
        BOOL GetMfg( CInstance *&a_pInst ) ;
        void GetProtocolSupported( CInstance *&a_pInst ){ a_pInst->SetCHString( IDS_ProtocolSupported, m_chsProtocol ) ;}
        void GetCfgMgrId( CHString &a_chsTmp ){ a_chsTmp = m_chsCfgMgrId; }
        BOOL GetBusType(CHString &chsBus ) ;
        BOOL GetAdapterType( CInstance *&a_pInst ) ;
        BOOL GetDriverDate( CInstance *&a_pInst ) ;
        BOOL GetDeviceVXDs( CInstance *&a_pInst,CHString &a_ServiceName ) ;
        BOOL GetMACAddress( CInstance *&a_pInst ) ;

		BOOL GetCompatibleIds(CHString &a_chsTmp ) ;
		BOOL GetHardwareId( CInstance *&a_pInst ) ;

    private:

        int             m_nTotal,m_nIndex ;
        CRegistrySearch m_Search ;
        CHPtrArray      m_chsaList ;
        CRegistry       m_Reg,m_DriverReg ;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\netclient.cpp ===
//=================================================================

//

// NetCli.CPP -- Network client property set provider

//                 (Windows 95 only)

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "NetClient.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "cfgmgrdevice.h"
#include <tchar.h>

// Property set declaration
//=========================
CWin32NetCli MyNetCliSet(PROPSET_NAME_NETWORK_CLIENT, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetCli::CWin32NetCli
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32NetCli::CWin32NetCli(LPCWSTR name, LPCWSTR pszNamespace)
:Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetCli::~CWin32NetCli
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32NetCli::~CWin32NetCli()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetCli::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32NetCli::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	// cache name for reality check at end.
	CHString name0, name1;
	CHString chsClient;
	if (pInstance->GetCHString(IDS_Name, name0))
	{

#ifdef WIN9XONLY
			hr = Get9XObject(pInstance);
#endif
#ifdef NTONLY
		// add code to check the instance to see if it exists.
			hr = GetNTObject(pInstance, lFlags);
			return(hr);
#endif

		pInstance->GetCHString(IDS_Name, name1);

		// if name doesn't match, then someone's asking for something
		// other than what we got.  Tell 'em to go fly a kite
		if (name0.CompareNoCase(name1) != 0)
			hr = WBEM_E_NOT_FOUND; // darn, no WBEM_E_GO_FLY_A_KITE...
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetCli::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32NetCli::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr;

#ifdef NTONLY
        hr = EnumerateNTInstances(pMethodContext);
#endif
#ifdef WIN9XONLY
		hr = EnumerateWin9xInstances(pMethodContext);
#endif
    return hr;

}

#ifdef NTONLY
////////////////////////////////////////////////////////////////////////
HRESULT CWin32NetCli::FillNTInstance(CInstance *pInstance, CHString &a_chsClient )
{
	CRegistry Reg;
    HRESULT hr=WBEM_E_FAILED;
    CHString chsKey,chsTmp,chsValue;
	DWORD dwTmp;

    //===========================================================
	//  Find out who we are dealing with here, lanman or netware
    //===========================================================
//    if( Reg.OpenLocalMachineKeyAndReadValue( "SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order", "ProviderOrder", chsTmp) == ERROR_SUCCESS)
	if (!a_chsClient.IsEmpty())
    {
		chsTmp = a_chsClient;
	    //=======================================================
		//  Get Description, Caption, Status
		//=======================================================
        chsKey = CHString(_T("SYSTEM\\CurrentControlSet\\Services\\")) + chsTmp;
	    if( Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("DisplayName"), chsValue) == ERROR_SUCCESS)
		{
			pInstance->SetCHString(IDS_Caption, chsValue);
		}

		CHString t_chsDesc ;
		Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("Description"), t_chsDesc);

		if( t_chsDesc.IsEmpty() )
		{
			t_chsDesc = a_chsClient ;
		}
		pInstance->SetCHString(IDS_Description, t_chsDesc ) ;

#ifdef NTONLY
		if( IsWinNT5() )
		{
			CHString t_chsStatus ;

			if( GetServiceStatus( a_chsClient,  t_chsStatus ) )
			{
				pInstance->SetCharSplat(IDS_Status, t_chsStatus ) ;
			}
		}
		else
#endif
		{
			// can't find status
			pInstance->SetCHString(IDS_Status, IDS_STATUS_Unknown);

			chsKey = CHString(_T("SYSTEM\\CurrentControlSet\\Services\\")) + chsTmp + CHString(_T("\\Enum"));

			if( Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("0"), chsValue) == ERROR_SUCCESS)
			{
				chsKey = CHString(_T("SYSTEM\\CurrentControlSet\\Enum\\")) + chsValue;
				if( Reg.Open( HKEY_LOCAL_MACHINE,chsKey,KEY_READ) == ERROR_SUCCESS)
				{
					if( Reg.GetCurrentKeyValue(_T("StatusFlags"),dwTmp) == ERROR_SUCCESS )
					{
						TranslateNTStatus(dwTmp,chsValue);
						pInstance->SetCHString(IDS_Status, chsValue);
					}
				}
			}
		}

	    //=======================================================
		//  Get InstallDate
		//=======================================================
		if( chsTmp.CompareNoCase(_T("LanmanWorkstation")) == 0 )
		{
			chsKey = CHString(_T("Software\\Microsoft\\LanmanWorkstation\\CurrentVersion"));
		    if( Reg.Open( HKEY_LOCAL_MACHINE,chsKey,KEY_READ) == ERROR_SUCCESS){
				if( Reg.GetCurrentKeyValue(_T("InstallDate"),dwTmp) == ERROR_SUCCESS ){
					pInstance->SetDateTime(IDS_InstallDate, (WBEMTime)dwTmp);
				}
			}
		}
	    //=======================================================
		//  Get Name, Manufacturer
		//=======================================================
        chsKey = CHString(_T("SYSTEM\\CurrentControlSet\\Services\\")) + chsTmp + CHString(_T("\\NetworkProvider"));
        if( Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("Name"), chsTmp) == ERROR_SUCCESS)
		{
			pInstance->SetCHString(IDS_Name, chsTmp);
			CHString fName;
			// try to find a manufacturer
			if( Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("ProviderPath"), fName) == ERROR_SUCCESS)
			{
				// get a filename out of it - might have %SystemRoot% in it...
				chsTmp = fName.Left(12);
				if (chsTmp.CompareNoCase(_T("%SystemRoot%")) == 0)
				{
					fName = fName.Right(fName.GetLength() - _tcslen(_T("%SystemRoot%")) );
					GetWindowsDirectory(chsTmp.GetBuffer(MAX_PATH), MAX_PATH);
					chsTmp.ReleaseBuffer();

					// if it's the root dir, it'll have a backslash at the end...
					LPTSTR pTmpTchar = chsTmp.GetBuffer(0) ;
					if( ( pTmpTchar = _tcsrchr( pTmpTchar, '\\' ) ) )
					{
						if( *(_tcsinc( pTmpTchar ) ) == '\0' )
						{
							chsTmp = chsTmp.Left(chsTmp.GetLength() -1);
						}
					}
					chsTmp.ReleaseBuffer();

					fName = chsTmp + fName;
				}

				if( GetManufacturerFromFileName( fName,chsTmp ))
				{
					pInstance->SetCHString(IDS_Manufacturer, chsTmp);
				}
			}
	        hr = WBEM_S_NO_ERROR;
		}

    }
	return hr;
}
#endif

//**********************************************************************/
#ifdef NTONLY
HRESULT CWin32NetCli::EnumerateNTInstances(MethodContext *&pMethodContext)
{
	CRegistry Reg;
	CHString chsTemp;
	CHString chsClient;
	HRESULT hr = WBEM_S_NO_ERROR;
	CInstancePtr pInstance;
	int nIndex = 0;
    if( Reg.OpenLocalMachineKeyAndReadValue( _T("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order"), _T("ProviderOrder"), chsTemp) == ERROR_SUCCESS)
    {
		// multiple clients are stored here delimitted by a comma
		nIndex = chsTemp.Find(_T(","));

		while (chsTemp.GetLength() && SUCCEEDED(hr))
		{
			// now we need to get the last instance
			if (-1 == nIndex)
			{
				chsClient = chsTemp;
				chsTemp.Empty();
			}
			else
			{
				chsClient = chsTemp.Left(nIndex);
				// peel left hand string off temp string.
				chsTemp = chsTemp.Mid(nIndex+1);
			}

			pInstance.Attach(CreateNewInstance(pMethodContext));
			if(SUCCEEDED(FillNTInstance(pInstance, chsClient)))
			{
				hr = pInstance->Commit();
			}

			nIndex = chsTemp.Find(_T(","));
		}

	}

    return hr;
}
#endif

//**********************************************************************/
#ifdef WIN9XONLY
HRESULT CWin32NetCli::EnumerateWin9xInstances(MethodContext *&pMethodContext)
{
	CRegistrySearch Search;
	HRESULT hr = WBEM_E_OUT_OF_MEMORY;
	UINT nCount = 0;
	CHPtrArray chsaList, chsaInstanceList;
	CInstancePtr pInstance;
	HRESULT hRet = WBEM_S_NO_ERROR;

    Search.SearchAndBuildList( _T("Enum\\Network"), chsaList, _T("NetClient"),
								_T("Class"), VALUE_SEARCH );

	nCount = chsaList.GetSize();
    if( nCount )
    {
		for (int n=0; n<nCount && SUCCEEDED(hRet); n++)
		{
			pInstance.Attach(CreateNewInstance(pMethodContext));

			if (pInstance)
            {
                try
                {
				    hr = FillWin9xInstance(pInstance, chsaList, chsaInstanceList, n, TRUE);
                }
                catch ( ... )
                {
                    Search.FreeSearchList( CSTRING_PTR, chsaList );
	                Search.FreeSearchList( CSTRING_PTR, chsaInstanceList );
                    throw ;
                }

				if (SUCCEEDED(hr))
				{
					hRet = pInstance->Commit();
					//hRet = WBEM_S_NO_ERROR;
				}
			}
		}	// end for loop
	}	// end if
	else
		hRet = WBEM_E_FAILED;

    Search.FreeSearchList( CSTRING_PTR, chsaList );
	Search.FreeSearchList( CSTRING_PTR, chsaInstanceList );
    return hRet;
}
#endif

#ifdef WIN9XONLY
HRESULT CWin32NetCli::Get9XObject(CInstance* pInstance, long lFlags /* =0L */)
{
	CRegistrySearch Search;
	HRESULT hr = WBEM_E_OUT_OF_MEMORY;
	UINT nCount = 0;
	CHPtrArray chsaList, chsaInstanceList;
	HRESULT hRet = WBEM_E_NOT_FOUND;

    Search.SearchAndBuildList( _T("Enum\\Network"), chsaList, _T("NetClient"),
								_T("Class"), VALUE_SEARCH );
	nCount = chsaList.GetSize();
    if( nCount )
    {
		for (int n=0; n<nCount; n++)
		{
			if (pInstance)
			{
				hr = FillWin9xInstance(pInstance, chsaList, chsaInstanceList, n, FALSE);
				if (SUCCEEDED(hr))
				{
//					Commit(pInstance);
				    Search.FreeSearchList( CSTRING_PTR, chsaList );
					hRet = WBEM_S_NO_ERROR;
				    return hRet;
				}
			}
		}	// end for loop
	}	// end if

    Search.FreeSearchList( CSTRING_PTR, chsaList );
    return hRet;
}
#endif

/////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT CWin32NetCli::FillWin9xInstance(CInstance *pInstance, CHPtrArray& chsaList, CHPtrArray& chsaInstList, UINT nIndex,
                                        BOOL bEnumerate)
{
	CRegistry Reg,PrimaryReg;
	CHString chsTmp,chsKey,*pPtr, *pName, *pNameTest;
//	CHPtrArray chsaList;
	struct tm tmDate;
	HRESULT hr = WBEM_E_FAILED;

	int n = 0;
	BOOL bFound = FALSE;

//    Search.SearchAndBuildList( _T("Enum\\Network"), chsaList, _T("NetClient"),
//								_T("Class"), VALUE_SEARCH );
    if( chsaList.GetSize() > 0 ){

        pPtr = ( CHString * ) chsaList.GetAt(nIndex);

		//========================================
		// Ok now open the display key
		//========================================
        if( pPtr )
        {
            if( PrimaryReg.Open( HKEY_LOCAL_MACHINE, *pPtr, KEY_READ ) == ERROR_SUCCESS)
            {
		        if( PrimaryReg.GetCurrentKeyValue( L"DeviceDesc",chsTmp )== ERROR_SUCCESS)
		        {
				     pInstance->SetCHString( IDS_Description, chsTmp );
					if (!bEnumerate)
					{
						pInstance->GetCHString( IDS_Name, chsKey );
						if (0 != chsKey.CompareNoCase(chsTmp))
						{
							return(WBEM_E_NOT_FOUND);
						}
					}
				     pInstance->SetCHString( IDS_Name, chsTmp );
				}
///////////////////////// if EnumerateInstances
				if (bEnumerate)
				{
					// add to instance list, or check if it is there....
					if (chsaInstList.GetSize() > 0)
					{
						// walk the list to find pPtr
						for (n=0; n<chsaInstList.GetSize() ; n++ )
						{
							pNameTest = (CHString*)chsaInstList.GetAt(n);
							if (0 == _wcsicmp(chsTmp, *pNameTest))
							{
								bFound = TRUE;
								// return because we do not need to fill the instance
								return (WBEM_E_FAILED);
							}
						}

						if (!bFound)
						{
							// if the pPtr is not found in the list, add it
							pName = new CHString(chsTmp);
                            if (pName != NULL)
                            {
                                try
                                {
							        chsaInstList.Add(pName);
                                }
                                catch ( ... )
                                {
                                    delete pName;
                                    throw ;
                                }
                            }
                            else
                            {
                                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                            }

						}	// end if
					}
					else
					{
						// the list is empty, so add pPtr
						pName = new CHString(chsTmp);
                        if (pName != NULL)
                        {
                            try
                            {
        						chsaInstList.Add(pName);
                            }
                            catch ( ... )
                            {
                                delete pName;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
					}
				}	// end if
/////////////////////////////////////

		        if( PrimaryReg.GetCurrentKeyValue( L"CompatibleIDs",chsTmp )== ERROR_SUCCESS)
		        {
				     pInstance->SetCHString( IDS_Caption, chsTmp );
				}

		        if( PrimaryReg.GetCurrentKeyValue( L"Mfg",chsTmp )== ERROR_SUCCESS)
		        {
				     pInstance->SetCHString( IDS_Manufacturer, chsTmp );
				}



				//===================================================
				//  Go get the Install Date and Status
				//===================================================
				if( PrimaryReg.GetCurrentKeyValue(L"Driver",chsTmp) == ERROR_SUCCESS)
				{
					CHString chsKey = L"System\\CurrentControlSet\\Services\\Class\\"+chsTmp;
					if( Reg.Open( HKEY_LOCAL_MACHINE,chsKey,KEY_READ) == ERROR_SUCCESS )
					{
						if( Reg.GetCurrentKeyValue(L"DriverDate",chsTmp) == ERROR_SUCCESS )
						{
							memset(&tmDate, 0, sizeof(tmDate)) ;
							swscanf(chsTmp,L"%d-%d-%d",
										&tmDate.tm_mon,
										&tmDate.tm_mday,
										&tmDate.tm_year);
							tmDate.tm_year = tmDate.tm_year - 1900;
							tmDate.tm_mon--;
							pInstance->SetDateTime( IDS_InstallDate,(const struct tm) tmDate);
						}
					}
				}

				if(PrimaryReg.GetCurrentKeyValue(L"MasterCopy",chsTmp) == ERROR_SUCCESS)
				{
					CConfigMgrDevice Cfg;
					if( Cfg.GetStatus(chsTmp))
					{
						pInstance->SetCHString( IDS_Status,chsTmp);
					}
				}

				pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
				hr = WBEM_S_NO_ERROR;
			}
		}
    }
	return hr;
}
#endif

#ifdef NTONLY
HRESULT CWin32NetCli::GetNTObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
	HRESULT	hr = WBEM_E_NOT_FOUND;
	CRegistry
				Reg;
	CHString chsTemp,
				chsName,
				chsTmp,
				chsKey,
				chsNamePassedIn,
				chsClient;
	int		nIndex = 0;
	LONG		lRes;

	BOOL bMultiple = FALSE;

	// get key from passed in instance
	if (NULL != pInstance)
    {
		pInstance->GetCHString(IDS_Name, chsNamePassedIn);
    }

	if ((lRes = Reg.OpenLocalMachineKeyAndReadValue(
		_T("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order"),
		_T("ProviderOrder"), chsTemp)) != ERROR_SUCCESS)
		return WinErrorToWBEMhResult(lRes);

	// multiple clients are stored here delimitted by a comma
	nIndex = chsTemp.Find(_T(","));

	while (chsTemp.GetLength())
	{
		// now we need to get the last instance
		if (-1 == nIndex)
		{
			chsClient = chsTemp;
			chsTemp = _T("");
		}
		else
		{
			chsClient = chsTemp.Left(nIndex);

            // peel left hand string off temp string.
			chsTemp = chsTemp.Mid(nIndex + 1);
		}

		if (NULL != pInstance)
		{
			//=======================================================
			//  Get Name, Manufacturer
			//=======================================================
			chsKey = CHString(L"SYSTEM\\CurrentControlSet\\Services\\") + chsClient + CHString(L"\\NetworkProvider");
     		if( Reg.OpenLocalMachineKeyAndReadValue( chsKey, _T("Name"), chsName) == ERROR_SUCCESS)
     		{
				// compare strings to see if there is an object to get
				if (0 == chsNamePassedIn.CompareNoCase(chsName))
				{
					// fill the instance
					hr = FillNTInstance(pInstance, chsClient);
					break;
				}
			}	// end if
		}	// end if

		nIndex = chsTemp.Find(_T(","));
	}	// end while

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\netconn.h ===
//=================================================================

//

// NetConn.h -- ent network connection property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
// Revisions:    05/25/99    a-peterc		Reworked...
//
//=================================================================
#include "cnetconn.h"

// Property set identification
//============================

#define	PROPSET_NAME_NETCONNECTION	L"Win32_NetworkConnection"

// Utility defines
//================


// Property set identification
//============================

class CWin32NetConnection : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32NetConnection(LPCWSTR strName, LPCWSTR pszNamespace) ;
       ~CWin32NetConnection() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	private:

        // Utility functions
        //==================
  		void LoadPropertyValues (

			CConnection *a_pConnection, 
			CInstance *a_pInst
		);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\netconn.cpp ===
//=================================================================

//

// NetConn.CPP -- ent network connection property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   08/01/96    a-jmoon			Created
//				09/10/97	a-sanjes		Added CImpersonateLoggedOnUser
//				05/25/99	a-peterc		Reworked...
//
//=================================================================

#include "precomp.h"
#include <lmuse.h>
#include "DllWrapperBase.h"
#include "MprApi.h"
#include "netconn.h"

#include "resource.h"

#include "sid.h"
#include "accessentrylist.h"
#include <accctrl.h>
#include "AccessRights.h"
#include "ObjAccessRights.h"

// Property set declaration
//=========================

CWin32NetConnection	win32NetConnection( PROPSET_NAME_NETCONNECTION, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetConnection::CWin32NetConnection
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for provider.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CWin32NetConnection :: CWin32NetConnection (

	LPCWSTR strName,
	LPCWSTR pszNamespace /*=NULL*/

) : Provider ( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32NetConnection::~CWin32NetConnection
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CWin32NetConnection::~CWin32NetConnection()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32NetConnection::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32NetConnection :: GetObject ( CInstance* a_pInst, long lFlags /*= 0L*/ )
{
    HRESULT			t_hResult = WBEM_E_NOT_FOUND ;
    CHString		t_strName ;

	CConnection		t_oConnection ;
	CNetConnection	t_Net ;

	a_pInst->GetCHString( IDS_Name, t_strName ) ;

	if( t_Net.GetConnection( t_strName, t_oConnection ) )
	{
        LoadPropertyValues( &t_oConnection, a_pInst ) ;

		t_hResult = WBEM_S_NO_ERROR ;
 	}

    return t_hResult ;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32NetConnection::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32NetConnection :: EnumerateInstances (

	MethodContext *a_pMethodContext,
	long a_lFlags /*= 0L*/
)
{
	HRESULT			t_hResult = WBEM_S_NO_ERROR ;

	CInstancePtr	t_pInst ;
	CConnection		*t_pConnection= NULL ;
	CNetConnection	t_Net ;

	t_Net.BeginConnectionEnum() ;

	while( t_Net.GetNextConnection( &t_pConnection ) && t_pConnection )
	{
		if( !t_pConnection->strKeyName.IsEmpty() )
		{
            t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

			LoadPropertyValues( t_pConnection, t_pInst ) ;

		    t_hResult = t_pInst->Commit() ;
		}
	}

    return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CNetConnection::LoadPropertyValues
 *
 *  DESCRIPTION : Sets property values according to contents of passed
 *                CConnection structure
 *
 *  INPUTS      : pointer to CConnection structure
 *                a_pInst - Instance object to load with values.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32NetConnection :: LoadPropertyValues (

	CConnection *a_pConnection,
	CInstance *a_pInst
)
{
    // Sanity check
    //=============
    if( a_pConnection == NULL )
	{
        return ;
    }

#ifdef NTONLY
#if 0
    ACCESS_MASK t_AccessMask;
    // Obtains an access mask reflecting the effective rights (held
    // by the user associated with the current thread) to the object.
    CObjAccessRights t_coar(a_pConnection->chsRemoteName, SE_LMSHARE, true);
    if(t_coar.GetError() == ERROR_SUCCESS)
    {
        if(t_coar.GetEffectiveAccessRights(&t_AccessMask) == ERROR_SUCCESS)
        {
            a_pInst->SetDWORD( IDS_AccessMask, t_AccessMask );
        }
    }
    else if(t_coar.GetError() == ERROR_ACCESS_DENIED)
    {
        a_pInst->SetDWORD( IDS_AccessMask, 0L );
    }
#else
	CHString dirname(a_pConnection->chsRemoteName);
	dirname += L"\\";
	SmartCloseHandle hFile = CreateFile(dirname,
										MAXIMUM_ALLOWED,
										FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
										NULL,
										OPEN_EXISTING,
										FILE_FLAG_BACKUP_SEMANTICS,
										NULL
										);

	DWORD dwErr = GetLastError();

	if ((hFile == INVALID_HANDLE_VALUE) &&
		(dwErr != ERROR_ACCESS_DENIED) &&
		!a_pConnection->chsLocalName.IsEmpty()
	)
	{
		//try the local name as a dir...
		dirname = L"\\\\.\\";
		dirname += a_pConnection->chsLocalName;
		dirname += L'\\';
		hFile = CreateFile(dirname,
							MAXIMUM_ALLOWED,
							FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
							NULL,
							OPEN_EXISTING,
							FILE_FLAG_BACKUP_SEMANTICS,
							NULL
							);
		dwErr = GetLastError();
	}

	if (hFile != INVALID_HANDLE_VALUE)
	{
		FILE_ACCESS_INFORMATION fai;
		IO_STATUS_BLOCK iosb;
		memset(&fai, 0, sizeof(FILE_ACCESS_INFORMATION));
		memset(&iosb, 0, sizeof(IO_STATUS_BLOCK));

		if ( NT_SUCCESS( NtQueryInformationFile( hFile,
                             &iosb,
                             &fai,
                             sizeof( FILE_ACCESS_INFORMATION ),
                             FileAccessInformation
                           ) )
		)
		{
			a_pInst->SetDWORD(IDS_AccessMask, (DWORD)(fai.AccessFlags));
		}
	}
	else
	{
		if (dwErr == ERROR_ACCESS_DENIED)
		{
			a_pInst->SetDWORD( IDS_AccessMask, 0L );
		}
	}

#endif
#endif

	a_pInst->SetCHString( IDS_Name, a_pConnection->strKeyName );

    if( !a_pConnection->chsLocalName.IsEmpty() )
	{
        a_pInst->SetCHString( IDS_LocalName, a_pConnection->chsLocalName ) ;
    }

    if( !a_pConnection->chsRemoteName.IsEmpty() )
	{
        a_pInst->SetCHString( IDS_RemoteName, a_pConnection->chsRemoteName ) ;
        a_pInst->SetCHString( IDS_RemotePath, a_pConnection->chsRemoteName ) ;
    }

    if( !a_pConnection->chsProvider.IsEmpty() )
	{
        a_pInst->SetCHString( IDS_ProviderName, a_pConnection->chsProvider ) ;
    }

    if( !a_pConnection->chsComment.IsEmpty() )
	{
        a_pInst->SetCHString( IDS_Comment, a_pConnection->chsComment ) ;
    }
	else
	{
        a_pInst->SetCHString( IDS_Comment, _T(" ") ) ;
	}

	// "Persistent" connection
    CHString sTemp2;

    if( CConnection::e_Remembered == a_pConnection->eScope )
    {
		a_pInst->Setbool( L"Persistent",true ) ;

		a_pInst->SetCHString( IDS_ConnectionType, IDS_Persistent ) ;

        LoadStringW(sTemp2, IDR_Resource_Remembered);

		if( !a_pConnection->chsProvider.IsEmpty() )
        {
            CHString t_chsStr;
			CHString t_chsDesc( a_pConnection->chsProvider ) ;

            Format( t_chsStr, IDR_ResourceRememberedFormat, t_chsDesc ) ;
			a_pInst->SetCHString( IDS_Description, t_chsStr ) ;
		}
	}
	else
	{
		a_pInst->Setbool( L"Persistent", false ) ;

		a_pInst->SetCHString( IDS_ConnectionType, IDS_Current ) ;

        LoadStringW(sTemp2, IDR_Resource_Connected);

		if( !a_pConnection->chsProvider.IsEmpty() )
        {
            CHString t_chsStr;
			CHString t_chsDesc( a_pConnection->chsProvider ) ;

            Format( t_chsStr, IDR_ResourceConnectedFormat, t_chsDesc ) ;

			a_pInst->SetCHString( IDS_Description, t_chsStr ) ;
		}
	}

	a_pInst->SetCHString( IDS_Caption, sTemp2 ) ;

    switch( a_pConnection->dwDisplayType )
	{
        case RESOURCEDISPLAYTYPE_DOMAIN:
		{
            a_pInst->SetCHString( IDS_DisplayType, L"Domain" );
		}
        break ;

        case RESOURCEDISPLAYTYPE_GENERIC :
		{
            a_pInst->SetCHString( IDS_DisplayType, L"Generic" );
		}
        break ;

        case RESOURCEDISPLAYTYPE_SERVER :
		{
            a_pInst->SetCHString( IDS_DisplayType, L"Server" );
		}
        break ;

        case RESOURCEDISPLAYTYPE_SHARE :
		{
            a_pInst->SetCHString( IDS_DisplayType, L"Share" );
		}
        break ;
    }

    switch( a_pConnection->dwType )
	{
        case RESOURCETYPE_DISK:
		{
            a_pInst->SetCHString( IDS_ResourceType, L"Disk" );
		}
        break ;

        case RESOURCETYPE_PRINT :
		{
            a_pInst->SetCHString( IDS_ResourceType, L"Print" );
		}
        break ;

		case RESOURCETYPE_ANY:
		{
			a_pInst->SetCHString( IDS_ResourceType, L"Any" );
		}
		break;

		default:
		{
			a_pInst->SetCHString( IDS_ResourceType, L"Any" );
		}
		break;
    }

	a_pInst->SetCHString( IDS_UserName, a_pConnection->strUserName );

    switch( a_pConnection->dwStatus )
    {
        case USE_OK:
		{
			a_pInst->SetCHString( L"ConnectionState", _T("Connected") ) ;
            a_pInst->SetCHString( IDS_Status, IDS_STATUS_OK ) ;
		}
        break;

        case USE_PAUSED:
		{
			a_pInst->SetCHString( L"ConnectionState", _T("Paused") ) ;
            a_pInst->SetCHString( IDS_Status, _T("Degraded") ) ;
        }
		break;

        case USE_DISCONN:
		{
			a_pInst->SetCHString( L"ConnectionState", _T("Disconnected") ) ;
            a_pInst->SetCHString( IDS_Status, _T("Degraded") ) ;
		}
        break;

        case USE_CONN:
		{
			a_pInst->SetCHString( L"ConnectionState", _T("Connecting") ) ;
            a_pInst->SetCHString( IDS_Status, _T("Starting") ) ;
        }
		break;

        case USE_RECONN:
		{
			a_pInst->SetCHString( L"ConnectionState", _T("Reconnecting") ) ;
            a_pInst->SetCHString( IDS_Status, _T("Starting") ) ;
        }
		break;

        case ERROR_NOT_CONNECTED:
        {
			a_pInst->SetCHString( L"ConnectionState", _T("Disconnected") ) ;
            a_pInst->SetCHString( IDS_Status, _T("Unavailable") ) ;
        }
        break;

        default:
        case USE_NETERR:
		{
			a_pInst->SetCHString( L"ConnectionState", IDS_STATUS_Error ) ;
            a_pInst->SetCHString( IDS_Status, IDS_STATUS_Error ) ;
		}
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\ntdriverio.cpp ===
//=================================================================

//

// NTDriverIO.cpp --

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/15/98	        Created
//
//				03/03/99    		Added graceful exit on SEH and memory failures,
//											syntactic clean up
//=================================================================






#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"

#include "NTDriverIO.h"
#include <ntsecapi.h>
#include "DllWrapperBase.h"
#include "NtDllApi.h"

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  void NTDriverIO::NTDriverIO()

 Description: encapsulates the functionallity of NtDll.dll's NtCreatefile

 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	  15-Nov-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

NTDriverIO::NTDriverIO( PWSTR a_pDriver )
{
	NTDriverIO();
	m_hDriverHandle = Open( a_pDriver );
}

NTDriverIO::NTDriverIO()
{
	m_hDriverHandle	= INVALID_HANDLE_VALUE;
}

NTDriverIO::~NTDriverIO()
{
	if( INVALID_HANDLE_VALUE != m_hDriverHandle )
	{
		Close( m_hDriverHandle ) ;
	}
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  HANDLE NTDriverIO::Open( PWSTR pDriver )

 Description: encapsulates the functionallity of NtDll.dll's NtCreatefile

 Arguments:
 Returns:	HANDLE to the driver
 Inputs:	PCWSTR pDriver
 Outputs:
 Caveats:
 Raid:
 History:	  15-Nov-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

HANDLE NTDriverIO::Open( PWSTR a_pDriver )
{
	CNtDllApi *t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidNtDllApi, NULL ) ;

	if( t_pNtDll == NULL )
    {
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	HANDLE				t_hDriverHandle ;
	OBJECT_ATTRIBUTES	t_objectAttributes ;
    IO_STATUS_BLOCK		t_iosb ;
    UNICODE_STRING		t_string ;

	t_pNtDll->RtlInitUnicodeString( &t_string, a_pDriver ) ;

    InitializeObjectAttributes(	&t_objectAttributes,
								&t_string,
								OBJ_CASE_INSENSITIVE,
								NULL,
								NULL
								);

	NTSTATUS t_status =
		t_pNtDll->NtCreateFile(
					&t_hDriverHandle,					// FileHandle
					SYNCHRONIZE | GENERIC_EXECUTE,		// DesiredAccess
					&t_objectAttributes,				// ObjectAttributes
					&t_iosb,							// IoStatusBlock
					NULL,								// AllocationSize
					FILE_ATTRIBUTE_NORMAL,				// FileAttributes
					FILE_SHARE_READ | FILE_SHARE_WRITE,	// ShareAccess
					FILE_OPEN_IF,						// CreateDisposition
					FILE_SYNCHRONOUS_IO_NONALERT,		// CreateOptions
					NULL,								// EaBuffer
					0									// EaLength
					);

    CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidNtDllApi, t_pNtDll ) ;
    t_pNtDll = NULL ;

	return NT_SUCCESS( t_status) ? t_hDriverHandle : INVALID_HANDLE_VALUE ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  HANDLE NTDriverIO::GetHandle()

 Description: returns the class creation scope driver handle

 Arguments:
 Returns:	HANDLE to the driver
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	  15-Nov-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

HANDLE NTDriverIO::GetHandle()
{
	return m_hDriverHandle ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  bool NTDriverIO::Close( HANDLE hDriver )

 Description: encapsulates the functionallity of NtDll.dll's NtCreatefile

 Arguments:
 Returns:	Boolean
 Inputs:	HANDLE to the driver
 Outputs:
 Caveats:
 Raid:
 History:	  15-Nov-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

bool NTDriverIO::Close( HANDLE a_hDriver )
{
    CNtDllApi *t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource( g_guidNtDllApi, NULL ) ;

	if( t_pNtDll == NULL )
    {
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	NTSTATUS t_status = t_pNtDll->NtClose( a_hDriver );

    CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidNtDllApi, t_pNtDll ) ;
    t_pNtDll = NULL ;

	return NT_SUCCESS( t_status ) ? true : false ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\ntlastboottime.h ===
//============================================================

//

// ntlastboottime.h - Performance Data helper class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 11/23/97     a-sanjes     created
//
//============================================================

#ifndef __NTLASTBOOTTIME_H__
#define __NTLASTBOOTTIME_H__

class CNTLastBootTime
{
	public :
		static CRITICAL_SECTION m_cs;

		CNTLastBootTime() ;
		~CNTLastBootTime() ;

		BOOL GetLastBootTime( FILETIME &a_ft );

	private:

		static bool			m_fGotTime;
		static FILETIME		m_ft;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\ntdriverio.h ===
//=================================================================

//

// NTDriverIO.h -- 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/15/98	        Created

//=================================================================
class NTDriverIO
{
	private:
		
		bool		m_fAlive;
		HANDLE		m_hDriverHandle; 
  	
	protected:
	public:
	        
        //=================================================
        // Constructor/destructor
        //=================================================
        NTDriverIO( PWSTR pDriver );
		NTDriverIO();
       ~NTDriverIO();

    	HANDLE	Open( PWSTR pDriver );
		bool	Close( HANDLE hDriver );
		HANDLE	GetHandle();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\ntlastboottime.cpp ===
//=================================================================

//

// ntlastboottime.CPP -- NT Last Boot Time Helper class

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:	11/23/97    a-sanjes		Created
//
//=================================================================

#include "precomp.h"
#include "perfdata.h"
#include <cregcls.h>
#include <cominit.h>
#include "ntlastboottime.h"
#include <createmutexasprocess.h>

#ifdef NTONLY
// Static Initialization
bool		CNTLastBootTime::m_fGotTime = FALSE;
FILETIME	CNTLastBootTime::m_ft;
CRITICAL_SECTION CNTLastBootTime::m_cs;

//////////////////////////////////////////////////////////
//
//	Function:	CNTLastBootTime::CNTLastBootTime
//
//	Default constructor
//
//	Inputs:
//				None
//
//	Outputs:
//				None
//
//	Returns:
//				None
//
//	Comments:
//
//////////////////////////////////////////////////////////

CNTLastBootTime::CNTLastBootTime( void )
{
}

//////////////////////////////////////////////////////////
//
//	Function:	CNTLastBootTime::~CNTLastBootTime
//
//	Destructor
//
//	Inputs:
//				None
//
//	Outputs:
//				None
//
//	Returns:
//				None
//
//	Comments:
//
//////////////////////////////////////////////////////////

CNTLastBootTime::~CNTLastBootTime( void )
{
	// Because this object is intended to be instantiated as a stack variable,
	// we do NOT want to perform the CPerformanceData.Close() operation in
	// this destructor.  We will leave it to the statically instantiated classes
	// to do this for us.  Because it only needs to happen once and only once,
	// this handles our HKEY_PERFORMANCE_DATA opens just fine.  Besides, this
	// class ensures that for getting the last boot time, we hit the performance
	// data once and only once.
}


//////////////////////////////////////////////////////////
//
//	Function:	CNTLastBootTime::GetLastBootTime
//
//	Inputs:
//		None
//
//	Outputs:
//		struct tm&		tmLastBootTime - Last Boot Time of machine
//											in tm format.
//
//
//	Returns: TRUE/FALSE- Whether or not we got the time.
//
//	Comments:	If we don't have the value, grabs it from
//				the performance data and caches it, so we
//				minimize the number of times we actually have
//				to hit the performance data.
//
//////////////////////////////////////////////////////////
BOOL CNTLastBootTime::GetLastBootTime ( FILETIME &a_ft )
{
	BOOL	fReturn = FALSE;

	// Check the static variable indicating that we have the time.  If it is
	// TRUE, we've already got the time.  If not, then we need to initialize the
	// data from PerformanceData, but since this may be happening on multiple
	// threads, we're going to use a named Mutex to protect the static data.
	
	EnterCriticalSection(&m_cs);
	
	try
	{
		if ( !m_fGotTime )
		{
			SYSTEM_TIMEOFDAY_INFORMATION t_TODInformation;

			if ( NT_SUCCESS(NtQuerySystemInformation(SystemTimeOfDayInformation,
										&t_TODInformation,
										sizeof(t_TODInformation),
										NULL)) )
			{
				memcpy(&m_ft, &t_TODInformation.BootTime, sizeof(t_TODInformation.BootTime));
				m_fGotTime = TRUE;
			}
		}
	}
	catch(...)
	{
		LeaveCriticalSection(&m_cs);
		throw;
	}

	LeaveCriticalSection(&m_cs);

	// Now, if we have the time, copy the value.
	if ( m_fGotTime )
	{
		CopyMemory( &a_ft, &m_ft, sizeof(m_ft) );
		fReturn = TRUE;
	}

	return fReturn;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\nvram.h ===
//============================================================

//

// NVRAM.h - SETPUDLL.DLL access class definition

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// 08/05/98     sotteson     created
//
//============================================================

#ifndef __NVRAM__
#define __NVARM__

#include <list>
#include <ntexapi.h>

typedef std::list<CHString> CHSTRINGLIST;
typedef std::list<CHString>::iterator CHSTRINGLIST_ITERATOR;

class CNVRam
{
public:
	CNVRam();
	~CNVRam();
//     privilege in question is SE_SYSTEM_ENVIRONMENT_NAME
    enum InitReturns {Success, LoadLibFailed, PrivilegeNotHeld, ProcNotFound};

	CNVRam::InitReturns Init();

	BOOL GetNVRamVar(LPWSTR szVar, CHSTRINGLIST *pList);
	BOOL GetNVRamVar(LPWSTR szVar, DWORD *pdwValue);
	BOOL GetNVRamVar(LPWSTR szVar, CHString &strValue);

	BOOL SetNVRamVar(LPWSTR szVar, CHSTRINGLIST *pList);
	BOOL SetNVRamVar(LPWSTR szVar, DWORD dwValue);
	BOOL SetNVRamVar(LPWSTR szVar, LPWSTR szValue);

//#if defined(EFI_NVRAM_ENABLED)

#if defined(_IA64_)
    BOOL IsEfi() { return TRUE; }
#else
    BOOL IsEfi() { return FALSE; }
#endif

    BOOL GetBootOptions(SAFEARRAY **ppsaNames, DWORD *pdwTimeout, DWORD *pdwCount);
    BOOL SetBootTimeout(DWORD dwTimeout);
    BOOL SetDefaultBootEntry(BYTE cIndex);

//endif // defined(EFI_NVRAM_ENABLED)

protected:

	BOOL GetNVRamVarRaw(LPWSTR szVar, CHString &strValue);
	BOOL SetNVRamVarRaw(LPWSTR szVar, LPWSTR szValue);
    
};

#endif // File inclusion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\os.cpp ===
//=================================================================

//

// OS.CPP -- Operating system property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/25/97    davwoh         Moved to curly
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "wbemnetapi32.h"
#include <lmwksta.h>
#include <CreateMutexAsProcess.h>

#include <locale.h>

#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"



#include "perfdata.h"
#include "os.h"
#include "WBEMPSAPI.h"
#include "WBEMToolH.h"

#include "pagefile.h"
#include "computersystem.h"
#include "ntlastboottime.h"
#include <cominit.h>
#include <winnls.h>
#include "Kernel32Api.h"
#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include "impself.h"

#include "SecurityApi.h"
#include <wtsapi32.h>

#include "KUserdata.h"

//#define SE_SHUTDOWN_NAME                  TEXT("SeShutdownPrivilege")
//#define SE_REMOTE_SHUTDOWN_NAME           TEXT("SeRemoteShutdownPrivilege")

#if(_WIN32_WINNT < 0x0500)
#define EWX_FORCEIFHUNG      0x00000010
#endif /* _WIN32_WINNT >= 0x0500 */

#define WIN32_SHUTDOWNOPTIONS (     EWX_LOGOFF      | \
                                    EWX_SHUTDOWN    | \
                                    EWX_REBOOT      | \
                                    EWX_FORCE       | \
                                    EWX_POWEROFF    )

#define NT5_WIN32_SHUTDOWNOPTIONS ( WIN32_SHUTDOWNOPTIONS | EWX_FORCEIFHUNG )

//typedef BOOL (WINAPI *lpKERNEL32_GlobalMemoryStatusEx) (IN OUT LPMEMORYSTATUSEX lpBuffer);

// This file can't be included since it conflicts with the nt header.  Grrr.  So,
// I have copy/pasted the structure I need into my .h file.
//#include <svrapi.h>  // Win95 NetServerGetInfo

// Property set declaration
//=========================

CWin32OS MyOSSet(PROPSET_NAME_OS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::CWin32OS
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32OS::CWin32OS(LPCWSTR name, LPCWSTR pszNamespace)
:Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::~CWin32OS
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32OS::~CWin32OS()
{
    // Because of performance issues with HKEY_PERFORMANCE_DATA, we close in the
    // destructor so we don't force all the performance counter dlls to get
    // unloaded from memory, and also to prevent an apparent memory leak
    // caused by calling RegCloseKey( HKEY_PERFORMANCE_DATA ).  We use the
    // class since it has its own internal synchronization.  Also, since
    // we are forcing synchronization, we get rid of the chance of an apparent
    // deadlock caused by one thread loading the performance counter dlls
    // and another thread unloading the performance counter dlls

    // Per raid 48395, we aren't going to shut this at all.

#ifdef NTONLY
//  CPerformanceData    perfdata;

//  perfdata.Close();
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32OS::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
   HRESULT hr;
   CInstancePtr pInstance (CreateNewInstance(pMethodContext), false);

   if (pInstance)
   {
      CSystemName cSN;
      cSN.SetKeys(pInstance);

      if (!pQuery.KeysOnly())
      {
         GetRunningOSInfo(pInstance, cSN.GetLocalizedName(), &pQuery) ;
      }

      hr = pInstance->Commit() ;
   }
   else
   {
      hr = WBEM_E_OUT_OF_MEMORY;
   }

   return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    : Returns info for running OS only until we discover other
 *                installed OSes
 *
 *****************************************************************************/

HRESULT CWin32OS::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CSystemName cSN;

    if (!cSN.ObjectIsUs(pInstance))
    {
        return WBEM_E_NOT_FOUND;
    }

    if (!pQuery.KeysOnly())
    {
        GetRunningOSInfo(pInstance, cSN.GetLocalizedName(), NULL) ;
    }

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each discovered OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    : Returns only running OS info until we discover installed OSes
 *
 *****************************************************************************/

HRESULT CWin32OS::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
   // Create instance for running OS
   //===============================
    HRESULT hr = WBEM_S_NO_ERROR;
   CInstancePtr pInstance (CreateNewInstance(pMethodContext), false);
   if (pInstance)
   {
       CSystemName cSN;
       cSN.SetKeys(pInstance);

       GetRunningOSInfo(pInstance, cSN.GetLocalizedName(), NULL) ;
       hr = pInstance->Commit () ;
   }
   else
       hr = WBEM_E_OUT_OF_MEMORY;
   return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetRunningOSInfo
 *
 *  DESCRIPTION : Assigns property values according to currently running OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32OS::GetRunningOSInfo(CInstance *pInstance, const CHString &sName, CFrameworkQuery *pQuery)
{
    WCHAR   wszTemp[_MAX_PATH];
    TCHAR   szTemp[_MAX_PATH];
    CRegistry RegInfo ;
    TCHAR szBuffer[MAXI64TOA +1];

    // Refresh properties for running OS (redundant until we're discovering others)
    //=============================================================================

	// EncryptionLevel
	DWORD t_dwCipherStrength = GetCipherStrength() ;
	if( t_dwCipherStrength )
	{
		pInstance->SetWORD( L"EncryptionLevel", t_dwCipherStrength ) ;
	}

	// SystemDrive
	TCHAR t_szDir[_MAX_PATH];
	TCHAR t_szDrive[_MAX_DRIVE];

	if( GetWindowsDirectory( t_szDir, sizeof(t_szDir)/sizeof(TCHAR) ) )
	{
		_tsplitpath( t_szDir, t_szDrive, NULL, NULL, NULL ) ;

		pInstance->SetCharSplat( L"SystemDrive", t_szDrive ) ;
	}

	//
    GetProductSuites( pInstance );

    // Note: use the Ex fields only when an explicit test is made on dwOSVersionInfoSize for Ex length.
#ifdef NTONLY
    OSVERSIONINFOEX OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = IsWinNT5() ? sizeof(OSVERSIONINFOEX) : sizeof(OSVERSIONINFO) ;
#endif
#ifdef WIN9XONLY
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;
#endif


    GetVersionEx((OSVERSIONINFO*)&OSVersionInfo);


#ifdef NTONLY
    // NT 5 and beyond
    if(OSVersionInfo.dwOSVersionInfoSize == sizeof(OSVERSIONINFOEX) )
    {
        pInstance->SetWORD(L"ServicePackMajorVersion", OSVersionInfo.wServicePackMajor);
        pInstance->SetWORD(L"ServicePackMinorVersion", OSVersionInfo.wServicePackMinor);
    }

    KUserdata	t_ku ;

	if ( t_ku.ProductTypeIsValid() )
	{
		pInstance->SetDWORD(L"ProductType", (DWORD) t_ku.NtProductType());
		pInstance->SetDWORD(L"SuiteMask", (DWORD) t_ku.SuiteMask());
	}
#endif

    // These are 'of-course' until we start discovering 'installed' OS's
    //==================================================================

    pInstance->SetDWORD(L"MaxNumberOfProcesses", 0xffffffff);
    pInstance->SetCharSplat(IDS_Caption, sName);
    pInstance->Setbool(L"Distributed", false);
    pInstance->Setbool(L"Primary", true );
    pInstance->SetCharSplat(IDS_Manufacturer, L"Microsoft Corporation");
    pInstance->SetCharSplat(IDS_CreationClassName, PROPSET_NAME_OS);
    pInstance->SetCharSplat(IDS_CSCreationClassName, PROPSET_NAME_COMPSYS);
    pInstance->SetCHString(L"CSName", GetLocalComputerName());
    pInstance->SetCharSplat(IDS_Status, L"OK");

    SYSTEMTIME tTemp ;
    GetSystemTime(&tTemp) ;
    pInstance->SetDateTime(L"LocalDateTime",tTemp );

    // This may get overridden below
    pInstance->SetCharSplat(L"Description", sName);

    // Extract what we can from OSVERSIONINFO
    //=======================================

//    sprintf(szTemp, "%d.%d", OSVersionInfo.dwMajorVersion, OSVersionInfo.dwMinorVersion) ;
//    pInstance->SetCharSplat("Version", szTemp );

    swprintf(wszTemp, L"%d.%d.%hu",
        OSVersionInfo.dwMajorVersion, OSVersionInfo.dwMinorVersion,
            LOWORD(OSVersionInfo.dwBuildNumber)) ;
    pInstance->SetCharSplat(L"Version", wszTemp );

    // Windows 95 Build Number is held in the LOWORD of the dwBuildNumber.  The
    // HIWORD echoes the Major and Minor Version Numbers.  NT uses the whole dword
   // for the build number.  We'll be ok for the next ~64000 builds or so
    swprintf(wszTemp, L"%hu", LOWORD(OSVersionInfo.dwBuildNumber) ) ;
    pInstance->SetCharSplat(L"BuildNumber", wszTemp);

    pInstance->SetCharSplat(L"CSDVersion", OSVersionInfo.szCSDVersion );


    // Get system directory
    //=================================
    if(GetSystemDirectory(szTemp, sizeof(szTemp) / sizeof(TCHAR)))
    {
        pInstance->SetCharSplat(L"SystemDirectory", szTemp);
    }

    // Amazingly, locale info is in the same place in both NT & Win95 registries
    //==========================================================================

    // Obtain the locale

    if ( GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_ILANGUAGE, szTemp, _MAX_PATH ) )
    {
        pInstance->SetCharSplat(L"Locale", szTemp);
    }

    // Get current Timezone
    TIME_ZONE_INFORMATION   tzone;
    DWORD                   dwRet;

    if (TIME_ZONE_ID_INVALID == (dwRet = GetTimeZoneInformation(&tzone)))
        return;

    if (dwRet == TIME_ZONE_ID_DAYLIGHT)
        tzone.Bias += tzone.DaylightBias;
    else
        // This is normally 0 but is non-zero in some timezones.
        tzone.Bias += tzone.StandardBias;

    pInstance->SetWBEMINT16(IDS_CurrentTimeZone, -1 * tzone.Bias);

    // Obtain the system default Country Code

    if ( GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_ICOUNTRY, szTemp, _MAX_PATH ) )
    {
        pInstance->SetCharSplat(L"CountryCode", szTemp);
    }

    // Obtain the ANSI system default Code Page and stick this puppy in Code Set
    // It's a best guess.  We probably oughta have a separate OEM Code Set property
    // to handle Japanese/Korean/etc.

    if ( GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE, szTemp, _MAX_PATH ) )
    {
        pInstance->SetCharSplat(L"CodeSet", szTemp);
    }



   if ((pQuery == NULL) || (pQuery->IsPropertyRequired(L"NumberOfProcesses")))
   {
      // Get list of processes
      //==================
      TRefPointerCollection<CInstance> Processes;
      DWORD dwProcesses = 0;
      MethodContext *pMethodContext = pInstance->GetMethodContext();
//      if SUCCEEDED(CWbemProviderGlue::GetAllInstances(_T("Win32_Process"),
//        &Processes, IDS_CimWin32Namespace, pMethodContext))
      if SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(L"SELECT __RELPATH FROM Win32_Process",
        &Processes, pMethodContext, GetNamespace()))
      {
         REFPTRCOLLECTION_POSITION pos;

         if (Processes.BeginEnum(pos))
         {
            CInstancePtr pProcess;
            for (pProcess.Attach(Processes.GetNext( pos ));
                 pProcess != NULL;
                 pProcess.Attach(Processes.GetNext( pos )))
            {
               dwProcesses++;
            }
         }
         Processes.EndEnum();
      }

      pInstance->SetDWORD(L"NumberOfProcesses", dwProcesses);
   }

   pInstance->Setbool(L"Debug", GetSystemMetrics(SM_DEBUG));

#ifdef NTONLY
    if( IsWinNT5() )
    {
        CKernel32Api* pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
        if(pKernel32 != NULL)
        {

            MEMORYSTATUSEX  stMemoryVLM;
                            stMemoryVLM.dwLength = sizeof( MEMORYSTATUSEX );

            BOOL bRetCode;
            if(pKernel32->GlobalMemoryStatusEx(&stMemoryVLM, &bRetCode) && bRetCode)
            {
                // All divided by 1024 because the units are in KB.
                pInstance->SetCharSplat(_T("FreePhysicalMemory"),
                    _i64tot(stMemoryVLM.ullAvailPhys / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("FreeVirtualMemory"),
                    _i64tot( ( stMemoryVLM.ullAvailPhys + stMemoryVLM.ullAvailPageFile ) / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("TotalVirtualMemorySize"),
                    _i64tot((stMemoryVLM.ullTotalPhys + stMemoryVLM.ullTotalPageFile ) / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("SizeStoredInPagingFiles"),
                    _i64tot(stMemoryVLM.ullTotalPageFile  / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("FreeSpaceInPagingFiles"),
                    _i64tot(stMemoryVLM.ullAvailPageFile / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("MaxProcessMemorySize"),
                    _i64tot(stMemoryVLM.ullTotalVirtual / 1024, szBuffer, 10));

                pInstance->SetCharSplat(_T("TotalVisibleMemorySize"),
                    _i64tot(stMemoryVLM.ullTotalPhys / 1024, szBuffer, 10));
            }
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
            pKernel32 = NULL;
        }
  }
  else
#endif
  {
        MEMORYSTATUS stMemory;
        GlobalMemoryStatus(&stMemory);

        // All divided by 1024 because the units are in KB.
        pInstance->SetCharSplat(L"FreePhysicalMemory",
            _i64tot(stMemory.dwAvailPhys / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"FreeVirtualMemory",
            _i64tot( ( stMemory.dwAvailPhys + stMemory.dwAvailPageFile ) / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"TotalVirtualMemorySize",
            _i64tot((stMemory.dwTotalPhys + stMemory.dwTotalPageFile ) / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"SizeStoredInPagingFiles",
            _i64tot(stMemory.dwTotalPageFile  / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"FreeSpaceInPagingFiles",
            _i64tot(stMemory.dwAvailPageFile / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"MaxProcessMemorySize",
            _i64tot(stMemory.dwTotalVirtual / 1024, szBuffer, 10));

        pInstance->SetCharSplat(L"TotalVisibleMemorySize",
            _i64tot(stMemory.dwTotalPhys / 1024, szBuffer, 10));
  }


   if (GetWindowsDirectory(szTemp, sizeof(szTemp) / sizeof(TCHAR)))
       pInstance->SetCharSplat(L"WindowsDirectory", szTemp);


    // Now get OS-specific stuff
    //==========================

#ifdef NTONLY
            GetNTInfo(pInstance) ;
#endif
#ifdef WIN9XONLY
            GetWin95Info(pInstance) ;
#endif
}

/*

  This function nor the population of the property TotalSwapSpaceSize
  is needed as Swap files are not distinquished from page files as defined
  by in Cim_OperatingSystem::TotalSwapSpaceSize. Pagefile information may be
  obtained either within this class or from Win32_Pagefile.

__int64 CWin32OS::GetTotalSwapFileSize()
{
    __int64 gazotta = 0;

#ifdef NTONLY
        CRegistry reg;
        CHString sRegValue;

        if(reg.OpenLocalMachineKeyAndReadValue(PAGEFILE_REGISTRY_KEY,
                                               PAGING_FILES,
                                               sRegValue) == ERROR_SUCCESS)
        {
            // pattern is name <space> min size [optional<max size>] 0A repeat...
            // I'll use an ASCII smiley face to replace the delimiter...
            int start = 0, index;
            const TCHAR smiley = '\x02';
            const TCHAR delimiter = '\x0A';
            CHString buf;

            while (-1 != (index = sRegValue.Find(delimiter)))
            {
                // copy to buffer to make life easier
                buf = sRegValue.Mid(start, index - start);
                // mash delimiter so we don't find it again.
                sRegValue.SetAt(index, smiley);
                // save start for next time around.
                start = index +1;

                index = buf.Find(' ');

                if (index != -1)
                    buf.SetAt(index, smiley);

                int end;
                end = buf.Find(' ');

                // if no more spaces, there isn't a max size written down
                // and so max size is 50 more than min
                if (end == -1)
                {
                    CHString littleBuf = buf.Mid(index +1);
                    gazotta += _ttoi(littleBuf) +50;
                }
                else
                {
                    CHString littleBuf = buf.Mid(end);
                    gazotta +=  _ttoi(littleBuf);
                }
            }
        }
#endif
#ifdef WIN9XONLY
        MEMORYSTATUS memoryStatus;
        memoryStatus.dwLength = sizeof(MEMORYSTATUS) ;
        GlobalMemoryStatus(&memoryStatus) ;

        gazotta = memoryStatus.dwTotalPageFile >> 20;
#endif

    return gazotta;
}
*/

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetNTInfo
 *
 *  DESCRIPTION : Assigns property values for NT
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : OSName is key, we must assign something to it
 *
 *****************************************************************************/

#ifdef NTONLY
void CWin32OS::GetNTInfo(CInstance *pInstance)
{
   CHString sTemp ;
   CRegistry RegInfo ;
   FILETIME   t_ft;
   DWORD dwTemp, dwLicenses;

   pInstance->SetWBEMINT16(_T("OSType"), 18);

    // Get the product id and stuff it into serial number.

    if(RegInfo.Open(HKEY_LOCAL_MACHINE,
                    _T("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                    KEY_READ) == ERROR_SUCCESS) {

        if( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("ProductId"), sTemp) )
        {
            pInstance->SetCHString(_T("SerialNumber"), sTemp );
        }

        if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("RegisteredOwner"), sTemp) )
        {
           pInstance->SetCHString(_T("RegisteredUser"), sTemp);
        }

        if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("RegisteredOrganization"), sTemp) )
        {
           pInstance->SetCHString(_T("Organization"), sTemp);
        }

        // Raid 18143
        if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("Plus! ProductId"), sTemp) )
        {
           pInstance->SetCHString(_T("PlusProductID"), sTemp);
           if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("Plus! VersionNumber"), sTemp) )
           {
              pInstance->SetCHString(_T("PlusVersionNumber"), sTemp);
           }

        }

        // Build Type from Current Type
        if( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("CurrentType"), sTemp) )
        {
            pInstance->SetCHString(_T("BuildType"), sTemp );
        }

        // Get the Installation Date as a DWORD.  Convert to time_t
        DWORD   dwInstallDate = 0;
        if( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("InstallDate"), dwInstallDate) )
        {
            time_t  tTime = (time_t) dwInstallDate;
            WBEMTime wTime(tTime);

            pInstance->SetDateTime(_T("InstallDate"), wTime);
        }

        RegInfo.Close() ;
    }

    if(RegInfo.Open(HKEY_LOCAL_MACHINE,
                    _T("SYSTEM\\Setup"),
                    KEY_READ) == ERROR_SUCCESS) {
        if( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("SystemPartition"), sTemp) )
        {
            pInstance->SetCharSplat(_T("BootDevice"), sTemp);
        }
    }

	{
		//make sure the buffer goes out of scope soon
		TCHAR szPath[_MAX_PATH];

		if (GetWindowsDirectory(szPath, _MAX_PATH))
		{
			TCHAR ntDosVolume[3] = L"A:";
			ntDosVolume[0] = szPath[0];
			LPTSTR pPath = sTemp.GetBuffer(_MAX_PATH);

			if (QueryDosDevice( ntDosVolume, pPath, _MAX_PATH ) > 0)
			{
				pInstance->SetCharSplat(_T("SystemDevice"), sTemp );
			}
		}
	}

    // Get the last boot time
    CNTLastBootTime ntLastBootTime;

    if ( ntLastBootTime.GetLastBootTime( t_ft ) )
    {
        pInstance->SetDateTime(_T("LastBootupTime"), WBEMTime(t_ft) );
    }

//    if(GetPrivateProfileString
//            ("Paths",
//    "SystemPartitionDirectory",
//        "",
//        szTemp,
//        sizeof(szTemp)/sizeof(TCHAR),
//        sTemp)
//        != 0) {
//
//        pInstance->SetCharSplat("BootDirectory", szTemp );
//    }

   if(RegInfo.Open(HKEY_LOCAL_MACHINE,
              _T("SYSTEM\\CurrentControlSet\\Control\\PriorityControl"),
              KEY_READ) == ERROR_SUCCESS) {

      if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(_T("Win32PrioritySeparation"), sTemp) )
      {
         dwTemp = _ttoi(sTemp);

         pInstance->SetByte(_T("ForeGroundApplicationBoost"), dwTemp & PROCESS_PRIORITY_SEPARATION_MASK);
         pInstance->SetByte(_T("QuantumType"), (dwTemp & PROCESS_QUANTUM_VARIABLE_MASK) >> 2);
         pInstance->SetByte(_T("QuantumLength"), (dwTemp & PROCESS_QUANTUM_LONG_MASK) >> 4);

      }
   }

   CNetAPI32 NetApi;
   PWKSTA_INFO_102 pw = NULL;
   PSERVER_INFO_101 ps = NULL;

   if( NetApi.Init() == ERROR_SUCCESS ) {
      if (NetApi.NetWkstaGetInfo(NULL, 102, (LPBYTE *)&pw) == NERR_Success)
      {
         try
         {
            pInstance->SetDWORD(_T("NumberOfUsers"), pw->wki102_logged_on_users);
         }
         catch ( ... )
         {
             NetApi.NetApiBufferFree(pw);
             throw;
         }

         NetApi.NetApiBufferFree(pw);

      }
      if (NetApi.NetServerGetInfo(NULL, 101, (LPBYTE *)&ps) == NERR_Success)
      {
        try
        {
             if (ps->sv101_comment != NULL)
             {
                pInstance->SetWCHARSplat(IDS_Description, (WCHAR *)ps->sv101_comment);
             }
         }
        catch ( ... )
        {
             NetApi.NetApiBufferFree(ps);
             throw;
        }
        NetApi.NetApiBufferFree(ps);

      }
   }

    if (!IsWinNT5()) {
        if (RegInfo.Open(HKEY_USERS,
            _T(".DEFAULT\\Control Panel\\International"), KEY_QUERY_VALUE) == ERROR_SUCCESS) {
            CHString sLang;
            LANGID dwOSLanguage = 0;
            if (RegInfo.GetCurrentKeyValue(_T("Locale"), sLang) == ERROR_SUCCESS) {
                _stscanf(sLang, _T("%x"), &dwOSLanguage);
                pInstance->SetDWORD(_T("OSLanguage"), dwOSLanguage);
            }
        }
    } else {
        LANGID dwOSLanguage = 0;
        CKernel32Api* pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
        if(pKernel32 != NULL)
        {
            if(pKernel32->GetSystemDefaultUILanguage(&dwOSLanguage))
            {   // The function existed. Its result is in dwOSLanguage.
                pInstance->SetDWORD(_T("OSLanguage"), dwOSLanguage);
            }
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
            pKernel32 = NULL;
        }
    }

    // raid 354436
    if(IsWinNT5()) 
    {
        if(RegInfo.Open(
            HKEY_LOCAL_MACHINE,
            _T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
            KEY_READ) == ERROR_SUCCESS) 
        {
            if(ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(IDS_LargeSystemCache, sTemp))
            {
                dwTemp = _ttoi(sTemp);
                pInstance->SetDWORD(IDS_LargeSystemCache, dwTemp);
            }
        }
    }

   // Property moved to win32_computersystem.
//  // no power management in any NTs <= 4
//  if (GetPlatformMajorVersion() <= 4)
//  {
//      pInstance->Setbool(IDS_PowerManagementSupported, false);
//      pInstance->Setbool(IDS_PowerManagementEnabled, false);
//  }
//  else
//  {
//      // dunno yet.
//      LogErrorMessage("APM not returned for NT 5+");
//  }

   if (GetLicensedUsers(&dwLicenses)) {
      pInstance->SetDWORD(_T("NumberOfLicensedUsers"), dwLicenses);
   }

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetWin95Info
 *
 *  DESCRIPTION : Assigns property values for Windows 95
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : OSName is key, we must assign something to it.  Also,
 *                these properties are retrieved via DMReg --
 *                the Win95 Desktop Management option must be installed
 *                on the target machine for these properties to be retrieved.
 *
 *****************************************************************************/

#ifdef WIN9XONLY
void CWin32OS::GetWin95Info(CInstance *pInstance)
{
    CRegistry RegInfo ;
    CHString sTemp ;
    TCHAR szTemp[_MAX_PATH] ;

    if (IsWin98())
    {
        pInstance->SetWBEMINT16(L"OSType", 17);
    }
    else
    {
        pInstance->SetWBEMINT16(L"OSType", 16);
    }

    pInstance->SetByte(L"ForeGroundApplicationBoost", 0 );
    pInstance->SetByte(L"QuantumType", 0 );
    pInstance->SetByte(L"QuantumLength", 0 );

   // Windows 95 Installation Date is in FirstInstallDateTime value in the CurrentVersion
   // key.  It is a DWORD.  HIWORD contains the date, LOWORD contains the time.

   if(RegInfo.Open(HKEY_LOCAL_MACHINE,
      L"Software\\Microsoft\\Windows\\CurrentVersion",
      KEY_READ) == ERROR_SUCCESS)
   {
      DWORD dwFirstInstallDateTime = 0;
      DWORD dwSize = 4;

      if( ERROR_SUCCESS == RegInfo.GetCurrentBinaryKeyValue(
        L"FirstInstallDateTime", (LPBYTE) &dwFirstInstallDateTime, &dwSize ) )
      {
         FILETIME   ft;
         SYSTEMTIME st;

         // To convert use DosDateTimeToFileTime, then FileTimeToSystemTime
         // Note how this does as far as the time goes.  Although the KB
         // entry that contained this info said the time would be UTC, it
         // appeared to be more a reflection as to the actual time that
         // was on the computer when the system ran.

         if (   DosDateTimeToFileTime( HIWORD(dwFirstInstallDateTime), LOWORD(dwFirstInstallDateTime), &ft )
            &&  FileTimeToSystemTime( &ft, &st ) )
         {
            pInstance->SetDateTime(L"InstallDate", st );
         }

      }


      if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(L"RegisteredOwner", sTemp) )
      {
         pInstance->SetCHString(L"RegisteredUser", sTemp);
      }

      if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(L"RegisteredOrganization",
        sTemp) )
      {
         pInstance->SetCHString(L"Organization", sTemp);
      }

      if(!RegInfo.GetCurrentKeyValue(L"ProductId", sTemp)) {

         pInstance->SetCHString(L"SerialNumber", sTemp );
      }

      // Raid 18143
      if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(L"Plus! ProductId", sTemp))
      {
         pInstance->SetCHString(L"PlusProductID", sTemp);
         if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(L"Plus! VersionNumber", sTemp) )
         {
            pInstance->SetCHString(L"PlusVersionNumber", sTemp);
         }
      }
      else
      // wasn't there? try looking for PLUS! ver 98
      {
        if(RegInfo.Open(HKEY_LOCAL_MACHINE,
          L"Software\\Microsoft\\Plus!98",
          KEY_READ) == ERROR_SUCCESS)
        {
            DWORD ver;
            if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(L"ProductId", sTemp) )
                pInstance->SetCHString(L"PlusProductID", sTemp);
            if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(L"SetupVer", ver) )
            {
                CHString verster;
                verster.Format(L"%u", ver);
                pInstance->SetCHString(L"PlusVersionNumber", verster);
            }
        }
      }

      RegInfo.Close() ;

   }

   // Per RAID 6576, we're going to report the boot drive
   // according to the Win95 environment variable WinBootDir
   // a-jmoon
   //=======================================================

   if(GetEnvironmentVariable(_T("WinBootDir"), szTemp, sizeof(szTemp) / sizeof(TCHAR))) {

//      pInstance->SetCharSplat("BootDirectory", szTemp );
      if(GetWin95BootDevice((char)toupper(szTemp[0]), sTemp)) {

         pInstance->SetCHString(L"BootDevice", sTemp );
      }
   }

    if (RegInfo.Open(HKEY_USERS,
        L".Default\\Control Panel\\desktop\\ResourceLocale", KEY_QUERY_VALUE) == ERROR_SUCCESS) {
        CHString sLang;
        LANGID dwOSLanguage = 0;

        if (RegInfo.GetCurrentKeyValue(L"", sLang) == ERROR_SUCCESS) {
            swscanf(sLang, L"%x", &dwOSLanguage);
            pInstance->SetDWORD(L"OSLanguage", dwOSLanguage);
        }
    }

   // Property moved to computersystem
//   // power management
//   if(RegInfo.Open(HKEY_LOCAL_MACHINE,
//      "Enum\\Root\\*PNP0C05\\0000",
//      KEY_READ) == ERROR_SUCCESS)
//   {
//      // if we got this key, then we got power management
//      pInstance->Setbool(IDS_PowerManagementSupported, true);
//
//      // need config manager for this one
//      // Setbool(IDS_PowerManagementEnabled,...);
//
//      RegInfo.Close() ;
//   }
//   else
//      pInstance->Setbool(IDS_PowerManagementSupported, false);

   // need config manager for this one
// Setbool(IDS_PowerManagementEnabled, );

    CNetAPI32        NetApi;
    server_info_1    *ps;
    unsigned short   dwSize;
    BOOL             bFound = FALSE;

    if( NetApi.Init() == ERROR_SUCCESS )
    {
        ps = (server_info_1 *) new BYTE [sizeof(server_info_1) + MAXCOMMENTSZ + 1 ] ;
        if (ps != NULL)
        {
            try
            {
                if (NetApi.NetServerGetInfo95(NULL, 1, (LPSTR)ps, sizeof(server_info_1)+MAXCOMMENTSZ + 1, &dwSize) == NERR_Success)
                {
                    if (ps->sv1_comment != NULL)
                    {
                        pInstance->SetCharSplat(IDS_Description,
                            (LPTSTR) (LPCTSTR) ps->sv1_comment);
                        bFound = TRUE;
                    }
                }
            }
            catch ( ... )
            {
                delete [] ( PBYTE ) ps;
                throw;
            }
            delete [] ( PBYTE ) ps ;
        }
    }

    // The call above fails if file sharing hasn't been enabled.
    // If that happens, just get it from the registry.
    if (!bFound)
    {
        CRegistry   reg;
        CHString    strDesc;

        if (reg.OpenLocalMachineKeyAndReadValue(
            L"System\\CurrentControlSet\\Services\\VxD\\VNETSUP",
            L"Comment",
            strDesc) == ERROR_SUCCESS)
            pInstance->SetCharSplat(IDS_Description, strDesc);
    }
}
#endif

#ifdef WIN9XONLY
BOOL CWin32OS::GetWin95BootDevice( TCHAR cBootDrive, CHString& strBootDevice )
{

    DRIVE_MAP_INFO dmiDriveInfo =   {0};

    BOOL                fResult         =   FALSE,
                        fReturn         =   FALSE;

   fResult = GetDriveMapInfo(&dmiDriveInfo, cBootDrive - _T('A') + 1); // A Drive is One

   // Make sure DeviceIoControl and the called function succeeds.
   if ( fResult )
   {
       if ( dmiDriveInfo.btInt13Unit    >=  0x80
           &&   dmiDriveInfo.btInt13Unit    <   0xFF )
       {
           int  nHardDiskId = dmiDriveInfo.btInt13Unit - 0x80;
           strBootDevice.Format(L"\\\\Device\\Harddisk%d", nHardDiskId );
           fReturn = TRUE;
       }
       int x = 0;
   }

    return fReturn;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::PutInstance
 *
 *  DESCRIPTION : Write changed instance
 *
 *  INPUTS      : pInstance to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32OS::PutInstance(const CInstance &pInstance, long lFlags /*= 0L*/)
{
    // Tell the user we can't create a new os (much as we might like to)
    if (lFlags & WBEM_FLAG_CREATE_ONLY)
        return WBEM_E_UNSUPPORTED_PARAMETER;

    CHString        sTemp,
                    newDesc;
    volatile DWORD  dwQuantum = 0;
    volatile DWORD  dwCurrent;
    HRESULT         hRet = WBEM_S_NO_ERROR;
    CRegistry       RegInfo;
    BOOL            bWrite = FALSE,
                    bNewComment = FALSE;
    BYTE            btByte;
    CSystemName     cSN;

    // store up here for possible rollback later.
    CNetAPI32       NetApi;
    LPWSTR          oldDesc = NULL;
    PSERVER_INFO_101
                    ps = NULL;

    if (!cSN.ObjectIsUs(&pInstance))
    {
        if (lFlags & WBEM_FLAG_UPDATE_ONLY)
            hRet = WBEM_E_NOT_FOUND;
        else
            hRet = WBEM_E_UNSUPPORTED_PARAMETER;
    }
    else
    {
		//BIG NOTE: even though sv101_comment is declared tchar, its always wchar.

        // Check to see which properties they set.
#ifdef NTONLY
        if (!pInstance.IsNull(IDS_Description))
        {
            pInstance.GetCHString(IDS_Description, newDesc);

            // if inited...
            if (NetApi.Init() == ERROR_SUCCESS &&
                NetApi.NetServerGetInfo(NULL, 101, (LPBYTE *) &ps) ==
                NERR_Success)
            {
                // if the comment changed....
                if (wcscmp(newDesc, (WCHAR *) ps->sv101_comment) != 0)
                {
                    // save the ptr for possible rollback. Remember is really wchar.
                    oldDesc = (LPWSTR)ps->sv101_comment;

                    // use the new comment.
                    ps->sv101_comment = (LPWSTR) (LPCWSTR) newDesc;

                    // save it.
                    NET_API_STATUS stat = NetApi.NetServerSetInfo(NULL, 101, (LPBYTE)ps, NULL);
                    if (stat == NERR_Success)
                    {
                        bNewComment = true;
                        hRet = WBEM_S_NO_ERROR;
                    }
                    else if (stat == ERROR_ACCESS_DENIED)
                        hRet = WBEM_E_ACCESS_DENIED;
                    else
                        hRet = WBEM_E_FAILED;

                } //endif newDesc

            } //endif NetServerGetInfo()
        } //endif !pInstance.IsNull(IDS_Description)

        // if anything went wrong, bail out now.
        if (hRet != WBEM_S_NO_ERROR)
        {
            // clean up for early return.
            ps->sv101_comment = (LPWSTR) (LPCTSTR) oldDesc;
            NetApi.NetApiBufferFree(ps);
            return hRet;
        }
#endif


        //-------------------------------------------
        // Assume the registry stuff is going to fail
        hRet = WBEM_E_FAILED;
        LONG regErr;
        regErr = RegInfo.Open(HKEY_LOCAL_MACHINE,
           L"SYSTEM\\CurrentControlSet\\Control\\PriorityControl",
           KEY_READ|KEY_WRITE);
        if (regErr == ERROR_SUCCESS)
        {
            if (ERROR_SUCCESS == RegInfo.GetCurrentKeyValue(
                L"Win32PrioritySeparation", sTemp))
            {

                // Ok, so now let's assume things are going to work
                hRet = WBEM_S_NO_ERROR;
                dwCurrent = _wtoi(sTemp);

                // Check to see which properties they set
                if (!pInstance.IsNull(L"ForegroundApplicationBoost"))
                {
                    // Check for value in range
                    pInstance.GetByte(L"ForegroundApplicationBoost", btByte);
                    if (((btByte & (~PROCESS_PRIORITY_SEPARATION_MASK)) != 0) ||
                        (btByte == 3))
                        hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                    else
                        // Build up our dword to write
                        dwQuantum |= btByte;

                    // Clear out the bits we are going to reset
                    dwCurrent &= (~PROCESS_PRIORITY_SEPARATION_MASK);
                    bWrite = true;
                }
            }

            // Check to see which properties they set
            if (!pInstance.IsNull(L"QuantumType"))
            {
                // Check for value in range
                pInstance.GetByte(L"QuantumType", btByte);
                btByte = btByte << 2;
                if (((btByte & (~PROCESS_QUANTUM_VARIABLE_MASK)) != 0) ||
                    (btByte == 0xc))
                    hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                else
                    // Build up our dword to write
                    dwQuantum |= btByte;

                // Clear out the bits we are going to reset
                dwCurrent &= (~PROCESS_QUANTUM_VARIABLE_MASK);
                bWrite = true;
            }

            // Check to see which properties they set
            if (!pInstance.IsNull(L"QuantumLength"))
            {
                pInstance.GetByte(L"QuantumLength", btByte);

                // Check for value in range
                btByte = btByte << 4;
                if (((btByte & (~PROCESS_QUANTUM_LONG_MASK)) != 0) ||
                    (btByte == 0x30))
                    hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                else
                {
                    // Build up our dword to write
                    dwQuantum |= btByte;

                    // Clear out the bits we are going to reset
                    dwCurrent &= (~PROCESS_QUANTUM_LONG_MASK);
                    bWrite = TRUE;
                }
            }

            // If anything to write and none of the above failed
            if (bWrite && hRet == WBEM_S_NO_ERROR)
            {
                dwCurrent |= dwQuantum;

                // Fixes what is an optimization bug on Alphas(??)  Something
                // about accessing the variable.  Lie back and think of the
                // Z-80...

                CHString strDummy;

                strDummy.Format(L"%d",dwCurrent);

                regErr = RegSetValueEx(RegInfo.GethKey(),
                        _T("Win32PrioritySeparation"),
                        0,
                        REG_DWORD,
                        (const unsigned char *)&dwCurrent,
                        sizeof(DWORD));
                if (regErr == ERROR_ACCESS_DENIED)
                    hRet = WBEM_E_ACCESS_DENIED;
                else if (regErr != ERROR_SUCCESS)
                  hRet = WBEM_E_FAILED;
                else
                    hRet = WBEM_S_NO_ERROR;
             }
        } // endif (regErr == ERROR_SUCCESS
        else if (regErr == ERROR_ACCESS_DENIED)
            hRet = WBEM_E_ACCESS_DENIED;
        else
            hRet = WBEM_E_FAILED;
    }

#ifdef NTONLY
    // if registry went wrong, rollback the NetServerSetInfo(),
    // if necesssary...
    if (hRet != WBEM_S_NO_ERROR && bNewComment)
    {
        // if inited...
        if (NetApi.Init() == ERROR_SUCCESS && ps)
        {
            // put the old comment back.
            ps->sv101_comment = (LPWSTR) (LPCTSTR) oldDesc;

            // restore the previous comment. Keep the previous error code.
            // This is just a rollback. If its fails, oh well.
            NetApi.NetServerSetInfo(NULL, 101, (LPBYTE) ps, NULL);
        } //endif NetApi.Init()
    }

    // put the old ptr back so it can be freed.
    if (ps)
    {
        ps->sv101_comment = (LPTSTR)oldDesc;
        NetApi.NetApiBufferFree(ps);
    }

    // raid 354436
    if(hRet == WBEM_S_NO_ERROR)
    {
        if(!pInstance.IsNull(IDS_LargeSystemCache))
        {
            DWORD dwCacheSize = 0;
            pInstance.GetDWORD(IDS_LargeSystemCache, dwCacheSize);

            CRegistry reg;

            DWORD dwRet = reg.CreateOpen(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management");
            
            if(ERROR_SUCCESS == dwRet)
            {
                if((dwRet = reg.SetCurrentKeyValue(IDS_LargeSystemCache, dwCacheSize)) != ERROR_SUCCESS)
                {
                    hRet = WinErrorToWBEMhResult(dwRet);
                }
                
                reg.Close();
            }
            else
            {
                hRet = WinErrorToWBEMhResult(dwRet);
            }
        }
    }

#endif

    return hRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32OS::ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/)
{
    CSystemName cSN;
    DWORD       dwFlags,
                dwReserved;
    bool        bDoit = true;
    DWORD       dwMode = -1, dwError;
    bool        fLogoff = false;

        // Is this our instance?
    if (!cSN.ObjectIsUs(&pInstance))
    {
        return WBEM_E_NOT_FOUND;
    }

    if (_wcsicmp(bstrMethodName, L"SetDateTime") == 0)
    {    
	    if( !pInParams->IsNull( L"LocalDateTime") )
        {
		    SYSTEMTIME	t_SysTime ;
            WBEMTime	t_wTime ;

		    if (EnablePrivilegeOnCurrentThread( SE_SYSTEMTIME_NAME ))
            {
		        pInParams->GetDateTime( L"LocalDateTime", t_wTime ) ;

                if (t_wTime.IsOk())
                {
		            t_wTime.GetSYSTEMTIME( &t_SysTime ) ;

		            if( SetSystemTime( &t_SysTime ) )
		            {
                        pOutParams->SetDWORD ( L"ReturnValue", 0 ) ;
                        return WBEM_S_NO_ERROR;
                    }
                    else
                    {
			            return WBEM_E_FAILED ;
		            }
                }
                else
                {
                    return WBEM_E_INVALID_PARAMETER;
                }
            }
            else
            {
                SetSinglePrivilegeStatusObject(pInstance.GetMethodContext(), SE_SYSTEMTIME_NAME);
                return WBEM_E_ACCESS_DENIED;
            }
	    }
        else
        {
            return WBEM_E_INVALID_PARAMETER;
        }
    }



    // Do we recognize the method?
    if (_wcsicmp(bstrMethodName, L"Win32ShutDown") == 0)
    {
        bool t_Exists; VARTYPE t_Type ;
        // See what they asked for
        if ( pInParams->GetStatus ( L"Flags", t_Exists , t_Type ) )
        {
            if ( t_Exists && ( t_Type == VT_I4 ) )
            {
                if ( pInParams->GetDWORD ( L"Flags" , dwFlags ) )
                {
                }
                else
                {
                    pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER ) ;
                    return S_OK ;
                }
                if(dwFlags == 0)
                {
                    fLogoff = true;
                }
            }
            else
            {
                pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER ) ;
                return S_OK ;
            }
        }
        else
        {
            pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER ) ;
            return WBEM_E_PROVIDER_FAILURE ;
        }

        DWORD t_dwForceIfHungOption = 0 ;
#ifdef NTONLY
        if ( IsWinNT5() )
        {
            t_dwForceIfHungOption = EWX_FORCEIFHUNG ;
        }
#endif
        if ( dwFlags == EWX_LOGOFF || dwFlags == ( EWX_LOGOFF | EWX_FORCE ) || dwFlags == ( EWX_LOGOFF | t_dwForceIfHungOption ) ||
             dwFlags == EWX_SHUTDOWN || dwFlags == ( EWX_SHUTDOWN | EWX_FORCE ) || dwFlags == ( EWX_SHUTDOWN | t_dwForceIfHungOption ) ||
             dwFlags == EWX_REBOOT || dwFlags == ( EWX_REBOOT | EWX_FORCE ) || dwFlags == ( EWX_REBOOT | t_dwForceIfHungOption ) ||
             dwFlags == EWX_POWEROFF || dwFlags == ( EWX_POWEROFF | EWX_FORCE ) || dwFlags == ( EWX_POWEROFF | t_dwForceIfHungOption )
            )
        {
			if ( dwFlags == EWX_LOGOFF || dwFlags == ( EWX_LOGOFF | EWX_FORCE ) || dwFlags == ( EWX_LOGOFF | t_dwForceIfHungOption ) )
			{
				fLogoff = true;
			}
        }
        else
        {
            pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER ) ;
            return S_OK ;
        }

        pInParams->GetDWORD(L"Reserved", dwReserved);
        dwMode = 0;
    }
    else if (_wcsicmp(bstrMethodName, L"ShutDown") == 0)
    {
        dwReserved = 0;
        dwMode = 1;
#ifdef WIN9XONLY
        dwFlags = EWX_SHUTDOWN | EWX_FORCE;
#endif

#ifdef NTONLY
        if ( IsWinNT5() )
        {
            dwFlags = EWX_SHUTDOWN | EWX_FORCEIFHUNG ;
        }
        else
        {
            dwFlags = EWX_SHUTDOWN | EWX_FORCE;
        }
#endif
    }
    else if (_wcsicmp(bstrMethodName, L"Reboot") == 0)
    {
        dwReserved = 0;
        dwMode = 2;
#ifdef WIN9XONLY
        dwFlags = EWX_REBOOT | EWX_FORCE;
#endif

#ifdef NTONLY
        if ( IsWinNT5() )
        {
            dwFlags = EWX_REBOOT | EWX_FORCEIFHUNG ;
        }
        else
        {
            dwFlags = EWX_REBOOT | EWX_FORCE;
        }
#endif
    }
	else if (_wcsicmp(bstrMethodName, L"Win32AbortShutdown") == 0)
	{
#if NTONLY >= 5
		dwMode = 3;
#else
		return WBEM_E_NOT_SUPPORTED;
#endif
	}
    else
    {
        return WBEM_E_INVALID_METHOD;
    }


/*
 * If the user has done a remote login, check if he has remote-shutdown privilege
 * if the user has logged locally, check if he has shutdown privilege. API Calls work only on NT5.
 */
#ifdef NTONLY
    if(!fLogoff) // only need to check for these privs if we were requesting something other than logoff
    {
        DWORD t_dwLastError ;
        bDoit = CanShutdownSystem ( pInstance, t_dwLastError );
        if ( !bDoit )
        {
            return WBEM_E_PRIVILEGE_NOT_HELD ;
        }
    }
#endif


    // Clear error
    SetLastError(0);

#if NTONLY >= 5
	DWORD dwTimeout = 0;
	bool bForceShutDown = false;
	bool bRebootAfterShutdown = false;
	BOOL bInitiateShutDown = FALSE;

	CHString t_ComputerName ( GetLocalComputerName() );
	if ( bDoit )
	{
		if ( dwMode == 3 )
		{
			// AbortShutDown
			BOOL bSuccess = AbortSystemShutdown( t_ComputerName.GetBuffer ( 0 ) );
		}
		else if ( dwMode == 0  && !fLogoff )
		{
			// InitiateShutDown
			bool t_Exists; VARTYPE t_Type ;
			// See what they asked for
			if ( pInParams->GetStatus ( L"Timeout", t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 ) )
				{
					pInParams->GetDWORD ( L"Timeout" , dwTimeout );
				}
				else
				if ( t_Exists && ( t_Type != VT_I4 ) )
				{
					pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER );
					return WBEM_E_PROVIDER_FAILURE ;
				}
			}

			if ( pInParams->GetStatus ( L"ForceShutdown", t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_BOOL ) )
				{
					pInParams->Getbool ( L"ForceShutdown" , bForceShutDown );
				}
				else
				if ( t_Exists && ( t_Type != VT_BOOL ) )
				{
					pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER );
					return WBEM_E_PROVIDER_FAILURE ;
				}
			}

			if ( pInParams->GetStatus ( L"RebootAfterShutdown", t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_BOOL ) )
				{
					pInParams->Getbool ( L"RebootAfterShutdown" , bRebootAfterShutdown );
				}
				else
				if ( t_Exists && ( t_Type != VT_BOOL ) )
				{
					pOutParams->SetDWORD ( L"ReturnValue" , ERROR_INVALID_PARAMETER );
					return WBEM_E_PROVIDER_FAILURE ;
				}
			}

			// For Win32ShutDown(), set the value of bRebootAfterShutdown based on the flags parameter
			if(dwFlags & EWX_REBOOT)
				bRebootAfterShutdown = true;

			if( dwFlags & EWX_FORCE)
				bForceShutDown = true;
            
            // In case we shut down successfully, need to set the
            // return value here while we can.  If shutdown fails,
            // this value will get overwritten below.
            pOutParams->SetDWORD(L"ReturnValue", 0);

            // If they want a poweroff, which InitiateSystemShutdown
            // doesn't support, need to call another api.  Can't call
            // ExitWindowsEx because our process (wmiprvse.exe) doesn't
            // hold privileges required to do the shutdown, and the
            // access check is made against the process, not the thread.
            // IniateSystemShutdown and WTSShutdownSystem (the latter
            // runs via an rpc service) both do the access checks against
            // the impersonated thread.
            if(dwFlags & EWX_POWEROFF)
            {
                ::WTSShutdownSystem(
                    WTS_CURRENT_SERVER_HANDLE, 
                    WTS_WSD_POWEROFF);
            }
            else
            {
			    bInitiateShutDown = InitiateSystemShutdown(
                    t_ComputerName.GetBuffer(0), 
                    NULL, 
                    dwTimeout, 
                    (bForceShutDown)? TRUE:FALSE, 
                    (bRebootAfterShutdown)? TRUE:FALSE);
            }
		}
	}
#endif
    // This might get overwritten below
    dwError = GetLastError();
	// Get the error (if any)
	pOutParams->SetDWORD(L"ReturnValue", dwError);

    // If we're still set to go, make the call
    if (bDoit)
    {
#ifdef NTONLY
		if ( dwMode != 3 )
		{
			// If we are not doing a logoff of the current user, just make
			// the ExitWindows call

			if ( !fLogoff )
			{
#if NTONLY >= 5
				if ( ! bInitiateShutDown )
				{
                    if(dwFlags & EWX_REBOOT)
                    {
				        bRebootAfterShutdown = true;
                    }
			        if( dwFlags & EWX_FORCE)
				    {
                        bForceShutDown = true;
                    }
			        
                    if(dwFlags & EWX_POWEROFF)
                    {
                        ::WTSShutdownSystem(
                            WTS_CURRENT_SERVER_HANDLE, 
                            WTS_WSD_POWEROFF);
                    }
                    else
                    {
                        bInitiateShutDown = ::InitiateSystemShutdown( 
                            t_ComputerName.GetBuffer(0), 
                            NULL, 
                            dwTimeout, 
                            (bForceShutDown)? TRUE:FALSE, 
                            (bRebootAfterShutdown)? TRUE:FALSE );
                    }

					dwError = GetLastError();
				}
#else
				if(dwFlags & EWX_REBOOT)
                {
				    bRebootAfterShutdown = true;
                }
			    if( dwFlags & EWX_FORCE)
				{
                    bForceShutDown = true;
                }
			    
                bInitiateShutDown = InitiateSystemShutdown( 
                    t_ComputerName.GetBuffer(0), 
                    NULL, 
                    dwTimeout, 
                    (bForceShutDown)? TRUE:FALSE, 
                    (bRebootAfterShutdown)? TRUE:FALSE );

				dwError = GetLastError();
#endif
			}
			else
			{
				// Otherwise, they requested a logoff.
				if(!::WTSLogoffSession(
                    WTS_CURRENT_SERVER_HANDLE,       // specifies the terminal server on which this process is running
                    WTS_CURRENT_SESSION,             // specifies that the current session is the one to logoff
                    FALSE))                          // return immediately, don't wait
                {
                    dwError = GetLastError();
                }
			}
		
			// Get the error (if any)
			pOutParams->SetDWORD(_T("ReturnValue"), dwError);
		}
#endif

#ifdef WIN9XONLY
        pOutParams->SetDWORD(L"ReturnValue", ShutdownThread(dwFlags));
#endif
    }
    else
    {
        return WBEM_E_PRIVILEGE_NOT_HELD ;
    }

    // The call to *us* suceeded, so WBEM_S_NO_ERROR is correct
    return WBEM_S_NO_ERROR;
}


#ifdef WIN9XONLY
BOOL CALLBACK KillWindowsOn95(
       HWND hwnd,
       DWORD lParam
       )
{
    DWORD      pid = 0;
    LRESULT    lResult = 0;
    SmartCloseHandle   hProcess;
    DWORD      dwResult;

    // don't want to shut ourselves down...
    DWORD us = GetCurrentProcessId();

    GetWindowThreadProcessId( hwnd, &pid );
    if (pid == us)
    {
        return TRUE;
    }

    lResult = SendMessageTimeout(
        hwnd,
        WM_QUERYENDSESSION,
        0,
        ENDSESSION_LOGOFF,
        SMTO_ABORTIFHUNG,
        2000,
        &dwResult);

    if( lResult )
    {
        //
        // application will terminate nicely so let it
        //
        lResult = SendMessageTimeout(
            hwnd,
            WM_ENDSESSION,
            TRUE,
            ENDSESSION_LOGOFF,
            SMTO_ABORTIFHUNG,
            2000,
            &dwResult);
    }

    if (!lResult && (lParam & EWX_FORCE)) // we have to take more forceful measures
    {
        //
        // get the processid for this window
        //
        GetWindowThreadProcessId( hwnd, &pid );
        //
        // open the process with all access
        //
        hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
        //
        // bye-bye
        //
        TerminateProcess(hProcess, 0);

    }
    //
    // continue the enumeration
    //
    return TRUE;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::ShutdownThread
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef WIN9XONLY
HRESULT WINAPI ShutdownThread(DWORD dwFlags)
{
    DWORD dwRet;

    //
    // close all open applications
    //
    EnumWindows((WNDENUMPROC)KillWindowsOn95, dwFlags);

    TCHAR szPath[_MAX_PATH];
    STARTUPINFO si;
    PROCESS_INFORMATION ProcessInformation;
    CHString sCmd;

    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpTitle = NULL;
    si.lpDesktop = NULL;
    si.dwFlags = STARTF_USESHOWWINDOW; // Hidden window
    si.wShowWindow = SW_HIDE;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;

    GetWindowsDirectory(szPath, _MAX_PATH);  // Find where rundll32 is
    CRegistry RegInfo;
    CHString sWBEMDirectory;

    // Find where framedyn.dll is
    RegInfo.Open(HKEY_LOCAL_MACHINE, L"SOFTWARE\\MICROSOFT\\WBEM", KEY_READ);
    RegInfo.GetCurrentKeyValue(L"Installation Directory", sWBEMDirectory);

    TCHAR szExpandedDirectory[_MAX_PATH];
    ExpandEnvironmentStrings(bstr_t(sWBEMDirectory), szExpandedDirectory, _MAX_PATH);

    // Build the command;
    sCmd.Format(L"%S\\rundll32.exe %S\\framedyn.dll,_DoCmd@16 ExitWindowsEx %d %d",
        szPath, szExpandedDirectory, dwFlags, 0);

    if (CreateProcess(NULL, (LPTSTR) (LPCTSTR) TOBSTRT(sCmd), NULL, NULL, FALSE,
        0, NULL, NULL, &si, &ProcessInformation))
    {
        // Wait for the process to finish, and get its return code
        if (WaitForSingleObject(ProcessInformation.hProcess, 1000 * 60) != WAIT_TIMEOUT)
        {
            GetExitCodeProcess(ProcessInformation.hProcess, &dwRet);
            LogMessage2(L"ExitWindowsEx returns: %d", dwRet);
        }
        else
        {
            // Not sure what happened.  Shouldn't take this long
            LogMessage(L"ExitWindowsEx thread not responding");
            dwRet = WBEM_E_FAILED;
        }
    }
    else
    {
        dwRet = GetLastError();
        LogMessage3(L"Failed to launch (%s) (%d)", (LPCWSTR)sCmd, dwRet);
    }

    if (dwRet > 0)
    {
        return (dwRet | 0x80000000);
    }

    return dwRet;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetLicensedUsers
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : Number of licenses
 *
 *  RETURNS     : true/false (succeeded or failed)
 *
 *  COMMENTS    : This routine will fail if LLSMGR has never been run on this
 *                computer.
 *
 *****************************************************************************/
#ifdef NTONLY
bool CWin32OS::GetLicensedUsers(DWORD *dwRetVal)
{

   HRESULT hResult;
   bool bFound = false;
   IUnknownPtr punk;
   IDispatchPtr pLLSMGR;
   IDispatchPtr pEnterpriseServer;
   IDispatchPtr pProducts;
   IDispatchPtr pProduct;
   DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
   DISPPARAMS dispparamsItem;
   CLSID clidLLSMGR;
   *dwRetVal = 0;

   // Get the classid
   bstr_t szMember (L"Llsmgr.Application.1");
   hResult = CLSIDFromProgID(szMember, &clidLLSMGR);

   // If we found the classid
   if (SUCCEEDED(hResult))
   {
      // Try to get the object
      hResult = CoCreateInstance(clidLLSMGR, NULL, CLSCTX_SERVER, IID_IUnknown, (void FAR* FAR*)&punk);
      if (SUCCEEDED(hResult))
      {
         // Get the IDispatch interface
         hResult = punk->QueryInterface(IID_IDispatch, (void FAR* FAR*)&pLLSMGR);

         if (SUCCEEDED(hResult))
         {
             variant_t vValue;

            // Indicate that we are working with domains
            if (GetValue(pLLSMGR, L"SelectDomain", &vValue))
            {
               vValue.Clear();

               // Get the ActiveController collection
               pEnterpriseServer.Attach(GetCollection(pLLSMGR, L"ActiveController", &dispparamsNoArgs));

               if (pEnterpriseServer != NULL)
               {
                  // Get the products collection (all the products licensed on this server)
                  pProducts.Attach(GetCollection(pEnterpriseServer, L"Products", &dispparamsNoArgs));

                  if (pProducts != NULL)
                  {
                     // Find the entry for NT Server
                     vValue = (L"Windows NT Server");

                     dispparamsItem.rgvarg = &vValue;
                     dispparamsItem.cArgs = 1;
                     dispparamsItem.cNamedArgs = 0;

                     pProduct.Attach(GetCollection(pProducts, L"Item", &dispparamsItem));

                     vValue.Clear();

                     // Get the value
                     if (pProduct != NULL) {

                        // If licensing laws are being correctly followed, only one of these
                        // two contains a value.
                        if (GetValue(pProduct, L"PerSeatLimit", &vValue) && (V_VT(&vValue) == VT_I4)) {
                           bFound = true;
                           *dwRetVal += V_I4(&vValue);
                        }

                        if (GetValue(pProduct, L"PerServerLimit", &vValue) && (V_VT(&vValue) == VT_I4)) {
                           bFound = true;
                           *dwRetVal += V_I4(&vValue);
                        }
                     }
                  }
               }
            }
         }
      }
   }

   return bFound;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetCollection
 *
 *  DESCRIPTION : Given an interface pointer, property name, and parameters,
 *                returns the IDispatch pointer for the collection
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : Either a valid pointer, or NULL on error
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
IDispatch FAR* CWin32OS::GetCollection(IDispatch FAR* pIn, WCHAR *wszName, DISPPARAMS *pDispParams)
{
   HRESULT hResult;
   DISPID didID;
   IDispatch FAR* pOut = NULL;
   variant_t VarResult;

   bstr_t szMember(wszName);
   BSTR bstrMember = szMember;
   hResult = pIn->GetIDsOfNames(IID_NULL, &bstrMember, 1,
                   LOCALE_USER_DEFAULT, &didID);

   if (SUCCEEDED(hResult) && (didID != -1)) {
      hResult = pIn->Invoke(
           didID,
           IID_NULL,
           LOCALE_USER_DEFAULT,
           DISPATCH_PROPERTYGET | DISPATCH_METHOD,
           pDispParams, &VarResult, NULL, NULL);

      if (SUCCEEDED(hResult) && (V_VT(&VarResult) == VT_DISPATCH)) {

         pOut = V_DISPATCH(&VarResult);
         if (pOut != NULL)
            pOut->AddRef();
      }
   }

   return pOut;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OS::GetValue
 *
 *  DESCRIPTION : Given an interface pointer and property name, gets the value
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : The variant containing the value
 *
 *  RETURNS     : True/false indicating whether the function succeeded.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32OS::GetValue(IDispatch FAR* pIn, WCHAR *wszName, VARIANT *vValue)
{
   HRESULT hResult;
   DISPID didID;
   DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

   bstr_t szMember (wszName);
   BSTR bstrMember = szMember;

    hResult = pIn->GetIDsOfNames(IID_NULL, &bstrMember, 1,
                            LOCALE_USER_DEFAULT, &didID);
    hResult = pIn->Invoke(
                    didID,
                    IID_NULL,
                    LOCALE_USER_DEFAULT,
                    DISPATCH_PROPERTYGET | DISPATCH_METHOD,
                    &dispparamsNoArgs, vValue, NULL, NULL);

   return (SUCCEEDED(hResult));
}


PWSTR ProductSuiteNames[] ={
    L"Small Business",
    L"Enterprise",
    L"BackOffice",
    L"CommunicationServer",
    L"Terminal Server",
    L"Small Business(Restricted)",
    L"EmbeddedNT",
    L"DataCenter"};

#define CountProductSuiteNames (sizeof(ProductSuiteNames)/sizeof(PWSTR))
#define MAX_PRODUCT_SUITE_BYTES 1024

/* ==========================================================================
 Function:  void CWin32OS::GetProductSuites( CInstance * pInstance )

 Description: Extracts a mask of OS product suites

 Caveats:
 Raid:
 History:   a-peterc  11-Feb-1999     Created
 ========================================================================== */
void CWin32OS::GetProductSuites( CInstance * pInstance )
{
    DWORD dwSuiteMask = 0L;

    CHStringArray chsaProductSuites;

    HRESULT hRes = hGetProductSuites(chsaProductSuites);

    if(WBEM_S_NO_ERROR == hRes )
    {
        for( DWORD dw = 0; dw < chsaProductSuites.GetSize(); dw++ )
        {
            CHString chsProduct = chsaProductSuites.GetAt(dw);

            for (int j=0; j<CountProductSuiteNames; j++)
            {
                if (!chsProduct.CompareNoCase(ProductSuiteNames[j]))
                {
                    dwSuiteMask |= (1 << j);
                }
            }
        }
    }
/*
 * When there isn't a Suite installed the value should be NULL --RAID 50508
 */
    if ( dwSuiteMask )
    {
        pInstance->SetDWORD(L"OSProductSuite", dwSuiteMask);
    }
}

/* ==========================================================================
 Function:  HRESULT CWin32OS::hGetProductSuites(CHStringArray& rchsaProductSuites )

 Description: Extracts a string array of OS product suites

 Caveats:
 Raid:
 History:   a-peterc  11-Feb-1999     Created
 ========================================================================== */
HRESULT CWin32OS::hGetProductSuites(CHStringArray& rchsaProductSuites )
{
    CRegistry oRegistry;
    CHString chsProductKey(L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions");

    HRESULT hRes = oRegistry.Open(HKEY_LOCAL_MACHINE, chsProductKey.GetBuffer(0), KEY_READ);

    HRESULT hError = WinErrorToWBEMhResult( hRes );

    if(WBEM_S_NO_ERROR != hError )
        return hError;

    oRegistry.GetCurrentKeyValue(L"ProductSuite", rchsaProductSuites);

    return WBEM_S_NO_ERROR;
}


#ifdef NTONLY

BOOL CWin32OS::CanShutdownSystem ( const CInstance& a_Instance , DWORD &a_dwLastError )
{

    SmartCloseHandle t_hToken;
    PSID t_pNetworkSid = NULL ;
    CAdvApi32Api *t_pAdvApi32 = NULL;
    a_dwLastError = 0 ;
	BOOL t_bStatus;
    try
    {
        t_bStatus = OpenThreadToken (

            GetCurrentThread () ,
            TOKEN_QUERY ,
            FALSE ,
            & t_hToken
        ) ;

        if ( !t_bStatus )
        {
            a_dwLastError = GetLastError () ;
            return t_bStatus ;
        }

#if NTONLY >= 5

        BOOL t_bNetworkLogon ;

        SID_IDENTIFIER_AUTHORITY t_NtAuthority = SECURITY_NT_AUTHORITY ;
        t_bStatus = AllocateAndInitializeSid (

                        &t_NtAuthority,
                        1,
                        SECURITY_NETWORK_RID,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        &t_pNetworkSid
                    ) ;

        if ( t_bStatus )
        {
            t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
            if(t_pAdvApi32 == NULL)
            {
                return FALSE ;
            }
            else
            {
                BOOL t_bRetVal = FALSE ;
                if ( t_pAdvApi32->CheckTokenMembership ( t_hToken, t_pNetworkSid, &t_bNetworkLogon , &t_bRetVal ) && t_bRetVal )
                {
                }
                else
                {
                    a_dwLastError = GetLastError();
                    t_bStatus = FALSE ;
                }
            }
        }
        else
        {
            a_dwLastError = GetLastError() ;
        }

#endif

        if ( t_bStatus )
        {
            LUID t_PrivilegeRequired ;
            bstr_t t_bstrtPrivilege ;

#if NTONLY >= 5
            if ( t_bNetworkLogon )
            {
                t_bstrtPrivilege = SE_REMOTE_SHUTDOWN_NAME ;
            }
            else
            {
                t_bstrtPrivilege = SE_SHUTDOWN_NAME ;
            }
#else
            t_bstrtPrivilege = SE_SHUTDOWN_NAME ;
#endif


            {
                CreateMutexAsProcess createMutexAsProcess ( SECURITYAPIMUTEXNAME ) ;
                t_bStatus = LookupPrivilegeValue (

                                    (LPTSTR) NULL,
                                    t_bstrtPrivilege,
                                    &t_PrivilegeRequired
                                ) ;
            }

            if ( t_bStatus )
            {
                PRIVILEGE_SET t_PrivilegeSet ;
                t_PrivilegeSet.PrivilegeCount = 1;
                t_PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY ;
                t_PrivilegeSet.Privilege[0].Luid = t_PrivilegeRequired ;
                t_PrivilegeSet.Privilege[0].Attributes = 0;

                BOOL t_bPrivileged ;
                t_bStatus = PrivilegeCheck (

                                t_hToken,
                                &t_PrivilegeSet,
                                &t_bPrivileged
                            );
                if ( t_bStatus )
                {
                    if ( !t_bPrivileged )
                    {
                        SetSinglePrivilegeStatusObject ( a_Instance.GetMethodContext () , t_bstrtPrivilege ) ;
                        t_bStatus = FALSE ;
                    }
                }
                else
                {
                    a_dwLastError = GetLastError();
                }
            }
            else
            {
                a_dwLastError = GetLastError();
            }
        }
    }
    catch ( ... )
    {
#if NTONLY >= 5

        if ( t_pNetworkSid )
        {
            FreeSid ( t_pNetworkSid ) ;
            t_pNetworkSid = NULL ;
        }

        if ( t_pAdvApi32 )
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
            t_pAdvApi32 = NULL;
        }
#endif

        throw ;
    }

#if NTONLY >= 5
 
        if ( t_pNetworkSid )
        {
            FreeSid ( t_pNetworkSid ) ;
            t_pNetworkSid = NULL ;
        }

        if ( t_pAdvApi32 )
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
            t_pAdvApi32 = NULL;
        }
#endif

        return t_bStatus ;
}

#endif

//=================================================================
// GetCipherStrength - Returns the maximum cipher strength
//=================================================================
DWORD CWin32OS::GetCipherStrength()
{

	DWORD	t_dwKeySize = 0;

	CSecurityApi* t_pSecurity = (CSecurityApi*)
								CResourceManager::sm_TheResourceManager.GetResource(g_guidSecurApi, NULL);

    if( t_pSecurity != NULL )
    {
		TimeStamp					t_tsExpiry ;
		CredHandle					t_chCred ;
		SecPkgCred_CipherStrengths	t_cs ;

		if( S_OK == t_pSecurity->AcquireCredentialsHandleW(
						NULL,
						UNISP_NAME_W, // Package
						SECPKG_CRED_OUTBOUND,
						NULL,
						NULL,
						NULL,
						NULL,
						&t_chCred,	// Handle
						&t_tsExpiry ) )
		{

			try
			{
				if( S_OK == t_pSecurity->QueryCredentialsAttributesW(
								&t_chCred,
								SECPKG_ATTR_CIPHER_STRENGTHS, &t_cs ) )
				{
					t_dwKeySize = t_cs.dwMaximumCipherStrength ;
				}
			}
			catch( ... )
			{
				// Free the handle
				t_pSecurity->FreeCredentialsHandle( &t_chCred ) ;

				throw ;
			}

			// Free the handle
			t_pSecurity->FreeCredentialsHandle( &t_chCred ) ;
		}
	}

    return t_dwKeySize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\nvram.cpp ===
//================================================================

//

// nvram.cpp - implementation of NVRam functions from setupdll.dll

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// 08/05/98     sotteson     created
//
//================================================================








#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cregcls.h>

#if !defined(_X86_) || defined(_IA64_)// defined(EFI_NVRAM_ENABLED)

#include <ntsecapi.h>
#define BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA    0x00000008
#include "DllWrapperBase.h"
#include "ntdllapi.h"
#include "nvram.h"

/*****************************************************************************
 *
 *  FUNCTION    : CNVRam::CNVRam
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CNVRam::CNVRam()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CNVRam::~CNVRam
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CNVRam::~CNVRam()
{
}

CNVRam::InitReturns CNVRam::Init ()
{
	if ( !EnablePrivilegeOnCurrentThread ( SE_SYSTEM_ENVIRONMENT_NAME ) )
	{
		return PrivilegeNotHeld;
	}
	else
	{
		return Success ;
	}
}


BOOL CNVRam::GetNVRamVar(LPWSTR szVar, CHSTRINGLIST *pList)
{
	CHString str;

	pList->clear();

	if (!GetNVRamVarRaw(szVar, str))
		return FALSE;

	while(str.GetLength())
	{
		CHString strValue = str.SpanExcluding(L";");

		pList->push_back(strValue);

		// Get past ';'
		str = str.Mid(strValue.GetLength() + 1);
	}

	return TRUE;
}

BOOL CNVRam::GetNVRamVar(LPWSTR szVar, DWORD *pdwValue)
{
	CHString str;

	if (!GetNVRamVar(szVar, str))
		return FALSE;

	*pdwValue = (DWORD) _wtoi(str);

	return TRUE;
}

BOOL CNVRam::GetNVRamVar(LPWSTR szVar, CHString &strValue)
{
	CHString str;

	if (!GetNVRamVarRaw(szVar, str))
		return FALSE;

	// Just return the first value.
    strValue = str.SpanExcluding(L";");

	return TRUE;
}

BOOL CNVRam::SetNVRamVar(LPWSTR szVar, CHSTRINGLIST *pList)
{
	CHString    strAll,
                strValue;
	BOOL		bFirst = TRUE;

	for (CHSTRINGLIST_ITERATOR i = pList->begin(); i != pList->end(); ++i)
	{
		CHString &strValue = *i;

		// If we're not on the first item, add ";" to the end of strAll.
		if (!bFirst)
			strAll += ";";
		else
			bFirst = FALSE;

		strAll += strValue;
	}

    bstr_t t_bstr( strAll ) ;
	BOOL bRet = SetNVRamVarRaw( szVar, t_bstr ) ;

    return bRet;
}

BOOL CNVRam::SetNVRamVar(LPWSTR szVar, DWORD dwValue)
{
	WCHAR   szTemp[20];
    BOOL    bRet;

	wsprintfW(szTemp, L"%u", dwValue);

	bRet = SetNVRamVar(szVar, szTemp);

    return bRet;
}

BOOL CNVRam::SetNVRamVar(LPWSTR szVar, LPWSTR szValue)
{
	return SetNVRamVarRaw(szVar, szValue);
}

#define CP_MAX_ENV   (MAX_PATH * 2)

BOOL CNVRam::GetNVRamVarRaw(LPWSTR szVar, CHString &strValue)
{
	WCHAR           szOut[CP_MAX_ENV] = L"";
    UNICODE_STRING  usName;
    BOOL            bRet = FALSE;

    CNtDllApi* t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(t_pNtDll != NULL)
    {
        t_pNtDll->RtlInitUnicodeString(&usName, szVar);
        bRet = t_pNtDll->NtQuerySystemEnvironmentValue(&usName, szOut, sizeof(szOut),
                NULL) == ERROR_SUCCESS;
        strValue = szOut;
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
        t_pNtDll = NULL;
    }
	return bRet;
}

BOOL CNVRam::SetNVRamVarRaw(LPWSTR szVar, LPWSTR szValue)
{
    UNICODE_STRING  usName,
                    usValue;
    BOOL fRet = FALSE;

    CNtDllApi* t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(t_pNtDll != NULL)
    {
        t_pNtDll->RtlInitUnicodeString(&usName, szVar);
        t_pNtDll->RtlInitUnicodeString(&usValue, szValue);
        if(t_pNtDll->NtSetSystemEnvironmentValue(&usName, &usValue) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
        t_pNtDll = NULL;
    }
    return fRet;
}

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

typedef struct _MY_BOOT_ENTRY {
    LIST_ENTRY ListEntry;
    PWSTR FriendlyName;
    BOOL Show;
    BOOL Ordered;
    PBOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;

DWORD BuildBootEntryList(CNtDllApi *t_pNtDll, PLIST_ENTRY BootEntries, PBOOT_ENTRY_LIST *BootEntryList)
{
    NTSTATUS status;
    DWORD count;
    DWORD length;
    PULONG order;
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY myBootEntry;
    LONG i;
    PLIST_ENTRY listEntry;

    InitializeListHead(BootEntries);
    *BootEntryList = NULL;

    //
    // Get the system boot order list.
    //
    count = 0;
    status = t_pNtDll->NtQueryBootEntryOrder(NULL, &count);

    if (status != STATUS_BUFFER_TOO_SMALL)
    {
        if (NT_SUCCESS(status))
        {

            //
            // There are no entries in the boot order list. Strange but
            // possible. But we can't do anything without it.
            //
            return 0;
        }
        else
        {
            //
            // An unexpected error occurred.
            //
            ASSERT_BREAK(FALSE);
            return 0;
        }
    }

    ASSERT_BREAK(count != 0);

    order = (PULONG)LocalAlloc(LPTR, count * sizeof(ULONG));
    if (order == NULL)
    {
        return 0;
    }

    status = t_pNtDll->NtQueryBootEntryOrder(order, &count);

    if (!NT_SUCCESS(status))
    {
        //
        // An unexpected error occurred.
        //
        ASSERT_BREAK(FALSE);
        LocalFree(order);
        return 0;
    }

    //
    // Get all existing boot entries.
    //
    length = 0;
    status = NtEnumerateBootEntries(NULL, &length);

    if (status != STATUS_BUFFER_TOO_SMALL)
    {
        if (NT_SUCCESS(status))
        {
            //
            // Somehow there are no boot entries in NVRAM.
            //
            LocalFree(order);
            return 0;
        }
        else
        {
            //
            // An unexpected error occurred.
            //
            ASSERT_BREAK(FALSE);
            LocalFree(order);
            return 0;
        }
    }

    ASSERT_BREAK(length != 0);
    
    bootEntryList = (PBOOT_ENTRY_LIST)LocalAlloc(LPTR, length);
    if (BootEntryList == NULL)
    {
        LocalFree(order);
        return 0;
    }
    *BootEntryList = bootEntryList;

    status = NtEnumerateBootEntries(bootEntryList, &length);

    if (!NT_SUCCESS(status))
    {
        ASSERT_BREAK(FALSE);
        LocalFree(order);
        return 0;
    }

    //
    // Convert the boot entries into our internal representation.
    //
    while (TRUE)
    {
        bootEntry = &bootEntryList->BootEntry;

        //
        // Allocate an internal structure for the boot entry.
        //
        myBootEntry = (PMY_BOOT_ENTRY)LocalAlloc(LPTR, sizeof(MY_BOOT_ENTRY));
        if (myBootEntry == NULL)
        {
            LocalFree(order);
            return 0;
        }

        RtlZeroMemory(myBootEntry, sizeof(MY_BOOT_ENTRY));

        //
        // Save the address of the NT boot entry.
        //
        myBootEntry->NtBootEntry = bootEntry;

        //
        // Save the address of the entry's friendly name.
        //
        myBootEntry->FriendlyName = (PWSTR)ADD_OFFSET(bootEntry, FriendlyNameOffset);

        //
        // Link the new entry into the list.
        //
        InsertTailList(BootEntries, &myBootEntry->ListEntry);

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0)
        {
            break;
        }
        bootEntryList = (PBOOT_ENTRY_LIST)ADD_OFFSET(bootEntryList, NextEntryOffset);
    }

    //
    // Boot entries are returned in an unspecified order. They are currently
    // in the BootEntries list in the order in which they were returned.
    // Sort the boot entry list based on the boot order. Do this by walking
    // the boot order array backwards, reinserting the entry corresponding to
    // each element of the array at the head of the list.
    //

    for (i = (LONG)count - 1; i >= 0; i--)
    {
        for (listEntry = BootEntries->Flink;
             listEntry != BootEntries;
             listEntry = listEntry->Flink)
        {
            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

            if (myBootEntry->NtBootEntry->Id == order[i] )
            {
                //
                // We found the boot entry with this ID. Move it to the
                // front of the list.
                //

                myBootEntry->Ordered = TRUE;

                RemoveEntryList(&myBootEntry->ListEntry);
                InsertHeadList(BootEntries, &myBootEntry->ListEntry);

                break;
            }
        }
    }

    //
    // Free the boot order list.
    //
    LocalFree(order);

    //
    // We don't want to show entries that are not in the boot order list.
    // We don't want to show removable media entries (for floppy or CD).
    // We do show non-NT entries.
    //
    count = 0;
    for (listEntry = BootEntries->Flink;
         listEntry != BootEntries;
         listEntry = listEntry->Flink)
    {
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

        if (myBootEntry->Ordered &&
            ((myBootEntry->NtBootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA) == 0))
        {
            myBootEntry->Show = TRUE;
            count++;
        }
    }

    return count;

} // BuildBootEntryList

VOID
FreeBootEntryList(
    PLIST_ENTRY BootEntries,
    PBOOT_ENTRY_LIST BootEntryList
    )
{
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY myBootEntry;

    while (!IsListEmpty(BootEntries))
    {
        listEntry = RemoveHeadList(BootEntries);
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
        LocalFree(myBootEntry);
    }
    if (BootEntryList != NULL)
    {
        LocalFree(BootEntryList);
    }

    return;

} // FreeBootEntryList

/*****************************************************************************
*
*  FUNCTION    : CNVRam::GetBootOptions
*
*  DESCRIPTION : Reads EFI NVRAM and returns the list of operating systems and
*                and the timeout
*
*  INPUTS      : pointer to names sa, pointer to timeout
*
*  OUTPUTS     : count of OS names returned
*
*  RETURNS     : BOOL
*
*  COMMENTS    :
*
*****************************************************************************/

BOOL CNVRam::GetBootOptions(SAFEARRAY **ppsaNames, DWORD *pdwTimeout, DWORD *pdwCount)
{
    NTSTATUS status;
    DWORD length;
    DWORD count;
    PBOOT_OPTIONS bootOptions = NULL;
    PBOOT_ENTRY_LIST bootEntryList = NULL;
    LIST_ENTRY bootEntries;
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY myBootEntry;
    BOOL retval = FALSE;

    CNtDllApi *t_pNtDll = (CNtDllApi *)CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(t_pNtDll == NULL)
    {
        return FALSE;
    }

    *ppsaNames = NULL;
    
    // Get NVRAM information from the kernel.

    InitializeListHead(&bootEntries);

    length = 0;
    status = t_pNtDll->NtQueryBootOptions(NULL, &length);
    
    if (status != STATUS_BUFFER_TOO_SMALL)
    {
        ASSERT_BREAK(FALSE);
        goto error;
    }
    else
    {
        bootOptions = (PBOOT_OPTIONS)LocalAlloc(LPTR, length);
        if (bootOptions == NULL)
        {
            goto error;
        }

        status = t_pNtDll->NtQueryBootOptions(bootOptions, &length);

        if (!NT_SUCCESS(status))
        {
            ASSERT_BREAK(FALSE);
            goto error;
        }
    }

    *pdwTimeout = bootOptions->Timeout;

    //
    // Build the boot entry list. If we don't have any entries to show,
    // bail out.
    //

    count = BuildBootEntryList(t_pNtDll, &bootEntries, &bootEntryList);
    if (count == 0)
    {
        goto error;
    }

    //
    // Create an array to put the showable entries in.  We'll start with 0
    // elements and add as necessary.
    //

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].cElements = count;
    rgsabound[0].lLbound = 0;
    
    try
    {
        *ppsaNames = SafeArrayCreate(VT_BSTR, 1, rgsabound);
        if (!*ppsaNames)
        {
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
        }
        
        long lIndex = 0;

        for (listEntry = bootEntries.Flink;
             listEntry != &bootEntries;
             listEntry = listEntry->Flink)
        {
            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
            if (myBootEntry->Show)
            {
                // Put the new element in

                bstr_t bstrTemp = (LPCWSTR)myBootEntry->FriendlyName;
                HRESULT t_Result = SafeArrayPutElement(*ppsaNames, &lIndex, (void *)(wchar_t*)bstrTemp);
                SysFreeString(bstrTemp);
                if (t_Result == E_OUTOFMEMORY)
                {
                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                }
                lIndex++;
            }
        }
    }
    catch(...)
    {
        if (*ppsaNames)
        {
            SafeArrayDestroy(*ppsaNames);
        }
        
        throw;
    }

    *pdwCount = rgsabound[0].cElements;

    retval = TRUE;

error:

    //
    // Clean up all allocations.
    //
    if (bootEntryList != NULL)
    {
        FreeBootEntryList(&bootEntries, bootEntryList);
    }
    if (bootOptions != NULL)
    {
        LocalFree(bootOptions);
    }

    return retval;

} // GetBootOptions

/*****************************************************************************
*
*  FUNCTION    : CNVRam::SetBootTimeout
*
*  DESCRIPTION : Sets boot timeout
*
*  INPUTS      : timeout
*
*  OUTPUTS     : none
*
*  RETURNS     : BOOL
*
*  COMMENTS    :
*
*****************************************************************************/

BOOL CNVRam::SetBootTimeout(DWORD dwTimeout)
{
    NTSTATUS status;
    DWORD length;
    PBOOT_OPTIONS bootOptions = NULL;
    BOOL retval = FALSE;

    CNtDllApi *t_pNtDll = (CNtDllApi *)CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(t_pNtDll == NULL)
    {
        return FALSE;
    }

    // Get NVRAM information from the kernel.

    length = 0;
    status = t_pNtDll->NtQueryBootOptions(NULL, &length);
    
    if (status != STATUS_BUFFER_TOO_SMALL)
    {
        ASSERT_BREAK(FALSE);
        goto error;
    }
    else
    {
        bootOptions = (PBOOT_OPTIONS)LocalAlloc(LPTR, length);
        if (bootOptions == NULL)
        {
            goto error;
        }

        status = t_pNtDll->NtQueryBootOptions(bootOptions, &length);

        if (!NT_SUCCESS(status))
        {
            ASSERT_BREAK(FALSE);
            goto error;
        }
    }

    bootOptions->Timeout = dwTimeout;

    //
    // Write the new timeout.
    //

    status = t_pNtDll->NtSetBootOptions(bootOptions, BOOT_OPTIONS_FIELD_TIMEOUT);
    if (NT_SUCCESS(status))
    {
        retval = TRUE;
    }

error:

    //
    // Clean up all allocations.
    //
    if (bootOptions != NULL)
    {
        LocalFree(bootOptions);
    }

    return retval;

} // SetBootTimeout

/*****************************************************************************
*
*  FUNCTION    : CNVRam::SetDefaultBootEntry
*
*  DESCRIPTION : Sets default boot entry
*
*  INPUTS      : default boot entry index
*
*  OUTPUTS     : none
*
*  RETURNS     : BOOL
*
*  COMMENTS    :
*
*****************************************************************************/

BOOL CNVRam::SetDefaultBootEntry(BYTE cIndex)
{
    NTSTATUS status;
    DWORD count;
    PBOOT_ENTRY_LIST bootEntryList = NULL;
    LIST_ENTRY bootEntries;
    PULONG order = NULL;
    BOOL retval = FALSE;

    if (cIndex == 0)
    {
        return TRUE;
    }

    CNtDllApi *t_pNtDll = (CNtDllApi *)CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(t_pNtDll == NULL)
    {
        return FALSE;
    }

    // Get NVRAM information from the kernel.

    InitializeListHead(&bootEntries);

    //
    // Build the boot entry list. If we don't have any entries to rearrange,
    // bail out.
    //

    count = BuildBootEntryList(t_pNtDll, &bootEntries, &bootEntryList);
    if (count == 0)
    {
        goto error;
    }

    //
    // Walk the boot entry list, looking for (a) the first showable entry
    // (which is the current index 0 entry, from the caller's point of view),
    // and (b) the selected entry. We want to swap these two entries.
    //

    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY myBootEntry;
    PMY_BOOT_ENTRY firstEntry = NULL;
    PMY_BOOT_ENTRY selectedEntry = NULL;
    PLIST_ENTRY previousEntry;

    count = 0;

    for (listEntry = bootEntries.Flink;
         listEntry != &bootEntries;
         listEntry = listEntry->Flink)
    {
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

        if (myBootEntry->Show)
        {
            if (count == 0)
            {
                firstEntry = myBootEntry;
            }
            else if (count == cIndex)
            {
                selectedEntry = myBootEntry;
            }
            count++;
        }
    }

    if ( (firstEntry == NULL) ||
         (selectedEntry == NULL) ||
         (selectedEntry == firstEntry) )
    {
        goto error;
    }

    //
    // Swap the entries. Capture the address of the entry before the first
    // entry (which might be the list head). Remove the first entry from
    // the list and insert it after the selected entry. Remove the selected
    // entry from the list and insert it after the captured entry.
    //

    previousEntry = firstEntry->ListEntry.Blink;
    RemoveEntryList(&firstEntry->ListEntry);
    InsertHeadList(&selectedEntry->ListEntry, &firstEntry->ListEntry);
    RemoveEntryList(&selectedEntry->ListEntry);
    InsertHeadList(previousEntry, &selectedEntry->ListEntry);

    //
    // Build the new boot order list. Insert all ordered boot entries
    // into the list.
    //
    count = 0;
    for (listEntry = bootEntries.Flink;
         listEntry != &bootEntries;
         listEntry = listEntry->Flink)
    {
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
        if (myBootEntry->Ordered)
        {
            count++;
        }
    }
    order = (PULONG)LocalAlloc(LPTR, count * sizeof(ULONG));
    if (order == NULL) {
        goto error;
    }

    count = 0;
    for (listEntry = bootEntries.Flink;
         listEntry != &bootEntries;
         listEntry = listEntry->Flink)
    {
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
        if (myBootEntry->Ordered)
        {
            order[count++] = myBootEntry->NtBootEntry->Id;
        }
    }

    //
    // Write the new boot entry order list to NVRAM.
    //
    status = t_pNtDll->NtSetBootEntryOrder(order, count);
    if (NT_SUCCESS(status))
    {
        retval = TRUE;
    }

error:

    //
    // An error occurred. Clean up all allocations.
    //
    if (bootEntryList != NULL)
    {
        FreeBootEntryList(&bootEntries, bootEntryList);
    }
    if (order != NULL)
    {
        LocalFree(order);
    }

    return retval;

} // SetDefaultBootEntry

#endif // defined(EFI_NVRAM_ENABLED)

#else

// Needed to fix warning message.  I believe this is fixed in vc6.
#if ( _MSC_VER <= 1100 )
void nvram_cpp(void) { ; };
#endif

#endif // !defined(_X86_) || defined(EFI_NVRAM_ENABLED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pagefile.cpp ===
//=================================================================

//

// PageFile.CPP --PageFile property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    03/01/99    a-peterc	    Created
//
//=================================================================

#include "precomp.h"
#include <io.h>
#include <WinPerf.h>
#include <cregcls.h>


#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"

#include "PageFile.h"
#include <tchar.h>
#include <ProvExce.h>

#include "computersystem.h"
#include "sid.h"
#include "ImpLogonUser.h"
#include "dllutils.h"


// declaration of our static instance
//=========================

PageFile MyPageFileSet(PROPSET_NAME_PageFile, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::PageFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

PageFile::PageFile(LPCWSTR name, LPCWSTR pszNamespace)
: CCIMDataFile(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::~PageFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

PageFile::~PageFile()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : CInstance *a_pInst, long a_lFlags
 *
 *  OUTPUTS     : CInstance *a_pInst
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT PageFile::GetObject(CInstance *a_pInst, long a_lFlags, CFrameworkQuery& pQuery)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif

    // calls the OS specific compiled version
	hr = GetPageFileData( a_pInst, true ) ;


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : PageFile::ExecQuery
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :  Because the local enumerate is faster than the parent's
 *                 enumerate, and in many types of queries the local enumerate
 *                 is faster than the parents execquery (such as those queries
 *                 that ask for a specific caption, which the parent would process
 *                 as an NtokenAnd query, enumerating all drives in the process),
 *                 we intercept the call and do an enumeration instead, allowing
 *                 CIMOM to post filter the results.
 *
 *****************************************************************************/
HRESULT PageFile::ExecQuery(MethodContext* pMethodContext,
                                  CFrameworkQuery& pQuery,
                                  long lFlags)
{
	HRESULT hr = WBEM_S_NO_ERROR;

    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    hr = EnumerateInstances(pMethodContext, lFlags);


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::EnumerateInstances
 *
 *  DESCRIPTION : Creates property set instances
 *
 *  INPUTS      : MethodContext*  a_pMethodContext, long a_lFlags
 *
 *  OUTPUTS     : MethodContext*  a_pMethodContext
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT PageFile::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;

    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    // calls the OS specific compiled version
	hr = GetAllPageFileData( a_pMethodContext );

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::GetPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance *a_pInst
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFile::GetPageFileData( CInstance *a_pInst, bool a_fValidate )
{
	HRESULT t_hRes = WBEM_E_NOT_FOUND;

    // NT page file name is in registry
    //=================================
	PageFileInstance t_files [ 26 ] ;

   	DWORD t_nInstances = GetPageFileInstances( t_files );
	CHString t_chsTemp ;
	CHString t_name;

	a_pInst->GetCHString( IDS_Name, t_name );

	for ( DWORD t_dw = 0; t_dw < t_nInstances; t_dw++ )
	{
		if ( t_name.CompareNoCase ( t_files[t_dw].name ) == 0 )
		{
      		// pagefile boundaries
			a_pInst->SetDWORD (	IDS_MaximumSize, t_files[t_dw].max ) ;
			a_pInst->SetDWORD (	IDS_InitialSize, t_files[t_dw].min ) ;

			t_hRes = WBEM_S_NO_ERROR;
		}
	}

	return t_hRes;
}
#endif

#ifdef WIN9XONLY
HRESULT PageFile::GetPageFileData( CInstance *a_pInst, bool a_fValidate )
{
    TCHAR t_szTemp[_MAX_PATH] ;
    CHString t_chstrCurrentName;
    DEVIOCTL_REGISTERS t_reg ;
	MEMORYSTATUS t_MemoryStatus;


	// We have to drill for the page file name in Win95
	//=================================================
	memset( &t_reg, '\0', sizeof(DEVIOCTL_REGISTERS) );

	t_reg.reg_EAX     = 0x440D ;          // IOCTL for block devices
	t_reg.reg_ECX     = 0x486e ;          // Get Swap file name
	t_reg.reg_EDX     = (DWORD) t_szTemp ;  // receives media identifier information

	if( VWIN32IOCTL( &t_reg, VWIN32_DIOC_DOS_IOCTL) )
	{
		// If szTemp is empty at this point, we don't have a pagefile,
		// so get the ... out of dodge.
		if( _tcslen( t_szTemp ) != 0 )
		{
			if(a_fValidate)
            {
                a_pInst->GetCHString( IDS_Name, t_chstrCurrentName );
                if( t_chstrCurrentName.CompareNoCase( CHString( t_szTemp ) ) != 0 )
			    {
				    return WBEM_E_NOT_FOUND;
			    } //otherwise, the one we have is ok (no need for 'else')
            }
            else
            {
                a_pInst->SetCharSplat( IDS_Name, t_szTemp ) ;
            }
		}
		else
		{
			return WBEM_E_NOT_FOUND;
		}
	}

	t_MemoryStatus.dwLength = sizeof( MEMORYSTATUS ) ;
	GlobalMemoryStatus( &t_MemoryStatus ) ;

	// Value current in bytes, to convert to Mb >> 20
	a_pInst->SetDWORD( IDS_MaximumSize, t_MemoryStatus.dwTotalPageFile >> 20 );
	a_pInst->SetDWORD( IDS_FreeSpace,   t_MemoryStatus.dwAvailPageFile >> 20 );

	return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::GetAllPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext *a_pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFile::GetAllPageFileData( MethodContext *a_pMethodContext )
{
	HRESULT		t_hResult	 = WBEM_S_NO_ERROR;
	DWORD		t_nInstances = 0;
	CInstancePtr t_pInst;
	PageFileInstance t_files [ 26 ] ;
	CHString t_chsTemp ;

	// NT page file name is in registry
	//=================================
	t_nInstances = GetPageFileInstances( t_files );

	for (DWORD t_dw = 0; t_dw < t_nInstances && SUCCEEDED( t_hResult ); t_dw++ )
	{
		t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );

		t_pInst->SetCHString( IDS_Name,		t_files[t_dw].name ) ;
		t_pInst->SetDWORD( IDS_MaximumSize, t_files[t_dw].max ) ;
		t_pInst->SetDWORD( IDS_InitialSize, t_files[t_dw].min ) ;

		t_hResult = t_pInst->Commit(  ) ;
	}

	return t_hResult;
}
#endif

#ifdef WIN9XONLY
HRESULT PageFile::GetAllPageFileData( MethodContext *a_pMethodContext )
{
	HRESULT		t_hResult	= WBEM_S_NO_ERROR;
	CInstancePtr t_pInst;

	t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
	t_hResult = GetPageFileData( t_pInst, false ) ;

	if( SUCCEEDED( t_hResult ) )
	{
		t_hResult = t_pInst->Commit( ) ;
    }

	return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFile::GetPageFileInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : PageFileInstanceArray &a_instArray
 *
 *  OUTPUTS     : PageFileInstanceArray &a_instArray
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	returns actual number found - NT ONLY
 *
 *****************************************************************************/

#ifdef NTONLY
DWORD PageFile::GetPageFileInstances( PageFileInstanceArray a_instArray )
{
    CHString	t_sRegValue;
    DWORD		t_nInstances = 0;
    CRegistry	t_Reg ;

    if( t_Reg.OpenLocalMachineKeyAndReadValue(PAGEFILE_REGISTRY_KEY,
												PAGING_FILES,
												t_sRegValue ) == ERROR_SUCCESS)
    {
        // pattern is name <space> min size [optional<max size>] 0A repeat...
        // I'll use an ASCII smiley face to replace the delimiter...
        int t_iStart = 0, t_iIndex;
        const TCHAR t_smiley = '\x02';
        const TCHAR t_delimiter = '\x0A';
        CHString t_buf;

        while (-1 != ( t_iIndex = t_sRegValue.Find( t_delimiter ) ) )
        {
            // copy to buffer to make life easier
            t_buf = t_sRegValue.Mid( t_iStart, t_iIndex - t_iStart );

			// mash delimiter so we don't find it again.
            t_sRegValue.SetAt( t_iIndex, t_smiley );

			// save start for next time around.
            t_iStart = t_iIndex + 1;

            t_iIndex = t_buf.Find(' ');

            a_instArray[ t_nInstances ].name = t_buf.Left( t_iIndex );

            if ( t_iIndex != -1 )
			{
                t_buf.SetAt( t_iIndex, t_smiley );
			}

            int t_iEnd = t_buf.Find(' ');

            // if no more spaces, there isn't a max size written down
            if ( -1 == t_iEnd )
            {
				CHString t_littleBuf = t_buf.Mid( t_iIndex + 1 );

				a_instArray[ t_nInstances ].min = _ttoi( t_littleBuf );
                a_instArray[ t_nInstances ].max = a_instArray[ t_nInstances ].min + 50;
            }
            else
            {
                CHString t_littleBuf = t_buf.Mid( t_iIndex +1, t_iEnd - t_iIndex );
                a_instArray[ t_nInstances ].min = _ttoi( t_littleBuf );

                t_littleBuf = t_buf.Mid( t_iEnd );
                a_instArray[ t_nInstances ].max = _ttoi( t_littleBuf );
            }

            // Make sure the thing really exists.  It should also be in use.
            DWORD t_dwRet = GetFileAttributes( a_instArray[ t_nInstances ].name );
            //if (-1 == t_dwRet ) // 51169 - a valid pagefile, in use, was returning 26, not -1.  GetLastError() still reported 0x5, so no need
            // for us to restrict to the -1 case... in fact, caused us to miss an otherwise valid instance.
            {
                DWORD t_wErr = GetLastError();

                // Some os's say sharing violation, some just say access denied.
                if ( ( t_wErr == ERROR_SHARING_VIOLATION ) ||
					( t_wErr == ERROR_ACCESS_DENIED ) )
				{
                    t_nInstances++;
				}
            }
        }
    }

    return t_nInstances;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : PageFile::PutInstance
 *
 *  DESCRIPTION : Write changed or new instance
 *
 *  INPUTS      : a_pInst to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :	Separate OS compile versions
					For win95, this won't work at all.  Apparently w95 can only
 *					have one page file.  The min, max, and name are all stored
 *					in system.ini.
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT PageFile::PutInstance( const CInstance &a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT t_hRet = WBEM_S_NO_ERROR;

	DWORD	t_dwCount,
			t_x,
			t_dwTemp;

	PageFileInstance t_instArray [ 26 ] ;
	CHString t_sName;

	bool t_bFoundIt = false;


	// Get the values we are supposed to write in
	a_pInst.GetCHString( IDS_Name, t_sName );

    //name must be letter colon slash name...
    if (t_sName.GetLength() == 0)
    {
        return WBEM_E_NOT_FOUND;
    }

    t_sName.MakeLower();

    // Check if the name is indeeed "pagefile.sys"
    if ( -1 == t_sName.Find( _T("pagefile.sys") ) )
    {
	    return WBEM_E_NOT_FOUND;
    }

    // Read the page file array
    t_dwCount = GetPageFileInstances( t_instArray );

	// Find if it is already there, and update the structure
	for ( t_x = 0; t_x < t_dwCount; t_x++ )
	{
      // Is this the guy?
      if ( 0 == _tcsicmp( t_instArray[t_x].name, t_sName ) )
	  {
         if ( a_lFlags & WBEM_FLAG_CREATE_ONLY )
		 {
            t_hRet = WBEM_E_ALREADY_EXISTS;
         }
		 else
		 {
            // Did they give us a value?
            if ( !a_pInst.IsNull( IDS_InitialSize ) )
			{
				// Check for value in range
				t_dwTemp = 0;
				a_pInst.GetDWORD( IDS_InitialSize, t_dwTemp );

				// minimum of 2 meg
				if( 2 > t_dwTemp )
				{
					t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                    t_bFoundIt = true;
					break;
				}
				t_instArray[t_x].min = t_dwTemp;
            }

            // Did they give us a value?
            if ( !a_pInst.IsNull( IDS_MaximumSize ) )
			{
				// Check for value in range
				a_pInst.GetDWORD( IDS_MaximumSize, t_dwTemp );

		        t_instArray[t_x].max = t_dwTemp;
            }

            // Check the basic
            if ( t_instArray[t_x].min > t_instArray[t_x].max )
			{
               t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
            }

			t_bFoundIt = true;
            break;
         }
      }
   }

   // We didn't find it.  Let's make a new one
   if ( !t_bFoundIt )
   {
      if (a_lFlags & WBEM_FLAG_UPDATE_ONLY)
	  {
         t_hRet = WBEM_E_NOT_FOUND;
      }
	  else
	  {
         t_instArray[ t_dwCount ].name = t_sName;

         // Did they give us a value?
         if ( !a_pInst.IsNull( IDS_InitialSize ) )
		 {
            // Check for value in range
            a_pInst.GetDWORD( IDS_InitialSize, t_dwTemp );

            // minimum of 2 meg
			if( 2 > t_dwTemp )
			{
				return WBEM_E_VALUE_OUT_OF_RANGE;
			}

			t_instArray[t_dwCount].min = t_dwTemp;
         }

         // Did they give us a value?
         if ( !a_pInst.IsNull( IDS_MaximumSize ) )
		 {
            // Check for value in range
            a_pInst.GetDWORD( IDS_MaximumSize, t_dwTemp );

			t_instArray[ t_dwCount ].max = t_dwTemp;
         }

         // Check for basic errors
         if ( t_instArray[ t_dwCount ].min > t_instArray[ t_dwCount ].max )
		 {
            return WBEM_E_VALUE_OUT_OF_RANGE;
         }

         // One more in the array
         t_dwCount++;

         // Iff we are able to create the pagefile,
         // continue to update the registry;
         // otherwise, fail. I will either succeed
         // to create all page files specified,
         // or, if even one fails to create, fail
         // and not update the registry for any.
         LARGE_INTEGER liMin;
         LARGE_INTEGER liMax;

         liMin.QuadPart = t_instArray[t_dwCount-1].min;
         liMax.QuadPart = t_instArray[t_dwCount-1].max;

         t_hRet = CreatePageFile(
            t_sName,
            liMin,
            liMax,
            a_pInst);
      }
   }

   // Update the registry
   if ( WBEM_S_NO_ERROR == t_hRet )
   {
      t_hRet = PutPageFileInstances( t_instArray, t_dwCount );
   }

   return t_hRet;
}
#endif

#ifdef WIN9XONLY
HRESULT PageFile::PutInstance(const CInstance &a_pInst, long a_lFlags /*= 0L*/)
{
	return WBEM_E_FAILED;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : PageFile::PutPageFileInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : PageFileInstanceArray &a_instArray, DWORD a_dwCount
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	returns actual number found - NT ONLY
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT PageFile::PutPageFileInstances(PageFileInstanceArray a_instArray, DWORD a_dwCount )
{
	CRegistry t_Reg ;
	CHString t_sFiles;
	TCHAR t_szBuff[MAXITOA];
	HRESULT t_hResult = WBEM_E_FAILED;

	HRESULT t_Res = t_Reg.Open( HKEY_LOCAL_MACHINE, PAGEFILE_REGISTRY_KEY, KEY_READ | KEY_WRITE );

	if( ERROR_SUCCESS == t_Res )
	{
	  // Build up the string.  Each entry is \0 terminated.
	  t_sFiles.Empty();

	  for ( int t_x = 0; t_x < a_dwCount; t_x++ )
	  {
		 t_sFiles += a_instArray[ t_x ].name;
		 t_sFiles += _T(' ');
		 t_sFiles += _itot( a_instArray[ t_x ].min, t_szBuff, 10 );
		 t_sFiles += _T(' ');
		 t_sFiles += _itot( a_instArray[ t_x ].max, t_szBuff, 10 );
		 t_sFiles += _T('\0');
	  }

	  // The end is indicated with \0\0.
	  t_sFiles += _T('\0');

		// Write the value
		if ((t_Res = RegSetValueEx( t_Reg.GethKey(),
								  PAGING_FILES,
								  0,
								  REG_MULTI_SZ,
								  (const unsigned char *)(LPCTSTR) t_sFiles,
								  t_sFiles.GetLength() * sizeof(TCHAR) )) == ERROR_SUCCESS )
		{
			t_hResult = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(t_Res) && (t_Res == ERROR_ACCESS_DENIED))
	{
		t_hResult = WBEM_E_ACCESS_DENIED;
	}

	return t_hResult;
}
#endif

////////////////////////////////////////////////////////////////////////
//
//	Function:	DeleteInstance
//
//	CIMOM wants us to delete this instance.
//
//	Inputs:
//
//	Outputs:
//
//	Return:
//
//	Comments: Separate OS compile versions
//
////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT PageFile::DeleteInstance(const CInstance &a_pInst, long a_lFlags /*= 0L*/)
{
   DWORD t_dwCount,
		 t_x;
   CHString t_sName;
   bool t_bFoundIt;
   HRESULT t_hRet;
   PageFileInstance t_instArray [ 26 ] ;

   // Fill the pagefile array
   t_dwCount = GetPageFileInstances( t_instArray );

   // Get the name
   a_pInst.GetCHString( IDS_Name, t_sName );

   t_bFoundIt = false;

   // Walk the array looking for it
   for ( t_x = 0; t_x < t_dwCount; t_x++ )
   {
      // This one?
      if ( _tcsicmp( t_instArray[ t_x ].name, t_sName ) == 0 )
	  {
         // Yup
         t_bFoundIt = true;

         // Move the rest down over this one
         for (int t_y = t_x; t_y < t_dwCount - 1; t_y++ )
		 {
			t_instArray[ t_y ].name	= t_instArray[ t_y + 1].name;
			t_instArray[ t_y ].min	= t_instArray[ t_y + 1].min;
			t_instArray[ t_y ].max	= t_instArray[ t_y + 1].max;
		}

         // The array is now one shorter
         t_dwCount--;
         break;
      }
   }

   if ( t_bFoundIt )
   {
      // If we found it, update the registry
      t_hRet = PutPageFileInstances( t_instArray, t_dwCount );
   }
   else
   {
      t_hRet = WBEM_E_NOT_FOUND;
   }

   return t_hRet;
}
#endif

#ifdef WIN9XONLY
HRESULT PageFile::DeleteInstance(const CInstance &a_pInst, long a_lFlags /*= 0L*/)
{
    return WBEM_E_NOT_FOUND;
}
#endif

////////////////////////////////////////////////////////////////////////
//
//	Function:	IsOneOfMe
//
//	Inputs:		LPWIN32_FIND_DATAA	a_pstFindData,
//				LPCSTR				a_szFullPathName
//
//	Outputs:
//
//	Return:		Boolean
//
//	Comments: Win9x and NT compiled version
//
////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL PageFile::IsOneOfMe( LPWIN32_FIND_DATA a_pstFindData,
		                  LPCTSTR		   a_tstrFullPathName )
{
    BOOL t_bRet = FALSE;
    PageFileInstance t_files [ 26 ] ;
	DWORD t_nInstances = GetPageFileInstances( t_files );

	for (DWORD t_dw = 0; t_dw < t_nInstances; t_dw++ )
	{
        _bstr_t t_bstrtName( (LPCTSTR)t_files[ t_dw ].name );

		if( 0 == _wcsicmp( t_bstrtName, a_tstrFullPathName ) )
        {
            t_bRet = TRUE;
            break;
        }
	}
    return t_bRet;
}
#endif

#ifdef WIN9XONLY
BOOL PageFile::IsOneOfMe(LPWIN32_FIND_DATAA a_pstFindData,
		                 LPCTSTR			a_tstrFullPathName )
{
    BOOL t_bRet = FALSE;
    DEVIOCTL_REGISTERS t_reg;
    char t_szTemp[_MAX_PATH] ;

    memset( &t_reg, '\0', sizeof( DEVIOCTL_REGISTERS ) );
    ZeroMemory( t_szTemp, sizeof( t_szTemp ) );

    t_reg.reg_EAX     = 0x440D ;          // IOCTL for block devices
    t_reg.reg_ECX     = 0x486e ;          // Get Swap file name
    t_reg.reg_EDX     = (DWORD_PTR) t_szTemp ;// receives media identifier information

    if( VWIN32IOCTL( &t_reg, VWIN32_DIOC_DOS_IOCTL ) )
	{
        if( 0 != strlen( t_szTemp ) )
        {
            if(0 == _stricmp( t_szTemp, a_tstrFullPathName )  )
            {
                t_bRet = TRUE;
            }
        }
    }
    return t_bRet;
}
#endif

PageFileInstance::PageFileInstance()
{
	min = max = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pagefile.h ===
//=================================================================

//

// PageFile.h -- PageFile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//			     03/01/99    a-peterc	    Cleanup
//
//=================================================================


// Property set identification
//============================

#define  PROPSET_NAME_PageFile L"Win32_PageFile"

#define PAGEFILE_REGISTRY_KEY _T("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management")
#define PAGING_FILES          _T("PagingFiles")



// corresponds to info found in NT registry
class PageFileInstance
{
public:

	CHString name;
	UINT     min;
	UINT     max;

public:

	PageFileInstance(); 
	
};

// twenty six possible drive letters, twenty six possible page files...
#define PageFileInstanceArray PageFileInstance *

class PageFile : public CCIMDataFile
{
	private:

		HRESULT GetPageFileData( CInstance *a_pInst, bool a_fValidate ) ;
		HRESULT GetAllPageFileData( MethodContext *a_pMethodContext ) ;

		// NT only
		DWORD	GetPageFileInstances( PageFileInstanceArray a_instArray ) ;
		HRESULT PutPageFileInstances( PageFileInstanceArray a_instArray, DWORD a_dwCount ) ;
        

	protected:
		// Overridable function inherited from CCIMLogicalFile needs to 
	    // implement this here since this class is derived from CCimDataFile
		// (both C++ and MOF derivation). CCimDataFile calls IsOneOfMe.
	    // The most derived instance will be called.  If not implemented here, 
		// CCimDataFile will be used, which will commit for datafiles.
		// However, If CCimDataFile does not return FALSE from its IsOneOfMe,
		// which it won't do if not implemented here, all data files  
		// will be assigned to this class.
		virtual BOOL IsOneOfMe(LPWIN32_FIND_DATA a_pstFindData,
							   LPCTSTR			 a_tstrFullPathName);

    public:
        // Constructor/destructor
        //=======================
        PageFile( LPCWSTR name, LPCWSTR pszNamespace ) ;
       ~PageFile() ;

		// Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_pInst = 0L ) ;
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags, CFrameworkQuery& pQuery ) ;
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);

        
		// NT ONLY
		virtual HRESULT PutInstance( const CInstance &a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT DeleteInstance( const CInstance &a_pInst, long a_lFlags = 0L ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\os.h ===
//=================================================================

//

// OS.h -- Operating system property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/25/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================
#include "SystemName.h"
#include "ServerDefs0.h"
#define PROPSET_NAME_OS L"Win32_OperatingSystem"

#define PROCESS_PRIORITY_SEPARATION_MASK    0x00000003
#define PROCESS_QUANTUM_VARIABLE_MASK       0x0000000c
#define PROCESS_QUANTUM_LONG_MASK           0x00000030

struct stOSStatus {
    DWORD dwFound;
    DWORD dwReturn;
    DWORD dwFlags;
    DWORD dwReserved;
};
    
class CWin32OS ;

class CWin32OS:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32OS(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32OS() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );

#ifdef WIN9XONLY
        static BOOL GetWin95BootDevice( TCHAR cBootDrive, CHString& strBootDevice );
#endif

	private:
        // Utility functions
        //==================

        void	GetProductSuites( CInstance * pInstance );
		HRESULT hGetProductSuites(CHStringArray& rchsaProductSuites ); 

		void GetRunningOSInfo(CInstance *pInstance, const CHString &sName, CFrameworkQuery *pQuery);
        void GetNTInfo(CInstance *pInstance) ;
        void GetWin95Info(CInstance *pInstance) ;
        __int64 GetTotalSwapFileSize();
		
		// Helper time conversion function
        HRESULT ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags = 0L);
        bool GetLicensedUsers(DWORD *dwRetVal);
        IDispatch FAR* GetCollection(IDispatch FAR* pIn, WCHAR *wszName, DISPPARAMS *pDispParams);
        bool GetValue(IDispatch FAR* pIn, WCHAR *wszName, VARIANT *vValue);
#ifdef NTONLY

		BOOL CWin32OS::CanShutdownSystem ( const CInstance& a_Instance , DWORD &a_dwLastError ) ;
#endif
		DWORD	GetCipherStrength() ;
} ;

HRESULT WINAPI ShutdownThread(DWORD dwFlags) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pagefilesetting.h ===
//=================================================================

//

// PageFileSetting.h -- PageFileSetting property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    03/01/99    a-peterc	    Created
//
//=================================================================




// Property set identification
//============================

#define  PROPSET_NAME_PageFileSetting L"Win32_PageFileSetting"

#define PAGEFILE_REGISTRY_KEY _T("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management")
#define PAGING_FILES          _T("PagingFiles")



// corresponds to info found in NT registry
class PageFileSettingInstance
{
public:

	CHString name;
	UINT     min;
	UINT     max;

public:

	PageFileSettingInstance() ;
};

// twenty six possible drive letters, twenty six possible page files...
#define PageFileInstanceArray PageFileSettingInstance *

class PageFileSetting : public Provider
{
	private:

		HRESULT GetPageFileData( CInstance *a_pInst, bool a_fValidate ) ;
		HRESULT GetAllPageFileData( MethodContext *a_pMethodContext ) ;

		// NT only
		DWORD	GetPageFileInstances( PageFileInstanceArray a_instArray ) ;
		HRESULT PutPageFileInstances( PageFileInstanceArray a_instArray, DWORD a_dwCount ) ;

		void	NameToSettingID( CHString &a_chsName, CHString &a_chsSettingID ) ;
		void	NameToCaption( CHString &a_chsName, CHString &a_chsCaption ) ;
		void	NameToDescription( CHString &a_chsName, CHString &a_chsDescription ) ;
    
	protected:

    public:
        // Constructor/destructor
        //=======================
        PageFileSetting( LPCWSTR name, LPCWSTR pszNamespace ) ;
       ~PageFileSetting() ;

		// Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_pInst = 0L ) ;
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        
		// NT ONLY
		virtual HRESULT PutInstance( const CInstance &a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT DeleteInstance( const CInstance &a_pInst, long a_lFlags = 0L ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pagefilesetting.cpp ===
//=================================================================

//

// PageFileSetting.CPP --PageFileSetting property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    03/01/99    a-peterc	    Created
//
//=================================================================

#include "precomp.h"
#include <io.h>
#include <WinPerf.h>
#include <cregcls.h>


#include "PageFileSetting.h"
#include <tchar.h>
#include <ProvExce.h>

#include "computersystem.h"
#include "dllutils.h"


// declaration of our static instance
//=========================

PageFileSetting MyPageFileSettingSet(PROPSET_NAME_PageFileSetting, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::PageFileSetting
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

PageFileSetting::PageFileSetting(LPCWSTR name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::~PageFileSetting
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

PageFileSetting::~PageFileSetting()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : CInstance *a_pInst, long a_lFlags
 *
 *  OUTPUTS     : CInstance *a_pInst
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT PageFileSetting::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
	// calls the OS specific compiled version
	return GetPageFileData( a_pInst, true ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::EnumerateInstances
 *
 *  DESCRIPTION : Creates property set instances
 *
 *  INPUTS      : MethodContext*  a_pMethodContext, long a_lFlags
 *
 *  OUTPUTS     : MethodContext*  a_pMethodContext
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT PageFileSetting::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	// calls the OS specific compiled version
	return GetAllPageFileData( a_pMethodContext );
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::GetPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance *a_pInst
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFileSetting::GetPageFileData( CInstance *a_pInst, bool a_fValidate )
{
	HRESULT t_hRes = WBEM_E_NOT_FOUND;

    // NT page file name is in registry
    //=================================
	PageFileSettingInstance t_files [ 26 ] ;

   	DWORD t_nInstances = GetPageFileInstances( t_files );
	CHString t_chsTemp ;
	CHString t_name;

	a_pInst->GetCHString( IDS_Name, t_name );

	for ( DWORD t_dw = 0; t_dw < t_nInstances; t_dw++ )
	{
		if ( t_name.CompareNoCase ( t_files[t_dw].name ) == 0 )
		{
            // CIM_Setting::SettingID
			NameToSettingID( t_files[t_dw].name,	t_chsTemp ) ;
			a_pInst->SetCHString( _T("SettingID"),  t_chsTemp ) ;

			// CIM_Setting::Caption
			NameToCaption( t_files[t_dw].name,		t_chsTemp ) ;
			a_pInst->SetCHString( IDS_Caption,		t_chsTemp ) ;

			// CIM_Setting::Description
			NameToDescription( t_files[t_dw].name,	t_chsTemp ) ;
			a_pInst->SetCHString( IDS_Description,	t_chsTemp ) ;

			// pagefile boundaries
			a_pInst->SetDWORD (	IDS_MaximumSize, t_files[t_dw].max ) ;
			a_pInst->SetDWORD (	IDS_InitialSize, t_files[t_dw].min ) ;

			t_hRes = WBEM_S_NO_ERROR;
		}
	}

	return t_hRes;
}
#endif

#ifdef WIN9XONLY
HRESULT PageFileSetting::GetPageFileData( CInstance *a_pInst, bool a_fValidate )
{
    TCHAR t_szTemp[_MAX_PATH] ;
    CHString t_chstrCurrentName;
    DEVIOCTL_REGISTERS t_reg ;
	MEMORYSTATUS t_MemoryStatus;


	// We have to drill for the page file name in Win95
	//=================================================
	memset( &t_reg, '\0', sizeof(DEVIOCTL_REGISTERS) );

	t_reg.reg_EAX     = 0x440D ;          // IOCTL for block devices
	t_reg.reg_ECX     = 0x486e ;          // Get Swap file name
	t_reg.reg_EDX     = (DWORD) t_szTemp ;  // receives media identifier information

	if( VWIN32IOCTL( &t_reg, VWIN32_DIOC_DOS_IOCTL) )
	{
		// If szTemp is empty at this point, we don't have a pagefile,
		// so get the ... out of dodge.
		if( _tcslen( t_szTemp ) != 0 )
		{
			if(a_fValidate)
            {
				a_pInst->GetCHString( IDS_Name, t_chstrCurrentName );
                if( t_chstrCurrentName.CompareNoCase( CHString( t_szTemp ) ) != 0 )
			    {
				    return WBEM_E_NOT_FOUND;
			    } //otherwise, the one we have is ok (no need for 'else')
            }
            else
            {
     			// Name
				a_pInst->SetCharSplat( IDS_Name, t_szTemp ) ;
			}
		}
		else
		{
			return WBEM_E_NOT_FOUND;
		}
	}
	else
	{
		return WBEM_E_NOT_FOUND;
	}

	CHString t_chsTemp, t_chsTemp2 ;

	// Name
	a_pInst->SetCharSplat( IDS_Name, t_szTemp ) ;

	// CIM_Setting::SettingID
    t_chsTemp2 = t_szTemp;
	NameToSettingID( t_chsTemp2, t_chsTemp ) ;
	a_pInst->SetCHString( L"SettingID", t_chsTemp ) ;

	// CIM_Setting::Caption
	NameToCaption( t_chsTemp2, t_chsTemp ) ;
	a_pInst->SetCHString( IDS_Caption, t_chsTemp ) ;

	// CIM_Setting::Description
	NameToDescription( t_chsTemp2, t_chsTemp ) ;
	a_pInst->SetCHString( IDS_Description, t_chsTemp ) ;

	t_MemoryStatus.dwLength = sizeof( MEMORYSTATUS ) ;
	GlobalMemoryStatus( &t_MemoryStatus ) ;

	// the min and max page file size comes from the System.ini for 9x
	UINT t_uiMinPageFileSize = GetPrivateProfileInt( _T("386Enh"), _T("MinPagingFileSize"), 0,  _T("System.ini") ) ;
	UINT t_uiMaxPageFileSize = GetPrivateProfileInt( _T("386Enh"), _T("MaxPagingFileSize"), 0,  _T("System.ini") ) ;

	// Value current in bytes, to convert to Mb
	if( t_uiMaxPageFileSize )
	{
		a_pInst->SetDWORD( IDS_MaximumSize, t_uiMaxPageFileSize / 1024 ) ;
	}
	else
	{
		a_pInst->SetDWORD( IDS_MaximumSize, t_MemoryStatus.dwTotalPageFile >> 20 ) ;
	}

	a_pInst->SetDWORD( IDS_InitialSize, t_uiMinPageFileSize / 1024 ) ;

	return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::GetAllPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext *a_pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFileSetting::GetAllPageFileData( MethodContext *a_pMethodContext )
{
	HRESULT		t_hResult	 = WBEM_S_NO_ERROR;
	DWORD		t_nInstances = 0;
	CInstancePtr t_pInst;
	PageFileSettingInstance t_files [ 26 ] ;
	CHString t_chsTemp ;

	// NT page file name is in registry
	//=================================
	t_nInstances = GetPageFileInstances( t_files );

	for (DWORD t_dw = 0; t_dw < t_nInstances && SUCCEEDED( t_hResult ); t_dw++ )
	{
		t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );

		// CIM_Setting::SettingID
		NameToSettingID( t_files[t_dw].name,	t_chsTemp ) ;
		t_pInst->SetCHString( _T("SettingID"),  t_chsTemp ) ;

		// CIM_Setting::Caption
		NameToCaption( t_files[t_dw].name,		t_chsTemp ) ;
		t_pInst->SetCHString( IDS_Caption,		t_chsTemp ) ;

		// CIM_Setting::Description
		NameToDescription( t_files[t_dw].name,	t_chsTemp ) ;
		t_pInst->SetCHString( IDS_Description,	t_chsTemp ) ;

		t_pInst->SetCHString( IDS_Name,		t_files[t_dw].name ) ;
		t_pInst->SetDWORD( IDS_MaximumSize, t_files[t_dw].max ) ;
		t_pInst->SetDWORD( IDS_InitialSize, t_files[t_dw].min ) ;

		t_hResult = t_pInst->Commit(  ) ;
	}

	return t_hResult;
}
#endif

#ifdef WIN9XONLY
HRESULT PageFileSetting::GetAllPageFileData( MethodContext *a_pMethodContext )
{
	HRESULT		t_hResult	= WBEM_S_NO_ERROR;
	CInstancePtr t_pInst;

	t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );

	t_hResult = GetPageFileData( t_pInst, false ) ;

	if( SUCCEEDED( t_hResult ) )
	{
		t_hResult = t_pInst->Commit( ) ;
	}

	return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::GetPageFileInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : PageFileInstanceArray a_instArray
 *
 *  OUTPUTS     : PageFileInstanceArray a_instArray
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	returns actual number found - NT ONLY
 *
 *****************************************************************************/

#ifdef NTONLY
DWORD PageFileSetting::GetPageFileInstances( PageFileInstanceArray a_instArray )
{
    CHString	t_sRegValue;
    DWORD		t_nInstances = 0;
    CRegistry	t_Reg ;

    if( t_Reg.OpenLocalMachineKeyAndReadValue(PAGEFILE_REGISTRY_KEY,
												PAGING_FILES,
												t_sRegValue ) == ERROR_SUCCESS)
    {
        // pattern is name <space> min size [optional<max size>] 0A repeat...
        // I'll use an ASCII smiley face to replace the delimiter...
        int t_iStart = 0, t_iIndex;
        const TCHAR t_smiley = '\x02';
        const TCHAR t_delimiter = '\x0A';
        CHString t_buf;

        while (-1 != ( t_iIndex = t_sRegValue.Find( t_delimiter ) ) )
        {
            // copy to buffer to make life easier
            t_buf = t_sRegValue.Mid( t_iStart, t_iIndex - t_iStart );

			// mash delimiter so we don't find it again.
            t_sRegValue.SetAt( t_iIndex, t_smiley );

			// save start for next time around.
            t_iStart = t_iIndex + 1;

            t_iIndex = t_buf.Find(' ');

            a_instArray[ t_nInstances ].name = t_buf.Left( t_iIndex );

            if ( t_iIndex != -1 )
			{
                t_buf.SetAt( t_iIndex, t_smiley );
			}

            int t_iEnd = t_buf.Find(' ');

            // if no more spaces, there isn't a max size written down
            if ( -1 == t_iEnd )
            {
				CHString t_littleBuf = t_buf.Mid( t_iIndex + 1 );

				a_instArray[ t_nInstances ].min = _ttoi( t_littleBuf );
                a_instArray[ t_nInstances ].max = a_instArray[ t_nInstances ].min + 50;
            }
            else
            {
                CHString t_littleBuf = t_buf.Mid( t_iIndex +1, t_iEnd - t_iIndex );
                a_instArray[ t_nInstances ].min = _ttoi( t_littleBuf );

                t_littleBuf = t_buf.Mid( t_iEnd );
                a_instArray[ t_nInstances ].max = _ttoi( t_littleBuf );
            }

			t_nInstances++;
		}
    }

    return t_nInstances;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::PutInstance
 *
 *  DESCRIPTION : Write changed or new instance
 *
 *  INPUTS      : a_pInst to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :	Separate OS compile versions
					For win95, this won't work at all.  Apparently w95 can only
 *					have one page file.  The min, max, and name are all stored
 *					in system.ini.
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT PageFileSetting::PutInstance( const CInstance &a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT t_hRet = WBEM_S_NO_ERROR;

	DWORD	t_dwCount = 0;
    DWORD   t_x = 0;
	DWORD	t_dwTemp = 0;

	PageFileSettingInstance t_instArray [26];
	CHString t_sName;

	bool t_bFoundIt = false;

	//  Free space variables
	DWORD t_dwSectorsPerCluster;
	DWORD t_dwBytesPerSector;
	DWORD t_dwFreeClusters;
	DWORD t_dwTotalClusters;
   	unsigned __int64 t_ullTotalFreeBytes = 0;

	// Get the values we are supposed to write in
	a_pInst.GetCHString( IDS_Name, t_sName );

	CHString t_chsRoot = t_sName.Left( 3 );

	// no higher that the amount of free space on this disk
	if( GetDiskFreeSpace(	t_chsRoot,
							&t_dwSectorsPerCluster,
							&t_dwBytesPerSector,
							&t_dwFreeClusters,
							&t_dwTotalClusters ) )
   {
		t_ullTotalFreeBytes = (unsigned __int64)
							t_dwSectorsPerCluster *
							t_dwBytesPerSector *
							t_dwFreeClusters;

		// back to megabytes
		t_ullTotalFreeBytes = t_ullTotalFreeBytes >> 20;
	}


   // Read the page file array
   t_dwCount = GetPageFileInstances( t_instArray );

   // Check if the name is indeeed "pagefile.sys"
   if ( -1 == t_sName.Find( _T("pagefile.sys") ) )
   {
	   return WBEM_E_UNSUPPORTED_PUT_EXTENSION;
   }

	// Find if it is already there, and update the structure
	for ( t_x = 0; t_x < t_dwCount; t_x++ )
	{
      // Is this the guy?
      CHString chstrSingleBackslashes;
      RemoveDoubleBackslashes(t_sName, chstrSingleBackslashes);

      if ( 0 == _tcsicmp( t_instArray[t_x].name, t_sName ) ||
           0 == chstrSingleBackslashes.CompareNoCase(t_instArray[t_x].name))
	  {
         if ( a_lFlags & WBEM_FLAG_CREATE_ONLY )
		 {
            t_hRet = WBEM_E_ALREADY_EXISTS;
         }
		 else
		 {
            // Did they give us a value?
            if ( !a_pInst.IsNull( IDS_MaximumSize ) )
			{
				// Check for value in range
				t_dwTemp = (DWORD) t_ullTotalFreeBytes;

                // BUG 403159: (UI does this as well - see 
                // \\index2\sdnt\shell\cpls\system\virtual.c
                // This code is stolen from there, essentially.
                //
                // Be sure to include the size of any existing pagefile.
                // Because this space can be reused for a new paging file,
                // it is effectively "disk free space" as well.  The
                // FindFirstFile api is safe to use, even if the pagefile
                // is in use, because it does not need to open the file
                // to get its size.
                //

                WIN32_FIND_DATA ffd;
                SmartFindClose hFind;
                DWORD dwSpaceExistingPagefile = 0;
                if((hFind = FindFirstFile(t_sName, &ffd)) !=
                    INVALID_HANDLE_VALUE)
                {
                    dwSpaceExistingPagefile = (INT)ffd.nFileSizeLow;
                    // convert to megs:
                    dwSpaceExistingPagefile = dwSpaceExistingPagefile >> 20;
                }
                t_ullTotalFreeBytes += dwSpaceExistingPagefile;

                // END 403159 fix. 


				a_pInst.GetDWORD( IDS_MaximumSize, t_dwTemp );

			   if( t_ullTotalFreeBytes < t_dwTemp ||
                   4095 < t_dwTemp )  // WINDOWS RAID 243309 FIX
			   {
					t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                    t_bFoundIt = true;
					break;
			   }
               t_instArray[t_x].max = t_dwTemp;
            }

            // Did they give us a value?
            if ( !a_pInst.IsNull( IDS_InitialSize ) )
			{
				// Check for value in range
				t_dwTemp = 0;
				a_pInst.GetDWORD( IDS_InitialSize, t_dwTemp );
				
                if(!(t_instArray[t_x].max == 0 && t_dwTemp == 0))
                {
                    if(t_dwTemp < 2)
                    {
                        t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
                        t_bFoundIt = true;
					    break;
                    }
                }
                t_instArray[t_x].min = t_dwTemp;
            }

            // Check the basic
            if ( t_instArray[t_x].min > t_instArray[t_x].max )
			{
               t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
            }

			t_bFoundIt = true;
            break;
         }
      }
   }

   // We didn't find it.  Let's make a new one.
   if ( !t_bFoundIt)
   {
       if (a_lFlags & WBEM_FLAG_UPDATE_ONLY)
       {
           t_hRet = WBEM_E_NOT_FOUND;
       }
       else
       {
           t_instArray[ t_dwCount ].name = t_sName;
        
           // Did they give us a value?
           if ( !a_pInst.IsNull( IDS_InitialSize ) )
	       {
               // Check for value in range
               a_pInst.GetDWORD( IDS_InitialSize, t_dwTemp );
		       t_instArray[t_dwCount].min = t_dwTemp;
           } 

           // Did they give us a value?
           if ( !a_pInst.IsNull( IDS_MaximumSize ) )
	       {
               // Check for value in range
               a_pInst.GetDWORD( IDS_MaximumSize, t_dwTemp );
		       t_instArray[ t_dwCount ].max = t_dwTemp;
           }

           if(!(t_instArray[t_dwCount].min == 0 && 
                t_instArray[t_dwCount].max == 0))
           {
               // Check for basic errors
               if(t_instArray[t_dwCount].min < 2)
               {
                   t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
               }
               if(t_ullTotalFreeBytes < t_instArray[ t_dwCount ].max &&
                   SUCCEEDED(t_hRet))
		       {
		           t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
		       }
               if ( t_instArray[ t_dwCount ].min > t_instArray[ t_dwCount ].max &&
                   SUCCEEDED(t_hRet))
	           {
                   t_hRet = WBEM_E_VALUE_OUT_OF_RANGE;
               }
           }

           if(SUCCEEDED(t_hRet))
           {
               t_dwCount++;
           }

           // Note: there is one special case where we
           // can not make a new one on the fly, and
           // have to set the registry only, and let
           // the changes go into effect on bootup:
           // This is when 0 and 0 have been specified
           // for Initialsize and Maximum size, which
           // is a combination used to signal the os to
           // figure out on its own what initial and
           // maximum sizes to use.  The os performs
           // this on reboot.  Therefore, we will skip
           // the call to CreatePageFile, which
           // will result in our going next to the
           // update registry portion below.

           if(!(t_instArray[t_dwCount-1].min == 0 && 
                t_instArray[t_dwCount-1].max == 0))
           {
               if(SUCCEEDED(t_hRet))
               {
                   LARGE_INTEGER liMin;
                   LARGE_INTEGER liMax;

                   liMin.QuadPart = t_instArray[t_dwCount-1].min;
                   liMax.QuadPart = t_instArray[t_dwCount-1].max;

                   t_hRet = CreatePageFile(
                      t_sName,
                      liMin,
                      liMax,
                      a_pInst);
               }
           }
       }
    }

    // Update the registry
    if ( WBEM_S_NO_ERROR == t_hRet )
    {
        t_hRet = PutPageFileInstances( t_instArray, t_dwCount );
    }

    return t_hRet;
}
#endif

#ifdef WIN9XONLY
HRESULT PageFileSetting::PutInstance(const CInstance &a_pInst, long a_lFlags /*= 0L*/)
{
	return WBEM_E_FAILED;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : PageFileSetting::PutPageFileInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : PageFileInstanceArray a_instArray, DWORD a_dwCount
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	returns actual number found - NT ONLY
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT PageFileSetting::PutPageFileInstances(PageFileInstanceArray a_instArray, DWORD a_dwCount )
{
	CRegistry t_Reg ;
	CHString t_sFiles;
	TCHAR t_szBuff[MAXITOA];
	HRESULT t_hResult = WBEM_E_FAILED;

	HRESULT t_Res = t_Reg.Open( HKEY_LOCAL_MACHINE, PAGEFILE_REGISTRY_KEY, KEY_READ | KEY_WRITE );

	if( ERROR_SUCCESS == t_Res )
	{
	  // Build up the string.  Each entry is \0 terminated.
	  t_sFiles.Empty();

	  for ( int t_x = 0; t_x < a_dwCount; t_x++ )
	  {
		 t_sFiles += a_instArray[ t_x ].name;
		 t_sFiles += _T(' ');
		 t_sFiles += _itot( a_instArray[ t_x ].min, t_szBuff, 10 );
		 t_sFiles += _T(' ');
		 t_sFiles += _itot( a_instArray[ t_x ].max, t_szBuff, 10 );
		 t_sFiles += _T('\0');
	  }

	  // The end is indicated with \0\0.
	  t_sFiles += _T('\0');

		// Write the value
		if ((t_Res = RegSetValueEx( t_Reg.GethKey(),
								  PAGING_FILES,
								  0,
								  REG_MULTI_SZ,
								  (const unsigned char *)(LPCTSTR) t_sFiles,
								  t_sFiles.GetLength() * sizeof(TCHAR) )) == ERROR_SUCCESS )
		{
			t_hResult = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(t_Res) && (t_Res == ERROR_ACCESS_DENIED))
	{
		t_hResult = WBEM_E_ACCESS_DENIED;
	}

	return t_hResult;
}
#endif

////////////////////////////////////////////////////////////////////////
//
//	Function:	DeleteInstance
//
//	CIMOM wants us to delete this instance.
//
//	Inputs:
//
//	Outputs:
//
//	Return:
//
//	Comments: Separate OS compile versions
//
////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT PageFileSetting::DeleteInstance(const CInstance &a_pInst, long a_lFlags /*= 0L*/)
{
   DWORD t_dwCount,
		 t_x;
   CHString t_sName;
   bool t_bFoundIt;
   HRESULT t_hRet;
   PageFileSettingInstance t_instArray [ 26 ] ;

   // Fill the pagefile array
   t_dwCount = GetPageFileInstances( t_instArray );

   // Get the name
   a_pInst.GetCHString( IDS_Name, t_sName );

   t_bFoundIt = false;

   // Walk the array looking for it
   for ( t_x = 0; t_x < t_dwCount; t_x++ )
   {
      // This one?
      if ( _tcsicmp( t_instArray[ t_x ].name, t_sName ) == 0 )
	  {
         // Yup
         t_bFoundIt = true;

         // Move the rest down over this one
         for (int t_y = t_x; t_y < t_dwCount - 1; t_y++ )
		 {
			t_instArray[ t_y ].name	= t_instArray[ t_y + 1].name;
			t_instArray[ t_y ].min	= t_instArray[ t_y + 1].min;
			t_instArray[ t_y ].max	= t_instArray[ t_y + 1].max;
		}

         // The array is now one shorter
         t_dwCount--;
         break;
      }
   }

   if ( t_bFoundIt )
   {
      // If we found it, update the registry
      t_hRet = PutPageFileInstances( t_instArray, t_dwCount );
   }
   else
   {
      t_hRet = WBEM_E_NOT_FOUND;
   }

   return t_hRet;
}
#endif

#ifdef WIN9XONLY
HRESULT PageFileSetting::DeleteInstance(const CInstance &a_pInst, long a_lFlags /*= 0L*/)
{
    return WBEM_E_NOT_FOUND;
}
#endif

//
void PageFileSetting::NameToSettingID( CHString &a_chsName, CHString &a_chsSettingID )
{
	if ( !a_chsName.IsEmpty() )
	{
		// e.g. "pagefile.sys @ D:"
		a_chsSettingID  = a_chsName.Mid( 3 ) ;
		a_chsSettingID += _T( " @ " ) ;
		a_chsSettingID += a_chsName.Left( 2 ) ;
	}
	else
	{
		a_chsSettingID = _T( "" ) ;
	}
}

//
void PageFileSetting::NameToCaption( CHString &a_chsName, CHString &a_chsCaption )
{
	if ( !a_chsName.IsEmpty() )
	{
		// e.g. "D:\ 'pagefile.sys'"
		a_chsCaption =  a_chsName.Left( 3 ) ;
		a_chsCaption += _T( " '" ) ;
		a_chsCaption += a_chsName.Mid( 3 ) ;
		a_chsCaption += _T( "'" ) ;
	}
	else
	{
		a_chsCaption = _T( "" ) ;
	}
}

//
void PageFileSetting::NameToDescription( CHString &a_chsName, CHString &a_chsDescription )
{
	// e.g. "'pagefile.sys' @  D:\"
	if ( !a_chsName.IsEmpty() )
	{
		a_chsDescription =  _T( "'" ) ;
		a_chsDescription += a_chsName.Mid( 3 ) ;
		a_chsDescription += _T( "' @ " ) ;
		a_chsDescription += a_chsName.Left( 3 ) ;
	}
	else
	{
		a_chsDescription = _T( "" ) ;
	}
}

PageFileSettingInstance :: PageFileSettingInstance(void)
{
	min = max = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pagefileusage.h ===
//=================================================================

//

// PageFileUsage.h -- PageFile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================




// Property set identification
//============================

#define  PROPSET_NAME_PAGEFILE L"Win32_PageFileUsage"

#define PAGEFILE_REGISTRY_KEY L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
#define PAGING_FILES          L"PagingFiles"
#define TEMP_PAGEFILE	      L"TempPageFile"







class CCIMDataFile;


// corresponds to info found in NT registry
class PageFileUsageInstance
{
public:

	CHString chsName;
	UINT     TotalSize;
	UINT     TotalInUse;
	UINT	 PeakInUse;
	BOOL	 bTempFile;

public:

	PageFileUsageInstance() ;
	
};

// twenty six possible drive letters, twenty six possible page files...
#define PageFileInstanceArray PageFileUsageInstance *

class PageFileUsage : public Provider 
{

	private:

		HRESULT GetPageFileData( 
            CInstance *a_pInst, 
            bool a_fValidate, 
            DWORD dwReqProps);

		HRESULT GetAllPageFileData( 
            MethodContext *a_pMethodContext,
            DWORD dwReqProps);

		// NT only
		DWORD	GetPageFileInstances( PageFileInstanceArray a_instArray );
        void SetInstallDate(CInstance *a_pInst);
		BOOL GetTempPageFile ( BOOL &bTempPageFile  );
        DWORD DetermineReqProps(
                CFrameworkQuery& pQuery,
                DWORD* pdwReqProps);

        HRESULT GetFileBasedName(
            CHString& chstrDeviceStyleName,
            CHString& chstrDriveStyleName);



	protected:
		

    public:
        // Constructor/destructor
        //=======================
        PageFileUsage(LPCWSTR name, LPCWSTR pszNamespace ) ;
       ~PageFileUsage() ;

		// Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_pInst = 0L);
		virtual HRESULT GetObject(CInstance *a_pInst, long a_lFlags, CFrameworkQuery& pQuery);
        HRESULT ExecQuery(
            MethodContext* pMethodContext, 
            CFrameworkQuery& pQuery, 
            long lFlags /*= 0L*/ );

} ;



#if 0 // ndef _SYSTEM_PAGEFILE_INFORMATION	// DEVL currently wraps this struct
	typedef struct _SYSTEM_PAGEFILE_INFORMATION {
		ULONG NextEntryOffset;
		ULONG TotalSize;
		ULONG TotalInUse;
		ULONG PeakUsage;
		UNICODE_STRING PageFileName;
	} SYSTEM_PAGEFILE_INFORMATION, *PSYSTEM_PAGEFILE_INFORMATION;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pagefileusage.cpp ===
//=================================================================

//

// PageFileUsage.CPP --PageFile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/23/97    a-hhance       converted to optimized framework
//				 03/01/99    a-peterc       Rewritten with parts split off to PageFileCfg.cpp
//
//=================================================================

// All these nt routines are needed to support the NtQuerySystemInformation
// call.  They must come before FWCommon et all or else it won't compile.
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <io.h>
#include <WinPerf.h>
#include <cregcls.h>

#include <ProvExce.h>

#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"

#include "PageFileUsage.h"
#include <tchar.h>

#include "computersystem.h"

#include "DllWrapperBase.h"
#include "NtDllApi.h"

#include "cfgmgrdevice.h"


const WCHAR *IDS_TempPageFile  = L"TempPageFile";

// declaration of our static instance
//=========================

PageFileUsage MyPageFileSet(PROPSET_NAME_PAGEFILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::PageFileUsage
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

PageFileUsage::PageFileUsage(LPCWSTR name, LPCWSTR pszNamespace)
: Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::~PageFileUsage
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

PageFileUsage::~PageFileUsage()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : CInstance *a_pInst, long a_lFlags
 *
 *  OUTPUTS     : CInstance *a_pInst
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT PageFileUsage::GetObject(CInstance *a_pInst, long a_lFlags, CFrameworkQuery& pQuery)
{
	// calls the OS specific compiled version
    DWORD dwReqProps = 0L;
    DetermineReqProps(pQuery, &dwReqProps);
	return GetPageFileData( a_pInst, true, dwReqProps ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::EnumerateInstances
 *
 *  DESCRIPTION : Creates property set instances
 *
 *  INPUTS      : MethodContext*  a_pMethodContext, long a_lFlags
 *
 *  OUTPUTS     : MethodContext*  a_pMethodContext
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT PageFileUsage::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	// calls the OS specific compiled version
	return GetAllPageFileData( a_pMethodContext, PROP_ALL_SPECIAL );
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::ExecQuery
 *
 *  DESCRIPTION : Creates property set instances
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This implementation of execquery is very basic - it optimizes
 *                only on properties, not on requested instances.  This is 
 *                because there will never be many instances, but some properties
 *                (such as InstallDate) can be fairly expensive to obtain.
 *
 *****************************************************************************/

HRESULT PageFileUsage::ExecQuery(
    MethodContext* pMethodContext, 
    CFrameworkQuery& pQuery, 
    long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD dwReqProps = 0L;
    DetermineReqProps(pQuery, &dwReqProps);

    hr = GetAllPageFileData( pMethodContext, dwReqProps );

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::GetPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance *a_pInst
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFileUsage::GetPageFileData( 
    CInstance *a_pInst,  
    bool a_fValidate,
    DWORD dwReqProps)
{
	HRESULT t_hRes = WBEM_E_NOT_FOUND;

    // NT page file name is in registry
    //=================================
	PageFileUsageInstance t_files [ 26 ] ;

   	DWORD t_nInstances = GetPageFileInstances( t_files );

	CHString t_name;
	a_pInst->GetCHString( IDS_Name, t_name );

	for ( DWORD t_i = 0; t_i < t_nInstances; t_i++ )
	{
		if ( 0 == t_name.CompareNoCase ( t_files[t_i].chsName ) )
		{
            a_pInst->SetDWORD ( IDS_AllocatedBaseSize,	(DWORD)t_files[t_i].TotalSize);
		    a_pInst->SetDWORD ( IDS_CurrentUsage,		(DWORD)t_files[t_i].TotalInUse);
			a_pInst->SetDWORD ( IDS_PeakUsage,			(DWORD)t_files[t_i].PeakInUse);
            a_pInst->SetCHString(IDS_Description, t_name);
            a_pInst->SetCHString(IDS_Caption, t_name);

			if ( ( t_files[t_i].bTempFile == 0 ) || ( t_files[t_i].bTempFile == 1 ) )
			{
				a_pInst->Setbool(IDS_TempPageFile, t_files[t_i].bTempFile);
			}

            if(dwReqProps & PROP_INSTALL_DATE)
            {
                SetInstallDate(a_pInst);
            }

			t_hRes = WBEM_S_NO_ERROR;
		}
	}

	return t_hRes;
}
#endif

#ifdef WIN9XONLY
HRESULT PageFileUsage::GetPageFileData( 
    CInstance *a_pInst,  
    bool a_fValidate, 
    DWORD dwReqProps)
{
    TCHAR t_szTemp[_MAX_PATH] ;
    CHString t_chstrCurrentName;
    DEVIOCTL_REGISTERS t_reg ;
	MEMORYSTATUS t_MemoryStatus;


	// We have to drill for the page file name in Win95
	//=================================================
	memset( &t_reg, '\0', sizeof(DEVIOCTL_REGISTERS) );

	t_reg.reg_EAX     = 0x440D ;          // IOCTL for block devices
	t_reg.reg_ECX     = 0x486e ;          // Get Swap file name
	t_reg.reg_EDX     = (DWORD_PTR) t_szTemp ;  // receives media identifier information

	if( VWIN32IOCTL( &t_reg, VWIN32_DIOC_DOS_IOCTL) )
	{
		// If szTemp is empty at this point, we don't have a pagefile,
		// so get the ... out of dodge.
		if( _tcslen( t_szTemp ) != 0 )
		{
			if(a_fValidate)
            {
                a_pInst->GetCHString( IDS_Name, t_chstrCurrentName );
                if( t_chstrCurrentName.CompareNoCase( CHString( t_szTemp ) ) != 0 )
			    {
				    return WBEM_E_NOT_FOUND;
			    } //otherwise, the one we have is ok (no need for 'else')
            }
            else
            {
                a_pInst->SetCharSplat( IDS_Name, t_szTemp ) ;
            }
		}
		else
		{
			return WBEM_E_NOT_FOUND;
		}
	}
	else
	{
		return WBEM_E_NOT_FOUND;
	}

	t_MemoryStatus.dwLength = sizeof( MEMORYSTATUS ) ;
	GlobalMemoryStatus( &t_MemoryStatus ) ;

	DWORD t_dwCurrentUsage = t_MemoryStatus.dwTotalPageFile - t_MemoryStatus.dwAvailPageFile ;

	a_pInst->SetDWORD( IDS_AllocatedBaseSize, t_MemoryStatus.dwTotalPageFile >> 20 );
	a_pInst->SetDWORD( IDS_CurrentUsage,      t_dwCurrentUsage >> 20 ) ;

    a_pInst->SetCHString(IDS_Description, t_szTemp);
    a_pInst->SetCHString(IDS_Caption, t_szTemp);
    
    if(dwReqProps & PROP_INSTALL_DATE)
    {
        SetInstallDate(a_pInst);
    }

	return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PageFileUsage::GetAllPageFileData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext *a_pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :	Win9x and NT compiled version
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PageFileUsage::GetAllPageFileData( 
    MethodContext *a_pMethodContext,
    DWORD dwReqProps)
{
	HRESULT		t_hResult	 = WBEM_S_NO_ERROR;
	DWORD		t_nInstances = 0;
	CInstancePtr t_pInst;
	PageFileUsageInstance t_files [ 26 ] ;

	// NT page file name is in registry
	//=================================
	t_nInstances = GetPageFileInstances( t_files );

	for (DWORD t_dw = 0; t_dw < t_nInstances && SUCCEEDED( t_hResult ); t_dw++ )
	{
		t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );

		t_pInst->SetCHString( IDS_Name,				t_files[t_dw].chsName );

        
		    t_pInst->SetDWORD(	  IDS_AllocatedBaseSize,t_files[t_dw].TotalSize );
		    t_pInst->SetDWORD(	  IDS_CurrentUsage,		t_files[t_dw].TotalInUse );
		    t_pInst->SetDWORD(	  IDS_PeakUsage,		t_files[t_dw].PeakInUse );

            t_pInst->SetCHString(IDS_Description, t_files[t_dw].chsName);
            t_pInst->SetCHString(IDS_Caption, t_files[t_dw].chsName);
		    if ( ( t_files[t_dw].bTempFile == 0 ) || ( t_files[t_dw].bTempFile == 1 ) )
		    {
			    t_pInst->Setbool(IDS_TempPageFile, t_files[t_dw].bTempFile);
		    }

            if(dwReqProps & PROP_INSTALL_DATE)
            {
                SetInstallDate(t_pInst);
            }

		    t_hResult = t_pInst->Commit(  ) ;
        
	}

	return t_hResult;
}
#endif

#ifdef WIN9XONLY
HRESULT PageFileUsage::GetAllPageFileData( 
    MethodContext *a_pMethodContext,
    DWORD dwReqProps)
{
	HRESULT		t_hResult	= WBEM_S_NO_ERROR;
	CInstancePtr t_pInst;

	t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );

	t_hResult = GetPageFileData( t_pInst, false, dwReqProps ) ;

	if( SUCCEEDED( t_hResult ) )
	{
		t_hResult = t_pInst->Commit( ) ;
	}

	return t_hResult;
}
#endif


// returns actual number found - NT ONLY!
#ifdef NTONLY
DWORD PageFileUsage::GetPageFileInstances( PageFileInstanceArray a_instArray )
{
   	NTSTATUS	t_Status ;
    UCHAR		t_ucGenericBuffer[0x1000] ;
	DWORD		t_nInstances = 0 ;
	CNtDllApi   *t_pNtDll = NULL ;

	BOOL bTempPageFile;

 
	try
	{
		t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
        if(t_pNtDll != NULL)
        {

			ULONG t_uLength = 0L ;
			SYSTEM_PAGEFILE_INFORMATION *t_pSPFI = (SYSTEM_PAGEFILE_INFORMATION*) t_ucGenericBuffer ;

			// Nt system query call
			t_Status = t_pNtDll->NtQuerySystemInformation(	SystemPageFileInformation,
															t_pSPFI,
															sizeof( t_ucGenericBuffer ),
															&t_uLength ) ;

			if ( NT_SUCCESS( t_Status ) && t_uLength )
			{
				SYSTEM_INFO t_SysInfo ;
				GetSystemInfo( &t_SysInfo ) ;

				for( ; ; )
				{
					CHString t_chsName ;

					// copy over the UNICODE_STRING
					LPTSTR  t_pBuffer = t_chsName.GetBuffer( t_pSPFI->PageFileName.Length + 4 ) ;

					memset( t_pBuffer,	'\0', t_pSPFI->PageFileName.Length + 4) ;
					memcpy( t_pBuffer, t_pSPFI->PageFileName.Buffer, t_pSPFI->PageFileName.Length ) ;

					t_chsName.ReleaseBuffer() ;

					// strip off the "\??\"
					if( -1 != t_chsName.Find( _T("\\??\\") ) )
					{
						t_chsName = t_chsName.Mid( 4 ) ;
					}

					if(t_chsName.Find(L":") == -1)
                    {
                        CHString chstrFileBasedName;
                        GetFileBasedName(t_chsName, chstrFileBasedName);
                        t_chsName = chstrFileBasedName;
                    }

                    a_instArray[ t_nInstances ].chsName = t_chsName ;

					// In megabytes, but watch out for the overflow
					unsigned __int64 t_ullTotalSize  = t_pSPFI->TotalSize  * t_SysInfo.dwPageSize ;
					unsigned __int64 t_ullTotalInUse = t_pSPFI->TotalInUse * t_SysInfo.dwPageSize ;
					unsigned __int64 t_ullPeakUsage  = t_pSPFI->PeakUsage  * t_SysInfo.dwPageSize ;

					a_instArray[ t_nInstances ].TotalSize  = (UINT)( t_ullTotalSize  >> 20 ) ;
					a_instArray[ t_nInstances ].TotalInUse = (UINT)( t_ullTotalInUse >> 20 ) ;
					a_instArray[ t_nInstances ].PeakInUse  = (UINT)( t_ullPeakUsage  >> 20 ) ;

					if ( GetTempPageFile ( bTempPageFile  ) )
					{
						a_instArray [ t_nInstances ].bTempFile = bTempPageFile;
					}

					t_nInstances++ ;

					if ( !t_pSPFI->NextEntryOffset )
					{
						break;
					}

					// and bump
					t_pSPFI = (SYSTEM_PAGEFILE_INFORMATION*)((PCHAR) t_pSPFI + t_pSPFI->NextEntryOffset ) ;
				}
			}
  		}

	}
	catch( ... )
	{
		if( t_pNtDll )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
		}

		throw ;
	}

	CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
    t_pNtDll = NULL;

	return t_nInstances;
}
#endif



void PageFileUsage::SetInstallDate(CInstance *a_pInst)
{
    if(a_pInst != NULL)
    {
        CHString chstrFilename;

        a_pInst->GetCHString(IDS_Name, chstrFilename);
        if(chstrFilename.GetLength() > 0)
        {
            MethodContext *pMethodContext = NULL;

            if((pMethodContext = a_pInst->GetMethodContext()) != NULL)
            {
                CInstancePtr clfInst;
                CHString chstrDblBkSlshFN;
                CHString chstrQuery;

                EscapeBackslashes(chstrFilename, chstrDblBkSlshFN);
                TRefPointerCollection<CInstance> pPagefileCollection;

                chstrQuery.Format(
                    L"SELECT InstallDate FROM Cim_Datafile WHERE Name =\"%s\"", 
                    (LPCWSTR)chstrDblBkSlshFN);

                if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(
                    (LPCWSTR)chstrQuery,
                    &pPagefileCollection,
                    pMethodContext,
                    GetNamespace())))
                {
                    REFPTRCOLLECTION_POSITION pos;
                    CInstancePtr pPageFileInst;
                    if(pPagefileCollection.BeginEnum(pos))
                    {
                        pPageFileInst.Attach(pPagefileCollection.GetNext(pos));
                        if(pPageFileInst != NULL)
                        {
                            CHString chstrTimeStr;

                            pPageFileInst->GetCHString(IDS_InstallDate, chstrTimeStr);
                            if(chstrTimeStr.GetLength() > 0)
                            {
                                a_pInst->SetCHString(IDS_InstallDate, chstrTimeStr);
                            }
                        }
                        pPagefileCollection.EndEnum();
                    }
                }
            }
        }
    }
}

#if NTONLY
BOOL PageFileUsage :: GetTempPageFile (
			
	BOOL &bTempPageFile 
)
{
	DWORD dwTemp;
	CRegistry RegInfo;
	BOOL bRetVal = FALSE;

	DWORD t_Status = RegInfo.Open (

		HKEY_LOCAL_MACHINE,
		PAGEFILE_REGISTRY_KEY,
		KEY_READ
	) ;

	if ( t_Status == ERROR_SUCCESS)
	{
		if(RegInfo.GetCurrentKeyValue(TEMP_PAGEFILE, dwTemp) == ERROR_SUCCESS)
		{
			if ( dwTemp )
			{
				bTempPageFile = 1;
			}
			else
			{
				bTempPageFile = 0;
			}

			bRetVal = TRUE;
		}
		else
		{
			// Value is set to 2 if the TempPageFile Doesnt exist in the registry and then this property should remain NULL
			bTempPageFile = 2;
		}
	}


	return bRetVal;
}
#endif



DWORD PageFileUsage::DetermineReqProps(
    CFrameworkQuery& pQuery,
    DWORD* pdwReqProps)
{
    DWORD dwRet = 0L;
    if(pdwReqProps)
    {
        if(pQuery.IsPropertyRequired(IDS_InstallDate))
        {
            dwRet |= PROP_INSTALL_DATE;
        }

        *pdwReqProps = dwRet;
    }
    return dwRet;
}



PageFileUsageInstance::PageFileUsageInstance()
{
	TotalSize = TotalInUse = PeakInUse = 0 ;
	bTempFile = 2;
}


HRESULT PageFileUsage::GetFileBasedName(
    CHString& chstrDeviceStyleName,
    CHString& chstrDriveStyleName)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrName;
    CHString chstrDriveBasedName;
    CHString chstrDeviceName;
    LPWSTR wstrDosDeviceNameList = NULL;
    
    chstrDeviceName = chstrDeviceStyleName.Left(
        chstrDeviceStyleName.ReverseFind(L'\\'));

    if(QueryDosDeviceNames(wstrDosDeviceNameList))
	{
        if(FindDosDeviceName(
            wstrDosDeviceNameList, 
            chstrDeviceName, 
            chstrDriveBasedName , 
            TRUE ) )
	    {
		    chstrDriveBasedName += L"\\pagefile.sys";
            chstrDriveStyleName = chstrDriveBasedName;   
	    }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\parallelport.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  parallelport.h
//
//  Purpose: Parallel port interface property set provider
//
//***************************************************************************

// Property set identification
//============================

#define	PROPSET_NAME_PARPORT	L"Win32_ParallelPort"

#define MAX_PARALLEL_PORTS  9           // As per Win32 spec LPT1-9 supported directly

#include "confgmgr.h"

typedef std::map<CHString, DWORD> STRING2DWORD;

// Property set identification
//============================

class CWin32ParallelPort : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32ParallelPort(LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32ParallelPort() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

        BOOL LoadPropertyValues( DWORD dwIndex, CInstance* pInstance ) ;
		BOOL LoadPropertyValuesFromStrings(CHString sName, LPCTSTR szValue, CInstance* pInstance );


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pcmcia.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  PCMCIA.h
//
//  Purpose: PCMCIA Controller property set provider
//
//***************************************************************************

// Property set identification
//============================

#define	PROPSET_NAME_PCMCIA	L"Win32_PCMCIAController"

class CWin32PCMCIA : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PCMCIA( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32PCMCIA() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

    private:

        // Utility function(s)
        //====================

        HRESULT LoadPropertyValues( CInstance* pInstance, CConfigMgrDevice *pDevice ) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pcmcia.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  PCMCIA.cpp
//
//  Purpose: PCMCIA Controller property set provider
//
// Note: On nt, it would also be possible to read the ControllerType
//       TupleCrc, Identifier, DeviceFunctionId, CardInSocket, and
//       CardEnabled properties by using DeviceIOCtl on the PCMCIAx
//       device.  An example of this is shown in pcm.cpp (in this
//       same project.
//
//***************************************************************************

#include "precomp.h"

#include "PCMCIA.h"

// Property set declaration
//=========================

CWin32PCMCIA MyPCMCIAController ( PROPSET_NAME_PCMCIA , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PCMCIA::CWin32PCMCIA
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PCMCIA :: CWin32PCMCIA (

	LPCWSTR strName,
	LPCWSTR pszNamespace

) : Provider ( strName , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PCMCIA::~CWin32PCMCIA
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32PCMCIA::~CWin32PCMCIA()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32PCMCIA::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32PCMCIA :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND ;

    CHString sDeviceID;
    pInstance->GetCHString ( IDS_DeviceID , sDeviceID );

    // Let's see if config manager recognizes this device at all

    CConfigManager cfgmgr ;
    CConfigMgrDevice *pDevice = NULL ;

    if( cfgmgr.LocateDevice ( sDeviceID , &pDevice ) )
    {
        // Ok, it knows about it.  Is it a PCMCIA device?

        // On nt4, we key off the service name, for all others, it's the class name.

#ifdef NTONLY

        if ( IsWinNT4 () )
        {
            CHString sService ;

            if ( pDevice->GetService ( sService ) && sService.CompareNoCase ( L"PCMCIA") == 0 )
            {
                hr = LoadPropertyValues ( pInstance , pDevice ) ;
            }
        }
        else
#endif
        {
            if ( pDevice->IsClass ( L"PCMCIA" ) )
            {
                // Yup, it must be one of ours.

                hr = LoadPropertyValues ( pInstance , pDevice ) ;
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32PCMCIA::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32PCMCIA :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_FAILED;

    CConfigManager cfgManager;

    CDeviceCollection deviceList;

    BOOL bRet ;

    // On nt4, we key off the service name, for all others, it's the class name.  The class
    // name on nt4 is 'Unknown.'
#ifdef NTONLY
    if ( IsWinNT4 () )
    {
        bRet = cfgManager.GetDeviceListFilterByService ( deviceList, L"PCMCIA" ) ;
    }
    else
#endif
    {
        bRet = cfgManager.GetDeviceListFilterByClass ( deviceList, L"PCMCIA" ) ;
    }

    // While it might be more performant to use FilterByGuid, it appears that at least some
    // 95 boxes will report PCMCIA info if we do it this way.

    if ( bRet )
    {
        REFPTR_POSITION pos;

        if ( deviceList.BeginEnum( pos ) )
        {
            hr = WBEM_S_NO_ERROR;

            // Walk the list

			CConfigMgrDevicePtr pDevice;
            for (pDevice.Attach(deviceList.GetNext ( pos ) );
                 SUCCEEDED( hr ) && (pDevice != NULL);
                 pDevice.Attach(deviceList.GetNext ( pos ) ))
            {
				CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
				if ( ( hr = LoadPropertyValues( pInstance, pDevice ) ) == WBEM_S_NO_ERROR )
				{
					hr = pInstance->Commit(  );
				}
            }

            // Always call EndEnum().  For all Beginnings, there must be an End

            deviceList.EndEnum();
        }
    }

    return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PCMCIA::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PCMCIA::LoadPropertyValues (

	CInstance *pInstance,
	CConfigMgrDevice *pDevice
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    SetConfigMgrProperties ( pDevice, pInstance ) ;

    // Set the status based on the config manager error code

    CHString t_sStatus;
	if ( pDevice->GetStatus ( t_sStatus ) )
	{
		pInstance->SetCHString ( IDS_Status , t_sStatus ) ;
	}

    // Use the PNPDeviceID for the DeviceID (key)

    CHString sTemp ;
    pInstance->GetCHString ( IDS_PNPDeviceID, sTemp ) ;

    pInstance->SetCHString ( IDS_DeviceID , sTemp ) ;

    pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
    pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;

    SetCreationClassName ( pInstance ) ;

	CHString sDesc ;
    if ( pDevice->GetDeviceDesc ( sDesc ) )
    {
        pInstance->SetCHString ( IDS_Description , sDesc ) ;
    }

    // Use the friendly name for caption and name

    if ( pDevice->GetFriendlyName ( sTemp ) )
    {
        pInstance->SetCHString ( IDS_Caption , sTemp ) ;
        pInstance->SetCHString ( IDS_Name , sTemp ) ;
    }
    else
    {
        // If we can't get the name, settle for the description
        pInstance->SetCHString(IDS_Caption, sDesc);
        pInstance->SetCHString(IDS_Name, sDesc);
    }

    if ( pDevice->GetMfg ( sTemp ) )
    {
        pInstance->SetCHString ( IDS_Manufacturer , sTemp ) ;
    }

    // Fixed value from enumerated list
    pInstance->SetWBEMINT16 ( IDS_ProtocolSupported , 15 ) ;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\parallelport.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  parallelport.cpp
//
//  Purpose: Parallel port interface property set provider
//
//***************************************************************************

#include "precomp.h"
#include <cregcls.h>
#include "parallelport.h"

#include <profilestringimpl.h>

// Property set declaration
//=========================

CWin32ParallelPort win32ParallelPort ( PROPSET_NAME_PARPORT , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::CWin32ParallelPort
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32ParallelPort :: CWin32ParallelPort (

	LPCWSTR strName,
	LPCWSTR pszNamespace

) : Provider ( strName , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::~CWin32ParallelPort
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32ParallelPort :: ~CWin32ParallelPort ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::~CWin32ParallelPort
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

HRESULT CWin32ParallelPort::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	CHString chsDeviceID ;
	pInstance->GetCHString ( IDS_DeviceID , chsDeviceID ) ;
	CHString chsIndex = chsDeviceID.Right ( 1 ) ;
	WCHAR *szIndex = chsIndex.GetBuffer(0);

	DWORD dwIndex = _wtol(szIndex);
    BOOL bRetCode = LoadPropertyValues( dwIndex, pInstance ) ;

    //=====================================================
    //  Make sure we got the one we want
    //=====================================================

	CHString chsNewDeviceID;
   	pInstance->GetCHString ( IDS_DeviceID , chsNewDeviceID ) ;

    if ( chsNewDeviceID.CompareNoCase ( chsDeviceID ) != 0 )
	{
        bRetCode = FALSE ;
    }

	if ( ! bRetCode )
	{
		CHString chsKeyCheck = chsDeviceID.Left ( 3 ) ;
		if ( chsKeyCheck.CompareNoCase ( L"LPT" ) == 0 )
		{
			TCHAR szBuff[_MAX_PATH + 1];
			chsDeviceID += _T(':');
			DWORD dwBuffsz = WMIRegistry_ProfileString (

				_T("Ports"),
				TOBSTRT(chsDeviceID),
				_T("__!!DEFAULT!!__"),
				szBuff,
				_MAX_PATH + 1
			);

			if ( ( dwBuffsz < (_MAX_PATH + 1) ) && ( _tcscmp(_T("__!!DEFAULT!!__"), szBuff ) != 0 ) )
			{
				bRetCode = LoadPropertyValuesFromStrings (

					chsDeviceID,
					szBuff,
					pInstance
				);
			}
		}
	}

    return ( bRetCode ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND );

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::~CWin32ParallelPort
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

HRESULT CWin32ParallelPort :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT	hr = WBEM_S_NO_ERROR ;

	//Map of instances

	STRING2DWORD	instMap;

	// Try to create instances for each possible parallel port or
	// until we encounter an error condition.

	for ( DWORD dwIndex = 1; ( dwIndex <= MAX_PARALLEL_PORTS ) && ( WBEM_S_NO_ERROR == hr ) ; dwIndex++ )
	{
		// Get a new instance pointer if we need one.

		CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
		if ( NULL != pInstance )
		{
			// If we load the values, something's out there Mulder, so
			// Commit it, invalidating the Instance pointer, in which
			// case if we NULL it out, the above code will get us a
			// new one if it runs again.  Otherwise, we'll just reuse
			// the instance pointer we're holding onto.  This will
			// keep us from allocating and releasing memory each iteration
			// of this for loop.

			CHString key( _T("LPT") ) ;

			if ( LoadPropertyValues ( dwIndex, pInstance ) )
			{
				hr = pInstance->Commit (  );

				TCHAR szBuffer [ 20 ] ;
				_ultot ( dwIndex , szBuffer , 10 ) ;
				key += szBuffer ;
				key.MakeUpper () ;

				instMap [ key ] = 0 ;
			}
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
    }

	//now check for win.ini (or registry entries)...
	//==============================================

	DWORD dwRet = 0 ;

	TCHAR *szBuff = new TCHAR [ 1024 ] ;
	if ( szBuff )
	{
		try
		{
			DWORD dwBuffSz = 1024 ;

			DWORD dwRet = WMIRegistry_ProfileSection ( _T("Ports") , szBuff, dwBuffSz ) ;

			while ( szBuff && ( dwRet == dwBuffSz - 2) )
			{
                if (szBuff)
                {
				    delete [] szBuff ;
                    szBuff = NULL;
                }

				dwBuffSz += 1024;

				szBuff = new TCHAR [ dwBuffSz ] ;
				if ( szBuff )
				{
					dwRet = WMIRegistry_ProfileSection ( _T("Ports"), szBuff, dwBuffSz ) ;
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
		}
		catch ( ... )
		{
            if (szBuff)
            {
			    delete [] szBuff ;
                szBuff = NULL;
            }

			throw ;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	if ( szBuff )
	{
		try
		{
			//Parse and process each entry...
			DWORD dwIndex = 0;

			while (dwIndex < dwRet)
			{
				//ignore leading space...
				while ( (dwIndex < dwRet) && ((szBuff[dwIndex] == _T(' ')) || (szBuff[dwIndex] == _T('\t'))) )
				{
					dwIndex++;
				}

				//ignore comment lines...
				if ( szBuff [ dwIndex ] == _T(';') )
				{
					while ( ( dwIndex < dwRet ) && ( szBuff [ dwIndex ] != _T('\0')) )
					{
						dwIndex ++ ;
					}
				}
				else
				{
					//handle key/value pair
					DWORD dwName = dwIndex ;

					while ( ( dwIndex < dwRet ) && ( szBuff [ dwIndex ] != _T('=')) && ( szBuff [ dwIndex ] != _T('\0') ) )
					{
						dwIndex ++ ;
					}

					if ( ( dwIndex >= dwRet ) || ( szBuff [ dwIndex ] == _T('\0') ) )
					{
						//skip to the next entry if there is one...
						continue ;
					}

					if ( szBuff [ dwIndex - 1] != _T(':'))
					{
						dwName = dwIndex - 1;
					}

					//should be LPTn:=...
					szBuff [ dwIndex - 1 ] = _T('\0');
					szBuff [ dwIndex ++ ] = _T('\0');

					DWORD dwValue = dwIndex;

					//if name is not in our map try and create an instance
					//=====================================================

					if (szBuff[dwName] != _T('\0'))
					{
						CHString key ( & szBuff [ dwName ] ) ;
						key.MakeUpper () ;

						if ( instMap.find ( key ) == instMap.end () )
						{
							//it wasn't in the map...
							//however we don't want to try this name again....

							instMap [ key ] = 0;

							DWORD dwPort = 0xFFFFFFFF ;

							//test the value name for a LPT port
							if ( 0 == _tcsnicmp ( & ( szBuff [ dwName ] ) , _T("LPT") , 3 ) )
							{
								TCHAR *szNum = & szBuff [ dwName ] ;
								for ( int i = 0; i < 3 ; i++ )
								{
									szNum = _tcsinc(szNum);
									if ( *szNum == _T('\0') )
									{
										szNum = NULL;
										break;
									}
								}

								if (szNum && *szNum != _T('\0') )
								{
									dwPort = _ttoi(szNum ) ;
									TCHAR szNumBuff[20];
									_itot ( dwPort , szNumBuff , 10 ) ;

									if ( 0 != _tcscmp( szNum , szNumBuff ) )
									{
										dwPort = 0xFFFFFFFF ;
									}
								}
							}

							if ( dwPort != 0xFFFFFFFF )
							{
								//generate a new instance...
								CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false);
								if ( NULL != pInstance )
								{
									if ( LoadPropertyValuesFromStrings ( &szBuff [ dwName ] , & szBuff [ dwValue ], pInstance ) )
									{
										hr = pInstance->Commit (  );
									}
								}
							}
						}
					}

					//set the index to the end of the value...
					while ( szBuff [ dwIndex ] != _T('\0') )
					{
						dwIndex++;
					}
				}

				//currently points to a null so set to next char

				if ( ( dwIndex < dwRet ) )
				{
					dwIndex ++ ;

					if ( ( dwIndex < dwRet ) && ( szBuff [ dwIndex ] == _T('\0') ) )
					{
						//double null, can leave early!
						break;
					}
				}
			}
		}
		catch ( ... )
		{
            if (szBuff)
            {
		        delete [] szBuff ;
                szBuff = NULL;
            }

			throw ;
		}

        if (szBuff)
        {
		    delete [] szBuff ;
            szBuff = NULL;
        }
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties according to passed index
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if port was found & properties loaded, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32ParallelPort :: LoadPropertyValues ( DWORD dwIndex, CInstance *pInstance )
{
    WCHAR szTemp[_MAX_PATH] ;
	swprintf(szTemp, L"LPT%d", dwIndex) ;

	// Use these to get the PNP Device ID
    CConfigManager cfgmgr;

	BOOL fRet = FALSE ;

#ifdef NTONLY

    if (IsWinNT4()) // if NT4
    {

#ifdef PROVIDER_INSTRUMENTATION

        MethodContext *pMethodContext = pInstance->GetMethodContext();
        pMethodContext->pStopWatch->Start(StopWatch::AtomicTimer);

#endif

// NT 4, this is the PARALLEL service.  We will only have one device

	    CDeviceCollection devlist;
		if ( cfgmgr.GetDeviceListFilterByService ( devlist, _T("Parport") ) )
		{
			CConfigMgrDevicePtr pDevice(devlist.GetAt ( 0 ), false) ;

#ifdef PROVIDER_INSTRUMENTATION

            pMethodContext->pStopWatch->Start(StopWatch::ProviderTimer);

#endif

			if ( pDevice )
			{
				// Set the device Status

				CHString chstrTemp ;
				if ( pDevice->GetStatus ( chstrTemp ) )
				{
					pInstance->SetCHString ( IDS_Status , chstrTemp ) ;
				}

				SetConfigMgrProperties ( pDevice , pInstance ) ;
			}
		}

        SmartCloseHandle hPortHandle = CreateFile (

			szTemp,
			GENERIC_READ,
			0,
			NULL,
			OPEN_EXISTING,
			0,
			NULL
		) ;

        if ( hPortHandle == INVALID_HANDLE_VALUE)
	    {
            // ACCESS_DENIED means the device exists, but we can't get anything else

		    if ( GetLastError () == ERROR_ACCESS_DENIED)
		    {
                fRet = TRUE ;
            }
            else
            {
                // otherwise, doesn't exist

                fRet = FALSE ;
            }
        }
        else
        {
		  // having made smartpointer closehandle is not required
          // CloseHandle ( hPortHandle ) ;
           fRet = TRUE ;
        }
    }
	else
#endif
	{
        // If we are still here, we have Win9x or NT5, so do the following:
        // Run a check using config manager for the port:

#ifdef WIN9XONLY
        {
		    CDeviceCollection devlist;
	        if ( cfgmgr.GetDeviceListFilterByClass ( devlist, L"Ports"))
	        {
		        REFPTR_POSITION pos;

		        if ( devlist.BeginEnum ( pos ) )
		        {
					CHString cshPort ;
                    CRegistry RegInfo;
                    CHString sKeyName;

			        CConfigMgrDevicePtr pDevice;
                    for (pDevice.Attach(devlist.GetNext ( pos ) );
                         (pDevice != NULL) && (fRet == FALSE);
                         pDevice.Attach(devlist.GetNext ( pos ) ))
			        {
                        pDevice->GetRegistryKeyName(sKeyName);

                        DWORD dwRet = RegInfo.Open(HKEY_LOCAL_MACHINE, sKeyName, KEY_QUERY_VALUE);
                        if (dwRet == ERROR_SUCCESS)
                        {
                            dwRet = RegInfo.GetCurrentKeyValue(L"PORTNAME", cshPort);
                        }

                        if ((dwRet == ERROR_SUCCESS) && ( cshPort.CompareNoCase ( szTemp ) == 0 ))
						{
							SetConfigMgrProperties ( pDevice , pInstance ) ;
							fRet = TRUE ;
						}
			        }

			        devlist.EndEnum();
		        }
	        }
        }
#endif

#ifdef NTONLY
        // should be nt5 at this point
        {
            // Good 'ol NT5 just has to be different.  Here is the scenario:
            // Examine HKLM\\HARDWARE\\DEVICEMAP\\PARALLEL PORTS\\ for the key(s) \\Device\\ParallelX,
            // where X is a number.  Scan through all such keys.  One of them should
            // contain a string data value the last part of which match szTemp
            // (e.g., the data will be "\\DosDevices\\LPT1").
            // Now, for whichever value's data yielded a match with szTemp, retain the value
            // of X for that value.
            // Then look at HKLM\\SYSTEM\\CurrentControlSet\\Services\\Parallel\\Enum
            // This key will contain keys with a numeric name, like 0 or 1.  These numeric
            // names correspond with the X value we retained above.  The data for that value
            // is the PNPDeviceID, which is what we are after. The end.

            DWORD dw = -1 ;

            CRegistry reg ;

            if ( reg.Open ( HKEY_LOCAL_MACHINE , _T("HARDWARE\\DEVICEMAP\\PARALLEL PORTS") , KEY_READ ) == ERROR_SUCCESS )
            {
                BOOL fContinue = TRUE;

                for ( dw = 0 ; fContinue; dw ++ )
                {
					TCHAR *pchValueName = NULL ;
					unsigned char* puchValueData = NULL ;

                    if ( reg.EnumerateAndGetValues ( dw , pchValueName , puchValueData ) == ERROR_NO_MORE_ITEMS )
                    {
                        fContinue = FALSE;
                    }

                    if ( pchValueName && puchValueData )
                    {
						try
						{
                            // Want to compare the data of the value with szTemp

                            CHString chstrValueData = (TCHAR *) puchValueData ;
                            if ( chstrValueData.Find ( szTemp ) != -1 )
                            {
                                // OK, this is the one we want. Quit looking.
                                fContinue = FALSE;
                                dw--;  // it's going to get incremented when we break out of the loop
                            }
						}
						catch ( ... )
						{
							delete [] pchValueName ;
							delete [] puchValueData ;

							throw ;
						}

                        delete [] pchValueName ;
						delete [] puchValueData ;
                    }
                }
            }

            // If dw != -1 here, we found the correct key name for the next step.

            if ( dw != -1 )
            {
                reg.Close () ;

                CHString chstrValueName ;
                chstrValueName.Format ( _T("%d") , dw ) ;

                CHString chstrPNPDeviceID ;
				DWORD dwRet = reg.OpenLocalMachineKeyAndReadValue (

					_T("SYSTEM\\CurrentControlSet\\Services\\Parport\\Enum") ,
					chstrValueName,
					chstrPNPDeviceID
				) ;

                if ( dwRet == ERROR_SUCCESS )
                {
                    CConfigMgrDevicePtr pDevice;

#ifdef PROVIDER_INSTRUMENTATION

      MethodContext *pMethodContext = pInstance->GetMethodContext();
      pMethodContext->pStopWatch->Start(StopWatch::AtomicTimer);

#endif
                    if ( cfgmgr.LocateDevice ( chstrPNPDeviceID , &pDevice ) )
                    {
						SetConfigMgrProperties ( pDevice , pInstance ) ;

#ifdef PROVIDER_INSTRUMENTATION

                        pMethodContext->pStopWatch->Start(StopWatch::ProviderTimer);

#endif
						fRet = TRUE ;
                    }
                }
            }
        }
#endif
    }

    // Only set these if we got back something good.

    if ( fRet )
    {
	    pInstance->SetWBEMINT16 ( IDS_Availability , 3 ) ;

	    pInstance->SetCHString ( IDS_Name , szTemp ) ;

	    pInstance->SetCHString ( IDS_DeviceID , szTemp ) ;

	    pInstance->SetCHString ( IDS_Caption , szTemp ) ;

	    pInstance->SetCHString ( IDS_Description , szTemp ) ;

	    SetCreationClassName ( pInstance ) ;

	    pInstance->Setbool ( IDS_PowerManagementSupported , FALSE ) ;

	    pInstance->SetCharSplat ( IDS_SystemCreationClassName , _T("Win32_ComputerSystem") ) ;

	    pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName() ) ;

        pInstance->SetWBEMINT16 ( IDS_ProtocolSupported , 17 ) ;

	    pInstance->Setbool ( IDS_OSAutoDiscovered , TRUE ) ;
    }

	return fRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ParallelPort::CWin32ParallelPort
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

BOOL CWin32ParallelPort :: LoadPropertyValuesFromStrings (

	CHString sName ,
	const TCHAR *szValue ,
	CInstance *pInstance
)
{
	// Scrape off the ':' if there's one on the end.

    if (sName[sName.GetLength() - 1] == ':')
	{
        sName = sName.Left ( sName.GetLength () - 1) ;
	}

    pInstance->SetCHString ( IDS_Name , sName ) ;

	pInstance->SetCHString ( IDS_DeviceID , sName ) ;

	pInstance->SetCHString ( IDS_Caption , sName ) ;

	pInstance->SetCHString ( IDS_Description , sName ) ;

	SetCreationClassName ( pInstance ) ;

	pInstance->SetCharSplat ( IDS_SystemCreationClassName , _T("Win32_ComputerSystem") ) ;

	pInstance->SetCHString ( IDS_SystemName, GetLocalComputerName() ) ;

    pInstance->SetWBEMINT16 ( IDS_ProtocolSupported , 17 ) ;

	pInstance->Setbool ( IDS_OSAutoDiscovered , FALSE ) ;

	//set the availability to unknown...

	pInstance->SetWBEMINT16 ( IDS_Availability , 2 ) ;

	//current implementation ignores the szValue
	//because the status of the comp port is unknown

	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pnpentity.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  PNPEntity.cpp
//
//  Purpose: PNPEntity Controller property set provider
//
//***************************************************************************

#include "precomp.h"
#include "LPVParams.h"
#include <FRQueryEx.h>
#include <devguid.h>

#include "PNPEntity.h"


// Property set declaration
//=========================

CWin32PNPEntity MyPNPEntityController ( PROPSET_NAME_PNPEntity, IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PNPEntity::CWin32PNPEntity
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PNPEntity::CWin32PNPEntity
(
    LPCWSTR strName,
    LPCWSTR pszNamespace

) : Provider ( strName , pszNamespace )
{

    m_ptrProperties.SetSize(15);

    m_ptrProperties[0] = ((LPVOID) IDS_ConfigManagerErrorCode);
    m_ptrProperties[1] = ((LPVOID) IDS_ConfigManagerUserConfig);
    m_ptrProperties[2] = ((LPVOID) IDS_Status);
    m_ptrProperties[3] = ((LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[4] = ((LPVOID) IDS_DeviceID);
    m_ptrProperties[5] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[7] = ((LPVOID) IDS_Description);
    m_ptrProperties[8] = ((LPVOID) IDS_Caption);
    m_ptrProperties[9] = ((LPVOID) IDS_Name);
    m_ptrProperties[10] = ((LPVOID) IDS_Manufacturer);
    m_ptrProperties[11] = ((LPVOID) IDS_ClassGuid);
    m_ptrProperties[12] = ((LPVOID) IDS_Service);
    m_ptrProperties[13] = ((LPVOID) IDS_CreationClassName);
    m_ptrProperties[14] = ((LPVOID) IDS_PurposeDescription);

    // This is needed since NT5 doesn't always populate the Class
    // property.  Rather than converting the GUID each call, we do
    // it once and store it.

    WCHAR *pGuid = m_GuidLegacy.GetBuffer(128);
	try
	{
		StringFromGUID2 ( GUID_DEVCLASS_LEGACYDRIVER , pGuid , 128 ) ;
	}
	catch ( ... )
	{
		m_GuidLegacy.ReleaseBuffer ();

		throw ;
	}

	m_GuidLegacy.ReleaseBuffer ();

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PNPEntity::~CWin32PNPEntity
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32PNPEntity :: ~CWin32PNPEntity ()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32PNPEntity::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32PNPEntity::GetObject
(
    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND ;
    CConfigManager cfgmgr;

    // Let's see if config manager recognizes this device at all
    CHString sDeviceID;
    pInstance->GetCHString(IDS_DeviceID, sDeviceID);

    CConfigMgrDevicePtr pDevice;
    if ( cfgmgr.LocateDevice ( sDeviceID , & pDevice ) )
    {
		// Ok, it knows about it.  Is it a PNPEntity device?
		if ( IsOneOfMe ( pDevice ) )
		{
			// Yup, it must be one of ours.  See what properties are being requested.
            CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

            DWORD dwProperties;
            pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

			hr = LoadPropertyValues ( &CLPVParams ( pInstance , pDevice , dwProperties ) ) ;
		}
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32PNPEntity::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32PNPEntity::ExecQuery (

    MethodContext* pMethodContext,
    CFrameworkQuery &pQuery,
    long lFlags
)
{
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    return Enumerate ( pMethodContext, lFlags, dwProperties);
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32PNPEntity::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32PNPEntity::EnumerateInstances
(
    MethodContext* pMethodContext,
    long lFlags /*= 0L*/
)
{
    return Enumerate(pMethodContext, lFlags, PNP_ALL_PROPS);
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32PNPEntity::Enumerate
(
    MethodContext* pMethodContext,
    long lFlags, DWORD dwReqProps
)
{
    HRESULT hr = WBEM_E_FAILED;

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    if ( cfgManager.GetDeviceList ( deviceList ) )
    {
        REFPTR_POSITION pos;

        if ( deviceList.BeginEnum ( pos ) )
        {
            hr = WBEM_S_NO_ERROR;

            // Walk the list

            CConfigMgrDevicePtr pDevice;
            for (pDevice.Attach(deviceList.GetNext ( pos ));
                 SUCCEEDED(hr) && (pDevice != NULL);
                 pDevice.Attach(deviceList.GetNext ( pos )))
            {
				if ( IsOneOfMe ( pDevice ) )
				{
					CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
					if( SUCCEEDED ( hr = LoadPropertyValues ( &CLPVParams( pInstance , pDevice, dwReqProps))))
					{
						if ( ShouldBaseCommit ( NULL ) )
						{
							hr = pInstance->Commit();
						}
					}
				}
            }
            // Always call EndEnum().  For all Beginnings, there must be an End

            deviceList.EndEnum();
        }
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PNPEntity::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32PNPEntity::LoadPropertyValues
(
    void* a_pv
)
{
    HRESULT t_hr = WBEM_S_NO_ERROR;
    CHString t_chstrDeviceID, t_chstrDesc, t_chstrTemp;

    /*************************************
    * Unpack and confirm our parameters...
    *************************************/

    CLPVParams* t_pData = (CLPVParams*)a_pv;
    CInstance* t_pInstance = (CInstance*)(t_pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* t_pDevice = (CConfigMgrDevice*)(t_pData->m_pDevice);
    DWORD t_dwReqProps = (DWORD)(t_pData->m_dwReqProps);

    if(t_pInstance == NULL || t_pDevice == NULL)
    {
        return WBEM_E_PROVIDER_FAILURE;
    }


    /***********************
    * Set the key properties
    ***********************/

    t_pDevice->GetDeviceID(t_chstrDeviceID);
    if(t_chstrDeviceID.GetLength() == 0)
    {
        // We need the device id for the key property of this class.  If we can
        // not obtain it, we can't set the key, which is an unacceptable error.
        return WBEM_E_PROVIDER_FAILURE;
    }
    else
    {
        t_pInstance->SetCHString(IDS_DeviceID, t_chstrDeviceID);
    }


    /*************************
    * Set PNPEntity properties
    *************************/

    if(t_dwReqProps & PNP_PROP_Manufacturer)
    {
        if(t_pDevice->GetMfg(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_Manufacturer, t_chstrTemp);
        }
    }

    if(t_dwReqProps & PNP_PROP_ClassGuid)
    {
        if(t_pDevice->GetClassGUID(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_ClassGuid, t_chstrTemp);
        }
    }

    if(t_dwReqProps & PNP_PROP_Service)
    {
        if(t_pDevice->GetService(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_Service, t_chstrTemp);
        }
    }


    /*********************************
    * Set CIM_LogicalDevice properties
    *********************************/

    if(t_dwReqProps & PNP_PROP_PNPDeviceID)
    {
        t_pInstance->SetCHString(IDS_PNPDeviceID, t_chstrDeviceID);
    }
    if(t_dwReqProps & PNP_PROP_SystemCreationClassName)
    {
        t_pInstance->SetCHString(IDS_SystemCreationClassName,
                                 IDS_Win32ComputerSystem);
    }
    if(t_dwReqProps & PNP_PROP_CreationClassName)
    {
        t_pInstance->SetCHString(IDS_CreationClassName,
                                 GetProviderName());
    }
    if(t_dwReqProps & PNP_PROP_SystemName)
    {
        t_pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());
    }
    if ((t_dwReqProps & PNP_PROP_Description) || (t_dwReqProps & PNP_PROP_Caption) || (t_dwReqProps & PNP_PROP_Name))
    {
        if(t_pDevice->GetDeviceDesc(t_chstrDesc))
        {
            t_pInstance->SetCHString(IDS_Description, t_chstrDesc);
        }
    }

    if(t_dwReqProps & PNP_PROP_ConfigManagerErrorCode ||
       t_dwReqProps & PNP_PROP_Status)
    {
        DWORD t_dwStatus = 0L;
        DWORD t_dwProblem = 0L;
        if(t_pDevice->GetStatus(&t_dwStatus, &t_dwProblem))
        {
            if(t_dwReqProps & PNP_PROP_ConfigManagerErrorCode)
            {
                t_pInstance->SetDWORD(IDS_ConfigManagerErrorCode, t_dwProblem);
            }
            if(t_dwReqProps & PNP_PROP_Status)
            {
                CHString t_chsTmp;

				ConfigStatusToCimStatus ( t_dwStatus , t_chsTmp ) ;
                t_pInstance->SetCHString(IDS_Status, t_chsTmp);
            }
        }
    }

    if(t_dwReqProps & PNP_PROP_ConfigManagerUserConfig)
    {
        t_pInstance->SetDWORD(IDS_ConfigManagerUserConfig,
                              t_pDevice->IsUsingForcedConfig());
    }

    // Use the friendly name for caption and name
    if(t_dwReqProps & PNP_PROP_Caption || t_dwReqProps & PNP_PROP_Name)
    {
        if(t_pDevice->GetFriendlyName(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_Caption, t_chstrTemp);
            t_pInstance->SetCHString(IDS_Name, t_chstrTemp);
        }
        else
        {
            // If we can't get the name, settle for the description
            if(t_chstrDesc.GetLength() > 0)
            {
                t_pInstance->SetCHString(IDS_Caption, t_chstrDesc);
                t_pInstance->SetCHString(IDS_Name, t_chstrDesc);
            }
        }
    }
    return t_hr;
}

bool CWin32PNPEntity::IsOneOfMe
(
    void* pv
)
{
    DWORD dwStatus;
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)pv;

    // This logic is what the nt5 device manager uses to
    // hide what it calls 'hidden' devices.  These devices
    // can be viewed by using the View/Show Hidden Devices.

    if (pDevice->GetConfigFlags( dwStatus ) &&          // If we can read the status
        ((dwStatus & DN_NO_SHOW_IN_DM) == 0) &&         // Not marked as hidden

        ( !(pDevice->IsClass(L"Legacy")) )              // Not legacy

        )
    {
        return true;
    }
    else
    {
        // Before we disqualify this device, see if it has any resources.
        CResourceCollection resourceList;

        pDevice->GetResourceList(resourceList);

        return resourceList.GetSize() != 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pointer.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   //

// Pointer.h -- System property set description for WBEM MO          //

//                                                                   //

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   //
// 10/24/95     a-skaja     Prototype                                //
// 10/25/96     jennymc     Updated
// 10/24/97    jennymc     Moved to the new framework
//                                                                   //
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
// Property set identification
///////////////////////////////////////////////////////////////////////
#define PROPSET_NAME_MOUSE L"Win32_PointingDevice"

///////////////////////////////////////////////////////////////////
class CWin32PointingDevice : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32PointingDevice(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32PointingDevice() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);


        // Utility
        //========
    private:
#ifdef NTONLY
        HRESULT GetSystemParameterSectionForNT( LPCTSTR pszServiceName, CRegistry & reg );
        BOOL AssignPortInfoForNT(CHString & chsMousePortInfo,
                                               CRegistry & Reg,
                                               CInstance * pInstance);
        BOOL AssignDriverNameForNT(CHString chsMousePortInfo, CHString &sDriver);
        void AssignHardwareTypeForNT(CInstance * pInstance,
                                  CRegistry& Reg, CHString sDriver);
        HRESULT GetNTInstance( CInstance *pInstance, CConfigMgrDevice *pDevice);
        HRESULT GetNTDriverInfo(CInstance *pInstance, LPCTSTR szService, 
            LPCTSTR szDriver);
		HRESULT GetNT351Instance( CInstance * pInstance, LPCTSTR pszServiceName = NULL );
		HRESULT NT4ArePointingDevicesAvailable( void );
#endif
#ifdef WIN9XONLY
        HRESULT GetWin9XInstance( CInstance * pInstance, LPCWSTR pszDriverName );
#endif
        void GetCommonMouseInfo(CInstance * pInstance);
        bool IsMouseUSB(CHString& chstrTest);
		void SetDeviceInterface(CInstance *pInstance);

        void SetConfigMgrStuff(
            CConfigMgrDevice *pDevice, 
            CInstance *pInstance);
} ;

// Class GUID for Mouse Devices on NT and Win98
#define	MOUSE_CLASS_GUID	L"{4D36E96F-E325-11CE-BFC1-08002BE10318}"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pointer.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  Pointer.CPP -- Win32 provider for pointing devices, eg, mice.

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//  10/16/95     a-skaja     Prototype for demo
//  9/04/96     jennymc     Updated to current standards
//  10/21/96    jennymc     Documentation/Optimization
//  10/24/97    jennymc     Moved to the new framework
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>

#include "Pointer.h"

// Property set declaration
//=========================

CWin32PointingDevice MyCWin32PointingDeviceSet ( PROPSET_NAME_MOUSE , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PointingDevice :: CWin32PointingDevice (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::~CWin32PointingDevice
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32PointingDevice :: ~CWin32PointingDevice ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PointingDevice :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

	CHString strDeviceID ;
	pInstance->GetCHString ( IDS_DeviceID, strDeviceID ) ;

#ifdef NTONLY
	if ( IsWinNT351 () )
	{
		// This function will fail if the strDeviceID value is not the
		// service name of the mouse.

		hr = GetNT351Instance ( pInstance , strDeviceID ) ;
	}
	else if ( ! IsWinNT4 () || SUCCEEDED ( NT4ArePointingDevicesAvailable () ) )
#endif
	{
		// In NT 4, if no pointing devices are plugged into the machine, a key
		// and value pair will be missing from the DEVICEMAP portion of the registry
		// If that is the case, then there are no pointing devices in the machine,
		// although ConfigManager will be more than happy to return confusing and
		// redundant information to us (device ids that will pass the test below,
		// since Config Manager believes them to be valid devices).  So with that
		// in mind, we want to ensure that no mouse instances will be returned.

		CConfigManager configMgr;
		CConfigMgrDevicePtr pDevice;
		if ( configMgr.LocateDevice ( strDeviceID, & pDevice ) )
		{
			CHString strService ;

			// The device had best be a Mouse device, with either a class
			// name of Mouse, or a class GUID of the MOUSE_CLASS_GUID

			if ( ( pDevice->IsClass ( L"Mouse" ) )
				|| ( pDevice->GetService ( strService ) && strService.CompareNoCase ( L"Mouclass" ) == 0 )
				|| ( IsMouseUSB ( strDeviceID ) ) )
			{
				CHString strTemp ;

				// Now we get platform dependent
#ifdef NTONLY
				hr = GetNTInstance ( pInstance , pDevice ) ;
#endif

#ifdef WIN9XONLY
					// On 9X, we need the driver name

				CHString strDriverName;
				if ( pDevice->GetDriver ( strDriverName ) )
				{
					hr = GetWin9XInstance ( pInstance , strDriverName ) ;
				}
#endif
				// Set the device Status

				// Set the device id and shove it into PNPDeviceId
				SetConfigMgrStuff(pDevice, pInstance);

				//set DeviceInterface property
				SetDeviceInterface(pInstance);
			}
		}
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PointingDevice :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_FAILED;

#ifdef NTONLY

	if ( IsWinNT351() )
	{
		// NT 3.51 only supports a single instance

	    CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
		if ( NULL != pInstance )
		{
			hr = GetNT351Instance ( pInstance ) ;
			if ( SUCCEEDED(hr) )
			{
				SetDeviceInterface (pInstance); //we will commit anyway
				hr = pInstance->Commit (  ) ;
			}
		}
		else
		{
			hr = WBEM_E_PROVIDER_FAILURE;
		}

	}
	// sorry 'bout this line - time for a rewrite
	else if ( ! IsWinNT4 () || ( SUCCEEDED ( hr = NT4ArePointingDevicesAvailable () ) ) )
#endif
	{
		// On NT4, we have a place we can look in the registry that will not have
		// a value if no pointing devices are plugged into the machine.  If that happens,
		// the config manager suddenly gets confused about the values it returns
		// and begins giving us back redundant/duplicate information.

		BOOL fGotList = FALSE;

		// Get all devices of class mouse.  This will get multiple devices
		// if there are multiple MICE --- DUH!

		// Saw an NT 5 box with no class for Mouse, but still had the class GUID.  Using
		// Class GUID is probably a better search anyway.  Unfortunately because we have
		// to support Win95, I don't see class GUIDs there, so we'll stick with Mouse for
		// non NT platforms.

		CConfigManager cfgMgr;
		CDeviceCollection deviceList;

#ifdef NTONLY
		{
            // HID USB devices are returned this way, but without any bus information, which causes an enumeration
            // of what devices are on a USB bus to fail.  So we do it the following way:
            // 1) Get all the devices where the class is {4D36E96F-E325-11CE-BFC1-08002BE10318} (MOUSE_CLASS_GUID).  Also get all devices where service is "HidUsb".
            // 2) Go through list of devices returned from "HidUsb", and see if the DeviceId for the device
            //    includes the string HID at the beginning.
            // 3) If one is found (format of string is HID\xxxxxxx\yyyyy), compare xxxxxx to the DeviceID of the
            //    devices returned from enumeration of devices where service is "HidUsb" from step 1 (format of these
            //    entries is similarly USB\zzzzzzz\qqqqq)
            //    a. If xxxxxx == zzzzzzz, then add device zzzzzzz to the vector.
            // 4) If we can't find a matching HID entry, use what we got

            cfgMgr.GetDeviceListFilterByClassGUID ( deviceList , MOUSE_CLASS_GUID ) ;

            // Some NT4 boxes report mice this way...
            if ( ! deviceList.GetSize () )
			{
                cfgMgr.GetDeviceListFilterByService ( deviceList , _T("Mouclass") ) ;
			}

            CDeviceCollection HIDDeviceList;
            cfgMgr.GetDeviceListFilterByService ( HIDDeviceList , _T("HidUsb") ) ;

            REFPTR_POSITION pos = 0;
            if ( deviceList.BeginEnum ( pos ) )
            {
                hr = WBEM_S_NO_ERROR;
                CConfigMgrDevicePtr pMouse;
                for (pMouse.Attach(deviceList.GetNext ( pos ));
                     SUCCEEDED(hr) && (pMouse != NULL);
                     pMouse.Attach(deviceList.GetNext ( pos )))
				{
					CHString chstrPNPDevID ;
					if ( pMouse->GetDeviceID ( chstrPNPDevID ) != NULL )
					{
						CHString chstrPrefix = chstrPNPDevID.Left ( 3 ) ;
						BOOL fGotMatchingHID = FALSE ;
						if ( chstrPrefix == _T("HID") )
						{
							REFPTR_POSITION posHID = 0 ;
							if ( chstrPNPDevID.GetLength () > 4 )
							{
								CHString chstrMiddlePart = chstrPNPDevID.Mid ( 4  );
								LONG m = chstrMiddlePart.ReverseFind ( _T('\\') ) ;
								if ( m != -1 )
								{
									chstrMiddlePart = chstrMiddlePart.Left ( m ) ;

									if ( HIDDeviceList.BeginEnum ( posHID ) )
									{
										CConfigMgrDevicePtr pHID;

                                        for (pHID.Attach(HIDDeviceList.GetNext ( posHID ) );
                                             !fGotMatchingHID && (pHID != NULL);
                                             pHID.Attach(HIDDeviceList.GetNext ( posHID ) ))
										{
											CHString chstrPNPHIDDevID ;
											if ( pHID->GetDeviceID ( chstrPNPHIDDevID ) != NULL )
											{
												if ( chstrPNPHIDDevID.GetLength () > 4 )
												{
													CHString chstrHIDMiddlePart = chstrPNPHIDDevID.Mid ( 4 ) ;
													m = chstrHIDMiddlePart.ReverseFind ( _T('\\') ) ;
													if ( m != -1 )
													{
														chstrHIDMiddlePart = chstrHIDMiddlePart.Left ( m ) ;

														if(chstrHIDMiddlePart.CompareNoCase ( chstrMiddlePart ) == 0 )
														{
															fGotMatchingHID = TRUE ;

															// Set various properties and commit:

															CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
															if ( pInstance != NULL )
															{
																pInstance->SetCHString ( IDS_DeviceID , chstrPNPHIDDevID ) ;

																SetConfigMgrStuff(pHID, pInstance);

																hr = GetNTInstance ( pInstance , pHID ) ;
																if ( SUCCEEDED ( hr ) )
																{
																	SetDeviceInterface (pInstance); //we will commit anyway
																	hr = pInstance->Commit ( ) ;
																}
															}
														}
													}
												}
											}
										}

										HIDDeviceList.EndEnum();
									}
								}
							}
						}

						if ( ! fGotMatchingHID  ) // Use what we got if couldn't find matching HID entry.
						{
							CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
							if ( pInstance != NULL )
							{
								pInstance->SetCHString ( IDS_DeviceID , chstrPNPDevID ) ;

								SetConfigMgrStuff(pMouse, pInstance);

								hr = GetNTInstance ( pInstance , pMouse ) ;

								if ( SUCCEEDED ( hr ) )
								{
									SetDeviceInterface (pInstance); //we will commit anyway
									hr = pInstance->Commit (  ) ;
								}
							}
						}
					}
                }

                deviceList.EndEnum();
            }

		}
#endif
#ifdef WIN9XONLY
		{
			fGotList = cfgMgr.GetDeviceListFilterByClass( deviceList, L"Mouse");
		}
#endif

		if ( fGotList )
		{
			CHString strServiceName ;
			CHString strDriverName;

			REFPTR_POSITION	pos = NULL;

			// Enumerate the devices


			if ( deviceList.BeginEnum ( pos ) )
			{
				CConfigMgrDevicePtr pDevice;

				hr = WBEM_S_NO_ERROR;

                for ( pDevice.Attach(deviceList.GetNext( pos ) );
                      SUCCEEDED(hr) && (pDevice != NULL);
                      pDevice.Attach(deviceList.GetNext( pos ) ))
				{
					// We need the Config Mgr device ID, as it will uniquely identify
					// the mouse on this system.

					CHString strDeviceID ;
					if ( pDevice->GetDeviceID ( strDeviceID ) )
					{
						CInstancePtr pInstance (CreateNewInstance( pMethodContext ), false);
						if ( NULL != pInstance )
						{
							pInstance->SetCHString ( IDS_DeviceID , strDeviceID ) ;

							SetConfigMgrStuff(pDevice, pInstance);

						// Now we get platform dependent
#ifdef NTONLY
							hr = GetNTInstance ( pInstance , pDevice ) ;
#endif

#ifdef WIN9XONLY
						// On 9X, we need the driver name

							if ( pDevice->GetDriver ( strDriverName ) )
							{
								hr = GetWin9XInstance ( pInstance , strDriverName ) ;
							}
#endif

							if ( SUCCEEDED ( hr ) )
							{
								SetDeviceInterface (pInstance); //we will commit anyway
								hr = pInstance->Commit (  ) ;
							}
						}
						else
						{
                            hr = WBEM_E_PROVIDER_FAILURE;
						}

					}
				}

				deviceList.EndEnum () ;

			}	// If BeginEnum


		}	// IF GetDeviceList

	}	// IF !NT3.51

    return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

void CWin32PointingDevice :: GetCommonMouseInfo (

	CInstance *pInstance
)
{
	DWORD dwNumberOfButtons;
	if ( ( dwNumberOfButtons = GetSystemMetrics (SM_CMOUSEBUTTONS)) == 0 )
	{
        //==================================================
        // Mouse not installed so other properties do not
        // make sense
        //==================================================
    }
    else
	{
        //==================================================
        // Mouse Installed
        //==================================================
        //==================================================
        // Check if buttons are swapped
        //==================================================
		if (GetSystemMetrics (SM_SWAPBUTTON))
		{
			pInstance->SetWBEMINT16(IDS_Handedness, 3);
		}
		else
		{
			pInstance->SetWBEMINT16(IDS_Handedness, 2);
		}

        //==================================================
        // Get mouse threshold and speed
        //==================================================

		int aMouseInfo [ 3 ] ;             // array for mouse info.
		if ( SystemParametersInfo ( SPI_GETMOUSE , NULL, & aMouseInfo , NULL ) )
		{
			pInstance->SetDWORD ( IDS_DoubleSpeedThreshold , (DWORD)aMouseInfo [ 0 ] ) ;
			pInstance->SetDWORD ( IDS_QuadSpeedThreshold , (DWORD)aMouseInfo [ 1 ] ) ;
		}
   }

	pInstance->SetDWORD ( IDS_NumberOfButtons, dwNumberOfButtons ) ;

	SetCreationClassName ( pInstance ) ;

	pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

  	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;

	pInstance->Setbool ( IDS_PowerManagementSupported , FALSE ) ;

	// 2 is unknown, since we dont' know if it's a mouse, trackball or whatever.
    pInstance->SetDWORD(L"PointingType", 2);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32PointingDevice::GetWin9XInstance( CInstance *pInstance, LPCWSTR pszDriverName )
{
    HRESULT hr = WBEM_E_FAILED;

	CHString strKey( L"SYSTEM\\CurrentControlSet\\SERVICES\\Class\\" );
	strKey += pszDriverName;

    //=========================================================
    //  Open the registry and init flag that the info is
    //  available if we were successful
    //  Assign the Win95 specific properties
    //=========================================================

    CRegistry Reg;
    CHString chsTmp ;

    if ( Reg.OpenLocalMachineKeyAndReadValue ( strKey, L"DriverDesc", chsTmp ) == ERROR_SUCCESS)
	{
		hr = WBEM_S_NO_ERROR;

        pInstance->SetCHString(IDS_HardwareType, chsTmp);

        if ( Reg.GetCurrentKeyValue( L"InfSection", chsTmp) == ERROR_SUCCESS )
		{
            pInstance->SetCHString ( IDS_InfSection , chsTmp ) ;
        }

        if ( Reg.GetCurrentKeyValue ( L"DriverDesc", chsTmp ) == ERROR_SUCCESS )
		{
			pInstance->SetCHString ( IDS_Description , chsTmp ) ;
			pInstance->SetCHString ( IDS_Name, chsTmp ) ;
			pInstance->SetCHString ( IDS_Caption, chsTmp ) ;
        }

        if ( Reg.GetCurrentKeyValue ( L"InfPath" , chsTmp ) == ERROR_SUCCESS )
		{
            pInstance->SetCHString ( IDS_InfFileName , chsTmp ) ;
        }

        GetCommonMouseInfo ( pInstance ) ;
    }
    return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32PointingDevice :: GetNTInstance (

	CInstance *pInstance,
    CConfigMgrDevice *pDevice
)
{
	CHString strServiceName ;
    if ( ! pDevice->GetService ( strServiceName ) )
	{
        return WBEM_E_NOT_FOUND ;
	}

    // It's OK if we don't have a driver.

	CHString strDriver, strName ;

    pDevice->GetDriver ( strDriver ) ;

    pDevice->GetDeviceDesc(strName);

    pInstance->SetCHString ( IDS_Name , strName ) ;

    pInstance->SetCHString ( IDS_Description , strName ) ;

    pInstance->SetCHString ( IDS_Caption , strName ) ;

    pInstance->SetCHString ( IDS_HardwareType , strName ) ;

    GetNTDriverInfo ( pInstance , strServiceName , strDriver ) ;

    return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32PointingDevice :: GetNTDriverInfo (

	CInstance *pInstance,
    LPCTSTR szService,
	LPCTSTR szDriver
	)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CRegistry Reg ;

	if ( GetSystemParameterSectionForNT ( szService , Reg ) == ERROR_SUCCESS )
	{

	    DWORD dwTmp ;

		if ( Reg.GetCurrentKeyValue ( _T("SampleRate") , dwTmp )  == ERROR_SUCCESS )
		{
			pInstance->SetDWORD (IDS_SampleRate , dwTmp) ;
		}

		if ( Reg.GetCurrentKeyValue(_T("MouseResolution"), dwTmp)  == ERROR_SUCCESS )
		{
			pInstance->SetDWORD ( IDS_Resolution, dwTmp ) ;
		}

		if( Reg.GetCurrentKeyValue(_T("MouseSynchIn100ns"), dwTmp)  == ERROR_SUCCESS )
		{
			pInstance->SetDWORD(IDS_Synch, dwTmp);
		}
	}

    CHString chsMousePortInfo ;
	AssignPortInfoForNT ( chsMousePortInfo, Reg , pInstance ) ;

	if ( szDriver && *szDriver )
    {
        CHString strDriverKey( _T("SYSTEM\\CurrentControlSet\\Control\\Class\\") );
        strDriverKey += szDriver ;

	    if ( Reg.Open ( HKEY_LOCAL_MACHINE , strDriverKey, KEY_READ ) == ERROR_SUCCESS )
        {
			CHString chsTmp ;
		    if ( Reg.GetCurrentKeyValue ( _T("InfPath"), chsTmp) == ERROR_SUCCESS)
		    {
			    pInstance->SetCHString ( IDS_InfFileName, chsTmp ) ;
			    if( Reg.GetCurrentKeyValue ( _T("InfSection") , chsTmp ) == ERROR_SUCCESS )
			    {
			       pInstance->SetCHString ( IDS_InfSection , chsTmp ) ;
			    }
		    }
        }
    }

    GetCommonMouseInfo ( pInstance ) ;

    return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32PointingDevice :: GetNT351Instance (

	CInstance *pInstance,
	LPCTSTR pszServiceName
)
{
	HRESULT hr = WBEM_E_FAILED ;

	CHString	chsMousePortInfo;
	CRegistry	Reg;

	DWORD dwRet = Reg.OpenLocalMachineKeyAndReadValue (

        _T("HARDWARE\\DEVICEMAP\\PointerPort"),
        _T("\\Device\\PointerPort0"),
		chsMousePortInfo
	) ;

	if ( dwRet == ERROR_SUCCESS )
	{
		// NT 3.51, we only support a single instance

		chsMousePortInfo.MakeUpper();

		if ( NULL == pszServiceName || chsMousePortInfo.CompareNoCase ( pszServiceName ) == 0 )
		{
			CHString strService ;

			if ( AssignDriverNameForNT ( chsMousePortInfo , strService ) )
			{
				// DeviceID for NT 3.51 is the Service Name
				pInstance->SetCHString ( IDS_DeviceID , strService ) ;

				// Driver name is hardcoded, preserving behavior of original code
				hr = GetNTDriverInfo(pInstance, strService, _T("{4D36E96F-E325-11CE-BFC1-08002BE10318}\\0000"));

			}	// IF AssignDriverNameForNT

		}	// If keynames match, or supplied value is NULL
		else
		{
			hr = WBEM_E_NOT_FOUND;
		}

	}	// If got value

	return hr;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

// Helper function that looks in the registry for a \Device\PointerPort0
// value in the HKLM\Hardware\DeviceMap\PointerPort key in the registry.  If the value
// exists, then we have mice connected to the machine.  If not, we don't.
// The Config Manager in NT 4 has this habit of returning confusing/redundant
// information regarding mice on the workstation if no mice are plugged in
// at boot time.  This call will only be helpful for NT 4 and maybe 3.51

#ifdef NTONLY
HRESULT CWin32PointingDevice::NT4ArePointingDevicesAvailable ( void )
{
	CHString strTest;
	CRegistry Reg;

	LONG lRet = Reg.OpenLocalMachineKeyAndReadValue (

		_T("HARDWARE\\DEVICEMAP\\PointerPort") ,
        _T("\\Device\\PointerPort0") ,
		strTest
	) ;

	return ( WinErrorToWBEMhResult ( lRet ) ) ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY

HRESULT CWin32PointingDevice :: GetSystemParameterSectionForNT (

	LPCTSTR pszServiceName,
	CRegistry &reg
)
{
    HRESULT hr = WBEM_E_FAILED;

	CHString strKey(L"System\\CurrentControlSet\\Services\\");
	strKey += pszServiceName;
	strKey += L"\\Parameters";

	// This is the service's Parameter section
    //=========================================================================

    hr = reg.Open ( HKEY_LOCAL_MACHINE , strKey, KEY_READ ) ;

    return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CWin32PointingDevice :: AssignPortInfoForNT (

	CHString &chsMousePortInfo,
    CRegistry &Reg,
    CInstance *pInstance
)
{
    BOOL fPortInfoAvailable = FALSE;

	DWORD dwRet = Reg.OpenLocalMachineKeyAndReadValue (

		_T("HARDWARE\\DEVICEMAP\\PointerClass"),
        _T("\\Device\\PointerClass0"),
        chsMousePortInfo
	) ;

	if ( dwRet == ERROR_SUCCESS )
	{
        chsMousePortInfo.MakeUpper() ;
        if ( GetSystemParameterSectionForNT ( chsMousePortInfo , Reg ) )
		{
            fPortInfoAvailable = TRUE;
        }
    }
    else
	{
        fPortInfoAvailable = FALSE;
    }

	return fPortInfoAvailable;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CWin32PointingDevice::AssignDriverNameForNT(CHString chsMousePortInfo, CHString &sDriver)
{
    TCHAR    *pTempPtr;

	// get the values from the
	// Get the Port Driver Name value
	//===============================
	pTempPtr = _tcsstr (chsMousePortInfo, _T("\\SERVICES\\"));
	if (pTempPtr)
    {
		pTempPtr += _tcslen (_T("\\SERVICES\\"));
		sDriver = pTempPtr;
        return TRUE;
	}

    return FALSE;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PointingDevice::CWin32PointingDevice
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

bool CWin32PointingDevice :: IsMouseUSB (

	CHString &chstrTest
)
{
    // Have the device id of the candidate hid device.  Is it a mouse?
    // 1) Obtain the middle portion of the device id (format:  "USB\\middleportion\\xxxx")
    // 2) Get list of devices of class MOUSE_CLASS_GUID
    // 3) For each, compare the middle part of its device id with middleportion
    // 4) If obtain a match, done, return true.

    bool fRet = false;

    if ( chstrTest.GetLength () > 4 )
    {
        CHString chstrTemp = chstrTest.Mid (4);

        LONG m = chstrTemp.ReverseFind ( _T('\\') ) ;
        if ( m != -1 )
        {
            CHString chstrTempMid = chstrTemp.Left ( m ) ;

            CConfigManager cfgMgr ;
            CDeviceCollection deviceList ;

            cfgMgr.GetDeviceListFilterByClassGUID ( deviceList , MOUSE_CLASS_GUID ) ;

            REFPTR_POSITION pos = 0;

            if ( deviceList.BeginEnum ( pos ) )
            {
                CConfigMgrDevicePtr pMouse;

                for (pMouse.Attach(deviceList.GetNext ( pos ) );
                     !fRet && (pMouse != NULL);
                     pMouse.Attach(deviceList.GetNext ( pos ) ))
	            {
					CHString chstrPNPDevID ;
					if ( pMouse->GetDeviceID ( chstrPNPDevID ) != NULL )
					{
						BOOL fGotMatchingHID = FALSE;

						CHString chstrPrefix = chstrPNPDevID.Left(3);
						if(chstrPrefix == _T("HID") )
						{
							if ( chstrPNPDevID.GetLength () > 4 )
							{
								CHString chstrMiddlePart = chstrPNPDevID.Mid(4);
								m = chstrMiddlePart.ReverseFind(_T('\\'));
								if ( m != -1 )
								{
									chstrMiddlePart = chstrMiddlePart.Left(m);
									if( chstrMiddlePart.CompareNoCase ( chstrTempMid ) == 0 )
									{
										fRet = true;
									}
								}
							}
						}
					}
				}

                deviceList.EndEnum();
            }
        }
    }
    return fRet;
}
void CWin32PointingDevice::SetDeviceInterface
											(
												CInstance *pInstance
											)
{
	CHString strDeviceID ;
	pInstance->GetCHString (IDS_DeviceID, strDeviceID);
	if(IsMouseUSB (strDeviceID))
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 162);
		return;
	}
	CHString strDeviceName;
	pInstance->GetCHString(IDS_Name, strDeviceName);
	if(strDeviceName.Find(L"PS/2") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 4);
		return;
	}
	if(strDeviceName.Find(L"Serial") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 3);
		return;
	}
	if(strDeviceName.Find(L"Infrared") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 5);
		return;
	}
	if(strDeviceName.Find(L"HP-HIL") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 6);
		return;
	}
	if(strDeviceName.Find(L"Bus mouse") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 7);
		return;
	}
	if((strDeviceName.Find(L"ADB") != -1) || (strDeviceName.Find(L"Apple") != -1))
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 8);
		return;
	}
	if(strDeviceName.Find(L"DB-9") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 160);
		return;
	}
	if(strDeviceName.Find(L"micro-DIN") != -1)
	{
		pInstance->SetWBEMINT16(IDS_DeviceInterface, 161);
		return;
	}
	//else we did not find any of the above so return unknown
	pInstance->SetWBEMINT16(IDS_DeviceInterface, 1);

	return;
}


void CWin32PointingDevice::SetConfigMgrStuff(
    CConfigMgrDevice *pDevice,
    CInstance *pInstance)
{
    CHString strTemp;

    if (pDevice->GetMfg(strTemp))
	{
	    pInstance->SetCHString(IDS_Manufacturer, strTemp);
	}

	if (pDevice->GetStatus(strTemp))
	{
		pInstance->SetCHString(IDS_Status, strTemp);
	}

	SetConfigMgrProperties(pDevice, pInstance);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\pnpentity.h ===
//=================================================================

//

// PNPEntity.h -- All PNP devices not reported by other cim classes

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/97    Davwoh        Created
//
//=================================================================

#ifndef _PNPEntity_H
#define _PNPEntity_H

// Property set identification
//============================
#define	PROPSET_NAME_PNPEntity	L"Win32_PnPEntity"


#define PNP_ALL_PROPS                    0xFFFFFFFF
#define PNP_KEY_ONLY                     0x00000010
#define PNP_PROP_ConfigManagerErrorCode  0x00000001
#define PNP_PROP_ConfigManagerUserConfig 0x00000002
#define PNP_PROP_Status                  0x00000004
#define PNP_PROP_PNPDeviceID             0x00000008
#define PNP_PROP_DeviceID                0x00000010
#define PNP_PROP_SystemCreationClassName 0x00000020
#define PNP_PROP_SystemName              0x00000040
#define PNP_PROP_Description             0x00000080
#define PNP_PROP_Caption                 0x00000100
#define PNP_PROP_Name                    0x00000200
#define PNP_PROP_Manufacturer            0x00000400
#define PNP_PROP_ClassGuid               0x00000800
#define PNP_PROP_Service                 0x00001000
#define PNP_PROP_CreationClassName       0x00002000
#define PNP_PROP_PurposeDescription      0x00004000


class CWin32PNPEntity : virtual public Provider
{
    private:
        CHPtrArray m_ptrProperties;
        CHString m_GuidLegacy;
        BOOL IsOurs
        (
            CConfigMgrDevice* a_pDevice
        );

    protected:

        virtual bool IsOneOfMe
        (
            void* a_pv
        );

        virtual HRESULT LoadPropertyValues
        (
            void* a_pv
        );

        virtual bool ShouldBaseCommit
        (
            void* a_pvData
        );

        HRESULT Enumerate
        (
            MethodContext* a_pMethodContext, 
            long a_lFlags, 
            DWORD a_dwReqProps
        );

    public:

        // Constructor/destructor
        //=======================

        CWin32PNPEntity
        (
            LPCWSTR a_strName, 
            LPCWSTR a_pszNamespace
        );

        ~CWin32PNPEntity();

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject
        (
            CInstance* a_pInstance, 
            long a_lFlags,
            CFrameworkQuery &pQuery
        );

        virtual HRESULT ExecQuery
        (
            MethodContext* a_pMethodContext, 
            CFrameworkQuery& a_pQuery, 
            long a_Flags = 0L 
        );

        virtual HRESULT EnumerateInstances
        (
            MethodContext* a_pMethodContext, 
            long a_lFlags = 0L
        );
};


// This is the base; it should always commit in the base.
inline bool CWin32PNPEntity::ShouldBaseCommit
(
    void* a_pvData
) 
{ 
    return true; 
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\port.h ===
//=================================================================

//

// Port.h -- Port property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_PORT L"Win32_PortResource"

class CWin32Port ;

class CWin32Port:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32Port(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32Port() ;

        // Funcitons provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    private:

        // Utility function(s)
        //====================

#if NTONLY == 4
        void LoadPropertyValues(LPRESOURCE_DESCRIPTOR pResourceDescriptor, CInstance *pInstance);
#endif
#if defined(WIN9XONLY) || NTONLY == 5
        void LoadPropertyValues(
            DWORD64 dwStart, 
            DWORD64 dwEnd, 
            BOOL bAlias, 
            CInstance *pInstance);
        HRESULT GetWin9XIO(MethodContext*  pMethodContext, CInstance *pSpecificInstance );
#endif

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\power.cpp ===
//=================================================================

//

// Power.cpp -- UPS supply property set provider

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
// 10/18/95     a-skaja     Prototype for demo
// 10/23/97	    a-hhance	integrated with new framework
//
//============================================================

#include "precomp.h"
#include <cregcls.h>

#include "Power.h"
#include "resource.h"

#define UNKNOWN 0
#define BATTERIES_OK 1
#define BATTERY_NEEDS_REPLACING 2

// Property set declaration
//=========================

PowerSupply MyPowerSet ( PROPSET_NAME_POWERSUPPLY , IDS_CimWin32Namespace  );

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::PowerSupply
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

PowerSupply :: PowerSupply (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::~PowerSupply
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

PowerSupply :: ~PowerSupply ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::GetObject
 *
 *  DESCRIPTION : Assigns values to properties in our set
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT PowerSupply :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hRetCode = WBEM_E_FAILED;

	CHString oldKey;
	if ( pInstance->GetCHString ( IDS_DeviceID , oldKey ) )
	{

#ifdef NTONLY

		hRetCode = GetUPSInfoNT ( pInstance ) ;

#endif

#ifdef WIN9XONLY

		hRetCode = GetUPSInfoWin95 ( pInstance ) ;
#endif

		if (SUCCEEDED ( hRetCode ) )
		{
			CHString newKey ;
			pInstance->GetCHString(IDS_DeviceID, newKey);

			if ( newKey.CompareNoCase ( oldKey ) != 0 )
			{
				hRetCode = WBEM_E_NOT_FOUND ;
			}
		}
	}
	else
	{
		hRetCode = WBEM_E_NOT_FOUND ;
	}

    return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of power supplies (1 if successful)
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT PowerSupply :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hRetCode = WBEM_E_FAILED;

	CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

	pInstance->SetCHString ( IDS_DeviceID , IDS_UPSName ) ;

	hRetCode = GetObject ( pInstance ) ;
	if ( SUCCEEDED ( hRetCode ) )
	{
		hRetCode = pInstance->Commit (  ) ;
	}

    return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::GetUPSInfoNT
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if successful
 *
 *  COMMENTS    : This is specific to NT
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT PowerSupply :: GetUPSInfoNT (CInstance *pInstance)
{
   HRESULT hr = WBEM_E_FAILED;

   // Open the service control manager & query UPS service for
   // 'running' status -- if service isn't running, registry data
   // is stale and possibly unreliable.
   //============================================================

	SmartCloseServiceHandle hSCHandle = OpenSCManager (	NULL ,NULL,	SC_MANAGER_ENUMERATE_SERVICE) ;

	if ( hSCHandle != NULL )
	{
		SmartCloseServiceHandle hUPSHandle = OpenService ( hSCHandle , L"UPS", SERVICE_QUERY_STATUS ) ;
		if ( hUPSHandle != NULL )
		{
			SERVICE_STATUS ServiceInfo ;
			if ( QueryServiceStatus ( hUPSHandle, & ServiceInfo  ) )
			{
				if ( ServiceInfo.dwCurrentState == SERVICE_RUNNING )
				{
					hr =  WBEM_S_NO_ERROR ;
				}
			}
        }
	}

	if ( FAILED ( hr ) )
	{
		return WBEM_E_NOT_FOUND ;
	}

   // Assign hard coded property values
   //=====================================================
 	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
    pInstance->SetCHString ( IDS_RemainingCapacityStatus,IDS_Unknown)  ;
    pInstance->Setbool     ( IDS_PowerManagementSupported, (bool)FALSE)  ;
	SetCreationClassName   ( pInstance ) ;

	CRegistry RegInfo ;

    //=====================================================
    //  Get stuff out of:
    //  System\\CurrentControlSet\\Services\\UPS
    //=====================================================
	DWORD dwRet = RegInfo.Open (HKEY_LOCAL_MACHINE,	_T("System\\CurrentControlSet\\Services\\UPS"),	KEY_READ) ;
	if ( dwRet == ERROR_SUCCESS )
	{
		CHString sTemp ;
		DWORD dwTemp ;
		if ( RegInfo.GetCurrentKeyValue ( _T("Options") , dwTemp ) == ERROR_SUCCESS )
		{
			pInstance->Setbool ( IDS_PowerFailSignal   ,   (bool)(dwTemp & UPS_POWER_FAIL_SIGNAL))  ;
			pInstance->Setbool ( IDS_LowBatterySignal  ,   (bool)(dwTemp & UPS_LOW_BATTERY_SIGNAL)) ;
			pInstance->Setbool ( IDS_CanTurnOffRemotely,   (bool)(dwTemp & UPS_CAN_TURN_OFF))       ;

			if ( dwTemp & UPS_COMMAND_FILE && RegInfo.GetCurrentKeyValue(_T("CommandFile"), sTemp) == ERROR_SUCCESS)
			{
	            pInstance->SetCHString(IDS_CommandFile, sTemp) ;
			}
		}

		if( RegInfo.GetCurrentKeyValue(_T("DisplayName"), sTemp) == ERROR_SUCCESS)
		{
			pInstance->SetCHString(IDS_Name, sTemp );
		}

		if( RegInfo.GetCurrentKeyValue(_T("Description"), sTemp) == ERROR_SUCCESS)
		{
			pInstance->SetCHString(IDS_Description, sTemp );
			pInstance->SetCHString(IDS_Caption, sTemp );
		}

		if( RegInfo.GetCurrentKeyValue(_T("Port"), sTemp) == ERROR_SUCCESS)
		{
			pInstance->SetCHString(IDS_UPSPort, sTemp );
		}

		if ( RegInfo.GetCurrentKeyValue ( _T("FirstMessageDelay") , dwTemp ) == ERROR_SUCCESS )
		{
			pInstance->SetDWORD ( IDS_FirstMessageDelay , dwTemp ) ;
		}

		if ( RegInfo.GetCurrentKeyValue ( _T("MessageInterval") , dwTemp ) == ERROR_SUCCESS )
		{
			pInstance->SetDWORD ( IDS_MessageInterval , dwTemp ) ;
		}

		RegInfo.Close () ;

        //=====================================================
        //  Get stuff out of:
        //  System\\CurrentControlSet\\Services\\UPS\\Status
        //=====================================================
        dwRet = RegInfo.Open (HKEY_LOCAL_MACHINE,	_T("System\\CurrentControlSet\\Services\\UPS\\Status"),	KEY_READ) ;
	    if ( dwRet == ERROR_SUCCESS )
	    {
//		    if ( RegInfo.GetCurrentKeyValue ( _T("SerialNumber") , sTemp ) == ERROR_SUCCESS )
//		    {
//  			pInstance->SetCHString(IDS_DeviceID, sTemp );
//    	    }
		    if ( RegInfo.GetCurrentKeyValue ( _T("UtilityPowerStatus") , dwTemp ) == ERROR_SUCCESS )
		    {
			    pInstance->SetWBEMINT16( IDS_Availability , (WBEMINT16) dwTemp ) ;
		    }
		    if ( RegInfo.GetCurrentKeyValue ( _T("BatteryStatus") , dwTemp ) == ERROR_SUCCESS )
		    {
                switch( dwTemp )
                {
                    case UNKNOWN:
        			    pInstance->Setbool( IDS_BatteryInstalled, FALSE) ;
           			    pInstance->SetCHString(IDS_Status, IDS_Unknown );
                        break;

                    case BATTERIES_OK:
        			    pInstance->Setbool( IDS_BatteryInstalled, TRUE) ;
           			    pInstance->SetCHString(IDS_Status, IDS_OK );
                        break;

                    case BATTERY_NEEDS_REPLACING:
        			    pInstance->Setbool( IDS_BatteryInstalled, TRUE) ;
           			    pInstance->SetCHString(IDS_Status, IDS_Degraded );
                        break;
                }
		    }
		    if ( RegInfo.GetCurrentKeyValue ( _T("BatteryCapacity") , dwTemp ) == ERROR_SUCCESS )
		    {
			    pInstance->SetWBEMINT16( IDS_EstimatedChargeRemaining , (WBEMINT16) dwTemp ) ;
		    }
		    if ( RegInfo.GetCurrentKeyValue ( _T("EstimatedRunTime") , dwTemp ) == ERROR_SUCCESS )
		    {
			    pInstance->SetDWORD( IDS_EstimatedRunTime, dwTemp ) ;
		    }
            RegInfo.Close();
	    }
    }
	return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PowerSupply::GetUPSInfoWin95
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if successful
 *
 *  COMMENTS    : 95 doesn't support ups.
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT PowerSupply :: GetUPSInfoWin95 ( CInstance *pInstance )
{
	return WBEM_E_NOT_FOUND ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\precomp.h ===
#pragma message("Precompiling header...")
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "fwcommon.h"
#include "brodcast.h"
#include "dllutils.h"
#include "smartptr.h"
#include "strings.h"
#include "ConfgMgr.h"
#define MAXDWORD MAXULONG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\powermanagement.cpp ===
//=================================================================

//

// PowerManagement.cpp -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "PowerManagement.h"


//=================================================================
//
// CFactoryRouter
//
// provides for registration and instance creation  
//
//
//=================================================================

// Implements a PowerEventProvider
IUnknown * CPowerEventFactory::CreateInstance (

REFIID a_riid ,
LPVOID FAR *a_ppvObject
)
{
	return static_cast<IWbemProviderInit *>(new CPowerManagementEvent) ;
}



//=================================================================
//
// CPowerManagementEvent
//
// provides for eventing of power management events  
//
//
//=================================================================
//

// CWmiProviderInit needs the class name
BSTR CPowerManagementEvent::GetClassName()
{
	return SysAllocString(POWER_EVENT_CLASS);
}


// CWmiEventProvider signals us to begin providing for events
void CPowerManagementEvent::ProvideEvents()
{
	if (!m_bRegistered)
	{
		m_bRegistered = TRUE ;
		CWinMsgEvent::RegisterForMessage( WM_POWERBROADCAST ) ;
	}
}


// CWinMsgEvent signals that a message event has arrived
void CPowerManagementEvent::WinMsgEvent(
			
IN	HWND a_hWnd,
IN	UINT a_message,
IN	WPARAM a_wParam,
IN	LPARAM	a_lParam,
OUT E_ReturnAction &a_eRetAction,
OUT LRESULT &a_lResult
)
{
	switch ( a_message ) 
	{
        case WM_POWERBROADCAST:
		{
			DWORD t_dwPowerEvent = (DWORD) a_wParam ;
			DWORD t_dwData		 = (DWORD) a_lParam ;
				
			switch( t_dwPowerEvent ) 
			{
				case PBT_APMSUSPEND: 
				case PBT_APMRESUMESUSPEND:
				case PBT_APMPOWERSTATUSCHANGE:
				case PBT_APMOEMEVENT:
				case PBT_APMRESUMEAUTOMATIC:			
				{
					HandleEvent( t_dwPowerEvent, t_dwData ) ;
				}	
				break;
				
				case PBT_APMQUERYSUSPEND:
				{
					// indicate we will receive additional messages
					a_eRetAction	= e_ReturnResult ;
					a_lResult		= TRUE ;
					
					break ;
				}

				// default cases			
				case PBT_APMBATTERYLOW:
				case PBT_APMRESUMECRITICAL:
				case PBT_APMQUERYSUSPENDFAILED:
				case PBT_APMQUERYSTANDBYFAILED:
				default:
				{
					break ;
				}
			}
			break ;
		}
	}
}

//
void CPowerManagementEvent::HandleEvent( DWORD a_dwPowerEvent, DWORD a_dwData )
{
	IWbemObjectSinkPtr t_pHandler(CEventProvider::GetHandler(), false);
	IWbemClassObjectPtr t_pClass(CEventProvider::GetClass(), false); 

	if( t_pClass != NULL && t_pHandler != NULL )
	{
    	IWbemClassObjectPtr t_pInst;

		if( SUCCEEDED( t_pClass->SpawnInstance( 0L, &t_pInst ) ) )
		{
			VARIANT t_varEvent ;
			VariantInit( &t_varEvent ) ;

			t_varEvent.vt	= VT_I4 ;
			t_varEvent.lVal = a_dwPowerEvent ;
		
			if ( SUCCEEDED( t_pInst->Put( L"EventType", 0, &t_varEvent, CIM_UINT16 ) ) )
			{
				BOOL t_bCont = TRUE ;

				if ( PBT_APMOEMEVENT == a_dwPowerEvent )
				{
					VARIANT t_varOEMCode ;
					VariantInit( &t_varOEMCode ) ;

					t_varOEMCode.vt	= VT_I4 ;
					t_varOEMCode.lVal = a_dwData ;
				
					if ( !SUCCEEDED( t_pInst->Put( L"OEMEventCode", 0, &t_varEvent, CIM_UINT16 ) ) )
					{
						t_bCont = FALSE ;
					}
					VariantClear ( &t_varOEMCode ) ;
				}

				if ( t_bCont )
				{
                    IWbemClassObject *p2 = t_pInst;
			        t_pHandler->Indicate ( 1, &p2 ) ;
				}
			}
			VariantClear ( &t_varEvent ) ;

		}
	}
}

//
void CPowerManagementEvent::OnFinalRelease()
{
    if (m_bRegistered)
	{
		CWinMsgEvent::UnRegisterMessage( WM_POWERBROADCAST ) ;
	}
	
	delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\port.cpp ===
//=================================================================

//

// Port.CPP --Port property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "CHWRes.h"
#include "Port.h"
#include "ntdevtosvcsearch.h"
#include "configmgrapi.h"

typedef std::map<DWORD, DWORD> DWORD2DWORD;

// Property set declaration
//=========================
CWin32Port MyPortSet(PROPSET_NAME_PORT, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::CWin32Port
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Port::CWin32Port(

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::~CWin32Port
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Port::~CWin32Port()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Port::GetObject(

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hRes;

    // This only has meaning for NT
    //=============================

#if NTONLY == 4

	hRes = WBEM_E_NOT_FOUND;

	// Find the nth instance
	//======================

	unsigned __int64 i64StartingAddress;
	if (pInstance)
	{
		pInstance->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);
	}


	// Create hardware resource list
	//==============================

	CHWResource HardwareResource;
	HardwareResource.CreateSystemResourceLists();

	LPRESOURCE_DESCRIPTOR pResourceDescriptor = HardwareResource._SystemResourceList.PortHead;
	while(pResourceDescriptor != NULL)
	{
        LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

        liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
        liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

		if (liTemp.QuadPart == i64StartingAddress)
		{
			LoadPropertyValues(pResourceDescriptor, pInstance);
			hRes = WBEM_S_NO_ERROR;
			break;
		}

		pResourceDescriptor = pResourceDescriptor->NextSame;
	}

#endif

#if defined(WIN9XONLY) || NTONLY == 5

	hRes = GetWin9XIO(NULL, pInstance);

#endif

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Port::EnumerateInstances(

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // This only has meaning for NT
    //=============================

#if NTONLY == 4

    // Create hardware resource list

    CHWResource HardwareResource;
    HardwareResource.CreateSystemResourceLists();

    // Count how many ports we're going to find.  We need this so
    // we can build an array to keep the ports found so we don't commit
    // the same port more than once. (This problem seems to happen
    // infrequently on NT4.)

    LPRESOURCE_DESCRIPTOR pResourceDescriptor;

	int nFound = 0;

    int nPorts;

    for (nPorts = 0, pResourceDescriptor = HardwareResource.
		 _SystemResourceList.PortHead;
		 pResourceDescriptor != NULL;
         pResourceDescriptor = pResourceDescriptor->NextSame, nPorts++
	)
    {
    }

    // Allocate an array large enough to hold all ports.

    unsigned __int64 *piPortsFound = new unsigned __int64 [ nPorts ];
    if (piPortsFound)
	{
		try
		{
            CInstancePtr pInstance;

			// Traverse list and create instance for each port.
			for (	pResourceDescriptor = HardwareResource._SystemResourceList.PortHead;
					pResourceDescriptor != NULL && SUCCEEDED(hRes);
					pResourceDescriptor = pResourceDescriptor->NextSame
			)
			{

				// Look to see if we already have this port.

                LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

                liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
                liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

				for (int i = 0; i < nFound && liTemp.QuadPart != piPortsFound [ i ]; i++)
				{
				}

				// Skip this port if we already have it.
				//(If we didn't find it, i == nFound.)
				if (i != nFound)
				{
					continue;
				}

				// Keep track of this port so we don't duplicate it later.
				piPortsFound [ nFound++ ] = liTemp.QuadPart;

				pInstance.Attach(CreateNewInstance(pMethodContext));
				LoadPropertyValues(pResourceDescriptor, pInstance);
				hRes = pInstance->Commit();
			}
		}
		catch(...)
		{
			delete [] piPortsFound;

			throw;
		}

		delete [] piPortsFound;
	}
	else
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

#endif

#if defined(WIN9XONLY) || NTONLY == 5

	hRes = GetWin9XIO(pMethodContext,NULL);

#endif

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties according to passed struct
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#if NTONLY == 4
void CWin32Port::LoadPropertyValues(LPRESOURCE_DESCRIPTOR pResourceDescriptor, CInstance *pInstance)
{
	pInstance->SetCharSplat(IDS_Status, IDS_OK);

	WCHAR szTemp[_MAX_PATH];

    LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

    liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
    liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

	pInstance->SetWBEMINT64(IDS_StartingAddress, liTemp.QuadPart);

	pInstance->SetWBEMINT64(IDS_EndingAddress,
        liTemp.QuadPart +
        pResourceDescriptor->CmResourceDescriptor.u.Port.Length - 1);

	swprintf(
		szTemp,
		L"0x%4.4I64lX-0x%4.4I64lX",
		liTemp.QuadPart,
		liTemp.QuadPart +
            pResourceDescriptor->CmResourceDescriptor.u.Port.Length - 1);

	pInstance->SetCharSplat(IDS_Caption, szTemp);
	pInstance->SetCharSplat(IDS_Name, szTemp);
	pInstance->SetCharSplat(IDS_Description, szTemp);

	pInstance->Setbool(IDS_Alias, false);

	SetCreationClassName(pInstance);

	pInstance->SetCHString(IDS_CSName, GetLocalComputerName());

	pInstance->SetCHString(IDS_CSCreationClassName, L"Win32_ComputerSystem");

    return;
}
#endif

#if defined(WIN9XONLY) || NTONLY == 5
void CWin32Port::LoadPropertyValues(
    DWORD64 dwStart,
    DWORD64 dwEnd,
    BOOL bAlias,
    CInstance *pInstance)
{
    WCHAR szTemp[100];

	pInstance->SetCharSplat(IDS_Status, IDS_OK);

    pInstance->SetWBEMINT64(IDS_StartingAddress, dwStart);
	pInstance->SetWBEMINT64(IDS_EndingAddress, dwEnd);
	pInstance->Setbool(L"Alias", bAlias);

#ifdef WIN9XONLY
	swprintf(szTemp, L"0x%04I64X-0x%04I64X", dwStart, dwEnd);
#endif
#ifdef NTONLY
	swprintf(szTemp, L"0x%08I64X-0x%08I64X", dwStart, dwEnd);
#endif

	pInstance->SetCharSplat(IDS_Caption, szTemp);
	pInstance->SetCharSplat(IDS_Name, szTemp);
	pInstance->SetCharSplat(IDS_Description, szTemp);

	SetCreationClassName(pInstance);
	pInstance->SetCharSplat(IDS_CSName, GetLocalComputerName());
	pInstance->SetCharSplat(IDS_CSCreationClassName, L"Win32_ComputerSystem");
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Port::GetWin9XIO
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#if defined(WIN9XONLY) || NTONLY == 5
HRESULT CWin32Port::GetWin9XIO(

	MethodContext *pMethodContext,
	CInstance *pInstance
)
{
	HRESULT          hr = WBEM_E_FAILED;
    unsigned __int64 i64StartingAddress;
    BOOL             bDone = FALSE;

    //=================================================================
    // If we are refreshing a specific instance, get which Address we
    // are going for
    //=================================================================

    if (pInstance)
    {
        pInstance->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);
    }

    //=================================================================
    // Get the latest IO info from the Configuration Manager
    //=================================================================

#ifdef WIN9XONLY
    // This code is only used for 9x because the 9x Cfg Mgr reports all
    // ports it doesn't have information on as 'In use by unknown device'.
    CConfigMgrAPI *pCfgMgr =
                       (CConfigMgrAPI*) CResourceManager::sm_TheResourceManager.
                            GetResource(guidCFGMGRAPI, NULL);

    if (!pCfgMgr)
        return WBEM_E_NOT_FOUND;

    RANGE_LIST rl;

    // Get the list of all ranges currently allocated.
    // As we enum through devices, we'll remove the ranges each is using
    // so that we'll end up with the list of addresses that are allocated
    // but are being used by something not in the list of cfgmgr devices.
    // The code for Device Manager does the exact same thing.
    pCfgMgr->CM_Query_Arbitrator_Free_Data(
        &rl,
        sizeof(RANGE_LIST),
        NULL,
        ResType_IO,
        0);
#endif


    CConfigManager CMgr(ResType_IO);


#ifdef WIN9XONLY
#define MAX_PORT_VALUE  0xFFFF
#endif
#ifdef NTONLY
// TODO: I don't think aliased ports even exist on NT, in which case this
// flag isn't really used.  If we were to find out it is used, we would
// need to add a larger value for NT64.
#define MAX_PORT_VALUE  0xFFFFFFFF
#endif

    if (CMgr.RefreshList())
	{
        DWORD2DWORD mapPorts;

        // Cfg mgr looks OK, so set no error at this point.
        hr = WBEM_S_NO_ERROR;

        for (int i = 0; i < CMgr.GetTotal() && SUCCEEDED(hr) && !bDone; i++)
		{
            //=========================================================
            //  Get the instance to process
            //=========================================================
            IO_INFO *pIO = CMgr.GetIO(i);

            // I've seen Cfg Mgr mess up on W2K and return a starting
            // address of 1 and ending of 0.  Since Device Mgr skips it,
            // we will too.
            if (pIO->StartingAddress > pIO->EndingAddress)
                continue;


			DWORD   dwBegin,
                    dwEnd,
                    dwAdd;
			BOOL    bAlias = FALSE;

            if (pIO->Alias == 0 || pIO->Alias == 0xFF)
			{
			    // This will make us break out of the for loop after the
                // first instance, since this one has no aliases.
                // source.
                dwAdd = 0;
            }
			else
			{
                dwAdd = pIO->Alias * 0x100;
            }

            for (dwBegin = pIO->StartingAddress, dwEnd = pIO->EndingAddress;
                dwEnd <= MAX_PORT_VALUE && SUCCEEDED(hr);
                dwBegin += dwAdd, dwEnd += dwAdd)
			{
#ifdef WIN9XONLY
                // Remove it from the range list.
                pCfgMgr->CM_Delete_Range(dwBegin, dwEnd, rl, 0);
#endif

                // If we're doing EnumInstances...
                if (pMethodContext)
				{
                    // If it's not in the map, add it.
                    if (mapPorts.find(dwBegin) == mapPorts.end())
                    {
                        // It wasn't in the map.
                        // Set it so we don't try this port again.
		    		    mapPorts[dwBegin] = 0;

                        CInstancePtr pInstance(
                                        CreateNewInstance(pMethodContext),
                                        false);

                        LoadPropertyValues(dwBegin, dwEnd, bAlias, pInstance);

					    hr = pInstance->Commit();
                    }
			    }
                // else if we're doing GetObject and we found the right one...
                else if (i64StartingAddress == dwBegin)
                {
                    LoadPropertyValues(dwBegin, dwEnd, bAlias, pInstance);

                    // We could just return WBEM_S_NO_ERROR now, but we
                    // won't to avoid having a return in the middle of
                    // the code path.
                    bDone = TRUE;
                    break;
				}

				// See if this is a non-aliased value.  If so, get out.
                if (dwAdd == 0)
                    break;

                bAlias = TRUE;
			}
        }

#ifdef WIN9XONLY
        // Now loop through the ones that weren't owned by any devices.
        // These are the ones that show up as 'In use by unknown device'
        // in Device Manager.
        if (!bDone && SUCCEEDED(hr))
        {
            RANGE_ELEMENT   re;
            ULONG           ulStart,
                            ulEnd;

            if (pCfgMgr->CM_First_Range(rl, &ulStart, &ulEnd, &re, 0) ==
            CR_SUCCESS)
            {
                do
                {
                    // 95(not 98) has a bug where it reports an unknown
                    // device using 0x10000-0xFFFFFFFF(actually it looks
                    // like 0x0-0xFFFF in the UI).  This not only makes no
                    // sense but it screws up our schema since the starting
                    // address is the key and it's a uint16.  So, only
                    // process the port if it has a starting value less than
                    // 0xFFFF.
                    if (ulStart <= 0xFFFF)
                    {
                        // If we're doing EnumInstances...
                        if (pMethodContext)
					    {
                            CInstancePtr pInstance(
                                            CreateNewInstance(pMethodContext),
                                            false);

                            LoadPropertyValues(ulStart, ulEnd, FALSE, pInstance);
						    hr = pInstance->Commit();
                        }
                        // else if we're doing GetObject and we found the right one...
                        else if (i64StartingAddress == ulStart)
                        {
                            LoadPropertyValues(ulStart, ulEnd, FALSE, pInstance);

                            bDone = TRUE;
                            break;
                        }
                    }

                } while(pCfgMgr->CM_Next_Range(&re, &ulStart, &ulEnd, 0) == CR_SUCCESS);
            }
        }

        // Free the range list.
        pCfgMgr->CM_Delete_Range(0, 0xFFFFFFFF, rl, 0);
#endif
    }

#ifdef WIN9XONLY
    CResourceManager::sm_TheResourceManager.ReleaseResource(
        guidCFGMGRAPI,
        pCfgMgr);
#endif

	if (!pMethodContext && !bDone)
	{
		hr = WBEM_E_NOT_FOUND;
	}

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\power.h ===
//=================================================================

//

// Power.h -- UPS supply property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/23/97	 a-hhance		integrated with new framework
//
//=================================================================

// Property set identification
//=============================

#define PROPSET_NAME_POWERSUPPLY L"Win32_UninterruptiblePowerSupply"

// the following are system defined values for UPS options
// they should not be changed
//========================================================

#define UPS_INSTALLED                   0x1
#define UPS_POWER_FAIL_SIGNAL           0x2
#define UPS_LOW_BATTERY_SIGNAL          0x4
#define UPS_CAN_TURN_OFF                0x8
#define UPS_POSITIVE_POWER_FAIL_SIGNAL  0x10
#define UPS_POSITIVE_LOW_BATTERY_SIGNAL 0x20
#define UPS_POSITIVE_SHUT_OFF_SIGNAL    0x40
#define UPS_COMMAND_FILE                0x80


class PowerSupply:public Provider 
{
    public:

        // Constructor/destructor
        //=======================

        PowerSupply(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~PowerSupply() ;

        // Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

        // Utility function(s)
        //====================
#ifdef NTONLY
        HRESULT GetUPSInfoNT(CInstance* pInstance);
#endif
#ifdef WIN9XONLY
        HRESULT GetUPSInfoWin95(CInstance* pInstance);
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\powermanagement.h ===
//=================================================================

//

// PowerManagement.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _WMI_POWER_EVENT_PROVIDER_H
#define _WMI_POWER_EVENT_PROVIDER_H

#include "FactoryRouter.h"
#include "EventProvider.h"
#include "WinMsgEvent.h"
#define POWER_EVENT_CLASS L"Win32_PowerManagementEvent"
//
class CPowerEventFactory :	public CFactoryRouter 
{
	private:
	protected:
	public:

		CPowerEventFactory( REFGUID a_rClsId, LPCWSTR a_pClassName )
			: CFactoryRouter( a_rClsId, a_pClassName ) {} ;

		~CPowerEventFactory() {};

		// implementation of abstract CFactoryRouter
		virtual IUnknown * CreateInstance (

			REFIID a_riid ,
			LPVOID FAR *a_ppvObject
			) ;	
};

//
class CPowerManagementEvent : 
	public CEventProvider, 
	public CWinMsgEvent
{
	private:
		void HandleEvent( DWORD a_dwPowerEvent, DWORD a_dwData ) ;
		BOOL m_bRegistered;
	
	protected:
	public:

		CPowerManagementEvent() : m_bRegistered ( FALSE ) {};
		~CPowerManagementEvent() {};

		// implementation of abstract CWinMsgEvent
		virtual void WinMsgEvent(
			
			IN	HWND a_hWnd,
			IN	UINT a_message,
			IN	WPARAM a_wParam,
			IN	LPARAM	a_lParam,
			OUT E_ReturnAction &a_eRetAction,
			OUT LRESULT &a_lResult
			) ;

		// implementation of abstract CEventProvider
		virtual void ProvideEvents() ;

		// implementation of abstract CEventProvider
        void OnFinalRelease();

		// implementation of class name retrieval for CEventProvider
		virtual BSTR GetClassName() ;
};

#endif // _WMI_POWER_EVENT_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printer.h ===
//////////////////////////////////////////////////////////////////////

//

//  MOPRINT.h  - Enumerate printers

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
//  09/03/96    jennymc     Updated to meet current standards
//                          Removed custom registry access to use the
//                          standard CRegCls
//  10/17/96    jennymc     Enhanced
//
//////////////////////////////////////////////////////////////////////
// Method Names
#define METHOD_SETDEFAULTPRINTER			L"SetDefaultPrinter"
#define METHOD_GETDEFAULTPRINTER			L"GetDefaultPrinter"
#define METHOD_PAUSEPRINTER					L"Pause"
#define METHOD_RESUME_PRINTER				L"Resume"
#define METHOD_CANCEL_ALLJOBS				L"CancelAllJobs"
#define METHOD_RENAME_PRINTER				L"RenamePrinter"
#define METHOD_TEST_PAGE    				L"PrintTestPage"
#define METHOD_ADD_PRINTER_CONNECTION       L"AddPrinterConnection"

#define	METHOD_RETURN_VALUE					L"ReturnValue"

// Method arguments
#define METHOD_ARG_NAME_SHARENAME			L"ShareName"
#define METHOD_ARG_NAME_SHAREPRINTER		L"SharePrinter"
#define METHOD_ARG_NAME_PRINTER		        L"Name"
#define METHOD_ARG_NAME_NEWPRINTERNAME      L"NewPrinterName"


#define EXTENDEDPRINTERSTATUS				L"ExtendedPrinterStatus"
#define EXTENDEDDETECTEDERRORSTATE			L"ExtendedDetectedErrorState"

 
//==================================
#define	PROPSET_NAME_PRINTER	            L"Win32_Printer"

// Types of information for Printers
// =================================
#define ENUMPRINTERS_WIN95_INFOTYPE 5
#define ENUMPRINTERS_WINNT_INFOTYPE 4
#define GETPRINTER_LEVEL2 (DWORD)2L

class CWin32Printer : public Provider
{
public:

        // Constructor/destructor
        //=======================

    CWin32Printer(LPCWSTR strName, LPCWSTR pszNamespace ) ;
    ~CWin32Printer() ;

        // Functions provide properties with current values
        //=================================================

	virtual HRESULT ExecQuery( MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L );

	virtual HRESULT GetObject( CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery );

    virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

    virtual HRESULT ExecMethod ( const CInstance& Instance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags = 0L ) ;
	
	virtual HRESULT PutInstance  ( const CInstance &Instance,  long lFlags );

	virtual	HRESULT DeleteInstance ( const CInstance &Instance,  long lFlags );


        // Utility function(s)
        //====================

private:

	enum E_CollectionScope { 

		e_CollectAll, 
		e_KeysOnly,
        e_CheapOnly
	} ;
		
	enum PrinterStatuses {

		PSOther =1, 
		PSUnknown, 
		PSIdle, 
		PSPrinting, 
		PSWarmup
	};

	enum ExtendedPrinterStatuses
	{

		EPSOther =1, 
		EPSUnknown, 
		EPSIdle, 
		EPSPrinting, 
		EPSWarmup,
		EPSStoppedPrinting,
		EPSOffline,
		EPSPaused,
		EPSError,
		EPSBusy,
		EPSNotAvailable,
		EPSWaiting,
		EPSProcessing,
		EPSInitialization,
		EPSPowerSave,
		EPSPendingDeletion,
		EPSIOActive,
		EPSManualFeed
	};

    enum DetectedErrorStates {

		DESUnknown, 
		DESOther, 
		DESNoError, 
		DESLowPaper, 
		DESNoPaper, 
		DESLowToner, 
        DESNoToner, 
		DESDoorOpen, 
		DESJammed, 
		DESOffline, 
		DESServiceRequested, 
        DESOutputBinFull
	} ;	

	enum ExtendedDetectedErrorStates {

		EDESUnknown, 
		EDESOther, 
		EDESNoError, 
		EDESLowPaper, 
		EDESNoPaper, 
		EDESLowToner, 
        EDESNoToner, 
		EDESDoorOpen, 
		EDESJammed, 
		EDESServiceRequested, 
        EDESOutputBinFull,
		EDESPaperProblem,
		EDESCanonotPrintPage,
		EDESUserInterventionRequired,
		EDESOutOfMemory,
		EDESServerUnknown
	};

#if NTONLY != 5 

	BOOL GetDefaultPrinter (

		IN LPTSTR pszBuffer,
		IN LPDWORD pcchBuffer
	) ;

#endif

	BOOL GetDefaultPrinter ( CHString &a_Printer ) ;

	HRESULT hCollectInstances ( MethodContext *pMethodContext, E_CollectionScope eCollScope);

	HRESULT	DynInstancePrinters ( MethodContext *pMethodContext, E_CollectionScope eCollScope);

	BOOL GetExpensiveProperties ( LPCTSTR szPrinter, CInstance *pInstance , BOOL a_DefaultPrinter ,E_CollectionScope a_eCollectionScope, PRINTER_INFO_2 *pPrintInfo );

	void SetStati ( CInstance *pInstance, DWORD status, HANDLE hPrinter ) ;

	void GetDeviceCapabilities (

		CInstance *pInstance, 
		LPCTSTR pDevice,    // pointer to a printer-name string																				  
		LPCTSTR pPort,      // pointer to a port-name string
		CONST DEVMODE *pDevMode
	);

	void GetDevModeGoodies ( CInstance *pInstance,CONST DEVMODE *pDevMode);
    WORD MapValue(WORD wPaper);
    void PrinterStatusEx (
		
		HANDLE hPrinter, 
		PrinterStatuses &printerStatus, 
		DetectedErrorStates &detectedErrorState, 
		LPCWSTR &pStatusStr ,
		DWORD &a_Status
	);
    
    HRESULT ExecSetDefaultPrinter ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams, long lFlag );
    HRESULT ExecGetDefaultPrinter ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams, long lFlag );
	HRESULT ExecSetPrinter ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams, long lFlags, DWORD dwState );
	HRESULT ExecRenamePrinter ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams );
    HRESULT ExecPrintTestPage ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams );
    HRESULT ExecAddPrinterConnection ( const CInstance &Instance, CInstance *pInParams, CInstance *pOutParams );
    
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printercfg.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  printercfg

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//      10/24/97        jennymc     Moved to new framework
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <winspool.h>
#include <lockwrap.h>
#include <DllWrapperBase.h>
#include <WinSpool.h>
#include "prnutil.h"
#include "Printercfg.h"

// Property set declaration
//=========================

CWin32PrinterConfiguration MyCWin32PrinterConfigurationSet ( PROPSET_NAME_PRINTERCFG , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrinterConfiguration::CWin32PrinterConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PrinterConfiguration :: CWin32PrinterConfiguration (

	LPCWSTR name,
    LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrinterConfiguration::~CWin32PrinterConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32PrinterConfiguration :: ~CWin32PrinterConfiguration ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: ExecQuery (

	MethodContext *pMethodContext,
	CFrameworkQuery& pQuery,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_FAILED;


	// If all they want is the name, we'll give it to them, else let them call enum.
	if( pQuery.KeysOnly() )
	{
		hr = hCollectInstances ( pMethodContext , e_KeysOnly ) ;
	}
	else
	{
		hr = WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery )
{
    //Get one pointer to resman.
	//Lock the printer
	HRESULT hr = WBEM_E_FAILED ;
	CLockWrapper lockPrinter(g_csPrinter);

	//Determine the printer's name (as requested by the user)
    CHString strPrinterName;
	pInstance->GetCHString (IDS_Name, strPrinterName);

	//Init some common vars
    DWORD BytesCopied = (DWORD)0L;
    DWORD TotalPrinters = (DWORD)0L;

	//Init some platform-specific vars
#ifdef NTONLY
    DWORD InfoType = ENUMPRINTERS_WINNT_INFOTYPE;
    DWORD PrinterFlags = PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS;
#endif
#ifdef WIN9XONLY
	DWORD InfoType = ENUMPRINTERS_WIN95_INFOTYPE;
    DWORD PrinterFlags = PRINTER_ENUM_LOCAL;
#endif

	//Call 'EnumPrinters' with a zero size to find out just how many bytes we need
    int RetVal = ::EnumPrinters (
		PrinterFlags,				// types of printer objects to enumerate
		NULL,						// name of printer object
		InfoType,					// specifies type of printer info structure
		NULL ,						// pointer to buffer to receive printer info structures
		(DWORD)0L,					// size, in bytes, of array
		(LPDWORD) & BytesCopied,	// addr. of variable with no. of bytes copied (or required)
		(LPDWORD) & TotalPrinters	// addr. of variable with no. of printer info. structures copied
                );

	// Now create a buffer big enough for the info
	DWORD printInfoSize = BytesCopied ;
	if ( !printInfoSize )
	{
		return WBEM_E_FAILED;
	}
	BYTE *pPrintInfoBase = new BYTE [ printInfoSize ] ;
	if ( !pPrintInfoBase )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	//Cast the buffer's pointer to new type
#ifdef NTONLY
	PRINTER_INFO_4 *pPrintInfo = (PRINTER_INFO_4 *) pPrintInfoBase ;
#endif
#ifdef WIN9XONLY
	PRINTER_INFO_5 *pPrintInfo = (PRINTER_INFO_5 *) pPrintInfoBase ;
#endif

	//Now do the actual enumeration & search
	try
	{
		hr = WBEM_E_NOT_FOUND;

		RetVal = ::EnumPrinters (
				PrinterFlags,				// types of printer objects to enumerate
				NULL,						// name of printer object
				InfoType,					// specifies type of printer info structure
				(LPBYTE)pPrintInfo,			// pointer to buffer to receive printer info structures
				printInfoSize,				// size, in bytes, of array
				(LPDWORD) & BytesCopied,	// addr. of variable with no. of bytes copied (or required)
				(LPDWORD) & TotalPrinters   // addr. of variable with no. of printer info. structures copied
				);

		if ( RetVal )
		{
			//Search for a printer with same name
			for( DWORD CurrentPrinterIndex = (DWORD)0L; CurrentPrinterIndex < TotalPrinters; CurrentPrinterIndex++)
				if  ( strPrinterName.CompareNoCase ( TOBSTRT (pPrintInfo->pPrinterName) ) == 0 )
					{
						hr = WBEM_S_NO_ERROR;
						break;
					}
				else
					++pPrintInfo;
		}
		else
		{
			DWORD Error = GetLastError();
			if (Error == ERROR_ACCESS_DENIED)
			{
				hr = WBEM_E_ACCESS_DENIED;
			}
			else
			{
				hr = WBEM_E_FAILED;
			}

			if (IsErrorLoggingEnabled())
			{
				LogErrorMessage4(L"%s:Error %lxH (%ld)\n",L"Win32_PrinterConfiguration", Error, Error);
			}
		}//RetVal

	}
	catch ( ... )
	{
		hr = WBEM_E_FAILED;
		throw ;
	}

	//If the printer was found - fill the instance with props...
	if SUCCEEDED( hr)
		//Normaly we shold check the result of this operation, yet in case of failure
		//it will simply not polupate some of the properties - which is not fatal !
		GetExpensiveProperties ( TOBSTRT ( strPrinterName ), pInstance, pQuery.KeysOnly() ) ;

	//Cleanup and return
	delete [] pPrintInfoBase ;

	return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hResult = WBEM_E_FAILED ;

	hResult = hCollectInstances ( pMethodContext , e_CollectAll ) ;


	return hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: hCollectInstances (

	MethodContext *pMethodContext,
	E_CollectionScope eCollectionScope
)
{
    CLockWrapper lockPrinter ( g_csPrinter ) ;

	// Get the proper OS dependent instance
#ifdef NTONLY

	HRESULT hr = DynInstanceWinNTPrinters ( pMethodContext, eCollectionScope ) ;

#endif

#ifdef WIN9XONLY

	HRESULT hr = DynInstanceWin95Printers ( pMethodContext, eCollectionScope  ) ;

#endif

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: DynInstanceWin95Printers (

	MethodContext *pMethodContext,
	E_CollectionScope eCollectionScope
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // First of all call with a zero size to find out just
    // how many bytes it needs
    //====================================================

	DWORD BytesCopied = (DWORD)0L;
	DWORD TotalPrinters = (DWORD)0L;
	DWORD InfoType = ENUMPRINTERS_WIN95_INFOTYPE;
	DWORD PrinterFlags = PRINTER_ENUM_LOCAL;

    ::EnumPrinters (

		PrinterFlags,				// types of printer objects to enumerate
		NULL,   					// name of printer object
		InfoType,					// specifies type of printer info structure
		NULL,						// pointer to buffer to receive printer info structures
		(DWORD)0L,					// size, in bytes, of array
		(LPDWORD) & BytesCopied,	// addr. of variable with no. of bytes copied (or required)
		(LPDWORD) & TotalPrinters 	// addr. of variable with no. of printer info. structures copied
	) ;

    // Now create a buffer big enough for the info
    // ===========================================

	DWORD pPrintInfoSize = BytesCopied;
	LPBYTE pPrintInfoBase = new BYTE[pPrintInfoSize];

    if ( pPrintInfoBase )
	{
		try
		{
			PRINTER_INFO_5 *pPrintInfo = (PRINTER_INFO_5 *) pPrintInfoBase;

            int RetVal = ::EnumPrinters (

				PrinterFlags,				// types of printer objects to enumerate
				NULL,						// name of printer object
				InfoType,					// specifies type of printer info structure
				(LPBYTE)pPrintInfo,			// pointer to buffer to receive printer info structures
				pPrintInfoSize,				// size, in bytes, of array
				(LPDWORD) & BytesCopied,	// addr. of variable with no. of bytes copied (or required)
				(LPDWORD) & TotalPrinters	// addr. of variable with no. of printer info. structures copied
			) ;

			if ( TRUE == RetVal )
			{
				for ( DWORD CurrentPrinterIndex = (DWORD)0L ; CurrentPrinterIndex < TotalPrinters && SUCCEEDED(hr); CurrentPrinterIndex ++ )
				{
					// Start building a new instance
					//==============================
					CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
            		pInstance->SetCHString ( L"Name", ((PRINTER_INFO_5 *)(pPrintInfo))->pPrinterName ) ;

					if ( e_CollectAll == eCollectionScope )
					{
						GetExpensiveProperties (

							((PRINTER_INFO_5 *)(pPrintInfo))->pPrinterName,
							pInstance ,
                            false
						) ;
					}

					// Send the new instance back to the MB
					//=====================================

					hr = pInstance->Commit (  ) ;

					++pPrintInfo ;
				}
			}
			else
			{
				hr = WBEM_E_FAILED ;

				if ( IsErrorLoggingEnabled () )
				{
					DWORD Error = GetLastError () ;

					CHString msg;
					msg.Format(L"%s:Error %lxH (%ld)\n",PROPSET_NAME_PRINTERCFG, Error, Error);
					LogErrorMessage(msg);
				}
			}

		}
		catch ( ... )
		{
			delete [] pPrintInfoBase ;

			throw ;
		}

		delete [] pPrintInfoBase ;
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: DynInstanceWinNTPrinters (

	MethodContext *pMethodContext,
	E_CollectionScope eCollectionScope
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // First of all call with a zero size to find out just
    // how many bytes it needs
    //====================================================

    DWORD InfoType = ENUMPRINTERS_WINNT_INFOTYPE;
    DWORD PrinterFlags = PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS;
    DWORD BytesCopied = (DWORD)0L;
    DWORD TotalPrinters = (DWORD)0L;

    ::EnumPrinters (

		PrinterFlags,				// types of printer objects to enumerate
		NULL,   					// name of printer object
		InfoType,					// specifies type of printer info structure
		NULL ,						// pointer to buffer to receive printer info structures
		(DWORD)0L,					// size, in bytes, of array
		(LPDWORD) & BytesCopied,	// addr. of variable with no. of bytes copied (or required)
		(LPDWORD) & TotalPrinters 	// addr. of variable with no. of printer info. structures copied
	);

    // Now create a buffer big enough for the info
    // ===========================================
    DWORD pPrintInfoSize = BytesCopied ;
    LPBYTE pPrintInfoBase = new BYTE[pPrintInfoSize];

    if ( pPrintInfoBase )
	{
		try
		{
			PRINTER_INFO_4 *pPrintInfo = (PRINTER_INFO_4 *)pPrintInfoBase;

			// Get the size of the total enumeration printer data
			// ==================================================

            int RetVal = ::EnumPrinters (

				PrinterFlags,				// types of printer objects to enumerate
				NULL,						// name of printer object
				InfoType,					// specifies type of printer info structure
				(LPBYTE)pPrintInfo,			// pointer to buffer to receive printer info structures
				pPrintInfoSize,				// size, in bytes, of array
				(LPDWORD) & BytesCopied,	// addr. of variable with no. of bytes copied (or required)
				(LPDWORD) & TotalPrinters 	// addr. of variable with no. of printer info. structures copied
			) ;

			if ( RetVal )
			{
				for ( DWORD CurrentPrinterIndex = (DWORD)0L; CurrentPrinterIndex < TotalPrinters && SUCCEEDED(hr); CurrentPrinterIndex++)
				{
					// Start building a new instance
					//==============================
					CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

            		pInstance->SetCHString ( IDS_Name, ((PRINTER_INFO_4 *)(pPrintInfo))->pPrinterName ) ;

					if ( e_CollectAll == eCollectionScope )
					{
						GetExpensiveProperties (

							((PRINTER_INFO_4 *)(pPrintInfo))->pPrinterName ,
							pInstance ,
                            false
						) ;
					}

					hr = pInstance->Commit (  ) ;

					++ pPrintInfo ;
				}
			}
			else
			{
				DWORD Error = GetLastError();

				if ( Error == ERROR_ACCESS_DENIED )
				{
					hr = WBEM_E_ACCESS_DENIED;
				}
				else
				{
					hr = WBEM_E_FAILED;
				}

				if (IsErrorLoggingEnabled())
				{
					CHString msg;
					msg.Format(L"%s:Error %lxH (%ld)\n",PROPSET_NAME_PRINTERCFG, Error, Error);
					LogErrorMessage(msg);
				}
			}
		}
		catch ( ... )
		{
			delete [] pPrintInfoBase ;

			throw ;
		}

        delete[] pPrintInfoBase;
    }
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

    return hr;
}



// Used to convert from dmPaperSize to width and height.
const DWORD g_dwSizes[][2] =
{
    {    0,    0}, // Unused
    { 2159, 2794}, /* Letter 8 1/2 x 11 in               */
    { 2159, 2794}, /* Letter Small 8 1/2 x 11 in         */
    { 2794, 4318}, /* Tabloid 11 x 17 in                 */
    { 4318, 2794}, /* Ledger 17 x 11 in                  */
    { 2159, 3556}, /* Legal 8 1/2 x 14 in                */
    { 1397, 2159}, /* Statement 5 1/2 x 8 1/2 in         */
    { 1842, 2667}, /* Executive 7 1/4 x 10 1/2 in        */
    { 2970, 4200}, /* A3 297 x 420 mm                    */
    { 2100, 2970}, /* A4 210 x 297 mm                    */
    { 2100, 2970}, /* A4 Small 210 x 297 mm              */
    { 1480, 2100}, /* A5 148 x 210 mm                    */
    { 2500, 3540}, /* B4 (JIS) 250 x 354                 */
    { 1820, 2570}, /* B5 (JIS) 182 x 257 mm              */
    { 2159, 3320}, /* Folio 8 1/2 x 13 in                */
    { 2150, 2750}, /* Quarto 215 x 275 mm                */
    { 2540, 3556}, /* 10x14 in                           */
    { 2794, 4318}, /* 11x17 in                           */
    { 2159, 2794}, /* Note 8 1/2 x 11 in                 */
    {  984, 2254}, /* Envelope #9 3 7/8 x 8 7/8          */
    { 1048, 2413}, /* Envelope #10 4 1/8 x 9 1/2         */
    { 1143, 2635}, /* Envelope #11 4 1/2 x 10 3/8        */
    { 1207, 2794}, /* Envelope #12 4 \276 x 11           */
    { 1270, 2921}, /* Envelope #14 5 x 11 1/2            */
    { 4318, 5588}, /* C 17 x 22 size sheet               */
    { 5588, 8636}, /* D 22 x 34 size sheet               */
    { 8636,11176}, /* E 34 x 44 size sheet               */
    { 1100, 2200}, /* Envelope DL 110 x 220mm            */
    { 1620, 2290}, /* Envelope C5 162 x 229 mm           */
    { 3240, 4580}, /* Envelope C3  324 x 458 mm          */
    { 2290, 3240}, /* Envelope C4  229 x 324 mm          */
    { 1140, 1620}, /* Envelope C6  114 x 162 mm          */
    { 1140, 2290}, /* Envelope C65 114 x 229 mm          */
    { 2500, 3530}, /* Envelope B4  250 x 353 mm          */
    { 1760, 2500}, /* Envelope B5  176 x 250 mm          */
    { 1760, 1250}, /* Envelope B6  176 x 125 mm          */
    { 1100, 2300}, /* Envelope 110 x 230 mm              */
    { 9843, 1905}, /* Envelope Monarch 3.875 x 7.5 in    */
    { 9208, 1651}, /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
    { 3778, 2794}, /* US Std Fanfold 14 7/8 x 11 in      */
    { 2159, 3048}, /* German Std Fanfold 8 1/2 x 12 in   */
    { 2159, 3302}, /* German Legal Fanfold 8 1/2 x 13 in */
    { 2500, 3530}, /* B4 (ISO) 250 x 353 mm              */
    { 1000, 1480}, /* Japanese Postcard 100 x 148 mm     */
    { 2286, 2794}, /* 9 x 11 in                          */
    { 2540, 2794}, /* 10 x 11 in                         */
    { 3810, 2794}, /* 15 x 11 in                         */
    { 2200, 2200}, /* Envelope Invite 220 x 220 mm       */
    {    0,    0}, /* RESERVED--DO NOT USE               */
    {    0,    0}, /* RESERVED--DO NOT USE               */
    { 2356, 3048}, /* Letter Extra 9 \275 x 12 in        */
    { 2356, 3810}, /* Legal Extra 9 \275 x 15 in         */
    { 2969, 4572}, /* Tabloid Extra 11.69 x 18 in        */
    { 2355, 3223}, /* A4 Extra 9.27 x 12.69 in           */
    { 2102, 2794}, /* Letter Transverse 8 \275 x 11 in   */
    { 2100, 2970}, /* A4 Transverse 210 x 297 mm         */
    { 2356, 3048}, /* Letter Extra Transverse 9\275 x 12 in */
    { 2270, 3560}, /* SuperA/SuperA/A4 227 x 356 mm      */
    { 3050, 4870}, /* SuperB/SuperB/A3 305 x 487 mm      */
    { 2159, 3223}, /* Letter Plus 8.5 x 12.69 in         */
    { 2100, 3330}, /* A4 Plus 210 x 330 mm               */
    { 1480, 2100}, /* A5 Transverse 148 x 210 mm         */
    { 1820, 2570}, /* B5 (JIS) Transverse 182 x 257 mm   */
    { 3220, 4450}, /* A3 Extra 322 x 445 mm              */
    { 1740, 2350}, /* A5 Extra 174 x 235 mm              */
    { 2010, 2760}, /* B5 (ISO) Extra 201 x 276 mm        */
    { 4200, 5940}, /* A2 420 x 594 mm                    */
    { 2970, 4200}, /* A3 Transverse 297 x 420 mm         */
    { 3200, 4450}, /* A3 Extra Transverse 322 x 445 mm   */

#if NTONLY >= 5
    { 2000, 1480}, /* Japanese Double Postcard 200 x 148 mm */
    { 1050, 1480}, /* A6 105 x 148 mm                 */
    {    0,    0}, /* Japanese Envelope Kaku #2       */
    {    0,    0}, /* Japanese Envelope Kaku #3       */
    {    0,    0}, /* Japanese Envelope Chou #3       */
    {    0,    0}, /* Japanese Envelope Chou #4       */
    { 2794, 2159}, /* Letter Rotated 11 x 8 1/2 11 in */
    { 4200, 2970}, /* A3 Rotated 420 x 297 mm         */
    { 2970, 2100}, /* A4 Rotated 297 x 210 mm         */
    { 2100, 1480}, /* A5 Rotated 210 x 148 mm         */
    { 3640, 2570}, /* B4 (JIS) Rotated 364 x 257 mm   */
    { 2570, 1820}, /* B5 (JIS) Rotated 257 x 182 mm   */
    { 1480, 1000}, /* Japanese Postcard Rotated 148 x 100 mm */
    { 1480, 2000}, /* Double Japanese Postcard Rotated 148 x 200 mm */
    { 1480, 1050}, /* A6 Rotated 148 x 105 mm         */
    {    0,    0}, /* Japanese Envelope Kaku #2 Rotated */
    {    0,    0}, /* Japanese Envelope Kaku #3 Rotated */
    {    0,    0}, /* Japanese Envelope Chou #3 Rotated */
    {    0,    0}, /* Japanese Envelope Chou #4 Rotated */
    { 1280, 1820}, /* B6 (JIS) 128 x 182 mm           */
    { 1820, 1280}, /* B6 (JIS) Rotated 182 x 128 mm   */
    { 3048, 2794}, /* 12 x 11 in                      */
    {    0,    0}, /* Japanese Envelope You #4        */
    {    0,    0}, /* Japanese Envelope You #4 Rotated*/
    { 1460, 2150}, /* PRC 16K 146 x 215 mm            */
    {  970, 1510}, /* PRC 32K 97 x 151 mm             */
    {  970, 1510}, /* PRC 32K(Big) 97 x 151 mm        */
    { 1020, 1650}, /* PRC Envelope #1 102 x 165 mm    */
    { 1020, 1760}, /* PRC Envelope #2 102 x 176 mm    */
    { 1250, 1760}, /* PRC Envelope #3 125 x 176 mm    */
    { 1100, 2080}, /* PRC Envelope #4 110 x 208 mm    */
    { 1100, 2200}, /* PRC Envelope #5 110 x 220 mm    */
    { 1200, 2300}, /* PRC Envelope #6 120 x 230 mm    */
    { 1600, 2300}, /* PRC Envelope #7 160 x 230 mm    */
    { 1200, 3090}, /* PRC Envelope #8 120 x 309 mm    */
    { 2290, 3240}, /* PRC Envelope #9 229 x 324 mm    */
    { 3240, 4580}, /* PRC Envelope #10 324 x 458 mm   */
    { 2150, 1460}, /* PRC 16K Rotated                 */
    { 1510,  970}, /* PRC 32K Rotated                 */
    { 1510,  970}, /* PRC 32K(Big) Rotated            */
    { 1650, 1020}, /* PRC Envelope #1 Rotated 165 x 102 mm */
    { 1760, 1020}, /* PRC Envelope #2 Rotated 176 x 102 mm */
    { 1760, 1250}, /* PRC Envelope #3 Rotated 176 x 125 mm */
    { 2080, 1100}, /* PRC Envelope #4 Rotated 208 x 110 mm */
    { 2200, 1100}, /* PRC Envelope #5 Rotated 220 x 110 mm */
    { 2300, 1200}, /* PRC Envelope #6 Rotated 230 x 120 mm */
    { 2300, 1600}, /* PRC Envelope #7 Rotated 230 x 160 mm */
    { 3090, 1200}, /* PRC Envelope #8 Rotated 309 x 120 mm */
    { 3240, 2290}, /* PRC Envelope #9 Rotated 324 x 229 mm */
    { 4580, 3240}, /* PRC Envelope #10 Rotated 458 x 324 mm */
#endif // NTONLY >= 5
};


#define MAX_PAPERSIZE_INDEX  sizeof(g_dwSizes)/sizeof(g_dwSizes[0])

void CWin32PrinterConfiguration :: UpdateSizesViaPaperSize(DEVMODE *pDevMode)
{
    // See if the paper type is one that we can find the size/length for.
    if (pDevMode->dmPaperSize >= 1 &&
        pDevMode->dmPaperSize < MAX_PAPERSIZE_INDEX)
    {
        // Only set the width if it's not already set.
        if (!(pDevMode->dmFields & DM_PAPERWIDTH))
        {
            pDevMode->dmPaperWidth = g_dwSizes[pDevMode->dmPaperSize][0];
            pDevMode->dmFields |= DM_PAPERWIDTH;
        }

        // Only set the length if it's not already set.
        if (!(pDevMode->dmFields & DM_PAPERLENGTH))
        {
            pDevMode->dmPaperLength = g_dwSizes[pDevMode->dmPaperSize][1];
            pDevMode->dmFields |= DM_PAPERLENGTH;
        }
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32PrinterConfiguration :: GetExpensiveProperties (

	LPCTSTR szPrinter,
    CInstance * pInstance ,
    bool a_KeysOnly
)
{

    HRESULT hr;

	// Instance fill
	CHString t_chsPrinterName( szPrinter ) ;
	pInstance->SetCHString( IDS_Description, t_chsPrinterName );

	//
	SmartClosePrinter hPrinter;

    // Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;
    try
    {
        BOOL t_Status = ::OpenPrinter (

		    (LPTSTR) szPrinter,
		    &hPrinter,
		    NULL
	    ) ;

        if ( t_Status )
	    {
            hr = WBEM_S_NO_ERROR;

            if (!a_KeysOnly)
            {
                // Call 1 time to get buffer size
                //===============================

                DWORD dwByteCount = ::DocumentProperties (

			        NULL,
			        hPrinter,
			        NULL,
			        NULL,
			        NULL,
			        0
		        ) ;

                if ( dwByteCount )
		        {
                    CSmartBuffer buffer(dwByteCount);
                    DEVMODE      *pDevMode = (DEVMODE *) (LPBYTE) buffer;

                    LONG t_DocStatus = ::DocumentProperties (

				        NULL,
					    hPrinter,
					    NULL,
					    pDevMode,
					    NULL,
					    DM_OUT_BUFFER
				        ) ;

				    if ( t_DocStatus == IDOK )
				    {
				        pInstance->SetCharSplat(L"DeviceName", (LPCTSTR) pDevMode->dmDeviceName );

					    pInstance->SetCharSplat(L"SettingID", (LPCTSTR) pDevMode->dmDeviceName );

					    pInstance->SetCHString( IDS_Caption, pDevMode->dmDeviceName );

					    pInstance->SetDWORD(L"DriverVersion", (DWORD) pDevMode->dmDriverVersion );

					    pInstance->SetDWORD(L"SpecificationVersion", (DWORD) pDevMode->dmSpecVersion );

					    // Get the paper width and height, if needed.
                        UpdateSizesViaPaperSize(pDevMode);

                        if (pDevMode->dmFields & DM_BITSPERPEL)
					    {
					        pInstance->SetDWORD(L"BitsPerPel", (DWORD) pDevMode->dmBitsPerPel );
					    }

					    if (pDevMode->dmFields & DM_COLLATE)
					    {
						    pInstance->Setbool(L"Collate",(BOOL)pDevMode->dmCollate);
					    }

					    if (pDevMode->dmFields & DM_COLOR)
					    {
					        pInstance->SetDWORD(L"Color",(DWORD) pDevMode->dmColor);
					    }

					    if (pDevMode->dmFields & DM_COPIES)
					    {
					        pInstance->SetDWORD(L"Copies",(DWORD) pDevMode->dmCopies);
					    }

					    if (pDevMode->dmFields & DM_DISPLAYFLAGS)
					    {
					        pInstance->SetDWORD(L"DisplayFlags",(DWORD) pDevMode->dmDisplayFlags );
					    }

					    if (pDevMode->dmFields & DM_DISPLAYFREQUENCY)
					    {
					        pInstance->SetDWORD(L"DisplayFrequency", (DWORD) pDevMode->dmDisplayFrequency );
					    }

					    if (pDevMode->dmFields & DM_DUPLEX)
					    {
					        pInstance->Setbool(L"Duplex", ((pDevMode->dmDuplex == DMDUP_SIMPLEX) ? 0 : 1) );
					    }

					    if (pDevMode->dmFields & DM_FORMNAME)
					    {
					        pInstance->SetCharSplat(L"FormName", (LPCTSTR) pDevMode->dmFormName );
					    }

					    if (pDevMode->dmFields & DM_LOGPIXELS)
					    {
					        pInstance->SetDWORD(L"LogPixels", (DWORD) pDevMode->dmLogPixels) ;
					    }

					    if (pDevMode->dmFields & DM_ORIENTATION)
					    {
					        pInstance->SetDWORD(L"Orientation",(DWORD) pDevMode->dmOrientation );
					    }

					    if (pDevMode->dmFields & DM_PAPERSIZE)
					    {
					        pInstance->SetDWORD(L"PaperSize",(DWORD) pDevMode->dmPaperSize );
					    }

					    // 0 indicates unknown.
                        if ((pDevMode->dmFields & DM_PAPERWIDTH) && pDevMode->dmPaperWidth)
					    {
					        pInstance->SetDWORD(L"PaperWidth", (DWORD) pDevMode->dmPaperWidth );
					    }

					    // 0 indicates unknown.
					    if ((pDevMode->dmFields & DM_PAPERLENGTH) && pDevMode->dmPaperLength)
					    {
					        pInstance->SetDWORD(L"PaperLength", (DWORD) pDevMode->dmPaperLength );
					    }

					    if (pDevMode->dmFields & DM_PELSHEIGHT)
					    {
					        pInstance->SetDWORD(L"PelsHeight",(DWORD) pDevMode->dmPelsHeight );
					    }

					    if (pDevMode->dmFields & DM_PELSWIDTH)
					    {
					        pInstance->SetDWORD(L"PelsWidth", (DWORD) pDevMode->dmPelsWidth );
					    }

					    if (pDevMode->dmFields & DM_PRINTQUALITY)
					    {
					        pInstance->SetDWORD(L"PrintQuality", (DWORD) pDevMode->dmPrintQuality );
					    }

					    if (pDevMode->dmFields & DM_SCALE)
					    {
					        pInstance->SetDWORD(L"Scale", (DWORD) pDevMode->dmScale );
					    }

					    if (pDevMode->dmFields & DM_TTOPTION)
					    {
					        pInstance->SetDWORD(L"TTOption", (DWORD) pDevMode->dmTTOption );
					    }

					    if (pDevMode->dmFields & DM_YRESOLUTION)
					    {
					        pInstance->SetDWORD ( IDS_VerticalResolution, (DWORD) pDevMode->dmYResolution );
						    pInstance->SetDWORD ( L"YResolution", (DWORD) pDevMode->dmYResolution );

						    // per DEVMODE documentation - if dmYres is populated, then printQuality contains the X res
						    // except that negative values are device independent enums

						    if ( pDevMode->dmPrintQuality > 0)
						    {
						        pInstance->SetDWORD ( IDS_HorizontalResolution , pDevMode->dmPrintQuality ) ;
							    pInstance->SetDWORD ( L"XResolution" , pDevMode->dmPrintQuality ) ;
						    }
					    }

    #ifdef NTONLY
					    if (pDevMode->dmFields & DM_DITHERTYPE)
					    {
					        pInstance->SetDWORD(L"DitherType", (DWORD) pDevMode->dmDitherType) ;
					    }

					    if (pDevMode->dmFields & DM_ICMINTENT)
					    {
					        pInstance->SetDWORD(L"ICMIntent",(DWORD) pDevMode->dmICMIntent) ;
					    }

					    if (pDevMode->dmFields & DM_ICMMETHOD)
					    {
					        pInstance->SetDWORD(L"ICMMethod",(DWORD) pDevMode->dmICMMethod) ;
					    }

					    if (pDevMode->dmFields & DM_MEDIATYPE)
					    {
					        pInstance->SetDWORD(L"MediaType",(DWORD) pDevMode->dmMediaType) ;
					    }
    #endif
			        }
                }
            }
        }
	    else
	    {
            hr = WBEM_E_NOT_FOUND ;
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo()); 
        hr = WBEM_E_FAILED;   
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printercfg.h ===
//////////////////////////////////////////////////////////////////////

//

//  printercfg

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//      10/24/97        jennymc     Moved to new framework
//
//////////////////////////////////////////////////////////////////////

//==================================
#define PROPSET_NAME_PRINTERCFG L"Win32_PrinterConfiguration"

// Types of information for Printers
// =================================
#define ENUMPRINTERS_WIN95_INFOTYPE 5
#define ENUMPRINTERS_WINNT_INFOTYPE 4
#define GETPRINTER_LEVEL2 (DWORD)2L

//==================================
class CWin32PrinterConfiguration : public Provider
{
public:

        // Constructor/destructor
        //=======================

    CWin32PrinterConfiguration(LPCWSTR name, LPCWSTR pszNamespace);
   ~CWin32PrinterConfiguration() ;

    // Funcitons provide properties with current values
    //=================================================
	virtual HRESULT ExecQuery( MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L );
	virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);


        // Utility
        //========
private:

	enum E_CollectionScope { e_CollectAll, e_KeysOnly }; 

 	HRESULT hCollectInstances ( MethodContext *pMethodContext, E_CollectionScope eCollScope );
	HRESULT	DynInstanceWin95Printers ( MethodContext *pMethodContext, E_CollectionScope eCollScope );
	HRESULT	DynInstanceWinNTPrinters ( MethodContext *pMethodContext, E_CollectionScope eCollScope );
    HRESULT GetExpensiveProperties ( LPCTSTR szPrinter , CInstance *pInstance , bool a_KeysOnly );
    static void UpdateSizesViaPaperSize(DEVMODE *pDevMode);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printer.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  PRINTER.CPP

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//  09/03/96    jennymc     Updated to meet current standards
//                          Removed custom registry access to use the
//                          standard CRegCls
//  03/01/2000  a-sandja    Added extended detected error codes
//                          Added printer control
//  03/29/2000  amaxa       Added boolean properties
//                          Added PutInstance, DeleteInstance
//                          AddPrinterConnection, RenamePrinter, Test Page
//
//////////////////////////////////////////////////////////////////////

#include <precomp.h>
#include <winspool.h>
#include <lockwrap.h>
#include <DllWrapperBase.h>
#include "printer.h"
#include "prnutil.h"
#include "prninterface.h"

#include <profilestringimpl.h>

//
// For mapping attributes to bools
//
struct PrinterAttributeMap
{
    DWORD   Bit;
    LPCWSTR BoolName;
};

//
// Note that the default bool is missing from the table. That is because
// it is updated in a deifferent way
//
static PrinterAttributeMap AttributeTable[] =
{
    { PRINTER_ATTRIBUTE_QUEUED,            L"Queued"              },
    { PRINTER_ATTRIBUTE_DIRECT,            L"Direct"              },
    { PRINTER_ATTRIBUTE_SHARED,            L"Shared"              },
    { PRINTER_ATTRIBUTE_NETWORK,           L"Network"             },
    { PRINTER_ATTRIBUTE_HIDDEN,            L"Hidden"              },
    { PRINTER_ATTRIBUTE_LOCAL,             L"Local"               },
    { PRINTER_ATTRIBUTE_ENABLE_DEVQ,       L"EnableDevQueryPrint" },
    { PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS,   L"KeepPrintedJobs"     },
    { PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST, L"DoCompleteFirst"     },
    { PRINTER_ATTRIBUTE_WORK_OFFLINE,      L"WorkOffline"         },
    { PRINTER_ATTRIBUTE_ENABLE_BIDI,       L"EnableBIDI"          },
    { PRINTER_ATTRIBUTE_RAW_ONLY,          L"RawOnly"             },
    { PRINTER_ATTRIBUTE_PUBLISHED,         L"Published"           }
};

/*****************************************************************************
 *
 *  FUNCTION    : ConvertCIMTimeToSystemTime
 *
 *  DESCRIPTION : Helper function. Transforms a string that represents a data and time
 *                in CIM format to a systemtime format
 *
 *  RETURNS     : WBEM HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT
ConvertCIMTimeToSystemTime(
    IN     LPCWSTR     pszTime,
    IN OUT SYSTEMTIME *pSysTime
    )
{
    HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    if (pszTime && 
        pSysTime && 
        wcslen(pszTime) >= wcslen(kDateTimeTemplate))
    {
        //
        // Each buffer must hold 2 digits and a NULL
        //
        WCHAR Hour[3]   = {0};
        WCHAR Minute[3] = {0};

        //
        // pszTime is of the form "19990101hhmmss...". The following functions
        // isolate the hour and the time from the string.
        //
        wcsncpy(Hour,   &pszTime[8],  2);
        wcsncpy(Minute, &pszTime[10], 2);

        memset(pSysTime, 0, sizeof(SYSTEMTIME));

        pSysTime->wHour   = static_cast<WORD>(_wtoi(Hour));
        pSysTime->wMinute = static_cast<WORD>(_wtoi(Minute));

        hRes = WBEM_S_NO_ERROR;
    }

    return hRes;
}

//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32Printer win32Printer ( PROPSET_NAME_PRINTER , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::CWin32Printer
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Printer :: CWin32Printer (

    LPCWSTR strName,
    LPCWSTR pszNamespace

) : Provider ( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::~CWin32Printer
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Printer::~CWin32Printer()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Printer :: ExecQuery (

    MethodContext *pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_FAILED;

    //
    // If all they want is the name, we'll give it to them, else let them call enum.
    //
    if (pQuery.KeysOnly())
    {
        hr = hCollectInstances(pMethodContext, e_KeysOnly);
    }
    else
    {
        if (pQuery.IsPropertyRequired(IDS_Status) ||
            pQuery.IsPropertyRequired(IDS_PrinterStatus) ||
            pQuery.IsPropertyRequired(IDS_DetectedErrorState) ||
            pQuery.IsPropertyRequired(EXTENDEDPRINTERSTATUS) ||
            pQuery.IsPropertyRequired(EXTENDEDDETECTEDERRORSTATE) ||
            pQuery.IsPropertyRequired(L"PrinterState"))
        {
            hr = WBEM_E_PROVIDER_NOT_CAPABLE ;
        }
        else
        {
            hr = hCollectInstances(pMethodContext, e_CheapOnly);
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::GetObject
 *
 *  DESCRIPTION : Poplulate one WBEM instance for the specific printer
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : op. code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Printer :: GetObject (
    CInstance       *pInstance,
    long             lFlags,
    CFrameworkQuery &pQuery)
{
    E_CollectionScope eCollScope;
    HRESULT  hRes            = WBEM_S_NO_ERROR;
    BOOL     bIsLocalCall    = TRUE;
    DWORD    dwLevel         = 2;
    DWORD    dwError;
    CHString csDefaultPrinter;
    CHString csPrinter;
    BOOL     bDefault        = FALSE;

#ifdef WIN9XONLY
    //
    // Lock the printer
    //
    CLockWrapper  lockPrinter(g_csPrinter);
#endif

    pInstance->GetCHString(IDS_DeviceID, csPrinter);
#if NTONLY >= 5
    dwError = IsLocalCall(&bIsLocalCall);

    hRes    = WinErrorToWBEMhResult(dwError);
#endif

    if (SUCCEEDED(hRes)) 
    {
        //
        // Check if the printer is a local printer or a printer connection.
        // We want to disallow the following scenario:
        // User connects remotely to winmgmt on server \\srv
        // User does GetObject on printer \\prnsrv\prn which is not local and
        // the user doesn't have a connection to. Normally this call succeeds,
        // because the spooler goes accros the wire. This means that you can
        // do GetObject on an instance that cannot be returned by EnumInstances.
        // This is inconsistent with WMI.
        //
        BOOL bInstalled;
        
        hRes = WinErrorToWBEMhResult(SplIsPrinterInstalled(csPrinter, &bInstalled));       

        if (SUCCEEDED(hRes) && !bInstalled) 
        {
            //
            // Caller wants to do GetObject on a remote printer
            //
            hRes = WBEM_E_NOT_FOUND;
        }
    }

    if (SUCCEEDED(hRes))
    {
        if (!pQuery.KeysOnly())
        {
            if (pQuery.IsPropertyRequired(IDS_Status) ||
                pQuery.IsPropertyRequired(IDS_PrinterStatus) ||
                pQuery.IsPropertyRequired(IDS_DetectedErrorState) ||
                pQuery.IsPropertyRequired(EXTENDEDPRINTERSTATUS) ||
                pQuery.IsPropertyRequired(EXTENDEDDETECTEDERRORSTATE) ||
                pQuery.IsPropertyRequired(L"PrinterState"))
            {
                eCollScope = e_CollectAll;
            }
            else
            {
                eCollScope = e_CheapOnly;
            }
        }
        else
        {
            eCollScope = e_KeysOnly;
        }

        //
        // The default printer is a per user resource and makes sens only for
        // user logged on the local machine
        //
        if (SUCCEEDED(hRes) && bIsLocalCall)
        {
            if (!GetDefaultPrinter(csDefaultPrinter))
            {
                dwError = GetLastError();

                //
                // If there are no printers on a machine or in the case on TS:
                // you delete your default printer, then you have no more default printer
                //
                if (dwError = ERROR_FILE_NOT_FOUND)
                {
                    //
                    // We have no default printer, behave like in the case of remote login
                    //
                    bDefault = FALSE;

                    dwError  = ERROR_SUCCESS;
                }

                hRes  = WinErrorToWBEMhResult(dwError);
            }
            else
            {
                bDefault = !csPrinter.CompareNoCase(csDefaultPrinter);
            }
        }

        //
        // We have the default printer, now get requested properties
        //
        if (SUCCEEDED(hRes))
        {
            SmartClosePrinter  hPrinter;
            BYTE              *pBuffer         = NULL;
            PRINTER_DEFAULTS   PrinterDefaults = {NULL, NULL, PRINTER_READ};

            // Use of delay loaded functions requires exception handler.
            SetStructuredExceptionHandler seh;
            
            try
            {
                if (::OpenPrinter((LPTSTR)(LPCTSTR)TOBSTRT(csPrinter), (LPHANDLE)&hPrinter, &PrinterDefaults))
                {
                    dwError = GetThisPrinter(hPrinter, 2, &pBuffer);

                    if (dwError==ERROR_SUCCESS)
                    {
                        try
                        {
                            GetExpensiveProperties(TOBSTRT(csPrinter),
                                                   pInstance,
                                                   bDefault,
                                                   eCollScope,
                                                   reinterpret_cast<PRINTER_INFO_2 *>(pBuffer));
                        }
                        catch(...)
                        {
                            delete [] pBuffer;

                            throw;
                        }

                        delete [] pBuffer;
                    }
                }
                else
                {
                    dwError = GetLastError();
                }
            }
            catch(Structured_Exception se)
            {
                DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                hRes = WBEM_E_FAILED;
            }

            hRes = WinErrorToWBEMhResult(dwError);
#if NTONLY >= 5
            if (FAILED(hRes))
            {
                SetErrorObject(*pInstance, dwError, pszGetObject);
            }
#endif
        }
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::EnumerateInstances
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Printer :: EnumerateInstances (

    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
    HRESULT hResult = WBEM_E_FAILED ;

    hResult = hCollectInstances(pMethodContext, e_CollectAll);

    return hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::hCollectInstances
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Printer :: hCollectInstances (

    MethodContext *pMethodContext,
    E_CollectionScope eCollectionScope
)
{
#ifdef WIN9XONLY
    CLockWrapper    lockPrinter(g_csPrinter);
#endif

    // Get the proper OS dependent instance

    HRESULT hr = DynInstancePrinters ( pMethodContext, eCollectionScope );

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::DynInstancePrinters
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Printer :: DynInstancePrinters (

    MethodContext *pMethodContext,
    E_CollectionScope eCollectionScope
)
{
    HRESULT  hRes            = WBEM_S_NO_ERROR;
    BOOL     bIsLocalCall    = FALSE;
    DWORD    cbSize          = 0;
    DWORD    cbNeeded        = 0;
    DWORD    cReturned       = 0;
    DWORD    dwLevel         = 2;
    DWORD    dwFlags         = PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS;
    DWORD    dwError;
    CHString csDefaultPrinter;
    BYTE    *pBuffer         = NULL;
#if NTONLY >= 5
    dwError = IsLocalCall(&bIsLocalCall);

    hRes    = WinErrorToWBEMhResult(dwError);
#endif
#ifdef WIN9XONLY
    bIsLocalCall = TRUE;
#endif

    //
    // The default printer is a per user resource and makes sens only for
    // user logged on the local machine
    //
    if (SUCCEEDED(hRes) && bIsLocalCall)
    {
        if (!GetDefaultPrinter(csDefaultPrinter))
        {
            dwError = GetLastError();

            //
            // If there are no printers on a machine or in the case on TS:
            // you delete your default printer, then you have no more default printer
            //
            if (dwError = ERROR_FILE_NOT_FOUND)
            {
                //
                // We have no default printer, behave like in the case of remote login
                //
                bIsLocalCall = FALSE;

                dwError      = ERROR_SUCCESS;
            }

            hRes    = WinErrorToWBEMhResult(dwError);
        }
    }

    if (SUCCEEDED(hRes))
    {
        if (!::EnumPrinters(dwFlags,
                                        NULL,
                                        dwLevel,
                                        NULL,
                                        cbSize,
                                        &cbNeeded,
                                        &cReturned))
        {
            dwError = GetLastError();

            if (dwError==ERROR_INSUFFICIENT_BUFFER)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;

                pBuffer = new BYTE [cbSize=cbNeeded];

                if (pBuffer)
                {
                    if (!::EnumPrinters(dwFlags,
                                                    NULL,
                                                    dwLevel,
                                                    pBuffer,
                                                    cbSize,
                                                    &cbNeeded,
                                                    &cReturned))
                    {
                        //
                        // We don't care about the error, if we should fail the second call to EnumPrinters
                        //
                        hRes    = WBEM_E_FAILED;
                    }
                    else
                    {
                        try
                        {
                            //
                            // Create instances of printers
                            //
                            hRes = WBEM_S_NO_ERROR;

                            PRINTER_INFO_2 *pPrnInfo = reinterpret_cast<PRINTER_INFO_2 *>(pBuffer);

                            for (DWORD uIndex = 0; uIndex < cReturned && SUCCEEDED(hRes); uIndex++, pPrnInfo++)
                            {
                                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                                pInstance->SetCHString(IDS_DeviceID, pPrnInfo->pPrinterName);

                                if (e_KeysOnly != eCollectionScope)
                                {
                                    BOOL bDefault = bIsLocalCall && !csDefaultPrinter.CompareNoCase(TOBSTRT(pPrnInfo->pPrinterName));

                                    GetExpensiveProperties(pPrnInfo->pPrinterName, pInstance, bDefault, eCollectionScope, pPrnInfo);
                                }

                                hRes = pInstance->Commit();
                            }
                        }
                        catch(...)
                        {
                            delete [] pBuffer;

                            throw;
                        }
                    }

                    delete [] pBuffer;
                }
            }
            else
            {
                hRes = WinErrorToWBEMhResult(dwError);
            }
        }
    }
    
    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::GetExpensiveProperties
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32Printer :: GetExpensiveProperties (

    LPCTSTR            szPrinter,
    CInstance         *pInstance ,
    BOOL               a_Default ,
    E_CollectionScope  a_eCollectionScope,
    PRINTER_INFO_2    *pPrinterInfo
)
{

    if (e_KeysOnly != a_eCollectionScope)
    {
        SetCreationClassName(pInstance);

        pInstance->SetWCHARSplat ( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;

        if ( pPrinterInfo->pPortName && *pPrinterInfo->pPortName )
        {
            pInstance->SetCharSplat( IDS_PortName, pPrinterInfo->pPortName );

#ifdef WIN9XONLY
            // Win9x doesn't seem to ever report this server and share names.
            // So, we'll get them from the port name (which is \\server\share for
            // network printers).  If future 9x cores report this info
            // these values will get overridden with the normal set statements
            // below.
            CHString strPort = pPrinterInfo->pPortName;
            int      iWhere = strPort.ReverseFind('\\');

            // The last slash can't be -1 (not found) or 0-2 (e.g. \\a\x).
            if (iWhere >= 3)
            {
                CHString strServer = strPort.Left(iWhere),
                         strShare = strPort.Mid(iWhere + 1);

                // Won't ever be empty because of where iWhere is.
                pInstance->SetCharSplat(IDS_ServerName, strServer);

                if (!strShare.IsEmpty())
                    pInstance->SetCharSplat(IDS_ShareName, strShare);
            }
#endif
        }

        if( pPrinterInfo->pShareName && *pPrinterInfo->pShareName)
        {
            pInstance->SetCharSplat( IDS_ShareName, pPrinterInfo->pShareName );
        }

        if( pPrinterInfo->pServerName && *pPrinterInfo->pServerName)
        {
            pInstance->SetCharSplat( IDS_ServerName, pPrinterInfo->pServerName );
        }

        if( pPrinterInfo->pPrintProcessor && *pPrinterInfo->pPrintProcessor)
        {
            pInstance->SetCharSplat( IDS_PrintProcessor, pPrinterInfo->pPrintProcessor );
        }

        if( pPrinterInfo->pParameters && *pPrinterInfo->pParameters)
        {
            pInstance->SetCharSplat( IDS_Parameters, pPrinterInfo->pParameters );
        }

        if( pPrinterInfo->pDriverName && *pPrinterInfo->pDriverName)
        {
            pInstance->SetCharSplat( IDS_DriverName, pPrinterInfo->pDriverName );
        }

        if( pPrinterInfo->pComment && *pPrinterInfo->pComment)
        {
            pInstance->SetCharSplat( IDS_Comment, pPrinterInfo->pComment );
        }

        if( pPrinterInfo->pLocation && *pPrinterInfo->pLocation)
        {
            pInstance->SetCharSplat( IDS_Location, pPrinterInfo->pLocation );
        }

        if( pPrinterInfo->pSepFile && *pPrinterInfo->pSepFile)
        {
            pInstance->SetCharSplat( IDS_SeparatorFile, pPrinterInfo->pSepFile );
        }

        pInstance->SetDWORD( IDS_JobCountSinceLastReset, pPrinterInfo->cJobs );
        pInstance->SetDWORD( IDS_DefaultPriority, pPrinterInfo->DefaultPriority );
        pInstance->SetDWORD( IDS_Priority, pPrinterInfo->Priority );

        //
        // Special case here
        //
        SYSTEMTIME StartTime = {0};
        SYSTEMTIME UntilTime = {0};
        CHString   csTime;

        PrinterTimeToLocalTime(pPrinterInfo->StartTime, &StartTime);
        PrinterTimeToLocalTime(pPrinterInfo->UntilTime, &UntilTime);

        //
        // If the printer is always available, then we do not set the StartTime
        // and the UntilTime properties
        //
        if (StartTime.wHour!=UntilTime.wHour || StartTime.wMinute!=UntilTime.wMinute)
        {
            csTime.Format(kDateTimeFormat, StartTime.wHour, StartTime.wMinute);

            pInstance->SetCHString(IDS_StartTime, csTime);

            csTime.Format(kDateTimeFormat, UntilTime.wHour, UntilTime.wMinute);

            pInstance->SetCHString(IDS_UntilTime, csTime);
        }

        if( pPrinterInfo->pDatatype && *pPrinterInfo->pDatatype)
        {
            pInstance->SetCharSplat( IDS_PrintJobDataType, pPrinterInfo->pDatatype );
        }

        pInstance->SetDWORD( IDS_AveragePagesPerMinute, pPrinterInfo->AveragePPM );

        pInstance->SetDWORD( IDS_Attributes, pPrinterInfo->Attributes | (a_Default ? PRINTER_ATTRIBUTE_DEFAULT : 0));

        //
        // Update the whole set of booleans
        //
        for (UINT uIndex = 0; uIndex < sizeof(AttributeTable)/sizeof(AttributeTable[0]); uIndex++)
        {
            bool bValue = pPrinterInfo->Attributes & AttributeTable[uIndex].Bit;

            pInstance->Setbool(AttributeTable[uIndex].BoolName, bValue);
        }

        //
        // Update the "Default" boolean
        //
        pInstance->Setbool(kDefaultBoolean, a_Default);

        CHString tmp;
        if( pInstance->GetCHString(IDS_DeviceID, tmp) )
        {
            pInstance->SetCHString(IDS_Caption, tmp );
            pInstance->SetCHString( IDS_Name , tmp ) ;
        }

        // if pservername is null, printer is local
        if (pPrinterInfo->pServerName)
        {
            pInstance->SetCharSplat( IDS_SystemName, pPrinterInfo->pServerName );
        }
        else
        {
            pInstance->SetCHString( IDS_SystemName, GetLocalComputerName() );
        }

        // Spooling
        bool bSpool = !( pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_DIRECT ) ||
                       ( pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_QUEUED );

        pInstance->Setbool(IDS_SpoolEnabled, bSpool);

        GetDeviceCapabilities (

            pInstance,
            szPrinter,
            pPrinterInfo->pPortName,
            pPrinterInfo->pDevMode
            );

        if (e_CheapOnly != a_eCollectionScope)
        {
            SmartClosePrinter hPrinter;

            BOOL t_Status = OpenPrinter (

                (LPTSTR) szPrinter,
                (LPHANDLE) & hPrinter,
                NULL
            ) ;

            if  ( t_Status )
            {
                SetStati (

                    pInstance,
                    pPrinterInfo->Status,
                    hPrinter 
                ) ;
            }
        }
    }

    return TRUE;

}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// what's the plural of "status?"
// sets the properties Status, PrinterStatus and DetectedErrorState

void CWin32Printer :: SetStati (

	CInstance *pInstance,
	DWORD a_status,
	HANDLE hPrinter
)
{
	DWORD t_Status = a_status ;

	PrinterStatuses printerStatus = PSIdle;
    DetectedErrorStates detectedErrorState = DESNoError;
    LPCWSTR pStatusStr = IDS_STATUS_OK;
	ExtendedPrinterStatuses eXPrinterStatus = EPSIdle;
	ExtendedDetectedErrorStates eXDetectedErrorState = EDESNoError;

	switch ( t_Status )
	{
		case PRINTER_STATUS_PAUSED:
		{
            printerStatus = PSOther;
            detectedErrorState = DESNoError;
			eXPrinterStatus = EPSPaused;
			eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
		}
		break;

		case PRINTER_STATUS_PENDING_DELETION:
		{
            printerStatus = PSOther;
            detectedErrorState = DESNoError;
			eXPrinterStatus = EPSPendingDeletion;
			eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_Degraded;
		}
		break;

		case PRINTER_STATUS_BUSY:
		{
            printerStatus = PSPrinting;
            detectedErrorState = DESNoError;
			eXPrinterStatus = EPSBusy;
			eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
		}
		break;

		case PRINTER_STATUS_DOOR_OPEN:
		{
            printerStatus = PSOther;
            detectedErrorState = DESDoorOpen;
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESDoorOpen;
            pStatusStr = IDS_STATUS_Error;
		}
		break;

		case PRINTER_STATUS_ERROR:
		{
            printerStatus = PSOther;
            detectedErrorState = DESOther;
			eXPrinterStatus = EPSError;
			eXDetectedErrorState = EDESOther;
            pStatusStr = IDS_STATUS_Error;
		}
		break;

		case PRINTER_STATUS_INITIALIZING:
		{
            printerStatus = PSWarmup;
            detectedErrorState = DESNoError;
			eXPrinterStatus = EPSInitialization;
			eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
		}
		break;

		case PRINTER_STATUS_IO_ACTIVE:
		{
            printerStatus = PSPrinting;
            detectedErrorState = DESNoError;
			eXPrinterStatus = EPSIOActive;
			eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
		}
		break;

		case PRINTER_STATUS_MANUAL_FEED:
		{
            printerStatus = PSOther;
            detectedErrorState = DESOther;
			eXPrinterStatus = EPSManualFeed;
			eXDetectedErrorState = EDESOther;
            pStatusStr = IDS_STATUS_Error;
		}
		break;

		case PRINTER_STATUS_NO_TONER:
		{
            printerStatus = PSOther;
            detectedErrorState = DESNoToner;
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESNoToner;
            pStatusStr = IDS_STATUS_Error;
		}
		break;

		case PRINTER_STATUS_NOT_AVAILABLE:
		{
            printerStatus = PSUnknown;
            detectedErrorState = DESUnknown;
			eXPrinterStatus = EPSNotAvailable;
			eXDetectedErrorState = EDESOther;
            pStatusStr = IDS_STATUS_Unknown;
		}
		break;

		case PRINTER_STATUS_OFFLINE:
		{
            printerStatus = PSOther;
            detectedErrorState = DESOffline;
			eXPrinterStatus = EPSOffline;
			eXDetectedErrorState = EDESOther;
            pStatusStr = IDS_STATUS_Degraded;
		}
		break;

		case PRINTER_STATUS_OUT_OF_MEMORY:
		{
            printerStatus = PSOther;
            detectedErrorState = DESOther;
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESOutOfMemory;
            pStatusStr = IDS_STATUS_Degraded;
		}
		break;

		case PRINTER_STATUS_OUTPUT_BIN_FULL:
		{
            printerStatus = PSOther;
            detectedErrorState = DESOutputBinFull;
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESOutputBinFull;
            pStatusStr = IDS_STATUS_Degraded;
		}
		break;

		case PRINTER_STATUS_PAGE_PUNT:
		{
            printerStatus = PSOther;
            detectedErrorState = DESOther;
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESCanonotPrintPage;
            pStatusStr = IDS_STATUS_Degraded;
		}
		break;

		case PRINTER_STATUS_PAPER_JAM:
		{
            printerStatus = PSOther;
            detectedErrorState = DESJammed;
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESJammed;
            pStatusStr = IDS_STATUS_Error;
		}
		break;

		case PRINTER_STATUS_PAPER_OUT:
		{
            printerStatus = PSOther;
            detectedErrorState = DESNoPaper;
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESNoPaper;
            pStatusStr = IDS_STATUS_Error;
		}
		break;

		case PRINTER_STATUS_PAPER_PROBLEM:
		{
            printerStatus = PSOther;
            detectedErrorState = DESOther;
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESPaperProblem;
            pStatusStr = IDS_STATUS_Error;
		}
		break;

		case PRINTER_STATUS_PRINTING:
		{
            printerStatus = PSPrinting;
            detectedErrorState = DESNoError;
			eXPrinterStatus = EPSPrinting;
			eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
		}
		break;

		case PRINTER_STATUS_PROCESSING:
		{
            printerStatus = PSPrinting;
            detectedErrorState = DESNoError;
			eXPrinterStatus = EPSProcessing;
			eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
		}
		break;

		case PRINTER_STATUS_TONER_LOW:
		{
            printerStatus = PSOther;
            detectedErrorState = DESLowToner;
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESLowToner;
            pStatusStr = IDS_STATUS_Degraded;
		}
		break;

		case PRINTER_STATUS_SERVER_UNKNOWN:
		{
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESServerUnknown;
		}
		break;

		case PRINTER_STATUS_POWER_SAVE:
		{
			eXPrinterStatus = EPSPowerSave;
			eXDetectedErrorState = EDESOther;
		}
		break;
		
#if 0
		// docs say this is the proper const
		// compiler says it never heard of it...

		case PRINTER_STATUS_UNAVAILABLE:
		{
			err = IDS_PRINTER_STATUS_UNAVAILABLE;
		}
		break;
#endif

		case PRINTER_STATUS_USER_INTERVENTION:
		{
            printerStatus = PSOther;
            detectedErrorState = DESOther;
			eXPrinterStatus = EPSOther;
			eXDetectedErrorState = EDESUserInterventionRequired;
            pStatusStr = IDS_STATUS_Degraded;
		}
		break;

		case PRINTER_STATUS_WAITING:
		{
            printerStatus = PSIdle;
            detectedErrorState = DESNoError;
			eXPrinterStatus = EPSWaiting;
			eXDetectedErrorState = EDESOther;
            pStatusStr = IDS_STATUS_OK;
		}
		break;

		case PRINTER_STATUS_WARMING_UP:
		{
            printerStatus = PSWarmup;
            detectedErrorState = DESNoError;
			eXPrinterStatus = EPSWarmup;
			eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;
		}
		break;
	
		case 0:	// o.k.
		{
			printerStatus = PSIdle;
            detectedErrorState = DESNoError;
			eXPrinterStatus = EPSIdle;
			eXDetectedErrorState = EDESNoError;
            pStatusStr = IDS_STATUS_OK;

			// but we better check for the status of an associated print job
			PrinterStatusEx ( hPrinter, printerStatus, detectedErrorState, pStatusStr , t_Status );
		}

        default:
		{
            // dang, got some other unrecognized status value.
            // we'll punt...

            // first, set de faulty values
            printerStatus = PSUnknown;
            detectedErrorState = DESUnknown;
			eXPrinterStatus = EPSUnknown;
			eXDetectedErrorState = EDESUnknown;
            pStatusStr = IDS_STATUS_Unknown;

            // then try to get the info another way.

            PrinterStatusEx ( hPrinter, printerStatus, detectedErrorState, pStatusStr , t_Status );
		}
        break;
	}

    // I know - this makes a ctor fire.  Since we don't have dual interfaces this'll work no matter how we're compiled.

    pInstance->SetCHString ( IDS_Status , pStatusStr ) ;
    pInstance->SetWBEMINT16 ( IDS_PrinterStatus , printerStatus ) ;
    pInstance->SetWBEMINT16 ( IDS_DetectedErrorState , detectedErrorState ) ;
	pInstance->SetWBEMINT16 ( EXTENDEDPRINTERSTATUS, eXPrinterStatus );
	pInstance->SetWBEMINT16 ( EXTENDEDDETECTEDERRORSTATE, eXDetectedErrorState );

	pInstance->SetDWORD ( L"PrinterState" , t_Status ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// second try to get some status.
// we'll use EnumJobs to try to get a little more info.

void CWin32Printer :: PrinterStatusEx (

	HANDLE hPrinter,
	PrinterStatuses &printerStatus,
	DetectedErrorStates &detectedErrorState,
	LPCWSTR &pStatusStr ,
	DWORD &a_Status
)
{
	DWORD dwSpaceNeeded = 0 ;
	DWORD dwReturneddwJobs = 0 ;

    // ASSUMPTION! we only have to pull one job off of the stack to see if it's okay...
    
    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        ::EnumJobs (

		    hPrinter,
		    0,
		    1,
		    1,
		    NULL,
		    0,
		    &dwSpaceNeeded,
		    &dwReturneddwJobs
	    ) ;

        if ( GetLastError () == ERROR_INSUFFICIENT_BUFFER )
        {
            LPBYTE lpBuffer = new BYTE [ dwSpaceNeeded + 2 ] ;

            if ( lpBuffer )
		    {
			    try
			    {
				    JOB_INFO_1 *pJobInfo = (JOB_INFO_1*)lpBuffer;

				    BOOL t_EnumStatus = EnumJobs (

					    hPrinter,
					    0,
					    1,
					    1,
					    lpBuffer,
					    dwSpaceNeeded,
					    &dwSpaceNeeded,
					    &dwReturneddwJobs
				    ) ;

				    if ( t_EnumStatus )
				    {
					    if ( dwReturneddwJobs )
					    {
						    
						    // map the Job to the printer state
						    if( JOB_STATUS_PAUSED & pJobInfo->Status )
						    {
							    a_Status |= PRINTER_STATUS_PAUSED ;
						    }

						    if( JOB_STATUS_ERROR & pJobInfo->Status )
						    {
							    a_Status |= PRINTER_STATUS_ERROR ;
						    }

						    if( JOB_STATUS_DELETING & pJobInfo->Status )
						    {
							    a_Status |= PRINTER_STATUS_PENDING_DELETION ;
						    }

						    if( JOB_STATUS_SPOOLING & pJobInfo->Status )
						    {
							    a_Status |= PRINTER_STATUS_PROCESSING ;
						    }

						    if( JOB_STATUS_PRINTING & pJobInfo->Status )
						    {
							    a_Status |= PRINTER_STATUS_PRINTING ;
						    }

						    if( JOB_STATUS_OFFLINE & pJobInfo->Status )
						    {
							    a_Status |= PRINTER_STATUS_OFFLINE ;
						    }

						    if( JOB_STATUS_PAPEROUT & pJobInfo->Status )
						    {
							    a_Status |= PRINTER_STATUS_PAPER_OUT ;
						    }

						    if( JOB_STATUS_PRINTED & pJobInfo->Status )
						    {
							    a_Status |= PRINTER_STATUS_PRINTING ;
						    }
						    
						    if( JOB_STATUS_DELETED & pJobInfo->Status )
						    {
							    a_Status |= PRINTER_STATUS_PENDING_DELETION ;
						    }

						    if( JOB_STATUS_USER_INTERVENTION & pJobInfo->Status )
						    {
							    a_Status |= PRINTER_STATUS_USER_INTERVENTION ;
						    }

						    // ain't a gonna parse a string
						    // if we got a string status, we'll accept the defaults

						    if ( pJobInfo->pStatus == NULL )
						    {
							    // status
							    if( (	JOB_STATUS_ERROR	| JOB_STATUS_OFFLINE |
									    JOB_STATUS_DELETING | JOB_STATUS_PAPEROUT |
									    JOB_STATUS_PAUSED	| JOB_STATUS_PRINTED ) & pJobInfo->Status )
							    {
								    printerStatus = PSOther ;
							    }
							    else if( ( JOB_STATUS_PRINTING | JOB_STATUS_SPOOLING ) & pJobInfo->Status )
							    {
								    printerStatus = PSPrinting ;	
							    }
							    else
							    {
								    // passed default
							    }
							    
							    // error state
							    if( JOB_STATUS_PAPEROUT & pJobInfo->Status )
							    {
								    detectedErrorState = DESNoPaper ;
							    }
							    else if( JOB_STATUS_OFFLINE & pJobInfo->Status )
							    {
								    detectedErrorState = DESOffline ;
							    }
							    else if( JOB_STATUS_ERROR & pJobInfo->Status )
							    {
								    detectedErrorState = DESUnknown ;
							    }
							    else if( (	JOB_STATUS_DELETING | JOB_STATUS_PAUSED |
										    JOB_STATUS_PRINTED  | JOB_STATUS_PRINTING |
										    JOB_STATUS_SPOOLING ) & pJobInfo->Status )
							    {
								    detectedErrorState = DESNoError ;
							    }
							    else
							    {
								    // passed default
							    }
							    
							    // status string
							    if( ( JOB_STATUS_ERROR | JOB_STATUS_PAPEROUT ) & pJobInfo->Status )
							    {
								    pStatusStr = IDS_STATUS_Error;
							    }
							    else if( JOB_STATUS_OFFLINE & pJobInfo->Status )
							    {
								    pStatusStr = IDS_STATUS_Degraded;
							    }
							    else if( JOB_STATUS_DELETING & pJobInfo->Status )
							    {
								    pStatusStr = IDS_STATUS_Degraded;
							    }
							    else if( (	JOB_STATUS_PAUSED  | JOB_STATUS_PRINTING |
										    JOB_STATUS_PRINTED | JOB_STATUS_SPOOLING ) & pJobInfo->Status )
							    {
								    pStatusStr = IDS_STATUS_OK;
							    }
							    else
							    {
								    // passed default
							    }
						    }
					    }
					    else
					    {

					    // there was a job a second ago, but not now.  Sounds good to me

						    printerStatus = PSIdle;
						    detectedErrorState = DESUnknown;
						    pStatusStr = IDS_STATUS_Unknown;
					    }
				    }
			    }
			    catch ( ... )
			    {
				    delete [] lpBuffer ;

				    throw ;
			    }

			    delete [] lpBuffer ;

		    }
		    else
		    {
			    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		    }
        }
        else
	    {
            if ( ( GetLastError () == 0 ) && ( dwSpaceNeeded == 0 ) )
		    {
	            // no error & no jobs - he's (probably) idle, but we can't be sure about errors

                printerStatus = PSIdle;
                detectedErrorState = DESUnknown;
                pStatusStr = IDS_STATUS_Unknown;
            }
	    }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::GetDeviceCapabilities
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// get the device caps
// set Horz & vert resolutions

void CWin32Printer :: GetDeviceCapabilities (

	CInstance *pInstance ,
	LPCTSTR pDevice,    // pointer to a printer-name string																				
	LPCTSTR pPort,      // pointer to a port-name string
	CONST DEVMODE *pDevMode
)
{
#ifdef NTONLY
    // there seems to be a severe error in DeviceCapabilities(DC_PAPERNAMES) for Win98
	// it *intermittently* GPFs when handed perfectly valid arguments, then it tries to
	// convince me that there are 6,144 different papernames available when it does run
	// I DON'T THINK SO! skip over the offensive code & get on with our lives...
	// I note that 6144 is evenly divisible by 64, perhaps that's indiciative of the problem?


	// determine list of available paper
	// call with NULL to find out how many we have

    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
	    DWORD dwNames = ::DeviceCapabilities (

		    pDevice ,
		    pPort,
		    DC_PAPERNAMES,
		    NULL,
		    pDevMode
	    ) ;

        if ( ( 0 != dwNames ) && ( -1 != dwNames ) )
        {
            TCHAR *pNames = new TCHAR [ ( dwNames + 2 ) * 64 ] ;
            if ( pNames )
            {
			    try
			    {
				    memset ( pNames, '\0', ( dwNames + 2 ) * 64 * sizeof(TCHAR)) ;

				    dwNames = ::DeviceCapabilities (

					    pDevice ,
					    pPort ,
					    DC_PAPERNAMES ,
					    pNames ,
					    pDevMode
				    ) ;

				    if ( ( 0 != dwNames ) && ( -1 != dwNames )  )
				    {
					    SAFEARRAYBOUND rgsabound[1];
					    rgsabound[0].cElements = dwNames;
					    rgsabound[0].lLbound = 0;

                        variant_t vValue;

					    V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
					    if ( V_ARRAY(&vValue) )
					    {
						    V_VT(&vValue) = VT_ARRAY | VT_BSTR;
						    long ix[1];

						    for ( int i = 0 ; i < dwNames; i++ )
						    {
							    TCHAR *pName = pNames + i * 64 ;

							    bstr_t bstrTemp = (pName);
							    ix[0] = i ;

							    HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , (wchar_t*)bstrTemp ) ;
							    if ( t_Result == E_OUTOFMEMORY )
							    {
								    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							    }
						    }

						    pInstance->SetVariant ( L"PrinterPaperNames", vValue ) ;
					    }
					    else
					    {
						    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					    }
				    }
			    }
                catch(Structured_Exception se)
                {
                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                }
			    catch ( ... )
			    {
				    delete [] pNames ;
                    throw;
			    }

			    delete [] pNames ;
            }
		    else
		    {
			    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		    }
        }

	    // call with NULL to find out how many we have

	    DWORD dwPapers = ::DeviceCapabilities (

		    pDevice,
		    pPort,
		    DC_PAPERS,
		    NULL,
		    pDevMode
	    ) ;

	    if ( ( 0 != dwPapers ) && ( -1 != dwPapers ) )
	    {
		    WORD *pPapers = new WORD [ dwPapers * sizeof ( WORD ) ] ;
		    if ( pPapers )
		    {
			    try
			    {
				    memset ( pPapers , '\0', ( dwPapers + 2 ) * sizeof ( WORD ) ) ;

				    dwPapers = ::DeviceCapabilities (

					    pDevice ,
					    pPort ,
					    DC_PAPERS ,
					    ( LPTSTR ) pPapers ,
					    pDevMode
				    ) ;

				    if ( ( 0 != dwPapers ) && ( -1 != dwPapers ) )
				    {
					    SAFEARRAYBOUND rgsabound [ 1 ] ;
					    rgsabound[0].cElements = dwPapers ;
					    rgsabound[0].lLbound = 0 ;

                        variant_t vValue;

					    V_ARRAY(&vValue) = SafeArrayCreate ( VT_I2 , 1 , rgsabound ) ;
					    if ( V_ARRAY(&vValue) )
					    {
						    V_VT(&vValue) = VT_ARRAY | VT_I2;
						    long ix[1];

						    for ( int i = 0; i < dwPapers ; i++ )
						    {
							    WORD wVal = MapValue ( pPapers [ i ] ) ;
							    ix[0] = i ;

							    HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , & wVal ) ;
							    if ( t_Result == E_OUTOFMEMORY )
							    {
								    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							    }
						    }

						    pInstance->SetVariant ( L"PaperSizesSupported" , vValue ) ;
					    }
					    else
					    {
						    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					    }
				    }
			    }
                catch(Structured_Exception se)
                {
                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                }
			    catch ( ... )
			    {
				    delete [] pPapers ;

				    throw ;
			    }

                delete [] pPapers ;
            }
		    else
		    {
			    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		    }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
    }

#endif

	GetDevModeGoodies ( pInstance , pDevMode ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32Printer :: GetDevModeGoodies (

	CInstance *pInstance,
	CONST DEVMODE *pDevMode
)
{
	if ( pDevMode )
	{
		//Get the resolution - it can be in the form of "X x Y" or just "X dpi".
		if ( pDevMode->dmFields & DM_YRESOLUTION )
        {
			pInstance->SetDWORD ( IDS_VerticalResolution , pDevMode->dmYResolution ) ;
			pInstance->SetDWORD ( IDS_HorizontalResolution , pDevMode->dmPrintQuality ) ;
        }
		else if ( pDevMode->dmFields & DM_PRINTQUALITY )
        {
			pInstance->SetDWORD ( IDS_VerticalResolution , pDevMode->dmPrintQuality ) ;
			pInstance->SetDWORD ( IDS_HorizontalResolution , pDevMode->dmPrintQuality ) ;
        }

		// safearry for strings

		SAFEARRAYBOUND rgsabound[1];
		rgsabound[0].cElements = 0;
		rgsabound[0].lLbound = 0;

        variant_t vValueI2, vValueBstr;
		V_VT(&vValueI2) = VT_ARRAY | VT_I2;
		V_VT(&vValueBstr) = VT_ARRAY | VT_BSTR ;

		V_ARRAY(&vValueI2) = SafeArrayCreate ( VT_I2 , 1, rgsabound ) ;
		V_ARRAY(&vValueBstr) = SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ;

		if ( V_ARRAY(&vValueI2) && V_ARRAY(&vValueBstr) )
		{
			long ix[1];

			ix[0] =0;
			int count = 0;

			if (pDevMode->dmFields & DM_COPIES)
			{
				ix[0] = count ++ ;
				rgsabound[0].cElements = count;

				HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValueI2) ,rgsabound ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				t_Result = SafeArrayRedim ( V_ARRAY(&vValueBstr) ,rgsabound ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				DWORD dwVal = 4;
				t_Result = SafeArrayPutElement ( V_ARRAY(&vValueI2) , ix , & dwVal ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				bstr_t bstrTemp (IDS_Copies);
				t_Result = SafeArrayPutElement ( V_ARRAY(&vValueBstr) , ix , (wchar_t*)bstrTemp ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}	
			
			if (pDevMode->dmFields & DM_COLOR)
			{
				ix[0] = count++;
				rgsabound[0].cElements = count;

				HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValueI2) ,rgsabound ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				t_Result = SafeArrayRedim ( V_ARRAY(&vValueBstr) ,rgsabound ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				DWORD dwVal = 2;
				t_Result = SafeArrayPutElement ( V_ARRAY(&vValueI2) , ix , & dwVal ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				bstr_t bstrTemp (IDS_Color);
				t_Result = SafeArrayPutElement ( V_ARRAY(&vValueBstr) , ix , (wchar_t*)bstrTemp ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}	
			
			if (pDevMode->dmFields & DM_DUPLEX)
			{
				ix[0] = count++;
				rgsabound[0].cElements = count;

				HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValueI2) ,rgsabound ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				t_Result = SafeArrayRedim ( V_ARRAY(&vValueBstr) ,rgsabound ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				DWORD dwVal = 3;
				t_Result = SafeArrayPutElement ( V_ARRAY(&vValueI2) , ix , & dwVal ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				bstr_t bstrTemp (IDS_Duplex);
				t_Result = SafeArrayPutElement ( V_ARRAY(&vValueBstr) , ix , (wchar_t*)bstrTemp ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}	
			
			if (pDevMode->dmFields & DM_COLLATE)
			{
				ix[0] = count++;
				rgsabound[0].cElements = count;

				HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValueI2) ,rgsabound ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				t_Result = SafeArrayRedim ( V_ARRAY(&vValueBstr) ,rgsabound ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}


				DWORD dwVal = 5;
				t_Result = SafeArrayPutElement ( V_ARRAY(&vValueI2) , ix , & dwVal ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				bstr_t bstrTemp (IDS_Collate);
				t_Result = SafeArrayPutElement ( V_ARRAY(&vValueBstr) , ix , (wchar_t*)bstrTemp ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}	
			
			pInstance->SetVariant ( IDS_Capabilities , vValueI2 ) ;

			// Now for the strings

			pInstance->SetVariant(L"CapabilityDescriptions", vValueBstr) ;
		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

WORD CWin32Printer :: MapValue ( WORD wPaper )
{
    WORD wRetPaper;

    switch ( wPaper )
	{
		case DMPAPER_LETTER:               /* Letter 8 1/2 x 11 in               */
		{
			wRetPaper = 7;
		}
		break;

		case DMPAPER_LETTERSMALL:          /* Letter Small 8 1/2 x 11 in         */
		{
			wRetPaper = 7;
		}
		break;

		case DMPAPER_TABLOID:              /* Tabloid 11 x 17 in                 */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_LEDGER:               /* Ledger 17 x 11 in                  */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_LEGAL:                /* Legal 8 1/2 x 14 in                */
		{
			wRetPaper = 8;
		}
		break;

		case DMPAPER_STATEMENT:            /* Statement 5 1/2 x 8 1/2 in         */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_EXECUTIVE:            /* Executive 7 1/4 x 10 1/2 in        */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A3:                   /* A3 297 x 420 mm                    */
		{
			wRetPaper = 21;
		}
		break;

		case DMPAPER_A4:                   /* A4 210 x 297 mm                    */
		{
			wRetPaper = 22;
		}
		break;

		case DMPAPER_A4SMALL:              /* A4 Small 210 x 297 mm              */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A5:                   /* A5 148 x 210 mm                    */
		{
			wRetPaper = 23;
		}
		break;

		case DMPAPER_B4:                   /* B4 (JIS) 250 x 354                 */
		{
			wRetPaper = 54;
		}
		break;

		case DMPAPER_B5:                   /* B5 (JIS) 182 x 257 mm              */
		{
			wRetPaper = 55;
		}
		break;

		case DMPAPER_FOLIO:                /* Folio 8 1/2 x 13 in                */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_QUARTO:               /* Quarto 215 x 275 mm                */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_10X14:                /* 10x14 in                           */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_11X17:                /* 11x17 in                           */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_NOTE:                 /* Note 8 1/2 x 11 in                 */
		{
			wRetPaper = 7;
		}
		break;

		case DMPAPER_ENV_9:                /* Envelope #9 3 7/8 x 8 7/8          */
		{
			wRetPaper = 15;
		}
		break;

		case DMPAPER_ENV_10:               /* Envelope #10 4 1/8 x 9 1/2         */
		{
			wRetPaper = 11;
		}
		break;

		case DMPAPER_ENV_11:               /* Envelope #11 4 1/2 x 10 3/8        */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_12:               /* Envelope #12 4 \276 x 11           */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_14:               /* Envelope #14 5 x 11 1/2            */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_CSHEET:               /* C size sheet                       */
		{
			wRetPaper = 4;
		}
		break;

		case DMPAPER_DSHEET:               /* D size sheet                       */
		{
			wRetPaper = 5;
		}
		break;

		case DMPAPER_ESHEET:               /* E size sheet                       */
		{
			wRetPaper = 6;
		}
		break;

		case DMPAPER_ENV_DL:               /* Envelope DL 110 x 220mm            */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_C5:               /* Envelope C5 162 x 229 mm           */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_C3:               /* Envelope C3  324 x 458 mm          */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_C4:               /* Envelope C4  229 x 324 mm          */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_C6:               /* Envelope C6  114 x 162 mm          */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_C65:              /* Envelope C65 114 x 229 mm          */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_B4:               /* Envelope B4  250 x 353 mm          */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_B5:               /* Envelope B5  176 x 250 mm          */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_B6:               /* Envelope B6  176 x 125 mm          */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_ITALY:            /* Envelope 110 x 230 mm              */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_MONARCH:          /* Envelope Monarch 3.875 x 7.5 in    */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_PERSONAL:         /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_FANFOLD_US:           /* US Std Fanfold 14 7/8 x 11 in      */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_FANFOLD_STD_GERMAN:   /* German Std Fanfold 8 1/2 x 12 in   */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_FANFOLD_LGL_GERMAN:   /* German Legal Fanfold 8 1/2 x 13 in */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ISO_B4:               /* B4 (ISO) 250 x 353 mm              */
		{
			wRetPaper = 49;
		}
		break;

		case DMPAPER_JAPANESE_POSTCARD:    /* Japanese Postcard 100 x 148 mm     */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_9X11:                 /* 9 x 11 in                          */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_10X11:                /* 10 x 11 in                         */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_15X11:                /* 15 x 11 in                         */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_ENV_INVITE:           /* Envelope Invite 220 x 220 mm       */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_RESERVED_48:          /* RESERVED--DO NOT USE               */
		{
			wRetPaper = 0;
		}
		break;

		case DMPAPER_RESERVED_49:          /* RESERVED--DO NOT USE               */
		{
			wRetPaper = 0;
		}
		break;

		case DMPAPER_LETTER_EXTRA:         /* Letter Extra 9 \275 x 12 in        */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_LEGAL_EXTRA:          /* Legal Extra 9 \275 x 15 in         */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_TABLOID_EXTRA:        /* Tabloid Extra 11.69 x 18 in        */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A4_EXTRA:             /* A4 Extra 9.27 x 12.69 in           */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_LETTER_TRANSVERSE:    /* Letter Transverse 8 \275 x 11 in   */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A4_TRANSVERSE:        /* A4 Transverse 210 x 297 mm         */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_LETTER_EXTRA_TRANSVERSE: /* Letter Extra Transverse 9\275 x 12 in */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A_PLUS:               /* SuperA/SuperA/A4 227 x 356 mm      */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_B_PLUS:               /* SuperB/SuperB/A3 305 x 487 mm      */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_LETTER_PLUS:          /* Letter Plus 8.5 x 12.69 in         */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A4_PLUS:              /* A4 Plus 210 x 330 mm               */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A5_TRANSVERSE:        /* A5 Transverse 148 x 210 mm         */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_B5_TRANSVERSE:        /* B5 (JIS) Transverse 182 x 257 mm   */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A3_EXTRA:             /* A3 Extra 322 x 445 mm              */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A5_EXTRA:             /* A5 Extra 174 x 235 mm              */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_B5_EXTRA:             /* B5 (ISO) Extra 201 x 276 mm        */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A2:                   /* A2 420 x 594 mm                    */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A3_TRANSVERSE:        /* A3 Transverse 297 x 420 mm         */
		{
			wRetPaper = 1;
		}
		break;

		case DMPAPER_A3_EXTRA_TRANSVERSE:  /* A3 Extra Transverse 322 x 445 mm   */
		{
			wRetPaper = 1;
		}
		break;

		default:
		{
			wRetPaper = 1;
		}
		break;
    }

    return wRetPaper ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Printer::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32Printer :: GetDefaultPrinter ( CHString &a_Printer )
{

#if NTONLY >= 5

    DWORD cchBufferLength = 0;
    BOOL  bStatus         = ::GetDefaultPrinter(NULL, &cchBufferLength);

    if (!bStatus && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        CSmartBuffer Buffer(cchBufferLength * sizeof(TCHAR));

        bStatus = ::GetDefaultPrinter(reinterpret_cast<LPTSTR>(static_cast<LPBYTE>(Buffer)), 
                                      &cchBufferLength);

        if (bStatus) 
        {
            //
            // The cast is very important, otherwise a_Printer will be updated only
            // with the first tchar in the buffer. The CSmartBuffer class has a set of 
            // overloaded operator= methods. Without the cast, the compiler will think
            // we are assigning a TCHAR instead of a LPTSTR
            //
            a_Printer = reinterpret_cast<LPCTSTR>(static_cast<LPBYTE>(Buffer));
        }
    }

#else

    BOOL bStatus = FALSE;
    SetLastError(ERROR_FILE_NOT_FOUND);

#endif
    
    return bStatus ;
}

//
// The buffer size needed to hold the maximum printer name.
//

#if NTONLY != 5

#define MAX_UNC_PRINTER_NAME 200

enum { kPrinterBufMax_  = MAX_UNC_PRINTER_NAME + 1 };

#define COUNTOF(x) (sizeof x/sizeof *x)
#define EQ(x) = x

LPCTSTR szNULL                  EQ( TEXT( "" ));
LPCTSTR szWindows               EQ( TEXT( "Windows" ));
LPCTSTR szDevice                EQ( TEXT( "Device" ));

/*++

Name:

    GetDefaultPrinter

Description:

    The GetDefaultPrinter function retrieves the printer
    name of the current default printer.

Arguments:

    pBuffer     - Points to a buffer to receive the null-terminated
                  character string containing the default printer name.
                  This parameter may be null if the caller want the size of
                  default printer name.

    pcchBuffer   - Points to a variable that specifies the maximum size,
                  in characters, of the buffer. This value should be
                  large enough to contain 2 + INTERNET_MAX_HOST_NAME_LENGTH
                  + 1 MAX_PATH + 1 characters.

Return Value:

    If the function succeeds, the return value is nonzero and
    the variable pointed to by the pnSize parameter contains the
    number of characters copied to the destination buffer,
    including the terminating null character.

    If the function fails, the return value is zero. To get extended
    error information, call GetLastError.

Notes:

    If this function fails with a last error of ERROR_INSUFFICIENT_BUFFER
    the variable pointed to by pcchBuffer is returned with the number of
    characters needed to hold the printer name including the
    terminating null character.

--*/
BOOL
CWin32Printer::GetDefaultPrinter(
    IN LPTSTR   pszBuffer,
    IN LPDWORD  pcchBuffer
    )
{
    BOOL    bRetval = FALSE;
    LPTSTR  psz     = NULL;
    UINT    uLen    = 0;
    TCHAR   szDefault[kPrinterBufMax_+MAX_PATH];

    //
    // Validate the size parameter.
    //
    if( !pcchBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return bRetval;
    }

    //
    // Get the devices key, which is the default device or printer.
    //

    bool fGotProfileString = false;

    try
    {
        fGotProfileString = WMIRegistry_ProfileString(szWindows, szDevice, szNULL, szDefault, COUNTOF(szDefault));
    }
    catch(...)
    {
        throw;
    }
    
    if(fGotProfileString)
    {
        //
        // The string is returned in the form.
        // "printer_name,winspool,Ne00:" now convert it to
        // printer_name
        //
        psz = _tcschr( szDefault, TEXT( ',' ));

        //
        // Set the comma to a null.
        //
        if( psz )
        {
            *psz = 0;

            //
            // Check if the return buffer has enough room for the printer name.
            //
            uLen = _tcslen( szDefault );

            if( uLen < *pcchBuffer && pszBuffer )
            {
                //
                // Copy the default printer name to the prvided buffer.
                //
                _tcscpy( pszBuffer, szDefault );

                bRetval = TRUE;

#if 0
                DBGMSG( DBG_TRACE,( "GetDefaultPrinter: Success " TSTR "\n", pszBuffer ) );
#endif
            }
            else
            {
#if 0
                DBGMSG( DBG_WARN,( "GetDefaultPrinter: buffer too small.\n" ) );
#endif
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
            }

            //
            // Return back the size of the default printer name.
            //
            *pcchBuffer = uLen + 1;
        }
        else
        {
#if 0
            DBGMSG( DBG_WARN,( "GetDefaultPrinter: comma not found in printer name in devices section.\n" ) );
#endif
            SetLastError( ERROR_INVALID_NAME );
        }
    }
    else
    {
#if 0
        DBGMSG( DBG_TRACE,( "GetDefaultPrinter: failed with %d Last error %d.\n", bRetval, GetLastError() ) );
        DBGMSG( DBG_TRACE,( "GetDefaultPrinter: No default printer.\n" ) );
#endif

        SetLastError( ERROR_FILE_NOT_FOUND );
    }

    return bRetval;
}

#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::ExecMethod
*
*  DESCRIPTION :    Implementing the Printer Methods for the provider out here
*
*****************************************************************************/

HRESULT CWin32Printer :: ExecMethod (

    const CInstance &Instance,
    const BSTR bstrMethodName,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags
)
{
#if NTONLY >= 5

    HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    if (pOutParams)
    {
        if (!_wcsicmp(bstrMethodName, METHOD_SETDEFAULTPRINTER))
        {
            hRes = ExecSetDefaultPrinter(Instance, pInParams, pOutParams, lFlags);
        }
        else if (!_wcsicmp(bstrMethodName , METHOD_PAUSEPRINTER))
        {
            hRes = ExecSetPrinter(Instance, pInParams, pOutParams, lFlags, PRINTER_CONTROL_PAUSE);
        }
        else if (!_wcsicmp(bstrMethodName , METHOD_RESUME_PRINTER))
        {
            hRes = ExecSetPrinter(Instance, pInParams, pOutParams, lFlags, PRINTER_CONTROL_RESUME);
        }
        else if (!_wcsicmp(bstrMethodName, METHOD_CANCEL_ALLJOBS))
        {
            hRes = ExecSetPrinter(Instance, pInParams, pOutParams, lFlags, PRINTER_CONTROL_PURGE);
        }
        else if (!_wcsicmp(bstrMethodName, METHOD_RENAME_PRINTER))
        {
            hRes = ExecRenamePrinter(Instance, pInParams, pOutParams);
        }
        else if (!_wcsicmp(bstrMethodName, METHOD_TEST_PAGE))
        {
            hRes = ExecPrintTestPage(Instance, pInParams, pOutParams);
        }
        else if (!_wcsicmp(bstrMethodName, METHOD_ADD_PRINTER_CONNECTION))
        {
            hRes = ExecAddPrinterConnection(Instance, pInParams, pOutParams);
        }
        else
        {
            hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::ExecSetDefaultPrinter
*
*  DESCRIPTION :    This method sets the default printer, if it is not already
*					Set as a Default printer
*
*****************************************************************************/
#if NTONLY >= 5

HRESULT CWin32Printer :: ExecSetDefaultPrinter (

    const CInstance &Instance,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags
)
{
    CHString    t_Printer;
    DWORD       dwError;
    HRESULT     hRes       = WBEM_S_NO_ERROR;
    BOOL        bLocalCall = FALSE;

    dwError = IsLocalCall(&bLocalCall);

    hRes    = WinErrorToWBEMhResult(dwError);

    if (SUCCEEDED(hRes))
    {
        hRes = WBEM_E_NOT_SUPPORTED;

        if (bLocalCall)
        {
            hRes = WBEM_S_NO_ERROR;

            if (!Instance.GetCHString(IDS_DeviceID, t_Printer))
            {
            hRes = WBEM_E_PROVIDER_FAILURE;
            }

            if (SUCCEEDED(hRes))
            {
                hRes = WBEM_E_FAILED;

                //
                // We reached to point where we call the method, report success to WMI
                //
                hRes    = WBEM_S_NO_ERROR;

                dwError = ERROR_SUCCESS;

                if (!::SetDefaultPrinter((LPTSTR)(LPCTSTR)t_Printer))
                {
                    dwError = GetLastError();
                }

                SetReturnValue(pOutParams, dwError);

            }
        }
    }

    return hRes;
}

#endif

/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::ExecSetPrinter
*
*  DESCRIPTION :    The SetPrinter function sets the data for a specified printer
*                   or sets the state of the specified printer by pausing printing,
*                   resuming printing, or clearing all print jobs.
*
*****************************************************************************/
HRESULT CWin32Printer :: ExecSetPrinter (

    const CInstance &Instance,
    CInstance *pInParams,
    CInstance *pOutParams,
    long lFlags,
    DWORD dwState
)
{
#if NTONLY==5
    CHString  t_Printer;
    DWORD     dwError;
    HRESULT   hRes = WBEM_S_NO_ERROR;

    hRes = InstanceGetString(Instance, IDS_DeviceID, &t_Printer, kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        hRes = WBEM_E_FAILED;

        SmartClosePrinter hPrinter;
        PRINTER_DEFAULTS PrinterDefaults = {NULL, NULL, PRINTER_ACCESS_ADMINISTER};

        hRes    = WBEM_S_NO_ERROR;
        dwError = ERROR_SUCCESS;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            if (::OpenPrinter(const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Printer)) ,&hPrinter, &PrinterDefaults))
            {
                if (!::SetPrinter(hPrinter, 0, NULL, dwState))
                {
                    dwError = GetLastError();
                }
            }
            else
            {
                dwError = GetLastError();
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            dwError = ERROR_DLL_NOT_FOUND;
            hRes = WBEM_E_FAILED;
        }

        SetReturnValue(pOutParams, dwError);        

    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    : CWin32Printer::PutInstance
*
*  DESCRIPTION : Adding a Printer if it doesnt exist
*
*****************************************************************************/

HRESULT CWin32Printer :: PutInstance  (

    const CInstance &Instance,
    long lFlags
)
{
#if NTONLY >= 5

    HRESULT hRes        = WBEM_S_NO_ERROR;
    DWORD   dwError;
    DWORD   dwOperation = WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE;

    switch(lFlags & dwOperation)
    {
    case WBEM_FLAG_CREATE_OR_UPDATE:
    case WBEM_FLAG_CREATE_ONLY:
    case WBEM_FLAG_UPDATE_ONLY:
        {
            //
            // Get all the necessary parameters
            //
            PRINTER_INFO_2W pPrnInfo = {0};
            CHString        t_Printer;
            CHString        t_Driver;
            CHString        t_Port;
            CHString        t_Share;
            CHString        t_Comment;
            CHString        t_Location;
            CHString        t_SepFile;
            CHString        t_PrintProc;
            CHString        t_DataType;
            CHString        t_Params;
            CHString        t_StartTime;
            CHString        t_UntilTime;
            SYSTEMTIME      st                = {0};
            DWORD           dwPriority        = 0;
            DWORD           dwDefaultPriority = 0;
            DWORD           dwAttributes      = 0;
            BOOL            bValue;

            hRes = InstanceGetString(Instance, IDS_DeviceID, &t_Printer, kFailOnEmptyString);

            //
            // Special case when the flag for PutInstance is CREATE_OR_UPDATE.
            // We need to check if the printer exists, then update it. If it does
            // not exist then create it
            //
            if (SUCCEEDED(hRes) && lFlags==WBEM_FLAG_CREATE_OR_UPDATE)
            {
                hRes = WBEM_E_FAILED;

                SmartClosePrinter  hPrinter;
                PRINTER_DEFAULTS   PrinterDefaults = {NULL, NULL, PRINTER_READ};

                hRes = WBEM_S_NO_ERROR;

                // Use of delay loaded functions requires exception handler.
                SetStructuredExceptionHandler seh;
                try
                {
                    if (::OpenPrinter(const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Printer)),
                                                  reinterpret_cast<LPHANDLE>(&hPrinter),
                                                  &PrinterDefaults))
                    {
                        //
                        // Printer exsits, so we do an update
                        //
                        lFlags = WBEM_FLAG_UPDATE_ONLY;

                        DBGMSG(DBG_TRACE, (L"CWin32_Printer::PutInstance update printer\n"));
                    }
                    else
                    {
                        //
                        // Regardless why OpenPrinter failed, try a create
                        //
                        lFlags = WBEM_FLAG_CREATE_ONLY;

                        DBGMSG(DBG_TRACE, (L"CWin32_Printer::PutInstance create printer\n"));
                    }
                }
                catch(Structured_Exception se)
                {
                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                    hRes = WBEM_E_FAILED;
                }

            }

            //
            // Continue getting property values
            //
            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pPrinterName = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Printer));

                hRes = InstanceGetString(Instance, IDS_DriverName, &t_Driver, kFailOnEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pDriverName = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Driver));

                hRes = InstanceGetString(Instance, IDS_ShareName, &t_Share, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pShareName = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Share));

                hRes = InstanceGetString(Instance, IDS_PortName, &t_Port, kFailOnEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pPortName = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Port));

                hRes = InstanceGetString(Instance, IDS_Comment, &t_Comment, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pComment = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Comment));

                hRes = InstanceGetString(Instance, IDS_Location, &t_Location, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pLocation = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Location));

                hRes = InstanceGetString(Instance, IDS_SeparatorFile, &t_SepFile, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pSepFile = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_SepFile));

                //
                // SplPrinterXXX will default the print proc to winprint, but we cannot
                //
                hRes = InstanceGetString(Instance, IDS_PrintProcessor, &t_PrintProc, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pPrintProcessor = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_PrintProc));

                //
                // SplPrinterXXX will default the data typ to RAW, if not present or empty
                //
                hRes = InstanceGetString(Instance, IDS_PrintJobDataType, &t_DataType, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pDatatype = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_DataType));

                hRes = InstanceGetString(Instance, IDS_Parameters, &t_Params, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.pParameters = const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Params));

                hRes = InstanceGetDword(Instance, IDS_Priority, &dwPriority);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.Priority = dwPriority;

                hRes = InstanceGetDword(Instance, IDS_DefaultPriority, &dwDefaultPriority);
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.DefaultPriority = dwDefaultPriority;

                hRes = InstanceGetString(Instance, IDS_StartTime, &t_StartTime, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                if (t_StartTime.IsEmpty())
                {
                    //
                    // SplPrinterSet will know -1 means not set
                    //
                    pPrnInfo.StartTime = (DWORD)-1;
                }
                else
                {
                    hRes = ConvertCIMTimeToSystemTime(t_StartTime, &st);

                    if (SUCCEEDED(hRes))
                    {
                        pPrnInfo.StartTime = LocalTimeToPrinterTime(st);
                    }
                }
            }

            if (SUCCEEDED(hRes))
            {
                hRes = InstanceGetString(Instance, IDS_UntilTime, &t_UntilTime, kAcceptEmptyString);
            }

            if (SUCCEEDED(hRes))
            {
                if (t_UntilTime.IsEmpty())
                {
                    //
                    // SplPrinterSet will know -1 means not set
                    //
                    pPrnInfo.UntilTime = (DWORD)-1;
                }
                else
                {
                    hRes = ConvertCIMTimeToSystemTime(t_UntilTime, &st);

                    if (SUCCEEDED(hRes))
                    {
                        pPrnInfo.UntilTime = LocalTimeToPrinterTime(st);
                    }
                }
            }

            if (SUCCEEDED(hRes))
            {
                //
                // Get the attributes
                //
                for (UINT uIndex = 0; SUCCEEDED(hRes) && uIndex < sizeof(AttributeTable)/sizeof(AttributeTable[0]); uIndex++)
                {
                    hRes = InstanceGetBool(Instance, AttributeTable[uIndex].BoolName, &bValue);

                    if (SUCCEEDED(hRes) && bValue)
                    {
                        dwAttributes |= AttributeTable[uIndex].Bit;
                    }
                }
            }

            if (SUCCEEDED(hRes))
            {
                pPrnInfo.Attributes = dwAttributes;

                dwError = lFlags & WBEM_FLAG_CREATE_ONLY ? SplPrinterAdd(pPrnInfo) : SplPrinterSet(pPrnInfo);

                hRes = WinErrorToWBEMhResult(dwError);

                if (FAILED(hRes))
                {
                    SetErrorObject(Instance, dwError, pszPutInstance);
                }
            }
        }

        break;

    default:
        hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer:: DeleteInstance
*
*  DESCRIPTION :    Deleting a Printer
*
*****************************************************************************/

HRESULT CWin32Printer :: DeleteInstance (

    const CInstance &Instance,
    long lFlags
)
{
#if NTONLY == 5
    HRESULT  hRes = WBEM_E_PROVIDER_FAILURE;
    CHString t_Printer;
    DWORD    dwError;
    BOOL     bLocalCall = TRUE;
    DWORD    dwAttributes = 0;

    hRes = InstanceGetString(Instance, IDS_DeviceID, &t_Printer , kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        dwError = SplPrinterGetAttributes(t_Printer, &dwAttributes);

        hRes = WinErrorToWBEMhResult(dwError);
    }

    if (SUCCEEDED(hRes))
    {
        if (dwAttributes & PRINTER_ATTRIBUTE_LOCAL)
        {
            dwError = SplPrinterDel(t_Printer);

            hRes = WinErrorToWBEMhResult(dwError);

            if (FAILED(hRes))
            {
                SetErrorObject(Instance, dwError, pszDeleteInstance);
            }
        }
        else
        {
            //
            // We are dealing with a printer connection
            //
            dwError = IsLocalCall(&bLocalCall);

            hRes    = WinErrorToWBEMhResult(dwError);

            if (SUCCEEDED(hRes))
            {
                if (bLocalCall)
                {
                    hRes = WBEM_E_FAILED;

                    hRes = WBEM_S_NO_ERROR;

                    if (!::DeletePrinterConnection(const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Printer))))
                    {
                        dwError = GetLastError();

                        hRes = WinErrorToWBEMhResult(dwError);

                        SetErrorObject(Instance, dwError, pszDeleteInstance);
                    }

                }
                else
                {
                    //
                    // Deleting connections on remote machine not supported
                    //
                    hRes = WBEM_E_NOT_SUPPORTED;
                }
            }
        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif

}


/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::PrintTestPage
*
*  DESCRIPTION :    This method will rename a given printer
*
*****************************************************************************/

HRESULT CWin32Printer :: ExecPrintTestPage (

    const CInstance &Instance,
    CInstance *pInParams,
    CInstance *pOutParams
)
{
#if NTONLY >= 5
    CHString    t_Printer;
    HRESULT     hRes = WBEM_S_NO_ERROR;

    hRes = InstanceGetString(Instance, IDS_DeviceID, &t_Printer, kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        DWORD dwError = SplPrintTestPage(t_Printer);

        SetReturnValue(pOutParams, dwError);
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::AddPrinterConnection
*
*  DESCRIPTION :    This method will rename a given printer
*
*****************************************************************************/

HRESULT CWin32Printer :: ExecAddPrinterConnection (

    const CInstance &Instance,
    CInstance *pInParams,
    CInstance *pOutParams
)
{
#if NTONLY==5
    CHString t_Printer;
    HRESULT	 hRes       = WBEM_E_NOT_SUPPORTED;
    BOOL     bLocalCall = TRUE;
    DWORD    dwError    = ERROR_SUCCESS;

    dwError = IsLocalCall(&bLocalCall);

    hRes    = WinErrorToWBEMhResult(dwError);

    if (SUCCEEDED(hRes))
    {
        hRes = WBEM_E_NOT_SUPPORTED;

        if (bLocalCall)
        {
            hRes = WBEM_E_INVALID_PARAMETER;

            if (pInParams)
            {
                hRes = InstanceGetString(*pInParams, METHOD_ARG_NAME_PRINTER, &t_Printer, kFailOnEmptyString);

                if (SUCCEEDED (hRes))
                {
                    hRes = WBEM_E_NOT_FOUND;

                    //
                    // We reached to point where we call the method, report success to WMI
                    //
                    hRes = WBEM_S_NO_ERROR;

                    dwError = ERROR_SUCCESS;

                    // Use of delay loaded functions requires exception handler.
                    SetStructuredExceptionHandler seh;

                    try
                    {
                        if (!::AddPrinterConnection(const_cast<LPWSTR>(static_cast<LPCWSTR>(t_Printer))))
                        {
                            dwError = GetLastError();
                        }
                    }
                    catch(Structured_Exception se)
                    {
                        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                        dwError = ERROR_DLL_NOT_FOUND;
                        hRes = WBEM_E_FAILED;
                    }

                    SetReturnValue(pOutParams, dwError);
                }
            }
        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CWin32Printer::RenamePrinter
*
*  DESCRIPTION :    This method will rename a given printer
*
*****************************************************************************/

HRESULT CWin32Printer :: ExecRenamePrinter (

    const CInstance &Instance,
    CInstance *pInParams,
    CInstance *pOutParams
)
{
#if NTONLY >= 5
    CHString    t_NewPrinterName;
    CHString    t_OldPrinterName;
    HRESULT     hRes = WBEM_S_NO_ERROR;

    hRes = InstanceGetString(Instance, IDS_DeviceID, &t_OldPrinterName, kFailOnEmptyString);

    if (SUCCEEDED (hRes))
    {
        hRes = InstanceGetString(*pInParams, METHOD_ARG_NAME_NEWPRINTERNAME, &t_NewPrinterName, kFailOnEmptyString);
    }

    if (SUCCEEDED(hRes))
    {
        DWORD dwError = SplPrinterRename(t_OldPrinterName, t_NewPrinterName);

        SetReturnValue(pOutParams, dwError);
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printercontroller.h ===
//=================================================================

//

// PrinterController.h -- PrinterController association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_PRINTERCONTROLLER L"Win32_PrinterController"

class CWin32PrinterController : public Provider
{
    
public:
    
    // Constructor/destructor
    //=======================
    
    CWin32PrinterController( LPCWSTR strName, LPCWSTR pszNamespace ) ;
    ~CWin32PrinterController() ;
    
    // Functions provide properties with current values
    //=================================================
    
    virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
    virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
    
    // Utility
    //========
    
private:
    
    void ParsePort( LPCWSTR szPort, CHStringArray &chsaPrinterPortNames );
    HRESULT EnumPortsForPrinter(CInstance*      pPrinter,
        TRefPointerCollection<CInstance>& portList,
        MethodContext* pMethodContext );
    
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printercontroller.cpp ===
//=================================================================

//

// PrinterController.cpp -- PrinterController association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

#include "precomp.h"
#include "PrinterController.h"

CWin32PrinterController MyPrinterController(PROPSET_NAME_PRINTERCONTROLLER, IDS_CimWin32Namespace);

CWin32PrinterController::CWin32PrinterController( LPCWSTR strName, LPCWSTR pszNamespace )
:	Provider( strName, pszNamespace )
{
}

CWin32PrinterController::~CWin32PrinterController ( void )
{
}

HRESULT CWin32PrinterController::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
    HRESULT		hr	=	WBEM_S_NO_ERROR;

    // Perform queries
    //================

    TRefPointerCollection<CInstance>	printerList;
    TRefPointerCollection<CInstance>	portList;

    CInstancePtr pPrinter;

    REFPTRCOLLECTION_POSITION	pos;

    // Get all the printers and all the ports.

    // !!! NOTE !!!
    // It is barely possible that some of the items under cim_controller may have some sort of key that look like the entries
    // in the printer port.  This code doesn't check for this.

    CHString sQuery1(_T("SELECT __RELPATH, PortName FROM Win32_Printer"));
    CHString sQuery2(_T("SELECT __RELPATH, DeviceID FROM CIM_Controller"));

    // grab all of both items that could be endpoints
    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery1, &printerList, pMethodContext, IDS_CimWin32Namespace))
        &&
        SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery2, &portList, pMethodContext, IDS_CimWin32Namespace)))

    {
        if ( printerList.BeginEnum( pos ) )
        {

            // For each printer, check the ports list for associations

            for (pPrinter.Attach(printerList.GetNext( pos )) ;
                    SUCCEEDED(hr) && ( pPrinter != NULL ) ;
                    pPrinter.Attach(printerList.GetNext( pos )) )
            {
                hr = EnumPortsForPrinter( pPrinter, portList, pMethodContext );
            }	// IF GetNext Computer System

            printerList.EndEnum();

        }	// IF BeginEnum

    }	// IF GetInstancesByQuery

    return hr;

}

HRESULT CWin32PrinterController::EnumPortsForPrinter(
                                                      CInstance*							pPrinter,
                                                      TRefPointerCollection<CInstance>&	portList,
                                                      MethodContext*						pMethodContext )
{

    HRESULT		hr	=	WBEM_S_NO_ERROR;

    CInstancePtr pPort;
    CInstancePtr pInstance;

    REFPTRCOLLECTION_POSITION	pos;

    CHString	strPrinterPath,
        strPortPath;

    // Pull out the object path of the printer as the various
    // ports object paths will be associated to this value

    if ( GetLocalInstancePath( pPrinter, strPrinterPath ) )
    {

        // The PortName element is actually a comma delimited list that contains all the ports for this printer.
        // So, to do the association, I just walk that list and find the matching item in cim_controller.  If there
        // is no match, I'm assuming that this printer port is not something I can do an association to, and return
        // no instance.
        CHStringArray chsaPrinterPortNames;
        CHString sPrinterPortString, sPrinterPortName;
        CHString sPortPortName;
        pPrinter->GetCHString(IDS_PortName, sPrinterPortString);

        // Parse the comma delimited string into a chstringarray
        ParsePort(sPrinterPortString, chsaPrinterPortNames);

        // Walk the array and find a match
        for (DWORD x = 0; x < chsaPrinterPortNames.GetSize(); x++)
        {
            sPrinterPortName = chsaPrinterPortNames[x];

            if ( portList.BeginEnum( pos ) )
            {

                for (pPort.Attach(portList.GetNext( pos ));
                     SUCCEEDED(hr) && ( pPort != NULL ) ;
                    pPort.Attach(portList.GetNext( pos )))
                {

                    // Check if we have an association
                    pPort->GetCHString(IDS_DeviceID, sPortPortName);
                    if (sPortPortName.CompareNoCase(sPrinterPortName) == 0)
                    {
                        // Get the path to the port object and create us an association.

                        if ( GetLocalInstancePath( pPort, strPortPath ) )
                        {

                            pInstance.Attach(CreateNewInstance( pMethodContext ));

                            if ( NULL != pInstance )
                            {
                                pInstance->SetCHString( IDS_Dependent, strPrinterPath );
                                pInstance->SetCHString( IDS_Antecedent, strPortPath );

                                // Invalidates pointer
                                hr = pInstance->Commit(  );
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }

                        }	// IF GetPath to Port Object

                    }	// IF AreAssociated

                }	// WHILE GetNext

                portList.EndEnum();

            }	// IF BeginEnum
        }

    }	// IF GetLocalInstancePath

    return hr;

}

HRESULT CWin32PrinterController::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    HRESULT		hr;

    CInstancePtr pPrinter;
    CInstancePtr pPort;

    CHString	strPrinterPath,
        strPortPath;

    pInstance->GetCHString( IDS_Dependent, strPrinterPath );
    pInstance->GetCHString( IDS_Antecedent, strPortPath );

    // First see if both objects exist

    if (	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strPrinterPath, &pPrinter, pInstance->GetMethodContext() ))
        &&	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strPortPath, &pPort, pInstance->GetMethodContext() )) )
    {
        CHString sPrinterClass, sPortClass;

        hr = WBEM_E_NOT_FOUND;

        // Just because the object exists, doesn't mean that it is a printer.  Conceivably, we
        // could have been passed a (valid) path to a win32_bios

        pPrinter->GetCHString(IDS___Class, sPrinterClass);
        pPort->GetCHString(IDS___Class, sPortClass);

        if ((sPrinterClass.CompareNoCase(L"Win32_Printer") == 0) &&
            (CWbemProviderGlue::IsDerivedFrom(L"CIM_Controller", sPortClass, pInstance->GetMethodContext(), IDS_CimWin32Namespace )) )
        {
            // The PortName element is actually a comma delimited list that contains all the ports for this printer.
            // So, to do the association, I just walk that list, and find the matching item in cim_controller.  If there
            // is no match, I'm assuming that this printer port is not something I can do an association to, and return
            // no instance.
            CHStringArray chsaPrinterPortNames;
            CHString sPrinterPortString, sPrinterPortName, sPortPortName;

            if (pPrinter->GetCHString(IDS_PortName, sPrinterPortString))
            {
                ParsePort(sPrinterPortString, chsaPrinterPortNames);
                for (DWORD x = 0; x < chsaPrinterPortNames.GetSize(); x++)
                {
                    sPrinterPortName = chsaPrinterPortNames[x];

                    if (pPort->GetCHString(IDS_DeviceID, sPortPortName))
                    {
                        if (sPortPortName.CompareNoCase(sPrinterPortName) == 0)
                        {
                            // Got one
                            hr = WBEM_S_NO_ERROR;
                            break;
                        }
                    }
                }
            }
        }
    }

    return ( hr );
}

void CWin32PrinterController::ParsePort( LPCWSTR szPortNames, CHStringArray &chsaPrinterPortNames )
{
    // While I trim spaces in this routine, further testing suggests that putting spaces in this registry
    // key causes the printer wizard to not function correctly.  After observing this, I decided that putting even
    // more sophisticated parsing in would not be productive.

    int nFind;
    CHString sTemp(szPortNames), sTemp2;

    sTemp.TrimLeft();

    chsaPrinterPortNames.RemoveAll();

    if (!sTemp.IsEmpty())
    {

        // While there is a comma in the string
        while ((nFind = sTemp.Find(_T(','))) > 0)
        {
            sTemp2 = sTemp.Left(nFind);
            sTemp2.TrimRight();

            // Add it to the array
            chsaPrinterPortNames.Add(sTemp2.Left(sTemp2.GetLength() - 1));

            // Re-adjust the string
            sTemp = sTemp.Mid(nFind + 1);
            sTemp.TrimLeft();
        }

        // Process the remaining (or only) entry
        sTemp.TrimRight();

        if (sTemp[sTemp.GetLength()-1] == _T(':'))
        {
            sTemp = sTemp.Left(sTemp.GetLength()-1);
        }

        chsaPrinterPortNames.Add(sTemp);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printerdriver.h ===
//=================================================================

//

// PrinterDriver.h -- PrinterDriver association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_PrinterDriver L"Win32_PrinterDriverDLL"

typedef std::map<CHString, CHString> STRING2STRING;

class CWin32PrinterDriver : public Provider
{
    
public:
    
    // Constructor/destructor
    //=======================
    
    CWin32PrinterDriver( LPCWSTR strName, LPCWSTR pszNamespace ) ;
    ~CWin32PrinterDriver() ;
    
    // Functions provide properties with current values
    //=================================================
    
    virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
    virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
    
private:
    void CWin32PrinterDriver::PopulateDriverMap(STRING2STRING &printerDriverMap);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printerdriver.cpp ===
//=================================================================

//

// PrinterDriver.cpp -- PrinterDriver association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

#include "precomp.h"
#include <objpath.h>
#include <DllWrapperBase.h>
#include <WinSpool.h>
#include "prnutil.h"
#include "PrinterDriver.h"
#include <map>

CWin32PrinterDriver MyPrinterDriver(PROPSET_NAME_PrinterDriver, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrinterDriver::CWin32PrinterDriver
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for provider.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PrinterDriver::CWin32PrinterDriver(LPCWSTR strName, LPCWSTR pszNamespace )
: Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrinterDriver::~CWin32PrinterDriver
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32PrinterDriver::~CWin32PrinterDriver ( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32PrinterDriver::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32PrinterDriver::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
    HRESULT  hr = WBEM_S_NO_ERROR;

    // Perform queries
    //================

    TRefPointerCollection<CInstance> printerList;
    CHString sPrinterPath, sPrinterDriverName, sDriverPath;

    // Load the drivers into a map
    STRING2STRING printerDriverMap;
    STRING2STRING::iterator      mapIter;

    PopulateDriverMap(printerDriverMap);

    CInstancePtr pPrinter;

    REFPTRCOLLECTION_POSITION pos;

    // Get all the printers, their attributes, and Driver names

    CHString sQuery1(_T("SELECT __PATH, __RELPATH, DriverName FROM Win32_Printer"));

    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery1, &printerList, pMethodContext, IDS_CimWin32Namespace)))
    {
        if ( printerList.BeginEnum( pos ) )
        {

            for (pPrinter.Attach(printerList.GetNext( pos )) ;
                SUCCEEDED(hr) && (pPrinter != NULL );
                pPrinter.Attach(printerList.GetNext( pos )) )
            {

                pPrinter->GetCHString(IDS_DriverName, sPrinterDriverName);

                // See if this driver is in the map
                if( ( mapIter = printerDriverMap.find( sPrinterDriverName ) ) != printerDriverMap.end() )
                {

                    // Grab the path from the printer
                    pPrinter->GetCHString(IDS___Path, sPrinterPath);

                    CInstancePtr pInstance(CreateNewInstance( pMethodContext ), false);
                    // Construct the path for the other end.

                    // Note, it is possible (in fact easy) to have instances where the driver name
                    // isn't really valid.  Per stevm, we should return the instance anyway.

                    CHString sTemp;
                    EscapeBackslashes((*mapIter).second, sTemp);

                    sDriverPath.Format(L"\\\\%s\\%s:CIM_Datafile.Name=\"%s\"",
                        GetLocalComputerName(), IDS_CimWin32Namespace, sTemp);

                    pInstance->SetCHString( IDS_Antecedent, sDriverPath);
                    pInstance->SetCHString( IDS_Dependent, sPrinterPath);

                    hr = pInstance->Commit(  );
                }
            } // IF GetNext Computer System

            printerList.EndEnum();

        } // IF BeginEnum

    } // IF GetInstancesByQuery

    return hr;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32PrinterDriver::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32PrinterDriver::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    HRESULT  hr;

    CInstancePtr pPrinter;

    CHString sPrinterPath, sDriverName, sDriverClass, sDriverPath;

    // Get the two paths they want verified
    pInstance->GetCHString( IDS_Antecedent, sDriverPath );
    pInstance->GetCHString( IDS_Dependent, sPrinterPath );

    // Since we allow for the fact that the Driver may not really be there, we can't
    // use GetObjectByPath the resolve everything for us.  Instead, we must manually
    // parse the object path.
    ParsedObjectPath*    pParsedPath = 0;
    CObjectPathParser    objpathParser;

    // Parse the object path passed to us by CIMOM
    // ==========================================
    int nStatus = objpathParser.Parse( bstr_t(sDriverPath),  &pParsedPath );

    // One of the biggest if statements I've ever written.
    if ( 0 == nStatus )                                                // Did the parse succeed?
    {
        try
        {
            if ((pParsedPath->IsInstance()) &&                                  // Is the parsed object an instance?
            (_wcsicmp(pParsedPath->m_pClass, L"CIM_Datafile") == 0) &&       // Is this the class we expect (no, cimom didn't check)
            (pParsedPath->m_dwNumKeys == 1) &&                              // Does it have exactly one key
            (pParsedPath->m_paKeys[0]) &&                                   // Is the keys pointer null (shouldn't happen)
            ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                 // Key name not specified or
            (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_Name) == 0)) &&  // key name is the right value
                                                                            // (no, cimom doesn't do this for us).
            (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&    // Check the variant type (no, cimom doesn't check this either)
            (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )         // And is there a value in it?
            {

                sDriverName = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);
            }
        }
        catch ( ... )
        {
            objpathParser.Free( pParsedPath );
            throw ;
        }

        // Clean up the Parsed Path
        objpathParser.Free( pParsedPath );
    }

    // First see if the printer exists
    if ( SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( sPrinterPath, &pPrinter, pInstance->GetMethodContext() )) )
    {
        CHString sPrinterClass, sPrinterDriverName;

        hr = WBEM_E_NOT_FOUND;

        // Just because the object exists, doesn't mean that it is a printer.  Conceivably, we
        // could have been passed a (valid) path to a win32_bios

        pPrinter->GetCHString(IDS___Class, sPrinterClass);
        if (sPrinterClass.CompareNoCase(L"Win32_Printer") == 0)
        {
            if (pPrinter->GetCHString(IDS_DriverName, sPrinterDriverName))
            {

                // Load the drivers into a map
                STRING2STRING printerDriverMap;
                STRING2STRING::iterator      mapIter;

                PopulateDriverMap(printerDriverMap);

                // See if this driver is in the map
                if( ( mapIter = printerDriverMap.find( sPrinterDriverName ) ) != printerDriverMap.end() )
                {

                    // Do the names match?
                    if (sDriverName.CompareNoCase((*mapIter).second) == 0)
                    {
                        // Got one
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            }
        }
    }

    return ( hr );
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32PrinterDriver::PopulateDriverMap
//
//	Inputs:		STRING2STRING &printerDriverMap - map to fill with driver names
//
//	Outputs:	None.
//
//	Returns:	None.
//
//	Comments:
//
////////////////////////////////////////////////////////////////////////

void CWin32PrinterDriver::PopulateDriverMap(STRING2STRING &printerDriverMap)
{
	DRIVER_INFO_3 *pDriverInfo = NULL;
	DWORD dwNeeded, dwReturned;

	// Get the size

    // Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;
    try
    {
	    ::EnumPrinterDrivers(NULL, NULL, 3, (BYTE *)pDriverInfo, 0, &dwNeeded, &dwReturned);

	    // Allocate the memory and try again
	    pDriverInfo = (DRIVER_INFO_3 *)new BYTE[dwNeeded];

	    if (pDriverInfo != NULL)
	    {
		    try
		    {
			    if (::EnumPrinterDrivers(NULL, NULL, 3, (BYTE *)pDriverInfo, dwNeeded, &dwNeeded, &dwReturned))
			    {
				    // Put the entries into the map
				    for (DWORD x=0; x < dwReturned; x++)
				    {
					    printerDriverMap[pDriverInfo[x].pName] = pDriverInfo[x].pDriverPath;
				    }
			    }
			    else
			    {
				    LogErrorMessage2(L"Can't EnumPrinterDrivers: %d", GetLastError());
			    }
		    }
            catch(Structured_Exception se)
            {
                DelayLoadDllExceptionFilter(se.GetExtendedInfo());    
            }
		    catch ( ... )
		    {
			    delete []pDriverInfo;
			    throw ;
		    }

		    delete []pDriverInfo;
	    }
	    else
	    {
		    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	    }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printerdriver2.h ===
/******************************************************************

   PrinterDriver.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef  _CPrinterDriver_H_
#define  _CPrinterDriver_H_

//
// Provider Name
//
#define PROVIDER_NAME_PRINTERDRIVER		L"Win32_PrinterDriver"

class CPrinterDriver : public Provider 
{
public:

        CPrinterDriver (LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);

        virtual ~CPrinterDriver () ;

        virtual HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L ) ;
		virtual HRESULT PutInstance  ( const CInstance &Instance, long lFlags );
		virtual HRESULT DeleteInstance ( const CInstance &Instance,  long lFlags );
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery &Query);
        
        virtual HRESULT ExecMethod(const CInstance& Instance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags = 0L);

private:

		HRESULT LoadInstance        (      CInstance *pInstance, DRIVER_INFO_6 *DriverInfo);
		HRESULT FindAndGetDriver    (      CInstance *pInstance);
		HRESULT GetAllPrinterDrivers(      BYTE*     &a_DriverInfo, DWORD     &dwNoDrivers);
        HRESULT ExecAddPrinterDriver(      CInstance *pInParams,    CInstance *pOutParams);

#ifdef _WMI_DELETE_METHOD_
        HRESULT ExecDelPrinterDriver(      CInstance *pInParams,    CInstance *pOutParams);
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printerport.h ===
//////////////////////////////////////////////////////////////////////

//

//  PRINTERPORT.h  - header file for printer ports functionality

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  03/27/2000    amaxa  Created.
//
//////////////////////////////////////////////////////////////////////


#define PROPSET_NAME_TCPPRINTERPORT L"Win32_TCPIPPrinterPort"

                                                                    
class CWin32TCPPrinterPort : public Provider
{
public:
    
    CWin32TCPPrinterPort(
        LPCWSTR strName, 
        LPCWSTR pszNamespace
        );

    ~CWin32TCPPrinterPort(
        VOID
        );

    virtual 
    HRESULT 
    ExecQuery( 
        MethodContext    *pMethodContext, 
        CFrameworkQuery&  pQuery, 
        long              lFlags = 0L);

    virtual 
    HRESULT 
    GetObject( 
        CInstance       *pInstance, 
        long             lFlags, 
        CFrameworkQuery &pQuery);

    virtual 
    HRESULT 
    EnumerateInstances( 
        MethodContext *pMethodContext, 
        long           lFlags = 0L);
    
    
    virtual 
    HRESULT 
    PutInstance( 
        const CInstance &Instance,  
              long       lFlags);

    virtual 
    HRESULT 
    DeleteInstance( 
        const CInstance &Instance,  
              long       lFlags);
        
private:
    
    enum EScope {
        kComplete,
        kKeys
    };

    HRESULT 
    CollectInstances(
        IN MethodContext *pMethodContext,
        IN EScope         eScope
        );

    static
    HRESULT
    GetExpensiveProperties(
        IN LPCWSTR       pszPort, 
        IN CInstance    &Instance
        );    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printerport.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  PRINTERPORT.CPP

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  03/27/2000    amaxa  Created
//
//////////////////////////////////////////////////////////////////////

#include <precomp.h>
#include <DllWrapperBase.h>
#include <WinSpool.h>
#include "printerport.h"
#include "prnutil.h"
#include "prninterface.h"

LPCWSTR kStandardTCP   = L"Standard TCP/IP Port";
LPCWSTR kPortName      = L"Name";
LPCWSTR kProtocol      = L"Protocol";
LPCWSTR kHostAddress   = L"HostAddress";
LPCWSTR kSNMPCommunity = L"SNMPCommunity";
LPCWSTR kByteCount     = L"ByteCount";
LPCWSTR kQueue         = L"Queue";
LPCWSTR kPortNumber    = L"PortNumber";
LPCWSTR kSNMPEnabled   = L"SNMPEnabled";
LPCWSTR kSNMPDevIndex  = L"SNMPDevIndex";

//
// Property set declaration
//=========================
//
CWin32TCPPrinterPort win32TCPPrinterPort(PROPSET_NAME_TCPPRINTERPORT, IDS_CimWin32Namespace);

/*++

Routine Name

    CWin32TCPPrinterPort::CWin32TCPPrinterPort

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/
CWin32TCPPrinterPort :: CWin32TCPPrinterPort (

    IN LPCWSTR strName,
    IN LPCWSTR pszNamespace

) : Provider ( strName, pszNamespace )
{
}

/*++

Routine Name

    CWin32TCPPrinterPort::~CWin32TCPPrinterPort

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
CWin32TCPPrinterPort::~CWin32TCPPrinterPort()
{
}

/*++

Routine Name

    CWin32TCPPrinterPort::ExecQuery

Routine Description:

    Executes a query on a Win32_TCPIPPrinterPort

Arguments:

    pMethodContext - pointer to method context
    lFlags         - flags
    pQuery         - query object

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
ExecQuery(
    MethodContext *pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags /*= 0L*/
    )
{
#if NTONLY >= 5

    HRESULT hRes = WBEM_E_NOT_FOUND;

    EScope eScope = kComplete;
    //
    // Getting only the key, whih is the port name, is cheap and requires no special privileges.
    // Getting the complete configuration of ports requires admin privileges
    //
    if (pQuery.KeysOnly())
    {
        eScope = kKeys;
    }

    hRes = CollectInstances(pMethodContext, eScope);

    return hRes;

#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*++

Routine Name

    CWin32TCPPrinterPort::GetObject

Routine Description:

    Gets an instances of a Win32_TCPIPPrinterPort

Arguments:

    pMethodContext - pointer to method context
    lFlags         - flags
    pQuery         - ?

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
GetObject(
    CInstance       *pInstance,
    long             lFlags,
    CFrameworkQuery &pQuery
    )
{
#if NTONLY >= 5

    HRESULT  hRes;
    CHString csPort;

    hRes = InstanceGetString(*pInstance, kPortName, &csPort, kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        SetCreationClassName(pInstance);

        pInstance->SetWCHARSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");

        hRes = GetExpensiveProperties(csPort, *pInstance);
    }

    return hRes;

#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*++

Routine Name

    CWin32TCPPrinterPort::EnumerateInstances

Routine Description:

    Enumerates all instances of Win32_TCPIPPrinterPort

Arguments:

    pMethodContext - pointer to method context
    lFlags         - flags

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
EnumerateInstances(
    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
    )
{
#if NTONLY >= 5

    HRESULT hRes = WBEM_E_NOT_FOUND;

    hRes = CollectInstances(pMethodContext, kComplete);

    return hRes;

#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}


/*++

Routine Name

    CWin32TCPPrinterPort::CollectInstances

Routine Description:

    Retrieves all instances of Win32_TCPIPPrinterPorts as partof an enumeration

Arguments:

    pMethodContext - pointer to method context
    eScope         - what to retrieve; key only or complete port config
    CwinSpoolApi   - reference to winspool wrapper object

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort ::
CollectInstances(
    IN MethodContext *pMethodContext,
    IN EScope         eScope
    )
{
#if NTONLY >= 5
    HRESULT hRes = WBEM_E_NOT_FOUND;

    DWORD  dwError;
    DWORD  cReturned = 0;
    DWORD  cbNeeded  = 0;
    DWORD  cbSize     = 0;
    BYTE  *pPorts     = NULL;

    hRes = WBEM_S_NO_ERROR;

    // Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        if (!::EnumPorts(NULL, 2, NULL, cbSize, &cbNeeded, &cReturned))
        {
            dwError = GetLastError();

            if (dwError==ERROR_INSUFFICIENT_BUFFER)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;

                pPorts = new BYTE[cbSize=cbNeeded];

                if (pPorts)
                {
                    //
                    // The try is to make sure that if an exception occurs, we free the allocated buffer
                    //
                    try
                    {
                        if (::EnumPorts(NULL, 2, pPorts, cbSize, &cbNeeded, &cReturned))
                        {
                            hRes = WBEM_S_NO_ERROR;

                            PORT_INFO_2 *pPortInfo = reinterpret_cast<PORT_INFO_2 *>(pPorts);

                            for (DWORD uIndex = 0; uIndex < cReturned && SUCCEEDED(hRes); uIndex++, pPortInfo++)
                            {
                                //
                                // Check if the port is Standard TCP/IP
                                //
                                if (pPortInfo->pDescription && !wcscmp(pPortInfo->pDescription, kStandardTCP))
                                {
                                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                                    pInstance->SetCHString(kPortName, pPortInfo->pPortName);

                                    if (eScope==kComplete)
                                    {
                                        //
                                        // This needs admin privileges.
                                        //
                                        hRes = GetExpensiveProperties(pPortInfo->pPortName, pInstance);
                                    }

                                    hRes = pInstance->Commit();
                                }
                            }
                        }
                        else
                        {
                            hRes = WinErrorToWBEMhResult(GetLastError());
                        }
                    }
                    catch(Structured_Exception se)
                    {
                        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                        delete [] pPorts;
                        hRes = WBEM_E_FAILED;    
                    }
                    catch(...)
                    {
                        delete [] pPorts;

                        throw;
                    }

                    delete [] pPorts;
                }
            }
            else
            {
                hRes = WinErrorToWBEMhResult(dwError);
            }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo()); 
        hRes = WBEM_E_FAILED;   
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*++

Routine Name

    CWin32TCPPrinterPort::PutInstance

Routine Description:

    Adds or updates an instances of Win32_TCPIPPrinterPort

Arguments:

    Instance - reference Instance
    lFlags   - flags

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
PutInstance(
    const CInstance &Instance,
    long            lFlags
    )
{
#if NTONLY >= 5
    HRESULT hRes        = WBEM_S_NO_ERROR;
    DWORD   dwError;
    DWORD   dwOperation = WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE;

    switch(lFlags & dwOperation)
    {
        case WBEM_FLAG_CREATE_OR_UPDATE:
        case WBEM_FLAG_CREATE_ONLY:
        case WBEM_FLAG_UPDATE_ONLY:
        {
            //
            // Get all the necessary parameters
            //
            PORT_DATA_1     PortData = {0};
            CHString        t_Port;
            CHString        t_HostAddress;
            CHString        t_SNMPCommunity;
            CHString        t_Queue;
            
            //
            // Get port name. This is a required parameter
            //
            if (SUCCEEDED(hRes = InstanceGetString(Instance, kPortName, &t_Port, kFailOnEmptyString)))
            {
                if (t_Port.GetLength() < MAX_PORTNAME_LEN)
                {
                    wcscpy(PortData.sztPortName, static_cast<LPCWSTR>(t_Port));
                }
                else
                {
                    hRes = WBEM_E_INVALID_PARAMETER;
                }
            }

            //
            // Special case when the flag for PutInstance is CREATE_OR_UPDATE.
            // We need to check if the port exists, then update it. If it does
            // not exist then create it
            //
            if (SUCCEEDED(hRes) && 
                (lFlags == WBEM_FLAG_CREATE_OR_UPDATE || lFlags == WBEM_FLAG_UPDATE_ONLY))
            {
                dwError = SplTCPPortGetConfig(t_Port, &PortData);

                switch(dwError)
                {
                case ERROR_SUCCESS:
                    lFlags = WBEM_FLAG_UPDATE_ONLY;
                    DBGMSG(DBG_TRACE, (L"CWin32TCPPrinterPort::PutInstance update instance\n"));
                    break;

                case ERROR_UNKNOWN_PORT:
                case ERROR_INVALID_PRINTER_NAME:
                    lFlags = WBEM_FLAG_CREATE_ONLY;
                    DBGMSG(DBG_TRACE, (L"CWin32TCPPrinterPort::PutInstance create instance\n"));
                    break;

                default:
                    hRes = WinErrorToWBEMhResult(dwError);
                    DBGMSG(DBG_TRACE, (L"CWin32TCPPrinterPort::PutInstance Error %u\n", dwError));
                }                
            }

            if (SUCCEEDED(hRes))
            {
                //
                // Get host address. This is a required parameter only for create.
                //
                if (SUCCEEDED(hRes = InstanceGetString(Instance, kHostAddress, &t_HostAddress, kFailOnEmptyString)))
                {
                    //
                    // Validate argument
                    //
                    if (t_HostAddress.GetLength() < MAX_NETWORKNAME_LEN)
                    {
                        wcscpy(PortData.sztHostAddress, static_cast<LPCWSTR>(t_HostAddress));
                    }
                    else
                    {
                        hRes = WBEM_E_INVALID_PARAMETER;
                    }
                }
                else if (lFlags == WBEM_FLAG_UPDATE_ONLY) 
                {
                    //
                    // We are in update mode. The user did not specify a host address, so we
                    // keep the host address of the port that we update
                    //
                    hRes = WBEM_S_NO_ERROR;
                }
            }

            //
            // Get protocol.
            //
            if (SUCCEEDED(hRes) &&
                SUCCEEDED(hRes = InstanceGetDword(Instance, kProtocol, &PortData.dwProtocol, PortData.dwProtocol)))
            {
                BOOL bDummy;

                switch (PortData.dwProtocol) 
                {
                case 0:

                    //
                    // No protocol was spcified in input. If we are in the update mode
                    // then we keep the setting of the exisiting port that we are updating 
                    //
                    if (lFlags == WBEM_FLAG_CREATE_ONLY) 
                    {
                        //
                        // Go out on the net and get the device settings
                        //
                        DBGMSG(DBG_TRACE, (L"Trying to default TCP settings\n"));

                        hRes = GetDeviceSettings(PortData) ? WBEM_S_NO_ERROR : WBEM_E_INVALID_PARAMETER;
                    }
                    break;

                case LPR:

                    //
                    // Get arguments specific to LPR port. Queue name
                    //
                    if (SUCCEEDED(hRes = InstanceGetString(Instance, kQueue, &t_Queue, kFailOnEmptyString)))
                    {
                        //
                        // Validate argument
                        //
                        if (t_Queue.GetLength() < MAX_QUEUENAME_LEN)
                        {
                            wcscpy(PortData.sztQueue, static_cast<LPCWSTR>(t_Queue));
                        }
                        else
                        {
                            hRes = WBEM_E_INVALID_PARAMETER;
                        }
                    }
                    else if (lFlags == WBEM_FLAG_UPDATE_ONLY) 
                    {
                        //
                        // No queue specified and we are in update mode
                        // We simply keep the queue name of the existing port
                        //
                        hRes = WBEM_S_NO_ERROR;
                    }

                    //
                    // Check if byte counting is enabled. If the user didn't specify any value for it,
                    // we take the default value of what we have already in the port data structure
                    //
                    if (SUCCEEDED(hRes))
                    {
                        hRes = InstanceGetBool(Instance, 
                                               kByteCount, 
                                               &bDummy,
                                               PortData.dwDoubleSpool);

                        PortData.dwDoubleSpool = bDummy;
                    }
                    
                    //
                    // We do not need a break here. We have common code for lpr and raw
                    //

                case RAWTCP:
                    
                    if (SUCCEEDED(hRes = InstanceGetBool(Instance, 
                                                         kSNMPEnabled, 
                                                         &bDummy, 
                                                         PortData.dwSNMPEnabled)) &&
                        (PortData.dwSNMPEnabled = bDummy))
                    {
                        //
                        // Get community name
                        //
                        if (SUCCEEDED(InstanceGetString(Instance, kSNMPCommunity, &t_SNMPCommunity, kFailOnEmptyString)))
                        {
                            if (t_SNMPCommunity.GetLength() < MAX_SNMP_COMMUNITY_STR_LEN)
                            {
                                wcscpy(PortData.sztSNMPCommunity, t_SNMPCommunity);
                            }
                            else
                            {
                                hRes = WBEM_E_INVALID_PARAMETER;
                            }
                        }
                        else if (lFlags == WBEM_FLAG_UPDATE_ONLY) 
                        {
                            //
                            // For update case, we simply keep the exisiting community name
                            //
                            hRes = WBEM_S_NO_ERROR;
                        }

                        //
                        // Get device index
                        //
                        if (SUCCEEDED(hRes))
                        {
                            hRes = InstanceGetDword(Instance, kSNMPDevIndex, &PortData.dwSNMPDevIndex, PortData.dwSNMPDevIndex);
                        }
                    }

                    if (SUCCEEDED(hRes))
                    {
                        //
                        // Get the port number. If the user did not spcify a port, then we use what we have
                        // in the port data. For create case, we will have a 0, for update case we will
                        // have the port number. 
                        //
                        hRes = InstanceGetDword(Instance, kPortNumber, &PortData.dwPortNumber, PortData.dwPortNumber);
                    }

                    break;

                default:

                    hRes = WBEM_E_INVALID_PARAMETER;
                }
            }

            //
            // Make final call. At thsi stage the PortData contains fields initialized either from
            // the input of the caller or by the function that gets prefeered device settings
            //
            if (SUCCEEDED(hRes))
            {
                dwError = lFlags == WBEM_FLAG_CREATE_ONLY ? SplPortAddTCP(PortData) : SplTCPPortSetConfig(PortData);

                if (FAILED(hRes = WinErrorToWBEMhResult(dwError)))
                {
                    SetErrorObject(Instance, dwError, pszPutInstance);
                }
            }
        }

        break;

    default:
        hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    return hRes;

#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*++

Routine Name

    CWin32TCPPrinterPort::DeleteInstance

Routine Description:

    Deletes an instances of Win32_TCPIPPrinterPort

Arguments:

    Instance - reference Instance
    lFlags   - flags

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
DeleteInstance(
    const CInstance &Instance,
    long lFlags
    )
{
#if NTONLY == 5
    HRESULT  hRes = WBEM_E_PROVIDER_FAILURE;
    CHString t_Port;
    DWORD    dwError;

    hRes = InstanceGetString(Instance, kPortName, &t_Port , kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        dwError = SplPortDelTCP(t_Port);

        hRes    = WinErrorToWBEMhResult(dwError);

        if (FAILED(hRes))
        {
            SetErrorObject(Instance, dwError, pszDeleteInstance);

            //
            // When we call DeleteInstance and there is no Standard TCP port with the specified
            // name, XcvData returns ERROR_UNKNOWN_PORT. WinErrorToWBEMhResult translates that 
            // to Generic Failure. We really need WBEM_E_NOT_FOUND in this case.
            // 
            if (dwError == ERROR_UNKNOWN_PORT)
            {
                hRes = WBEM_E_NOT_FOUND;
            } 
        }
    }

    return hRes;

#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*++

Routine Name

    CWin32TCPPrinterPort::GetExpensiveProperties

Routine Description:

    Gets all the properties of a Win32_TCPIPPrinterPort

Arguments:

    pszPort  - port name
    Instance - reference to Instance
    lFlags   - reference to winspool wrapper object

Return Value:

    WBEM HRESULT

--*/
HRESULT
CWin32TCPPrinterPort::
GetExpensiveProperties(
    IN LPCWSTR       pszPort,
    IN CInstance    &Instance)
{
#if NTONLY >= 5

    HRESULT     hRes;
    PORT_DATA_1 PortData = {0};
    DWORD       dwError;

    dwError = SplTCPPortGetConfig(pszPort, &PortData);

    hRes    = WinErrorToWBEMhResult(dwError);

    if (SUCCEEDED(hRes))
    {
        Instance.SetDWORD   (kProtocol,      PortData.dwProtocol);
        Instance.SetCHString(kHostAddress,   PortData.sztHostAddress);
        Instance.Setbool    (kSNMPEnabled,   PortData.dwSNMPEnabled);

        if (PortData.dwSNMPEnabled)
        {
            Instance.SetCHString(kSNMPCommunity, PortData.sztSNMPCommunity);
            Instance.SetDWORD   (kSNMPDevIndex,  PortData.dwSNMPDevIndex);
        }

        if (PortData.dwProtocol==PROTOCOL_LPR_TYPE)
        {
            if (PortData.sztQueue[0])
            {
                Instance.SetCHString(kQueue, PortData.sztQueue);
            }

            Instance.Setbool(kByteCount, PortData.dwDoubleSpool);
        }

        Instance.SetDWORD(kPortNumber, PortData.dwPortNumber);
    }
    else
    {
        SetErrorObject(Instance, dwError);
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printershare.h ===
//=================================================================

//

// PrinterShare.h -- PrinterShare association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_PrinterShare L"Win32_PrinterShare"

class CWin32PrinterShare : public Provider
{
    
public:
    
    // Constructor/destructor
    //=======================
    
    CWin32PrinterShare(LPCWSTR strName, LPCWSTR pszNamespace ) ;
    ~CWin32PrinterShare() ;
    
    // Functions provide properties with current values
    //=================================================
    
    virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
    virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
    
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printershare.cpp ===
//=================================================================

//

// PrinterShare.cpp -- PrinterShare association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/10/98    davwoh        Created
//
//=================================================================

#include "precomp.h"
#include <objpath.h>
#include <winspool.h>
#include "PrinterShare.h"

CWin32PrinterShare MyPrinterShare(PROPSET_NAME_PrinterShare, IDS_CimWin32Namespace);

CWin32PrinterShare::CWin32PrinterShare(LPCWSTR strName, LPCWSTR pszNamespace )
: Provider( strName, pszNamespace )
{
}

CWin32PrinterShare::~CWin32PrinterShare ( void )
{
}

HRESULT CWin32PrinterShare::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
    HRESULT  hr = WBEM_S_NO_ERROR;

    // Perform queries
    //================

    TRefPointerCollection<CInstance> printerList;
    CHString sPrinterPath, sPrinterShareName, sSharePath;

    CInstancePtr pPrinter;

    REFPTRCOLLECTION_POSITION pos;

    // Get all the printers, their attributes, and share names

    CHString sQuery1(_T("SELECT __PATH, __RELPATH, Attributes, ShareName FROM Win32_Printer"));

    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery1, &printerList, pMethodContext, IDS_CimWin32Namespace)))
    {
        if ( printerList.BeginEnum( pos ) )
        {

            // For each printer, see if it is a locally shared printer
            for (pPrinter.Attach(printerList.GetNext( pos )) ;
                SUCCEEDED(hr) && ( pPrinter != NULL ) ;
                pPrinter.Attach(printerList.GetNext( pos )) )
            {

                DWORD dwAttributes;

                pPrinter->GetDWORD(IDS_Attributes, dwAttributes);

                // If it's not a network printer, but is shared, we've got one
                if (((dwAttributes & PRINTER_ATTRIBUTE_NETWORK) == 0) &&
                    ((dwAttributes & PRINTER_ATTRIBUTE_SHARED)  != 0))
                {
                    // Grab the path fromt the printer
                    pPrinter->GetCHString(IDS___Path, sPrinterPath);

                    CInstancePtr pInstance(CreateNewInstance( pMethodContext ), false);
                    // Construct the path for the other end.

                    // Note, it is possible (in fact easy) to have instances where the share name
                    // isn't really valid.  Per stevm, we should return the instance anyway.
                    pPrinter->GetCHString(IDS_ShareName, sPrinterShareName);
                    sSharePath.Format(L"\\\\%s\\%s:Win32_Share.Name=\"%s\"",
                            GetLocalComputerName(), IDS_CimWin32Namespace, sPrinterShareName);

                    pInstance->SetCHString( IDS_Antecedent, sPrinterPath );
                    pInstance->SetCHString( IDS_Dependent, sSharePath );

                    hr = pInstance->Commit(  );
                }

            } // IF GetNext Computer System

            printerList.EndEnum();

        } // IF BeginEnum

    } // IF GetInstancesByQuery

    return hr;

}

HRESULT CWin32PrinterShare::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    HRESULT  hr;

    CInstancePtr pPrinter;
    CInstancePtr pShare;
    DWORD dwAttributes;

    CHString sPrinterPath, sShareName, sShareClass, sSharePath;

    // Get the two paths they want verified
    pInstance->GetCHString( IDS_Antecedent, sPrinterPath );
    pInstance->GetCHString( IDS_Dependent, sSharePath );

    // Since we allow for the fact that the share may not really be there, we can't
    // use GetObjectByPath the resolve everything for us.  Instead, we must manually
    // parse the object path.
    ParsedObjectPath*    pParsedPath = 0;
    CObjectPathParser    objpathParser;

    // Parse the object path passed to us by CIMOM
    // ==========================================
    int nStatus = objpathParser.Parse( sSharePath,  &pParsedPath );

    // One of the biggest if statements I've ever written.
    if ( 0 == nStatus )                                                 // Did the parse succeed?
    {
        try
        {
            if ((pParsedPath->IsInstance()) &&                                  // Is the parsed object an instance?
                (_wcsicmp(pParsedPath->m_pClass, L"Win32_Share") == 0) &&       // Is this the class we expect (no, cimom didn't check)
                (pParsedPath->m_dwNumKeys == 1) &&                              // Does it have exactly one key
                (pParsedPath->m_paKeys[0]) &&                                   // Is the keys pointer null (shouldn't happen)
                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                 // Key name not specified or
                (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_Name) == 0)) &&  // key name is the right value
                                                                                // (no, cimom doesn't do this for us).
                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&    // Check the variant type (no, cimom doesn't check this either)
                (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )         // And is there a value in it?
            {

                sShareName = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);
            }
        }
        catch ( ... )
        {
            objpathParser.Free( pParsedPath );
            throw ;
        }

        // Clean up the Parsed Path
        objpathParser.Free( pParsedPath );
    }

    // First see if the printer exists
    if ( SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( sPrinterPath, &pPrinter, pInstance->GetMethodContext() )) )
    {
        CHString sPrinterClass, sPrinterShareName;

        hr = WBEM_E_NOT_FOUND;

        // Just because the object exists, doesn't mean that it is a printer.  Conceivably, we
        // could have been passed a (valid) path to a win32_bios

        pPrinter->GetCHString(IDS___Class, sPrinterClass);
        if ((sPrinterClass.CompareNoCase(L"Win32_Printer") == 0) )
        {
            // Note, it is possible (in fact easy) to have instances where the share name
            // isn't really valid.
            //
            // 1) Use printer wizard to add a printer, share it.
            // 2) Use net use <printershare> /d
            //
            // Printer wizard, win32_printer, etc still believe it's shared, but it ain't.
            // Per stevm, we should return the instance anyway.
            if ((pPrinter->GetCHString(IDS_ShareName, sPrinterShareName)) &&
                (pPrinter->GetDWORD(IDS_Attributes, dwAttributes)) )
            {
                // Do the names match?  Is this a local printer?  Is it shared?
                if ((sShareName.CompareNoCase(sPrinterShareName) == 0) &&
                    ((dwAttributes & PRINTER_ATTRIBUTE_NETWORK) == 0) &&
                    ((dwAttributes & PRINTER_ATTRIBUTE_SHARED)  != 0))
                {
                    // Got one
                    hr = WBEM_S_NO_ERROR;
                }
            }
        }
    }

    return ( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printerdriver2.cpp ===
////////////////////////////////////////////////////////////////////////

//

//  PrinterDriver2.CPP -- WMI provider class implementation

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  03/01/2000  a-sandja    Created
//  03/29/2000  amaxa       Added PutInstance, DeleteInstance
//                          ExecAddPrinterDriver, ExecDelPrinterDriver
//
//////////////////////////////////////////////////////////////////////////

#include <precomp.h>
#include <winspool.h>
#include <lockwrap.h>
#include <DllWrapperBase.h>
#include "prninterface.h"
#include "prnutil.h"
#include "printerDriver2.h"


CONST LPCWSTR kAddDriverMethod = L"AddPrinterDriver";

#ifdef _WMI_DELETE_METHOD_
CONST LPCWSTR kDelDriverMethod = L"DeletePrinterDriver";
#endif //_WMI_DELETE_METHOD_

CONST LPCWSTR kDriverName      = L"Name";
CONST LPCWSTR kVersion         = L"Version";
CONST LPCWSTR kEnvironment     = L"SupportedPlatform";
CONST LPCWSTR kDriverPath      = L"DriverPath";
CONST LPCWSTR kDataFile        = L"DataFile";
CONST LPCWSTR kConfigFile      = L"ConfigFile";
CONST LPCWSTR kHelpFile        = L"HelpFile";
CONST LPCWSTR kDependentFiles  = L"DependentFiles";
CONST LPCWSTR kMonitorName     = L"MonitorName";
CONST LPCWSTR kDefaultDataType = L"DefaultDataType";
CONST LPCWSTR kInfName         = L"InfName";
CONST LPCWSTR kFilePath        = L"FilePath";
CONST LPCWSTR kOemUrl          = L"OEMUrl";

CONST LPCWSTR kArgToMethods    = L"DriverInfo";

CONST LPCWSTR kFormatString    = L"%s,%u,%s";


/*****************************************************************************
 *
 *  FUNCTION    :   ConvertDriverKeyToValues
 *
 *  DESCRIPTION :   Helper function. Takes in a string that has the format:
 *                  "string,number,string" that correspomnd to a driver name,
 *                  driver version and environment and returns those entities
 *
 *****************************************************************************/

HRESULT
ConvertDriverKeyToValues(
    IN     CHString  Key,
    IN OUT CHString &DriverName,
    IN OUT DWORD    &dwVersion,
    IN OUT CHString &Environment,
    IN     WCHAR     cDelimiter = L','
    )
{
    HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    if (!Key.IsEmpty())
    {
        CHString t_Middle;

        int iFirst = Key.Find(cDelimiter);
        int iLast  = Key.ReverseFind(cDelimiter);

        if (iFirst>=1 && iLast>=1 && iLast!=iFirst)
        {
            int iLength = Key.GetLength();

            DriverName  = Key.Left(iFirst);
            Environment = Key.Right(iLength - iLast - 1);
            t_Middle    = Key.Mid(iFirst + 1, iLast - iFirst - 1);

            if (1==swscanf(t_Middle, L"%u", &dwVersion))
            {
                hRes = WBEM_S_NO_ERROR;
            }
        }
    }

    return hRes;
}

CPrinterDriver MyPrinterDriver (

	PROVIDER_NAME_PRINTERDRIVER ,
	IDS_CimWin32Namespace
) ;



/*****************************************************************************
 *
 *  FUNCTION    :   CPrinterDriver::CPrinterDriver
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CPrinterDriver :: CPrinterDriver (

	LPCWSTR lpwszName,
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CPrinterDriver::~CPrinterDriver
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CPrinterDriver :: ~CPrinterDriver ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CPrinterDriver :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags
)
{
#if NTONLY >= 5
	HRESULT hRes = WBEM_S_NO_ERROR;

    DWORD dwBytesNeeded = 0;
	DWORD dwNoDrivers = 0;
	BYTE *pDriverInfo;


	hRes = GetAllPrinterDrivers ( pDriverInfo, dwNoDrivers );
	
	if ( SUCCEEDED ( hRes ) && (dwNoDrivers > 0) )
	{
		if ( pDriverInfo != NULL )
		{
			try
			{
				DRIVER_INFO_6 *pNewDriverInfo = ( DRIVER_INFO_6 *) pDriverInfo;

				for ( int i = 0; i < dwNoDrivers; i++, pNewDriverInfo++ )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false );

					hRes = LoadInstance ( pInstance, pNewDriverInfo );
					{
						hRes = pInstance->Commit ();

						if ( FAILED ( hRes ) )
						{
							break;
						}
					}
				}
			}
			catch ( ... )
			{
				delete 	[] pDriverInfo;
				pDriverInfo = NULL;
				throw;
			}
			delete [] pDriverInfo ;
			pDriverInfo = NULL;
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class.
*
*****************************************************************************/

HRESULT CPrinterDriver :: GetObject (

	CInstance *pInstance,
	long lFlags ,
	CFrameworkQuery &Query
)
{
#if NTONLY >= 5
    HRESULT hRes = WBEM_S_NO_ERROR;

	hRes = FindAndGetDriver(pInstance);

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    : CPrinterDriver::PutInstance
*
*  DESCRIPTION : Adding a driver if it doesnt exist
*
*****************************************************************************/

HRESULT CPrinterDriver :: PutInstance  (

	const CInstance &Instance,
	long lFlags
)
{
#if NTONLY >= 5
    HRESULT  hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
	CHString t_DriverName;
	CHString t_Environment;
    CHString t_InfName;
    CHString t_FilePath;
    CHString t_Key;
	DWORD    dwVersion = 0;
    DWORD    dwPossibleOperations = 0;
	DWORD    dwError = 0;

	dwPossibleOperations = dwPossibleOperations | WBEM_FLAG_CREATE_ONLY;

	if (lFlags & dwPossibleOperations)
    {	
        //
        // Get driver name
        //
        hRes = InstanceGetString(Instance, kDriverName, &t_Key, kFailOnEmptyString);

        if (SUCCEEDED(hRes))
        {
            hRes = ConvertDriverKeyToValues(t_Key, t_DriverName, dwVersion, t_Environment);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get inf name. optional argument
            //
            hRes = InstanceGetString(Instance, kInfName, &t_InfName, kAcceptEmptyString);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get file path. optional argument
            //
            hRes = InstanceGetString(Instance, kFilePath, &t_FilePath, kAcceptEmptyString);
        }

        if (SUCCEEDED(hRes))
	    {
            dwError = SplDriverAdd(t_DriverName,
                                   dwVersion,
                                   t_Environment.IsEmpty() ? static_cast<LPCTSTR>(NULL) : t_Environment,
                                   t_InfName.IsEmpty()     ? static_cast<LPCTSTR>(NULL) : t_InfName,
                                   t_FilePath.IsEmpty()    ? static_cast<LPCTSTR>(NULL) : t_FilePath);

			hRes = WinErrorToWBEMhResult(dwError);			

            if (FAILED(hRes))
            {
                SetErrorObject(Instance, dwError, pszPutInstance);
            }            
		}		
	}

   return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver:: DeleteInstance
*
*  DESCRIPTION :    Deleting a PrinterDriver
*
*****************************************************************************/

HRESULT CPrinterDriver :: DeleteInstance (

	const CInstance &Instance,
	long lFlags
)
{
#if NTONLY >= 5
	HRESULT  hRes          = WBEM_E_PROVIDER_FAILURE;
	DWORD    dwError       = 0;
    DWORD    dwVersion     = 0;
    CHString t_DriverName;
	CHString t_Environment;
    CHString t_Key;

    //
    // Get driver name
    //
    hRes = InstanceGetString(Instance, kDriverName, &t_Key, kFailOnEmptyString);

    if (SUCCEEDED(hRes))
    {
        hRes = ConvertDriverKeyToValues(t_Key, t_DriverName, dwVersion, t_Environment);
    }

    if (SUCCEEDED(hRes))
    {
        dwError = SplDriverDel(t_DriverName, dwVersion, t_Environment);

        hRes    = WinErrorToWBEMhResult(dwError);
		
        if (FAILED(hRes))
        {
            SetErrorObject(Instance, dwError, pszDeleteInstance);

            //
            // When we call DeleteInstance and there is no printer driver with the specified
            // name, DeletePrinterDriver returns ERROR_UNKNOWN_PRINTER_DRIVER. WinErrorToWBEMhResult 
            // translates that to Generic Failure. We really need WBEM_E_NOT_FOUND in this case.
            // 
            if (dwError == ERROR_UNKNOWN_PRINTER_DRIVER)
            {
                hRes = WBEM_E_NOT_FOUND;
            } 
        }	  	
	}

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::LoadInstance
*
*  DESCRIPTION :    Loads the properties into the instance
*
*****************************************************************************/
HRESULT CPrinterDriver :: LoadInstance (
										
	CInstance *pInstance,
	DRIVER_INFO_6 *pDriverInfo
)
{
	HRESULT  hRes = WBEM_E_PROVIDER_FAILURE;
    CHString t_FullName;

    SetCreationClassName(pInstance);

    pInstance->SetWCHARSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
	
    t_FullName.Format(kFormatString, pDriverInfo->pName, pDriverInfo->cVersion, pDriverInfo->pEnvironment);

    if (                                   pInstance->SetCHString(kDriverName,      t_FullName)             &&
                                           pInstance->SetDWORD   (kVersion,         pDriverInfo->cVersion)          &&
                                           pInstance->SetCHString(kEnvironment,     pDriverInfo->pEnvironment)      &&
        (!pDriverInfo->pDriverPath      || pInstance->SetCHString(kDriverPath,      pDriverInfo->pDriverPath))      &&
        (!pDriverInfo->pDataFile        || pInstance->SetCHString(kDataFile,        pDriverInfo->pDataFile))        &&
    	(!pDriverInfo->pConfigFile      || pInstance->SetCHString(kConfigFile,      pDriverInfo->pConfigFile))      &&
    	(!pDriverInfo->pHelpFile        || pInstance->SetCHString(kHelpFile,        pDriverInfo->pHelpFile))        &&
    	(!pDriverInfo->pMonitorName     || pInstance->SetCHString(kMonitorName,     pDriverInfo->pMonitorName))     &&
        (!pDriverInfo->pDefaultDataType || pInstance->SetCHString(kDefaultDataType, pDriverInfo->pDefaultDataType)) &&
    	(!pDriverInfo->pszOEMUrl        || pInstance->SetCHString(kOemUrl,          pDriverInfo->pszOEMUrl)))
    {
        SAFEARRAY *pArray = NULL;

        hRes = CreateSafeArrayFromMultiSz(pDriverInfo->pDependentFiles, &pArray);

        if (SUCCEEDED(hRes))
        {
            //
            // We succeed in the case when there are no dependent files, too.
            // We need to check that case
            //
            if (pArray)
            {
                if (!pInstance->SetStringArray(kDependentFiles, *pArray))
                {
				    hRes = WBEM_E_PROVIDER_FAILURE;
				}
				
                SafeArrayDestroy(pArray);
            }
        }
    }

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::FindPrinterDriver
*
*  DESCRIPTION :    Checks if the Given driver exists, if not it return
*					WBEM_E_NOT_FOUND
*
*****************************************************************************/
HRESULT CPrinterDriver::FindAndGetDriver (
					
	CInstance *pInstance
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

    CHString t_Key;
	CHString t_DriverName;
	DWORD    dwVersion;
	CHString t_Environment;

	if SUCCEEDED ( hRes = InstanceGetString(*pInstance, kDriverName, &t_Key, kFailOnEmptyString) )
	{
		if SUCCEEDED( hRes =ConvertDriverKeyToValues(t_Key, t_DriverName, dwVersion, t_Environment) )
		{
			// enumerate all the drivers and check if the drivers already exist
			BYTE *pDriverInfo = NULL;
			DWORD dwNoOfDrivers;

			hRes = GetAllPrinterDrivers(pDriverInfo, dwNoOfDrivers);

			if (SUCCEEDED(hRes) && pDriverInfo)
			{
				try
				{
					DRIVER_INFO_6 *pNewDriverInfo = reinterpret_cast<DRIVER_INFO_6 *>(pDriverInfo);

					hRes = WBEM_E_NOT_FOUND;

					for ( int i = 0; i < dwNoOfDrivers; i++, pNewDriverInfo++ )
					{
						CHString t_TempDriverName(pNewDriverInfo->pName);
						CHString t_TempEnvironment(pNewDriverInfo->pEnvironment);

						if (t_DriverName.CompareNoCase(t_TempDriverName)   == 0  &&
							t_Environment.CompareNoCase(t_TempEnvironment) == 0  &&
							dwVersion == pNewDriverInfo->cVersion)	
						{
							hRes = LoadInstance(pInstance, pNewDriverInfo);

							break;					
						}
					}
				}
				catch ( ... )
				{
					delete [] pDriverInfo;
					pDriverInfo = NULL;
					throw;
				}
					
				delete [] pDriverInfo;
				pDriverInfo = NULL;			
			}
		}
	}

	if ( hRes == WBEM_E_INVALID_PARAMETER )
	{
		hRes = WBEM_E_NOT_FOUND;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::GetAllPrinterDrivers
*
*  DESCRIPTION :    Reads the instances of All the drivers on a local machine.
*
*****************************************************************************/
HRESULT CPrinterDriver :: GetAllPrinterDrivers (
												
	BYTE* &a_pDriverInfo,
	DWORD &dwNoDrivers
)
{
	HRESULT hRes = WBEM_E_FAILED;
	DWORD dwError;
    DWORD dwBytesNeeded = 0;

    a_pDriverInfo = NULL;

    hRes = WBEM_S_NO_ERROR;

    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        if (!::EnumPrinterDrivers(NULL, TEXT("all"), 6, a_pDriverInfo, 0, &dwBytesNeeded, &dwNoDrivers))
        {
            dwError = GetLastError();

		    if (dwError==ERROR_INSUFFICIENT_BUFFER)
		    {
                a_pDriverInfo = new BYTE [dwBytesNeeded];

			    if (a_pDriverInfo)
			    {
                    if (!::EnumPrinterDrivers(NULL, TEXT("all"), 6, a_pDriverInfo,  dwBytesNeeded, &dwBytesNeeded, &dwNoDrivers))
                    {
                        delete 	[] a_pDriverInfo;
					    
					    dwError = GetLastError();

                        hRes = WinErrorToWBEMhResult(dwError);
				    }
			    }
			    else
			    {
				    hRes = WBEM_E_OUT_OF_MEMORY;
			    }
		    }
            else
            {
                hRes = WinErrorToWBEMhResult(dwError);
            }
	    }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        hRes = WBEM_E_FAILED;
    }

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::ExecMethod
*
*  DESCRIPTION :    Implementation for the Printer Driver Methods
*
*****************************************************************************/

HRESULT CPrinterDriver :: ExecMethod (

	const CInstance &Instance,
	const BSTR       bstrMethodName,
          CInstance *pInParams,
          CInstance *pOutParams,
          long       lFlags
)
{
#if NTONLY >= 5
	HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    if (pOutParams)
	{
		if (!_wcsicmp(bstrMethodName, kAddDriverMethod))
		{
			hRes = ExecAddPrinterDriver(pInParams, pOutParams);
		}
#ifdef _WMI_DELETE_METHOD_
		else
		if (!_wcsicmp(bstrMethodName, kDelDriverMethod))
		{
			hRes = ExecDelPrinterDriver(pInParams, pOutParams);
		}
#endif //_WMI_DELETE_METHOD_
        else
		{
			hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::ExecAddPrinterDriver
*
*  DESCRIPTION :    Adds a printer driver. VErsion and Environment are optional
*
*****************************************************************************/

HRESULT CPrinterDriver :: ExecAddPrinterDriver (

    CInstance *pInParams,
    CInstance *pOutParams
)
{
#if NTONLY >= 5
    HRESULT				hRes         = WBEM_E_INVALID_PARAMETER;
    CHString			t_DriverName;
    CHString            t_Environment;
    CHString            t_InfName;
    CHString            t_FilePath;
    DWORD               dwVersion;
	bool				t_Exists;
	VARTYPE				t_Type;
    CInstancePtr        t_EmbeddedObject;

	if (pInParams->GetStatus(kArgToMethods, t_Exists, t_Type) &&
        t_Exists &&
        pInParams->GetEmbeddedObject(kArgToMethods, &t_EmbeddedObject, pInParams->GetMethodContext()))
    {
        //
        // Get driver name
        //
        hRes = InstanceGetString(t_EmbeddedObject, kDriverName, &t_DriverName, kFailOnEmptyString);

		if (SUCCEEDED (hRes))
		{
            //
			// Get driver environment
            //
            hRes = InstanceGetString(t_EmbeddedObject, kEnvironment, &t_Environment, kAcceptEmptyString);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get inf name. optional argument
            //
            hRes = InstanceGetString(t_EmbeddedObject, kInfName, &t_InfName, kAcceptEmptyString);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get file path. optional argument
            //
            hRes = InstanceGetString(t_EmbeddedObject, kFilePath, &t_FilePath, kAcceptEmptyString);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get driver version. Will be defaulted to -1
            //
            hRes = InstanceGetDword(t_EmbeddedObject, kVersion, &dwVersion);
        }

        if (SUCCEEDED(hRes))
	    {
            DWORD dwError = SplDriverAdd(t_DriverName,
                                         dwVersion,
                                         t_Environment.IsEmpty() ? static_cast<LPCTSTR>(NULL) : t_Environment,
                                         t_InfName.IsEmpty()     ? static_cast<LPCTSTR>(NULL) : t_InfName,
                                         t_FilePath.IsEmpty()    ? static_cast<LPCTSTR>(NULL) : t_FilePath);

			SetReturnValue(pOutParams, dwError);			            
		}	
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

#ifdef _WMI_DELETE_METHOD_
/*****************************************************************************
*
*  FUNCTION    :    CPrinterDriver::ExecDelPrinterDriver
*
*  DESCRIPTION :    This method will delete a given printer driver
*
*****************************************************************************/

HRESULT CPrinterDriver :: ExecDelPrinterDriver (

    CInstance *pInParams,
    CInstance *pOutParams
)
{
#if NTONLY >= 5
    HRESULT				hRes         = WBEM_E_INVALID_PARAMETER;
    CHString			t_DriverName;
    CHString            t_Environment;
    DWORD               dwVersion;
	bool				t_Exists;
	VARTYPE				t_Type;
    CInstancePtr        t_EmbeddedObject;

	if (pInParams->GetStatus(kArgToMethods, t_Exists, t_Type) &&
        t_Exists &&
        pInParams->GetEmbeddedObject(kArgToMethods, &t_EmbeddedObject, pInParams->GetMethodContext()))
    {
        //
        // Get driver name
        //
        hRes = InstanceGetString(t_EmbeddedObject, kDriverName, &t_DriverName, kFailOnEmptyString);

		if (SUCCEEDED (hRes))
		{
            //
			// Get driver environment
            //
            hRes = InstanceGetString(t_EmbeddedObject, kEnvironment, &t_Environment, kAcceptEmptyString);
        }

        if (SUCCEEDED (hRes))
		{
            //
			// Get driver version. Will be defaulted to -1
            //
            hRes = InstanceGetDword(t_EmbeddedObject, kVersion, &dwVersion);
        }

        if (SUCCEEDED(hRes))
	    {
            DWORD dwError = SplDriverDel(t_DriverName,
                                         dwVersion,
                                         t_Environment.IsEmpty() ? static_cast<LPCTSTR>(NULL) : t_Environment);

			SetReturnValue(pOutParams, dwError);			
		}
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

#endif //_WMI_DELETE_METHOD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\prninterface.h ===
/*++



//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
All rights reserved.

Module Name:

    PrnInterface.h

Abstract:

    Interface for WMI Provider. Used for doing printer object
    management: printers, driver, ports, jobs.
    
Author:

    Felix Maxa (AMaxa)  03-March-2000

--*/

#ifndef _PRNINTERFACE_HXX_
#define _PRNINTERFACE_HXX_

#include <fwcommon.h>
#include "winspool.h"
#include "tcpxcv.h"

//
// Printer functionality
//
DWORD
SplPrinterAdd(
    IN PRINTER_INFO_2W &Printer2
    );

DWORD
SplPrinterDel(
    IN LPCWSTR pszPrinter
    );

DWORD
SplPrinterSet(
    IN PRINTER_INFO_2W &Printer2
    );

DWORD
SplPrinterRename(
    IN LPCWSTR pCurrentPrinterName,
    IN LPCWSTR pNewPrinterName
    );

DWORD
SplPrintTestPage(
    IN LPCWSTR pPrinter
    );

//
// Printer driver functionality
//
DWORD
SplDriverAdd(
    IN LPCWSTR pszDriverName,
    IN DWORD   dwVersion,
    IN LPCWSTR pszEnvironment,
    IN LPCWSTR pszInfName,
    IN LPCWSTR pszFilePath
    );

DWORD
SplDriverDel(
    IN LPCWSTR pszDriverName,
    IN DWORD   pszVersion,
    IN LPCWSTR pszEnvironment
    );

//
// Printer port functionality
//   
DWORD
SplPortAddTCP(
    IN PORT_DATA_1 &Port
    );

DWORD
SplPortDelTCP(
    IN LPCWSTR pszPort
    );

DWORD
SplTCPPortGetConfig(
    IN     LPCWSTR       pszPort,
    IN OUT PORT_DATA_1 *pPortData
    );

DWORD
SplTCPPortSetConfig(
    IN PORT_DATA_1 &PortData
    );

BOOL
GetDeviceSettings(
    IN OUT PORT_DATA_1 &PortData
    );

enum {
    kProtocolRaw      = 1,
    kProtocolLpr      = 2,
    kDefaultRawNumber = 9100,
    kDefaultLprNumber = 515,
    kTCPVersion       = 1,
    kCoreVersion      = 1,
    kDefaultSnmpIndex = 1
};



#endif // _PRNINTERFACE_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printjob.h ===
//////////////////////////////////////////////////////////////////////

//

//  PrintJob.h  - Implementation of Provider for user print-jobs

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
//  10/17/96    jennymc     Enhanced
//  10/27/97    davwoh      Moved to curly
//
//////////////////////////////////////////////////////////////////////

//==================================

#define PJ_STATUS_UNKNOWN     L"Unknown"

#define PJ_JOB_STATUS_PAUSED     L"Paused"
#define PJ_JOB_STATUS_ERROR      L"Error"
#define PJ_JOB_STATUS_DELETING   L"Deleting"
#define PJ_JOB_STATUS_SPOOLING   L"Spooling"
#define PJ_JOB_STATUS_PRINTING   L"Printing"
#define PJ_JOB_STATUS_OFFLINE    L"Offline"
#define PJ_JOB_STATUS_PAPEROUT   L"Paperout"
#define PJ_JOB_STATUS_PRINTED    L"Printed"

// returns required for the ExecMethod Routines
#define PJ_JOB_NO_ERROR					0
#define PJ_JOB_PAUSED					1
#define PJ_JOB_STATUS_ACCESS_DENIED		2
#define PJ_JOB_STATUS_ALREADY_RUNNING	3
#define PJ_JOB_STATUS_ALREADY_PRINTED	3
#define PJ_JOB_UNKNOWN					4

#define PROPSET_NAME_PRINTJOB L"Win32_PrintJob"

// Method Names
#define	 PAUSEJOB						 L"Pause"
#define	 RESUMEJOB						 L"Resume"
#define	 DELETEJOB						 L"Delete"

//==========================================================

#define NUM_OF_JOBS_TO_ENUM 100
#define ENUM_LEVEL 2
#define FIRST_JOB_IN_QUEUE 0
#define NO_SPECIFIC_PRINTJOB 9999999
//==========================================================

class CWin32PrintJob;

class CWin32PrintJob:public Provider
{
    private:
        
        void    
        AssignPrintJobFields(
            LPVOID     lpJob, 
            CInstance *pInstance
            );

        HRESULT 
        AllocateAndInitPrintersList(
            LPBYTE       *ppPrinterList, 
            DWORD        &dwInstances
            );

        HRESULT 
        GetAndCommitPrintJobInfo(
            HANDLE         hPrinter, 
            LPCWSTR        pszPrinterName,
            DWORD          dwJobId, 
            MethodContext *pMethodContext, 
            CInstance     *pInstance
            );

	    HRESULT 
        ExecPrinterOp(
            const CInstance &Instance, 
            CInstance       *pOutParams, 
            DWORD            dwOperation
            );

        //============== not used at the moment
        BOOL GetNTInstance()    { return TRUE; }
        BOOL GetWin95Instance() { return TRUE; }
        BOOL RefreshNTInstance(){ return TRUE; }
        BOOL RefreshWin95Instance(){ return TRUE; }
	    CHString  StartEndTimeToDMTF(DWORD time);

            

    public:

       virtual	HRESULT DeleteInstance(const CInstance &Instance,  long lFlags);

       // These functions are REQUIRED for the property set
       // ==================================================
       virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);

       // This class has dynamic instances
       // =================================
       virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

	   // a routine to execute the Methods 
	   virtual HRESULT ExecMethod ( const CInstance &Instance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags );

       // Constructor sets the name and description of the property set
       // and initializes the properties to their startup values
       // ==============================================================
       CWin32PrintJob(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32PrintJob();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\printjob.cpp ===
//////////////////////////////////////////////////////////////////////

//

//  PRINTJOB.CPP  - Implementation of Provider for user print-dwJobs

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
//  10/17/96    jennymc     Enhanced
//  10/27/97    davwoh      Moved to curly
//  1/12/98     a-brads     Passed off to Moe and Larry.
//  07/24/00    amaxa       Rewrote GetObject and ExecPrinterOp
//
//////////////////////////////////////////////////////////////////////

#include <precomp.h>

#include <lockwrap.h>
#include <DllWrapperBase.h>
#include <winspool.h>

#include "printjob.h"
#include "resource.h"
#include "prnutil.h"

CWin32PrintJob PrintJobs ( PROPSET_NAME_PRINTJOB , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::CWin32PrintJob
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PrintJob :: CWin32PrintJob (

	LPCWSTR name, 
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::CWin32PrintJob
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32PrintJob :: ~CWin32PrintJob ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::GetObject
 *
 *  DESCRIPTION : 
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

HRESULT CWin32PrintJob :: GetObject (

	CInstance *pInstance, 
	long lFlags /*= 0L*/
)
{
    CHString t_String;
    CHString csPrinter;
    DWORD    dwPos;
    HRESULT  hRes = WBEM_S_NO_ERROR;
    
    hRes = InstanceGetString(*pInstance, IDS_Name, &t_String, kFailOnEmptyString);
    
    if (SUCCEEDED(hRes)) 
    {
        //
        // Isolate  a JobId and PrinterName from the PrintJob key
        // The key is of the form "printername, 123"
        //
        dwPos = t_String.Find(L',');

        csPrinter   = t_String.Left(dwPos);

        //
        // Check if the printer is a local printer or a printer connection.
        // We want to disallow the following scenario:
        // User connects remotely to winmgmt on server \\srv
        // User does GetObject on printer \\prnsrv\prn which is not local and
        // the user doesn't have a connection to. Normally this call succeeds,
        // because the spooler goes accross the wire. This means that you can
        // do GetObject on an instance that cannot be returned by EnumInstances.
        // This is inconsistent with WMI.
        //
        BOOL bInstalled = FALSE;

        //
        // Get the error code of the execution of SplIsPrinterInstalled
        //
        hRes = WinErrorToWBEMhResult(SplIsPrinterInstalled(csPrinter, &bInstalled));

        //
        // Check if the printer is installed locally or not
        //
        if (SUCCEEDED(hRes) && !bInstalled) 
        {
            hRes = WBEM_E_NOT_SUPPORTED;
        }
        
        if (SUCCEEDED(hRes)) 
        {
            CHString csJob;
            DWORD    dwJobId = 0;
    
    	    csJob       = t_String.Mid(dwPos+1);
    
            dwJobId     = _wtoi(csJob);
            
            hRes        = WBEM_E_FAILED;
    
            SmartClosePrinter hPrinter;
            DWORD             dwError  = ERROR_SUCCESS;
            DWORD             cbNeeded = 0;
            
            //
            // The code in the if statement uses dwError and Win32 error codes. Below 
            // we will convert the Win32 error code to a WBEM error code
            //
            BYTE *pBuf = NULL;
            
            // Use of delay loaded functions requires exception handler.
            SetStructuredExceptionHandler seh;

	        try
            {
                if (::OpenPrinter((LPTSTR)(LPCTSTR)TOBSTRT(csPrinter), &hPrinter, NULL))
                {
                    if (!::GetJob(hPrinter, dwJobId, ENUM_LEVEL, NULL, 0, &cbNeeded) &&
                        (dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
                    {
                        //
                        // SetCHString and AssignPrintJobFields can throw
                        //
                        
						if (pBuf = new BYTE[cbNeeded]) 
						{
							if (::GetJob(hPrinter, dwJobId, ENUM_LEVEL, pBuf, cbNeeded, &cbNeeded)) 
							{
								pInstance->SetCHString(IDS_Caption, t_String);
        						pInstance->SetCHString(IDS_Description, t_String);
        						
								AssignPrintJobFields(pBuf, pInstance);
                        
        						dwError = ERROR_SUCCESS;
							}
							else
							{
								dwError = GetLastError();
							}
						}
						else
						{
							dwError = ERROR_NOT_ENOUGH_MEMORY;
						}
						
						
					}
					else
					{
						dwError = GetLastError();                
					}
                }
                else
				{
					dwError = GetLastError();                
				}
            }
            catch(Structured_Exception se)
            {
                DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                if(pBuf)
                {
                    delete [] pBuf;
                    pBuf = NULL;
                }
                hRes = WBEM_E_FAILED;
            }
            catch(...)
            {
                if(pBuf)
                {
                    delete [] pBuf;
                    pBuf = NULL;
                }

                // It was not a delay load related exception...
                throw;
            }

            if (FAILED(hRes = WinErrorToWBEMhResult(dwError)))
            {
                
				// GetJob returns ERROR_INVALID_PARAMETER if it cannot find the job. This 
                // translates to GENERIC_FAILURE in the provider, which is not what we want.
                // The provider needs to return WBEM_E_NOT_FOUND in this case

				if(dwError == ERROR_INVALID_PARAMETER)
				{
					hRes = WBEM_E_NOT_FOUND;
				}
				
				//
                // Our caller was PutInstance/DeleteInstance. We use 
                // SetStatusObject to set extended error information
                //
                
                SetErrorObject(*pInstance, dwError, pszDeleteInstance);

            }
            
        }
    }
    
    return hRes;

#ifdef WIN9XONLY

    //
    // Old code for Win9x, not built anymore
    //
	//So, under Win9x we will get the JobInfo via enumeration ...

	DWORD dwReturnedJobs;

	// Get the total print dwJobs curretnly pending for this printer handle.
    
    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;

    LPBYTE t_pbJobInfoBase = NULL;
    JOB_INFO_2* t_pJobInfo = NULL;
	try
    {
        bStatus = ::EnumJobs ( hPrinter, 
            FIRST_JOB_IN_QUEUE,NUM_OF_JOBS_TO_ENUM,
            ENUM_LEVEL, 
            (LPBYTE)0,
            NULL,
            &dwJBytesNeeded, 
            &dwReturnedJobs );
	    if ( ! bStatus ) 
	    {
		    dwLastError = GetLastError () ;
		    
		    if ( dwLastError != ERROR_INSUFFICIENT_BUFFER ) 
		    {
			    return hr ;
		    }
	    }

	    // No Job entries - may be the print queue is now empty ? Is this an error ?
        if ( dwJBytesNeeded == 0L ) 
	    {
            return hr ;
	    }

	    // Allocates an array of JOB_INFO_2 to contain all of the job enumerations.
        DWORD dwJobsToCopy = dwJBytesNeeded / sizeof(JOB_INFO_2);
    
	    t_pbJobInfoBase = new BYTE [ dwJBytesNeeded + 2 ] ; 
	    t_pJobInfo = (JOB_INFO_2*) t_pbJobInfoBase ;
    
	    if ( ! t_pJobInfo ) 
	    {
		    return WBEM_E_OUT_OF_MEMORY;
	    }

		// Retrieves all the print dwJobs.
		bStatus = ::EnumJobs (	hPrinter, 
            FIRST_JOB_IN_QUEUE, 
            dwJobsToCopy, 
            ENUM_LEVEL,
            (LPBYTE)t_pJobInfo,
            dwJBytesNeeded, 
            &dwJBytesNeeded, 
            &dwReturnedJobs );
		if ( bStatus )
		{
			for ( DWORD dwJobs = 0; dwJobs < dwReturnedJobs && FAILED ( hr ); dwJobs ++ )
			{
				if ( dwJobID == t_pJobInfo->JobId )
				{
					pInstance->SetCHString ( IDS_Caption , name ) ;
					pInstance->SetCHString ( IDS_Description , name ) ;
					AssignPrintJobFields ( t_pJobInfo , pInstance ) ;
					hr = WBEM_S_NO_ERROR;
				}

				t_pJobInfo ++ ;
			}
		}

        delete [] (LPBYTE) t_pbJobInfoBase ;
	    t_pbJobInfoBase = NULL ;
	}
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        if ( t_pbJobInfoBase ) 
		{
			delete [] (LPBYTE) t_pbJobInfoBase ;
			t_pbJobInfoBase = NULL ;
		}
    }
	catch(...)
	{
		if ( t_pbJobInfoBase ) 
		{
			delete [] (LPBYTE) t_pbJobInfoBase ;

			t_pbJobInfoBase = NULL ;
		}
		
		throw ;
	}
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CWin32PrintJob:: DeleteInstance
*
*  DESCRIPTION :    Deleting a Print Job
*
*****************************************************************************/

HRESULT CWin32PrintJob :: DeleteInstance (

    const CInstance &Instance, 
          long       lFlags
)
{   
    return ExecPrinterOp(Instance, NULL, JOB_CONTROL_DELETE);            
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::EnumerateInstances
 *
 *  DESCRIPTION : 
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

HRESULT CWin32PrintJob::EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags /*= 0L*/
)
{
	char  buffer[200]; //debug 7/15/1999
    HRESULT hr = WBEM_S_NO_ERROR;

	//==================================================
	//  Get a list of printers and assign the ptr
	//==================================================

	DWORD dwNumberOfPrinters = 0;
	LPBYTE pBuff = NULL;

	hr = AllocateAndInitPrintersList ( &pBuff , dwNumberOfPrinters  ) ;

	PPRINTER_INFO_1 pPrinter = (PPRINTER_INFO_1) pBuff ;

	//==================================================
	//  Now, go thru them one at a time
	//==================================================
	if ( pPrinter )
	{
		// Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;

	    try
        {
			for ( DWORD i=0; i < dwNumberOfPrinters && SUCCEEDED(hr); i++)
			{
				SmartClosePrinter t_hPrinter ;

				if ( ::OpenPrinter ( pPrinter->pName, &t_hPrinter, NULL ) == TRUE ) 
				{
					sprintf(buffer,"%S",pPrinter->pName);

					DWORD dwJobId = NO_SPECIFIC_PRINTJOB ;

					hr = GetAndCommitPrintJobInfo(t_hPrinter, 
                                                  pPrinter->pName,
                                                  dwJobId, 
                                                  pMethodContext, 
                                                  NULL);

					pPrinter ++ ;						
				}
				else
				{
					DWORD dwErr = GetLastError();
				}
			}
		}
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            delete [] pBuff ;
            pBuff = NULL;
            hr = WBEM_E_FAILED;
        }
		catch(...)
		{
			delete [] pBuff ;
            pBuff = NULL;
			throw ;
		}

		delete [] pBuff ;
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::CWin32PrintJob
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

void CWin32PrintJob :: AssignPrintJobFields (

	LPVOID lpJob, 
	CInstance *pInstance
)
{
    LPJOB_INFO_2 pJobInfo = ( LPJOB_INFO_2 ) lpJob ;


    // Setting the properties for the JOB_INFO_2.
    // ==========================================

	//Note that IDS_Name,IDS_Caption and IDS_Description are set
	//elsewere - in the caller

	/*
    CHString sName ;
    sName = pJobInfo->pPrinterName;
    sName += _T(", ");

    TCHAR szBuff [ MAXITOA ] ;
    sName += _itot ( pJobInfo->JobId , szBuff, 10 ) ;

    pInstance->SetCHString (IDS_Name, sName ) ;

	pInstance->SetCHString ( IDS_Caption , sName ) ;

    pInstance->SetCHString ( IDS_Description , sName ) ;
	*/

    pInstance->SetDWORD ( IDS_JobId, pJobInfo->JobId ) ;

    pInstance->SetCharSplat ( IDS_Document , pJobInfo->pDocument ) ;

	CHString t_chsNotifyName( pJobInfo->pNotifyName ) ;
#ifdef WIN9XONLY
	
	// pNotifyName rolls on to other fields
	t_chsNotifyName.GetBufferSetLength( 16 ) ;
#endif
    pInstance->SetCharSplat ( IDS_Notify , t_chsNotifyName ) ;

    pInstance->SetDWORD ( IDS_Priority , pJobInfo->Priority ) ;

    //
    // Special case here. The start and until time are in universal time.
    // we need to convert it to local time
    //
    SYSTEMTIME StartTime = {0};
    SYSTEMTIME UntilTime = {0};
    CHString   csTime;

    PrinterTimeToLocalTime(pJobInfo->StartTime, &StartTime);
    PrinterTimeToLocalTime(pJobInfo->UntilTime, &UntilTime);

    //
    // If the job can be printed any time, then we do not set the StartTime
    // 
    //
    if (StartTime.wHour!=UntilTime.wHour || StartTime.wMinute!=UntilTime.wMinute)
    {
        csTime.Format(kDateTimeFormat, StartTime.wHour, StartTime.wMinute);

        pInstance->SetCHString(IDS_StartTime, csTime);

        csTime.Format(kDateTimeFormat, UntilTime.wHour, UntilTime.wMinute);

        pInstance->SetCHString(IDS_UntilTime, csTime);
    }
    
	if ( pJobInfo->Time == 0 )
	{
	    pInstance->SetTimeSpan ( IDS_ElapsedTime , WBEMTimeSpan (0,0,0,pJobInfo->Time) ) ;
    }
    	
    pInstance->SetDateTime(IDS_TimeSubmitted, pJobInfo->Submitted);

	pInstance->SetCharSplat ( IDS_Owner , pJobInfo->pUserName ) ;

    pInstance->SetCharSplat ( IDS_HostPrintQueue , pJobInfo->pMachineName ) ;

    pInstance->SetDWORD ( IDS_PagesPrinted, pJobInfo->PagesPrinted ) ;

    pInstance->SetDWORD ( IDS_Size, pJobInfo->Size ) ;

    pInstance->SetDWORD ( IDS_TotalPages, pJobInfo->TotalPages ) ;

    pInstance->SetCharSplat ( IDS_DriverName , pJobInfo->pDriverName ) ;

    pInstance->SetCharSplat ( IDS_Parameters, pJobInfo->pParameters ) ;

    pInstance->SetCharSplat ( IDS_DataType, pJobInfo->pDatatype ) ;

    pInstance->SetCharSplat ( IDS_PrintProcessor , pJobInfo->pPrintProcessor ) ;

	// Job StatusMask
	pInstance->SetDWORD ( L"StatusMask" , pJobInfo->Status ) ;

	// CIM_Job:JobStatus, string version 
	CHString t_chsJobStatus( pJobInfo->pStatus ) ;

	// build the status if pStatus is empty 
	if( t_chsJobStatus.IsEmpty() )
	{
		for( DWORD dw = 0; dw < 32; dw++ )
		{
			DWORD t_dwState = 1 << dw ;

			if( pJobInfo->Status & t_dwState )
			{
				CHString t_chsMaskItem ;

				switch( t_dwState )
				{
					case JOB_STATUS_PAUSED:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_PAUSED ) ;
						break ;
					}
					case JOB_STATUS_ERROR:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_ERROR ) ;
						break ;
					}
					case JOB_STATUS_DELETING:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_DELETING ) ;
						break ;
					}
					case JOB_STATUS_SPOOLING:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_SPOOLING ) ;
						break ;
					}
					case JOB_STATUS_PRINTING:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_PRINTING ) ;
						break ;
					}
					case JOB_STATUS_OFFLINE:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_OFFLINE ) ;
						break ;
					}
					case JOB_STATUS_PAPEROUT:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_PAPEROUT ) ;
						break ;
					}
					case JOB_STATUS_PRINTED:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_PRINTED ) ;
						break ;
					}
					case JOB_STATUS_DELETED:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_DELETED ) ;
						break ;
					}
					case JOB_STATUS_BLOCKED_DEVQ:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_BLOCKED_DEVQ ) ;
						break ;
					}
					case JOB_STATUS_USER_INTERVENTION:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_USER_INTERVENTION ) ;
						break ;
					}
					case JOB_STATUS_RESTART:
					{
						LoadStringW( t_chsMaskItem, IDR_JOB_STATUS_RESTART ) ;
						break ;
					}
					default:
					{
					}
				}
				if( !t_chsMaskItem.IsEmpty() )
				{
					if( !t_chsJobStatus.IsEmpty() )
					{
						t_chsJobStatus += L" | " ;
					}
					t_chsJobStatus += t_chsMaskItem;
				}
			}
		}
	}
	
	if( !t_chsJobStatus.IsEmpty() )
	{
		pInstance->SetCHString( IDS_JobStatus, t_chsJobStatus ) ;
	}


	// CIM_ManagedSystemElement::Status	
	if ( pJobInfo->Status & JOB_STATUS_ERROR )  
	{
		pInstance->SetCHString(IDS_Status, IDS_Error) ;
	}
	else if ( ( pJobInfo->Status & JOB_STATUS_OFFLINE ) ||
			  ( pJobInfo->Status & JOB_STATUS_PAPEROUT ) ||
			  ( pJobInfo->Status & JOB_STATUS_PAUSED ) )
	{
		pInstance->SetCHString(IDS_Status, IDS_Degraded) ;
	}
	else if ( ( pJobInfo->Status & JOB_STATUS_DELETING ) ||
			  ( pJobInfo->Status & JOB_STATUS_SPOOLING ) ||
			  ( pJobInfo->Status & JOB_STATUS_PRINTING ) ||
			  ( pJobInfo->Status & JOB_STATUS_PRINTED ) )
	{
		pInstance->SetCHString(IDS_Status, IDS_OK) ;
	}
	else
	{
		pInstance->SetCHString(IDS_Status, IDS_Unknown);
	}
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::CWin32PrintJob
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

HRESULT CWin32PrintJob :: AllocateAndInitPrintersList (

	LPBYTE *ppPrinterList, 
	DWORD &dwInstances
)
{
    DWORD   dwSpaceNeeded = 0, dwLastError = 0, dwReturnedPrinterInfo = 0;
    HANDLE  hPrinter = 0;

    // Set everything to null
    dwInstances = 0;
    *ppPrinterList = NULL;

    // ======================================================================
    // The first call to the enumeration is to find out how many printers
    // there are so that we can allocate buffer to contain all of the printer
    // enumeration.
    // ======================================================================

    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;
    BOOL t_Status = FALSE;

    try
    {
        t_Status = ::EnumPrinters (

		    PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,// | PRINTER_ENUM_NETWORK | PRINTER_ENUM_REMOTE,
            NULL,
		    1, 
		    NULL,
		    NULL,
		    &dwSpaceNeeded,
		    &dwReturnedPrinterInfo 
	    ) ;

        if ( t_Status == FALSE )
	    {
		    if ( ( dwLastError = GetLastError ()) != ERROR_INSUFFICIENT_BUFFER ) 
		    {
			    if (IsErrorLoggingEnabled())
			    {
				    CHString msg;
				    msg.Format( L"EnumPrinters failed: %d", dwLastError);
				    LogErrorMessage(msg);
			    }

			    if (dwLastError == ERROR_ACCESS_DENIED)
			    {
				    return WBEM_E_ACCESS_DENIED;
			    }
			    else
			    {
				    return WBEM_E_FAILED ;
			    }
            }
        }

        // ======================================================================
        // Allocates an array of PRINTER_INFO_1 to contain all of the printer enumerations.
        // ================================================================================

        *ppPrinterList = new BYTE [ dwSpaceNeeded + 2 ] ;
        if ( *ppPrinterList ) 
	    {
		    // ======================================================================
		    // The enumeration of printers is to receive the name of the existed printers in
		    // the domain the machine belongs to. With the printer's names the logic can identify
		    // the print-dwJobs per printer which transmitted to the Mo-server.
		    // ===================================================================================

			t_Status = ::EnumPrinters (

				PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,// | PRINTER_ENUM_NETWORK | PRINTER_ENUM_REMOTEn,
				NULL, 
				1, 
				( LPBYTE )*ppPrinterList, 
				dwSpaceNeeded, 
				&dwSpaceNeeded,
				&dwReturnedPrinterInfo 
			) ;

			if ( ! t_Status )
			{
				delete [] *ppPrinterList;

				*ppPrinterList = NULL;
				LogLastError(_T(__FILE__), __LINE__);

				return WBEM_E_FAILED;
			}

			// ======================================================================
			// Sets the properties for print dwJobs per printer when open successfully.
			// ======================================================================
			dwInstances = dwReturnedPrinterInfo ;
	    }
	    else
	    {
            CHString msg;
            msg.Format( L"EnumPrinters failed: %d", ERROR_NOT_ENOUGH_MEMORY);
            LogErrorMessage(msg);

            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        delete[] *ppPrinterList;
        return WBEM_E_FAILED;
    }
    catch(...)
    {
        delete[] *ppPrinterList;
        throw;
    }

    return( WBEM_S_NO_ERROR );
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::GetAndCommitPrintJobInfo
 *
 *  DESCRIPTION : 
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

HRESULT CWin32PrintJob::GetAndCommitPrintJobInfo (

	HANDLE         hPrinter, 
    LPCWSTR        pszPrinterName,
	DWORD          dwJobId, 
	MethodContext *pMethodContext, 
	CInstance     *a_pInstance
)
{
    HRESULT			hr = WBEM_E_FAILED;
	PRINTER_INFO_1	*pPrinterInfo = NULL;

	BYTE			*t_pbJobInfoBase	= NULL ;
	JOB_INFO_2		*t_pJobInfo			= NULL ;

	DWORD			dwPBytesNeeded = 0L;	//for printer info
	DWORD			dwJBytesNeeded = 0L;	//for jobs info
	DWORD			dwBytesUsed = 0L;
	DWORD			dwReturnedJobs = 0L;
	BOOL			bStatus = FALSE;
	CInstancePtr	t_pInstance = a_pInstance;


    // Get the total print dwJobs curretnly pending for the given printer handle.
    
    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;
    try
    {
        bStatus = ::EnumJobs ( hPrinter, 
            FIRST_JOB_IN_QUEUE,NUM_OF_JOBS_TO_ENUM,
            ENUM_LEVEL, 
            (LPBYTE)0,
            NULL,
            &dwJBytesNeeded, 
            &dwReturnedJobs );
        if (!bStatus) 
	    {
		    DWORD dwLastError = GetLastError();

            if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
            {
                DWORD dwAttributes = 0;

                //
                // Here we need to see if we are dealing with a printer connection.
                // OpenPrinter always succeeds on printer connections, because we
                // used cached information for creating the handle. However, EnumJobs
                // on a printer connection can fail because of various reasons:
                // - remote server machine is down
                // - spooler on remote server is not running
                // - remote printer was deleted, so the connection is broken.
                // In these cases, the print folders will display messages like:
                // "Access denied, unable to connect". We do not want our WMI call
                // to fail because of this. So if we have a printer connection, 
                // and an error other than insufficient buffer occurred, then we 
                // simply return success
                //
                hr = WinErrorToWBEMhResult(SplPrinterGetAttributes(pszPrinterName, &dwAttributes));

                if (SUCCEEDED(hr) &&
                    !(dwAttributes & PRINTER_ATTRIBUTE_LOCAL))
                {
                    //
                    // Printer connection
                    //
                    hr = WBEM_S_NO_ERROR;
                }

                return hr ;
		    }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        dwJBytesNeeded = 0L;
    }

    // No Job entries
    if ( dwJBytesNeeded == 0L ) 
        return WBEM_S_NO_ERROR ;

	// Allocates an array of JOB_INFO_2 to contain all of the print job enumerations.
    DWORD dwJobsToCopy = dwJBytesNeeded / sizeof(JOB_INFO_2);
    
	t_pbJobInfoBase = new BYTE [ dwJBytesNeeded + 2 ] ;
	t_pJobInfo = (JOB_INFO_2 *) t_pbJobInfoBase ;

    if ( ! t_pJobInfo ) 
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );
		return WBEM_E_OUT_OF_MEMORY;
	}

	// Get the buffer size needed for the printer information (level 1)
    try
    {
        bStatus = ::GetPrinter(hPrinter, 1, NULL, 0, &dwPBytesNeeded);
        pPrinterInfo = (PRINTER_INFO_1 *) new BYTE [ dwPBytesNeeded ];
        if (!(pPrinterInfo))
	    {
		    delete [] (LPBYTE) t_pbJobInfoBase;
		    return WBEM_E_OUT_OF_MEMORY;
	    }

	    // Get the printer information (level 1). 
	    bStatus = ::GetPrinter(hPrinter, 1,(LPBYTE )pPrinterInfo, dwPBytesNeeded, &dwBytesUsed);
        if (!bStatus)
        {
		    delete [] (LPBYTE) t_pbJobInfoBase ;
            delete [] (LPBYTE) pPrinterInfo;
		    return WBEM_E_ACCESS_DENIED;
	    }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        return WBEM_E_FAILED;
    }
    catch(...)
    {
        delete [] (LPBYTE) t_pbJobInfoBase ;
        delete [] (LPBYTE) pPrinterInfo;
		return WBEM_E_FAILED;
    }


	try
	{
		// Retrieves all the print dwJobs.
		bStatus = ::EnumJobs (	hPrinter, 
            FIRST_JOB_IN_QUEUE, 
            dwJobsToCopy, 
            ENUM_LEVEL,
            (LPBYTE)t_pJobInfo,
            dwJBytesNeeded, 
            &dwJBytesNeeded, 
            &dwReturnedJobs );
		if ( bStatus )
		{
			hr = WBEM_S_NO_ERROR ;

			for ( DWORD dwJobs = 0; dwJobs < dwReturnedJobs && SUCCEEDED ( hr ); dwJobs ++ )
			{
				if ( ! pMethodContext && dwJobId != t_pJobInfo->JobId )
						continue ;

				if ( pMethodContext )
					t_pInstance.Attach( CreateNewInstance ( pMethodContext ) ) ;

				//The instance name has the format 'PrinterName , Job#'
				CHString sName ;
				sName = pPrinterInfo->pName;
				sName += _T(", ");

				TCHAR szBuff [ MAXITOA ] ;
				sName += _itot ( t_pJobInfo->JobId , szBuff, 10 ) ;

				t_pInstance->SetCHString (IDS_Name, sName ) ;

				//Caption and Description are same as the Name
				t_pInstance->SetCHString ( IDS_Caption , sName ) ;
				t_pInstance->SetCHString ( IDS_Description , sName ) ;

				//Polulate the rest of the props
				AssignPrintJobFields ( t_pJobInfo , t_pInstance ) ;

				if ( pMethodContext )
					hr = t_pInstance->Commit() ;
				
				t_pJobInfo ++ ;
			}
		}
	}
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        if( t_pbJobInfoBase )
		{
			delete [] (LPBYTE) t_pbJobInfoBase ;
			t_pbJobInfoBase = NULL ;
		}
		if( pPrinterInfo )
		{
			delete [] (LPBYTE) pPrinterInfo;
			pPrinterInfo = NULL ;
		}
        hr = WBEM_E_FAILED;
    }
	catch(...)
	{
		if( t_pbJobInfoBase )
		{
			delete [] (LPBYTE) t_pbJobInfoBase ;
			t_pbJobInfoBase = NULL ;
		}
		if( pPrinterInfo )
		{
			delete [] (LPBYTE) pPrinterInfo;
			pPrinterInfo = NULL ;
		}
                throw;
	}

	if( pPrinterInfo ) 
	{
		delete [] (LPBYTE) pPrinterInfo;
		pPrinterInfo = NULL ;
	}

	if( t_pbJobInfoBase )
	{
		delete [] (LPBYTE) t_pbJobInfoBase ;
		t_pbJobInfoBase = NULL ;
	}

    return( hr );
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::ExecPrinterOp
 *
 *  DESCRIPTION : Makes a call to ExecPrinterOp to do a appropriate operation
 *				  based on the method called by the user.
 *
 ****************************************************************************/
HRESULT CWin32PrintJob :: ExecMethod (

	const CInstance &Instance , 	
	const BSTR       bstrMethodName,
          CInstance *pInParams,
          CInstance *pOutParams,
          long       lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
  
	if (!pOutParams)
	{
	   	hRes = WBEM_E_INVALID_PARAMETER;
	} 
    else if (!_wcsicmp(bstrMethodName, PAUSEJOB))
	{
		hRes = ExecPrinterOp(Instance, pOutParams, PRINTER_CONTROL_PAUSE);
	}
	else if (!_wcsicmp(bstrMethodName, RESUMEJOB))
	{
		hRes = ExecPrinterOp(Instance, pOutParams, PRINTER_CONTROL_RESUME);
	}
    else
	{
		hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32PrintJob::ExecPrinterOp
 *
 *  DESCRIPTION : Makes a call to SetJob, to either cancel a job, or Resume or 
 *				  Delete a job based on the dwOperation passed
 ****************************************************************************/

HRESULT CWin32PrintJob :: ExecPrinterOp ( 
										 
	const CInstance &Instance , 
	      CInstance *pOutParams, 
          DWORD      dwOperation          
          
)
{
#if NTONLY >= 5
    CHString  t_String;
    HRESULT   hRes = WBEM_S_NO_ERROR;
    
    hRes = InstanceGetString(Instance, IDS_Name, &t_String, kFailOnEmptyString);
    
    if (SUCCEEDED(hRes)) 
    {
        CHString csPrinter;
        CHString csJob;
        DWORD    dwJobId = 0;
        
        //
        // Isolate  a JobId and PrinterName from the PrintJob key
        // The key is of the form "printername, 123"
        //
	    DWORD dwPos = t_String.Find(L',');

	    csPrinter   = t_String.Left(dwPos);

	    csJob       = t_String.Mid(dwPos+1);

        dwJobId     = _wtoi(csJob);
        
        hRes        = WBEM_E_FAILED;

        SmartClosePrinter hPrinter;
        DWORD             dwError = ERROR_SUCCESS;

        //
        // We reached this point, return success to the framework
        //
        hRes = WBEM_S_NO_ERROR;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
		    if (!::OpenPrinter((LPTSTR)(LPCTSTR)TOBSTRT(csPrinter), &hPrinter, NULL) ||
                !::SetJob(hPrinter, dwJobId, 0, NULL, dwOperation)
               )
            {
                dwError = GetLastError();                
            }

            if (pOutParams) 
            {
                //
                // Our caller was invoked via ExecMethod. It passed us pOutParams
                // for returning the status of the operation
                //
                SetReturnValue(pOutParams, dwError);
            }
            else if (FAILED(hRes = WinErrorToWBEMhResult(dwError)))
            {
                //
                // Our caller was PutInstance/DeleteInstance. We use 
                // SetStatusObject to set extended error information
                // 
                SetErrorObject(Instance, dwError, pszDeleteInstance);

                //
                // When we call DeleteInstance and there is no job with the specified ID,
                // SetJob returns ERROR_INVALID_PARAMETER. WinErrorToWBEMhResult translates
                // that to Generic Failure. We really need WBEM_E_NOT_FOUND in this case.
                // 
                if (dwError == ERROR_INVALID_PARAMETER)
                {
                    hRes = WBEM_E_NOT_FOUND;
                } 
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            hRes = WBEM_E_FAILED;
        }
	}
    
	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\prnutil.h ===
/*++



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
All rights reserved.

Module Name:

    PrnUtil.h

Abstract:

    Declaration of some utility functions

Author:

    Felix Maxa (amaxa)  3-March-2000

--*/

extern CONST BOOL    kFailOnEmptyString;    
extern CONST BOOL    kAcceptEmptyString;
extern CONST LPCWSTR pszPutInstance;
extern CONST LPCWSTR pszDeleteInstance;
extern CONST LPCWSTR pszGetObject;

extern CONST LPCWSTR kDefaultBoolean;  
extern CONST LPCWSTR kDateTimeFormat;  
extern CONST LPCWSTR kDateTimeTemplate;


#include <..\..\framework\provexpt\include\provexpt.h>



class SmartClosePrinter
{
private:

	HANDLE m_h;

public:

	SmartClosePrinter () : m_h ( INVALID_HANDLE_VALUE ) {}
	SmartClosePrinter ( HANDLE h ) : m_h ( h ) {}

	~SmartClosePrinter()
	{
		// Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            if (m_h!=INVALID_HANDLE_VALUE) 
		    {
			    ::ClosePrinter(m_h);
		    }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }
	}

	HANDLE operator =(HANDLE h) 
	{
		// Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            if (m_h!=INVALID_HANDLE_VALUE) 
		    {
			    ::ClosePrinter(m_h); 
		    }

		    m_h=h;
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        } 

		return h;
	}

	operator HANDLE() const {return m_h;}
	HANDLE* operator &()
	{
		// Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            if (m_h!=INVALID_HANDLE_VALUE) 
		    {
		        ::ClosePrinter(m_h); 
		    }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }

		m_h = INVALID_HANDLE_VALUE; 

		return &m_h;
	}
};

HRESULT
InstanceGetString(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       CHString  *pcsString,
    IN           BOOL       bFailOnEmptyString,
    IN           LPWSTR     pszDefaultValue = L""
    );

HRESULT
InstanceGetDword(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       DWORD     *pdwOut,
    IN           DWORD      dwDefaultValue = (DWORD)-1
    );

HRESULT
InstanceGetBool(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       BOOL      *pbOut,
    IN           BOOL       bDefaultValue = FALSE
    );

UINT
MultiSzCount(
    IN LPCWSTR psz
    );

HRESULT
CreateSafeArrayFromMultiSz(
    IN  LPCTSTR     pszMultiSz,
    OUT SAFEARRAY **pArray
    );

DWORD
LocalTimeToPrinterTime(
    IN CONST SYSTEMTIME &st
    );

VOID
PrinterTimeToLocalTime(
    IN     DWORD        Minutes,
    IN OUT SYSTEMTIME *pSysTime
    );

DWORD
SplPrinterGetAttributes(
    IN     LPCWSTR   pszPrinter,
    IN OUT DWORD   *pdwAttributes
    );   
 
DWORD
SplIsPrinterInstalled(
    IN  LPCWSTR  pszPrinter,
    OUT BOOL    *pbInstalled
    );

DWORD
GetThisPrinter(
    IN  HANDLE   hPrinter,
    IN  DWORD    dwLevel,
    OUT BYTE   **ppData
    );

#if NTONLY == 5
#ifndef _PRNUTIL_HXX_
#define _PRNUTIL_HXX_

//
// The following lines are for the TABLE
// which makes building command strings for printui easier
//
class TUISymbols
{

public:
    static LPCTSTR kstrQuiet;
    static LPCTSTR kstrAddDriver;
    static LPCTSTR kstrAddPrinter;
    static LPCTSTR kstrDelDriver;
    static LPCTSTR kstrDriverPath;
    static LPCTSTR kstrDriverModelName;
    static LPCTSTR kstrDriverVersion;
    static LPCTSTR kstrDriverArchitecture;
    static LPCTSTR kstrInfFile;
    static LPCTSTR kstrMachineName;
    static LPCTSTR kstrPrinterName;
    static LPCTSTR kstrBasePrinterName;
    static LPCTSTR kstrPrinterPortName;
    static LPCTSTR kstrDelLocalPrinter;
    static LPCTSTR kstrDelPort;
    static LPCTSTR kstrAddPort;
    static LPCTSTR kstrConfigPort;
    static LPCTSTR kstrPortName;
    static LPCTSTR kstrPrintTestPage;    
};

DWORD WINAPI
PrintUIEntryW(
    IN LPCTSTR   pszCmdLine    
    );    

DWORD
CallXcvDataW(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData
    );

DWORD
IsLocalCall(
    IN OUT BOOL *pbOutValue
    );   

VOID
SetErrorObject(
    IN CONST CInstance &Instance,
    IN       DWORD      dwError,
    IN       LPCWSTR    pszOperation = L""
    );

VOID
SetReturnValue( 
    IN CInstance *pOutParams,
    IN DWORD      dwError 
    );

BOOL
GetDeviceSectionFromDeviceDescription(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszDeviceDescription,
    IN OUT LPWSTR   pszSectionName,
    IN     DWORD    dwSectionNameLen
    );

BOOL
GetIniString(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszSectionName,
    IN     LPCWSTR  pszKeyName,
    IN OUT LPWSTR   pszString,
    IN     DWORD    dwStringLen
    );

BOOL
GetIniDword(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszSectionName,
    IN     LPCWSTR  pszKeyName,
       OUT LPDWORD  pdwValue
    );

//
// Debug utilities
//
#ifdef DBG
VOID 
DbgMsg(
    IN LPCTSTR MsgFormat, ...
    );

#define DBG_LEVEL               4
#define DBG_NONE                0
#define DBG_TRACE               1
#define DBG_WARNING             2
#define DBG_ERROR               4

#define DBGMSG(Level, MsgAndArgs) {if (Level >= DBG_LEVEL) {DbgMsg MsgAndArgs;}}

#else
#define DBGMSG(x,y)
#endif

#endif
#endif // NTONLY == 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\prnutil.cpp ===
/*++



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
All rights reserved.

Module Name:

    PrnUtil.cpp

Abstract:

    The implementation of some printing utility functions

Author:

    Felix Maxa (amaxa)  3-Mar-2000

Revision History:

--*/


#include <precomp.h>
#include <DllWrapperBase.h>
#include <winspool.h>
#include "prnutil.h"
#include "WMI_FilePrivateProfile.h"

extern CONST BOOL    kFailOnEmptyString    = TRUE;
extern CONST BOOL    kAcceptEmptyString    = FALSE;
extern CONST LPCWSTR pszPutInstance        = L"PutInstance";
extern CONST LPCWSTR pszDeleteInstance     = L"DeleteInstance";
extern CONST LPCWSTR pszGetObject          = L"GetObject";
extern CONST LPCWSTR kDefaultBoolean       = L"Default";
extern CONST LPCWSTR kDateTimeFormat       = L"********%02d%02d00.000000+000";
extern CONST LPCWSTR kDateTimeTemplate     = L"19990102334411";


CONST LPCWSTR kMethodReturnValue    = L"ReturnValue";
CONST LPCWSTR kErrorClassPath       = L"\\\\.\\root\\cimv2:__ExtendedStatus";
CONST LPCWSTR pszIniPortsSection    = L"Ports";
CONST LPCWSTR g_pszPrintUIDll       = L"printui.dll";
CONST LPCSTR  g_pszPrintUIEntry     = "PrintUIEntryW";

#if NTONLY == 5

#include <winsock.h>
#include "prninterface.h"
#include <lockwrap.h>
#include <smartptr.h>
#include "AdvApi32Api.h"


LPCWSTR TUISymbols::kstrQuiet                   = _T("/q ");
LPCWSTR TUISymbols::kstrAddDriver               = _T("/Gw /ia /K ");
LPCWSTR TUISymbols::kstrAddPrinter              = _T("/if /u /z /Y /f \"\" ");
LPCWSTR TUISymbols::kstrDelDriver               = _T("/dd /K ");
LPCWSTR TUISymbols::kstrDriverPath              = _T("/l \"%s\" ");
LPCWSTR TUISymbols::kstrDriverModelName         = _T("/m \"%s\" ");
LPCWSTR TUISymbols::kstrDriverVersion           = _T("/v \"%u\" ");
LPCWSTR TUISymbols::kstrDriverArchitecture      = _T("/h \"%s\" ");
LPCWSTR TUISymbols::kstrInfFile                 = _T("/f \"%s\" ");
LPCWSTR TUISymbols::kstrMachineName             = _T("/c \"%s\" ");
LPCWSTR TUISymbols::kstrPrinterName             = _T("/n \"%s\" ");
LPCWSTR TUISymbols::kstrBasePrinterName         = _T("/b \"%s\" ");
LPCWSTR TUISymbols::kstrPrinterPortName         = _T("/r \"%s\" ");
LPCWSTR TUISymbols::kstrDelLocalPrinter         = _T("/dl ");
LPCWSTR TUISymbols::kstrPortName                = _T("/r \"%s\" ");
LPCWSTR TUISymbols::kstrPrintTestPage           = _T("/k ");


/*++

Routine Name

     PrintUIEntryW

Routine Description:

    Wrapper around the entry point in printui.dll

Arguments:

    pszCmdLine - String command line for printui

Return Value:

    DWORD Error status of the call

--*/
DWORD WINAPI
PrintUIEntryW(
    IN LPCWSTR pszCmdLine
    )
{
    DWORD     dwError = ERROR_SUCCESS;
    HINSTANCE hLib    = ::LoadLibrary(g_pszPrintUIDll);

    if(hLib)
    {
        typedef   DWORD (*PFNENTRY)(HWND, HINSTANCE, LPCTSTR, UINT);
        PFNENTRY  pfnEntry = NULL;

        pfnEntry = (PFNENTRY)::GetProcAddress(hLib, g_pszPrintUIEntry);

        if (pfnEntry)
        {
            dwError = pfnEntry(NULL, NULL, pszCmdLine, 0);

            DBGMSG(DBG_TRACE, (_T("PrintUIEntry returns %u GLE %u\n"), dwError, GetLastError()));
        }
        else
        {
            dwError = GetLastError();
        }
    }
    else
    {
        dwError = GetLastError();
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return dwError;
}

/*++

Routine Name

    GetPrinterAttributes

Routine Description:

    Gets a printer's attribute field

Arguments:

    pszPrinter    - printer name
    pdwAttributes - pointer to dword

Return Value:

    Win32 error code

--*/
DWORD
SplPrinterGetAttributes(
    IN     LPCWSTR  pszPrinter,
    IN OUT DWORD   *pdwAttributes
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszPrinter && pdwAttributes)
    {
        HANDLE             hPrinter         = NULL;
        PPRINTER_INFO_4    pInfo            = NULL;
        PRINTER_DEFAULTS   PrinterDefaults  = {NULL, NULL, PRINTER_READ};

        dwError = ERROR_DLL_NOT_FOUND;

        //
        // Open the printer.
        //
        
        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
	    try  
        {
            if (::OpenPrinter(const_cast<LPWSTR>(pszPrinter), &hPrinter, &PrinterDefaults))
            {
                //
                // Get the printer data. ATTENTION This doesn't work on Win9x because of the
                // mutex in the CWinSpoolApi class
                //
                dwError = GetThisPrinter(hPrinter, 4, reinterpret_cast<BYTE **>(&pInfo));

                if (dwError==ERROR_SUCCESS)
                {
                    *pdwAttributes = pInfo->Attributes;
                
                    //
                    // Release the printer info data.
                    //
                    delete [] pInfo;
                }

                //
                // Close the printer handle
                //
                ::ClosePrinter(hPrinter);
            }
            else
            {
                dwError = GetLastError();
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            dwError = E_FAIL;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrinterGetAttributes returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name:

    CallXcvData

Routine Description:

    Calls XcvDataW in winspool.drv. This is designed so to allow the tool to be
    run on NT4.0. If we don't get the procaddress and do eveything through
    the linked winspool.lib, the tool can't be registered with regsvr32.
    So we eliminte the import of XcvDataW from the imagefile.

Arguments:

    See DDK

Return Value:

    Win32 error code

--*/
DWORD
CallXcvDataW(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData
    )
{
    HMODULE      hLib = NULL;
    typedef      BOOL (* XCVDATAPARAM)(HANDLE, PCWSTR, PBYTE, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
    XCVDATAPARAM pfnXcvData = NULL;
    DWORD        dwError  = ERROR_DLL_NOT_FOUND;

    DWORD cbOutputNeeded = 0;
    DWORD Status         = NO_ERROR;
    BOOL  bReturn = FALSE;

    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;
	try  
    {
        bReturn =  XcvData(hXcv,
                                           pszDataName,
                                           pInputData,
                                           cbInputData,
                                           pOutputData,
                                           cbOutputData,
                                           &cbOutputNeeded,
                                           &Status);
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        dwError = E_FAIL;
    }

    dwError =  bReturn ? Status : GetLastError();

    DBGMSG(DBG_TRACE, (_T("CallXcvData returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

     IsLocalCall

Routine Description:

    Helper function. Checks if the caller's thread is local or remote

    DO NOT USE THIS FUNTCION OUTSIDE OF THE PRINTER FILES. The function doesn't
    handle the return value from OpenThreadToken properly in the case when the
    caller is the process, not a thread

Arguments:

    pbOutValue - pointer to bool

Return Value:

    DWORD Error status of the call

--*/
DWORD
IsLocalCall(
    IN OUT BOOL *pbOutValue
    )
{
    HANDLE        hToken         = NULL;
    PSID          pNetworkSid    = NULL;
    CAdvApi32Api *pAdvApi32      = NULL;
    DWORD         dwError        = ERROR_INVALID_PARAMETER;
    BOOL          bNetworkLogon  = FALSE;
    BOOL          bRetVal        = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (pbOutValue &&
        (dwError = OpenThreadToken(GetCurrentThread(), 
                                   TOKEN_QUERY, 
                                   FALSE, 
                                   &hToken) ? ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS &&
        (dwError = AllocateAndInitializeSid(&NtAuthority,
                                            1,
                                            SECURITY_NETWORK_RID,
                                            0,
                                            0,
                                            0,
                                            0,
                                            0,
                                            0,
                                            0,
                                            &pNetworkSid) ? ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS)
    {
        pAdvApi32 = (CAdvApi32Api*)CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);

        dwError = ERROR_INVALID_FUNCTION;

        if (pAdvApi32)
        {
            if (pAdvApi32->CheckTokenMembership(hToken, pNetworkSid, &bNetworkLogon, &bRetVal) && bRetVal)
            {
                dwError = ERROR_SUCCESS;
                *pbOutValue     = !bNetworkLogon;
            }
            else
            {
               dwError = GetLastError();
            }

            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
        }
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    if (pNetworkSid)
    {
        FreeSid(pNetworkSid);
    }

    DBGMSG(DBG_TRACE, (_T("IsLocalCall returns %u bLocal %u\n"), dwError, *pbOutValue));

    return dwError;
}

/*++

Routine Name:

    SetErrorObject

Routine Description:

    Sets en error object with extended information about an error that occurred.
    The function will format the win32 error code passed in as argument into a
    string description.

Arguments:

    Instace      - instance
    dwError      - Win32 error
    pszOperation - optional, description of what operation failed

Return Value:

    None

--*/
VOID
SetErrorObject(
    IN const CInstance &Instance,
    IN       DWORD      dwError,
    IN       LPCWSTR    pszOperation
    )
{
    CInstancePtr pErrorInstance(NULL);

    //
    // First, get a status object
    //
    CWbemProviderGlue::GetInstanceByPath(kErrorClassPath, &pErrorInstance, Instance.GetMethodContext());

    if (pErrorInstance)
    {
        DWORD       cchReturn         = 0;
        LPWSTR      pszFormatMessage  = NULL;
        HMODULE     hModule           = NULL;
        DWORD       dwFlags           = 0;
        HRESULT     hr                = E_FAIL;

        dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_IGNORE_INSERTS  |
                  FORMAT_MESSAGE_FROM_SYSTEM     |
                  FORMAT_MESSAGE_MAX_WIDTH_MASK;

        //
        // Format the message with the passed in last error.
        //
        cchReturn = FormatMessage(dwFlags,
                                  hModule,
                                  dwError,
                                  0,
                                  (LPTSTR)&pszFormatMessage,
                                  0,
                                  NULL);

        //
        // If a format string was returned then copy it back to the callers specified string.
        //
        pErrorInstance->SetWCHARSplat(L"Description", cchReturn ? pszFormatMessage : L"Unknown error");

        //
        // Release the format string.
        //
        if (pszFormatMessage)
        {
            LocalFree(pszFormatMessage);
        }

        //
        // Now, populate it
        //
        pErrorInstance->SetWCHARSplat(L"Operation",    pszOperation);
        pErrorInstance->SetWCHARSplat(L"ProviderName", L"Win32 Provider");
        pErrorInstance->SetDWORD     (L"StatusCode",   dwError);

        //
        // Get the actual IWbemClassObject pointer
        //
        IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();

        //
        // Note that no Release() is required for this
        //
        MethodContext *pMethodContext = Instance.GetMethodContext();

        //
        // Set the status object
        //
        pMethodContext->SetStatusObject(pObj);

        //
        // Cleanup
        //
        pObj->Release();
    }
}

//
// Debugging utility
//
#ifdef DBG
VOID cdecl
DbgMsg(
    IN LPCTSTR pszFormat, ...
    )
{
    CHString csMsgText;
    va_list  pArgs;

    va_start(pArgs, pszFormat);

    csMsgText.FormatV(pszFormat, pArgs);

    va_end(pArgs);

    OutputDebugString(csMsgText);
}
#endif

/*++

Routine Name:

    StringCompareWildcard

Routine Description:

    Compares two strings where * represents a wild card

Arguments:

    pszString1 - pointer to the first string
    pszString2 - pointer to the second string

Return Value:

    TRUE if the two strings match

--*/
BOOL
StringCompareWildcard(
    IN LPCWSTR pszString1,
    IN LPCWSTR pszString2
    )
{
    if (!pszString1 && !pszString2)
    {
        return TRUE;
    }
    else if (!pszString1 || !pszString2)
    {
        return FALSE;
    }

    while (*pszString1 != '\0' && *pszString2 != '\0')
    {
        if (*pszString2 == '*')
        {
            pszString2 = CharNext(pszString2);

            if (*pszString2 == '\0')
            {
                return TRUE;
            }

            for ( ; *pszString1 != '\0'; pszString1 = CharNext(pszString1))
            {
                if (StringCompareWildcard(pszString1, pszString2) == TRUE)
                {
                    return TRUE;
                }
            }

            break;
        }
        else if (*pszString1 == *pszString2)
        {
            pszString1 = CharNext(pszString1);
            pszString2 = CharNext(pszString2);
        }
        else
        {
            break;
        }
    }

    if (*pszString1 == '\0' && *pszString2 == '*')
    {
        pszString2 = CharNext(pszString2);

        if (*pszString2 == '\0')
        {
            return TRUE;
        }
    }

    return (*pszString1 == '\0' && *pszString2 == '\0');
}

/*++

Routine Name:

    GetIniDword

Routine Description:

    Gets a dword value from the ini file section. We do not validate arguments

Arguments:

    pszIniFileName - pointer to the ini file name
    pszSectionName - pointer to the ini file section name
    pszKeyName     - pointer to the ini file key name
    pdwValue       - pointer to the dword value

Return Value:

    TRUE on success

--*/
BOOL
GetIniDword(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszSectionName,
    IN     LPCWSTR  pszKeyName,
       OUT LPDWORD  pdwValue
    )
{
    *pdwValue = (DWORD)WMI_FILE_GetPrivateProfileIntW(pszSectionName, pszKeyName, -1, pszIniFileName);

    return *pdwValue != (DWORD)-1;
}

/*++

Routine Name

    GetIniString

Routine Description:

    Gets a string value from the ini file section

Arguments:

    pszIniFileName - pointer to the ini file name
    pszSectionName - pointer to the ini file section name
    pszKeyName     - pointer to the ini file key name
    pszString      - pointer to the string value
    dwStringLen    - size of the string

Return Value:

    TRUE on success

--*/
BOOL
GetIniString(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszSectionName,
    IN     LPCWSTR  pszKeyName,
    IN OUT LPWSTR   pszString,
    IN     DWORD    dwStringLen
    )
{
    DWORD dwResult = WMI_FILE_GetPrivateProfileStringW(pszSectionName, pszKeyName, NULL, pszString, dwStringLen, pszIniFileName);

    return dwResult > 0 && dwResult < dwStringLen - 1;
}

/*++

Routine Name:

    GetDeviceSectionFromDeviceDescription

Routine Description:

    Gets the appropriate section name from the ini file based on the device description

Arguments:

    pszIniFileName       - pointer to the ini file name
    pszDeviceDescription - pointer to the device description
    pszSectionName       - pointer to the section name
    dwSectionNameLen     - size of the section name

Return Value:

  TRUE on success

--*/
BOOL
GetDeviceSectionFromDeviceDescription(
    IN     LPCWSTR  pszIniFileName,
    IN     LPCWSTR  pszDeviceDescription,
    IN OUT LPWSTR   pszSectionName,
    IN     DWORD    dwSectionNameLen
    )
{
    LPWSTR  pszBuffer, pszTemp;
    DWORD   dwBufferLen = 1024;
    LPWSTR  pszKeyName;
    DWORD   dwKeyNameLen;
    DWORD   dwResult;
    BOOL    bReturn     = FALSE;

    //
    // Get the section strings from the ini file
    //
    pszBuffer = new WCHAR[dwBufferLen];

    while (pszBuffer && !bReturn)
    {
        dwResult = WMI_FILE_GetPrivateProfileStringW(pszIniPortsSection, NULL, NULL, pszBuffer, dwBufferLen, pszIniFileName);

        if (dwResult == 0)
        {
            bReturn = FALSE;
        }
        else if (dwResult < dwBufferLen - sizeof(WCHAR))
        {
            bReturn = TRUE;
        }
        else
        {
            dwBufferLen += 0x10;

            pszTemp = new WCHAR[dwBufferLen];

            if (pszTemp)
            {
                wcscpy(pszTemp, pszBuffer);

                delete [] pszBuffer;

                pszBuffer = pszTemp;
            }
        }
    }

    if (bReturn)
    {
        bReturn = FALSE;

        for (pszKeyName = pszBuffer; *pszKeyName; pszKeyName = &pszKeyName[dwKeyNameLen + 1])
        {
            //
            // Remove the quotes from the string
            //
            dwKeyNameLen = wcslen(pszKeyName);

            pszKeyName[dwKeyNameLen - 1] = '\0';

            if (StringCompareWildcard(pszDeviceDescription, &pszKeyName[1]))
            {
                //
                // Replace the quotes to the string
                //
                pszKeyName[dwKeyNameLen - 1] = '\"';

                //
                // Get the specific section string from the ini file
                //
                if (GetIniString(pszIniFileName, pszIniPortsSection, pszKeyName, pszSectionName, dwSectionNameLen) == TRUE)
                {
                    bReturn = TRUE;
                }

                break;
            }
        }
    }

    delete [] pszBuffer;

    return bReturn;
}

#endif //NTONLY

/*++

Routine Name

    GetThisPrinter

Routine Description:

    Gets a pointer to a chunk of memory that contains a PRINTER_INFO structure
    as specified by level. Caller must use delte [] to free the returned memory

Arguments:

    hPrinter   - handle to printer
    dwLevel    - level of the call
    ppData     - pointer to allocated printer information. caller needs to do delete []

Return Value:

    Win32 error code

--*/
DWORD
GetThisPrinter(
    IN     HANDLE   hPrinter,
    IN     DWORD    dwLevel,
    IN OUT BYTE   **ppData
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (hPrinter && ppData)
    {
        dwError = ERROR_DLL_NOT_FOUND;

        *ppData = NULL;

        BYTE   *pBuf  = NULL;
        DWORD   cbBuf = 0;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
	    try
        {
            dwError = ::GetPrinter(hPrinter, dwLevel, pBuf, cbBuf, &cbBuf) ? ERROR_SUCCESS : GetLastError();

            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                pBuf = new BYTE[cbBuf];

                if (pBuf)
                {
                    dwError = ::GetPrinter(hPrinter, dwLevel, pBuf, cbBuf, &cbBuf) ? ERROR_SUCCESS : GetLastError();

                    if (dwError==ERROR_SUCCESS)
                    {
                       *ppData = pBuf;
                    }
                    else
                    {
                        delete [] pBuf;
                    }
                }
                else
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            if(pBuf)
            {
                delete [] pBuf;
                pBuf = NULL;
            }
        }
    }

    return dwError;
}

/*++

Routine Name:

    GetTimeZoneBias

Routine Description:

    Returns the time zone bias.

Arguments:

    Nothing.

Return Value:

    Value of the time zone specific bias.

--*/
LONG
lGetTimeZoneBias(
    VOID
    )
{
    LONG lBias;
    TIME_ZONE_INFORMATION tzi;

    //
    // Get the time zone specific bias.
    //
    switch(GetTimeZoneInformation(&tzi))
    {
    case TIME_ZONE_ID_DAYLIGHT:

        lBias = (tzi.Bias + tzi.DaylightBias);
        break;

    case TIME_ZONE_ID_STANDARD:

        lBias = (tzi.Bias + tzi.StandardBias);
        break;

    case TIME_ZONE_ID_UNKNOWN:			

        lBias = tzi.Bias;
        break;						

    default:
        lBias = 0;
        break;
    }

    return lBias;
}

/*++

Routine Name:

    PrinterTimeToLocalTime

Routine Description:

    Converts the system time in minutes to local time in minutes.

Arguments:

    System time in minutes to convert.

    A system time structure that contains the converted local time in
    minutes if sucessful, otherwize returns the original system time.

--*/
VOID
PrinterTimeToLocalTime(
    IN     DWORD       Minutes,
    IN OUT SYSTEMTIME *pSysTime
    )
{
    //
    // NULL the out parameter
    //
    memset(pSysTime, 0,  sizeof(SYSTEMTIME));

    //
    // Ensure there is no wrap around.  Add a full day to prevent biases
    //
    Minutes += (24*60);

    //
    // Adjust for bias.
    //
    Minutes -= lGetTimeZoneBias();

    //
    // Now discard extra day.
    //
    Minutes = Minutes % (24*60);

    pSysTime->wHour   = static_cast<WORD>(Minutes / 60);
    pSysTime->wMinute = static_cast<WORD>(Minutes % 60);
}


/*++

Routine Name:

    LocalTimeToPrinterTime

Routine Description:

    Converts the local time in minutes to system time in minutes.

Arguments:

    Local time in minutes to convert.

Return Value:

    The converted system time in minutes if sucessful,
    otherwize returns the original local time.

--*/
DWORD
LocalTimeToPrinterTime(
    IN CONST SYSTEMTIME &st
    )
{
    DWORD Minutes = st.wHour * 60 + st.wMinute;
    //
    // Ensure there is no wrap around.  Add a full day to prevent biases
    //
    Minutes += (24*60);

    //
    // Adjust for bias.
    //
    Minutes += lGetTimeZoneBias();

    //
    // Now discard extra day.
    //
    Minutes = Minutes % (24*60);

    return Minutes;
}

/*++

Routine Name:

    MultiSzCount

Routine Description:

    Counts how many strings are in an multi sz

Arguments:

    psz - pointer to multi sz

Return Value:

    count of strings in multi sz

--*/
UINT
MultiSzCount(
    IN LPCWSTR psz
    )
{
    UINT nCount = 0;

    for ( ; psz && *psz; )
    {
        psz += wcslen (psz) + 1;
        nCount++;
    }

    return nCount;
}

/*++

Routine Name:

    CreateSafeArrayFromMultiSz

Routine Description:

    ANSI version not defined

Arguments:

    pszMultiSz - pointer to multi sz
    pArray     - pointer to pointer to safearry

Return Value:

    HRESULT

--*/
HRESULT
CreateSafeArrayFromMultiSz(
    IN  LPCSTR      pszMultiSz,
    OUT SAFEARRAY **pArray
    )
{
    return WBEM_E_NOT_FOUND;
}

/*++

Routine Name:

    CreateSafeArrayFromMultiSz

Routine Description:

    Parses a multi sz and createss a safearray with strings

Arguments:

    pszMultiSz - pointer to multi sz
    pArray     - pointer to pointer to safearry. Caller must use
                 SafeArrayDestroy to free the safe array  

Return Value:

    HRESULT

--*/
HRESULT
CreateSafeArrayFromMultiSz(
    IN  LPCWSTR     pszMultiSz,
    OUT SAFEARRAY **pArray
    )
{
    HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    if (pArray)
    {
        *pArray = NULL;

        hRes = WBEM_S_NO_ERROR;

        SAFEARRAYBOUND rgsabound[1];

        rgsabound[0].lLbound   = 0;
        rgsabound[0].cElements = MultiSzCount(pszMultiSz);

        if (rgsabound[0].cElements)
        {
            *pArray = SafeArrayCreate(VT_BSTR, 1, rgsabound);

            if (*pArray)
            {
                long    Index = 0;
                LPWSTR  psz   = const_cast<LPWSTR>(pszMultiSz);

                for (Index = 0; SUCCEEDED(hRes) && Index < rgsabound[0].cElements; Index++)
                {
                    BSTR bstr = SysAllocString(psz);

                    if (bstr)
                    {
                        hRes = SafeArrayPutElement (*pArray, &Index, bstr);

                        SysFreeString(bstr);
                    }
                    else
                    {
                        hRes = WBEM_E_OUT_OF_MEMORY;
                    }

                     psz += wcslen (psz) + 1;
                }

                if (FAILED(hRes) && *pArray)
                {
                    SafeArrayDestroy(*pArray);
                }
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return hRes;
}

/*++

Routine Name

    InstanceGetString

Routine Description:

    Helper function. Stores a property from an Instance into
    a CHString. If the property is NULL, the function fails
    if bFailOnEmtpyString is true, or succeeds and set the
    out parameter to a default value

Arguments:

    Instance           - reference to instance
    pszProperty        - property name for which to retrieve the data
    pcsString          - pointer to string class, will recevie the
                         string stored in pszProperty
    bFailOnEmptyString - if true, the function will fail if the property in the
                         instance contains no value or an empty string
    pszDEfaultValue    - if bAcceptEmptyString is true, and pszProperty has no string
                         in it, this value will be returned in csString

Return Value:

    DWORD Error status of the call

--*/
HRESULT
InstanceGetString(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       CHString  *pcsString,
    IN           BOOL       bFailOnEmptyString,
    IN           LPWSTR     pszDefaultValue
    )
{
    HRESULT hRes      = WBEM_E_INVALID_PARAMETER;
    bool    t_Exists;
	VARTYPE t_Type    = VT_NULL;

    if (pcsString &&
        Instance.GetStatus(pszProperty, t_Exists, t_Type) && 
        t_Exists)
    {
        switch(t_Type)
        {
        case VT_NULL:
            //
            // Property exists and but no value was specified. Check if caller wants
            // the default value to be returned
            //
            if (!bFailOnEmptyString)
            {
                hRes = WBEM_S_NO_ERROR;

                *pcsString = pszDefaultValue;
            }

            break;

        case VT_BSTR:
            //
            // Property exists and is string
            //
            hRes = WBEM_E_PROVIDER_FAILURE;

            if (Instance.GetCHString(pszProperty, *pcsString))
            {
                hRes = bFailOnEmptyString && pcsString->IsEmpty() ? WBEM_E_INVALID_PARAMETER : WBEM_S_NO_ERROR;
            }

            break;

        default:
            hRes = WBEM_E_INVALID_PARAMETER;
        }
    }

    return hRes;
}

/*++

Routine Name

    InstanceGetDword

Routine Description:

    Helper function. Stores a property from an Instance into
    a DWORD. If the property is NULL, the function will set the
    out parameter to a default value

Arguments:

    Instance       - reference to instance
    pszPropert     - property name
    pdwOut         - pointer to dword
    dwDefaultValue - if the property is null, the function will set dwOut to this value

Return Value:

    DWORD Error status of the call

--*/
HRESULT
InstanceGetDword(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       DWORD     *pdwOut,
    IN           DWORD      dwDefaultValue
    )
{
    HRESULT hRes      = WBEM_E_INVALID_PARAMETER;
    bool    t_Exists;
	VARTYPE t_Type    = VT_NULL;

    if (pdwOut &&
        Instance.GetStatus(pszProperty, t_Exists, t_Type) && 
        t_Exists)
    {
        switch(t_Type)
        {
        case VT_NULL:
            //
            // Property exists and but no value was specified. Return the default value
            //
            *pdwOut = dwDefaultValue;

            hRes  = WBEM_S_NO_ERROR;

            break;

        case VT_I4:
            //
            // Property exists and is DWORD
            //
            hRes = Instance.GetDWORD(pszProperty, *pdwOut) ? WBEM_S_NO_ERROR : WBEM_E_PROVIDER_FAILURE;

            break;

        default:
            hRes = WBEM_E_INVALID_PARAMETER;
        }
    }

    return hRes;
}

/*++

Routine Name

    InstanceGetBool

Routine Description:

    Helper function. Stores a property from an Instance into
    a BOOL. If the property is NULL, the function will set the
    out parameter to a default value

Arguments:

    Instance           - reference to instance
    pszProperty        - property name for which to retrieve the data
    pbOut              - pointer to bool, will recevie the bool stored in pszProperty
    pszDEfaultValue    - if pszProperty has no bool in it, this value will be returned in bOut

Return Value:

    DWORD Error status of the call

--*/
HRESULT
InstanceGetBool(
    IN     CONST CInstance &Instance,
    IN           LPCWSTR    pszProperty,
    IN OUT       BOOL      *pbOut,
    IN           BOOL       bDefaultValue
    )
{
    HRESULT hRes      = WBEM_E_INVALID_PARAMETER;
    bool    t_Exists;
	VARTYPE t_Type    = VT_NULL;
    
    if (pbOut &&
        Instance.GetStatus(pszProperty, t_Exists, t_Type) && 
        t_Exists)
    {
        bool bTemp;

        switch(t_Type)
        {
        case VT_NULL:
            //
            // Property exists and but no value was specified. Return the default value
            //
            *pbOut = bDefaultValue;

            hRes  = WBEM_S_NO_ERROR;

            break;

        case VT_BOOL:

            //
            // Property exists and is DWORD
            //
            hRes = Instance.Getbool(pszProperty, bTemp) ? WBEM_S_NO_ERROR : WBEM_E_PROVIDER_FAILURE;

            if (SUCCEEDED(hRes)) 
            {
                *pbOut = bTemp;
            }

            break;

        default:
            hRes = WBEM_E_INVALID_PARAMETER;
        }
    }

    return hRes;
}

/*++

Routine Name

    SetReturnValue

Routine Description:

    Sets the error resulted from ExecMethod in the out parameter

Arguments:

    pOutParams - pointer to Instance representing the out params of a method
    dwError    - error number to be set

Return Value:

    none

--*/
VOID
SetReturnValue(
    IN CInstance *pOutParams,
    IN DWORD      dwError
    )
{
	if (pOutParams)
    {
        pOutParams->SetDWORD(kMethodReturnValue, dwError);
    }
}

/*++

Routine Name

    SplIsPrinterInstalled

Routine Description:

    Checks if a printer is installed locally. This is useful especially 
    for printer connection. Let's say we have "\\ntprint\hp4000". This
    function will determinte if we have a connection to this printer or
    not. GetPrinter will level 4 doesn't help in this case.
    
Arguments:

    pszPrinter  - printer name
    pbInstalled - pointer to bool

Return Value:

    Win32 error code
    
--*/
DWORD
SplIsPrinterInstalled(
    IN  LPCWSTR  pszPrinter,
    OUT BOOL    *pbInstalled
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszPrinter && pbInstalled) 
    {
        DWORD  dwFlags   = PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS;
        DWORD  dwLevel   = 4;
        DWORD  cbNeeded  = 0;
        DWORD  cReturned = 0;

        *pbInstalled = FALSE;
        
        dwError = ERROR_MOD_NOT_FOUND;
        
        dwError = ERROR_SUCCESS;

        if (!EnumPrinters(dwFlags,
                                        NULL,
                                        dwLevel,
                                        NULL,
                                        0,
                                        &cbNeeded,
                                        &cReturned) &&
            (dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)            
        {
            BYTE *pBuf = new BYTE[cbNeeded];

            if (pBuf) 
            {
                if (EnumPrinters(dwFlags,
                                               NULL,
                                               dwLevel,
                                               pBuf,
                                               cbNeeded,
                                               &cbNeeded,
                                               &cReturned)) 
                {
                    PRINTER_INFO_4 *pPrn4 = reinterpret_cast<PRINTER_INFO_4 *>(pBuf);

                    for (DWORD i = 0; i < cReturned; i++, pPrn4++)
                    {
                        if (!lstrcmpi(pPrn4->pPrinterName, pszPrinter)) 
                        {
                            *pbInstalled = TRUE;

                            break;
                        }
                    }

                    dwError = ERROR_SUCCESS;
                }
                else
                {
                    dwError = GetLastError();
                }

                delete [] pBuf;
            }
            else
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            }            
        }
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\processdll.h ===
//=================================================================

// ProcessDLL.h -- CWin32ProcessDLL 

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//=================================================================
#ifndef __ASSOC_PROCESSDLL
#define __ASSOC_PROCESSDLL

typedef BOOL (CALLBACK *MODULEENUMPROC)(MODULEENTRY32*, LPVOID);

class CWin32ProcessDLL : public Provider
{
public:

	CWin32ProcessDLL();
	~CWin32ProcessDLL();

	virtual HRESULT EnumerateInstances (

		MethodContext *pMethodContext, 
		long lFlags = 0L
	);

	virtual HRESULT GetObject (

		CInstance* pInstance, 
		long lFlags = 0L
	);

protected:
	
	
	HRESULT AreAssociated (

		CInstance *pProcessDLL, 
		CInstance *pProcess, 
		CInstance *pDLL
	);

	void SetInstanceData (

		CInstance *pInstance, 
		MODULEENTRY32 *pModule
	);


	HRESULT EnumModulesWithCallback (

		MODULEENUMPROC fpCallback, 
		LPVOID pUserDefined,
		MethodContext *a_pMethodContext
	);

	static BOOL CALLBACK EnumInstancesCallback (

		MODULEENTRY32 *pModule, 
		LPVOID pUserDefined
	);

	static BOOL CALLBACK IsAssocCallback (

		MODULEENTRY32 *pModule, 
		LPVOID pUserDefined
	);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\prninterface.cpp ===
/*++



//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
All rights reserved.

Module Name:

    PrnInterface.cpp

Abstract:

    Interface for WMI Provider. Used for doing printer object
    management: printers, driver, ports, jobs.

Author:

    Felix Maxa (AMaxa)  03-March-2000

--*/

#include <precomp.h>
#if NTONLY == 5
#include <winspool.h>
#include "tcpxcv.h"
#include "prninterface.h"
#include "prnutil.h"
#include <DllWrapperBase.h>
#include <WSock32api.h>

LPCWSTR kXcvPortConfigOpenPrinter = L",XcvPort ";
LPCWSTR kXcvPortGetConfig         = L"GetConfigInfo";
LPCWSTR kXcvPortSetConfig         = L"ConfigPort";
LPCWSTR kXcvPortDelete            = L"DeletePort";
LPCWSTR kXcvPortAdd               = L"AddPort";
LPWSTR  kXcvPortOpenPrinter       = L",XcvMonitor Standard TCP/IP Port";

LPCWSTR kDefaultCommunity         = L"public";
LPCWSTR kDefaultQueue             = L"lpr";


/*++

Routine Name

    SplPrinterDel

Routine Description:

    Deletes a printer

Arguments:

    pszPrinter - printer name

Return Value:

    Win32 Error code

--*/

DWORD
SplPrinterDel(
    IN LPCWSTR pszPrinter
    )
{
    DWORD             dwError          = ERROR_INVALID_PRINTER_NAME;
    HANDLE            hPrinter         = NULL;
    PRINTER_DEFAULTS  PrinterDefaults  = {NULL, NULL, PRINTER_ALL_ACCESS};

    if (pszPrinter)
    {
        dwError = ERROR_DLL_NOT_FOUND;

        //
        // Open the printer.
        //
        // Use of delay loaded function requires exception handler.
        SetStructuredExceptionHandler seh;

        try
        {
            if (::OpenPrinter(const_cast<LPTSTR>(pszPrinter), &hPrinter, &PrinterDefaults))
            {
                dwError = ::DeletePrinter(hPrinter) ? ERROR_SUCCESS : GetLastError();

                ::ClosePrinter(hPrinter);
            }
            else
            {
                dwError = GetLastError();
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());    
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrinterDel returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplPrintTestPage

Routine Description:

    Prints a test page

Arguments:

    pPrinter - printer name

Return Value:

    Win32 Error code

--*/
DWORD
SplPrintTestPage(
    IN LPCWSTR pPrinter
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pPrinter && pPrinter)
    {
        //
        // CHString throws exceptions. We start building the
        // command string for calling into printui
        //
        try
        {
            CHString csCommand;
            CHString csTemp;

            csCommand += TUISymbols::kstrQuiet;
            csCommand += TUISymbols::kstrPrintTestPage;

            //
            // Append printer name to the command
            //
            csTemp.Format(TUISymbols::kstrPrinterName, pPrinter);
            csCommand += csTemp;

            DBGMSG(DBG_TRACE, (_T("SplPrintTestPage csCommand \"%s\"\n"), csCommand));

            dwError = PrintUIEntryW(csCommand);
        }
        catch (CHeap_Exception)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrintTestPage returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplPrinterAdd

Routine Description:

    Adds a printer queue

Arguments:

    A pointer to PRINTER_INFO_2 structure

Return Value:

    Win32 Error code

--*/
DWORD
SplPrinterAdd(
    IN PRINTER_INFO_2 &Printer2
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (Printer2.pPrinterName && Printer2.pDriverName && Printer2.pPortName)
    {
        //
        // CHString throws exceptions. We start building the
        // command string for calling into printui
        //
        try
        {
            CHString csCommand;
            CHString csTemp;

            csCommand += TUISymbols::kstrQuiet;
            csCommand += TUISymbols::kstrAddPrinter;

            //
            // Append printer name to the command
            //
            csTemp.Format(TUISymbols::kstrBasePrinterName, Printer2.pPrinterName);
            csCommand += csTemp;

            //
            // Append driver name to the command
            //
            csTemp.Format(TUISymbols::kstrDriverModelName, Printer2.pDriverName);
            csCommand += csTemp;

            //
            // Append port name to the command
            //
            csTemp.Format(TUISymbols::kstrPortName, Printer2.pPortName);
            csCommand += csTemp;

            DBGMSG(DBG_TRACE, (_T("SplPrinterAdd csCommand \"%s\"\n"), csCommand));

            dwError = PrintUIEntryW(csCommand);

            //
            // Set all the additional information about the printer
            // (information what cannot be set as part of the add printer)
            //
            if (dwError==ERROR_SUCCESS)
            {
                dwError = SplPrinterSet(Printer2);

                //
                // We need to delete the printer if the set failed
                //
                if (dwError!=ERROR_SUCCESS)
                {
                    DBGMSG(DBG_TRACE, (_T("SplPrinterAdd SetPrinter failed. Deleting printer\n")));

                    //
                    // Disregard error code
                    //
                    SplPrinterDel(Printer2.pPrinterName);
                }
            }
        }
        catch (CHeap_Exception)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrinterAdd returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplPrinterSet

Routine Description:

    Sets printer properties using the data set in the object members

Arguments:

    Nothing

Return Value:

    Win32 Error code

--*/
DWORD
SplPrinterSet(
    IN PRINTER_INFO_2 &Printer2
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    //
    // We do not support setting the devmode or the security descriptor
    //
    if (Printer2.pPrinterName && !Printer2.pDevMode && !Printer2.pSecurityDescriptor)
    {
        HANDLE             hPrinter         = NULL;
        PPRINTER_INFO_2    pInfo            = NULL;
        PRINTER_DEFAULTS   PrinterDefaults  = {NULL, NULL, PRINTER_ALL_ACCESS};
        DWORD              dwOldAttributes  = 0;
        DWORD              dwNewAttributes  = 0;

        dwError = ERROR_DLL_NOT_FOUND;

        //
        // Open the printer.
        //

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;

        try
        {
            if (::OpenPrinter(Printer2.pPrinterName, &hPrinter, &PrinterDefaults))
            {
                //
                // Get the printer data. ATTENTION This doesn't work on Win9x because of the
                // mutex in the CWinSpoolApi class
                //
                dwError = GetThisPrinter(hPrinter, 2, reinterpret_cast<BYTE **>(&pInfo));

                //
                // Merge in any changed fields.
                //

                if (dwError==ERROR_SUCCESS)
                {
                    //
                    // Publishing and UnPublishing needs to be special cased, since this setting is
                    // not done in the printer info 2 structure.  The published bit is a read only
                    // attribute in the printer info 2, the publish state is changed using set printer
                    // info 7.
                    //
                    dwOldAttributes = pInfo->Attributes;
                    dwNewAttributes = Printer2.Attributes != -1 ? Printer2.Attributes : pInfo->Attributes;

                    //
                    // Copy the changed date into the info sturcture.
                    //
                    pInfo->pPrinterName     = Printer2.pPrinterName ? Printer2.pPrinterName     : pInfo->pPrinterName;
                    pInfo->pShareName       = Printer2.pShareName   ? Printer2.pShareName       : pInfo->pShareName;
                    pInfo->pPortName        = Printer2.pPortName    ? Printer2.pPortName        : pInfo->pPortName;
                    pInfo->pDriverName      = Printer2.pDriverName  ? Printer2.pDriverName      : pInfo->pDriverName;
                    pInfo->pComment         = Printer2.pComment     ? Printer2.pComment         : pInfo->pComment;
                    pInfo->pLocation        = Printer2.pLocation    ? Printer2.pLocation        : pInfo->pLocation;
                    pInfo->pSepFile         = Printer2.pSepFile     ? Printer2.pSepFile         : pInfo->pSepFile;
                    pInfo->pParameters      = Printer2.pParameters  ? Printer2.pParameters      : pInfo->pParameters;
                    pInfo->pDatatype        = Printer2.pDatatype && *Printer2.pDatatype
                                                                    ? Printer2.pDatatype        : pInfo->pDatatype;
                    pInfo->pPrintProcessor  = Printer2.pPrintProcessor && *Printer2.pPrintProcessor
                                                                    ? Printer2.pPrintProcessor  : pInfo->pPrintProcessor;

                    //
                    // We cannot have 0 as attributes. So 0 will mean not initialized
                    //
                    pInfo->Attributes       = Printer2.Attributes             ? Printer2.Attributes       : pInfo->Attributes;
                    pInfo->Priority         = Printer2.Priority         != -1 ? Printer2.Priority         : pInfo->Priority;
                    pInfo->DefaultPriority  = Printer2.DefaultPriority  != -1 ? Printer2.DefaultPriority  : pInfo->DefaultPriority;
                    pInfo->StartTime        = Printer2.StartTime        != -1 ? Printer2.StartTime        : pInfo->StartTime;
                    pInfo->UntilTime        = Printer2.UntilTime        != -1 ? Printer2.UntilTime        : pInfo->UntilTime;

                    if (pInfo->StartTime == pInfo->UntilTime)
                    {
                        //
                        // Printer is always avaiable
                        //
                        pInfo->StartTime = pInfo->UntilTime = 0;
                    }

                    //
                    // Set the changed printer data.
                    //
                    if (::SetPrinter(hPrinter, 2, (PBYTE)pInfo, 0))
                    {
                        dwError = ERROR_SUCCESS;

                        //
                        // Control printer
                        //
                        if (Printer2.Status)
                        {
                            dwError = ::SetPrinter(hPrinter, 0, NULL, Printer2.Status) ? ERROR_SUCCESS : GetLastError();
                        }
                    }
                    else
                    {
                        dwError = GetLastError();
                    }

                    //
                    // Handle the printer publishing case.
                    //
                    if (dwError == ERROR_SUCCESS)
                    {
                        BOOL           bWasPublished = dwOldAttributes & PRINTER_ATTRIBUTE_PUBLISHED;
                        BOOL           bPublishNow   = dwNewAttributes & PRINTER_ATTRIBUTE_PUBLISHED;
                        PRINTER_INFO_7 Info7         = {0};
                        BOOL           bCallSetPrn   = TRUE;

                        if (bWasPublished && !bPublishNow) 
                        {
                            //
                            // unpublish
                            //
                            Info7.dwAction = DSPRINT_UNPUBLISH;                            
                        }
                        else if (!bWasPublished && bPublishNow) 
                        {
                            //
                            // publish
                            //
                            Info7.dwAction = DSPRINT_PUBLISH;                            
                        }
                        else
                        {
                            //
                            // don't do anything
                            //
                            bCallSetPrn = FALSE;                            
                        }

                        if (bCallSetPrn) 
                        {
                            //
                            // The UI will unpublish a printer if the printer becomes unshared. The UI 
                            // allows a printer to be published only if it is shared. The code here
                            // mimics the API set, rather than the UI
                            //
                            dwError = ::SetPrinter(hPrinter, 7, (PBYTE)&Info7, 0) ? ERROR_SUCCESS : GetLastError();
    
                            //
                            // Printer info 7 fails with ERROR_IO_PENDING when the publishing is occurring
                            // in the background. 
                            //
                            dwError = dwError == ERROR_IO_PENDING ? ERROR_SUCCESS : dwError;                            
                        }                        
                    }

                    //
                    // Release the printer info data.
                    //
                    delete [] pInfo;
                }

                //
                // Close the printer handle
                //
                ::ClosePrinter(hPrinter);
            }
            else
            {
                dwError = GetLastError();
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrinterSet returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplPrinterRename

Routine Description:

    Changes the name of a printer

Arguments:

    pCurrentPrinterName - old printer name
    pNewPrinterName     - new printer name

Return Value:

    Win32 error code

--*/
DWORD
SplPrinterRename(
    IN LPCWSTR pCurrentPrinterName,
    IN LPCWSTR pNewPrinterName
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pCurrentPrinterName && pNewPrinterName)
    {
        HANDLE             hPrinter         = NULL;
        PPRINTER_INFO_2    pInfo            = NULL;
        PRINTER_DEFAULTS   PrinterDefaults  = {NULL, NULL, PRINTER_ALL_ACCESS};

        dwError = ERROR_DLL_NOT_FOUND;

        //
        // Open the printer.
        //
        
        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            dwError = ::OpenPrinter(const_cast<LPTSTR>(pCurrentPrinterName), &hPrinter, &PrinterDefaults) ? ERROR_SUCCESS : GetLastError();

            if (dwError==ERROR_SUCCESS)
            {
                //
                // Get the printer data. ATTENTION. This would normally not work on Win9x,
                // because of the MUTEX
                //
                dwError = GetThisPrinter(hPrinter, 2, reinterpret_cast<BYTE **>(&pInfo));

                if (dwError==ERROR_SUCCESS)
                {
                    pInfo->pPrinterName = const_cast<LPWSTR>(pNewPrinterName);

                    dwError = ::SetPrinter(hPrinter, 2, reinterpret_cast<BYTE *>(pInfo), 0) ? ERROR_SUCCESS : GetLastError();

                    delete [] pInfo;
                }

                ::ClosePrinter(hPrinter);
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
            dwError = ERROR_DLL_NOT_FOUND;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPrinterRename returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplDriverAdd

Routine Description:

    Adds a printer driver.

Arguments:

    pszDriverName  - required name of the driver
    dwVersion      - driver version. optional (pass -1)
    pszEnvironment - driver environment. optional (pass NULL)
    pszInfName     - path to an inf file. optional (pass NULL)
    pszFilePath    - path to the driver binaries. optional (pass NULL)

Return Value:

    Win32 error code

--*/
DWORD
SplDriverAdd(
    IN LPCWSTR pszDriverName,
    IN DWORD   dwVersion,
    IN LPCWSTR pszEnvironment,
    IN LPCWSTR pszInfName,
    IN LPCWSTR pszFilePath)
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszDriverName)
    {
        //
        // CHString throws exceptions. We start building the
        // command string for calling into printui
        //
        try
        {
            CHString csCommand;
            CHString csTemp;

            csCommand += TUISymbols::kstrQuiet;
            csCommand += TUISymbols::kstrAddDriver;

            //
            // Append driver name to the command
            //
            csTemp.Format(TUISymbols::kstrDriverModelName, pszDriverName);
            csCommand += csTemp;

            //
            // Append inf file name to the command
            //
            if (pszInfName)
            {
                csTemp.Format(TUISymbols::kstrInfFile, pszInfName);
                csCommand += csTemp;
            }

            //
            // Append the path to the driver binaries to the command
            //
            if (pszFilePath)
            {
                csTemp.Format(TUISymbols::kstrDriverPath, pszFilePath);
                csCommand += csTemp;
            }

            if (pszEnvironment)
            {
                csTemp.Format(TUISymbols::kstrDriverArchitecture, pszEnvironment);
                csCommand += csTemp;
            }

            //
            // Append the driver verion to the command
            //
            if (dwVersion != (DWORD)-1)
            {
                csTemp.Format(TUISymbols::kstrDriverVersion, dwVersion);
                csCommand += csTemp;
            }

            DBGMSG(DBG_TRACE, (_T("SplDriverAdd csCommand \"%s\"\n"), csCommand));

            dwError = PrintUIEntryW(csCommand);
        }
        catch (CHeap_Exception)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplDriverAdd returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name

    SplDriverDel

Routine Description:

    Deletes a printer driver.

Arguments:

    pszDriverName  - required name of the driver
    dwVersion      - optional (pass -1)
    pszEnvironment - optional (pass NULL)

Return Value:

    Win32 error code

--*/
DWORD
SplDriverDel(
    IN LPCWSTR pszDriverName,
    IN DWORD   dwVersion,
    IN LPCWSTR pszEnvironment
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszDriverName)
    {
        //
        // CHString throws exceptions. We start building the
        // command string for calling into printui
        //
        try
        {
            CHString csCommand;
            CHString csTemp;

            csCommand += TUISymbols::kstrQuiet;
            csCommand += TUISymbols::kstrDelDriver;

            //
            // Append driver name to the command
            //
            csTemp.Format(TUISymbols::kstrDriverModelName, pszDriverName);
            csCommand += csTemp;

            if (pszEnvironment)
            {
                csTemp.Format(TUISymbols::kstrDriverArchitecture, pszEnvironment);
                csCommand += csTemp;
            }

            //
            // Append the driver verion to the command
            //
            if (dwVersion!=(DWORD)-1)
            {
                csTemp.Format(TUISymbols::kstrDriverVersion, dwVersion);
                csCommand += csTemp;
            }

            DBGMSG(DBG_TRACE, (_T("SplDriverDel csCommand \"%s\"\n"), csCommand));

            dwError = PrintUIEntryW(csCommand);
        }
        catch (CHeap_Exception)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplDriverDel returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name:

    SplPortAddTCP

Routine Description:

    Add a Standard TCP port

Arguments:

    PORT_DATA_1 structure

Return Value:

    Win32 error code

--*/
DWORD
SplPortAddTCP(
    IN PORT_DATA_1 &Port
    )
{
    DWORD             dwError        = ERROR_INVALID_PARAMETER;
    PRINTER_DEFAULTS  PrinterDefault = {NULL, NULL, SERVER_ACCESS_ADMINISTER};
    HANDLE            hXcvPrinter    = NULL;
    PORT_DATA_1       PortDummy      = {0};

    memcpy(&PortDummy, &Port, sizeof(Port));

    if (PortDummy.sztPortName[0])
    {
        dwError = ERROR_DLL_NOT_FOUND;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            dwError = ::OpenPrinter(kXcvPortOpenPrinter, &hXcvPrinter, &PrinterDefault) ? ERROR_SUCCESS : GetLastError();

            if (dwError==ERROR_SUCCESS)
            {
                //
                // Set defaults
                //
                PortDummy.dwCoreUIVersion  = kCoreVersion;
                PortDummy.dwVersion        = kTCPVersion;
                PortDummy.cbSize           = sizeof(PortDummy);
                PortDummy.dwProtocol       = PortDummy.dwProtocol     ? PortDummy.dwProtocol     : kProtocolRaw;
                PortDummy.dwSNMPDevIndex   = PortDummy.dwSNMPDevIndex ? PortDummy.dwSNMPDevIndex : kDefaultSnmpIndex;

                //
                // Set default port number
                //
                if (!PortDummy.dwPortNumber)
                {
                    PortDummy.dwPortNumber = PortDummy.dwProtocol==kProtocolRaw ? kDefaultRawNumber : kDefaultLprNumber;
                }

                if (PortDummy.dwSNMPEnabled && !PortDummy.sztSNMPCommunity[0])
                {
                    wcscpy(PortDummy.sztSNMPCommunity, _T("public"));
                }

                if (PortDummy.dwProtocol==kProtocolLpr && !PortDummy.sztQueue[0])
                {
                    wcscpy(PortDummy.sztQueue, _T("lpr"));
                }

                dwError  = CallXcvDataW(hXcvPrinter,
                                        kXcvPortAdd,
                                        reinterpret_cast<BYTE *>(&PortDummy),
                                        PortDummy.cbSize,
                                        NULL,
                                        0);

                ::ClosePrinter(hXcvPrinter);
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }

    }

    DBGMSG(DBG_TRACE, (_T("SplPortAddTCP returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name:

    SplTCPPortSetConfig

Routine Description:

    Set configuration of a Standard TCP port. Note that we do not default any properties.

Arguments:

    PORT_DATA_1 structure

Return Value:

    Win32 error code

--*/
DWORD
SplTCPPortSetConfig(
    IN PORT_DATA_1 &Port
    )
{
    DWORD             dwError        = ERROR_INVALID_PARAMETER;
    PRINTER_DEFAULTS  PrinterDefault = {NULL, NULL, SERVER_ACCESS_ADMINISTER};
    HANDLE            hXcvPrinter    = NULL;
    PORT_DATA_1       PortDummy      = {0};

    memcpy(&PortDummy, &Port, sizeof(Port));

    if (PortDummy.sztPortName[0])
    {
        dwError = ERROR_DLL_NOT_FOUND;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;
        try
        {
            dwError = ::OpenPrinter(kXcvPortOpenPrinter, &hXcvPrinter, &PrinterDefault) ? ERROR_SUCCESS : GetLastError();

            if (dwError == ERROR_SUCCESS)
            {
                //
                // Set defaults
                //
                PortDummy.dwCoreUIVersion  = kCoreVersion;
                PortDummy.dwVersion        = kTCPVersion;
                PortDummy.cbSize           = sizeof(PortDummy);

                //
                // Set default port number
                //
                if (!PortDummy.dwPortNumber)
                {
                    PortDummy.dwPortNumber = PortDummy.dwProtocol==kProtocolRaw ? kDefaultRawNumber : kDefaultLprNumber;
                }

                //
                // Set default queue name 
                //
                if (PortDummy.dwProtocol == LPR && !PortDummy.sztQueue[0])
                {
                    wcscpy(PortDummy.sztQueue, kDefaultQueue);
                }

                //
                // Set default snmp community name 
                //
                if (PortDummy.dwSNMPEnabled && !PortDummy.sztSNMPCommunity[0])
                {
                    wcscpy(PortDummy.sztSNMPCommunity, kDefaultCommunity);
                }

                dwError  = CallXcvDataW(hXcvPrinter,
                                        kXcvPortSetConfig,
                                        reinterpret_cast<BYTE *>(&PortDummy),
                                        PortDummy.cbSize,
                                        NULL,
                                        0);

                ::ClosePrinter(hXcvPrinter);
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPortSetTCP returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name:

    SplPortDelTCP

Routine Description:

    Delete a Standard TCP port

Arguments:

    pszPort - port name

Return Value:

    Win32 error code

--*/
DWORD
SplPortDelTCP(
    IN LPCWSTR pszPort
    )
{
    DWORD              dwError        = ERROR_INVALID_PARAMETER;
    PRINTER_DEFAULTS   PrinterDefault = {NULL, NULL, SERVER_ACCESS_ADMINISTER};
    HANDLE             hXcvPrinter    = NULL;
    DELETE_PORT_DATA_1 PortDummy      = {0};

    if (pszPort && wcslen(pszPort) < MAX_PORTNAME_LEN)
    {
        dwError = ERROR_DLL_NOT_FOUND;

        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;

        try
        {
            dwError = ::OpenPrinter(kXcvPortOpenPrinter, &hXcvPrinter, &PrinterDefault) ? ERROR_SUCCESS : GetLastError();

            if (dwError==ERROR_SUCCESS)
            {
                PortDummy.dwVersion = kTCPVersion;

                wcscpy(PortDummy.psztPortName, pszPort);

                dwError  = CallXcvDataW(hXcvPrinter,
                                        kXcvPortDelete,
                                        reinterpret_cast<BYTE *>(&PortDummy),
                                        sizeof(PortDummy),
                                        NULL,
                                        0);

                ::ClosePrinter(hXcvPrinter);
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplPortDelTCP returns %u\n"), dwError));

    return dwError;
}

/*++

Routine Name:

    SplTCPPortGetConfig

Routine Description:

    Gets the configuration of a Standard TCP port

Arguments:

    pszPort - port name
    pData   - pointer to PORT_DATA_1 structure

Return Value:

    Win32 error code

--*/
DWORD
SplTCPPortGetConfig(
    IN     LPCWSTR       pszPort,
    IN OUT PORT_DATA_1 *pPortData
    )
{
    DWORD              dwError        = ERROR_INVALID_PARAMETER;
    PRINTER_DEFAULTS   PrinterDefault = {NULL, NULL, SERVER_ACCESS_ADMINISTER};
    HANDLE             hXcvPrinter    = NULL;
    
    if (pPortData && pszPort && wcslen(pszPort) < MAX_PORTNAME_LEN)
    {
        dwError = ERROR_DLL_NOT_FOUND;

        CHString csPort;

        csPort += kXcvPortConfigOpenPrinter;

        csPort += pszPort;
        // Use of delay loaded functions requires exception handler.
        SetStructuredExceptionHandler seh;

        try
        {
            dwError = ::OpenPrinter(const_cast<LPWSTR>(static_cast<LPCWSTR>(csPort)),
                                                &hXcvPrinter,
                                                &PrinterDefault) ? ERROR_SUCCESS : GetLastError();

            if (dwError==ERROR_SUCCESS)
            {
                CONFIG_INFO_DATA_1 cfgData = {0};
                cfgData.dwVersion          = 1;

                dwError = CallXcvDataW(hXcvPrinter,
                                      kXcvPortGetConfig,
                                      reinterpret_cast<BYTE *>(&cfgData),
                                      sizeof(cfgData),
                                      reinterpret_cast<BYTE *>(pPortData),
                                      sizeof(PORT_DATA_1));

                ::ClosePrinter(hXcvPrinter);
            }

            if (dwError == ERROR_SUCCESS) 
            {
                //
                // XcvData doesn't set port name in the port data structure.
                // We have to set it manually because that field may be used by the caller
                //
                wcscpy(pPortData->sztPortName, pszPort);
            }
        }
        catch(Structured_Exception se)
        {
            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        }
    }

    DBGMSG(DBG_TRACE, (_T("SplTCPPortGetConfig returns %u\n"), dwError));

    return dwError;
}





/*++

   Description:

   The following constants and functions are needed by the CompilePort.
   Thw whole functionality is used in the following context: we have an
   IP address. We find out what kind of device has that IP. Then we retrieve
   the properties of that device,if it is a printing device.

--*/
LPCWSTR pszIniNumPortsKey            = _T("PORTS");
LPCWSTR pszIniPortProtocolKey        = _T("PROTOCOL%d");
LPCWSTR pszIniPortNumberKey          = _T("PORTNUMBER%d");
LPCWSTR pszIniQueueKey               = _T("QUEUE%d");
LPCWSTR pszIniDoubleSpoolKey         = _T("LPRDSPOOL%d");
LPCWSTR pszSnmpCommunityKey          = _T("COMMUNITYNAME%d");
LPCWSTR pszIniSnmpDeviceIndex        = _T("DEVICE%d");
LPCWSTR pszIniSnmpEnabledKey         = _T("SNMP%d");
LPCWSTR pszIniPortDeviceNameKey      = _T("NAME");
LPCWSTR pszIniPortPortNameKey        = _T("NAME%d");
LPCWSTR pszPortProtocolRawString     = _T("RAW");
LPCWSTR pszPortProtocolLprString     = _T("LPR");
LPCWSTR pszSnmpEnabledYesString      = _T("YES");
LPCWSTR pszSnmpEnabledNoString       = _T("NO");
LPCWSTR pszTcpPortNamePrefix         = _T("IP_");
LPCWSTR pszIniFileName               = _T("%SystemRoot%\\system32\\tcpmon.ini");
LPCWSTR pszTcpMibDll                 = _T("tcpmib.dll");
LPCWSTR pszDefaultCommunityW         = _T("public");
LPCSTR  pszDefaultCommunityA         = "public";

enum EConstants
{
    kDefaultSNMPDeviceIndex  = 1,
    kSnmpEnabled             = 1,
    kSnmpDisabled            = 0,
};

class CTcpMib;

typedef CTcpMib* (CALLBACK *RPARAM_1) (VOID);

EXTERN_C CTcpMib* GetTcpMibPtr(VOID);

class __declspec(dllexport) CTcpMib
{
public:
    CTcpMib() { };

    virtual ~CTcpMib() { };

    virtual
    BOOL
    SupportsPrinterMib(LPCSTR lpszIPAddress,
                       LPCSTR lpszSNMPCommunity,
                       DWORD  dwSNMPDeviceIndex,
                       PBOOL  pbSupported) = 0;

    virtual
    DWORD
    GetDeviceDescription(LPCSTR lpszIPAddress,
                         LPCSTR lpszSNMPCommunity,
                         DWORD  dwSNMPDeviceIndex,
                         LPTSTR lpszDeviceDescription,
                         DWORD  dwDeviceDescriptionLen) = 0;
};

/*++

Routine Name:

    GetDeviceSettings

Routine Description:

    Gets the appropriate section name from the ini file based on the device description

Arguments:

    PortData - port data structure

Return Value:

    TRUE is function succeeds and port setting is collected

--*/
BOOL
GetDeviceSettings(
    IN OUT PORT_DATA_1 &PortData
    )
{
    DWORD     dwSelPortOnDevice = 1;
    WSADATA   wsaData;
    HINSTANCE hInstance;
    FARPROC   pGetTcpMibPtr;
    CTcpMib   *pTcpMib;
    WCHAR     szIniFileName[MAX_PATH + 1];
    CHAR      szHostAddressA[256];
    WCHAR     szDeviceSectionName[256];
    WCHAR     szPortProtocol[256];
    WCHAR     szKeyName[256];
    WCHAR     szDeviceName[256];
    DWORD     dwNumPortsOnDevice, TalkError;
    BOOL      bSNMPEnabled = FALSE;
    HRESULT   hRes         = WBEM_E_INVALID_PARAMETER;
    DWORD     dwError;

    //
    // Validate arguments
    //
    if (PortData.sztHostAddress[0])
    {
        hRes = WBEM_S_NO_ERROR;
    }

    if (SUCCEEDED(hRes))
    {
        hRes = WBEM_E_NOT_FOUND;

        CWsock32Api *pWSock32api = (CWsock32Api*)CResourceManager::sm_TheResourceManager.GetResource(g_guidWsock32Api, NULL);
    
        if (pWSock32api)
        {
            dwError = pWSock32api->WsWSAStartup(0x0101, (LPWSADATA) &wsaData);

            hRes    = WinErrorToWBEMhResult(dwError);

            if (SUCCEEDED(hRes))
            {
                if (hInstance = LoadLibrary(pszTcpMibDll))
                {
                    //
                    // Get the class pointer and class object and ini filename
                    //
                    if ( (pGetTcpMibPtr = (FARPROC) GetProcAddress(hInstance, "GetTcpMibPtr"))                             &&
                         (pTcpMib       = (CTcpMib *) pGetTcpMibPtr())                                                     &&
                         ExpandEnvironmentStrings(pszIniFileName, szIniFileName, sizeof(szIniFileName) / sizeof(WCHAR))    &&
                         WideCharToMultiByte(CP_ACP,
                                             0,
                                             PortData.sztHostAddress,
                                             -1,
                                             szHostAddressA,
                                             sizeof(szHostAddressA),
                                             NULL,
                                             NULL)                                                                       &&
                         (TalkError = pTcpMib->GetDeviceDescription(szHostAddressA,
                                                                    pszDefaultCommunityA,
                                                                    kDefaultSNMPDeviceIndex,
                                                                    PortData.sztDeviceType,
                                                                    sizeof(PortData.sztDeviceType))) == NO_ERROR         &&
                         GetDeviceSectionFromDeviceDescription(szIniFileName,
                                                               PortData.sztDeviceType,
                                                               szDeviceSectionName,
                                                               sizeof(szDeviceSectionName) / sizeof(WCHAR))              &&
                         pTcpMib->SupportsPrinterMib(szHostAddressA,
                                                     pszDefaultCommunityA,
                                                     kDefaultSNMPDeviceIndex,
                                                     &bSNMPEnabled))
                    {
                        PortData.dwSNMPEnabled = bSNMPEnabled ? kSnmpEnabled : kSnmpDisabled;

                        if (bSNMPEnabled)
                        {
                            PortData.dwSNMPDevIndex = kDefaultSNMPDeviceIndex;

                            wcscpy(PortData.sztSNMPCommunity, pszDefaultCommunityW);
                        }

                        //
                        // Get the Device name, ex: Hewlett Packard Jet Direct
                        //
                        hRes = GetIniString(szIniFileName,
                                            szDeviceSectionName,
                                            pszIniPortDeviceNameKey,
                                            szDeviceName,
                                            sizeof(szDeviceName) / sizeof(WCHAR)) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;

                        if (SUCCEEDED(hRes))
                        {
                            //
                            // Get the number of ports on the device
                            //
                            hRes = GetIniDword(szIniFileName,
                                               szDeviceSectionName,
                                               pszIniNumPortsKey,
                                               &dwNumPortsOnDevice) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
                        }

                        if (SUCCEEDED(hRes))
                        {
                            //
                            // Create the string used to query the protocol, ex: PROTOCOL2
                            // refers to the protocol of the second port on the device
                            //
                            wsprintf(szKeyName, pszIniPortProtocolKey, dwSelPortOnDevice);

                            //
                            // Get the port protocol from the ini file
                            //
                            hRes = GetIniString(szIniFileName,
                                                szDeviceSectionName,
                                                szKeyName,
                                                szPortProtocol,
                                                sizeof(szPortProtocol) / sizeof(WCHAR)) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
                        }

                        if (SUCCEEDED(hRes))
                        {
                            //
                            // Fill in the result of the query
                            //
                            if (!_wcsicmp(szPortProtocol, pszPortProtocolRawString))
                            {
                                PortData.dwProtocol = RAWTCP;
                            }
                            else if (!_wcsicmp(szPortProtocol, pszPortProtocolLprString))
                            {
                                PortData.dwProtocol = LPR;
                            }
                            else
                            {
                                hRes = WBEM_E_FAILED;
                            }
                        }

                        if (SUCCEEDED(hRes))
                        {
                            //
                            // If the protocol is RAW then we need to query for the port number,
                            // if it is LPR then we query for the QUEUE
                            //
                            if (PortData.dwProtocol == RAWTCP)
                            {
                                //
                                // Create the string used to query for the port number, ex: PORTNUMBER2
                                // referrs to the port number of the second port on the device
                                //
                                wsprintf(szKeyName, pszIniPortNumberKey, dwSelPortOnDevice);

                                hRes = GetIniDword(szIniFileName,
                                                   szDeviceSectionName,
                                                   szKeyName,
                                                   &PortData.dwPortNumber) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
                            }
                            else
                            {
                                //
                                // Create the string used to query for the queue name, ex: QUEUE2
                                // referrs to the queue of the second port on the device
                                //
                                wsprintf(szKeyName, pszIniQueueKey, dwSelPortOnDevice);

                                hRes = GetIniString(szIniFileName,
                                                    szDeviceSectionName,
                                                    szKeyName,
                                                    PortData.sztQueue,
                                                    MAX_QUEUENAME_LEN) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
                            }
                        }

                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings szIniFileName %s\n"),       szIniFileName));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings szDeviceDescription %s\n"), PortData.sztDeviceType));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings szDeviceSectionName %s\n"), szDeviceSectionName));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings szDeviceName        %s\n"), szDeviceName));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings dwNumPortsOnDevice  %u\n"), dwNumPortsOnDevice));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings dwPortNumber        %u\n"), PortData.dwPortNumber));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings Queue               %s\n"), PortData.sztQueue));
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings szPortProtocol      %s\n"), szPortProtocol));
                    }
                    else
                    {
                        //
                        // Talking to device through sockets failed
                        //
                        DBGMSG(DBG_TRACE, (_T("GetDeviceSettings TalkError  %u \n"), TalkError));

                        hRes = WBEM_E_INVALID_PARAMETER;
                    }

                    FreeLibrary(hInstance);
                }
                else
                {
                    //
                    // LoadLibrary failed
                    //
                    dwError = GetLastError();

                    hRes    = WinErrorToWBEMhResult(dwError);
                }

                pWSock32api->WsWSACleanup();
            }

            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWsock32Api, pWSock32api);
        }
    }

    DBGMSG(DBG_TRACE, (_T("GetDeviceSettings returns %x\n"), hRes));

    return SUCCEEDED(hRes);
}


#endif // NTONLY == 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\processdll.cpp ===
//=================================================================

//

// ProcessDLL.CPP -- CWin32ProcessDLL

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    sotteson         Created
//
//=================================================================

#include "precomp.h"
#include <tlhelp32.h>
#include "WBEMPSAPI.h"
#include "Kernel32Api.h"
#include "NtDllApi.h"
#include "processdll.h"
#include "CProcess.h"

// Struct used by the EnumInstancesCallback function.

struct ENUM_INST_DATA
{
public:

	MethodContext *pMethodContext;
    CWin32ProcessDLL *pThis;
	HRESULT hres ;

} ;

struct ASSOC_DATA
{
    DWORD dwProcessID ;
    CHString strDLL ;
    HRESULT hres ;
    BOOL bFoundProcessID ;
    CInstance *pInstance ;
    CWin32ProcessDLL *pThis ;
} ;

CWin32ProcessDLL processdll;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: CWin32ProcessDll
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CWin32ProcessDLL :: CWin32ProcessDLL () : Provider ( L"CIM_ProcessExecutable", IDS_CimWin32Namespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: ~CWin32ProcessDll
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CWin32ProcessDLL :: ~CWin32ProcessDLL ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32ProcessDLL :: EnumerateInstances (

	MethodContext *pMethodContext,
    long lFlags
)
{
    ENUM_INST_DATA data;
	HRESULT t_hr ;
    data.pMethodContext = pMethodContext;
    data.pThis = this;

    // Enum through process modules.  EnumInstancesCallback will Commit
    // each instance.

    t_hr = EnumModulesWithCallback ( EnumInstancesCallback , &data , pMethodContext ) ;
	if ( FAILED ( data.hres ) )
	{
		return data.hres ;
	}
	else
	{
		return t_hr ;
	}
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32ProcessDLL :: GetObject (

	CInstance *pInstance,
	long lFlags
)
{
    CInstancePtr pProcess;
    CInstancePtr pDLL;
    CHString strProcessPath ;
	CHString strDLLPath;

    pInstance->GetCHString(IDS_Dependent, strProcessPath);
    pInstance->GetCHString(IDS_Antecedent, strDLLPath);

    // If we can get both objects, test for an association

    HRESULT     hres;

    if (SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(strDLLPath, &pDLL, pInstance->GetMethodContext())) &&
        SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(strProcessPath,
            &pProcess, pInstance->GetMethodContext())))
    {
        hres = AreAssociated(pInstance, pProcess, pDLL);
    }
    else
    {
        hres = WBEM_E_NOT_FOUND;
    }

    return hres;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: AreWeAssociated
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32ProcessDLL :: AreAssociated (

	CInstance *pProcessDLL,
    CInstance *pProcess,
	CInstance *pDLL
)
{
    CHString strHandle;
    pProcess->GetCHString(L"Handle", strHandle);

    ASSOC_DATA  data;

    data.dwProcessID = wcstoul(strHandle, NULL, 10);
    pDLL->GetCHString(L"Name", data.strDLL);
    data.hres = WBEM_E_NOT_FOUND;
    data.bFoundProcessID = FALSE;
    data.pInstance = pProcessDLL;
    data.pThis = this;

    // Enum processes and their DLLs and see if we can find a match.

    HRESULT hres;
    if ( FAILED ( hres = EnumModulesWithCallback ( IsAssocCallback, &data, pDLL->GetMethodContext () ) ) )
	{
        return hres;
	}
    else
	{
        return data.hres;
	}
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: EnumModulesWithCallback
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY

HRESULT CWin32ProcessDLL :: EnumModulesWithCallback (

	MODULEENUMPROC fpCallback,
    LPVOID pUserDefined,
	MethodContext *a_pMethodContext
)
{
    // This will help us find out if the current user didn't have
    // enough rights.
    HRESULT t_hr = WBEM_S_NO_ERROR ;
    BOOL bDone = FALSE;

	CNtDllApi *pNtdll = ( CNtDllApi * ) CResourceManager::sm_TheResourceManager.GetResource ( g_guidNtDllApi, NULL ) ;
	if ( pNtdll )
	{
		SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

		try
		{
			t_ProcessBlock = Process :: RefreshProcessCacheNT (

														*pNtdll ,
														a_pMethodContext ,
														&t_hr /* = NULL */
													) ;

			SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = t_ProcessBlock ;
			while ( t_CurrentInformation )
			{
				SmartCloseHandle hProcess = OpenProcess (

					PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
					FALSE,
					HandleToUlong ( t_CurrentInformation->UniqueProcessId )
				) ;

				// Make sure we can open the process.
				if ( hProcess )
				{
					MODULEENTRY32 module;

					// Fill in the members that won't change.

					module.dwSize = sizeof(module);
					module.GlblcntUsage = (DWORD) -1;

					LIST_ENTRY *t_LdrHead = NULL;

					BOOL t_Status = Process :: GetProcessModuleBlock (

						*pNtdll ,
						hProcess ,
						t_LdrHead
					) ;

					LIST_ENTRY *t_LdrNext = t_LdrHead ;

					while ( t_Status )
					{
						CHString t_ModuleName ;
						t_Status = Process :: NextProcessModule (

							*pNtdll ,
							hProcess ,
							t_LdrHead ,
							t_LdrNext ,
							t_ModuleName,
                            (DWORD_PTR *) &module.hModule,
                            &module.ProccntUsage
						) ;

						if ( t_Status )
						{
							lstrcpy(module.szExePath, t_ModuleName);

							// Set the process ID
							module.th32ProcessID = HandleToUlong ( t_CurrentInformation->UniqueProcessId ) ;

							// Call the callback
							// If the callback function returns 0, break out.

							if (!fpCallback(&module, pUserDefined))
							{
								bDone = TRUE;
								break;
							}
						}
            		}
				}

				t_CurrentInformation = Process :: NextProcessBlock ( *pNtdll , t_CurrentInformation ) ;
			}
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

			if ( t_ProcessBlock )
			{
				delete [] ( PBYTE )t_ProcessBlock ;
				t_ProcessBlock = NULL ;
			}
			throw ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

		if ( t_ProcessBlock )
		{
			delete [] ( PBYTE )t_ProcessBlock ;
			t_ProcessBlock = NULL ;
		}
	}
	else
	{
		t_hr = WBEM_E_FAILED ;
	}

    return t_hr ;
}

#else

HRESULT CWin32ProcessDLL :: EnumModulesWithCallback (

	MODULEENUMPROC fpCallback,
    LPVOID pUserDefined,
	MethodContext *a_pMethodContext
)
{
    // This will help us find out if the current user didn't have
    // enough rights.
    int nOpened = 0;

    //CToolHelp     toolhelp;
    SmartCloseHandle hProcesses;
    PROCESSENTRY32  proc;

    BOOL            bDone;

    CKernel32Api *pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
    if(pKernel32 == NULL)
    {
        return WBEM_E_FAILED;
    }

    try // pKernel32
    {
        if ( pKernel32->CreateToolhelp32Snapshot ( TH32CS_SNAPPROCESS , 0 , & hProcesses ) )
        {
            proc.dwSize = sizeof(proc);
            if(pKernel32->Process32First(hProcesses, &proc, &bDone))
            {
                bDone = !bDone;
                while (!bDone)
                {
                    SmartCloseHandle hModules ;
                    pKernel32->CreateToolhelp32Snapshot (

						TH32CS_SNAPMODULE,
                        proc.th32ProcessID,
                        &hModules
					);

                    BOOL bModDone;

                    MODULEENTRY32 module;
                    module.dwSize = sizeof(module);

                    if(hModules != NULL)
                    {
                        if(pKernel32->Module32First(hModules, &module, &bModDone))
                        {
                            bModDone = !bModDone;
                            while (!bModDone)
                            {
                                nOpened++;

                                // If the callback function returns 0, break out.
                                if (!fpCallback(&module, pUserDefined))
                                {
                                    bDone = TRUE;
                                    break;
                                }

                                pKernel32->Module32Next(hModules, &module, &bModDone);
                                bModDone = !bModDone;
                            }

                            // May have been changed after the call to fpCallback.
                            if (bDone)
                                break;

                        }
                    }

                    pKernel32->Process32Next(hProcesses, &proc, &bDone);
					bDone = !bDone;
                }
            }
        }
    }
    catch ( ... )
    {
        if(pKernel32 != NULL)
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
            pKernel32 = NULL;
        }
        throw ;
    }

    if(pKernel32 != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
        pKernel32 = NULL;
    }

    if (!nOpened)
	{
        // Assume access was denied if we couldn't open a single process.
        return WBEM_E_ACCESS_DENIED;
	}

    return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: SetInstanceData
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32ProcessDLL :: SetInstanceData (

	CInstance *pInstance,
    MODULEENTRY32 *pModule
)
{
    if (pModule->GlblcntUsage != (DWORD) -1 && pModule->GlblcntUsage != (WORD) -1)
        pInstance->SetDWORD(L"GlobalProcessCount", pModule->GlblcntUsage);

    if (pModule->ProccntUsage != (DWORD) -1 && pModule->ProccntUsage != (WORD) -1)
        pInstance->SetDWORD(L"ProcessCount", pModule->ProccntUsage);

    if (pModule->hModule != (HINSTANCE) -1)
    {
        // The compiler does funny things without the (DWORD_PTR) cast.
        pInstance->SetWBEMINT64(L"BaseAddress",
            (unsigned __int64) (DWORD_PTR) pModule->hModule);

        // Deprecated, but we'll return it anyway.
        pInstance->SetDWORD(L"ModuleInstance", (DWORD)((DWORD_PTR)pModule->hModule));
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: EnumInstancesCallback
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CALLBACK CWin32ProcessDLL :: EnumInstancesCallback (

	MODULEENTRY32 *pModule,
    LPVOID pUserDefined
)
{
    ENUM_INST_DATA *pData = (ENUM_INST_DATA *) pUserDefined ;

	CHString sTemp ;

    CInstancePtr pInstance(pData->pThis->CreateNewInstance(pData->pMethodContext), false);

    // Get the relative path to the process
    // We used to build this path like for the DLL below, but once
    // Win32_Process moved to cimwin33.dll the CWbemProviderGlue::GetEmptyInstance
    // call quit working.

    sTemp.Format (

        L"\\\\%s\\%s:Win32_Process.Handle=\"%lu\"",
        pData->pThis->GetLocalComputerName(),
        IDS_CimWin32Namespace,
        pModule->th32ProcessID
	);

    pInstance->SetCHString(IDS_Dependent, sTemp);

    // Get the relative path to the DLL

    sTemp = pModule->szExePath;
	CHString strDLLPathAdj ;
    EscapeBackslashes(sTemp, strDLLPathAdj);

    sTemp.Format(

        L"\\\\%s\\%s:CIM_DataFile.Name=\"%s\"",
        pData->pThis->GetLocalComputerName(),
        IDS_CimWin32Namespace,
        (LPCWSTR)strDLLPathAdj
	);

    pInstance->SetCHString(IDS_Antecedent, sTemp);

    pData->pThis->SetInstanceData(pInstance, pModule);

    if ( FAILED ( pData->hres = pInstance->Commit() ) )
	{
		return FALSE ;
	}
    return TRUE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProcessDll :: IsAssocCallback
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// Callback used by GetObject to see if a given process\DLL pair are
// associated.
BOOL CALLBACK CWin32ProcessDLL :: IsAssocCallback (

	MODULEENTRY32 *pModule,
    LPVOID pUserDefined
)
{
    ASSOC_DATA *pData = (ASSOC_DATA *) pUserDefined;

    if (pModule->th32ProcessID == pData->dwProcessID)
    {
        if (!pData->strDLL.CompareNoCase(TOBSTRT(pModule->szExePath)))
        {
            pData->hres = WBEM_S_NO_ERROR;

            pData->pThis->SetInstanceData(pData->pInstance, pModule);

            // Because we want to stop enumeration once we've found the requested
            // object.
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\processor.cpp ===
//=================================================================

//

// Processor.CPP --Processor property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "perfdata.h"

#include "cpuid.h"
#include "processor.h"
#include "computersystem.h"

#include "smbios.h"
#include "smbstruc.h"
#include "resource.h"

// Property set declaration
//=========================

CWin32Processor	win32Processor(PROPSET_NAME_PROCESSOR, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Processor::CWin32Processor
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for provider.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Processor::CWin32Processor(LPCWSTR strName, LPCWSTR pszNamespace)
	:	Provider(strName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Processor::~CWin32Processor
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Processor::~CWin32Processor()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32Processor::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32Processor::GetObject(
    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery &query)
{
	BOOL		bRetCode = FALSE;
	DWORD		dwIndex;
    CHString    sDevice;
    WCHAR       szTemp[100];
    int         nProcessors = GetProcessorCount();

    // Ok, now let's check the deviceid
	pInstance->GetCHString(IDS_DeviceID, sDevice);
    dwIndex = _wtoi(sDevice.Mid(3));

	swprintf(szTemp, L"CPU%d", dwIndex);

    // Is this REALLY us?
    if (sDevice.CompareNoCase(szTemp) == 0 && dwIndex < nProcessors)
	{
#ifdef NTONLY
	    int nProcessors = GetProcessorCount();

		if (nProcessors > 0)
		{
			// Get the data
			PROCESSOR_POWER_INFORMATION *pProcInfo = new PROCESSOR_POWER_INFORMATION[nProcessors];
			
			try
			{
				memset(pProcInfo, 0, sizeof(PROCESSOR_POWER_INFORMATION) * nProcessors);
				NTSTATUS ntStatus = NtPowerInformation(ProcessorInformation,
														NULL,
														0,
														pProcInfo,
														sizeof(PROCESSOR_POWER_INFORMATION) * nProcessors
														);

				bRetCode = LoadProcessorValues(dwIndex, pInstance, query,
												pProcInfo[dwIndex].MaxMhz,
												pProcInfo[dwIndex].CurrentMhz);
			}
			catch(...)
			{
				if (pProcInfo)
				{
					delete [] pProcInfo;
				}
				
				throw;
			}

			if (pProcInfo)
			{
				delete [] pProcInfo;
			}
		}
#else
		bRetCode = LoadProcessorValues(dwIndex, pInstance, query, 0, 0);
#endif
	}

	return bRetCode ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32Processor::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32Processor::EnumerateInstances(MethodContext* pMethodContext, long lFlags)
{
    CFrameworkQuery query;

    return ExecQuery(pMethodContext, query, lFlags);
}

HRESULT CWin32Processor::ExecQuery(
    MethodContext* pMethodContext,
    CFrameworkQuery &query,
    long lFlags)
{
	HRESULT         hr = WBEM_S_NO_ERROR;
	CInstancePtr    pInstance;
    int             nProcessors = GetProcessorCount();

#ifdef NTONLY
	if (nProcessors > 0)
	{
		PROCESSOR_POWER_INFORMATION *pProcInfo = new PROCESSOR_POWER_INFORMATION[nProcessors];
		
		try
		{
			memset(pProcInfo, 0, sizeof(PROCESSOR_POWER_INFORMATION) * nProcessors);
			NTSTATUS ntStatus = NtPowerInformation(ProcessorInformation,
													NULL,
													0,
													pProcInfo,
													sizeof(PROCESSOR_POWER_INFORMATION) * nProcessors
													);

			for (DWORD dwInstanceCount = 0;
				dwInstanceCount < nProcessors && WBEM_S_NO_ERROR == hr;
				dwInstanceCount++)
			{
				pInstance.Attach(CreateNewInstance(pMethodContext));

				// Release the instance if we are unable to obtain values.
				if (LoadProcessorValues(dwInstanceCount, pInstance, query,
										pProcInfo[dwInstanceCount].MaxMhz,
										pProcInfo[dwInstanceCount].CurrentMhz))
				{
					hr = pInstance->Commit();
				}
			}
		}
		catch(...)
		{
			if (pProcInfo)
			{
				delete [] pProcInfo;
			}
			
			throw;
		}

		if (pProcInfo)
		{
			delete [] pProcInfo;
		}
	}
#else
	for (DWORD dwInstanceCount = 0;
		dwInstanceCount < nProcessors && WBEM_S_NO_ERROR == hr;
		dwInstanceCount++)
	{
		pInstance.Attach(CreateNewInstance(pMethodContext));

		// Release the instance if we are unable to obtain values.
		if (LoadProcessorValues(dwInstanceCount, pInstance, query, 0,0))
		{
			hr = pInstance->Commit();
		}
	}
#endif

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Processor::LoadProcessorValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    : Assigns values to properties -- NT is the only instance
 *                where we have multiple processors and is symmetrical, so
 *                we can assign duplicate values to both processors
 *
 *****************************************************************************/

BOOL CWin32Processor::LoadProcessorValues(
    DWORD dwProcessorIndex,
    CInstance *pInstance,
    CFrameworkQuery &query,
	DWORD dwMaxSpeed,
	DWORD dwCurrentSpeed)
{
	WCHAR szTemp[100];

	swprintf(szTemp, L"CPU%d", dwProcessorIndex);
	pInstance->SetCharSplat(L"DeviceID", szTemp);

	// We're done if they only wanted the keys.
    if (query.KeysOnly())
        return TRUE;


    SYSTEM_INFO_EX info;

    if (!GetSystemInfoEx(dwProcessorIndex, &info, dwCurrentSpeed))
        return FALSE;

#ifdef NTONLY
	if ((dwMaxSpeed == 0) || (dwCurrentSpeed == 0))
	{
		wchar_t buff[100];
		_snwprintf(buff, 99, L"Zero processor speed returned from kernel: Max: %d, Current %d.", dwMaxSpeed, dwCurrentSpeed);
		LogErrorMessage(buff);
	}
#endif //NTONLY

    // Assign hard coded values
	pInstance->SetCHString(IDS_Role, L"CPU");
	pInstance->SetCharSplat(IDS_Status, L"OK");
	pInstance->SetCharSplat(L"CreationClassName", PROPSET_NAME_PROCESSOR);
	pInstance->Setbool(IDS_PowerManagementSupported, false);
	pInstance->SetCharSplat(L"SystemCreationClassName", PROPSET_NAME_COMPSYS);
	pInstance->SetCHString(L"SystemName", GetLocalComputerName());
	pInstance->SetWBEMINT16(IDS_Availability, 3);
	pInstance->SetWBEMINT16(IDS_StatusInfo, 3);

	// Some of these may get overridden below
    CHString    strTemp;

    Format(strTemp, IDR_CPUFormat, dwProcessorIndex);

	pInstance->SetCharSplat(IDS_Caption, strTemp);
    pInstance->SetCharSplat(IDS_Description, strTemp);

#ifdef _X86_
	pInstance->SetDWORD(L"AddressWidth", 32);
	pInstance->SetDWORD(L"DataWidth", 32);
#else
	pInstance->SetDWORD(L"AddressWidth", 64);
	pInstance->SetDWORD(L"DataWidth", 64);
#endif


#ifdef NTONLY
	if (query.IsPropertyRequired(L"LoadPercentage"))
    {
        // Get NT-only props
        DWORD   dwObjIndex,
                dwCtrIndex;
	    unsigned __int64
			    i64Value1,
			    i64Value2,
			    ilTime1,
			    ilTime2,
			    dwa,
			    dwb;
	    CPerformanceData
			    perfdata;
	    WCHAR   wszBuff[MAXITOA * 2];

	    dwObjIndex = perfdata.GetPerfIndex(L"Processor");
	    dwCtrIndex = perfdata.GetPerfIndex(L"% Processor Time");
	    if (dwObjIndex && dwCtrIndex)
	    {
		    _itow(dwProcessorIndex, wszBuff, 10);

		    perfdata.GetValue(dwObjIndex, dwCtrIndex, wszBuff, (PBYTE) &i64Value1,
			    &ilTime1);
		    Sleep(1000);
		    perfdata.GetValue(dwObjIndex, dwCtrIndex, wszBuff, (PBYTE) &i64Value2,
			    &ilTime2);

		    dwb = (ilTime2 - ilTime1);
		    dwa = (i64Value2 - i64Value1);

            // Just to be safe, we'll make sure dwb is non zero.
            if (dwb != 0)
            {
		        pInstance->SetDWORD(L"LoadPercentage", 100-((100 * dwa)/dwb));
            }
	    }
    }
#endif

    // Get the description needed for system info in Win2K.
    // This also works for Win98.
    CRegistry   reg;
    CHString    strDesc,
                strKey;

    strKey.Format(
        L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\%d",
        dwProcessorIndex);

    if (reg.OpenLocalMachineKeyAndReadValue(
        strKey,
        L"Identifier",
        strDesc) == ERROR_SUCCESS)
    {
        pInstance->SetCharSplat(IDS_Description, strDesc);
        pInstance->SetCharSplat(IDS_Caption, strDesc);
    }


	// Do all the stuff we got from GetSystemInfoEx
	pInstance->SetCharSplat(IDS_Name, info.szProcessorName);

	if (wcslen(info.szProcessorStepping))
	{
		pInstance->SetCharSplat(IDS_Stepping, info.szProcessorStepping);
	}

	pInstance->SetCharSplat(IDS_Version, info.szProcessorVersion);
	pInstance->SetCharSplat(IDS_Manufacturer, info.szProcessorVendor);
	pInstance->SetWBEMINT16(IDS_Architecture, info.wProcessorArchitecture);

	if (info.dwProcessorSpeed > 0)
	{
		pInstance->SetDWORD(IDS_CurrentClockSpeed, info.dwProcessorSpeed);
	}

    pInstance->SetWBEMINT16(IDS_Family, info.wWBEMProcessorFamily);
    pInstance->SetWBEMINT16(IDS_UpgradeMethod, info.wWBEMProcessorUpgradeMethod);

	if (info.dwProcessorL2CacheSize != (DWORD) -1)
		pInstance->SetDWORD(IDS_L2CacheSize, info.dwProcessorL2CacheSize);

	if (info.dwProcessorL2CacheSpeed != (DWORD) -1)
		pInstance->SetDWORD(IDS_L2CacheSpeed, info.dwProcessorL2CacheSpeed);

	pInstance->SetWBEMINT16(IDS_Level, info.wProcessorLevel);
	pInstance->SetWBEMINT16(IDS_Revision, info.wProcessorRevision);

    // CPUID Serial number
    if (info.dwSerialNumber[0] != 0)
    {
        WORD    *pwSerialNumber = (WORD *) info.dwSerialNumber;
        WCHAR   szSerialNumber[100];

        swprintf(
            szSerialNumber,
            L"%04X-%04X-%04X-%04X-%04X-%04X",
            (DWORD) pwSerialNumber[1],
            (DWORD) pwSerialNumber[0],
            (DWORD) pwSerialNumber[3],
            (DWORD) pwSerialNumber[2],
            (DWORD) pwSerialNumber[5],
            (DWORD) pwSerialNumber[4]);

        pInstance->SetCharSplat(L"UniqueId", szSerialNumber);
    }


    // Set to unknown in case we don't have SMBIOS or there's not type 4 structure.
    pInstance->SetDWORD(L"CpuStatus", 0);

    if (info.dwProcessorSpeed > dwMaxSpeed)
	{
        dwMaxSpeed = info.dwProcessorSpeed;
	}

	pInstance->SetDWORD(L"MaxClockSpeed", dwMaxSpeed);

	// SMBIOS qualified properties for Win32_Processor class
    CSMBios smbios;

    if (smbios.Init())
    {
        PPROCESSORINFO	ppi = (PPROCESSORINFO) smbios.GetNthStruct(4, dwProcessorIndex);
		WCHAR           tempstr[MIF_STRING_LENGTH+1];

		// Some bad SMP BIOSes only have a struct for the 1st processor.  In
        // this case reuse the first one for all the others.
        if (!ppi && dwProcessorIndex != 0)
            ppi = (PPROCESSORINFO) smbios.GetNthStruct(4, 0);

        if (ppi)
		{
		    pInstance->SetDWORD(L"CpuStatus", ppi->Status & 0x07);

            // Leave it as NULL if we get back a 0 (means unknown).
            if (ppi->External_Clock)
                pInstance->SetDWORD(L"ExtClock", (long) ppi->External_Clock);

            // Some BIOSes mess this up and report a max speed lower than the
            // current speed.  So, use the current speed in this case.
			if (info.dwProcessorSpeed == 0)
			{
				info.dwProcessorSpeed = ppi->Current_Speed;
				pInstance->SetDWORD(IDS_CurrentClockSpeed, info.dwProcessorSpeed);
			}

			if (dwMaxSpeed == 0)
			{
				if (info.dwProcessorSpeed > ppi->Max_Speed)
				{
					ppi->Max_Speed = info.dwProcessorSpeed;
				}

				pInstance->SetDWORD(L"MaxClockSpeed", ppi->Max_Speed);
			}

            USHORT rgTmp[4];
            memcpy(&rgTmp[0], &ppi->Processor_ID[6], sizeof(USHORT));
            memcpy(&rgTmp[1], &ppi->Processor_ID[4], sizeof(USHORT));
            memcpy(&rgTmp[2], &ppi->Processor_ID[2], sizeof(USHORT));
            memcpy(&rgTmp[3], &ppi->Processor_ID[0], sizeof(USHORT));
			swprintf(
                tempstr,
                L"%04X%04X%04X%04X",
				rgTmp[0],		// byte array
				rgTmp[1],		// byte array
				rgTmp[2],		// byte array
				rgTmp[3]		// byte array
				);
		    pInstance->SetCHString(L"ProcessorId", tempstr);
		    pInstance->SetDWORD(L"ProcessorType", ppi->Processor_Type);

			if ( ppi->Voltage & 0x80 )
			{
			    pInstance->SetDWORD(L"CurrentVoltage", ppi->Voltage & 0x7f);
			}
			else
			{
				switch(ppi->Voltage)
                {
                    case 1:
        			    pInstance->SetDWORD( L"CurrentVoltage", 50);
                        break;
                    case 2:
        			    pInstance->SetDWORD( L"CurrentVoltage", 33);
                        break;
                    case 4:
        			    pInstance->SetDWORD( L"CurrentVoltage", 29);
                        break;
                }

                // this is a bitmap of possible voltages.
			    pInstance->SetDWORD(L"VoltageCaps", ppi->Voltage & 0x07);
			}

            smbios.GetStringAtOffset((PSHF) ppi, tempstr, ppi->Socket_Designation);
	    	pInstance->SetCHString(L"SocketDesignation", tempstr);
		}
	}

	return TRUE;
}

int CWin32Processor::GetProcessorCount()
{
    SYSTEM_INFO info;

    GetSystemInfo(&info);

    return info.dwNumberOfProcessors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\protocol.cpp ===
//=================================================================

//

// Protocol.CPP -- Network Protocol property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//				 1/20/98	 jennymc	Added socket 2.2 support
//
//=================================================================

#include "precomp.h"

#include <iostream.h>

#define INCL_WINSOCK_API_TYPEDEFS	1
#include <winsock2.h>

#include <cregcls.h>
#include "Ws2_32Api.h"
#include "Wsock32Api.h"
#include <nspapi.h>
#include "Protocol.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "cfgmgrdevice.h"
#include <typeinfo.h>
#include <ntddndis.h>
#include <traffic.h>
#include <dllutils.h>
#include <..\..\framework\provexpt\include\provexpt.h>


// Property set declaration
//=========================

CWin32Protocol MyProtocolSet(PROPSET_NAME_PROTOCOL, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Protocol::CWin32Protocol
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Protocol::CWin32Protocol( LPCWSTR a_name, LPCWSTR a_pszNamespace )
:Provider( a_name, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Protocol::~CWin32Protocol
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Protocol::~CWin32Protocol()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Protocol::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32Protocol::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT			t_hResult = WBEM_E_NOT_FOUND;
	CProtocolEnum	t_Protocol ;
	CHString		t_sName ;

    //===========================================
	//  Get the correct version of sockets
    //===========================================
	if( !t_Protocol.InitializeSockets() )
	{
		return WBEM_E_FAILED ;
	}

    //===========================================
	//  Go thru the list of protocols
    //===========================================
	a_pInst->GetCHString( IDS_Name, t_sName ) ;

	if( t_Protocol.GetProtocol( a_pInst, t_sName ) )
	{
		// we found it
		t_hResult = WBEM_S_NO_ERROR ;
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Protocol::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Protocol::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	HRESULT			t_hResult = WBEM_S_NO_ERROR ;
	CProtocolEnum	t_Protocol;
	CHString		t_chsTmp;
					t_chsTmp.Empty();

    // smart ptr
	CInstancePtr	t_pInst ;

	//===========================================
	//  Get the correct version of sockets
    //===========================================
	if( !t_Protocol.InitializeSockets() )
	{
		return WBEM_E_FAILED ;
	}

    //===========================================
	//  Get the list of protocols
    //===========================================

	while( SUCCEEDED( t_hResult ) )
	{
		t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

		if( t_Protocol.GetProtocol( t_pInst, t_chsTmp ) )
		{
			t_hResult = t_pInst->Commit();
		}
        else
        {
            break;
        }
	}

	return t_hResult ;
}
////////////////////////////////////////////////////////////////////////
//=====================================================================
//  Try to do it using winsock 2.2 for more information, otherwise
//  do it the old way
//=====================================================================
CProtocolEnum::CProtocolEnum()
{
	m_pProtocol = NULL ;
}

//
CProtocolEnum::~CProtocolEnum()
{
	if( m_pProtocol )
	{
        delete m_pProtocol ;
        m_pProtocol = NULL ;
	}
}

//=====================================================================
BOOL CProtocolEnum::InitializeSockets()
{
	BOOL		t_fRc = FALSE ;

	m_pProtocol = new CSockets22();

	if( !m_pProtocol )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	if( m_pProtocol->BeginEnumeration() )
	{
		t_fRc = TRUE ;
	}
	else
	{
		if( m_pProtocol )
		{
			delete m_pProtocol ;
			m_pProtocol = NULL;
		}
		m_pProtocol = new CSockets11();

		if( !m_pProtocol )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		if( m_pProtocol->BeginEnumeration() )
		{
			t_fRc = TRUE ;
		}
        else
        {
			delete m_pProtocol ;
            m_pProtocol = NULL;
        }
	}
	return t_fRc ;
}
//=====================================================================
//
//  Yes, I know the proper way is to provide functions to return
//  all of the data values, but I'm lazy....
//
//=====================================================================
BOOL CProtocolEnum::GetProtocol( CInstance *a_pInst,CHString t_chsName )
{
	return( m_pProtocol->GetProtocol( a_pInst, t_chsName ) );
}
//********************************************************************
//  Protocol class
//********************************************************************
CProtocol::CProtocol()
{
	Init();
}

//
void CProtocol::Init()
{
	m_pbBuffer			= NULL ;
	m_nTotalProtocols	= 0 ;
	m_nCurrentProtocol	= 0 ;
}

//
CProtocol::~CProtocol()
{
	if( m_pbBuffer )
	{
		delete [] m_pbBuffer;
		m_pbBuffer = NULL;
	}

	Init();
}

//
BOOL CProtocol::SetDateFromFileName( CHString &a_chsFileName, CInstance *a_pInst )
{
	BOOL		t_fRc = FALSE ;

	_bstr_t		t_bstrFileName ;

	// strip off any trailing switches
	int t_iTokLen = a_chsFileName.Find( L" " ) ;
	if( -1 != t_iTokLen )
	{
		t_bstrFileName = a_chsFileName.Left( t_iTokLen ) ;
	}
	else
	{
		t_bstrFileName = a_chsFileName ;
	}

    WIN32_FILE_ATTRIBUTE_DATA t_FileAttributes;

	if( GetFileAttributesEx(t_bstrFileName, GetFileExInfoStandard, &t_FileAttributes) )
	{

        TCHAR t_Buff[_MAX_PATH];
        CHString t_sDrive = a_chsFileName.Left(3);

        if (!GetVolumeInformation(TOBSTRT(t_sDrive), NULL, 0, NULL, NULL, NULL, t_Buff, _MAX_PATH) ||
            (_tcscmp(t_Buff, _T("NTFS")) != 0) )
        {

            bstr_t t_InstallDate(WBEMTime(t_FileAttributes.ftCreationTime).GetDMTFNonNtfs(), false);

		    a_pInst->SetWCHARSplat( IDS_InstallDate, t_InstallDate) ;
        }
        else
        {
		    a_pInst->SetDateTime( IDS_InstallDate, t_FileAttributes.ftCreationTime) ;
        }

		t_fRc = TRUE ;
	}

	return t_fRc ;
}


//********************************************************************
//    SOCKETS 2.2 implementation
//********************************************************************
CSockets22::CSockets22()
  : m_pws32api( NULL ),
    m_fAlive( FALSE )
{
	m_pws32api = (CWs2_32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWs2_32Api, NULL);

	// Note a NULL pointer indicates the DLL is not present on the system
	if( m_pws32api != NULL )
    {
        WSADATA t_wsaData;

		m_fAlive = ( m_pws32api->WSAStartUp( 0x202, &t_wsaData) == 0 ) ;
	}
}

CSockets22::~CSockets22()
{
	if( m_fAlive && m_pws32api )
	{
        m_pws32api->WSACleanup();
    }

	if( m_pws32api )
    {
		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWs2_32Api, m_pws32api);
        m_pws32api = NULL ;
    }
}

/////////////////////////////////////////////////////////////////////
BOOL CSockets22::BeginEnumeration()
{
	BOOL	t_fRc		= FALSE,
			t_fEnum	= FALSE ;

	if( !m_fAlive )
	{
		return t_fRc ;
	}

	//===========================================================
	//  Now, get a list of protocols
	//===========================================================
	DWORD t_dwSize = 4096 ;

	while( TRUE )
	{
		m_pbBuffer = new byte[ t_dwSize ] ;

		if( !m_pbBuffer )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		m_pInfo = (LPWSAPROTOCOL_INFO) m_pbBuffer ;

		if ( ( m_nTotalProtocols = m_pws32api->WSAEnumProtocols( NULL, m_pInfo, &t_dwSize ) ) == SOCKET_ERROR )
		{
			if( m_pws32api->WSAGetLastError() == WSAENOBUFS )
			{
				// buffer too small
				delete [] m_pbBuffer ;
				m_pbBuffer = NULL;
			}
			else
			{
			   t_fRc = FALSE ;

			   break ;
			}
		}
		else
		{
		   t_fRc = TRUE ;

		   break ;
		}
	}
	return t_fRc ;
}

//=====================================================================
BOOL CSockets22::GetProtocol( CInstance *a_pInst, CHString a_chsName )
{
	BOOL t_fRc = FALSE ;

	if( m_nCurrentProtocol < m_nTotalProtocols )
	{
		//==============================================
		// If chsName is not empty, then we are looking
		// for a specific protocol, otherwise, we are
		// enumerating them.
		//==============================================

		while( m_nCurrentProtocol < m_nTotalProtocols )
		{
			if( !a_chsName.IsEmpty() )
			{
				if( _tcsicmp( m_pInfo[ m_nCurrentProtocol ].szProtocol, TOBSTRT( a_chsName ) ) == 0 )
				{
					LoadProtocol( a_pInst ) ;

					t_fRc = TRUE ;
				}
			}
			else
			{
				LoadProtocol( a_pInst ) ;

				t_fRc = TRUE ;
			}

			m_nCurrentProtocol++ ;

			if( t_fRc )
			{
				break ;
			}
		}
	}
	return t_fRc ;
}

//====================================================================
void CSockets22::LoadProtocol( CInstance *a_pInst )
{
    a_pInst->SetCHString(	IDS_Name,				(LPCTSTR)	m_pInfo[ m_nCurrentProtocol ].szProtocol);
    a_pInst->SetCHString(	IDS_Caption,			(LPCTSTR)	m_pInfo[ m_nCurrentProtocol ].szProtocol);
    a_pInst->SetCHString(	IDS_Description,		(LPCTSTR)	m_pInfo[ m_nCurrentProtocol ].szProtocol);
	a_pInst->SetDWORD(		L"MaximumMessageSize",				m_pInfo[ m_nCurrentProtocol ].dwMessageSize );
	a_pInst->SetDWORD(		L"MaximumAddressSize",	(DWORD)		m_pInfo[ m_nCurrentProtocol ].iMaxSockAddr );
	a_pInst->SetDWORD(		L"MinimumAddressSize", (DWORD)		m_pInfo[ m_nCurrentProtocol ].iMinSockAddr );
	a_pInst->Setbool(		L"ConnectionlessService",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_CONNECTIONLESS        ? TRUE : FALSE );
	a_pInst->Setbool(		L"MessageOriented",					m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_MESSAGE_ORIENTED      ? TRUE : FALSE );
	a_pInst->Setbool(		L"PseudoStreamOriented",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_PSEUDO_STREAM         ? TRUE : FALSE );
	a_pInst->Setbool(		L"GuaranteesDelivery",				m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_GUARANTEED_DELIVERY   ? TRUE : FALSE );
	a_pInst->Setbool(		L"GuaranteesSequencing",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_GUARANTEED_ORDER      ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsGracefulClosing",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_GRACEFUL_CLOSE        ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsExpeditedData",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_EXPEDITED_DATA        ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsConnectData",				m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_CONNECT_DATA          ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsDisconnectData",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_DISCONNECT_DATA       ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsBroadcasting",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_SUPPORT_BROADCAST     ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsMulticasting",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_SUPPORT_MULTIPOINT    ? TRUE : FALSE );
	a_pInst->Setbool(		L"SupportsEncryption",				m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_QOS_SUPPORTED         ? TRUE : FALSE );
	a_pInst->Setbool(		IDS_SupportsQualityofService,		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags1 & XP1_QOS_SUPPORTED        ? TRUE : FALSE );


	CHString t_chsStatus ;

	#ifdef WIN9XONLY
    GetSocketInfo( a_pInst, &m_pInfo[ m_nCurrentProtocol ], t_chsStatus );
    #endif

    #ifdef NTONLY
    GetTrafficControlInfo(a_pInst);
    #endif

	// Under 9x status is developed by attempting to open a socket in this family
 	#ifdef WIN9XONLY
		a_pInst->SetCHString( IDS_Status, t_chsStatus ) ;
	#endif

	#ifdef NTONLY
	//===================================================
	//  Now if we can extract the service name, then we
	//  can go out other info out of the registry.  Need
	//  to find a better way to do this.
	//===================================================

	CHString t_chsService;

	_stscanf( m_pInfo[ m_nCurrentProtocol ].szProtocol, _T("%s"), t_chsService.GetBuffer( _MAX_PATH + 2 ) ) ;
	t_chsService.ReleaseBuffer() ;

	// test for RSVP service
	if( t_chsService.CompareNoCase( L"RSVP" ) )
	{
		// else pull out the service name following MSAFD
		t_chsService.Empty() ;

		_stscanf( m_pInfo[ m_nCurrentProtocol ].szProtocol, _T("MSAFD %s"), t_chsService.GetBuffer( _MAX_PATH + 2 ) ) ;
		t_chsService.ReleaseBuffer() ;
	}

	if( !t_chsService.IsEmpty() )
    {
		ExtractNTRegistryInfo( a_pInst, t_chsService.GetBuffer( 0 ) ) ;
	}
	#endif
}

////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
void CSockets22::ExtractNTRegistryInfo(CInstance *a_pInst, LPWSTR a_szService )
{
	CRegistry	t_Reg ;
	CHString	t_chsKey,
				t_chsTmp,
				t_fName ;

	//==========================================================
	//  set the Caption property
	//==========================================================

	a_pInst->SetCHString( IDS_Caption, a_szService ) ;

	t_chsKey = _T("System\\CurrentControlSet\\Services\\") + CHString( a_szService ) ;

	if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
	{
		//======================================================
		//  Set Description and InstallDate properties
		//======================================================
		if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("DisplayName"), t_chsTmp ) )
		{
			a_pInst->SetCHString( IDS_Description, t_chsTmp ) ;
		}

		if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("ImagePath"), t_fName ) )
		{
			// get a filename out of it - might have SystemRoot in it...
			if ( -1 != t_fName.Find( _T("%SystemRoot%\\") ) )
			{
				t_fName = t_fName.Right( t_fName.GetLength() - 13 ) ;
			}
			else if ( -1 != t_fName.Find( _T("\\SystemRoot\\") ) )
			{
				t_fName = t_fName.Right( t_fName.GetLength() - 12 ) ;
			}

			GetWindowsDirectory( t_chsTmp.GetBuffer( MAX_PATH ), MAX_PATH ) ;

			t_chsTmp.ReleaseBuffer() ;

			t_fName = t_chsTmp + _T("\\") + t_fName ;

			SetDateFromFileName( t_fName, a_pInst ) ;
		}

		//=========================================================
		//  Now, go get the status info
		//=========================================================
#ifdef NTONLY
		if( IsWinNT5() )
		{
			CHString t_chsStatus ;

			if( GetServiceStatus( a_szService,  t_chsStatus ) )
			{
				a_pInst->SetCharSplat(IDS_Status, t_chsStatus ) ;
			}
		}
		else
#endif
		{
			t_chsKey = _T("System\\CurrentControlSet\\Services\\") + CHString( a_szService ) + _T("\\Enum") ;

			if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
			{
				if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("0"), t_chsTmp))
				{
					t_chsKey = _T("System\\CurrentControlSet\\Enum\\") + t_chsTmp ;

					if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
					{
						DWORD t_dwTmp ;

						if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("StatusFlags"), t_dwTmp ) )
						{
							TranslateNTStatus( t_dwTmp, t_chsTmp ) ;

							a_pInst->SetCHString( IDS_Status, t_chsTmp ) ;
						}
						else
						{
							a_pInst->SetCHString( IDS_Status, IDS_STATUS_Unknown ) ;
						}
					}
				}
			}
		}
	}
}

#endif
//********************************************************************
//    SOCKETS 1.1 implementation
//********************************************************************
CSockets11::CSockets11() : m_pwsock32api( NULL ) , m_pInfo(NULL), m_fAlive( FALSE )
{
	m_pwsock32api = (CWsock32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWsock32Api, NULL);

	// Note a NULL pointer indicates the DLL is not present on the system
	if( m_pwsock32api != NULL )
    {
        WSADATA t_wsaData;

		m_fAlive = ( m_pwsock32api->WsWSAStartup( 0x0101, &t_wsaData) == 0 ) ;
	}
}

CSockets11::~CSockets11()
{
	if( m_pwsock32api )
    {
		if( m_fAlive )
		{
			m_pwsock32api->WsWSACleanup() ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWsock32Api, m_pwsock32api);
        m_pwsock32api = NULL ;
    }
}

void CSockets11::GetStatus( PROTOCOL_INFO *a_ProtoInfo, CHString &a_chsStatus )
{
	if( !a_ProtoInfo || !m_pwsock32api)
	{
		a_chsStatus = IDS_Error ;
		return;
	}

	// Create a socket for this protocol.
	SOCKET t_s = m_pwsock32api->Wssocket(	a_ProtoInfo->iAddressFamily,
											a_ProtoInfo->iSocketType,
											a_ProtoInfo->iProtocol
											);
	if( INVALID_SOCKET != t_s )
	{
		m_pwsock32api->Wsclosesocket( t_s ) ;

		a_chsStatus = IDS_OK ;
	}
	else
	{
		switch ( m_pwsock32api->WsWSAGetLastError() )
		{
			case WSAENETDOWN:
			case WSAEINPROGRESS:
			case WSAENOBUFS:
			case WSAEMFILE:
			{
				a_chsStatus = IDS_Degraded ;
				break;
			}
			case WSANOTINITIALISED:
			case WSAEAFNOSUPPORT:
			case WSAEPROTONOSUPPORT:
			case WSAEPROTOTYPE:
			case WSAESOCKTNOSUPPORT:
			case WSAEINVAL:
			case WSAEFAULT:
			{
				a_chsStatus = IDS_Error ;
				break;
			}

			default:
			{
				a_chsStatus = IDS_Unknown ;
				break;
			}
		}
	}
}

BOOL CSockets11::BeginEnumeration()
{
	DWORD	t_dwByteCount	= 0 ;
	BOOL	t_fRc			= FALSE ;
	m_pInfo = NULL ;

	if ( m_pwsock32api )
	{
		m_pwsock32api->WsEnumProtocols( NULL, m_pInfo, &t_dwByteCount ) ;

		m_pbBuffer = new byte[ t_dwByteCount ] ;

		if( !m_pbBuffer )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		m_pInfo = (PROTOCOL_INFO *) m_pbBuffer ;

		if( m_pInfo != NULL )
		{
			m_nTotalProtocols = m_pwsock32api->WsEnumProtocols( NULL, m_pInfo, &t_dwByteCount) ;

			if( m_nTotalProtocols != SOCKET_ERROR )
			{
				t_fRc = TRUE ;
			}
		}
	}

	return t_fRc ;
}

//=====================================================================
BOOL CSockets11::GetProtocol( CInstance *a_pInst, CHString a_chsName )
{
	BOOL t_fRc = FALSE ;

	if( m_nCurrentProtocol < m_nTotalProtocols )
	{
		//==============================================
		// If chsName is not empty, then we are looking
		// for a specific protocol, otherwise, we are
		// enumerating them.
		//==============================================
		while( m_nCurrentProtocol < m_nTotalProtocols )
		{
			if( !a_chsName.IsEmpty() )
			{
				if( _tcsicmp( m_pInfo[ m_nCurrentProtocol ].lpProtocol, TOBSTRT( a_chsName ) ) == 0 )
				{
					LoadProtocol( a_pInst ) ;

					t_fRc = TRUE ;
				}
			}
			else
			{
				LoadProtocol( a_pInst ) ;
				t_fRc = TRUE ;
			}
			 m_nCurrentProtocol++ ;

			if( t_fRc )
			{
				break ;
			}
		}
	}
	return t_fRc ;
}

//====================================================================
void CSockets11::LoadProtocol( CInstance *a_pInst )
{
 	a_pInst->SetCHString( IDS_Name,					m_pInfo[ m_nCurrentProtocol ].lpProtocol);
 	a_pInst->SetCHString( IDS_Caption,				m_pInfo[ m_nCurrentProtocol ].lpProtocol);
 	a_pInst->SetCHString( IDS_Description,			m_pInfo[ m_nCurrentProtocol ].lpProtocol);
	a_pInst->SetDWORD( L"MaximumMessageSize",		m_pInfo[ m_nCurrentProtocol ].dwMessageSize );
	a_pInst->SetDWORD( L"MaximumAddressSize", (DWORD) m_pInfo[ m_nCurrentProtocol ].iMaxSockAddr );
	a_pInst->SetDWORD( L"MinimumAddressSize", (DWORD) m_pInfo[ m_nCurrentProtocol ].iMinSockAddr );

	a_pInst->Setbool( L"ConnectionlessService",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_CONNECTIONLESS       ? TRUE : FALSE );
	a_pInst->Setbool( L"MessageOriented",			m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_MESSAGE_ORIENTED     ? TRUE : FALSE );
	a_pInst->Setbool( L"PseudoStreamOriented",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_PSEUDO_STREAM        ? TRUE : FALSE );
	a_pInst->Setbool( L"GuaranteesDelivery",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_GUARANTEED_DELIVERY  ? TRUE : FALSE );
	a_pInst->Setbool( L"GuaranteesSequencing",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_GUARANTEED_ORDER     ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsGuaranteedBandwidth", m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_BANDWIDTH_ALLOCATION ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsGracefulClosing",	m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_GRACEFUL_CLOSE       ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsExpeditedData",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_EXPEDITED_DATA       ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsConnectData",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_CONNECT_DATA         ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsDisconnectData",	m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_DISCONNECT_DATA      ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsBroadcasting",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_SUPPORTS_BROADCAST   ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsMulticasting",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_SUPPORTS_MULTICAST   ? TRUE : FALSE );
	a_pInst->Setbool(  L"SupportsFragmentation",	m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_FRAGMENTATION        ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsEncryption",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_ENCRYPTS             ? TRUE : FALSE );
	a_pInst->Setbool( IDS_SupportsQualityofService, false ) ;

#ifdef WIN9XONLY
		GetWin95RegistryStuff( a_pInst, m_pInfo[ m_nCurrentProtocol ].lpProtocol ) ;
#endif

	// Sockets 1.1 status... open the socket and test
	CHString t_chsStatus ;
	GetStatus( &m_pInfo[ m_nCurrentProtocol ], t_chsStatus ) ;

	a_pInst->SetCHString( IDS_Status, t_chsStatus ) ;
}
void CSockets11::GetWin95RegistryStuff( CInstance *a_pInst, LPTSTR a_szProtocol )
{
	CRegistrySearch		t_Search;
	CHPtrArray			t_chsaList;
	CHString			*t_pPtr,
						t_chsValue,
						t_chsTmp ;
	SYSTEMTIME			t_sysTime;

	try
	{
		a_pInst->SetCHString( IDS_Status, IDS_STATUS_Unknown ) ;

		//====================================================
		//  Go thru, find the network transports, then check
		//  with config manager to see which ones are loaded
		//====================================================
		t_Search.SearchAndBuildList( L"Enum\\Network", t_chsaList, L"NetTrans", L"Class", VALUE_SEARCH ) ;

		for( int t_i = 0; t_i < t_chsaList.GetSize(); t_i++ )
		{
			CRegistry t_Reg ;
			t_pPtr = ( CHString* ) t_chsaList.GetAt( t_i ) ;

			//====================================================
			//  Opened the key, now I need to read the MasterCopy
			//  key and strip out enum\ and see if that is current
			//  in Config Manager
			//====================================================

			if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, *t_pPtr, KEY_READ ) )
			{
				if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( L"DeviceDesc", t_chsValue ) )
				{
					if( _tcsicmp( a_szProtocol, TOBSTRT( t_chsValue ) ) != 0 )
					{
						continue ;
					}
				}
				else
				{
					break ;
				}

				if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( L"MasterCopy", t_chsValue ) )
				{
					CConfigMgrDevice t_Cfg ;

					//=================================================
					//  If we find the status, then we know that this
					//  is the current key, and to read the Driver key
					//  in the registry to tell us where the driver info
					//  is at.
					//=================================================
					if( t_Cfg.GetStatus( t_chsValue ) )
					{
						a_pInst->SetCHString( IDS_Status, t_chsValue ) ;

						if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( L"DeviceDesc", t_chsValue ) )
						{
							a_pInst->SetCHString( IDS_Caption, t_chsValue ) ;
						}

						if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( L"Mfg", t_chsTmp ) )
						{
							a_pInst->SetCHString( IDS_Description, t_chsTmp + CHString( _T("-")) + t_chsValue ) ;
						}

						if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( L"Driver",t_chsTmp ) )
						{
							t_chsTmp = L"System\\CurrentControlSet\\Services\\Class\\" + t_chsTmp ;

							if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsTmp, KEY_READ ) )
							{
								if( t_Reg.GetCurrentKeyValue( L"DriverDate", t_chsTmp ) == ERROR_SUCCESS )
								{
									swscanf( t_chsTmp,L"%d-%d-%d",
												&t_sysTime.wMonth,
												&t_sysTime.wDay,
												&t_sysTime.wYear);

									t_sysTime.wSecond = 0;
									t_sysTime.wMilliseconds = 0;
									a_pInst->SetDateTime( IDS_InstallDate, t_sysTime ) ;
								}
							}
						}

						break ;
					}
				}
			}
		}
	}
	catch( ... )
	{
		t_Search.FreeSearchList( CSTRING_PTR, t_chsaList ) ;

		throw ;
	}

	t_Search.FreeSearchList( CSTRING_PTR, t_chsaList ) ;
}

/*******************************************************************
    NAME:       GetSocketInfo( CInstance * a_pInst, LPWSAPROTOCOL_INFO pInfo, CHString &a_chsStatus )

    SYNOPSIS:   Get protocol status (9x )and checks for Guaranteed Bandwidth support.

				For Guaranteed Bandwidth, Determine if the local traffic control agent
				is installed and operational. If so, the agent can establish a negotiated
				bandwidth with the socket initiator.
				Although mutiple vendors could supply a traffic control agent this
				IODevCtl call is not currently IOC_WS2 abstracted. This is a vendor
				specific call(MS).
				This was discussed with Kam Lee in the NT networking group and suggested
				this IOCTL apply to all vendors (he will submit the request and follow up).

				Test note: this specific WSAIoctl is confirmed to fail with NT5 builds before 1932.

	ENTRY:      CInstance * a_pInst		:
				LPWSAPROTOCOL_INFO pInfo	:

    HISTORY:
                a-peterc  22-Nov-1998     Created
********************************************************************/
void CSockets22::GetSocketInfo( CInstance *a_pInst, LPWSAPROTOCOL_INFO a_pInfo, CHString &a_chsStatus )
{
	bool t_bGuaranteed = false ;

	if( !a_pInfo )
	{
		a_chsStatus = IDS_Error ;
		return;
	}

	// Create a socket for this protocol.
	SOCKET t_s = m_pws32api->WSASocket(	FROM_PROTOCOL_INFO,
										FROM_PROTOCOL_INFO,
										FROM_PROTOCOL_INFO,
										a_pInfo,
										0,
										NULL );
	if( INVALID_SOCKET != t_s )
	{
		try
        {
            if( a_pInfo->dwServiceFlags1 & XP1_QOS_SUPPORTED )
		    {
			    // The socket must be bound for the query
			    SOCKADDR	t_sAddr;

			    memset( &t_sAddr, 0, sizeof( t_sAddr ) ) ;
			    t_sAddr.sa_family = (u_short)a_pInfo->iAddressFamily;

			    if( SOCKET_ERROR != m_pws32api->Bind( t_s, &t_sAddr, sizeof( t_sAddr ) ) )
			    {
				    // query for local traffic control
				    DWORD	t_dwInBuf = 50004 ;	// LOCAL_TRAFFIC_CONTROL ( vendor specific, ms )
				    DWORD	t_dwOutBuf ;
				    DWORD	t_dwReturnedBytes = 0;

				    if( SOCKET_ERROR !=
					    m_pws32api->WSAIoctl( t_s,						// socket
										     _WSAIORW( IOC_VENDOR, 1 ), /* = SIO_CHK_QOS */	// dwIoControlCode
										     &t_dwInBuf,				// lpvInBuffer
										     sizeof( t_dwInBuf ),		// cbInBuffer
										     &t_dwOutBuf,				// lpvOUTBuffer
										     sizeof( t_dwOutBuf ),		// cbOUTBuffer
										     &t_dwReturnedBytes,		// lpcbBytesReturned
										     NULL ,						// lpOverlapped
										     NULL ) )					// lpCompletionROUTINE
				    {
					    if( sizeof( t_dwOutBuf ) == t_dwReturnedBytes )
					    {
						    t_bGuaranteed = t_dwOutBuf ? true : false ;

					    }
				    }
			    }
		    }
		    m_pws32api->CloseSocket( t_s ) ;

		    a_chsStatus = IDS_OK ;
        }
        catch(...)
        {
            m_pws32api->CloseSocket( t_s ) ;
            throw; 
        }
	}
	else
	{
		switch ( m_pws32api->WSAGetLastError() )
		{
			case WSAENETDOWN:
			case WSAEINPROGRESS:
			case WSAENOBUFS:
			case WSAEMFILE:
			{
				a_chsStatus = IDS_Degraded ;
				break;
			}
			case WSANOTINITIALISED:
			case WSAEAFNOSUPPORT:
			case WSAEPROTONOSUPPORT:
			case WSAEPROTOTYPE:
			case WSAESOCKTNOSUPPORT:
			case WSAEINVAL:
			case WSAEFAULT:
			{
				a_chsStatus = IDS_Error ;
				break;
			}

			default:
			{
				a_chsStatus = IDS_Unknown ;
				break;
			}
		}
	}

	a_pInst->Setbool( L"SupportsGuaranteedBandwidth", t_bGuaranteed ) ;
}





//==============================================================================
//
//	Callback function prototypes
//
//		NotifyHandler
//		AddFlowCompleteHandler
//		ModifyFlowCompleteHandler
//		DeleteFlowCompleteHandler
//
//  NOTE: These callback functions are all stub. They don't need to take 
//		  any action acccording to current functionality
//
//==============================================================================


VOID CALLBACK
NotifyHandler(
		HANDLE	ClRegCtx,
		HANDLE	ClIfcCtx,
		ULONG	Event, 
		HANDLE	SubCode,
		ULONG	BufSize,
		PVOID	Buffer)
{
	
	// Perform callback action

}



VOID CALLBACK
AddFlowCompleteHandler(
	HANDLE	ClFlowCtx,
	ULONG	Status)
{

	// Perform callback action

}


VOID CALLBACK
ModifyFlowCompleteHandler(
	HANDLE	ClFlowCtx,
	ULONG	Status)
{

	// Perform callback action

}



VOID CALLBACK 
DeleteFlowCompleteHandler(
	HANDLE	ClFlowCtx,
	ULONG	Status)
{

	// Perform callback action

}



//==============================================================================
//
// Define the list of callback functions that can be activated by 
// Traffic Control Interface.
//
//==============================================================================

TCI_CLIENT_FUNC_LIST	g_tciClientFuncList = 
{	
	NotifyHandler,
	AddFlowCompleteHandler,
	ModifyFlowCompleteHandler,
	DeleteFlowCompleteHandler
};


DWORD CSockets22::GetTrafficControlInfo(CInstance *a_pInst)
{
	DWORD dwRet = NO_ERROR;
	HANDLE	hClient				= INVALID_HANDLE_VALUE;
	HANDLE	hClientContext		= INVALID_HANDLE_VALUE; /* DEFAULT_CLNT_CONT */;
	ULONG	ulEnumBufSize		= 0;
	BYTE	buff[1];			// We only need a dummy buffer
    
    // Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;
    
    try 
    {
        //register the TC Client
	    dwRet = TcRegisterClient(
            CURRENT_TCI_VERSION,
		    hClientContext,
		    &g_tciClientFuncList,
		    &hClient);
	    
        // was the client registration successful?
	    if (dwRet == NO_ERROR)
	    {
		    //enumerate the interfaces available
		    dwRet = TcEnumerateInterfaces(
                hClient,
			    &ulEnumBufSize,
			    (TC_IFC_DESCRIPTOR*) buff);

		    // We expect ERROR_INSUFFICIENT_BUFFER
		    if (dwRet == ERROR_INSUFFICIENT_BUFFER)
            {
			    // Don't bother to enumerate the interfaces - 
                // we now know PSched is installed. 
			    a_pInst->Setbool( L"SupportsGuaranteedBandwidth", TRUE ) ;
                dwRet = ERROR_SUCCESS;
            }
            else
            {
                a_pInst->Setbool( L"SupportsGuaranteedBandwidth", FALSE ) ;
                dwRet = ERROR_SUCCESS;
            }
	    }

	    // De-register the TC client
	    TcDeregisterClient(hClient);
        hClient = INVALID_HANDLE_VALUE;
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        if(hClient != INVALID_HANDLE_VALUE)
        {
            TcDeregisterClient(hClient);
            hClient = INVALID_HANDLE_VALUE;
        }
        dwRet = ERROR_DLL_NOT_FOUND;
    }
    catch(...)
    {
        if(hClient != INVALID_HANDLE_VALUE)
        {
            TcDeregisterClient(hClient);
            hClient = INVALID_HANDLE_VALUE;
        }
        throw;
    }    

	return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\protocolbinding.h ===
//=================================================================

//

// ProtocolBinding.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __ASSOC_PROTOCOLBINDING__
#define __ASSOC_PROTOCOLBINDING__

// Property set identification
//============================

#define	PROPSET_NAME_NETCARDtoPROTOCOL	L"Win32_ProtocolBinding"

class CWin32ProtocolBinding : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32ProtocolBinding( LPCWSTR strName, LPCWSTR pszNamespace = NULL ) ;
       ~CWin32ProtocolBinding() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility
        //========

        // Utility function(s)
        //====================

    private:

        // Utility function(s)
        //====================

		HRESULT EnumProtocolsForAdapter(	CInstance*		pAdapter,
											MethodContext*	pMethodContext,
											TRefPointerCollection<CInstance>&	protocolList );

		bool SetProtocolBinding(	CInstance*	pAdapter,
									CInstance*	pProtocol,
									CInstance*	pProtocolBinding );

        BOOL LinkageExists( LPCTSTR pszServiceName, LPCTSTR pszProtocolName ) ;
        BOOL LinkageExistsNT5(CHString& chstrAdapterDeviceID, CHString& chstrProtocolName);
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\protocolbinding.cpp ===
//=================================================================

//

// ProtocolBinding.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "protocolbinding.h"


// The Map we will use below is an STL Template, so make sure we have the std namespace
// available to us.

using namespace std;

// Property set declaration
//=========================

CWin32ProtocolBinding	win32ProtocolBinding( PROPSET_NAME_NETCARDtoPROTOCOL, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProtocolBinding::CWin32ProtocolBinding
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32ProtocolBinding::CWin32ProtocolBinding(LPCWSTR strName, LPCWSTR pszNamespace /*=NULL*/ )
:	Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProtocolBinding::~CWin32ProtocolBinding
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32ProtocolBinding::~CWin32ProtocolBinding()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32ProtocolBinding::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32ProtocolBinding::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	// Instances to mess around with
	CInstancePtr	pAdapter;
    CInstancePtr	pProtocol;
	CHString		strAdapterPath,
					strProtocolPath,
					strAdapterSystemName,
					strProtocolName;
	HRESULT		hr;

	//
	pInstance->GetCHString( IDS_Device, strAdapterPath );
	pInstance->GetCHString( IDS_Antecedent, strProtocolPath );

    // Perform queries
    //================

	if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(strAdapterPath,
		&pAdapter, pInstance->GetMethodContext())) &&
		SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strProtocolPath,
		&pProtocol, pInstance->GetMethodContext())))
	{

		// Get values necessary to determine association

		if (	pAdapter->GetCHString( IDS_ProductName, strAdapterSystemName )
			&&	pProtocol->GetCHString( IDS_Caption, strProtocolName ) )
		{
			BOOL fReturn = FALSE;

			// If the protocol and adapter are associated, we need to create
			// a new instance, fill it up with binding information and commit.
#ifdef WIN9XONLY
			{
				fReturn = SetProtocolBinding( pAdapter, pProtocol, pInstance );
			}
#endif
#ifdef NTONLY
			if(IsWinNT5())
            {
                CHString chstrAdapterDeviceID;
                if(pAdapter->GetCHString(IDS_DeviceID, chstrAdapterDeviceID))
                {
                    if(LinkageExistsNT5(chstrAdapterDeviceID, strProtocolName))
                    {
                        fReturn = SetProtocolBinding(pAdapter, pProtocol, pInstance);
                    }
                }
            }
            else if ( LinkageExists( strAdapterSystemName, strProtocolName ) )
			{

				// Try to finalize object values now.

				fReturn = SetProtocolBinding( pAdapter, pProtocol, pInstance );

			}	// IF Linkage Exists
#endif

			hr = fReturn ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;

		}	// IF Got strings

	}	// IF Got Instances

	return hr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32ProtocolBinding::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32ProtocolBinding::EnumerateInstances( MethodContext* pMethodContext, long lFlags /*= 0L*/ )
{
	BOOL		fReturn		=	FALSE;
	HRESULT		hr			=	WBEM_S_NO_ERROR;

	// Our instance lists.
	TRefPointerCollection<CInstance>	adapterList;
	TRefPointerCollection<CInstance>	protocolList;

	// Instances to mess around with
	CInstancePtr		pAdapter ;

    // Perform queries
    //================

//	if (SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(_T("Win32_NetworkAdapter"),
//		&adapterList, NULL, pMethodContext)) &&
//		SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(_T("Win32_NetworkProtocol"),
//		&protocolList, NULL, pMethodContext)))

	if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"select DeviceID, ProductName, ServiceName from Win32_NetworkAdapter",
		&adapterList, pMethodContext, GetNamespace())) &&
		SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"select Name, Caption from Win32_NetworkProtocol",
		&protocolList, pMethodContext, GetNamespace())))
	{
		REFPTRCOLLECTION_POSITION	posAdapter;

		if ( adapterList.BeginEnum( posAdapter ) )
		{
			// Order is important.  Check hr first so we don't get another adapter, and
			// orphan it by not releasing it.

			for (pAdapter.Attach(adapterList.GetNext( posAdapter ));
                 (WBEM_S_NO_ERROR == hr) &&	(pAdapter != NULL );
                  pAdapter.Attach(adapterList.GetNext( posAdapter )))
			{

				hr = EnumProtocolsForAdapter( pAdapter, pMethodContext, protocolList );

			}	// for GetNext Adapter

			adapterList.EndEnum();

		}	// If BeginEnum

	}	// If GetAllInstances

	return hr;

}

HRESULT CWin32ProtocolBinding::EnumProtocolsForAdapter(
CInstance*							pAdapter,
MethodContext*						pMethodContext,
TRefPointerCollection<CInstance>&	protocolList
)
{
	HRESULT		hr	= WBEM_S_NO_ERROR;

	// Instances to mess around with
	CInstancePtr		pProtocol;
	CInstancePtr		pInstance;
	CHString		strAdapterSystemName,
					strProtocolName;

	REFPTRCOLLECTION_POSITION	posProtocol;

	if ( protocolList.BeginEnum( posProtocol ) )
	{
		// Order is important.  Check hr first so we don't get another protocol, and
		// orphan it by not releasing it.

		for (pProtocol.Attach(protocolList.GetNext( posProtocol )) ;
            WBEM_S_NO_ERROR == hr && ( pProtocol != NULL );
            pProtocol.Attach(protocolList.GetNext( posProtocol )) )
		{

			// We need the adapter's service name and the protocol's name

			if (	!pAdapter->IsNull( IDS_ServiceName )
				&&	pAdapter->GetCHString( IDS_ServiceName, strAdapterSystemName )
				&&	pProtocol->GetCHString( IDS_Caption, strProtocolName ) )
			{

				// If the protocol and adapter are associated, we need to create
				// a new instance, fill it up with binding information and commit.

				// unless we are in Win 95 or '98.  Then there is no linkage. It just works.
#ifdef WIN9XONLY
				{
					pInstance.Attach(CreateNewInstance( pMethodContext ));

					if ( NULL != pInstance )
					{

						// Commit the instance
						if ( SetProtocolBinding( pAdapter, pProtocol, pInstance ) )
						{
							hr = pInstance->Commit(  );
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
#endif
#ifdef NTONLY
                if(IsWinNT5())
                {
                    CHString chstrAdapterDeviceID;
                    if(pAdapter->GetCHString(IDS_DeviceID, chstrAdapterDeviceID))
                    {
                        if(LinkageExistsNT5(chstrAdapterDeviceID, strProtocolName))
                        {
                            pInstance.Attach(CreateNewInstance( pMethodContext ));
					        if ( NULL != pInstance )
					        {
						        // Commit the instance
						        if ( SetProtocolBinding( pAdapter, pProtocol, pInstance ) )
						        {
							        hr = pInstance->Commit(  );
						        }
					        }
					        else
					        {
						        hr = WBEM_E_OUT_OF_MEMORY;
					        }
                        }
                    }
                }
				else
                {
                    // The actual service name is stored in Win32_NetworkAdapter.ServiceName.  However,
                    // for NT4, we need the 'instance' name, which is stored in ProductName (don't ask
                    // me why).
                    pAdapter->GetCHString( IDS_ProductName, strAdapterSystemName);
                    if ( LinkageExists( strAdapterSystemName, strProtocolName ) )  // i.e., neither NT5 nor Win9x
				    {

					    pInstance.Attach(CreateNewInstance( pMethodContext ));

					    if ( NULL != pInstance )
					    {

						    // Commit the instance
						    if ( SetProtocolBinding( pAdapter, pProtocol, pInstance ) )
						    {
							    hr = pInstance->Commit(  );
						    }
					    }
					    else
					    {
						    hr = WBEM_E_OUT_OF_MEMORY;
					    }

				    }	// IF Linkage Exists
                }
#endif

			}	// IF Got required values

		}	// WHILE GetNext Protocol

		protocolList.EndEnum();

	}	// IF BeginEnum

	return hr;

}

bool CWin32ProtocolBinding::SetProtocolBinding(
CInstance*	pAdapter,
CInstance*	pProtocol,
CInstance*	pProtocolBinding
)
{
	bool		fReturn = FALSE;

	// Instances to mess around with
	CInstancePtr	pService;

	CHString		strAdapterServiceName,
					strServicePath,
					strProtocolPath,
					strAdapterPath;

#ifdef NTONLY
   {
	   // Use the product name from the Adapter Instance to get a Win32 Service, and
	   // then set our paths in the protocol binding instance

	   pAdapter->GetCHString( IDS_ServiceName, strAdapterServiceName );

	   // We must release this instance when we are through with it.
	   CHString strPath;
	   strPath.Format(	_T("\\\\%s\\%s:Win32_SystemDriver.Name=\"%s\""),
						(LPCTSTR) GetLocalComputerName(),
						IDS_CimWin32Namespace,
						(LPCTSTR) strAdapterServiceName );


	   if (SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(strPath, &pService, pAdapter->GetMethodContext())))
	   {
		   // Load all three paths, and if that succeeds, we can create
		   // a new instance

		   if (	GetLocalInstancePath( pAdapter, strAdapterPath )
			   &&	GetLocalInstancePath( pProtocol, strProtocolPath )
			   &&	GetLocalInstancePath( pService, strServicePath ) )
		   {

			   pProtocolBinding->SetCHString( IDS_Device, strAdapterPath );
			   pProtocolBinding->SetCHString( IDS_Antecedent, strProtocolPath );
			   pProtocolBinding->SetCHString( IDS_Dependent, strServicePath );

			   fReturn = TRUE;

		   }	// IF Get Paths

	   }	// IF GetEmptyInstance
   }
#endif
#ifdef WIN9XONLY
   {
	   if (	GetLocalInstancePath( pAdapter, strAdapterPath )
		   &&	GetLocalInstancePath( pProtocol, strProtocolPath ))
	   {

		   pProtocolBinding->SetCHString( IDS_Device, strAdapterPath );
		   pProtocolBinding->SetCHString( IDS_Antecedent, strProtocolPath );

		   fReturn = TRUE;

	   }	// IF Get Paths
   }
#endif


	return fReturn;

}

BOOL CWin32ProtocolBinding::LinkageExistsNT5(CHString& chstrAdapterDeviceID, CHString& chstrProtocolName)
{
    bool fRetCode = false ;
    CRegistry RegInfo;
    CRegistry RegAdapter;
	CHString strTemp;
    CHString strDevice;
    DWORD x;
    DWORD y;
    DWORD dwSize;
    CHStringArray asBindings;

    // This is where the bindings for this PROTOCOL are stored
	strTemp.Format( L"System\\CurrentControlSet\\Services\\%s\\Linkage",
        (LPCWSTR) chstrProtocolName);
    // Open it
    if( RegInfo.Open( HKEY_LOCAL_MACHINE, strTemp, KEY_READ ) == ERROR_SUCCESS )
	{
        // Read all the bindings (drivers supporting this protocol) into a chstringarray
        if (RegInfo.GetCurrentKeyValue(L"Bind", asBindings) == ERROR_SUCCESS)
		{
            // Walk the list looking for a 'match'
            dwSize = asBindings.GetSize();
            // Here is where we differ from the standard LinkageExists routine.  For NT5,
            // we need to look at the registry entry for this device.  Under the class for
            // network adapters (which is
            // HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318} )
            // are numeric entries, which (by our design) correspond to the DeviceIDs of
            // the network adapters.  Under each numeric subkey is a subkey "Linkage".
            // "Linkage" has a REG_MULTI_SZ value "Bind" that lists all the protocols bound
            // by this adapter.  For each of these strings in the multi-sz array, need to look
            // at each string in the multi-sz array opened up above (the Linkage subkey under
            // Services).  If and when we find a match, we are done.

            CHStringArray asAdapterBindings;
            WCHAR* tcEnd = NULL;
            LONG lNum = wcstol(chstrAdapterDeviceID,&tcEnd,10);
            strTemp.Format(L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\%04d\\Linkage",
                           lNum);
            if(RegAdapter.Open(HKEY_LOCAL_MACHINE, strTemp, KEY_READ ) == ERROR_SUCCESS)
            {
                // Read all the protocols supported by the adapter driver (usually only one):
                if(RegAdapter.GetCurrentKeyValue(L"Export", asAdapterBindings) == ERROR_SUCCESS)
                {
                    DWORD dwAdapterSize = asAdapterBindings.GetSize();
                    for(y=0L; y < dwAdapterSize && (!fRetCode); y++)
                    {
                        for (x=0L; (x < dwSize) && (!fRetCode); x++)
			            {
                            if(asBindings[x].CompareNoCase(asAdapterBindings[y]) == 0)
				            {
                                fRetCode = true ;
                            }
                        }
                    }
                }
            }
        }
    }
    return fRetCode;
}

BOOL CWin32ProtocolBinding::LinkageExists( LPCTSTR pszSystemName, LPCTSTR pszProtocolName)
{
    bool bRetCode = false ;
    CRegistry RegInfo, RegProt ;

    CHString	strTemp, strDevice;

    DWORD x, dwSize;

#ifdef NTONLY
    {
        CHStringArray asBindings;

        // This is where the bindings for this card are stored
        strTemp.Format( _T("System\\CurrentControlSet\\Services\\%s\\Linkage"), pszProtocolName );

        // Open it
        if( RegInfo.Open( HKEY_LOCAL_MACHINE, strTemp, KEY_READ ) == ERROR_SUCCESS )
        {
            // Read all the bindings into a chstringarray
            if (RegInfo.GetCurrentKeyValue(_T("Bind"), asBindings) == ERROR_SUCCESS)
            {
                // Walk the list looking for a 'match'
                dwSize = asBindings.GetSize();
                strDevice = _T("\\Device\\");
                strDevice += pszSystemName;

                for (x=0; (x < dwSize) && (!bRetCode); x++)
                {
                    if (asBindings[x].CompareNoCase(strDevice) == 0)
                    {

                        bRetCode = true ;
                    }
                }
            }
        }
    }
#endif
#ifdef WIN9XONLY
    {

        // 95, of course, does things differently.  In this case, 95 is probably a bit
        // easier to follow
        WCHAR *pValueName;
        BYTE *pValueData ;

        // This is where the bindings for this netcard are stored.  
        strTemp.Format(L"Enum\\Root\\%s\\0000\\Bindings", pszSystemName);

        if (RegInfo.Open(HKEY_LOCAL_MACHINE, strTemp, KEY_READ) == ERROR_SUCCESS) {

            // Now we walk the keys.  Note that the interesting part is the key name, not the
            // value it contains.
            dwSize = RegInfo.GetValueCount();

            for (x=0; (x < dwSize) && (!bRetCode) ; x++) {

                // Here is a pointer to a protocol that this card supports.
                if (RegInfo.EnumerateAndGetValues(x, pValueName, pValueData) == ERROR_SUCCESS)
                {
                    try
                    {
                        strTemp.Format(L"Enum\\Network\\%s", pValueName);
                    }
                    catch ( ... )
                    {
                        delete [] pValueName ;
                        delete [] pValueData ;
                        throw ;
                    }

                    delete [] pValueName ;
                    delete [] pValueData ;

                    // Let's get its name.  First open the key
                    if (RegProt.Open(HKEY_LOCAL_MACHINE, strTemp, KEY_READ) == ERROR_SUCCESS) {

                        // Now get the value
                        if (RegProt.GetCurrentKeyValue(L"DeviceDesc", strDevice) == ERROR_SUCCESS) {

                            // Is this the one?
                            if (strDevice.CompareNoCase(TOBSTRT(pszProtocolName)) == 0) {
                                bRetCode = true;
                            }
                        }
                    }
                }
            }
        }
    }
#endif

    return bRetCode ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\processor.h ===
//=================================================================

//

// Processor.h -- Processor property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               07/09/98    sotteson       Overhauled to work with
//                                          AMD/Cyrix/etc.															
//
//=================================================================

// Property set identification
//============================

// Property set identification
//============================

#define	PROPSET_NAME_PROCESSOR	L"Win32_Processor"

class CWin32Processor : public Provider
{
public:

	// Constructor/destructor
	//=======================
	CWin32Processor(LPCWSTR strName, LPCWSTR pszNamespace);
	~CWin32Processor();

	// Functions provide properties with current values
	//=================================================
	virtual HRESULT GetObject(CInstance *pInstance, long lFlags, 
        CFrameworkQuery &query);
	virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, 
        long lFlags = 0L);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
        CFrameworkQuery &query, long lFags);

protected:

	// Utility function(s)
	//====================
    BOOL LoadProcessorValues(DWORD dwProcessorIndex,
							CInstance *pInstance,
							CFrameworkQuery &query,
							DWORD dwMaxSpeed,
							DWORD dwCurrentSpeed);
    int GetProcessorCount();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\protocol.h ===
//=================================================================

//

// Protocol.h -- Network Protocol property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//				 1/21/98	jennymc   Added protocol classes to deal
//									  with different socket versions
//=================================================================
#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_


// Property set identification
//============================

#define PROPSET_NAME_PROTOCOL L"Win32_NetworkProtocol"

class CProtocol
{
	public:
		CProtocol();
		virtual ~CProtocol();
		virtual BOOL BeginEnumeration()=0;
		virtual BOOL GetProtocol(CInstance *pInstance,CHString chsName)=0;

	protected:		
		void Init();
		BOOL SetDateFromFileName( CHString &a_chsFileName, CInstance *a_pInstance ) ;

		BYTE * m_pbBuffer;
		int    m_nTotalProtocols;
		int    m_nCurrentProtocol;
};

class CSockets22 : public CProtocol
{
	public:	
		BOOL BeginEnumeration();
		BOOL GetProtocol(CInstance *pInstance,CHString chsName);
		CSockets22();
		~CSockets22();
	private:

		BOOL					m_fAlive;
		CWs2_32Api             *m_pws32api;
		LPWSAPROTOCOL_INFO		m_pInfo;

		void LoadProtocol(CInstance *pInstance);
		void GetSocketInfo( CInstance *a_pInst, LPWSAPROTOCOL_INFO a_pInfo, CHString &a_chsStatus ) ;
		void ExtractNTRegistryInfo(CInstance *pInstance, LPWSTR szService);
        DWORD GetTrafficControlInfo(CInstance *a_pInst);
};		

class CSockets11 : public CProtocol
{
	public:	
		BOOL BeginEnumeration();
		BOOL GetProtocol(CInstance *pInstance,CHString chsName);
		CSockets11();
		~CSockets11();
	private:
		BOOL			m_fAlive;
		CWsock32Api		*m_pwsock32api;
		PROTOCOL_INFO	*m_pInfo;

		void GetStatus( PROTOCOL_INFO *a_ProtoInfo, CHString &a_chsStatus ) ;
		void LoadProtocol(CInstance *pInstance);
		void GetWin95RegistryStuff(CInstance *pInstance, LPTSTR szProtocol);

};

class CProtocolEnum
{
	public:
		CProtocolEnum();
		~CProtocolEnum();
		BOOL InitializeSockets();
		BOOL GetProtocol(CInstance *pInstance,CHString chsName);

	private:
		CProtocol * m_pProtocol;
};
//=====================================================================

class CWin32Protocol:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32Protocol(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32Protocol() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    private:
		BOOL EnumProtocolsTheOldWay(CInstance *pInstance,MethodContext * pMethod);
		BOOL EnumerateProtocols(CInstance *pInstance,MethodContext * pMethod);
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\programgroup.cpp ===
//=================================================================

//

// ProgramGroup.CPP -- Program group property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//       10/24/97    jennymc     Moved to new framework
//
//=================================================================


//*****************************************************************
//*****************************************************************
//
//             W   A   R   N   I   N   G  !!!!!!!!!!
//             W   A   R   N   I   N   G  !!!!!!!!!!
//
//
//  This class has been deprecated for Nova M2 and later builds of
//  WBEM.  Do not make alterations to this class.  Make changes to
//  the new class Win32_LogicalProgramFile (LogicalProgramFile.cpp)
//  instead.  The new class (correctly) is derived in CIMOM from
//  LogicalElement, not LogicalSetting.
//
//*****************************************************************
//*****************************************************************



#include "precomp.h"
#include <cregcls.h>

#include "UserHive.h"
#include <io.h>

#include "ProgramGroup.h"
#include "wbemnetapi32.h"
#include "user.h"
// Property set declaration
//=========================
CWin32ProgramGroup MyCWin32ProgramGroupSet(PROPSET_NAME_PRGGROUP, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProgramGroup::CWin32ProgramGroup
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32ProgramGroup::CWin32ProgramGroup(LPCWSTR name, LPCWSTR pszNameSpace)
: Provider(name, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProgramGroup::~CWin32ProgramGroup
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32ProgramGroup::~CWin32ProgramGroup()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32ProgramGroup::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
//    HRESULT hr = WBEM_E_FAILED;
//  int iIndex ;
    CHString Name;
	HRESULT		hr;
	pInstance->GetCHString(IDS_Name, Name);
   CHString chsUserName, chsGroupName;
   TRefPointerCollection<CInstance> Groups;

   if SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(L"Win32_ProgramGroup", &Groups, IDS_CimWin32Namespace, pInstance->GetMethodContext()))
   {
		REFPTRCOLLECTION_POSITION	pos;

		CInstancePtr pProgramGroupInstance;

		if ( Groups.BeginEnum( pos ) )
		{
            hr = WBEM_E_NOT_FOUND;
			for (	pProgramGroupInstance.Attach ( Groups.GetNext( pos ) );
					pProgramGroupInstance != NULL ;
					pProgramGroupInstance.Attach ( Groups.GetNext( pos ) )
				)
			{
				CHString chsCompName;
				pProgramGroupInstance->GetCHString(IDS_Name, chsCompName);

				// We're done with the pointer
                pProgramGroupInstance.Release();

				if (chsCompName.CompareNoCase(Name) == 0)
				{
                    // Parse out the user name
					chsUserName = chsCompName.SpanExcluding(L":");
			    	pInstance->SetCHString(IDS_UserName, chsUserName);

                    // Parse out the group
					int nUserLength = (chsUserName.GetLength() + 1);
					int nGroupLength = chsCompName.GetLength() - nUserLength;
					chsGroupName = chsCompName.Right(nGroupLength);
					pInstance->SetCHString(IDS_GroupName, chsGroupName);

                    CHString chstrTmp2;
                    chstrTmp2.Format(L"Program group \"%s\"", (LPCWSTR) Name);
                    pInstance->SetCHString(L"Description" , chstrTmp2) ;
                    pInstance->SetCHString(L"Caption" , chstrTmp2) ;

                    hr = WBEM_S_NO_ERROR;
                    break;
				}

			}	// WHILE GetNext

			Groups.EndEnum();

		}	// IF BeginEnum

	}
	return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32ProgramGroup::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_E_FAILED;
    TCHAR szWindowsDir[_MAX_PATH];
    CRegistry RegInfo ;
    CHString sTemp;

    if(GetWindowsDirectory(szWindowsDir, sizeof(szWindowsDir) / sizeof(TCHAR) ))
    {

#ifdef WIN9XONLY
            if(RegInfo.OpenCurrentUser(
                            L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                            KEY_READ) == ERROR_SUCCESS)
            {

                if(RegInfo.GetCurrentKeyValue(L"Programs", sTemp) == ERROR_SUCCESS)
                {
                    hr=CreateSubDirInstances(_T("All Users"), TOBSTRT(sTemp), _T("."), pMethodContext) ;
                }

                RegInfo.Close() ;
            }
#endif
#ifdef NTONLY
			LONG lRet;
            if(GetPlatformMajorVersion() < 4)
            {
                hr=EnumerateGroupsTheHardWay(pMethodContext) ;
            }
            else
            {
                // Default user doesn't show up under profiles
                if((lRet = RegInfo.Open(HKEY_USERS, _T(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"), KEY_READ)) == ERROR_SUCCESS)
                {
                    if(RegInfo.GetCurrentKeyValue(_T("Programs"), sTemp) == ERROR_SUCCESS)
                    {
                        hr=CreateSubDirInstances(_T("Default User"), sTemp, _T("."), pMethodContext);
                    }
                }
				else
				{
					if (lRet == ERROR_ACCESS_DENIED)
						hr = WBEM_E_ACCESS_DENIED;
				}

                // Neither does All Users
                if((lRet = RegInfo.Open(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"), KEY_READ)) == ERROR_SUCCESS)
                {
                    if(RegInfo.GetCurrentKeyValue(_T("Common Programs"), sTemp) == ERROR_SUCCESS)
                    {
                        hr=CreateSubDirInstances(_T("All Users"), sTemp, _T("."), pMethodContext);
                    }
                }
				else
				{
					if (lRet == ERROR_ACCESS_DENIED)
						hr = WBEM_E_ACCESS_DENIED;
				}

                // Now walk the registry looking for the rest
                CRegistry regProfileList;
                if((lRet = regProfileList.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, IDS_RegNTProfileList, KEY_READ )) == ERROR_SUCCESS )
                {
                    CUserHive UserHive ;
                    CHString strProfile, strUserName, sKeyName2;

		            for (int i=0; regProfileList.GetCurrentSubKeyName( strProfile ) == ERROR_SUCCESS ; i++)
		            {
                        // Try to load the hive.  If the user has been deleted, but the directory
                        // is still there, this will return ERROR_NO_SUCH_USER
						bool t_bUserHiveLoaded = false ;
		                if ( UserHive.LoadProfile( strProfile, strUserName ) == ERROR_SUCCESS  && 
                            strUserName.GetLength() > 0 )
		                {
                            t_bUserHiveLoaded = true ;
							try
							{
								sKeyName2 = strProfile + _T("\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");

								if(RegInfo.Open(HKEY_USERS, sKeyName2, KEY_READ) == ERROR_SUCCESS) {
									if(RegInfo.GetCurrentKeyValue(_T("Programs"), sTemp) == ERROR_SUCCESS) {
										hr=CreateSubDirInstances(strUserName, sTemp, _T("."), pMethodContext) ;
									}
									RegInfo.Close();
								}
							}
							catch ( ... )
							{
								if ( t_bUserHiveLoaded )
								{
									UserHive.Unload( strProfile ) ;
								}
								throw ;
							}
							t_bUserHiveLoaded = false ;
							UserHive.Unload( strProfile ) ;
                        }
			            regProfileList.NextSubKey();
		            }

		            regProfileList.Close();
                }
				else
				{
					if (lRet == ERROR_ACCESS_DENIED)
						hr = WBEM_E_ACCESS_DENIED;
				}
            }
#endif
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProgramGroup::CreateSubDirInstances
 *
 *  DESCRIPTION : Creates instance of property set for each directory
 *                beneath the one passed in
 *
 *  INPUTS      : pszBaseDirectory    : Windows directory + "Profiles\<user>\Start Menu\Programs"
 *                pszParentDirectory  : Parent directory to enumerate
 *
 *  OUTPUTS     : pdwInstanceCount : incremented for each instance created
 *
 *  RETURNS     : Zip
 *
 *  COMMENTS    : Recursive descent thru profile directories
 *
 *****************************************************************************/

HRESULT CWin32ProgramGroup::CreateSubDirInstances(LPCTSTR pszUserName,
                               LPCTSTR pszBaseDirectory,
                               LPCTSTR pszParentDirectory,
                               MethodContext * pMethodContext )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TCHAR szDirSpec[_MAX_PATH], szTemp[_MAX_PATH], *pszGroupName ;
    Smart_findclose lFindHandle ;
    intptr_t iptrRetCode = -1L;

#if (defined(UNICODE) || defined (_UNICODE))
#if defined(_X86_)
    _wfinddata_t FindData ;
#else
    _wfinddatai64_t FindData ;
#endif
#else
    _finddata_t FindData ;
#endif

    // Put together search spec for this level
    //========================================

    _stprintf(szDirSpec, _T("%s\\%s\\*.*"), pszBaseDirectory, pszParentDirectory) ;

	// Enumerate subdirectories ( == program groups)
	//==============================================
#if defined(_X86_)
	lFindHandle = _tfindfirst(szDirSpec, &FindData) ;
#else
    lFindHandle = _tfindfirsti64(szDirSpec, &FindData) ;
#endif
    
    iptrRetCode = lFindHandle;

	while(iptrRetCode != -1 && SUCCEEDED(hr)) {

		if(FindData.attrib & _A_SUBDIR && _tcscmp(FindData.name, _T(".")) && _tcscmp(FindData.name, _T(".."))) {

			CInstancePtr pInstance ;
			pInstance.Attach ( CreateNewInstance ( pMethodContext ) ) ;
			if ( pInstance != NULL )
			{
				_stprintf(szTemp, _T("%s\\%s"), pszParentDirectory, FindData.name) ;
				pszGroupName = _tcschr(szTemp, '\\') + 1 ;

				pInstance->SetCHString(L"UserName", pszUserName );
				pInstance->SetCHString(L"GroupName", pszGroupName );

                CHString chstrTmp;
                chstrTmp.Format(L"%s:%s",(LPCWSTR)TOBSTRT(pszUserName),(LPCWSTR)TOBSTRT(pszGroupName));

				pInstance->SetCHString(L"Name", chstrTmp );

                CHString chstrTmp2;
                chstrTmp2.Format(L"Program group \"%s\"", (LPCWSTR) chstrTmp);
                pInstance->SetCHString(L"Description" , chstrTmp2) ;
                pInstance->SetCHString(L"Caption" , chstrTmp2) ;

				hr = pInstance->Commit () ;
			}
			// Enumerate directories sub to this one
			//======================================
			_stprintf(szDirSpec, _T("%s\\%s"), pszParentDirectory, FindData.name) ;
			CreateSubDirInstances(pszUserName, pszBaseDirectory, szDirSpec, pMethodContext) ;
		}

#if defined(_X86_)
	    iptrRetCode = _tfindnext(lFindHandle, &FindData) ;
#else
        iptrRetCode = _tfindnexti64(lFindHandle, &FindData) ;
#endif

	}

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProgramGroup::EnumerateGroupsTheHardWay
 *
 *  DESCRIPTION : Creates instances for program groups by drilling into
 *                user profiles
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : dwInstanceCount receives the total number of instances created
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32ProgramGroup::EnumerateGroupsTheHardWay(MethodContext * pMethodContext)
{
    HRESULT hr = WBEM_E_FAILED;
    CUserHive UserHive ;
    CRegistry Reg ;
    WCHAR szUserName[_MAX_PATH], szKeyName[_MAX_PATH] ;

    // Get default user first
    //=======================

    InstanceHardWayGroups(L"Default User", L".DEFAULT", pMethodContext) ;

    // Get the users first
    //====================
        // Create instances for each user
    //===============================

	TRefPointerCollection<CInstance> users;

	if (SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(PROPSET_NAME_USER, &users, IDS_CimWin32Namespace, pMethodContext)))
	{
		REFPTRCOLLECTION_POSITION pos;
		CInstancePtr pUser;
        CHString userName;

		if (users.BeginEnum(pos))
		{
            hr = WBEM_S_NO_ERROR;
			// GetNext() will AddRef() the pointer, so make sure we Release()
			// it when we are done with it.
			for (	pUser.Attach ( users.GetNext( pos ) );
					pUser != NULL ;
					pUser.Attach ( users.GetNext( pos ) )
				)
			{
    			// Look up the user's account info
				//================================
				pUser->GetCHString(IDS_Name, userName) ;
				wcscpy(szUserName, userName) ;
				bool t_bUserHiveLoaded = false ;
                if(UserHive.Load(szUserName, szKeyName) == ERROR_SUCCESS)
                {
                    t_bUserHiveLoaded = true ;
					try
					{
						InstanceHardWayGroups(szUserName, szKeyName, pMethodContext) ;
					}
					catch ( ... )
					{
						if ( t_bUserHiveLoaded )
						{
							UserHive.Unload(szKeyName) ;
						}
						throw ;
					}

					t_bUserHiveLoaded = false ;
					UserHive.Unload(szKeyName) ;
                }
			}
			users.EndEnum();
		}
	}
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProgramGroup::InstanceHardWayGroups
 *
 *  DESCRIPTION : Creates instances of program groups for specified user
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : dwInstanceCount receives the total number of instances created
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

WCHAR szBaseRegKey[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager" ;

HRESULT CWin32ProgramGroup::InstanceHardWayGroups(LPCWSTR  pszUserName,
                                   LPCWSTR  pszRegistryKeyName,
                                   MethodContext * pMethodContext)
{
    HRESULT hr= WBEM_S_NO_ERROR;
    CRegistry Reg ;
    WCHAR szTemp[_MAX_PATH] ;
    CHString sSubKey ;
    DWORD i, j, dwRetCode ;
    WCHAR *pValueName = NULL , *c = NULL ;
    BYTE *pValueData = NULL ;
	LONG lRet;

    // UNICODE groups
    //===============

    swprintf(szTemp, L"%s\\%s\\UNICODE Groups", pszRegistryKeyName, szBaseRegKey) ;
    if((lRet = Reg.Open(HKEY_USERS, szTemp, KEY_READ)) == ERROR_SUCCESS)
	{

        try
		{
			for(i = 0 ; i < Reg.GetValueCount() && SUCCEEDED(hr); i++)
			{

				dwRetCode = Reg.EnumerateAndGetValues(i, pValueName, pValueData) ;
				if(dwRetCode == ERROR_SUCCESS)
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
					if (pInstance != NULL )
					{
						pInstance->SetCHString(L"UserName", pszUserName );
						pInstance->SetCHString(L"GroupName", (LPCSTR) pValueData );
						pInstance->SetCHString(L"Name", CHString(pszUserName) + CHString(L":") + CHString((WCHAR*)pValueData) );

						hr = pInstance->Commit () ;
					}
				}
			}

			Reg.Close() ;
		}
		catch ( ... )
		{
			if ( pValueName )
			{
				delete [] pValueName ;
				pValueName = NULL ;
			}

			if ( pValueData )
			{
				delete [] pValueData ;
				pValueData = NULL ;
			}
			throw ;
		}

		if ( pValueName )
		{
			delete [] pValueName ;
			pValueName = NULL ;
		}

		if ( pValueData )
		{
			delete [] pValueData ;
			pValueData = NULL ;
		}
    }
	//else
	//{
	//	if (lRet == ERROR_ACCESS_DENIED)
	//		hr = WBEM_E_ACCESS_DENIED;
	//}

    // Get the Common Groups
    //======================
	pValueName = NULL ;
	pValueData = NULL ;

	swprintf(szTemp, L"%s\\%s\\Common Groups", pszRegistryKeyName, szBaseRegKey) ;
    try
	{
		if((lRet = Reg.Open(HKEY_USERS, szTemp, KEY_READ)) == ERROR_SUCCESS)
		{

			for(i = 0 ; i < Reg.GetValueCount() && SUCCEEDED(hr); i++)
			{

				dwRetCode = Reg.EnumerateAndGetValues(i, pValueName, pValueData) ;
				if(dwRetCode == ERROR_SUCCESS)
				{
					// Scan past window coord info (7 decimal #s)
					//===========================================

					c = wcschr((WCHAR*) pValueData, _T(' ')) ;
					for(j = 0 ; j < 6 ; j++) {

						if(c == NULL) {

							break ;
						}

						c = wcschr(c+1, ' ') ; // L10N OK
					}

					// Check conformance to expected format
					//=====================================

					if(c != NULL)
					{

						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
						if ( pInstance != NULL )
						{
							pInstance->SetCHString(L"UserName", pszUserName );
							pInstance->SetCHString(L"GroupName", c+1);
							pInstance->SetCHString(L"Name", CHString(pszUserName) + CHString(L":") + CHString(c+1));

							hr = pInstance->Commit () ;
						}
					}
				}
			}

			Reg.Close() ;
		}
	}
	catch ( ... )
	{
   		if ( pValueName )
		{
			delete [] pValueName ;
			pValueName = NULL ;
		}

		if ( pValueData )
		{
			delete [] pValueData ;
			pValueData = NULL ;
		}

		throw ;
	}

   	if ( pValueName )
	{
		delete [] pValueName ;
		pValueName = NULL ;
	}

	if ( pValueData )
	{
		delete [] pValueData ;
		pValueData = NULL ;
	}
	//else
	//{
	if (lRet == ERROR_ACCESS_DENIED)
	{
		hr = WBEM_E_ACCESS_DENIED;
	}
	//}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\programgroup.h ===
//=================================================================

//

// PrgGroup.h -- Program group property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/24/97    jennymc        Updated to meet new framework
//
//=================================================================


//*****************************************************************
//*****************************************************************
//
//             W   A   R   N   I   N   G  !!!!!!!!!!
//             W   A   R   N   I   N   G  !!!!!!!!!!
//
//
//  This class has been deprecated for Nova M2 and later builds of
//  WBEM.  Do not make alterations to this class.  Make changes to
//  the new class Win32_LogicalProgramFile (LogicalProgramFile.cpp)
//  instead.  The new class (correctly) is derived in CIMOM from
//  LogicalElement, not LogicalSetting.
//
//*****************************************************************
//*****************************************************************



// Property set identification
//============================

#define PROPSET_NAME_PRGGROUP   L"Win32_ProgramGroup"


class CWin32ProgramGroup : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32ProgramGroup(LPCWSTR name, LPCWSTR pszNameSpace);
       ~CWin32ProgramGroup() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);



    private:
        // Utility function(s)
        //====================

        HRESULT CreateSubDirInstances(LPCTSTR pszUserName,
                                      LPCTSTR pszBaseDirectory,
                                      LPCTSTR pszParentDirectory,
                                      MethodContext*  pMethodContext) ;

        HRESULT EnumerateGroupsTheHardWay(MethodContext*  pMethodContext) ;

        HRESULT InstanceHardWayGroups(LPCWSTR  pszUserName, 
                                   LPCWSTR  pszRegistryKeyName,
                                   MethodContext*  pMethodContext) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\qfe.cpp ===
//=================================================================

//

// CQfe.cpp -- quick fix engineering property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    02/01/99    a-peterc        Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "Qfe.h"


// Property set declaration
//=========================

CQfe MyCQfe ( PROPSET_NAME_CQfe , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CQfe::CQfe
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CQfe :: CQfe (

	LPCWSTR a_name,
	LPCWSTR a_pszNamespace

) : Provider ( a_name , a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CQfe::CQfe
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CQfe::~CQfe()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CQfe::GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CQfe::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
  	HRESULT	t_hResult = WBEM_E_NOT_FOUND ;
	CQfeArray t_oQfeArray ;

	HRESULT t_hRes = hGetQfes ( t_oQfeArray ) ;
	if ( SUCCEEDED ( t_hRes ) )
	{
		CHString t_chsHotFixID;
		CHString t_chsServicePackInEffect;

		a_pInst->GetCHString( L"HotFixID", t_chsHotFixID ) ;

		if( !a_pInst->IsNull ( L"ServicePackInEffect" ) )
		{
			a_pInst->GetCHString( L"ServicePackInEffect", t_chsServicePackInEffect ) ;
		}

		for( int t_iCtrIndex = 0; t_iCtrIndex < t_oQfeArray.GetSize(); t_iCtrIndex++ )
		{
			CQfeElement *t_pQfeElement = (CQfeElement*)t_oQfeArray.GetAt( t_iCtrIndex ) ;

			// two keys for this class
			if( !t_chsHotFixID.CompareNoCase( t_pQfeElement->chsHotFixID ) &&
				!t_chsServicePackInEffect.CompareNoCase( t_pQfeElement->chsServicePackInEffect ) )
			{
				if( t_chsServicePackInEffect.IsEmpty() )
				{
					// populated the empty key
					a_pInst->SetCHString( L"ServicePackInEffect", t_pQfeElement->chsServicePackInEffect ) ;
				}

				a_pInst->SetCHString( L"Description",			t_pQfeElement->chsFixDescription ) ;
				a_pInst->SetCHString( L"FixComments",			t_pQfeElement->chsFixComments ) ;
				a_pInst->SetCHString( L"InstalledBy",			t_pQfeElement->chsInstalledBy ) ;
				a_pInst->SetCHString( L"InstalledOn",			t_pQfeElement->chsInstalledOn ) ;
				a_pInst->SetCHString( L"CSName",				GetLocalComputerName() ) ;

				t_hResult = WBEM_S_NO_ERROR ;
			}
		}
	}

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CQfe::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CQfe :: EnumerateInstances (

	MethodContext *a_pMethodContext,
	long a_lFlags /*= 0L*/
)
{
	HRESULT	t_hResult = WBEM_E_NOT_FOUND;

	CQfeArray	t_oQfeArray ;
	HRESULT		t_hRes = hGetQfes ( t_oQfeArray ) ;

	if ( SUCCEEDED ( t_hRes ) )
	{
		for( int t_iCtrIndex = 0; t_iCtrIndex < t_oQfeArray.GetSize(); t_iCtrIndex++ )
		{
			CQfeElement *t_pQfeElement = (CQfeElement*)t_oQfeArray.GetAt( t_iCtrIndex ) ;

			CInstancePtr t_pInst(CreateNewInstance ( a_pMethodContext ), false);

			if ( t_pInst )
			{
				t_pInst->SetCHString( L"HotFixID",				t_pQfeElement->chsHotFixID ) ;
				t_pInst->SetCHString( L"ServicePackInEffect",	t_pQfeElement->chsServicePackInEffect ) ;
				t_pInst->SetCHString( L"Description",			t_pQfeElement->chsFixDescription ) ;
				t_pInst->SetCHString( L"FixComments",			t_pQfeElement->chsFixComments ) ;
				t_pInst->SetCHString( L"InstalledBy",			t_pQfeElement->chsInstalledBy ) ;
				t_pInst->SetCHString( L"InstalledOn",			t_pQfeElement->chsInstalledOn ) ;
	 			t_pInst->SetCHString( L"CSName",				GetLocalComputerName() ) ;

				t_hResult = t_pInst->Commit(  );
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CQfe::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CQfe :: hGetQfes ( CQfeArray& a_rQfeArray )
{

	CHString t_chsHotFixKey (_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix"));

	// Under Hotfix

	CRegistry t_oRegistry;

	if ( ERROR_SUCCESS == t_oRegistry.OpenAndEnumerateSubKeys ( HKEY_LOCAL_MACHINE , t_chsHotFixKey , KEY_READ ) )
	{
		CHString t_csQFEInstKey ;

		// Walk through each instance under this key.

		while (	( ERROR_SUCCESS == t_oRegistry.GetCurrentSubKeyName ( t_csQFEInstKey ) ) )
		{
			CHString t_csQFECompleteKey;

			t_csQFECompleteKey = t_chsHotFixKey;
			t_csQFECompleteKey += _T("\\");
			t_csQFECompleteKey += t_csQFEInstKey;

			// If pre NT4 SP4 the key starts with a "Q". No SP info
			if( -1 != t_csQFEInstKey.Find( (CHString) "Q" ) )
			{
				CQfeElement *t_pElement = new CQfeElement ;
				if ( t_pElement )
				{
					try
					{
						// build the keys
						TCHAR t_chDelimiter = ',';
						int t_iTokLen = t_csQFEInstKey.Find( t_chDelimiter );

						if( -1 == t_iTokLen )
						{
							t_pElement->chsHotFixID = t_csQFEInstKey ;
						}
						else
						{
							t_pElement->chsHotFixID = t_csQFEInstKey.Left( t_iTokLen ) ;
						}

						t_pElement->chsServicePackInEffect = "" ;

						// open the hotfix

						CRegistry t_oRegistry2 ;

						if ( ERROR_SUCCESS == t_oRegistry2.Open (	HKEY_LOCAL_MACHINE,
																	t_csQFECompleteKey,
																	KEY_READ ) )
						{
							t_oRegistry2.GetCurrentKeyValue( L"Fix Description",t_pElement->chsFixDescription ) ;
							t_oRegistry2.GetCurrentKeyValue( L"Comments",		t_pElement->chsFixComments ) ;
							t_oRegistry2.GetCurrentKeyValue( L"Installed By",	t_pElement->chsInstalledBy ) ;
							t_oRegistry2.GetCurrentKeyValue( L"Installed On",	t_pElement->chsInstalledOn ) ;
							t_oRegistry2.GetCurrentKeyValue( L"Installed",		t_pElement->dwInstalled ) ;

							try
							{
								a_rQfeArray.Add ( t_pElement ) ;
							}
							catch ( ... )
							{
								t_pElement = NULL ;

								throw ;
							}
						}
					}
					catch ( ... )
					{
						if ( t_pElement )
						{
							delete t_pElement ;
						}
                        throw;
					}
				}
			}
			else // else by service pack
			{
				CRegistry t_oRegistry2 ;
				if ( ERROR_SUCCESS == t_oRegistry2.OpenAndEnumerateSubKeys ( HKEY_LOCAL_MACHINE ,
																			 t_csQFECompleteKey ,
																			 KEY_READ ) )
				{
					CHString t_csSpQFEInstKey;
                    CHString t_csSPName;

                    int j = t_csQFECompleteKey.ReverseFind(L'\\');
                    if(j != -1)
                    {
                        t_csSPName = t_csQFECompleteKey.Mid(j+1);
                    }

					// Hotfixes within a SP
					while (	(ERROR_SUCCESS == t_oRegistry2.GetCurrentSubKeyName( t_csSpQFEInstKey ) ) )
					{
						CQfeElement *t_pElement = new CQfeElement ;
						if ( t_pElement )
						{
							try
							{
								// build the keys
								TCHAR t_chDelimiter = ',';
								int t_iTokLen = t_csSpQFEInstKey.Find( t_chDelimiter ) ;

								if ( -1 == t_iTokLen )
								{
									t_pElement->chsHotFixID = t_csSpQFEInstKey ;
								}
								else
								{
									t_pElement->chsHotFixID = t_csSpQFEInstKey.Left( t_iTokLen ) ;
								}

								t_pElement->chsServicePackInEffect = t_csSPName ;

								// open the hotfix
								CHString t_csSpQFECompleteKey ;

								 t_csSpQFECompleteKey = t_csQFECompleteKey ;
								 t_csSpQFECompleteKey += _T("\\") ;
								 t_csSpQFECompleteKey += t_csSpQFEInstKey ;

								CRegistry t_oRegistry3 ;

								if (ERROR_SUCCESS == t_oRegistry3.Open(	HKEY_LOCAL_MACHINE,
																		t_csSpQFECompleteKey,
																		KEY_READ ) )
								{
									t_oRegistry3.GetCurrentKeyValue( L"Fix Description",t_pElement->chsFixDescription ) ;
									t_oRegistry3.GetCurrentKeyValue( L"Comments",		t_pElement->chsFixComments ) ;
									t_oRegistry3.GetCurrentKeyValue( L"Installed By",	t_pElement->chsInstalledBy ) ;
									t_oRegistry3.GetCurrentKeyValue( L"Installed On",	t_pElement->chsInstalledOn ) ;
									t_oRegistry3.GetCurrentKeyValue( L"Installed",		t_pElement->dwInstalled ) ;
								}

								try
								{
									a_rQfeArray.Add( t_pElement ) ;
								}
								catch ( ... )
								{
									t_pElement = NULL ;

									throw ;
								}
							}
							catch ( ... )
							{
								if ( t_pElement )
								{
									delete t_pElement ;
								}

								throw ;
							}
						}
                        t_oRegistry2.NextSubKey();
					}
				}
			}
			t_oRegistry.NextSubKey() ;
		}
	}

    // Now get info from the W2K and later portion of the registry...
    hGetQfesW2K(a_rQfeArray);

	return WBEM_S_NO_ERROR ;
}


// On Windows 2000 and later, QFEs are stored under the following key:
// HKEY_LOCAL_MACHINE\software\Microsoft\Updates\<product>\<updateID>", 
// where product might be something like "WMI", and updateID might be
// something like Q123456.
HRESULT CQfe :: hGetQfesW2K ( CQfeArray& a_rQfeArray )
{
    HRESULT hrRet = WBEM_S_NO_ERROR;
	
    CHString t_chsUpdateKey (_T("SOFTWARE\\Microsoft\\Updates"));

	// Under Hotfix

	CRegistry t_oRegistry;

	if ( ERROR_SUCCESS == t_oRegistry.OpenAndEnumerateSubKeys ( HKEY_LOCAL_MACHINE , t_chsUpdateKey , KEY_READ ) )
	{
		CHString t_csQFEProductKey ;

		// Walk through each instance under this key. Each instance under this key
        // is the <product>.

		while (	( ERROR_SUCCESS == t_oRegistry.GetCurrentSubKeyName ( t_csQFEProductKey ) ) )
		{
			CHString t_csQFEProductCompleteKey;

			t_csQFEProductCompleteKey = t_chsUpdateKey;
			t_csQFEProductCompleteKey += _T("\\");
			t_csQFEProductCompleteKey += t_csQFEProductKey;


			// Now we need to look under the product entries to get the updateID
            // keys.

			CRegistry t_oRegistry2 ;
			if ( ERROR_SUCCESS == t_oRegistry2.OpenAndEnumerateSubKeys ( HKEY_LOCAL_MACHINE ,
																		 t_csQFEProductCompleteKey ,
																		 KEY_READ ) )
			{
				CHString t_csQFEUpdateIDKey;

				while (	(ERROR_SUCCESS == t_oRegistry2.GetCurrentSubKeyName( t_csQFEUpdateIDKey ) ) )
				{
					CHString t_csQFEUpdateIDCompleteKey;
                    
                    t_csQFEUpdateIDCompleteKey = t_csQFEProductCompleteKey;
                    t_csQFEUpdateIDCompleteKey += _T("\\");
                    t_csQFEUpdateIDCompleteKey += t_csQFEUpdateIDKey;

                    // Now, as an added wrinkle, the updateID key might be the Q number (e.g., Q12345),
                    // or, in the case of service packs, just another grouping, under which in turn the
                    // Q numbers appear.  We can tell if it is just another grouping key by checking 
                    // whether there is a Description value.  If there is not one, we will assume it is
                    // a grouping key.

                    // Check if the Description value is present...
                    CRegistry t_oRegistry3;

                    if(ERROR_SUCCESS == t_oRegistry3.Open(	
                        HKEY_LOCAL_MACHINE,
						t_csQFEUpdateIDCompleteKey,
						KEY_READ))
                    {
                        CHString chsDescription;
                        if(t_oRegistry3.GetCurrentKeyValue(L"Description", chsDescription) == ERROR_SUCCESS)
                        {
                            // This is the level at which the QFE data exists.  Continue to collect the data.
                            GetDataForW2K(
                                t_csQFEUpdateIDKey,
                                L"",
                                t_oRegistry3,
                                a_rQfeArray);
                        }
                        else
                        {
                            // We are at a "grouping" level (e.g., something like SP1), so need to go
                            // one level deeper.
                            CHString t_csQFEDeeperUpdateIDKey;

                            if ( ERROR_SUCCESS == t_oRegistry3.OpenAndEnumerateSubKeys(
                                HKEY_LOCAL_MACHINE ,
								t_csQFEUpdateIDCompleteKey ,
								KEY_READ))
                            {
                                while (	(ERROR_SUCCESS == t_oRegistry3.GetCurrentSubKeyName( t_csQFEDeeperUpdateIDKey ) ) )
				                {
                                    CHString t_csQFEDeeperUpdateIDCompleteKey;
                    
                                    t_csQFEDeeperUpdateIDCompleteKey = t_csQFEUpdateIDCompleteKey;
                                    t_csQFEDeeperUpdateIDCompleteKey += _T("\\");
                                    t_csQFEDeeperUpdateIDCompleteKey += t_csQFEDeeperUpdateIDKey;

                                    CRegistry t_oRegistry4;

                                    if(ERROR_SUCCESS == t_oRegistry4.Open(	
                                        HKEY_LOCAL_MACHINE,
						                t_csQFEDeeperUpdateIDCompleteKey,
						                KEY_READ))
                                    {

                                        if(t_oRegistry4.GetCurrentKeyValue(L"Description", chsDescription) == ERROR_SUCCESS)
                                        {
                                            GetDataForW2K(
                                                t_csQFEDeeperUpdateIDKey,
                                                t_csQFEUpdateIDKey,
                                                t_oRegistry4, 
                                                a_rQfeArray);
                                        }
                                    }
                                
                                    // there might be other grouping keys at this level...
                                    t_oRegistry3.NextSubKey();
                                }
                            }
                        }        
                    }
                    // Now go to the next update ID key...
                    t_oRegistry2.NextSubKey();
				}
			}
            // Now get the next product key...
			t_oRegistry.NextSubKey() ;
		}
	}

	return hrRet ;
}

HRESULT CQfe::GetDataForW2K(
    const CHString& a_chstrQFEInstKey,
    LPCWSTR wstrServicePackOrGroup,
    CRegistry& a_reg,
    CQfeArray& a_rQfeArray)
{
    HRESULT hrRet = WBEM_S_NO_ERROR;

    CQfeElement *t_pElement = new CQfeElement;
	if(t_pElement)
	{
		try
		{
			// build the keys
			TCHAR t_chDelimiter = ',';
			int t_iTokLen = a_chstrQFEInstKey.Find( t_chDelimiter ) ;

			if ( -1 == t_iTokLen )
			{
				t_pElement->chsHotFixID = a_chstrQFEInstKey ;
			}
			else
			{
				t_pElement->chsHotFixID = a_chstrQFEInstKey.Left( t_iTokLen ) ;
			}

			t_pElement->chsServicePackInEffect = wstrServicePackOrGroup ;
            
            {
				a_reg.GetCurrentKeyValue( L"Description",t_pElement->chsFixDescription ) ;
				a_reg.GetCurrentKeyValue( L"Type",		t_pElement->chsFixComments ) ;
				a_reg.GetCurrentKeyValue( L"InstalledBy",	t_pElement->chsInstalledBy ) ;
				a_reg.GetCurrentKeyValue( L"InstallDate",	t_pElement->chsInstalledOn ) ;
				a_reg.GetCurrentKeyValue( L"Installed",		t_pElement->dwInstalled ) ;
			}

			try
			{
				a_rQfeArray.Add(t_pElement);
			}
			catch(...)
			{
				t_pElement = NULL;
				throw;
			}
		}
		catch(...)
		{
			if(t_pElement)
			{
				delete t_pElement;
                t_pElement = NULL;
			}
			throw;
		}
	}

    return hrRet;
}

//
CQfeElement :: CQfeElement ()
{
	dwInstalled = 0 ;
}

CQfeElement::~CQfeElement()
{
}


CQfeArray::CQfeArray()
{
}

CQfeArray::~CQfeArray()
{
	CQfeElement *t_pQfeElement ;

	for ( int t_iar = 0; t_iar < GetSize(); t_iar++ )
	{
		if( t_pQfeElement = (CQfeElement*)GetAt( t_iar ) )
		{
			delete t_pQfeElement ;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\recovery.h ===
//=================================================================

//

// Recovery.h -- OS Recovery Configuration property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/97    davwoh         Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_RECOVERY_CONFIGURATION L"Win32_OSRecoveryConfiguration"

class CWin32OSRecoveryConfiguration:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32OSRecoveryConfiguration(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32OSRecoveryConfiguration() ;

        // Funcitons provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);

    private:
       void GetRecoveryInfo(CInstance *pInstance);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\qfe.h ===
//=================================================================

//

// qfe.h -- quick fix engineering property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    02/01/99    a-peterc        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_CQfe L"Win32_QuickFixEngineering"

class CQfeArray : public CHPtrArray 
{
    public:

        // Constructor/destructor
        //=======================

        CQfeArray() ;
       ~CQfeArray() ;
} ;

class CQfeElement
 {
    public:

        // Constructor/destructor
        //=======================

        CQfeElement() ;
       ~CQfeElement() ;

        
	   CHString chsHotFixID ;
	   CHString chsServicePackInEffect ;
	   CHString chsFixDescription ;
	   CHString chsFixComments ;
	   CHString chsInstalledBy ;
	   CHString chsInstalledOn ;
	   DWORD	dwInstalled ;
} ;

    
class CQfe : public Provider 
{
    public:

        // Constructor/destructor
        //=======================

        CQfe(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CQfe() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
		HRESULT hGetQfes( CQfeArray& a_rQfeArray ) ;

    private:

        HRESULT hGetQfesW2K(CQfeArray& a_rQfeArray);
        
        HRESULT GetDataForW2K(
            const CHString& a_chstrQFEInstKey,
            LPCWSTR wstrServicePackOrGroup,
            CRegistry& a_reg,
            CQfeArray& a_rQfeArray);
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\recovery.cpp ===
//=================================================================

//

// Recovery.h -- OS Recovery Configuration property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/97    davwoh         Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "SystemName.h"

#include "Recovery.h"

// Property set declaration
//=========================

CWin32OSRecoveryConfiguration CWin32OSRecoveryConfiguration ( PROPSET_NAME_RECOVERY_CONFIGURATION , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::CWin32OSRecoveryConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32OSRecoveryConfiguration :: CWin32OSRecoveryConfiguration (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::~CWin32OSRecoveryConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32OSRecoveryConfiguration :: ~CWin32OSRecoveryConfiguration ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    : Returns info for running OS only until we discover other
 *                installed OSes
 *
 *****************************************************************************/

HRESULT CWin32OSRecoveryConfiguration :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
#ifdef WIN9XONLY
    return WBEM_E_NOT_FOUND;
#endif

#ifdef NTONLY

    CSystemName cSN;

    // Not our object path
    if (!cSN.ObjectIsUs(pInstance))
	{
         return WBEM_E_NOT_FOUND;
	}

    GetRecoveryInfo ( pInstance ) ;

    return WBEM_S_NO_ERROR;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each discovered OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    : Returns only running OS info until we discover installed OSes
 *
 *****************************************************************************/

HRESULT CWin32OSRecoveryConfiguration :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
#ifdef NTONLY
    HRESULT hr = WBEM_S_NO_ERROR;

    CInstancePtr pInstance(CreateNewInstance ( pMethodContext), false) ;

	CSystemName cSN;
	cSN.SetKeys ( pInstance ) ;

	GetRecoveryInfo ( pInstance ) ;

	hr = pInstance->Commit ( ) ;

    return hr;

#endif

#ifdef WIN9XONLY

    return WBEM_S_NO_ERROR;

#endif

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::GetRecoveryInfo
 *
 *  DESCRIPTION : Assigns property values according to currently running OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32OSRecoveryConfiguration :: GetRecoveryInfo (

	CInstance *pInstance
)
{
	CRegistry RegInfo ;
	RegInfo.Open(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\CrashControl", KEY_READ);

	DWORD dwValue ;
	if ( RegInfo.GetCurrentKeyValue( L"LogEvent", dwValue) == ERROR_SUCCESS )
	{
      pInstance->Setbool( L"WriteToSystemLog", dwValue);
	}
	else
	{
		pInstance->Setbool( L"WriteToSystemLog", false);
	}

	if ( RegInfo.GetCurrentKeyValue( L"SendAlert", dwValue) == ERROR_SUCCESS )
	{
		pInstance->Setbool( L"SendAdminAlert", dwValue);
	}
	else
	{
		pInstance->Setbool( L"SendAdminAlert", false);
	}

	if ( RegInfo.GetCurrentKeyValue( L"CrashDumpEnabled", dwValue) == ERROR_SUCCESS)
	{
		pInstance->Setbool( L"WriteDebugInfo", dwValue);
		pInstance->SetDWORD( L"DebugInfoType", dwValue);
	}
	else
	{
		pInstance->Setbool( L"WriteDebugInfo", false);
		pInstance->SetDWORD( L"DebugInfoType", 0);
	}

	if ( RegInfo.GetCurrentKeyValue ( L"Overwrite", dwValue) == ERROR_SUCCESS )
	{
		pInstance->Setbool( L"OverwriteExistingDebugFile", dwValue);
	}
	else
	{
		pInstance->Setbool( L"OverwriteExistingDebugFile", false);
	}

	if ( RegInfo.GetCurrentKeyValue( L"KernelDumpOnly", dwValue) == ERROR_SUCCESS)
	{
		pInstance->Setbool( L"KernelDumpOnly", dwValue);
	}
	else
	{
		pInstance->Setbool( L"KernelDumpOnly", false);
	}

	if ( RegInfo.GetCurrentKeyValue( L"AutoReboot", dwValue) == ERROR_SUCCESS)
	{
		pInstance->Setbool( L"AutoReboot", dwValue);
	}
	else
	{
		pInstance->Setbool( L"AutoReboot", false);
	}

	TCHAR szEnvironment[_MAX_PATH];

	CHString sValue;
	if (RegInfo.GetCurrentKeyValue( L"DumpFile", sValue) == ERROR_SUCCESS)
	{
        pInstance->SetCharSplat( L"DebugFilePath", sValue);
		ExpandEnvironmentStrings(TOBSTRT(sValue), szEnvironment, _MAX_PATH);
	}
	else
	{
        pInstance->SetCharSplat( L"DebugFilePath", _T("%SystemRoot%\\MEMORY.DMP"));
		ExpandEnvironmentStrings( _T("%SystemRoot%\\MEMORY.DMP"), szEnvironment, _MAX_PATH);
	}

	pInstance->SetCharSplat( L"ExpandedDebugFilePath", szEnvironment);

	if (RegInfo.GetCurrentKeyValue( L"MiniDumpDir", sValue) == ERROR_SUCCESS)
	{
    	pInstance->SetCharSplat( L"MinidumpDirectory", sValue);
		ExpandEnvironmentStrings(TOBSTRT(sValue), szEnvironment, _MAX_PATH);
	}
	else
	{
    	pInstance->SetCharSplat( L"MinidumpDirectory", _T("%SystemRoot%\\MINIDUMP"));
		ExpandEnvironmentStrings( _T("%SystemRoot%\\MINIDUMP"), szEnvironment, _MAX_PATH);
	}

	pInstance->SetCharSplat( L"ExpandedMinidumpDirectory", szEnvironment);

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::PutInstance
 *
 *  DESCRIPTION : Write changed instance
 *
 *  INPUTS      : pInstance to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : The only property we write is MaximumSize
 *
 *****************************************************************************/

HRESULT CWin32OSRecoveryConfiguration :: PutInstance (

	const CInstance &pInstance,
	long lFlags /*= 0L*/
)
{
   // Tell the user we can't create a new os (much as we might like to)
	if (lFlags & WBEM_FLAG_CREATE_ONLY)
	{
		return WBEM_E_UNSUPPORTED_PARAMETER;
	}

#ifdef WIN9XONLY

      return WBEM_E_NOT_FOUND;

#endif

#ifdef NTONLY

   DWORD dwTemp;

	HRESULT hRet = WBEM_S_NO_ERROR;

   // Not our object path

	CSystemName cSN;
	if (!cSN.ObjectIsUs(&pInstance))
	{
		if ( lFlags & WBEM_FLAG_UPDATE_ONLY )
		{
			hRet = WBEM_E_NOT_FOUND;
		}
		else
		{
			hRet = WBEM_E_UNSUPPORTED_PARAMETER;
		}
	}
	else
	{
		CRegistry RegInfo ;
		RegInfo.Open ( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\CrashControl"), KEY_WRITE);

      // If a value was specified, write it.

		if ( ! pInstance.IsNull ( _T("WriteToSystemLog") ) )
		{
			bool bWrite;
			pInstance.Getbool( _T("WriteToSystemLog"), bWrite);

			if (bWrite)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("LogEvent"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if ( ! pInstance.IsNull( _T("SendAdminAlert") ) )
		{
			bool bSend;
			pInstance.Getbool( _T("SendAdminAlert"), bSend);

			if (bSend)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("SendAlert"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if (!pInstance.IsNull( _T("DebugInfoType") ))
		{
			if (pInstance.GetDWORD( _T("DebugInfoType"), dwTemp))
			{
				DWORD dwRet = RegSetValueEx (

					RegInfo.GethKey(),
					_T("CrashDumpEnabled"),
					0,
					REG_DWORD,
					(CONST BYTE *)&dwTemp,
					sizeof(DWORD)
				) ;

				if (ERROR_SUCCESS != dwRet )
				{
					hRet = WBEM_E_FAILED;
				}
			}
		}
		else if (!pInstance.IsNull( _T("WriteDebugInfo") ) )
		{
			bool bWrite;
			pInstance.Getbool( _T("WriteDebugInfo"), bWrite);

			if (bWrite)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("CrashDumpEnabled"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if (ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if ( ! pInstance.IsNull( _T("OverwriteExistingDebugFile") ) )
		{
			bool bOver;
			pInstance.Getbool( _T("OverwriteExistingDebugFile"), bOver);

			if (bOver)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("Overwrite"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		// KMH
		if ( ! pInstance.IsNull( _T("KernelDumpOnly") ) )
		{
			bool bOver;
			pInstance.Getbool( _T("KernelDumpOnly"), bOver);

			if (bOver)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("KernelDumpOnly"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if ( ! pInstance.IsNull( _T("AutoReboot") ) )
		{
			bool bAuto;
			pInstance.Getbool( _T("AutoReboot"), bAuto);

			if (bAuto)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("AutoReboot"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if (ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if ( ! pInstance.IsNull( _T("DebugFilePath") ) )
		{
			CHString sName ;
			pInstance.GetCHString( _T("DebugFilePath"), sName);

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("DumpFile"),
				0,
				REG_SZ,
				(CONST BYTE *)(LPCTSTR) sName,
				lstrlen ( sName )* sizeof(TCHAR)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if ( ! pInstance.IsNull( _T("DirectoryPath") ) )
		{
			CHString sName ;
			pInstance.GetCHString( _T("DirectoryPath"), sName);

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("MiniDumpDir"),
				0,
				REG_SZ,
				(CONST BYTE *)(LPCTSTR) sName,
				lstrlen ( sName )* sizeof(TCHAR)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}
	}

	return hRet ;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\regcfg.cpp ===
//=================================================================

//

// RegCfg.h -- Registry Configuration property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/20/97    davwoh         Created
//
//=================================================================

// All these nt routines are needed to support the NtQuerySystemInformation
// call.  They must come before FWCommon et all or else it won't compile.



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cregcls.h>
#include "SystemName.h"
#include "resource.h"

#include "DllWrapperBase.h"
#include "NtDllApi.h"

#include "RegCfg.h"

// Property set declaration
//=========================

CWin32RegistryConfiguration CWin32RegistryConfiguration ( PROPSET_NAME_REGISTRY_CONFIGURATION , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::CWin32RegistryConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32RegistryConfiguration :: CWin32RegistryConfiguration (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::~CWin32RegistryConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32RegistryConfiguration::~CWin32RegistryConfiguration()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    : Returns info for running OS only until we discover other
 *                installed OSes
 *
 *****************************************************************************/

HRESULT CWin32RegistryConfiguration :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
#ifdef WIN9XONLY

    return WBEM_E_NOT_FOUND;

#endif

#ifdef NTONLY

	CSystemName cSN;
	if (!cSN.ObjectIsUs(pInstance))
	{
      return WBEM_E_NOT_FOUND;
	}

	GetRegistryInfo ( pInstance ) ;

	return WBEM_S_NO_ERROR;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each discovered OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    : Returns only running OS info until we discover installed OSes
 *
 *****************************************************************************/

HRESULT CWin32RegistryConfiguration :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR;
   // No workee on 95
#ifdef NTONLY

	CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
	if (pInstance)
	{
		CSystemName cSN;

	// Sets the key properties common to several classes

		cSN.SetKeys ( pInstance ) ;
		GetRegistryInfo ( pInstance ) ;

	// Only one instance, save it.
		hr = pInstance->Commit() ;

	}

#endif

   return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::GetRunningOSInfo
 *
 *  DESCRIPTION : Assigns property values according to currently running OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32RegistryConfiguration :: GetRegistryInfo ( CInstance *pInstance )
{

    DWORD dwUsed = -1;
    DWORD dwProposedSize = -1;
    DWORD dwMaxSize = -1;

    bool bDone = false;

    CNtDllApi *t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if ( t_pNtDll != NULL )
    {
		try
		{
			// This is from ntdll.dll and is not doc'ed in the sdk docs

		    SYSTEM_REGISTRY_QUOTA_INFORMATION srqi;

   			NTSTATUS Status = t_pNtDll->NtQuerySystemInformation (

				SystemRegistryQuotaInformation,
				&srqi,
				sizeof(srqi),
				NULL
			);

			if (NT_SUCCESS(Status))
			{
				dwUsed = srqi.RegistryQuotaUsed;
				dwMaxSize = srqi.RegistryQuotaAllowed;
				bDone = true;
			}
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);

			throw ;
		}

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
        t_pNtDll = NULL;
    }

    // Read the size from the registry


	CRegistry RegInfo ;

    if ( RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control", KEY_READ) == ERROR_SUCCESS )
    {
        if ( RegInfo.GetCurrentKeyValue ( L"RegistrySizeLimit", dwProposedSize ) != ERROR_SUCCESS )
        {
            dwProposedSize = -1 ;
        }
    }
    else
    {
        dwProposedSize = -1 ;
    }

    if ( ! bDone )
    {
        // I don't see a good way to get this otherwise

        // Read the size from the registry

        RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control", KEY_READ ) ;
        if ( RegInfo.GetCurrentKeyValue ( L"RegistrySizeLimit", dwMaxSize) != ERROR_SUCCESS )
        {
            // If we couldn't read it, make a guess based on ppl

            RegInfo.Open ( HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management", KEY_READ ) ;

		    DWORD dwPPL ;

            if ( ( RegInfo.GetCurrentKeyValue( L"PagedPoolSize", dwPPL) != ERROR_SUCCESS) || (dwPPL == 0))
            {
                dwPPL = 5 * ONE_MEG;
            }

            dwMaxSize = dwPPL * 8 / 10;
        }
    }

    if ( dwMaxSize == -1 )
    {
        dwMaxSize = dwProposedSize;
    }

    // Massage it according to nt's arcane rules and store
    if ( dwMaxSize != -1 )
    {
        pInstance->SetDWORD ( L"MaximumSize", (dwMaxSize + ONE_MEG - 1) / ONE_MEG);
    }

    if ( dwUsed != -1 )
    {
        pInstance->SetDWORD ( L"CurrentSize", (dwUsed + ONE_MEG - 1) / ONE_MEG);
    }

    if (dwProposedSize != -1)
    {
        pInstance->SetDWORD ( L"ProposedSize", (dwProposedSize + ONE_MEG - 1) / ONE_MEG);
    }
    else
    {
        pInstance->SetDWORD ( L"ProposedSize", (dwMaxSize + ONE_MEG - 1) / ONE_MEG);
    }

    // Set some fixed values...
    CHString sTemp2;
    LoadStringW(sTemp2, IDR_Registry);

    pInstance->SetCHString ( L"Caption", sTemp2);
    pInstance->SetCHString ( L"Description", sTemp2);
    pInstance->SetCharSplat ( L"Status", L"OK" );

    // Since the registry was created when the os was installed,
    // get the os installed date.
    RegInfo.Open (

		HKEY_LOCAL_MACHINE,
        L"Software\\Microsoft\\Windows NT\\CurrentVersion",
        KEY_READ
	) ;

    DWORD dwInstallDate ;

    if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue ( L"InstallDate", dwInstallDate ) )
    {
		time_t tTime = (time_t) dwInstallDate;

      // The followng line was commented out and replaced with the line following it
      // to be consistent with Win32_OperatingSystem (os.cpp).

		WBEMTime wTime(tTime);

		pInstance->SetDateTime( L"InstallDate", wTime );
   }
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::PutInstance
 *
 *  DESCRIPTION : Write changed instance
 *
 *  INPUTS      : pInstance to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : The only property we write is MaximumSize
 *
 *****************************************************************************/

HRESULT CWin32RegistryConfiguration :: PutInstance (

	const CInstance &pInstance,
	long lFlags /*= 0L*/
)
{

#ifdef WIN9XONLY

        return WBEM_E_NOT_FOUND;

#endif

#ifdef NTONLY

    HRESULT hRet = WBEM_S_NO_ERROR ;
	DWORD t_dwUsed = -1 ;
    // Tell the user we can't create a new registry
    if ( lFlags & WBEM_FLAG_CREATE_ONLY )
	{
        return WBEM_E_UNSUPPORTED_PARAMETER ;
	}

	CSystemName cSN;
    if (!cSN.ObjectIsUs(&pInstance))
	{
        if (lFlags & WBEM_FLAG_UPDATE_ONLY)
		{
            hRet = WBEM_E_NOT_FOUND;
        }
		else
		{
            hRet = WBEM_E_UNSUPPORTED_PARAMETER;
        }
    }
	else
	{
		CRegistry RegInfo;

        // See if they specified a value for this field
        if (!pInstance.IsNull( _T("ProposedSize") ) )
		{
			DWORD dwSize;
            pInstance.GetDWORD( _T("ProposedSize"), dwSize);

			CNtDllApi *t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);

			if ( t_pNtDll != NULL )
			{
				try
				{
					// This is from ntdll.dll and is not doc'ed in the sdk docs

					SYSTEM_REGISTRY_QUOTA_INFORMATION srqi;

   					NTSTATUS Status = t_pNtDll->NtQuerySystemInformation (

						SystemRegistryQuotaInformation,
						&srqi,
						sizeof(srqi),
						NULL
					);

					if (NT_SUCCESS(Status))
					{
						t_dwUsed = srqi.RegistryQuotaUsed;
						t_dwUsed = (t_dwUsed + ONE_MEG - 1) / ONE_MEG ;
					}
				}
				catch ( ... )
				{
					CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);

					throw ;
				}

				CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
				t_pNtDll = NULL;
			}

/*
 * Allow the put if the new proposed max size is greater than the current size
 */
			if ( t_dwUsed != -1 )
			{
				if ( dwSize >= t_dwUsed )
				{
					// Massage it and write it
					dwSize = dwSize * ONE_MEG;

					HRESULT res = RegInfo.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control"), KEY_WRITE) ;

					if ( res == ERROR_SUCCESS)
					{
						res = RegSetValueEx (

							RegInfo.GethKey(),
							_T("RegistrySizeLimit"),
							0,
							REG_DWORD,
							(const unsigned char *)&dwSize,
							sizeof(DWORD)
						) ;

						if ( res != ERROR_SUCCESS)
						{
							hRet = WBEM_E_FAILED;
						}
					}

					if (res == ERROR_ACCESS_DENIED)
					{
						hRet = WBEM_E_ACCESS_DENIED;
					}
				}
				else
				{
					hRet = WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
				hRet = WBEM_E_FAILED ;
			}
        }
    }

    return hRet;
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file. Copyright (c) 1997-2001 Microsoft Corporation
// Used by cimwin32.rc
//
#define IDR_UPSBatteryName              1
#define IDR_BatteryName                 2
//#define IDR_BOOT_CONFIG_NAME            3 //Not required ID maybe reused when next string is req'd.
#define IDR_PhysicalDriveFormat         4
#define IDR_IDEFixedDisk                5
#define IDR_SCSIFixedDisk               6
#define IDR_Unknown                     7
#define IDR_DiskPartitionFormat         8
#define IDR_DiskPartitionFormat1        9
#define IDR_PartitionDescUnused         10
#define IDR_PartitionDesc12bitFAT       11
#define IDR_PartitionDescXenixOne       12
#define IDR_PartitionDescXenixTwo       13
#define IDR_PartitionDesc16bitFAT       14
#define IDR_PartitionDescExtPartition   15
#define IDR_PartitionDescDOSV4Huge      16
#define IDR_PartitionDescInstallable    17
#define IDR_PartitionDescPowerPCRef     18
#define IDR_PartitionDescUnix           19
#define IDR_PartitionDescNTFT           20
#define IDR_PartitionDescWin95Ext       21
#define IDR_PartitionDescExt13          22
#define IDR_PartitionDescUnknown        23
#define IDR_PartitionDescLogicalDiskManager 24
#define IDR_DMAFormat                   25
#define IDR_IRQFormat                   26
#define IDR_PCXT                        27
#define IDR_PCAT                        28
#define IDR_ENHANCED101102              29
#define IDR_NOKIA1050                   30
#define IDR_NOKIA9140                   31
#define IDR_UnknownKeyboard             32
#define IDR_Japanese                    33
#define IDR_ICO                         34
#define IDR_525Floppy                   35
#define IDR_350Floppy                   36
#define IDR_800Floppy                   37
#define IDR_NetworkConnection           38
#define IDR_CDRomDisk                   39
#define IDR_RAMDisk                     40
#define IDR_LogicalMemoryConfiguration  41
#define IDR_Motherboard                 42
#define IDR_UPSName                     43
#define IDR_CPUFormat                   44
#define IDR_Registry                    45
#define IDR_VidModeFormat               46
#define IDR_VidControllerResolutionFormat 48
#define IDR_VidControllerResolutionFormatInterlaced 49
#define IDR_Bus                         50
#define IDR_DefaultMonitor              51
#define IDR_ChannelFormat               52
#define IDR_LocalFixedDisk              53
#define IDR_RemovableDisk               54
#define IDR_Resource_Remembered         55
#define IDR_Resource_Connected          56
#define IDR_ResourceRememberedFormat    57
#define IDR_ResourceConnectedFormat     58
#define IDR_ProcessOSFormat             59
#define IDR_ProcessOSFormat2            60
#define IDR_ComputerSystemProduct       61
#define IDR_BaseBoard                   62
#define IDR_SystemEnclosure             63
#define IDR_CacheMemory                 64
#define IDR_PortConnector               65
#define IDR_SystemSlot                  66
#define IDR_PhysicalMemory              67
#define IDR_PhysicalMemoryArray         68
#define IDR_PortableBattery             69
#define IDR_NumericSensor               70
#define IDR_MemoryArray                 71
#define IDR_MemoryDevice                72
#define IDR_CoolingDevice               73
#define IDR_ModelSteppingFormat         74
#define IDR_DECAlpha21064               108
#define IDR_DECAlpha21066               109
#define IDR_DECAlpha21164               110
#define IDR_ModelPassFormat             111
#define IDR_x86ProcessorFormat          112
#define IDR_UnknownDECAlphaProcessor    113
#define IDR_AMDK7                       114
#define IDR_x86FamilyModelStepping      115
#define IDR_W2k_StockName               116
#define IDR_W2k_Datacenter              117
#define IDR_W2k_AdvancedServer          118
#define IDR_W2k_Server                  119
#define IDR_W2k_Professional            120
#define IDR_NT_StockName                121
#define IDR_NT_EnterpriseServer         122
#define IDR_NT_Server                   123
#define IDR_NT_Workstation              124
#define IDR_9x_StockName                125
#define IDR_JOB_STATUS_PAUSED           126
#define IDR_JOB_STATUS_ERROR            127
#define IDR_JOB_STATUS_DELETING         128
#define IDR_JOB_STATUS_SPOOLING         129
#define IDR_JOB_STATUS_PRINTING         130
#define IDR_JOB_STATUS_OFFLINE          131
#define IDR_JOB_STATUS_PAPEROUT         132
#define IDR_JOB_STATUS_PRINTED          133
#define IDR_JOB_STATUS_DELETED          134
#define IDR_JOB_STATUS_BLOCKED_DEVQ     135
#define IDR_JOB_STATUS_USER_INTERVENTION 136
#define IDR_JOB_STATUS_RESTART          137
#define IDR_NdisMedium802_3             138
#define IDR_NdisMedium802_5             139
#define IDR_NdisMediumFddi              140
#define IDR_NdisMediumWan               141
#define IDR_NdisMediumLocalTalk         142
#define IDR_NdisMediumDix               143
#define IDR_NdisMediumArcnetRaw         144
#define IDR_NdisMediumArcnet878_2       145
#define IDR_NdisMediumAtm               146
#define IDR_NdisMediumWirelessWan       147
#define IDR_NdisMediumIrda              148
#define IDR_NdisMediumBpc               149
#define IDR_NdisMediumCoWan             150
#define IDR_NdisMedium1394              151
#define IDR_CurrentVideoConfiguration   152
#define IDR_Intel486DX                  153
#define IDR_Intel486SX                  154
#define IDR_Intel486DX2                 155
#define IDR_Intel486SL                  156
#define IDR_Intel486SX2                 157
#define IDR_Intel486DX4                 158
#define IDR_Intel486                    159
#define IDR_IntelPentiumMMX             160
#define IDR_IntelPentium                161
#define IDR_IntelPentiumPro             162
#define IDR_IntelCeleron                163
#define IDR_IntelPentiumII              164
#define IDR_IntelPentiumIIXeon          165
#define IDR_IntelPentiumIII             166
#define IDR_IntelPentiumIIIXeon         167
#define IDR_IntelUnknown                168
#define IDR_UnknownIntelP6              169
#define IDR_AMD4685x86                  170
#define IDR_AMDK5                       171
#define IDR_AMDK6                       172
#define IDR_AMDK62                      173
#define IDR_AMDK63                      174
#define IDR_AMDAthlon                   175
#define IDR_CyrixMediaGX                176
#define IDR_Cyrix486                    177
#define IDR_Cyrix6x86                   178
#define IDR_Cyrix6x86L                  179
#define IDR_CyrixMediaGXMMX             180
#define IDR_Cyrix586                    181
#define IDR_Cyrix6x86MX                 182
#define IDR_CyrixUnknown                183
#define IDR_IDTWinChip                  184
#define IDR_Intel486SX2WriteBack        185
#define IDR_AMDUnknown                  186
#define IDR_Itanium            			187
#define IDR_PartitionDescGPTUnused		188
#define IDR_PartitionDescGPTSystem		189
#define IDR_PartitionDescGPTMSFTReserved 190
#define IDR_PartitionDescGPTBasicData	191
#define IDR_PartitionDescGPTLDMMetaData 192
#define IDR_PartitionDescGPTLDMData		193
#define IDR_PartitionDescGPTUnknown		194
#define IDR_W2kPlus1_StockName          195
#define IDR_W2kPlus1_Datacenter         196
#define IDR_W2kPlus1_AdvancedServer     197
#define IDR_W2kPlus1_Server             198
#define IDR_W2kPlus1_Professional       199
#define IDR_W2kPlus1_Personal			200
#define IDR_Blade_StockName             201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\regcfg.h ===
//=================================================================

//

// RegCfg.h -- Registry Configuration property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/20/97    davwoh         Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_REGISTRY_CONFIGURATION L"Win32_Registry"

// I have no idea why this isn't 1,024,000, but that's what nt uses.
#define ONE_MEG             1048576

class CWin32RegistryConfiguration:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32RegistryConfiguration(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32RegistryConfiguration() ;

        // Funcitons provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);

    private:
      void GetRegistryInfo(CInstance *pInstance);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\schedjob.cpp ===
//=================================================================

//

// ScheduledJob.CPP --ScheduledJob property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/27/97	 a-hhance		updated to new framework paradigm.
//				 1/13/98	a-brads		updated to V2 MOF
//			     1/31/01	jennymc         Converted to WBEMTIME and got rid of multiple returns
//=================================================================
#include "precomp.h"

#include "lmcons.h"     // LAN Manager defines
#include "lmerr.h"      // LAN Manager error messages
#include "lmat.h"       // AT Command prototypes
#include "lmapibuf.h"
#include "wbemnetapi32.h"
#include "SchedJob.h"
#include <wbemtime.h>

// Property set declaration
//=========================

ScheduledJob s_ScheduledJob ( PROPSET_NAME_SCHEDULEDJOB , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::ScheduledJob
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

ScheduledJob :: ScheduledJob (LPCWSTR a_Name,LPCWSTR a_Namespace) : Provider ( a_Name, a_Namespace )
{

}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::~ScheduledJob
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

ScheduledJob::~ScheduledJob()
{

}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::GetJobObject
 *
 *  DESCRIPTION : 
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

HRESULT ScheduledJob::GetJobObject (CInstance *a_Instance,DWORD a_JobId )
{
#ifdef WIN9XONLY
    return NERR_NetworkError;
#endif

#ifdef NTONLY
    HRESULT hr = S_OK ;

	CNetAPI32 t_NetAPI ;

	if( ( hr = t_NetAPI.Init() ) == ERROR_SUCCESS )
	{
		AT_INFO *AtInfo = NULL ;

		NET_API_STATUS dwStatus = t_NetAPI.NetScheduleJobGetInfo (NULL ,a_JobId,( LPBYTE * ) & AtInfo) ;

		if ( dwStatus == NERR_Success )
		{
			try
			{
				if ( AtInfo->Command )
				{
					CHString t_Command ( AtInfo->Command ) ;
					a_Instance->SetCHString ( PROPERTY_NAME_COMMAND , t_Command ) ;
				}

				a_Instance->Setbool ( PROPERTY_NAME_RUNREPEATEDLY , AtInfo->Flags & JOB_RUN_PERIODICALLY ? true : false ) ;

				if ( AtInfo->Flags & JOB_EXEC_ERROR )
				{
					a_Instance->SetCHString ( PROPERTY_NAME_JOBSTATUS , PROPERTY_VALUE_JOBSTATUS_FAILURE ) ;
				}
				else
				{
					a_Instance->SetCHString ( PROPERTY_NAME_JOBSTATUS , PROPERTY_VALUE_JOBSTATUS_SUCCESS ) ;
				}

				a_Instance->Setbool ( PROPERTY_NAME_INTERACTWITHDESKTOP , AtInfo->Flags & JOB_NONINTERACTIVE ? false : true ) ;

				a_Instance->Setbool ( PROPERTY_NAME_RUNSTODAY , AtInfo->Flags & JOB_RUNS_TODAY ? true : false ) ;

				
				CHString chsTime;
				if( FormatTimeString( chsTime, AtInfo->JobTime ) )
				{
					a_Instance->SetCHString ( PROPERTY_NAME_STARTTIME , (WCHAR*)(const WCHAR*) chsTime ) ;
				}

				if ( AtInfo->DaysOfMonth )
				{
					a_Instance->SetDWORD ( PROPERTY_NAME_DAYSOFMONTH , AtInfo->DaysOfMonth ) ;
				}

				if ( AtInfo->DaysOfWeek )
				{
					a_Instance->SetDWORD ( PROPERTY_NAME_DAYSOFWEEK , AtInfo->DaysOfWeek ) ;
				}
			}
			catch ( ... )
			{
				t_NetAPI.NetApiBufferFree ( (LPVOID) AtInfo ) ;

				throw ;
			}

			t_NetAPI.NetApiBufferFree ( (LPVOID) AtInfo ) ;
		}
		else
		{
			hr = GetScheduledJobResultCode ( dwStatus ) ;
		}
	}
    return hr ;

#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob::GetObject (CInstance *a_Instance,long a_Flags /*= 0L*/)
{
	HRESULT hr = WBEM_E_FAILED;
	DWORD t_JobId = 0 ;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( a_Instance->GetStatus ( PROPERTY_NAME_JOBID , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_I4 ) )
		{
			if ( a_Instance->GetDWORD ( PROPERTY_NAME_JOBID , t_JobId ) )
			{
				hr = GetJobObject ( a_Instance , t_JobId ) ;
			}
		}
	}

    return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::InstantionJob
 *
 *  DESCRIPTION : Creates instance of property set for each discovered job
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : result code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob :: InstantiateJob (MethodContext *a_MethodContext,long a_Flags /*= 0L*/ ,	AT_ENUM *a_Job)
{
	HRESULT hr = S_OK ;

	CInstancePtr t_Instance(CreateNewInstance ( a_MethodContext ), false) ;

	t_Instance->SetDWORD ( PROPERTY_NAME_JOBID , a_Job->JobId ) ;

	if ( a_Job->Command )
	{
		CHString t_Command ( a_Job->Command ) ;
		t_Instance->SetCHString ( PROPERTY_NAME_COMMAND , t_Command ) ;
	}

	if ( a_Job->DaysOfMonth )
	{
		t_Instance->SetDWORD ( PROPERTY_NAME_DAYSOFMONTH , a_Job->DaysOfMonth ) ;
	}

	if ( a_Job->DaysOfWeek )
	{
		t_Instance->SetDWORD ( PROPERTY_NAME_DAYSOFWEEK , a_Job->DaysOfWeek ) ;
	}

	t_Instance->Setbool ( PROPERTY_NAME_RUNREPEATEDLY , a_Job->Flags & JOB_RUN_PERIODICALLY ? true : false ) ;

	if ( a_Job->Flags & JOB_EXEC_ERROR )
	{
		t_Instance->SetCHString ( PROPERTY_NAME_JOBSTATUS , PROPERTY_VALUE_JOBSTATUS_FAILURE ) ;
	}
	else
	{
		t_Instance->SetCHString ( PROPERTY_NAME_JOBSTATUS , PROPERTY_VALUE_JOBSTATUS_SUCCESS ) ;
	}

	t_Instance->Setbool ( PROPERTY_NAME_INTERACTWITHDESKTOP , a_Job->Flags & JOB_NONINTERACTIVE ? false : true ) ;

	t_Instance->Setbool ( PROPERTY_NAME_RUNSTODAY , a_Job->Flags & JOB_RUNS_TODAY ? true : false ) ;

	CHString chsTime;
	if( FormatTimeString( chsTime, a_Job->JobTime ) )
	{
		t_Instance->SetCHString ( PROPERTY_NAME_STARTTIME , chsTime) ;
	}

	hr = t_Instance->Commit () ;

    return  hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::EnumerateJobs
 *
 *  DESCRIPTION : Creates instance of property set for each discovered job
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : result code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob::EnumerateJobs (	MethodContext *a_MethodContext,	long a_Flags /*= 0L*/
)
{
#ifdef WIN9XONLY
    return NERR_NetworkError;
#endif

#ifdef NTONLY
	HRESULT hr = S_OK ;

	CNetAPI32 t_NetAPI ;

	if( ( hr = t_NetAPI.Init() ) == ERROR_SUCCESS )
	{
		BOOL t_EnumerationContinues = TRUE ;

		DWORD t_PreferedMaximumLength = 0xFFFFFFFF ;
		DWORD t_EntriesRead = 0 ;
		DWORD t_TotalEntriesRead = 0 ;
		DWORD t_ResumeJob = 0 ;

		while ( t_EnumerationContinues )
		{
			AT_ENUM *t_AtEnum = NULL ;

			NET_API_STATUS dwStatus = t_NetAPI.NetScheduleJobEnum (	NULL ,(LPBYTE *) & t_AtEnum, 1000 ,	& t_EntriesRead,
																	& t_TotalEntriesRead ,& t_ResumeJob	) ;

			try
			{
				t_EnumerationContinues = ( dwStatus == ERROR_MORE_DATA ) ? TRUE : FALSE ;

				if ( dwStatus == ERROR_MORE_DATA || dwStatus == NERR_Success )
				{
					for ( ULONG t_Index = 0 ; t_Index < t_EntriesRead ; t_Index ++ )
					{
						AT_ENUM *t_Job = & t_AtEnum [ t_Index ] ;
						hr = InstantiateJob (	a_MethodContext ,a_Flags ,t_Job	) ;
					}
				}
			}
			catch ( ... )
			{
				if ( t_AtEnum )
				{
					t_NetAPI.NetApiBufferFree ( (LPVOID) t_AtEnum ) ;
				}

				throw ;
			}

			if ( t_AtEnum )
			{
				t_NetAPI.NetApiBufferFree ( (LPVOID) t_AtEnum ) ;
			}
		}
	}
    return  hr ;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each discovered job
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : result code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob::EnumerateInstances (MethodContext *a_MethodContext,long a_Flags /*= 0L*/)
{
	HRESULT hr = S_OK ;

	hr = EnumerateJobs ( a_MethodContext , a_Flags ) ;

    return  hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob :: DeleteInstance ( const CInstance &a_Instance, long a_Flags /*= 0L*/ )
{
#ifdef WIN9XONLY
    return NERR_NetworkError;
#endif

#ifdef NTONLY
	HRESULT hr = WBEM_E_TYPE_MISMATCH ;
	bool fExists = FALSE;
	VARTYPE vType ;

	DWORD t_JobId = 0 ;
	if ( a_Instance.GetStatus ( PROPERTY_NAME_JOBID , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_I4 ) )
		{
			if ( a_Instance.GetDWORD ( PROPERTY_NAME_JOBID , t_JobId ) )
			{
				CNetAPI32 t_NetAPI ;

				if( ( hr = t_NetAPI.Init() ) == ERROR_SUCCESS )
				{
					NET_API_STATUS t_JobStatus = t_NetAPI.NetScheduleJobDel(NULL ,t_JobId ,	t_JobId	) ;

					if ( t_JobStatus != NERR_Success )
					{
						hr = GetScheduledJobResultCode ( t_JobStatus ) ;
					}
				}
			}
		}
	}
    return hr ;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob::ExecMethod( const CInstance& a_Instance, const BSTR a_MethodName, CInstance *pInst ,
								  CInstance *a_OutParams ,long a_Flags )
{
	if ( ! a_OutParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}
	//========================================================
    // Do we recognize the method?
 	//========================================================
	if ( _wcsicmp ( a_MethodName , METHOD_NAME_CREATE ) == 0 )
	{
		return ExecCreate ( a_Instance , pInst , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_DELETE ) == 0 )
	{
		return ExecDelete ( a_Instance , pInst , a_OutParams , a_Flags ) ;
	}

	return WBEM_E_INVALID_METHOD;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD ScheduledJob :: GetScheduledJobErrorCode ( NET_API_STATUS dwNetStatus )
{
	DWORD dwStatus = STATUS_UNKNOWN_FAILURE;

	switch ( dwNetStatus )
	{
		case ERROR_INVALID_HANDLE:
		{
			dwStatus = STATUS_UNKNOWN_FAILURE ;
		}
		break ;

		case 3806:	/* special private error code which is not within includes */
		case ERROR_PATH_NOT_FOUND:
		{
			dwStatus = STATUS_PATH_NOT_FOUND ;
		}
		break ;

		case ERROR_ACCESS_DENIED:
		{
			dwStatus = STATUS_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			dwStatus = STATUS_INVALID_PARAMETER ;
		}
		break;

		case NERR_ServiceNotInstalled:
		{
			dwStatus = STATUS_SERVICE_NOT_STARTED ;
		}
		break ;

		default:
		{
			dwStatus = STATUS_UNKNOWN_FAILURE ;
		}
		break ;
	}

	return dwStatus ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob :: GetScheduledJobResultCode ( NET_API_STATUS dwStatus )
{
	HRESULT hr ;

	switch ( dwStatus )
	{
		case NERR_ServiceNotInstalled:
		{
			hr = WBEM_E_FAILED ;
		}
		break ;

		case ERROR_INVALID_HANDLE:
		{
			hr = STATUS_UNKNOWN_FAILURE ;
		}
		break ;

		case 3806:	/* special private error code which is not within includes */
		case ERROR_PATH_NOT_FOUND:
		{
			hr = WBEM_E_NOT_FOUND ;
		}
		break ;

		case ERROR_ACCESS_DENIED:
		{
			hr = WBEM_E_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			hr = WBEM_E_INVALID_PARAMETER ;
		}
		break;

		default:
		{
			hr = WBEM_E_FAILED ;
		}
		break ;
	}

	return hr ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Time handling functions
///////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ScheduledJob::GetOffsetAndSeperator( WCHAR * wcsTime, LONG * lpOffSet, WCHAR * wchSep, BOOL fSetOffset )
{
	DWORD dwHours, dwMinutes, dwSeconds, dwMicros;
	return GetTimeStringParts( wcsTime, &dwHours, &dwMinutes, &dwSeconds, &dwMicros, lpOffSet, wchSep, fSetOffset );
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Time handling functions
///////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ScheduledJob::GetTimeStringParts( WCHAR * wcsTime, DWORD * pdwHours, DWORD * pdwMinutes, DWORD * pdwSeconds,
									   DWORD * pdwMicros, LONG * lpOffSet, WCHAR * wchSep, BOOL fSetOffset)
{
	int nRes = swscanf(&wcsTime[8],L"%2d%2d%2d.%6d%c%3d",pdwHours,pdwMinutes,pdwSeconds,pdwMicros,wchSep,lpOffSet );
	if ( nRes != 6)
	{
		return FALSE;
	}
	
	if( fSetOffset && *wchSep == L'-')
	{
		*lpOffSet *= -1;
	}
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
// The StartTime parameter represents the UTC time to run the job.  
// This is of the form YYYYMMDDHHMMSS.MMMMMM(+-)OOO, 
// where YYYYMMDD must be replaced by ******** 
//			********123000.000000-420 which implies 12:30 pm PST with daylight savings time in effect
//
//	JobTime is coming in as:
//  The time is the local time at a computer on which the schedule service is running; 
//  it is measured from midnight, and is expressed in milliseconds. 
///////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ScheduledJob::FormatTimeString( CHString & chsTime, DWORD dwTime)
{
	BOOL fRc = FALSE;
    WBEMTime wt;
	SYSTEMTIME st;

	GetSystemTime( &st );
	wt = st;
	if( wt.IsOk() )
	{
		//======================================================
		//  set the first eight chars to ********
		//======================================================
		_bstr_t cbsTmp;
		LONG lOffset = 0;
		WCHAR wchSep;
		cbsTmp = wt.GetDMTF(TRUE);
		if( GetOffsetAndSeperator( cbsTmp, &lOffset, &wchSep, FALSE) )
		{
			//=========================================================
			// convert from milliseconds since midnight to DMTF
			//=========================================================
			DWORD dwSeconds = dwTime/1000;
			DWORD dwMinutes = dwSeconds / 60 ;
			DWORD dwHours  = dwMinutes / 60 ;
			DWORD dwMicros = dwTime - ( dwSeconds * 1000 );

    		chsTime.Format(L"********%02ld%02ld%02ld.%06ld%c%03ld" ,dwHours,dwMinutes-( dwHours * 60 ) , dwSeconds-( dwMinutes * 60 ),
																	dwMicros, wchSep, lOffset);
			fRc = TRUE;
		}
	}
	return fRc;
}
//////////////////////////////////////////////////////////////////////////////////////////////
//  Time needs to be converted from property string to milliseconds
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetStartTime( CInstance * pInst, LONG & lTime, int & nShift )
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	nShift = 0;
	if ( pInst->GetStatus( PROPERTY_NAME_STARTTIME, fExists , vType ) )
	{
		if ( fExists && ( vType == VT_BSTR ) )
		{
			CHString chsTimeString ;

			if ( pInst->GetCHString ( PROPERTY_NAME_STARTTIME , chsTimeString ) && ! chsTimeString.IsEmpty () )
			{
			    WBEMTime wtScheduledTime;
				_bstr_t cbstrScheduledTime, cbstrLocalTime;
				LONG lLocalOffset = 0, lScheduledOffset = 0;
				DWORD dwHours, dwMins, dwSecs, dwMicros;
				WCHAR wchSep = 0;
				dwHours = dwMins = dwSecs = dwMicros = 0;

				//================================================================
				//  Convert the incoming date to a DMTF date and break out the
				//  parts to get the milliseconds since midnight
				//================================================================
				cbstrScheduledTime = (WCHAR*) (const WCHAR*) chsTimeString;
				if( wtScheduledTime.SetDMTF( cbstrScheduledTime ) )
				{
					if( GetTimeStringParts( (WCHAR*)(const WCHAR*) cbstrScheduledTime, &dwHours, &dwMins, &dwSecs, &dwMicros, &lScheduledOffset, &wchSep, TRUE ))
					{
						//=========================================================
						// convert to milliseconds since midnight
						//=========================================================

                        lTime =  dwHours * 60 * 60;
                        lTime += dwMins * 60;
                        lTime += dwSecs;
                        lTime *= 1000;
                        lTime += dwMicros / 1000;

                        if ( lTime < MILLISECONDS_IN_A_DAY )
						{
							WBEMTime tmpTime;
							SYSTEMTIME st;
							GetSystemTime( &st );

							tmpTime = st;
							if( tmpTime.GetSYSTEMTIME(&st))
							{
								//=================================================
								//  Determine if we need to shift the days of the
								//  month and week
								//=================================================
								_bstr_t cbsTmp;
								cbsTmp = tmpTime.GetDMTF(TRUE);
								if( GetOffsetAndSeperator( cbsTmp, &lLocalOffset, &wchSep, TRUE) )
								{
									//=========================================================
									//  If these are not equal, then set flags to adjust for
									//  the day
									//=========================================================
									if( lScheduledOffset != lLocalOffset )
									{
										LONG lDelta = lLocalOffset - lScheduledOffset ;
                                        lTime = lTime + lDelta * 60 * 1000 ;

                                        if( lTime < (DWORD) 0)
										{
                                            lTime = MILLISECONDS_IN_A_DAY + lTime ;
											nShift = -1 ;
										}
										else
										{
                                            if ( lTime > MILLISECONDS_IN_A_DAY )
											{
                                                lTime = lTime - MILLISECONDS_IN_A_DAY ;
												nShift = 1;
											}
										}
									}
									hr = S_OK;
								}
							} 
						}
					}
				}
			}
		}
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  Get info from properties in instance
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetCommand( CInstance * pInst, CHString & chsCommand )
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( pInst->GetStatus( PROPERTY_NAME_COMMAND , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_BSTR ) )
		{
			if ( pInst->GetCHString ( PROPERTY_NAME_COMMAND , chsCommand ) && ! chsCommand.IsEmpty () )
			{
				hr = S_OK;
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetDaysOfMonth( CInstance * pInst, DWORD & dwDaysOfMonth, int nShift )
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( pInst->GetStatus( PROPERTY_NAME_DAYSOFMONTH , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_I4 || vType == VT_NULL ) )
		{
			if ( vType == VT_NULL )
			{
				hr = S_OK;
			}
			else
			{
				if ( pInst->GetDWORD ( PROPERTY_NAME_DAYSOFMONTH , dwDaysOfMonth ) )
				{
					if ( dwDaysOfMonth >= ( 1 << 31 ) )
					{
						hr = WBEM_E_INVALID_PARAMETER;
					}
					else
					{
						if ( nShift < 0)
						{
							if ( dwDaysOfMonth & 1 )
							{
								dwDaysOfMonth = dwDaysOfMonth & 0xFFFFFFFE ;
								dwDaysOfMonth = ( dwDaysOfMonth >> 1 ) | 0x40000000 ;
							}
							else
							{
								dwDaysOfMonth = ( dwDaysOfMonth >> 1 ) ;
							}
						}
						else if ( nShift > 0 )
						{
							if ( dwDaysOfMonth & 0x4000000 )
							{
								dwDaysOfMonth = dwDaysOfMonth & 0xBFFFFFFF ;
								dwDaysOfMonth = ( dwDaysOfMonth << 1 ) | 0x1 ;
							}
							else
							{
								dwDaysOfMonth = ( dwDaysOfMonth << 1 ) | 0x1 ;
							}
						}
					}

					hr = S_OK;
				}
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetDaysOfWeek( CInstance * pInst,	DWORD dwDaysOfMonth, DWORD & dwDaysOfWeek, int nShift )
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( pInst->GetStatus ( PROPERTY_NAME_DAYSOFWEEK , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_I4 || vType == VT_NULL ) )
		{
			if ( vType == VT_NULL )
			{
				hr = S_OK;
			}
			else
			{
				if ( pInst->GetDWORD ( PROPERTY_NAME_DAYSOFWEEK , dwDaysOfWeek) )
				{
					if ( dwDaysOfWeek >= ( 1 << 7 ) )
					{
						hr = WBEM_E_INVALID_PARAMETER;
					}
					else
					{
						if ( nShift < 0 )
						{
							if ( dwDaysOfWeek & 1 )
							{
								dwDaysOfMonth = dwDaysOfMonth & 0xBF ;
								dwDaysOfWeek = ( dwDaysOfWeek >> 1 ) | 0x40 ;
							}
							else
							{
								dwDaysOfWeek = ( dwDaysOfWeek >> 1 ) ;
							}
						}
						else if ( nShift > 0 )
						{
							if ( dwDaysOfWeek & 0x40 )
							{
								dwDaysOfMonth = dwDaysOfMonth & 0xFE ;
								dwDaysOfWeek = ( dwDaysOfWeek << 1 ) | 0x1 ;
							}
							else
							{
								dwDaysOfWeek = ( dwDaysOfWeek << 1 ) ;
							}
						}

						hr = S_OK;
					}
				}
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetInteractiveWithDeskTop(CInstance * pInst, bool & fInteract)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( pInst->GetStatus ( PROPERTY_NAME_INTERACTWITHDESKTOP , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_BOOL || vType == VT_NULL ) )
		{
			if ( vType != VT_NULL )
			{
				if ( pInst->Getbool ( PROPERTY_NAME_INTERACTWITHDESKTOP , fInteract ) )
				{
					hr = S_OK;
				}
			}
			else
			{
				hr = S_OK;
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetRunRepeatedly(CInstance * pInst, bool & fRunRepeatedly )
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( pInst->GetStatus ( PROPERTY_NAME_RUNREPEATEDLY , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_BOOL || vType == VT_NULL ) )
		{
			if ( vType != VT_NULL )
			{
				if ( pInst->Getbool ( PROPERTY_NAME_RUNREPEATEDLY , fRunRepeatedly ) )
				{
					hr = S_OK;
				}
			}
			else
			{
				hr = S_OK;
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::CreateJob( CInstance * pInst, DWORD &dwStatus, DWORD &a_JobId )
{
#ifdef WIN9XONLY
    return WBEM_E_FAILED;
#endif

#ifdef NTONLY
	
	dwStatus = STATUS_INVALID_PARAMETER ;
	CHString chsCommand;

	HRESULT hr = GetCommand(pInst, chsCommand);
	if( S_OK == hr )
	{
		int nShift = 0;
        LONG lTime = 0;
        hr = GetStartTime( pInst, lTime, nShift );
		if( S_OK == hr )
		{
			DWORD dwDaysOfMonth = 0;
			hr = GetDaysOfMonth( pInst, dwDaysOfMonth, nShift );
			if( S_OK == hr )
			{
				DWORD dwDaysOfWeek = 0;
				hr = GetDaysOfWeek( pInst, dwDaysOfMonth, dwDaysOfWeek, nShift );
				if( S_OK == hr )
				{
					bool fInteract = TRUE;
					hr = GetInteractiveWithDeskTop(pInst, fInteract);
					if( S_OK == hr )
					{
						bool fRunRepeatedly = FALSE;
						hr = GetRunRepeatedly( pInst, fRunRepeatedly );
						if( S_OK == hr )
						{
							AT_INFO AtInfo ;
							_bstr_t cbstrCommand;

							cbstrCommand = (WCHAR*)(const WCHAR*) chsCommand;

							AtInfo.Command = cbstrCommand;
                                                        AtInfo.JobTime = lTime ;
							AtInfo.DaysOfMonth = dwDaysOfMonth ;
							AtInfo.DaysOfWeek = dwDaysOfWeek ;
							AtInfo.Flags = 0;

							if ( fRunRepeatedly )
							{
								AtInfo.Flags = AtInfo.Flags | JOB_RUN_PERIODICALLY ;
							}

							if ( !fInteract )
							{
								AtInfo.Flags = AtInfo.Flags | JOB_NONINTERACTIVE ;
							}

							CNetAPI32 t_NetAPI ;
							if( ( hr = t_NetAPI.Init() ) == ERROR_SUCCESS )
							{
								NET_API_STATUS dwJobStatus = t_NetAPI.NetScheduleJobAdd(NULL,(LPBYTE)&AtInfo,&a_JobId);

								if ( dwJobStatus == NERR_Success )
								{
									dwStatus = S_OK;
								}
								else
								{
									dwStatus = GetScheduledJobErrorCode ( dwJobStatus ) ;
								}
							}
						}
					}
				}
			}
		}
	}
	return hr;
#endif
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob :: ExecCreate (const CInstance& a_Instance,CInstance *pInst,CInstance *a_OutParams,long lFlags)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER ;

	if ( pInst && a_OutParams )
	{
		DWORD t_JobId = 0 ;
		DWORD dwStatus = 0 ;

		hr = CreateJob (pInst ,dwStatus ,t_JobId	) ;
		if ( SUCCEEDED ( hr ) )
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;

			if ( dwStatus == STATUS_SUCCESS )
			{
				a_OutParams->SetDWORD ( PROPERTY_NAME_JOBID , t_JobId ) ;
			}
 		}
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob :: DeleteJob (const CInstance& a_Instance,DWORD &dwStatus )
{
#ifdef WIN9XONLY
    return WBEM_E_FAILED;
#endif

#ifdef NTONLY
	HRESULT hr = WBEM_E_PROVIDER_FAILURE;
	bool fExists = FALSE;
	VARTYPE vType ;
	DWORD t_JobId = 0 ;

	dwStatus = STATUS_INVALID_PARAMETER ;
	if ( a_Instance.GetStatus ( PROPERTY_NAME_JOBID , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_I4 ) )
		{
			if ( a_Instance.GetDWORD ( PROPERTY_NAME_JOBID , t_JobId ) )
			{
				CNetAPI32 t_NetAPI ;

				if( ( hr = t_NetAPI.Init() ) == ERROR_SUCCESS )
				{
					NET_API_STATUS t_JobStatus = t_NetAPI.NetScheduleJobDel (NULL ,	t_JobId ,t_JobId) ;

					if ( t_JobStatus != NERR_Success )
					{
						dwStatus = GetScheduledJobErrorCode ( t_JobStatus ) ;
					}
					else
					{
						dwStatus = STATUS_SUCCESS;
					}
				}
			}
		}
	}

	return hr ;
#endif
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob :: ExecDelete (const CInstance& a_Instance,CInstance *pInst,CInstance *a_OutParams,long lFlags)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER ;

	if ( a_OutParams )
	{
		DWORD dwStatus = 0 ;

		hr = DeleteJob (a_Instance , dwStatus) ;

		if ( SUCCEEDED ( hr ) )
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\schedjob.h ===
//=================================================================

//

// schedjob.h -- scheduled job provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    07/11/98    stevm        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_SCHEDULEDJOB					L"Win32_ScheduledJob"

#define PROPERTY_NAME_JOBID					L"JobId"
#define PROPERTY_NAME_STARTTIME				L"StartTime"
#define PROPERTY_NAME_COMMAND				L"Command"
#define PROPERTY_NAME_RUNREPEATEDLY			L"RunRepeatedly"
#define PROPERTY_NAME_INTERACTWITHDESKTOP	L"InteractWithDesktop"
#define PROPERTY_NAME_DAYSOFWEEK			L"DaysOfWeek"
#define PROPERTY_NAME_DAYSOFMONTH			L"DaysOfMonth"
#define PROPERTY_NAME_JOBSTATUS				L"JobStatus"
#define PROPERTY_NAME_RUNSTODAY				L"RunsToday"

#define PROPERTY_VALUE_JOBSTATUS_SUCCESS L"Success"
#define PROPERTY_VALUE_JOBSTATUS_FAILURE L"Failure"

#define METHOD_NAME_CREATE				L"Create"
#define METHOD_NAME_DELETE				L"Delete"

#define METHOD_ARG_NAME_RETURNVALUE					L"ReturnValue"

#define PROPERTY_VALUE_MIN_DAYOFWEEK 0
#define PROPERTY_VALUE_MAX_DAYOFWEEK 6

#define PROPERTY_VALUE_MIN_DAYOFMONTH 0
#define PROPERTY_VALUE_MAX_DAYOFMONTH 30


#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS							0
#endif

#undef STATUS_NOT_SUPPORTED
#define STATUS_NOT_SUPPORTED					1

// Control
#undef STATUS_ACCESS_DENIED					
#define STATUS_ACCESS_DENIED					2
#define STATUS_UNKNOWN_FAILURE					8

// Start
#define STATUS_PATH_NOT_FOUND					9
#undef STATUS_INVALID_PARAMETER				
#define STATUS_INVALID_PARAMETER				21
#define STATUS_SERVICE_NOT_STARTED				22


#define MILLISECONDS_IN_A_DAY 86400000
#define DECPOS 14
#define SGNPOS 21
#define DMTFLEN 25


class ScheduledJob : public Provider
{
public:

	// Constructor/destructor
    //=======================

	ScheduledJob (

		LPCWSTR a_Name,
		LPCWSTR a_Namespace
	) ;

    ~ScheduledJob () ;

	// Funcitons provide properties with current values
    //=================================================

	HRESULT EnumerateInstances (

		MethodContext *a_MethodContext,
		long a_Flags = 0L
	) ;

	HRESULT GetObject (

		CInstance *a_Instance,
		long a_Flags = 0L
	) ;

	HRESULT DeleteInstance (

		const CInstance& a_Instance,
		long a_Flags = 0L
	) ;

	HRESULT ExecMethod (

		const CInstance &a_Instance,
		const BSTR a_MethodName,
		CInstance *a_InParams,
		CInstance *a_OutParams,
		long a_Flags = 0L
	) ;

private:

	DWORD m_Platform ;

        HRESULT GetStartTime( CInstance * pInst, LONG & lTime, int & fShift );
	BOOL FormatTimeString( CHString & chsTime, DWORD dwJobTime);
	BOOL GetOffsetAndSeperator( WCHAR * wcsTime, LONG * lpOffSet, WCHAR * wchSep, BOOL fSetOffset );
	BOOL GetTimeStringParts( WCHAR * wcsTime, DWORD * pdwHours, DWORD * pdwMinutes, DWORD * pdwSeconds,
		 				   DWORD * pdwMicros, LONG * lpOffSet, WCHAR * wchSep, BOOL fSetOffset);

	HRESULT GetCommand( CInstance * pInst, CHString & chsCommand );
	HRESULT GetDaysOfMonth( CInstance * pInst, DWORD & dwDaysOfMonth, int nShift);
	HRESULT GetDaysOfWeek( CInstance * pInst,	DWORD dwDaysOfMonth, DWORD & dwDaysOfWeek, int nShift );
	HRESULT GetInteractiveWithDeskTop(CInstance * pInst, bool & fInteract);
	HRESULT GetRunRepeatedly(CInstance * pInst, bool & fRunRepeatedly );

	DWORD GetScheduledJobErrorCode ( NET_API_STATUS a_Status ) ;

	HRESULT GetScheduledJobResultCode ( NET_API_STATUS a_Status ) ;

	HRESULT GetJobObject (
		
		CInstance *a_Instance,
		DWORD a_JobId
	) ;

	HRESULT InstantiateJob (

		MethodContext *a_MethodContext,
		long a_Flags /*= 0L*/ ,
		AT_ENUM *a_Job
	) ;

	HRESULT EnumerateJobs (

		MethodContext *a_MethodContext,
		long a_Flags /*= 0L*/
	) ;

	HRESULT CreateJob (

		CInstance *a_InParams,
		DWORD &a_Status ,
		DWORD &a_JobId
	) ;

	HRESULT DeleteJob (

		const CInstance& a_Instance,
		DWORD &a_Status
	) ;

	HRESULT ExecCreate (

		const CInstance& a_Instance,
		CInstance *a_InParams,
		CInstance *a_OutParams,
		long lFlags
	) ;

	HRESULT ExecDelete (

		const CInstance& a_Instance,
		CInstance *a_InParams,
		CInstance *a_OutParams,
		long lFlags
	) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\scsi.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  serialport.h
//
//  Purpose: scsi controller property set provider
//
//***************************************************************************

#ifndef _SCSI_H
#define _SCSI_H

//==================================
#define  PROPSET_NAME_SCSICONTROLLER L"Win32_SCSIController"
//#define  PROPSET_UUID_SCSIPORTS L"{14c7dd80-09a2-11cf-8d6f-00aa004bd99e}"

//==========================================================
// In WinNT the SCSI ports are enumerated under
// this key under HKEY_LOCAL_MACHINE
//==========================================================
#define WINNT_REG_SCSIPORT_KEY L"Hardware\\DeviceMap\\Scsi"
#define WIN95_REG_SCSIPORT_KEY L"ENUM\\Scsi"


#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_AVAILABILITY			0x00000001
#define SPECIAL_PROPS_STATUS				0x00000002
#define SPECIAL_PROPS_DEVICEID				0x00000004
#define SPECIAL_PROPS_CREATIONNAME			0x00000008
#define SPECIAL_PROPS_SYSTEMNAME			0x00000010
#define SPECIAL_PROPS_DESCRIPTION			0x00000020
#define SPECIAL_PROPS_CAPTION				0x00000040
#define SPECIAL_PROPS_NAME					0x00000080
#define SPECIAL_PROPS_MANUFACTURER			0x00000100
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000200
#define SPECIAL_PROPS_DRIVE					0x00000400
#define SPECIAL_PROPS_ID					0x00000800
#define SPECIAL_PROPS_CAPABILITY			0x00001000
#define SPECIAL_PROPS_PNPDEVICEID			0x00002000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00004000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x00008000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x00010000
#define SPECIAL_PROPS_HWREVISION			0x00020000
#define SPECIAL_PROPS_MAXIMUMLOGICALUNIT	0x00040000
#define SPECIAL_PROPS_STATUSINFO			0x00080000
#define SPECIAL_PROPS_DRIVERNAME            0x00100000


#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
                                    SPECIAL_PROPS_DRIVERNAME | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_SCSI				( SPECIAL_PROPS_HWREVISION | \
									SPECIAL_PROPS_MAXIMUMLOGICALUNIT )


#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_SCSI )

#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000

#if ( NTONLY >= 5 || defined(WIN9XONLY) )	

	#include "LPVParams.h"

	class CWin32_ScsiController;

	class W2K_SCSI_LPVParms : public CLPVParams
	{
	public:
		W2K_SCSI_LPVParms() {}
		W2K_SCSI_LPVParms(CInstance* pInstance, 
						  CConfigMgrDevice* pDevice,
						  CHString& chstrDeviceName,
						  TCHAR* tstrDosDeviceNameList,
                          DWORD dwWhichInstance,
						  UINT64 ui64SpecifiedProperties);
		~W2K_SCSI_LPVParms() {}
		CHString m_chstrDeviceName;
		TCHAR* m_tstrDosDeviceNameList;
		UINT64 m_ui64SpecifiedProperties;
        DWORD m_dwWhichInstance;

	};

	inline W2K_SCSI_LPVParms::W2K_SCSI_LPVParms(CInstance* pInstance, 
						  CConfigMgrDevice* pDevice,
						  CHString& chstrDeviceName,
						  TCHAR* tstrDosDeviceNameList,
                          DWORD dwWhichInstance,
						  UINT64 ui64SpecifiedProperties = SPECIAL_PROPS_ALL_REQUIRED) 
	:  CLPVParams(pInstance, pDevice, ui64SpecifiedProperties),
	   m_chstrDeviceName(chstrDeviceName),
	   m_tstrDosDeviceNameList(tstrDosDeviceNameList),
	   m_ui64SpecifiedProperties(ui64SpecifiedProperties),
       m_dwWhichInstance(dwWhichInstance)
	{
	}

#endif

// PROPERTY SET
//=============
class CWin32_ScsiController: virtual public Provider
{
    private:
      
    DWORD GetBitmap(CFrameworkQuery &a_Query);
	#if ( defined(WIN9XONLY) || NTONLY == 4 )	
	
		HRESULT OpenSCSIKey(CRegistry&	PrimaryReg, LPCTSTR szKey ) ;
		BOOL SetDateFromFileName(LPCTSTR szFileName,CInstance *& pInstance);


		#ifdef WIN9XONLY
			// Win95 Private
			HRESULT RefreshWin95Instance(CInstance* pInstance);
			HRESULT EnumerateWin95Instances(MethodContext* pMethodContext, UINT64 Properties);

		#endif

			// Winnt 
		#if NTONLY == 4
            typedef struct 
            {
                CRegistry *PrimaryReg;
                DWORD dwWhichInstance;
                CInstance* pInstance;
            } stValues;

			HRESULT RefreshNTInstance(CInstance* pInstance);
			HRESULT EnumerateNTInstances(MethodContext* pMethodContext);
			void GetNTCapabilities(CInstance* pInstance, DWORD dwWhichInstance);
			VOID SetStatusAndAvailabilityNT(CHString& chstrDeviceID, CInstance* pInstance);
		#endif
	
	#endif

	protected:

		virtual bool IsOneOfMe(void* pvData);

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			UINT64 a_SpecifiedProperties = SPECIAL_PROPS_ALL_REQUIRED
		) ;


        virtual HRESULT LoadPropertyValues(void* pvData);

#if ( NTONLY >= 5 || defined(WIN9XONLY) )	
        // Utility function(s)
        //====================
        virtual bool ShouldBaseCommit(void* pvData);
#endif

	#if NTONLY >= 5
        CRITICAL_SECTION m_CriticalSection ;

		HRESULT LoadConfigManagerPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			UINT64 a_SpecifiedProperties
		) ;

		HRESULT GetDeviceInformation ( 

			CInstance *a_Instance ,
			CConfigMgrDevice *a_Device , 
			CHString a_DeviceName , 
			CHString &a_DosDeviceName ,
			const TCHAR *a_DosDeviceNameList ,
			UINT64 a_SpecifiedProperties
		) ;

		HRESULT LoadMediaPropertyValues (	

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const CHString &a_DosDeviceName , 
			UINT64 a_SpecifiedProperties 
		) ;

	#endif

public:

        // Constructor/destructor
        //=======================

        CWin32_ScsiController (LPCWSTR a_Name, LPCWSTR a_Namespace ) ;
       ~CWin32_ScsiController () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject ( CInstance *a_Instance, long a_Flags, CFrameworkQuery &a_Query );

        HRESULT EnumerateInstances ( 

			MethodContext *a_MethodContext, 
			long a_Flags = 0L 
		) ;

 	
	#if NTONLY >= 5

		HRESULT ExecQuery ( 

			MethodContext *a_MethodContext, 
			CFrameworkQuery &a_Query, 
			long a_Flags = 0L
		) ;
	
	#else	
		WORD LookupProtocol( CHString a_sSeek ) ;
	#endif
};

#if ( NTONLY >= 5 || defined(WIN9XONLY) )	
	// This is the base; it should always commit in the base.
	inline bool CWin32_ScsiController::ShouldBaseCommit(void* pvData) { return true; }
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\scsi.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  scsi.cpp
//
//  Purpose: scsi controller property set provider
//
//***************************************************************************

#include "precomp.h"
#include <CRegCls.h>
#include <devioctl.h>
#include <NTDDSCSI.h>
#include "poormansresource.h"
#include "resourcedesc.h"
#include "cfgmgrdevice.h"

#include "Scsi.h"
#include "wnaspi32.h"

typedef  DWORD (__cdecl * ASPIInit)(VOID) ;
typedef  DWORD (__cdecl *ASPIGet)(LPSRB);


////////////////////////////////////////////////////////////////////

CWin32_ScsiController MySCSIPortSet(PROPSET_NAME_SCSICONTROLLER, IDS_CimWin32Namespace);

////////////////////////////////////////////////////////////////////
// Function:  BOOL CWin32_ScsiController::CWin32_ScsiController
// Description: CONSTRUCTOR
// Arguments: None
// Returns:   Nothing
// Inputs:
// Outputs:
// Caveats:
// Raid:
////////////////////////////////////////////////////////////////////
CWin32_ScsiController::CWin32_ScsiController( LPCWSTR a_name, LPCWSTR a_pszNamespace )
: Provider( a_name, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::~CWin32_ScsiController
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_ScsiController::~CWin32_ScsiController()
{
}

HRESULT CWin32_ScsiController::Enumerate (
    MethodContext *a_MethodContext ,
	long a_Flags ,
	UINT64 a_SpecifiedProperties
	)
{
	HRESULT t_hResult;

	#ifdef NTONLY
		t_hResult = EnumerateNTInstances( a_MethodContext ) ;
	#endif

	#ifdef WIN9XONLY
	    t_hResult = EnumerateWin95Instances( a_MethodContext, a_SpecifiedProperties ) ;
	#endif

	return t_hResult;
}

HRESULT CWin32_ScsiController::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
    return Enumerate(a_pMethodContext, a_lFlags, SPECIAL_PROPS_ALL_REQUIRED);
}

#ifdef NTONLY
HRESULT CWin32_ScsiController::EnumerateNTInstances( MethodContext *a_pMethodContext )
{
	CRegistry	t_PrimaryReg ;
 	DWORD		t_dwSCSIPorts ;

	HRESULT t_hResult =  OpenSCSIKey( t_PrimaryReg, WINNT_REG_SCSIPORT_KEY ) ;

	if( SUCCEEDED( t_hResult ) )
	{
		t_dwSCSIPorts = t_PrimaryReg.GetCurrentSubKeyCount() ;

		// smart ptr
		CInstancePtr t_pInst;

		for ( DWORD t_i = 0; ( t_i < t_dwSCSIPorts ) && SUCCEEDED( t_hResult ); t_i++ )
		{
			t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

			if ( NULL != t_pInst )
            {
                struct stValues stLoadValues = {&t_PrimaryReg, t_i, t_pInst};
                if ( SUCCEEDED(LoadPropertyValues( &stLoadValues) ) )
				{
					t_hResult = t_pInst->Commit();
				}
            }
            else
			{
                t_hResult = WBEM_E_FAILED ;
				break ;
			}

			t_PrimaryReg.NextSubKey();
		}
	}

	return t_hResult ;
}
#endif

#ifdef WIN9XONLY
HRESULT CWin32_ScsiController::EnumerateWin95Instances(MethodContext* a_pMethodContext, UINT64 a_SpecifiedProperties)
{
	HRESULT			t_hResult = WBEM_S_NO_ERROR ;
    CConfigManager cfgManager;
	CDeviceCollection t_DeviceList ;

	// While it might be more performant to use FilterByGuid, it appears that at least some
	// 95 boxes will report InfraRed info if we do it this way.
	if ( cfgManager.GetDeviceListFilterByClass ( t_DeviceList, L"SCSIAdapter" ) )
	{
		REFPTR_POSITION t_Position ;
		if( t_DeviceList.BeginEnum ( t_Position ) )
		{
			// smart ptrs
			CConfigMgrDevicePtr t_pDevice;
			CInstancePtr		t_pInst;
            DWORD t_i = 0;

			t_hResult = WBEM_S_NO_ERROR ;

			// Walk the list
            for (t_pDevice.Attach(t_DeviceList.GetNext ( t_Position ));
                 SUCCEEDED( t_hResult ) && (t_pDevice != NULL);
                 t_pDevice.Attach(t_DeviceList.GetNext ( t_Position )))
			{
				// Now to find out if this is the scsi controller
				if(IsOneOfMe( t_pDevice ) )
				{
					t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

					CHString t_PNPId;
                    t_pDevice->GetDeviceID(t_PNPId);

					if( SUCCEEDED( t_hResult =
						LoadPropertyValues(	&W2K_SCSI_LPVParms(	t_pInst,
                                                                t_pDevice,
                                                                t_PNPId ,
                                                                NULL,
                                                                t_i,
                                                                a_SpecifiedProperties))))
        			{

			            // Derived classes (like CW32SCSICntrlDev) may commit as result of call to LoadPropertyValues,
			            // so check if we should -> only do so if we are of this class's type.
			            if( ShouldBaseCommit( NULL ) )
			            {
    				        t_hResult = t_pInst->Commit();
                        }
                    }

                    t_i++;
                }
			}
		}
	}

	return t_hResult ;
}
#endif

////////////////////////////////////////////////////////////////////
// Function:
// Description:
// Arguments: None
// Returns:   HRESULT
// Inputs:
// Outputs:
// Caveats:
// Raid:
////////////////////////////////////////////////////////////////////
HRESULT CWin32_ScsiController::GetObject(CInstance *a_pInst, long a_lFlags, CFrameworkQuery& pQuery)
{
	HRESULT		t_hResult ;
	CHString	t_oldKey,
				t_newKey ;

	a_pInst->GetCHString( IDS_DeviceID, t_oldKey ) ;

	#ifdef NTONLY
		t_hResult = RefreshNTInstance( a_pInst ) ;
	#endif

	#ifdef WIN9XONLY
	    t_hResult = RefreshWin95Instance( a_pInst ) ;
	#endif

	if ( SUCCEEDED( t_hResult ) )
	{
		a_pInst->GetCHString( IDS_DeviceID, t_newKey ) ;

		if ( t_newKey.CompareNoCase( t_oldKey ) != 0 )
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}

	return t_hResult ;

}
////////////////////////////////////////////////////////////////////
//	Function:
//		BOOL CWin32_ScsiController::RefreshInstanceWinNTScsi
//
// 	Description:
// 		The method assigns values to the properties instance of
// 		a class when the port name read from the registry is the
// 		same as the one provided by the framework.
//
// 	Returns:
// 		Nothing
//
////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT CWin32_ScsiController::RefreshWin95Instance( CInstance *a_pInst )
{
	HRESULT			t_hResult = WBEM_E_NOT_FOUND ;
    CConfigManager cfgManager;
	CDeviceCollection t_DeviceList ;
    CHString sLookingFor;

    a_pInst->GetCHString(IDS_DeviceID, sLookingFor);

	// Using LocateDevice would clearly be much faster... If we DIDN'T need
    // to populate the IDS_Index property.
	if ( cfgManager.GetDeviceListFilterByClass ( t_DeviceList, L"SCSIAdapter" ) )
	{
		REFPTR_POSITION t_Position ;
		if( t_DeviceList.BeginEnum ( t_Position ) )
		{
			// smart ptrs
			CConfigMgrDevicePtr t_pDevice;
            CHString t_PNPId;
            DWORD t_i = 0;

			// Walk the list
            for (t_pDevice.Attach(t_DeviceList.GetNext ( t_Position ));
                 (t_pDevice != NULL);
                 t_pDevice.Attach(t_DeviceList.GetNext ( t_Position )))
			{
				// Now to find out if this is the scsi controller
				if(IsOneOfMe( t_pDevice ) )
				{
                    t_pDevice->GetDeviceID(t_PNPId);

                    if (t_PNPId.CompareNoCase(sLookingFor) == 0)
                    {
					    t_hResult =
						    LoadPropertyValues(	&W2K_SCSI_LPVParms(	a_pInst,
                                                                    t_pDevice,
                                                                    t_PNPId ,
                                                                    NULL,
                                                                    t_i,
                                                                    SPECIAL_PROPS_ALL_REQUIRED));
                        break;
                    }

                    t_i++;
                }
			}
		}
	}

	return t_hResult ;
}
#endif
////////////////////////////////////////////////////////////////////
//	Function:
//		BOOL CWin32_ScsiController::RefreshInstanceWinNTScsi
//
// 	Description:
// 		The method assigns values to the properties instance of
// 		a class when the port name read from the registry is the
// 		same as the one provided by the framework.
//
// 	Returns:
// 		Nothing
//
////////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT CWin32_ScsiController::RefreshNTInstance( CInstance *a_pInst )
{
	HRESULT			t_hResult = WBEM_E_NOT_FOUND;
	CRegistry		t_PrimaryReg ;
	DWORD			t_dwWhichInstance ;
	CHString		t_deviceID;

	if ( a_pInst->GetCHString( IDS_DeviceID, t_deviceID ) )
	{
		if ( SUCCEEDED( t_hResult = OpenSCSIKey( t_PrimaryReg, WINNT_REG_SCSIPORT_KEY ) ) )
		{
			DWORD t_dwSCSIPorts = t_PrimaryReg.GetCurrentSubKeyCount() ;

            t_dwWhichInstance = _ttoi( (LPCTSTR) t_deviceID ) ;

			TCHAR t_szBack[ MAXITOA ] ;

            t_hResult = WBEM_E_NOT_FOUND ;

            if ( t_deviceID == _itot( t_dwWhichInstance, t_szBack, 10 ) )
            {
			    for ( DWORD t_i = 0; t_i < t_dwSCSIPorts; t_i++ )
			    {
				    // this is a hack, LoadPropertyValues does not really pay attention to the dwWhichInstance parameter
				    // it depends upon the caller setting the registry at the proper key
                    struct stValues stLoadValues = {&t_PrimaryReg, t_i, a_pInst};
                    if ( ( t_i == t_dwWhichInstance ) && SUCCEEDED(t_hResult = LoadPropertyValues( &stLoadValues ) ) )
				    {
					    break ;
                    }

					t_PrimaryReg.NextSubKey() ;
                }
            }
		}
	}
	else
	{
		t_hResult = WBEM_E_INVALID_PARAMETER ;
	}

    return t_hResult;

}
#endif

///////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT CWin32_ScsiController::LoadPropertyValues( void* pvData )
{
	// Unpack and confirm our parameters...
    W2K_SCSI_LPVParms* pData = (W2K_SCSI_LPVParms*)pvData;

    CInstance* a_Instance = (pData->m_pInstance);  // This instance released by caller
    CConfigMgrDevice* a_Device = (pData->m_pDevice);
    CHString a_DeviceName = (pData->m_chstrDeviceName);

//    TCHAR* a_DosDeviceNameList = (pData->m_tstrDosDeviceNameList);
    UINT64 a_SpecifiedProperties = (pData->m_ui64SpecifiedProperties);
    DWORD a_dwWhichInstance = (pData->m_dwWhichInstance);

    if(a_Instance == NULL || a_Device == NULL) return WBEM_E_PROVIDER_FAILURE;

    CHString    sRegKeyName;
	CRegistry	t_TmpReg ;
    HRESULT     t_hr = WBEM_E_NOT_FOUND;

	SetCreationClassName( a_Instance ) ;

	a_Instance->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;
   	a_Instance->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;

	// Get the key name to the next set of Adapter Settings
	if (	a_Device->GetRegistryKeyName(sRegKeyName) &&
			ERROR_SUCCESS == t_TmpReg.Open( HKEY_LOCAL_MACHINE, sRegKeyName, KEY_READ ) )
	{
        CHString	t_TempString;

		a_Instance->SetDWORD( IDS_Index, a_dwWhichInstance ) ;

		//=======================================================
		//  Get the device id from the registry key name
		//	Enum\
		//=======================================================

		// This is in effect the PNP Device ID as recognized by those in the know.
		a_Instance->SetCHString( IDS_DeviceID, a_DeviceName ) ;

		a_Instance->SetCHString( IDS_PNPDeviceID, a_DeviceName ) ;

		a_Instance->SetWBEMINT16( IDS_ProtocolSupported, LookupProtocol( a_DeviceName.SpanExcluding( L"\\" ) ) ) ;
		a_Instance->SetCHString( IDS_Name, a_DeviceName ) ;

		SetConfigMgrProperties( a_Device, a_Instance ) ;

		a_Device->GetStatus( t_TempString ) ;
		a_Instance->SetCHString( IDS_Status, t_TempString ) ;

        if ( t_TempString == IDS_STATUS_OK )
		{
   			a_Instance->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
			a_Instance->SetWBEMINT16(IDS_Availability, 3 ) ;
        }
		else if ( t_TempString == IDS_STATUS_Degraded )
		{
   			a_Instance->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
			a_Instance->SetWBEMINT16(IDS_Availability, 10 ) ;
        }
		else if ( t_TempString == IDS_STATUS_Error )
		{
   			a_Instance->SetWBEMINT16( IDS_StatusInfo, 4 ) ;
			a_Instance->SetWBEMINT16(IDS_Availability, 4 ) ;
        }
		else
		{
   			a_Instance->SetWBEMINT16( IDS_StatusInfo, 2 ) ;
			a_Instance->SetWBEMINT16(IDS_Availability, 2 ) ;
        }

		// Load values from the subkey.  These pertain to various properties in the
		// provider.
		if ( a_Device->GetDeviceDesc ( t_TempString ) )
		{
			a_Instance->SetCHString( IDS_Caption, t_TempString ) ;
			a_Instance->SetCHString( IDS_Description, t_TempString ) ;
		}

		// Manufacturer
		if ( a_Device->GetMfg ( t_TempString ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_TempString ) ;
		}

		DWORD t_TempDWORD ;

		// per KB Q98272, defualt value is eight
		if ( ERROR_SUCCESS == t_TmpReg.GetCurrentKeyValue( L"MaximumLogicalUnit", t_TempDWORD) )
		{
			a_Instance->SetDWORD( IDS_MaxNumberControlled, t_TempDWORD ) ;
		}
		else
		{
			a_Instance->SetDWORD( IDS_MaxNumberControlled, 8 ) ;
		}

		// Hardware Version
		if ( ERROR_SUCCESS == t_TmpReg.GetCurrentKeyValue( L"HWRevision", t_TempString ) )
		{
			a_Instance->SetCHString( IDS_HardwareVersion, t_TempString ) ;
		}

        if ( a_Device->GetDriver( t_TempString ) )
		{
            CHString t_chsSubKey;
			t_chsSubKey = L"System\\CurrentControlSet\\Services\\Class\\" + t_TempString ;

			if( ERROR_SUCCESS == t_TmpReg.Open( HKEY_LOCAL_MACHINE, t_chsSubKey, KEY_READ ) )
			{
				if ( ERROR_SUCCESS == t_TmpReg.GetCurrentKeyValue( L"PortDriver", t_TempString ) )
				{
					a_Instance->SetCHString( IDS_DriverName, t_TempString ) ;
				}

				if ( ERROR_SUCCESS == t_TmpReg.GetCurrentKeyValue( L"DriverDate", t_TempString ) )
				{
					struct tm t_tmDate ;

					memset( &t_tmDate, 0, sizeof( t_tmDate ) ) ;

					swscanf( t_TempString,L"%d-%d-%d",
								&t_tmDate.tm_mon,
								&t_tmDate.tm_mday,
								&t_tmDate.tm_year ) ;

					t_tmDate.tm_year = t_tmDate.tm_year - 1900 ;
					t_tmDate.tm_mon-- ;

					a_Instance->SetDateTime( IDS_InstallDate, (const struct tm) t_tmDate ) ;
				}
			}
		}

		t_hr = WBEM_S_NO_ERROR;
	}

    return t_hr ;
}
#endif

////////////////////////////////////////////////////////////////////
// LoadPropertyValues does not really pay attention to the dwWhichInstance parameter
// it depends upon the caller opening the registry at the proper key
#ifdef NTONLY
HRESULT CWin32_ScsiController::LoadPropertyValues( void* pvData )
{
    struct stValues *pstValues = (struct stValues *)pvData;

    CHString	t_chsPortName ;
    CHString	t_chsSubKey ;
    CHString	t_TempString ;
	DWORD		t_TempDWORD ;
	CRegistry	t_TmpReg ;
    HRESULT     t_hr = WBEM_E_NOT_FOUND;

	SetCreationClassName( pstValues->pInstance ) ;

	pstValues->pInstance->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;
  	pstValues->pInstance->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;

    if( ERROR_SUCCESS != pstValues->PrimaryReg->GetCurrentSubKeyName( t_chsPortName ) )
    {
        return FALSE ;
    }

	//==============================================================
    // Build up the key name & open it to get the values
	//==============================================================
    t_chsSubKey = WINNT_REG_SCSIPORT_KEY + (CHString) _T("\\") + t_chsPortName ;

	if( t_TmpReg.Open( HKEY_LOCAL_MACHINE, t_chsSubKey, KEY_READ ) == ERROR_SUCCESS )
    {
		pstValues->pInstance->SetDWORD( IDS_Index, pstValues->dwWhichInstance ) ;

		// per KB Q98272, defualt value is eight
		if ( ERROR_SUCCESS == t_TmpReg.GetCurrentKeyValue( _T("MaximumLogicalUnit"), t_TempDWORD ) )
		{
			pstValues->pInstance->SetDWORD( IDS_MaxNumberControlled, t_TempDWORD ) ;
		}
		else
        {
			pstValues->pInstance->SetDWORD( IDS_MaxNumberControlled, 8 );
        }

		// Now, get the name of the service to go after
		if ( ERROR_SUCCESS == t_TmpReg.GetCurrentKeyValue( _T("Driver"), t_TempString ) )
        {
			pstValues->pInstance->SetCHString( IDS_Name, t_TempString ) ;

			// NT Device ID == Index#
			CHString t_deviceID;
			t_deviceID.Format( _T("%u"), pstValues->dwWhichInstance ) ;
			pstValues->pInstance->SetCHString( IDS_DeviceID, t_deviceID ) ;

			// find driver in registry
			CHString	t_chsKey ;
            CHString	t_chsTmp ;
			CRegistry	t_Reg ;

			t_chsKey = _T("SYSTEM\\CurrentControlSet\\Services\\") + t_TempString;
			if (ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ) )
            {
				if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("ImagePath"), t_chsTmp) )
                {
					pstValues->pInstance->SetCHString( IDS_DriverName, t_chsTmp ) ;
				}

				if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("Group"), t_chsTmp ) )
                {
					pstValues->pInstance->SetCHString( IDS_Caption, t_chsTmp ) ;
				}

				t_chsKey += _T("\\Enum") ;

				if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
                {
					//  Get the key to go get more info
					if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("0"), t_chsTmp ) )
                    {
						// At this point, chsTmp will contain the Device ID of the
						// "controller".
                        SetStatusAndAvailabilityNT( t_chsTmp, pstValues->pInstance ) ;
					}
				}
			}
		}

#if 0
		// Finally, remove spaces from the port name, and stick that value in DeviceMap,
		// This will yield values like: SCSIPort0, etc.

		t_TempString.Empty();

		TCHAR *t_CharacterString = t_chsPortName.GetBuffer( 0 ) ;
		LONG t_Characters = _tcsclen ( t_CharacterString ) ;
		LONG t_CharacterIndex = 0 ;

		for(INT	t_nCtr = 0; t_nCtr < t_Characters ; t_nCtr++ )
        {
			LONG t_CharacterLength = _tclen ( ( LPCTSTR ) t_CharacterString [ t_CharacterIndex ] ) ;

			if (t_CharacterString [ t_CharacterIndex ]  !=  _T(' ') )
            {
				char t_Char [ 3 ] ;

				t_Char [ 0 ] = t_CharacterString [ t_CharacterIndex ] ;
				t_Char [ 1 ] = 0 ;
				t_Char [ 2 ] = 0 ;

				if ( t_CharacterLength == 2 )
				{
					t_Char [ 1 ] = t_CharacterString [ t_CharacterIndex + 1 ] ;
				}

				t_TempString += t_Char ;
			}

			t_CharacterIndex = t_CharacterIndex + t_CharacterLength ;
		}

		pstValues->pInstance->SetCHString( IDS_DeviceMap, t_TempString ) ;
#endif

		GetNTCapabilities( pstValues->pInstance, pstValues->dwWhichInstance ) ;

        t_hr = WBEM_S_NO_ERROR;
    }

    return t_hr ;
}
#endif

////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
VOID CWin32_ScsiController::SetStatusAndAvailabilityNT(CHString& a_chstrDeviceID, CInstance* a_pInst)
{
    CHString t_chsTmp( a_chstrDeviceID );

	if(a_pInst == NULL)
    {
        return ;
    }

    CHString	t_chsKey ;
    CRegistry	t_Reg ;
    DWORD		t_dwTemp ;

    a_pInst->SetCHString( IDS_PNPDeviceID, t_chsTmp ) ;

	t_chsKey = _T("System\\CurrentControlSet\\Enum\\") + t_chsTmp ;
	if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ ) )
    {
		//  Get the DeviceDesc
		if(ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("DeviceDesc"), t_chsTmp ) )
        {
			a_pInst->SetCHString( IDS_Description, t_chsTmp ) ;
		}
		if(ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("Mfg"), t_chsTmp ) )
        {
			a_pInst->SetCHString( IDS_Manufacturer, t_chsTmp ) ;
		}
		BYTE t_szTmp[ ( _MAX_PATH + 2 ) * sizeof( TCHAR ) ] ;

        DWORD dwSize = sizeof(t_szTmp);
		if( ERROR_SUCCESS == t_Reg.GetCurrentBinaryKeyValue( _T("HardwareId"), t_szTmp, &dwSize ) )
        {
			t_chsTmp = (TCHAR *) t_szTmp ;

			a_pInst->SetWBEMINT16( IDS_ProtocolSupported, LookupProtocol( t_chsTmp.SpanExcluding( _T("\\") ) ) ) ;
		}

		if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( _T("StatusFlags"), t_dwTemp ) )
        {
			ConfigStatusToCimStatus ( t_dwTemp , t_chsTmp ) ;

			a_pInst->SetCHString( IDS_Status, t_chsTmp ) ;

			if ( t_chsTmp.CompareNoCase( IDS_STATUS_OK ) == 0 )
            {
                a_pInst->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
				a_pInst->SetWBEMINT16( IDS_Availability, 3 ) ;
            }
            else if ( t_chsTmp.CompareNoCase( IDS_STATUS_Degraded ) == 0 )
            {
                a_pInst->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
				a_pInst->SetWBEMINT16(IDS_Availability, 10 ) ;
            }
            else if ( t_chsTmp.CompareNoCase( IDS_STATUS_Error ) == 0 )
            {
                a_pInst->SetWBEMINT16( IDS_StatusInfo, 4 ) ;
				a_pInst->SetWBEMINT16(IDS_Availability, 4 ) ;
            }
            else
            {
                a_pInst->SetWBEMINT16( IDS_StatusInfo, 2 ) ;
				a_pInst->SetWBEMINT16(IDS_Availability, 2 ) ;
            }
		}
	}
}
#endif
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
HRESULT CWin32_ScsiController::OpenSCSIKey( CRegistry &a_PrimaryReg, LPCTSTR a_szKey )
{
    return	( WinErrorToWBEMhResult(a_PrimaryReg.Open( HKEY_LOCAL_MACHINE,
													 TOBSTRT( a_szKey ),
													 KEY_READ | KEY_ENUMERATE_SUB_KEYS ) ) ) ;
}

#ifdef NTONLY
void CWin32_ScsiController::GetNTCapabilities( CInstance *a_pInst, DWORD a_dwWhichInstance )
{
	CHString	t_fName ;

	t_fName.Format( L"\\\\.\\Scsi%d:", a_dwWhichInstance ) ;

	SmartCloseHandle t_hScuzzyHandle = CreateFile(	t_fName,
									 0,
									 FILE_SHARE_READ  | FILE_SHARE_WRITE,
									 NULL,
									 OPEN_EXISTING,
									 0,
									 0) ;

	if( t_hScuzzyHandle != INVALID_HANDLE_VALUE )
	{
		IO_SCSI_CAPABILITIES t_capabilities;
		memset( &t_capabilities, '\0', sizeof( IO_SCSI_CAPABILITIES ) ) ;

		t_capabilities.Length = sizeof( IO_SCSI_CAPABILITIES ) ;

		DWORD t_bytesBitten ;

		if ( DeviceIoControl(	t_hScuzzyHandle,
								IOCTL_SCSI_GET_CAPABILITIES,
								NULL,
								0,
								&t_capabilities,
								sizeof( IO_SCSI_CAPABILITIES ),
								&t_bytesBitten,
								NULL ) )
		{
			// length, width - what's the difference?
			// commented out because this is the wrong value
			//a_pInst->SetDWORD("MaxDataWidth", capabilities.MaximumTransferLength);
		}
		else
		{
			if ( IsErrorLoggingEnabled() )
			{
				DWORD		t_err = GetLastError() ;
				CHString	t_errStr ;
							t_errStr.Format( L"DeviceIoControl(IOCTL_SCSI_GET_CAPABILITIES) Failed %u", t_err ) ;

				LogErrorMessage( t_errStr ) ;
			}
		}

	}
	else
	{
		LogErrorMessage(L"CreateFile failed");
	}
}
#endif

/*
/////////////////////////////////////////////////////////////////////
BOOL CWin32_ScsiController::SetDateFromFileName( LPCTSTR a_szFileName, CInstance *&a_pInst )
{
	BOOL		t_fRc = FALSE ;
	FILETIME	t_ftCreationTime,
				t_ftLastAccessTime,
				t_ftLastWriteTime,
				t_ftLocal ;
	HANDLE		t_hFile = INVALID_HANDLE_VALUE ;

	try
	{
		t_hFile = CreateFile(	a_szFileName,
								GENERIC_READ,
								0,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL ) ;

		if( INVALID_HANDLE_VALUE != t_hFile )
		{
			GetFileTime( t_hFile, &t_ftCreationTime, &t_ftLastAccessTime, &t_ftLastWriteTime ) ;

			CloseHandle( t_hFile ) ;
			t_hFile = INVALID_HANDLE_VALUE ;

			FileTimeToLocalFileTime( &t_ftCreationTime, &t_ftLocal ) ;

			SYSTEMTIME t_SystemTime ;

			if( FileTimeToSystemTime( &t_ftLocal, &t_SystemTime ) )
			{
				a_pInst->SetDateTime( IDS_InstallDate,(SYSTEMTIME) t_SystemTime ) ;
			}

			t_fRc = TRUE ;
		}

	}
	catch( ... )
	{
		if( INVALID_HANDLE_VALUE == t_hFile )
		{
			CloseHandle( t_hFile ) ;
		}
        throw;
	}

    return t_fRc ;
}
*/

// The only value I've actually seen returned here is PCI.
WORD CWin32_ScsiController::LookupProtocol( CHString a_sSeek )
{
    WORD t_wRetVal = 2 ;

    if ( a_sSeek.CompareNoCase( L"PCI" ) == 0 )
	{
        t_wRetVal = 5 ;
    }
	else if ( a_sSeek.CompareNoCase( L"EISA" ) == 0 )
	{
        t_wRetVal = 3 ;
    }
	else if ( a_sSeek.CompareNoCase(L"ISA") == 0 )
	{
        t_wRetVal = 4 ;
    }
	else if ( a_sSeek.CompareNoCase(L"PCMCIA") == 0 )
	{
        t_wRetVal = 15 ;
    }
	else if ( a_sSeek.CompareNoCase(L"MCA") == 0 )
    {
       t_wRetVal = 35 ;
    }

    return t_wRetVal ;
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::IsOneOfMe
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of SCSI device.
 *
 *  INPUTS      : CConfigMgrDevice* pDevice - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid USB class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32_ScsiController::IsOneOfMe(void* pv)
{
    bool fRet = false;

    if(pv != NULL)
    {
        CConfigMgrDevice* pDevice = (CConfigMgrDevice*) pv;
        // Ok, it knows about it.  Is it a usb device?
        if(pDevice->IsClass(L"SCSIAdapter"))
        {
            fRet = true;
        }
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\secureregkey.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	SecurityDescriptor.cpp - implementation file for CSecureRegistryKey class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"

#include "SecurityDescriptor.h"			// CSid class
#include "secureregkey.h"
#include "tokenprivilege.h"


/*
 *	This constructor is the default
 */

CSecureRegistryKey::CSecureRegistryKey()
:	CSecurityDescriptor(),
	m_hParentKey( NULL ),
	m_strKeyName()
{
}

// This constructor takes in a parent key and key name, which it uses
// to initialize our security.
CSecureRegistryKey::CSecureRegistryKey( HKEY hParentKey, LPCTSTR pszRegKeyName, BOOL fGetSACL /*= TRUE*/ )
:	CSecurityDescriptor(),
	m_hParentKey( NULL ),
	m_strKeyName()
{
	SetKey( hParentKey, pszRegKeyName );
}

/*
 *	Destructor.
 */

CSecureRegistryKey::~CSecureRegistryKey( void )
{
}

// This function provides an entry point for obtaining a registry key and using
// it to get to its security descriptor so we can get who's who and what's what

DWORD CSecureRegistryKey::SetKey( HKEY hParentKey, LPCTSTR pszRegKeyName, BOOL fGetSACL /*= TRUE*/ )
{
	REGSAM	dwAccessMask = STANDARD_RIGHTS_READ;
	SECURITY_INFORMATION	siFlags = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;

	// We must have the security privilege enabled in order to access the object's SACL
	CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( fGetSACL )
	{
		fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
		dwAccessMask |= ACCESS_SYSTEM_SECURITY;
		siFlags |= SACL_SECURITY_INFORMATION;
	}

	// Open handle to the key
	HKEY	hKey	=	NULL;
	DWORD	dwError	=	RegOpenKeyEx(	hParentKey,				// Root key.
										pszRegKeyName,			// Subkey.
										NULL,						// Reserved, must be NULL.
										dwAccessMask,		// Access desired.
										&hKey );

	// if unable to open registry key, simply return error message.
	if ( dwError == ERROR_SUCCESS )
	{
		// Determine the length needed for self-relative SD
		DWORD dwLengthNeeded = 0;
		dwError = ::RegGetKeySecurity( hKey,
						siFlags,
						NULL,
						&dwLengthNeeded );

		// The only expected error at this point is insufficcient buffer
		if ( ERROR_INSUFFICIENT_BUFFER == dwError )
		{
            PSECURITY_DESCRIPTOR	pSD;
			pSD = NULL;
            try
            {
                pSD = malloc( dwLengthNeeded );

			    if ( NULL != pSD )
			    {
				    // Now obtain security descriptor
				    dwError = ::RegGetKeySecurity( hKey,
								    siFlags,
								    pSD,
								    &dwLengthNeeded );

				    if ( ERROR_SUCCESS == dwError )
				    {

					    if ( InitSecurity( pSD ) )
					    {
						    m_hParentKey = hParentKey;
						    m_strKeyName = pszRegKeyName;
					    }

				    }

				    // free up the security descriptor
				    //free( pSD );

			    }	// IF NULL != pSD
            }
            catch(...)
            {
                if(pSD != NULL)
                {
                    free(pSD);
                }
                throw;
            }
			free( pSD );

		}	// IF INSUFFICIENTBUFFER

		::RegCloseKey( hKey );


	}	// IF RegOpenKey

	// Cleanup the Name Privilege as necessary.
	if ( fDisablePrivilege )
	{
		securityPrivilege.Enable(FALSE);
	}

	return dwError;

}

DWORD CSecureRegistryKey::WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD, SECURITY_INFORMATION securityinfo )
{
	REGSAM	dwAccessMask = WRITE_DAC;

	// We must have the security privilege enabled in order to access the object's SACL
	CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( securityinfo & SACL_SECURITY_INFORMATION )
	{
		fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
		dwAccessMask |= ACCESS_SYSTEM_SECURITY;
	}

	// Open with write DAC access
	HKEY	hKey	=	NULL;
	DWORD	dwResult =	RegOpenKeyEx(	m_hParentKey,				// Root key.
										TOBSTRT(m_strKeyName),		// Subkey.
										NULL,						// Reserved, must be NULL.
										dwAccessMask,				// Access desired.
										&hKey );

	if ( ERROR_SUCCESS == dwResult )
	{
		dwResult = ::RegSetKeySecurity( hKey,
										securityinfo,
										pAbsoluteSD );

		RegCloseKey( hKey );

	}

	// Cleanup the Name Privilege as necessary.
	if ( fDisablePrivilege )
	{
		securityPrivilege.Enable(FALSE);
	}

	return dwResult;

}

DWORD CSecureRegistryKey::WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD )
{
	// Open with the appropriate access, set the security and leave

	HKEY	hKey	=	NULL;
	DWORD	dwResult =	RegOpenKeyEx( m_hParentKey,			// Root key.
								TOBSTRT(m_strKeyName),		// Subkey.
								NULL,						// Reserved, must be NULL.
								WRITE_OWNER,				// Access desired.
								&hKey );

	if ( ERROR_SUCCESS == dwResult )
	{
		dwResult = ::RegSetKeySecurity( hKey,
									OWNER_SECURITY_INFORMATION,
									pAbsoluteSD );

		RegCloseKey( hKey );

	}

	return dwResult;

}

DWORD CSecureRegistryKey::AllAccessMask( void )
{
	// Registry specific All Access Mask
	return KEY_ALL_ACCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\secureregkey.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CSecureRegistryKey.h - header file for CSecureRegistryKey class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSECUREREGKEY_H__
#define __CSECUREREGKEY_H__




/*
 *	Class CSecureRegistryKey is a helper class. It groups user CSid together with its access mask.
 */ 

class CSecureRegistryKey : public CSecurityDescriptor
{
	// Constructors and destructor
	public:
		CSecureRegistryKey();
		CSecureRegistryKey( HKEY hKeyParent, LPCTSTR pszKeyName, BOOL fGetSACL = TRUE );
		~CSecureRegistryKey();

		DWORD	SetKey( HKEY hKeyParent, LPCTSTR pszKeyName, BOOL fGetSACL = TRUE );

		virtual DWORD AllAccessMask( void );

	protected:

		virtual DWORD WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD );
		virtual DWORD WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD , SECURITY_INFORMATION securityinfo  );

	private:
		HKEY	m_hParentKey;
		CHString	m_strKeyName;

};

#endif // __CSecureRegistryKey_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\serialport.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  serialport.cpp
//
//  Purpose: serialport property set provider
//
//***************************************************************************

#include "precomp.h"
#include <cregcls.h>
#include <lockwrap.h>
#include "WDMBase.h"

#include <devguid.h>

#include "serialport.h"

#include <profilestringimpl.h>

// Property set declaration
//=========================

CWin32SerialPort	win32SerialPort( PROPSET_NAME_SERPORT, IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::CWin32SerialPort
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCWSTR pszNamespace - Namespace for provider.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SerialPort::CWin32SerialPort(LPCWSTR a_strName, LPCWSTR a_pszNamespace /*=NULL*/ )
:	Provider( a_strName, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::~CWin32SerialPort
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32SerialPort::~CWin32SerialPort()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32SerialPort::GetObject
//
//	Inputs:		CInstance*		a_pInst - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SerialPort::GetObject( CInstance *a_pInst, long a_lFlags, CFrameworkQuery &a_Query)
{
    HRESULT		t_hResult	= WBEM_E_NOT_FOUND ;
	BOOL		t_bRetCode	= FALSE ;
	CHString	t_strName ;
	CHString	t_chsKeyCheck ;
    BOOL		t_bIsMouse = FALSE ;

	if ( a_pInst->GetCHString( IDS_DeviceID, t_strName ) )
	{
		if ( IsOneOfMe( t_strName) )
		{

			DWORD t_dwPort;
			t_dwPort = _wtoi( t_strName.Mid( 3 ) ) - 1 ;

#ifdef NTONLY
			{
                CHString t_sPortName;
                TryToFindNTCommPort( t_dwPort, t_sPortName, t_bIsMouse ) ;
				t_bRetCode = LoadPropertyValues(	t_strName,
													a_pInst,
													t_bIsMouse,
													t_sPortName.CompareNoCase( t_strName ) == 0 ) ;
            }
#endif

#ifdef WIN9XONLY

			{
				t_bRetCode = LoadPropertyValues( t_strName, a_pInst, t_bIsMouse, TRUE ) ;
            }
#endif
			if ( !t_bRetCode )
			{
				TCHAR t_szBuff[ _MAX_PATH + 1 ] ;

				CHString t_strName2 = t_strName + ':' ;

				DWORD t_dwBuffsz =
                    WMIRegistry_ProfileString(	_T("Ports"),
												TOBSTRT( t_strName2 ),
												_T("__!!DEFAULT!!__"),
												t_szBuff,
												_MAX_PATH + 1 ) ;

				if ( (t_dwBuffsz < ( _MAX_PATH + 1 ) ) && ( _tcscmp( _T("__!!DEFAULT!!__"), t_szBuff ) != 0 ) )
				{
					t_bRetCode = LoadPropertyValuesFromStrings( t_strName, t_szBuff, a_pInst ) ;
				}
			}
		}
	}

	if ( t_bRetCode )
	{
		t_hResult = WBEM_S_NO_ERROR ;
	}

    return ( t_hResult ) ;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32SerialPort::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32SerialPort::EnumerateInstancesNT(
    MethodContext *a_pMethodContext,
    long a_lFlags)
{
	HRESULT		t_hResult	= WBEM_S_NO_ERROR;
    CHString	t_sPortName ;
    CRegistry	t_RegInfo ;

	// guarded
	WCHAR	*t_szValueName	= NULL ;
	BYTE	*t_szValue		= NULL ;
	TCHAR	*t_szBuff		= NULL ;

	try
	{
		// smart ptr
		CInstancePtr t_pInst;

		// Map of instances
		STRING2DWORD t_instMap ;

		// Retrieve "friendly" names of COM ports
		//=======================================

		if ( t_RegInfo.Open( HKEY_LOCAL_MACHINE, L"Hardware\\DeviceMap\\SerialComm", KEY_READ ) == ERROR_SUCCESS )
		{
			DWORD t_dwKeys = t_RegInfo.GetValueCount() ;

			for( DWORD t_dwKey = 0; t_dwKey < t_dwKeys && SUCCEEDED(t_hResult) ; t_dwKey++ )
			{
				DWORD	t_dwPort = 0xFFFFFFFF ;

				if ( t_RegInfo.EnumerateAndGetValues( t_dwKey, t_szValueName, t_szValue ) != ERROR_SUCCESS )
				{
					continue ;
				}

				if ( 0 == _tcsnicmp( t_szValueName, _T("Serial"), 6 ) )
				{
					TCHAR *t_szNum = t_szValueName ;

					for (int T_i = 0; T_i < 6; T_i++ )
					{
						t_szNum = _tcsinc( t_szNum ) ;

						if ( *t_szNum == _T('\0') )
						{
							t_szNum = NULL ;
							break ;
						}
					}

					if ( t_szNum && *t_szNum != _T('\0') )
					{
						t_dwPort = _ttoi( t_szNum ) ;
						TCHAR t_szNumBuff[ 20 ] ;

						_itot( t_dwPort, t_szNumBuff, 10 ) ;

						if ( 0 != _tcscmp( t_szNum, t_szNumBuff ) )
						{
							t_dwPort = 0xFFFFFFFF ;
						}
					}
				}

				t_sPortName = (LPCTSTR) t_szValue ;

				BOOL t_bIsMouse = FALSE ;

				if ( t_dwPort != 0xFFFFFFFF )
				{
					t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

					if ( NULL != t_pInst )
					{
						BOOL t_bIsAuto = FALSE ;

						if ( TryToFindNTCommPort( t_dwPort, t_sPortName, t_bIsMouse ) )
						{
							t_bIsAuto = TRUE;
						}

						if ( LoadPropertyValues( t_sPortName, t_pInst, t_bIsMouse, t_bIsAuto ) )
						{
							t_hResult = t_pInst->Commit() ;

							t_sPortName.MakeUpper() ;
							t_instMap[ t_sPortName ] = 0;
						}
					}
				}
			}

            // We'll only do the .ini ports if our registry calls succeeded.
            EnumerateInstancesIni(
                a_pMethodContext,
                a_lFlags,
                t_instMap);
		}
    }
    catch(...)
    {
        if (t_szValueName)
            delete t_szValueName;

        if (t_szValue)
            delete t_szValue;

        if (t_szBuff)
            delete t_szBuff;
    }

	delete [] t_szValueName ;
	t_szValueName = NULL ;

	delete [] t_szValue ;
	t_szValue = NULL ;

    return t_hResult;
}
#endif

#ifdef WIN9XONLY
HRESULT CWin32SerialPort::EnumerateInstances9x(
    MethodContext *a_pMethodContext,
    long a_lFlags)
{
    HRESULT t_Result = WBEM_E_FAILED ;

	CConfigManager t_ConfigManager ;
	CDeviceCollection t_DeviceList ;

	if ( t_ConfigManager.GetDeviceListFilterByClass ( t_DeviceList, CONFIG_MANAGER_CLASS_PORTS ) )
	{
		// Map of instances
		STRING2DWORD    t_instMap ;
		REFPTR_POSITION t_Position ;

		if ( t_DeviceList.BeginEnum ( t_Position ) )
		{
			// smart ptrs
			CConfigMgrDevicePtr t_pDevice( NULL );

			t_Result = WBEM_S_NO_ERROR ;
			CHString	t_strName,
						t_strPort;
            CHString sKeyName;
            CRegistry RegInfo;

			// Walk the list

			for ( t_pDevice.Attach(t_DeviceList.GetNext ( t_Position )) ;
				  SUCCEEDED ( t_Result ) && ( NULL != t_pDevice) ;
				  t_pDevice.Attach(t_DeviceList.GetNext ( t_Position )) )
			{

                t_pDevice->GetRegistryKeyName(sKeyName);

                DWORD dwRet = RegInfo.Open(HKEY_LOCAL_MACHINE, sKeyName, KEY_QUERY_VALUE);
                if (dwRet == ERROR_SUCCESS)
                {
                    dwRet = RegInfo.GetCurrentKeyValue(L"PORTNAME", t_strPort);
                }

				// If this is a COM port, load the properties and commit it.
                if (t_strPort.Find(L"COM") == 0)
				{
        			CInstancePtr t_pInst ;

					t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

					if ( NULL != t_pInst )
					{
						if ( LoadPropertyValues(t_strPort, t_pInst, FALSE, TRUE))
						{
							t_Result = t_pInst->Commit() ;

							t_strPort.MakeUpper() ;
							t_instMap[t_strPort] = 0;
						}
					}
					else
					{
						t_Result = WBEM_E_FAILED ;
					}
				}
			}

			// Always call EndEnum().  For all Beginnings, there must be an End

			t_DeviceList.EndEnum();
		}

        if (SUCCEEDED(t_Result))
        {
            // We'll only do the .ini ports if our config mgr calls succeeded.
            t_Result =
                EnumerateInstancesIni(
                    a_pMethodContext,
                    a_lFlags,
                    t_instMap);
        }

	}

	return t_Result ;
}
#endif

HRESULT CWin32SerialPort::EnumerateInstancesIni(
    MethodContext *a_pMethodContext,
    long a_lFlags,
    STRING2DWORD &a_instMap)
{
	//now check for win.ini (or registry entries)...
	//==============================================

	HRESULT     t_hResult = WBEM_S_NO_ERROR ;
	DWORD	    t_dwBuffSz = 1024,
	            t_dwRet = 0;
    TCHAR       *t_szBuff = NULL;
    CHString    t_strBuffer;

	do
	{
        if (t_szBuff)
        {
            t_strBuffer.ReleaseBuffer();
    		t_dwBuffSz += 1024 ;
        }

        t_szBuff = (LPTSTR) t_strBuffer.GetBuffer(t_dwBuffSz);

		t_dwRet = WMIRegistry_ProfileSection( _T("Ports"), t_szBuff, t_dwBuffSz ) ;
	} while ( t_szBuff && ( t_dwRet == t_dwBuffSz - 2 ) );

    // t_szBuff must be non-null at this point (a mem failure would have
    // thrown).

    // Parse and process each entry...
	DWORD t_dwIndex = 0 ;

	while ( t_dwIndex < t_dwRet && SUCCEEDED( t_hResult ) )
	{
		//ignore leading space...
		while ( ( t_dwIndex < t_dwRet ) &&
			( ( t_szBuff[ t_dwIndex ] == _T(' ')) || ( t_szBuff[ t_dwIndex ] == _T('\t') ) ) )
		{
			t_dwIndex++ ;
		}

		//ignore comment lines...
		if ( t_szBuff[ t_dwIndex ] == _T(';') )
		{
			while ( ( t_dwIndex < t_dwRet ) && ( t_szBuff[ t_dwIndex ] != _T('\0') ) )
			{
				t_dwIndex++ ;
			}
		}
		else
		{
			//handle key/value pair
			DWORD t_dwName = t_dwIndex ;

			while ( ( t_dwIndex < t_dwRet ) &&
				( t_szBuff[ t_dwIndex ] != _T('=') ) && ( t_szBuff[ t_dwIndex ] != _T('\0') ) )
			{
				t_dwIndex++ ;
			}

			if ( ( t_dwIndex >= t_dwRet ) || ( t_szBuff[ t_dwIndex ] == _T('\0') ) )
			{
				//skip to the next entry if there is one...
				continue ;
			}

			if ( t_szBuff[ t_dwIndex - 1 ] != _T(':') )
			{
				t_dwName = t_dwIndex - 1 ;
			}

        	//should be COMn:=...
			t_szBuff[ t_dwIndex - 1 ] = _T('\0') ;
			t_szBuff[ t_dwIndex++ ] = _T('\0') ;

			DWORD t_dwValue = t_dwIndex ;

			//if name is not in our map try and create an instance
			//=====================================================

			if ( t_szBuff[ t_dwName ] != _T('\0') )
			{
				CHString t_key( &t_szBuff[ t_dwName ] ) ;

        		t_key.MakeUpper() ;

				if ( a_instMap.find( t_key ) == a_instMap.end() )
				{
					//it wasn't in the map...
					//however we don't want to try this name again....
					a_instMap[ t_key ] = 0 ;

					DWORD t_dwPort = 0xFFFFFFFF ;

					//test the value name for a COM port
					if ( 0 == _tcsnicmp( &(t_szBuff[ t_dwName ] ), _T("COM"), 3 ) )
					{
						TCHAR *t_szNum = &t_szBuff[ t_dwName ] ;

						for ( int t_i = 0; t_i < 3; t_i++ )
						{
							t_szNum = _tcsinc( t_szNum ) ;
							if ( *t_szNum == _T('\0') )
							{
								t_szNum = NULL ;
								break ;
							}
						}

						if ( t_szNum && *t_szNum != _T('\0') )
						{
							t_dwPort = _ttoi( t_szNum ) ;

							TCHAR t_szNumBuff[ 20 ] ;

							_itot( t_dwPort, t_szNumBuff, 10 ) ;

							if ( 0 != _tcscmp( t_szNum, t_szNumBuff) )
							{
								t_dwPort = 0xFFFFFFFF ;
							}
						}
					}

					if ( t_dwPort != 0xFFFFFFFF )
					{
            			CInstancePtr t_pInst;

						//generate a new instance...
						t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

						if ( NULL != t_pInst )
						{
							if (LoadPropertyValuesFromStrings(
                                &t_szBuff[ t_dwName ],
								&t_szBuff[ t_dwValue ],
								t_pInst ) )
							{
								t_hResult = t_pInst->Commit() ;
							}
						}
					}
				}
			}

			//set the index to the end of the value...
			while ( t_szBuff[ t_dwIndex ] != _T('\0') )
			{
				t_dwIndex++ ;
			}
		}

		//currently points to a null so set to next char
		if ( ( t_dwIndex < t_dwRet ) )
		{
			t_dwIndex++ ;

			if ( ( t_dwIndex < t_dwRet ) && ( t_szBuff[ t_dwIndex ] == _T('\0') ) )
			{
				//double null, can leave early!
				break ;
			}
		}
	}

	t_strBuffer.ReleaseBuffer();

    return t_hResult;
}

HRESULT CWin32SerialPort::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
#ifdef NTONLY
    return EnumerateInstancesNT(
        a_pMethodContext,
        a_lFlags);
#endif

#ifdef WIN9XONLY
    return EnumerateInstances9x(
        a_pMethodContext,
        a_lFlags);
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties according to passed index
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if port was found & properties loaded, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32SerialPort::LoadPropertyValues(	CHString &a_sPortName,
											CInstance *a_pInst,
											BOOL a_bIsMouse /* = FALSE*/,
											BOOL a_bIsAuto /* = FALSE*/ )
{
	TCHAR		t_szTemp[ _MAX_PATH ] ;
	COMMPROP	t_COMProp ;

	SmartCloseHandle t_hCOMHandle;

#ifdef WIN9XONLY
	CLockWrapper t_lockVXD( g_csVXD ) ;
#endif

	a_pInst->SetCHString( IDS_Name, a_sPortName ) ;

	// set descr & caption to same as name
	a_pInst->SetCHString( IDS_Caption, a_sPortName ) ;
	a_pInst->SetCHString( IDS_Description, a_sPortName ) ;
	a_pInst->SetCHString( IDS_DeviceID, a_sPortName ) ;
	a_pInst->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;
	a_pInst->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;

	SetCreationClassName( a_pInst ) ;

	a_pInst->SetWBEMINT16( IDS_StatusInfo, 3 ) ;
	a_pInst->Setbool( IDS_OSAutoDiscovered, a_bIsAuto ) ;

#ifdef _UNICODE
	swprintf( t_szTemp, L"\\\\.\\%s", a_sPortName.GetBuffer( _MAX_PATH ) ) ;
#else
	sprintf( t_szTemp, "%S", a_sPortName.GetBuffer( _MAX_PATH ) ) ;
#endif



	t_hCOMHandle = CreateFile(  t_szTemp,
								0 /* GENERIC_READ | GENERIC_WRITE */,
								0,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL ) ;

	bool t_fHaveWMIData = false ;

	if(t_hCOMHandle == INVALID_HANDLE_VALUE)
    {
        // We're done with the port so unlock the VXD critical section if on
        // 9x.
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
		{

// According to alan warwick, 98 doesn't support serialport.
/*

			if( IsWin98() )
			{
				// Try using wmi's interface to the kernel
				if(	WBEM_S_NO_ERROR != hLoadWmiSerialData( a_pInst ) )
				{

					// Go ahead and unlock it if we couldn't open the port.
			        g_csVXD.Leave();

					// Com port not there
					// note that NT seems to think that if a mouse is connected, then the com port doesn't exist!
					if ( (GetLastError() == ERROR_FILE_NOT_FOUND ) && !a_bIsMouse )
					{
					 return FALSE ;
					}
				}
				t_fHaveWMIData = true ;
			}
*/

		// Grab the PNPDeviceID if we can.
#ifdef NTONLY
			GetWinNTPNPDeviceID( a_pInst, a_sPortName );
#endif

#ifdef WIN9XONLY
			GetWin9XPNPDeviceID( a_pInst, a_sPortName ) ;
#endif

			// com port is valid, but we can't get to it.
			return TRUE ;
        }
        else
        {
            return FALSE;
        }
	}

	if( !t_fHaveWMIData )
	{
		t_COMProp.wPacketLength = sizeof( COMMPROP ) ;
		if( GetCommProperties( t_hCOMHandle, &t_COMProp ) )
		{
			a_pInst->SetDWORD( IDS_MaximumOutputBufferSize, t_COMProp.dwMaxTxQueue ) ;
			a_pInst->SetDWORD( IDS_MaximumInputBufferSize, t_COMProp.dwMaxRxQueue ) ;

			DWORD t_dwMaxBaudRate = 0L;

#ifdef WIN9XONLY
			{
				CConfigManager		t_cfgmgr;
				CDeviceCollection	t_deviceList;

				if( t_cfgmgr.GetDeviceListFilterByClass( t_deviceList, L"Ports") )
				{
					REFPTR_POSITION	t_pos = NULL ;
					if ( t_deviceList.BeginEnum( t_pos ) )
					{
						// smart ptr
						CConfigMgrDevicePtr t_pPort;

						BOOL				t_fFound = FALSE ;
						CHString			t_chstrPortName ;
                        CHString sKeyName;
                        CRegistry RegInfo;

						// Enum the devices until we find one that has our name in its
						// description string
                        for (t_pPort.Attach(t_deviceList.GetNext( t_pos ) ) ;
                             (!t_fFound) && (t_pPort != NULL);
                             t_pPort.Attach(t_deviceList.GetNext( t_pos ) ) )
						{
							// Parallel and Serial devices mark their name in the registry
							// under the "PORTNAME" value.
                            t_pPort->GetRegistryKeyName(sKeyName);

                            DWORD dwRet = RegInfo.Open(HKEY_LOCAL_MACHINE, sKeyName, KEY_QUERY_VALUE);
                            if (dwRet == ERROR_SUCCESS)
                            {
                                dwRet = RegInfo.GetCurrentKeyValue(L"PORTNAME", t_chstrPortName);
                            }

							if( dwRet == ERROR_SUCCESS
									&& ( t_chstrPortName.CompareNoCase( a_sPortName ) == 0 ) )
							{
								t_fFound = TRUE ;

								CHString t_chstrDriver ;

								if( t_pPort->GetDriver( t_chstrDriver ) )
								{
									CRegistry	t_reg ;
									CHString	t_chstrSubkey = IDS_WIN9XCurCtlSet_Svcs_Class ;
												t_chstrSubkey += L"\\" ;
												t_chstrSubkey += t_chstrDriver ;

									if( t_reg.Open( HKEY_LOCAL_MACHINE, t_chstrSubkey,KEY_READ ) == ERROR_SUCCESS )
									{
										// Now need to get the binary data stored in the key DCB.
										BYTE t_bByteBuf[ _MAX_PATH ] ;
                                        DWORD t_dwSize = sizeof(t_bByteBuf);

										ZeroMemory( t_bByteBuf,_MAX_PATH ) ;

										if( t_reg.GetCurrentBinaryKeyValue( L"DCB", (LPBYTE)&t_bByteBuf, &t_dwSize ) == ERROR_SUCCESS )
										{
											BYTE t_bByteLong[ 4 ] ;
											memcpy( t_bByteLong, t_bByteBuf + 4 , 4 ) ;

											DWORD* t_pdwTemp = reinterpret_cast<DWORD*>( t_bByteLong ) ;
											t_dwMaxBaudRate = *t_pdwTemp ;
										}
									}
								}
							}
						}
						t_deviceList.EndEnum() ;
					}
				}
			}
#endif

#ifdef NTONLY
			{
				switch( t_COMProp.dwMaxBaud )
				{
					case BAUD_075:
					{
						t_dwMaxBaudRate = 75;
						break;
					}
					case BAUD_110:
					{
						t_dwMaxBaudRate = 110;
						break;
					}
					case BAUD_134_5:
					{
						t_dwMaxBaudRate = 1345;
						break;
					}
					case BAUD_150:
					{
						t_dwMaxBaudRate = 150;
						break;
					}
					case BAUD_300:
					{
						t_dwMaxBaudRate = 300;
						break;
					}
					case BAUD_600:
					{
						t_dwMaxBaudRate = 600;
						break;
					}
					case BAUD_1200:
					{
						t_dwMaxBaudRate = 1200;
						break;
					}
					case BAUD_1800:
					{
						t_dwMaxBaudRate = 1800;
						break;
					}
					case BAUD_2400:
					{
						t_dwMaxBaudRate = 2400;
						break;
					}
					case BAUD_4800:
					{
						t_dwMaxBaudRate = 4800;
						break;
					}
					case BAUD_7200:
					{
						t_dwMaxBaudRate = 7200;
						break;
					}
					case BAUD_9600:
					{
						t_dwMaxBaudRate = 9600;
						break;
					}
					case BAUD_14400:
					{
						t_dwMaxBaudRate = 14400;
						break;
					}
					case BAUD_19200:
					{
						t_dwMaxBaudRate = 19200;
						break;
					}
					case BAUD_38400:
					{
						t_dwMaxBaudRate = 38400;
						break;
					}
					case BAUD_56K:
					{
						t_dwMaxBaudRate = 56000;
						break;
					}
					case BAUD_57600:
					{
						t_dwMaxBaudRate = 57600;
						break;
					}
					case BAUD_115200:
					{
						t_dwMaxBaudRate = 115200;
						break;
					}
					case BAUD_128K:
					{
						t_dwMaxBaudRate = 128000;
						break;
					}
					default:
					{
						t_dwMaxBaudRate = 0;
						break;
					}
				}
        	}
#endif

			if ( t_dwMaxBaudRate != 0 )
			{
				a_pInst->SetDWORD( IDS_MaximumBaudRate, t_dwMaxBaudRate ) ;
			}

			CHString chsProviderType;

			switch( t_COMProp.dwProvSubType )
			{
				case PST_FAX:
				{
					chsProviderType = L"FAX Device";
					break;
				}
				case PST_LAT:
				{
					chsProviderType = L"LAT Protocol";
					break;
				}
				case PST_MODEM:
				{
					chsProviderType = L"Modem Device";
					break;
				}
				case PST_NETWORK_BRIDGE:
				{
					chsProviderType = L"Network Bridge";
					break;
				}
				case PST_PARALLELPORT:
				{
					chsProviderType = L"Parallel Port";
					break;
				}
				case PST_RS232:
				{
					chsProviderType = L"RS232 Serial Port";
					break;
				}
				case PST_RS422:
				{
					chsProviderType = L"RS422 Port";
					break;
				}
				case PST_RS423:
				{
					chsProviderType = L"RS423 Port";
					break;
				}
				case PST_RS449:
				{
					chsProviderType = L"RS449 Port";
					break;
				}
				case PST_SCANNER:
				{
					chsProviderType = L"Scanner Device";
					break;
				}
				case PST_TCPIP_TELNET:
				{
					chsProviderType = L"TCP/IP TelNet";
					break;
				}
				case PST_X25:
				{
					chsProviderType = L"X.25";
					break;
				}
				default:
				{
					chsProviderType = L"Unspecified";
					break;
				}
			}

			a_pInst->SetCHString( IDS_ProviderType, chsProviderType );

			a_pInst->Setbool( IDS_Supports16BitMode,
				( ( t_COMProp.dwProvCapabilities & PCF_16BITMODE ) ? TRUE : FALSE ) ) ;

			a_pInst->Setbool( IDS_SupportsDTRDSR,
				( ( t_COMProp.dwProvCapabilities & PCF_DTRDSR )	? TRUE : FALSE ) ) ;

			a_pInst->Setbool( IDS_SupportsIntervalTimeouts,
				( ( t_COMProp.dwProvCapabilities & PCF_INTTIMEOUTS ) ? TRUE : FALSE ) ) ;

			a_pInst->Setbool( IDS_SupportsParityCheck,
				( ( t_COMProp.dwProvCapabilities & PCF_PARITY_CHECK ) ? TRUE : FALSE ) ) ;

			a_pInst->Setbool( IDS_SupportsRLSD,
				( ( t_COMProp.dwProvCapabilities & PCF_RLSD ) ? TRUE : FALSE ) ) ;

			a_pInst->Setbool( IDS_SupportsRTSCTS,
				( ( t_COMProp.dwProvCapabilities & PCF_RTSCTS ) ? TRUE : FALSE ) ) ;

			a_pInst->Setbool( IDS_SupportsSettableXOnXOff,
				( ( t_COMProp.dwProvCapabilities & PCF_SETXCHAR ) ? TRUE : FALSE ) ) ;

			a_pInst->Setbool( IDS_SupportsSpecialChars,
				( ( t_COMProp.dwProvCapabilities & PCF_SPECIALCHARS ) ? TRUE : FALSE ) ) ;

			// Elapsed timeout support.....not total timeouts.
			a_pInst->Setbool( IDS_SupportsElapsedTimeouts,
				( ( t_COMProp.dwProvCapabilities & PCF_TOTALTIMEOUTS ) ? TRUE : FALSE ) ) ;

			a_pInst->Setbool( IDS_SupportsXOnXOff,
				( ( t_COMProp.dwProvCapabilities & PCF_XONXOFF ) ? TRUE : FALSE ) ) ;

			a_pInst->Setbool( IDS_SettableBaudRate,
				t_COMProp.dwSettableParams & SP_BAUD ? TRUE : FALSE ) ;

			a_pInst->Setbool( IDS_SettableDataBits,
				t_COMProp.dwSettableParams & SP_DATABITS ? TRUE : FALSE ) ;

			a_pInst->Setbool( IDS_SettableFlowControl,
				t_COMProp.dwSettableParams & SP_HANDSHAKING	? TRUE : FALSE ) ;

			a_pInst->Setbool( IDS_SettableParity,
				t_COMProp.dwSettableParams & SP_PARITY ? TRUE : FALSE ) ;

			a_pInst->Setbool( IDS_SettableParityCheck,
				t_COMProp.dwSettableParams & SP_PARITY_CHECK ? TRUE : FALSE ) ;

			a_pInst->Setbool( IDS_SettableRLSD,
				t_COMProp.dwSettableParams & SP_RLSD ? TRUE : FALSE ) ;

			a_pInst->Setbool( IDS_SettableStopBits,
				t_COMProp.dwSettableParams & SP_STOPBITS ? TRUE : FALSE ) ;

	//		a_pInst->Setbool( IDS_HotSwappable, FALSE ) ;
	//		a_pInst->Setbool( IDS_PowerManagementEnabled, FALSE ) ;
			a_pInst->Setbool( IDS_PowerManagementSupported, FALSE ) ;

            CHString	t_sTemp;

			// set descr & caption to same as name
			if (a_pInst->GetCHString( IDS_Name, t_sTemp ) )
			{
				a_pInst->SetCHString( IDS_Caption, t_sTemp ) ;
				a_pInst->SetCHString( IDS_Description, t_sTemp ) ;
				a_pInst->SetCHString( IDS_DeviceID, t_sTemp ) ;
			}

			DCB t_dcb;
			if ( GetCommState( t_hCOMHandle, &t_dcb ) )
			{
				BOOL t_fBinary = FALSE;

				t_fBinary = (BOOL) t_dcb.fBinary ;
				a_pInst->Setbool( IDS_Binary, t_fBinary ) ;
			}

		}
	}

// Grab the PNPDeviceID if we can.
#ifdef NTONLY
	GetWinNTPNPDeviceID( a_pInst, a_sPortName );
#endif

#ifdef WIN9XONLY
	GetWin9XPNPDeviceID( a_pInst, a_sPortName ) ;
#endif

	return TRUE ;
}

// just like the name says, tries to find the port in a different place in the registry
// note that  "dwPort" is zero based.
BOOL CWin32SerialPort::TryToFindNTCommPort( DWORD a_dwPort, CHString &a_strSerialPort, BOOL &a_bIsMouse )
{
	BOOL		t_bRet = FALSE ;
	CRegistry	t_reg ;

	a_bIsMouse	= FALSE ;

	if ( t_reg.Open(	HKEY_LOCAL_MACHINE,
						L"HARDWARE\\DESCRIPTION\\SYSTEM\\MultifunctionAdapter",
						KEY_READ ) == ERROR_SUCCESS)
	{
		DWORD t_count = t_reg.GetCurrentSubKeyCount() ;

		for( LONG t_m = t_count - 1; t_m >= 0; t_m-- )  // start looking at the highest number - could be in any of them
		{
			CHString t_key ;

			t_key.Format(	L"HARDWARE\\DESCRIPTION\\SYSTEM\\MultifunctionAdapter\\%d\\SerialController\\%d",
							t_m,
							a_dwPort ) ;

			if ( t_reg.Open( HKEY_LOCAL_MACHINE, t_key, KEY_READ ) == ERROR_SUCCESS )
            {
				if ( t_bRet = ( t_reg.GetCurrentKeyValue( L"Identifier", a_strSerialPort ) == ERROR_SUCCESS ) )
				{
					t_key += L"\\PointerPeripheral" ;

					a_bIsMouse = ( t_reg.Open( HKEY_LOCAL_MACHINE, t_key, KEY_READ ) == ERROR_SUCCESS ) ;
				}

				if( t_bRet )
                {
                    break ;
                }
            }
		}
	}

	return t_bRet ;
}



// Sigh... Had to break these out cause yet again Windows platforms
// do not standardize how I tie the device ID to the device.  On
// Win95, we get all "ports" class devices and then we enum the
// list, looking for the first device (this will get LPT devices
// and Infrared devices here too) whose description contains our
// port name.

void CWin32SerialPort::GetWin9XPNPDeviceID( CInstance *a_pInst, LPCWSTR a_pwszName )
{
	CConfigManager		t_cfgmgr ;
	CDeviceCollection	t_deviceList ;
	BOOL				t_fGotList = FALSE ;

	// Class Name of Ports will get us to the ports
	if ( t_cfgmgr.GetDeviceListFilterByClass( t_deviceList, L"Ports" ) )
	{
		REFPTR_POSITION	t_pos = NULL ;

		if ( t_deviceList.BeginEnum( t_pos ) )
		{
			// smart ptr
			CConfigMgrDevicePtr t_pPort;

			BOOL				t_fFound = FALSE ;
			CHString			t_strDevID,
								t_strPortName ;
            CHString sKeyName;
            CRegistry RegInfo;

			// Enum the devices until we find one that has our name in its
			// description string

            for (t_pPort.Attach(t_deviceList.GetNext( t_pos ) ) ;
                 (!t_fFound) && (t_pPort != NULL);
                 t_pPort.Attach(t_deviceList.GetNext( t_pos ) ) )
			{
				// Parallel and Serial devices mark their name in the registry
				// under the "PORTNAME" value.
                t_pPort->GetRegistryKeyName(sKeyName);

                DWORD dwRet = RegInfo.Open(HKEY_LOCAL_MACHINE, sKeyName, KEY_QUERY_VALUE);
                if (dwRet == ERROR_SUCCESS)
                {
                    dwRet = RegInfo.GetCurrentKeyValue(L"PORTNAME", t_strPortName);
                }

				if	(	dwRet == ERROR_SUCCESS &&
						t_pPort->GetDeviceID( t_strDevID ) )
				{
					// Looking for an exact match
					if ( t_strPortName.CompareNoCase( a_pwszName ) == 0 )
					{
						t_fFound = TRUE ;
                        CHString t_chstrTemp ;

                        // Set the device Status
				        if( t_pPort->GetStatus( t_chstrTemp ) )
				        {
					        a_pInst->SetCHString( IDS_Status, t_chstrTemp ) ;
				        }

						SetConfigMgrProperties( t_pPort, a_pInst ) ;
					}
				}
			}

			t_deviceList.EndEnum() ;
		}
	}
}

// WinNT, we get all "serial" service devices.  Then on
// NT 5 we identify via the registry which 0 index number
// maps to the Name we have.  On NT 4 there is only one
// LEGACY_SERIAL service, so that's all we got.
#ifdef NTONLY
void CWin32SerialPort::GetWinNTPNPDeviceID( CInstance *a_pInst, LPCWSTR a_pszName )
{
	CConfigManager		t_cfgmgr ;
	CDeviceCollection	t_deviceList;

	// smart ptr
	CConfigMgrDevicePtr t_pPort;

	// On NT filter by the service name "Serial"
	if ( t_cfgmgr.GetDeviceListFilterByService( t_deviceList, L"Serial" ) )
	{
		DWORD	t_dwPort = 0 ;

		t_pPort.Attach(t_deviceList.GetAt( t_dwPort ));

		if ( NULL != t_pPort )
		{
			CHString t_chstrTemp ;

			// Set the device Status
			if( t_pPort->GetStatus( t_chstrTemp ) )
			{
				a_pInst->SetCHString( IDS_Status, t_chstrTemp ) ;
			}

			SetConfigMgrProperties( t_pPort, a_pInst ) ;
		}
	}
}
#endif

//
BOOL CWin32SerialPort::LoadPropertyValuesFromStrings(

CHString a_sName,
const TCHAR *a_szValue,
CInstance *a_pInst )
{
	a_pInst->SetCHString( IDS_Name, a_sName ) ;

	// set descr & caption to same as name
	a_pInst->SetCHString( IDS_Caption, a_sName ) ;
	a_pInst->SetCHString( IDS_Description, a_sName ) ;
	a_pInst->SetCHString( IDS_DeviceID, a_sName ) ;
	a_pInst->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;
    a_pInst->SetCHString( IDS_SystemName, GetLocalComputerName()) ;
	a_pInst->Setbool( IDS_OSAutoDiscovered, FALSE ) ;
    a_pInst->SetWCHARSplat( IDS_Status, IDS_Unknown );

	SetCreationClassName( a_pInst ) ;

	//set the status to unknown...
    a_pInst->SetWBEMINT16( IDS_StatusInfo, 2 ) ;

	//current implementation ignores the szValue
	//because the status of the comp port is unknown

	return TRUE ;
}

#define Serial_ComInfo_Guid L"{EDB16A62-B16C-11D1-BD98-00A0C906BE2D}"
#define Serial_Name_Guid	L"{A0EC11A8-B16C-11D1-BD98-00A0C906BE2D}"

HRESULT CWin32SerialPort::hLoadWmiSerialData( CInstance *a_pInst )
{
	HRESULT			t_hResult = WBEM_E_NOT_FOUND;
	CWdmInterface	t_wdm ;
	CNodeAll		t_oSerialNames( Serial_Name_Guid ) ;

	t_hResult = t_wdm.hLoadBlock( t_oSerialNames ) ;

	if( S_OK == t_hResult )
	{
		CHString t_chsName;
		a_pInst->GetCHString( IDS_DeviceID, t_chsName ) ;

		CHString t_chsSerialPortName;
		bool t_bValid = t_oSerialNames.FirstInstance() ;

		while( t_bValid )
		{
			// Extract the friendly name
			t_oSerialNames.GetString( t_chsSerialPortName ) ;

			// friendly name is a match
			if( !t_chsSerialPortName.CompareNoCase( t_chsName ) )
			{
				// instance name
				CHString t_chsNameInstanceName ;
				t_oSerialNames.GetInstanceName( t_chsNameInstanceName ) ;

				// key on the instance name
				return GetWMISerialInfo( a_pInst, t_wdm, t_chsName, t_chsNameInstanceName ) ;

			}

			t_bValid = t_oSerialNames.NextInstance() ;
		}
	}
	return t_hResult ;
}

//
HRESULT CWin32SerialPort::GetWMISerialInfo(

CInstance *a_pInst,
CWdmInterface &a_rWdm,
CHString &a_chsName,
CHString &a_chsNameInstanceName )
{
	HRESULT		t_hResult = WBEM_E_NOT_FOUND;
	CNodeAll	t_oSerialData( Serial_ComInfo_Guid ) ;

	t_hResult = a_rWdm.hLoadBlock( t_oSerialData ) ;

	if( S_OK == t_hResult )
	{
		CHString t_chsDataInstanceName;
		bool t_bValid = t_oSerialData.FirstInstance() ;

		while( t_bValid )
		{
			t_oSerialData.GetInstanceName( t_chsDataInstanceName ) ;

			// friendly name is a match
			if( !t_chsDataInstanceName.CompareNoCase( a_chsNameInstanceName ) )
			{
				// collect this MSSerial_CommInfo instance
				MSSerial_CommInfo t_ci ;

				/*	We are currently without a class contract. The class within
					the wmi mof is not expected to changed however we have to
					explicitly indicate how the data is layed out. Having the class
					definition would allow us to examine the property qualifiers
					to get us the order (WmiDataId) and property types.

					Secondly, because the data is aligned on natural boundaries
					a direct offset to a specific piece of data is conditioned on
					what has preceeded it. Thus, a string followed by a DWORD may
					be 1 to 3 bytes away from each other.

					Serially extracting each property in order will take into
					account the alignment problem.
				*/
				t_oSerialData.GetDWORD( t_ci.BaudRate ) ;
				t_oSerialData.GetDWORD( t_ci.BitsPerByte ) ;
				t_oSerialData.GetDWORD( t_ci.Parity ) ;
				t_oSerialData.GetBool(  t_ci.ParityCheckEnable ) ;
				t_oSerialData.GetDWORD( t_ci.StopBits ) ;
				t_oSerialData.GetDWORD( t_ci.XoffCharacter ) ;
				t_oSerialData.GetDWORD( t_ci.XoffXmitThreshold ) ;
				t_oSerialData.GetDWORD( t_ci.XonCharacter ) ;
				t_oSerialData.GetDWORD( t_ci.XonXmitThreshold ) ;
				t_oSerialData.GetDWORD( t_ci.MaximumBaudRate ) ;
				t_oSerialData.GetDWORD( t_ci.MaximumOutputBufferSize ) ;
				t_oSerialData.GetDWORD( t_ci.MaximumInputBufferSize ) ;
				t_oSerialData.GetBool( t_ci.Support16BitMode ) ;
				t_oSerialData.GetBool( t_ci.SupportDTRDSR ) ;
				t_oSerialData.GetBool( t_ci.SupportIntervalTimeouts ) ;
				t_oSerialData.GetBool( t_ci.SupportParityCheck ) ;
				t_oSerialData.GetBool( t_ci.SupportRTSCTS ) ;
				t_oSerialData.GetBool( t_ci.SupportXonXoff ) ;
				t_oSerialData.GetBool( t_ci.SettableBaudRate ) ;
				t_oSerialData.GetBool( t_ci.SettableDataBits ) ;
				t_oSerialData.GetBool( t_ci.SettableFlowControl ) ;
				t_oSerialData.GetBool( t_ci.SettableParity ) ;
				t_oSerialData.GetBool( t_ci.SettableParityCheck ) ;
				t_oSerialData.GetBool( t_ci.SettableStopBits ) ;
				t_oSerialData.GetBool( t_ci.IsBusy ) ;

				// populate the instance
				a_pInst->SetDWORD( IDS_MaximumOutputBufferSize,	t_ci.MaximumOutputBufferSize ) ;
				a_pInst->SetDWORD( IDS_MaximumInputBufferSize,	t_ci.MaximumInputBufferSize) ;
				a_pInst->SetDWORD( IDS_MaximumBaudRate,			t_ci.MaximumBaudRate ) ;
				a_pInst->Setbool( IDS_Supports16BitMode,		t_ci.Support16BitMode ? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SupportsDTRDSR,			t_ci.SupportDTRDSR ? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SupportsIntervalTimeouts,	t_ci.SupportIntervalTimeouts ? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SupportsParityCheck,		t_ci.SupportParityCheck	? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SupportsRTSCTS,			t_ci.SupportRTSCTS ? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SupportsXOnXOff,			t_ci.SupportXonXoff ? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SettableBaudRate,			t_ci.SettableBaudRate ? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SettableDataBits,			t_ci.SettableDataBits ? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SettableFlowControl,		t_ci.SettableFlowControl ? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SettableParity,			t_ci.SettableParityCheck ? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SettableParityCheck,		t_ci.SettableParityCheck ? TRUE : FALSE ) ;
				a_pInst->Setbool( IDS_SettableStopBits,			t_ci.SettableStopBits ? TRUE : FALSE ) ;

				a_pInst->Setbool( IDS_PowerManagementSupported, FALSE ) ;

				// set descr & caption to same as name
				if ( a_pInst->GetCHString( IDS_Name, a_chsName ) )
				{
					a_pInst->SetCHString( IDS_Caption, a_chsName ) ;
					a_pInst->SetCHString( IDS_Description, a_chsName ) ;
				}

				return WBEM_S_NO_ERROR ;
			}

			t_bValid = t_oSerialData.NextInstance() ;
		}
	}
	return t_hResult ;
}

BOOL CWin32SerialPort::IsOneOfMe(LPCWSTR a_DeviceName)
{
	BOOL bRet = FALSE;

	if ( _wcsnicmp(a_DeviceName, L"COM", 3 ) == 0 )
	{
		DWORD t_dwPort = _wtoi( &a_DeviceName[3] ) ;

		CHString t_chsKeyCheck;

		t_chsKeyCheck.Format(L"COM%d", t_dwPort);
		if (t_chsKeyCheck.CompareNoCase( a_DeviceName ) == 0)
		{
			bRet = TRUE;
		}
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\serialport.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  serialport.h
//
//  Purpose: serialport property set provider
//
//***************************************************************************

#ifndef _SERIALPORT_H
#define _SERIALPORT_H

// Property set identification
//============================
#define PROPSET_NAME_SERPORT	    L"Win32_SerialPort"
#define CONFIG_MANAGER_CLASS_PORTS  L"Ports"


#define	REQ_ALL_REQUIRED		0xFFFFFFFF
#define REQ_NONE_REQUIRED		x0x00000000

#if NTONLY >= 5
#else
	typedef std::map<CHString, DWORD> STRING2DWORD;
#endif
	
class CWin32SerialPort : public Provider
{
	private:	
	
	#if NTONLY >= 5
		CHPtrArray m_ptrProperties;
	#endif

	protected:

	#if NTONLY >= 5
        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
            CInstance *a_pinstGetObj,
			long a_Flags , 
			BYTE a_bBits[]
		) ;

		HRESULT LoadPropertyValues ( 

			CInstance *a_Instance, 
			CConfigMgrDevice *a_Device , 
			LPCWSTR szDeviceName , 
			BYTE a_bBits[] 
		) ;

        static void WINAPI RegNameToServiceName(
            LPCWSTR szName, 
            CHString &strService);

	#endif
	
	private:

		HRESULT hLoadWmiSerialData( CInstance* pInstance, BYTE a_bBits[] );

		HRESULT GetWMISerialInfo(	CInstance* pInstance,
									CWdmInterface& rWdm,
									LPCWSTR szName, 
									LPCWSTR szNameInstanceName, BYTE a_bBits[] );

	#ifdef NTONLY
		DWORD GetPortPropertiesFromRegistry ( LPCWSTR szDeviceName );
	#endif

    #ifdef WIN9XONLY
        HRESULT CWin32SerialPort::EnumerateInstances9x(
            MethodContext *a_pMethodContext, 
            long a_lFlags);
    #endif

    #if NTONLY == 4
        HRESULT CWin32SerialPort::EnumerateInstancesNT(
            MethodContext *a_pMethodContext, 
            long a_lFlags);
    #endif

	#if ( defined(WIN9XONLY) || NTONLY == 4 )	
	
		BOOL LoadPropertyValues(	CHString &a_strSerialPort, 
									CInstance *a_pInst,
									BOOL a_bIsMouse = FALSE,
									BOOL a_bIsAuto = FALSE ) ;

		BOOL TryToFindNTCommPort( DWORD a_dwPort, CHString &a_strSerialPort, BOOL &a_bIsMouse ) ; 

		BOOL LoadPropertyValuesFromStrings( CHString a_sName, const TCHAR *a_szValue, CInstance *a_pInst ) ;

		// Helpers for matching device ids up to the ports.
		void GetWin9XPNPDeviceID( CInstance *a_pInst, LPCWSTR a_pszName ) ;
		void GetWinNTPNPDeviceID( CInstance *a_pInst, LPCWSTR a_pszName ) ;

		HRESULT hLoadWmiSerialData( CInstance *a_pInst );
		HRESULT GetWMISerialInfo(	CInstance *a_pInst,
									CWdmInterface &a_rWdm,
									CHString &a_chsName, 
									CHString &a_chsNameInstanceName ) ;

		BOOL IsOneOfMe(LPCWSTR a_DeviceName);

        HRESULT CWin32SerialPort::EnumerateInstancesIni(
            MethodContext *a_pMethodContext, 
            long a_lFlags,
            STRING2DWORD &a_instMap);

	#endif
	
	public:

        // Constructor/destructor
        //=======================

        CWin32SerialPort ( LPCWSTR a_pszName, LPCWSTR a_pszNamespace ) ;
       ~CWin32SerialPort () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject ( 

			CInstance *a_Instance, 
			long a_Flags,
            CFrameworkQuery &a_Query
		) ;

        HRESULT EnumerateInstances ( 

			MethodContext *a_MethodContext, 
			long a_Flags = 0L 
		) ;

	#if NTONLY >= 5
        HRESULT ExecQuery ( 

			MethodContext *a_MethodContext, 
			CFrameworkQuery &a_Query, 
			long a_Flags = 0L
		) ;
	#endif

	enum ePropertyIDs { 
		e_Binary,					// Win32_SerialPort
		e_MaximumInputBufferSize,
		e_MaximumOutputBufferSize,
		e_ProviderType,
		e_SettableBaudRate,
		e_SettableDataBits,
		e_SettableFlowControl,
		e_SettableParity,
		e_SettableParityCheck,
		e_SettableRLSD,
		e_SettableStopBits,
		e_Supports16BitMode,
		e_SupportsDTRDSR,
		e_SupportsElapsedTimeouts,
		e_SupportsIntTimeouts,
		e_SupportsParityCheck,
		e_SupportsRLSD,
		e_SupportsRTSCTS,
		e_SupportsSpecialCharacters,
		e_SupportsXOnXOff,
		e_SupportsXOnXOffSet,
		e_OSAutoDiscovered,
		e_MaxBaudRate,					// CIM_SerialController
		e_MaxNumberControlled,			// CIM_Controller
		e_ProtocolSupported,
		e_TimeOfLastReset,
		e_Availability,					// CIM_LogicalDevice
		e_CreationClassName,
		e_ConfigManagerErrorCode,
		e_ConfigManagerUserConfig,
		e_DeviceID,
		e_PNPDeviceID,
		e_PowerManagementCapabilities,
		e_PowerManagementSupported,
		e_StatusInfo,
		e_SystemCreationClassName,
		e_SystemName,
		e_Caption,						// CIM_ManagedSystemElement
		e_Description,
		e_InstallDate,
		e_Name,
		e_Status,
		e_End_Property_Marker			// end marker
	};	

} ;

// WDM 
typedef struct _MSSerial_CommInfo
{
	DWORD	BaudRate;
	DWORD	BitsPerByte;
	DWORD	Parity;
	BYTE	ParityCheckEnable;
	DWORD	StopBits;
	DWORD	XoffCharacter;
	DWORD	XoffXmitThreshold;
	DWORD	XonCharacter;
	DWORD	XonXmitThreshold;
	DWORD	MaximumBaudRate;
	DWORD	MaximumOutputBufferSize;
	DWORD	MaximumInputBufferSize;
	BYTE	Support16BitMode;		
	BYTE	SupportDTRDSR;
	BYTE	SupportIntervalTimeouts;
	BYTE	SupportParityCheck;
	BYTE	SupportRTSCTS;
	BYTE	SupportXonXoff;
	BYTE	SettableBaudRate;
	BYTE	SettableDataBits;
	BYTE	SettableFlowControl;
	BYTE	SettableParity;
	BYTE	SettableParityCheck;
	BYTE	SettableStopBits;
	BYTE	IsBusy;
} MSSerial_CommInfo;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\serialportcfg.cpp ===
//=================================================================

//

// SerialPortCfg.cpp --Serial port configuration property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/24/97    jennymc        Moved to new framework
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>

#include "WDMBase.h"
#include "SerialPortCfg.h"

#include <profilestringimpl.h>

// Property set declaration
//=========================
CWin32SerialPortConfiguration MyCWin32SerialPortConfigurationSet(PROPSET_NAME_SERIALCONFIG, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPortConfiguration::CWin32SerialPortConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SerialPortConfiguration::CWin32SerialPortConfiguration(
    LPCWSTR name,
    LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPortConfiguration::~CWin32SerialPortConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32SerialPortConfiguration::~CWin32SerialPortConfiguration()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SerialPortConfiguration::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
	HRESULT			hResult = WBEM_E_NOT_FOUND;
	CInstancePtr	pinstPort;
	CHString		strName,
					strPath;

	pInstance->GetCHString(IDS_Name, strName);

	strPath.Format(
		L"Win32_SerialPort.DeviceID=\"%s\"",
		(LPCWSTR) strName);

	// Try to find the item.
	hResult =
		CWbemProviderGlue::GetInstanceByPath(
			strPath,
			&pinstPort, pInstance->GetMethodContext());

	if (SUCCEEDED(hResult))
	{
		pInstance->SetCharSplat(IDS_Name, strName);
		hResult = LoadPropertyValues(pInstance, strName, FALSE);
	}

	return hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SerialPortConfiguration::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance>
				listPorts;
	REFPTRCOLLECTION_POSITION
				posPorts;

	// guarded resources
	CInstancePtr pinstPort;

	// grab all of both items that could be endpoints
	hResult =
		CWbemProviderGlue::GetAllInstances(
			L"Win32_SerialPort",
			&listPorts,
			NULL,
			pMethodContext);

	if (SUCCEEDED(hResult))
	{
		if (listPorts.BeginEnum(posPorts))
		{
			for (pinstPort.Attach(listPorts.GetNext(posPorts));
				pinstPort != NULL && SUCCEEDED(hResult);
				pinstPort.Attach(listPorts.GetNext(posPorts)))
			{
				CHString strPort;

				if (pinstPort->GetCHString(L"DeviceID", strPort))
				{
					CInstancePtr pInst;

					pInst.Attach(CreateNewInstance(pMethodContext));

					pInst->SetCharSplat(IDS_Name, strPort);
					hResult = LoadPropertyValues(pInst, strPort, FALSE);
					if (SUCCEEDED(hResult))
						hResult = pInst->Commit();
				}
			}

			listPorts.EndEnum();
		}
	}

	return hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties according to passed index
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if port was found & properties loaded, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32SerialPortConfiguration::GetDCBPropsViaIni(LPCTSTR szPort, DCB &dcb)
{
    CHString strBuffer;
    TCHAR    szBuffer[_MAX_PATH];
    BOOL     bRet;

	// get the com port info out of the WIN.INI file
	WMIRegistry_ProfileString(
								_T("Ports"),
								szPort,
								_T("9600,n,8,1,x"),
								szBuffer,
								sizeof(szBuffer) / sizeof(TCHAR));

    strBuffer = szBuffer;

    // Make sure the string is at least half way valid.
    if (CountCommas(strBuffer) >= 3)
    {
	    CHString strTemp;

        // Baud rate
        strTemp = strBuffer.SpanExcluding(L",");
        dcb.BaudRate = _wtol(strTemp);
        strBuffer = strBuffer.Mid(strTemp.GetLength() + 1);

        // Parity
        strTemp = strBuffer.SpanExcluding(L",");
        strBuffer = strBuffer.Mid(strTemp.GetLength() + 1);
        dcb.Parity = NOPARITY; // Setup a default.
        if (strTemp.GetLength() > 0)
		{
            switch (strTemp[0])
			{
			    case _T('o'):
				    dcb.Parity = ODDPARITY;
					break;
                case _T('e'):
				    dcb.Parity = EVENPARITY;
					break;
			    case _T('m'):
					dcb.Parity = MARKPARITY;
					break;
                case _T('n'):
				    dcb.Parity = NOPARITY;
					break;
		    }
		}

        // ByteSize
        strTemp = strBuffer.SpanExcluding(L",");
        dcb.ByteSize = _wtol(strTemp);
        strBuffer = strBuffer.Mid(strTemp.GetLength() + 1);

        // Stop bits
        strTemp = strBuffer.SpanExcluding(L",");
        strTemp.TrimRight();
	    if (strTemp == L"1.5")
		    dcb.StopBits = ONE5STOPBITS;
        else if (strTemp == L"2")
		    dcb.StopBits = TWOSTOPBITS;
        else
		    // The default.
            dcb.StopBits = ONESTOPBIT;

        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}

HRESULT CWin32SerialPortConfiguration::LoadPropertyValues(
    CInstance *pInstance,
    CHString &sPortName,
    bool bIsMouse)
{
    TCHAR   szTemp[_MAX_PATH],
            szPort[_MAX_PATH];
    HANDLE  hCOMHandle;
    DCB     dcb = { sizeof(DCB) };
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL    bGotDCB = FALSE,
            bGotIniSettings = FALSE;

    pInstance->Setbool(IDS_IsBusy, FALSE);
    pInstance->SetCharSplat(IDS_Description, sPortName);
    pInstance->SetCharSplat(IDS_Caption, sPortName);

    _stprintf(szTemp, _T("\\\\.\\%s"), (LPCTSTR) TOBSTRT(sPortName));
	_stprintf(szPort, _T("%s:"), (LPCTSTR) TOBSTRT(sPortName));


	hCOMHandle =
        CreateFile(
            szTemp,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hCOMHandle == INVALID_HANDLE_VALUE)
    {
		DWORD dwErr = GetLastError();

        // Try using wmi's interface to the kernel
		if (WBEM_S_NO_ERROR != hLoadWmiSerialData( pInstance))
		{
			// ACCESS_DENIED and IRQ_BUSY indicate that the port is in
			// use or in conflict with something else.
			if (dwErr == ERROR_ACCESS_DENIED ||
                dwErr == ERROR_IRQ_BUSY ||
                bIsMouse)
			{
				pInstance->Setbool( IDS_IsBusy, TRUE);
			}
			else
			{
				hr = WBEM_E_NOT_FOUND;
			}
		}
    }
    else
    {
		// So the handle will go away when we need it to.
		SmartCloseHandle handle(hCOMHandle);

		if (GetCommState(hCOMHandle, &dcb))
        {
	        pInstance->SetDWORD(IDS_XOnXMitThreshold, dcb.XonLim);
		    pInstance->SetDWORD(IDS_XOffXMitThreshold, dcb.XoffLim);
			pInstance->SetDWORD(IDS_XOnCharacter, dcb.XonChar);
			pInstance->SetDWORD(IDS_XOffCharacter, dcb.XoffChar);
			pInstance->SetDWORD(IDS_ErrorReplaceCharacter, dcb.ErrorChar);
			pInstance->SetDWORD(IDS_EndOfFileCharacter, dcb.EofChar);
			pInstance->SetDWORD(IDS_EventCharacter, dcb.EvtChar);

			pInstance->Setbool(IDS_BinaryModeEnabled, dcb.fBinary           ? TRUE : FALSE);
			pInstance->Setbool(IDS_ParityCheckEnabled, dcb.fParity           ? TRUE : FALSE);
			pInstance->Setbool(IDS_CTSOutflowControl, dcb.fOutxCtsFlow      ? TRUE : FALSE);
			pInstance->Setbool(IDS_DSROutflowControl, dcb.fOutxDsrFlow      ? TRUE : FALSE);
			pInstance->Setbool(IDS_DSRSensitivity, dcb.fDsrSensitivity   ? TRUE : FALSE);
			pInstance->Setbool(IDS_ContinueXMitOnXOff, dcb.fTXContinueOnXoff ? TRUE : FALSE);
			pInstance->Setbool(IDS_XOnXOffOutflowControl, dcb.fOutX             ? TRUE : FALSE);
			pInstance->Setbool(IDS_XOnXOffInflowControl, dcb.fInX              ? TRUE : FALSE);
			pInstance->Setbool(IDS_ErrorReplacementEnabled, dcb.fErrorChar        ? TRUE : FALSE);
			pInstance->Setbool(IDS_DiscardNULLBytes, dcb.fNull             ? TRUE : FALSE);
			pInstance->Setbool(IDS_AbortReadWriteOnError, dcb.fAbortOnError     ? TRUE : FALSE);

			pInstance->SetCHString(IDS_DTRFlowControlType, dcb.fDtrControl   == DTR_CONTROL_DISABLE  ? L"DISABLE"    :
				dcb.fDtrControl   == DTR_CONTROL_ENABLE   ? L"ENABLE"     :
				L"HANDSHAKE" );

			pInstance->SetCHString(IDS_RTSFlowControlType, dcb.fRtsControl   == RTS_CONTROL_DISABLE  ? L"DISABLE"    :
				dcb.fRtsControl   == RTS_CONTROL_ENABLE   ? L"ENABLE"     :
				dcb.fRtsControl   == RTS_CONTROL_TOGGLE   ? L"TOGGLE"     :
				L"HANDSHAKE" );
		}
    }

    // The ini values will override the DCB values as the DCB doesn't seem to
    // ever reflect the proper values.  The OS UI uses the .ini to display
    // these four values.
    bGotIniSettings =
        GetDCBPropsViaIni(szPort, dcb);

    if (bGotIniSettings || bGotDCB)
    {
        pInstance->SetDWORD(IDS_BaudRate, dcb.BaudRate);
		pInstance->SetDWORD(IDS_BitsPerByte, dcb.ByteSize);
		pInstance->SetCHString(IDS_Parity, dcb.Parity == ODDPARITY ? L"ODD" :
		    dcb.Parity == EVENPARITY ? L"EVEN" :
			dcb.Parity == MARKPARITY ? L"MARK" : L"NONE");

        pInstance->SetCHString(IDS_StopBits, dcb.StopBits == ONESTOPBIT ? L"1" :
		    dcb.StopBits == ONE5STOPBITS ? L"1.5" : L"2");
    }

    return hr;
}

// just like the name says, tries to find the port in a different place in the registry
// note that  "dwPort" is zero based.
BOOL CWin32SerialPortConfiguration::TryToFindNTCommPort(DWORD dwPort, CHString& strSerialPort, bool& bIsMouse)
{
	BOOL bRet = FALSE;
	bIsMouse = false;
	CRegistry reg;
	if (reg.Open(HKEY_LOCAL_MACHINE,
        L"HARDWARE\\DESCRIPTION\\SYSTEM\\MultifunctionAdapter",
        KEY_READ) == ERROR_SUCCESS)
	{
		DWORD count;
		count = reg.GetCurrentSubKeyCount();
		if (count > 0)
		{
			CHString key;
			key.Format(L"HARDWARE\\DESCRIPTION\\SYSTEM\\MultifunctionAdapter\\%d\\SerialController\\%d",
                count -1, dwPort);
			if (reg.Open(HKEY_LOCAL_MACHINE, key, KEY_READ) == ERROR_SUCCESS)
				if (bRet = (reg.GetCurrentKeyValue(L"Identifier", strSerialPort) == ERROR_SUCCESS))
				{
					key += L"\\PointerPeripheral";
					bIsMouse = (reg.Open(HKEY_LOCAL_MACHINE, key, KEY_READ) == ERROR_SUCCESS);
				}
		}
	}

	return bRet;
}

BOOL CWin32SerialPortConfiguration::TryToFindNTCommPortFriendlyName()
{
	// returning zero instances is not an error
	BOOL bRet = FALSE;
    DWORD dwPort;
    WCHAR szTemp[_MAX_PATH];
    CHString sPortName;
    CRegistry RegInfo;

    // Retrieve "friendly" names of COM ports
    //=======================================

    if(RegInfo.Open(HKEY_LOCAL_MACHINE, L"Hardware\\DeviceMap\\SerialComm",
        KEY_READ) == ERROR_SUCCESS) {

        for(dwPort = 0; dwPort < 16; dwPort++)
		{
			WCHAR *pKey;
#ifdef NTONLY
			{
				if (GetPlatformMajorVersion() >= 5)
					pKey = L"\\Device\\Serial";
				else
					pKey = L"Serial";
			}
#endif
#ifdef WIN9XONLY
				pKey = L"COM";
#endif

            swprintf(szTemp, L"%s%d", pKey, dwPort);


			bool bIsMouse = false;
#ifdef WIN9XONLY
            if (RegInfo.GetCurrentKeyValue(szTemp, sPortName) == ERROR_SUCCESS)
#endif
#ifdef NTONLY
            if (RegInfo.GetCurrentKeyValue(szTemp, sPortName) == ERROR_SUCCESS ||
				TryToFindNTCommPort(dwPort, sPortName, bIsMouse))
#endif
			{
                bRet = TRUE;
            }
        }
        RegInfo.Close();
    }
    return bRet;
}

LONG CWin32SerialPortConfiguration::CountCommas(LPCWSTR szText)
{
    LONG    nCommas = 0;
    LPCWSTR szCurrent;

    for (szCurrent = szText; *szCurrent; szCurrent++)
    {
        if (*szCurrent == ',')
            nCommas++;
    }

    return nCommas;

}

#define Serial_ComInfo_Guid L"{EDB16A62-B16C-11D1-BD98-00A0C906BE2D}"
#define Serial_Name_Guid	L"{A0EC11A8-B16C-11D1-BD98-00A0C906BE2D}"

HRESULT CWin32SerialPortConfiguration::hLoadWmiSerialData( CInstance* pInstance)
{
	HRESULT			hRes;
	CWdmInterface	wdm;
	CNodeAll		oSerialNames(Serial_Name_Guid);

	hRes = wdm.hLoadBlock( oSerialNames);
	if(S_OK == hRes)
	{
		CHString chsName;
		pInstance->GetCHString( IDS_Name, chsName);

	    // Haven't found it yet.
        hRes = WBEM_E_NOT_FOUND;

		CHString chsSerialPortName;
		bool bValid = oSerialNames.FirstInstance();

		while( bValid)
		{
			// extract the friendly name
			oSerialNames.GetString( chsSerialPortName);

			// friendly name is a match
			if( !chsSerialPortName.CompareNoCase(chsName))
			{
				// instance name
				CHString chsNameInstanceName;
				oSerialNames.GetInstanceName( chsNameInstanceName);

				// key on the instance name
				return GetWMISerialInfo( pInstance, wdm, chsName, chsNameInstanceName);

			}
			bValid = oSerialNames.NextInstance();
		}
	}
	return hRes;
}

//
HRESULT CWin32SerialPortConfiguration::GetWMISerialInfo(
    CInstance* pInstance,
    CWdmInterface& rWdm,
    CHString& chsName,
    CHString& chsNameInstanceName)
{
	HRESULT		hRes = WBEM_E_NOT_FOUND;
	CNodeAll	oSerialData(Serial_ComInfo_Guid);

	hRes = rWdm.hLoadBlock( oSerialData);
	if(S_OK == hRes)
	{
		CHString chsDataInstanceName;
		bool bValid = oSerialData.FirstInstance();

		while( bValid)
		{
			oSerialData.GetInstanceName( chsDataInstanceName);

			// friendly name is a match
			if( !chsDataInstanceName.CompareNoCase( chsNameInstanceName))
			{
				// collect this MSSerial_CommInfo instance
				MSSerial_CommInfo ci;

				/*	We are currently without a class contract. The class within
					the wmi mof is not expected to changed however we have to
					explicitly indicate how the data is layed out. Having the class
					definition would allow us to examine the property qualifiers
					to get us the order (WmiDataId) and property types.

					Secondly, because the data is aligned on natural boundaries
					a direct offset to a specific piece of data is conditioned on
					what has preceeded it. Thus, a string followed by a DWORD may
					be 1 to 3 bytes away from each other.

					Serially extracting each property in order will take into
					account the alignment problem.
				*/
				oSerialData.GetDWORD( ci.BaudRate);
				oSerialData.GetDWORD( ci.BitsPerByte);
				oSerialData.GetDWORD( ci.Parity);
				oSerialData.GetBool( ci.ParityCheckEnable);
				oSerialData.GetDWORD( ci.StopBits);
				oSerialData.GetDWORD( ci.XoffCharacter);
				oSerialData.GetDWORD( ci.XoffXmitThreshold);
				oSerialData.GetDWORD( ci.XonCharacter);
				oSerialData.GetDWORD( ci.XonXmitThreshold);
				oSerialData.GetDWORD( ci.MaximumBaudRate);
				oSerialData.GetDWORD( ci.MaximumOutputBufferSize);
				oSerialData.GetDWORD( ci.MaximumInputBufferSize);
				oSerialData.GetBool( ci.Support16BitMode);
				oSerialData.GetBool( ci.SupportDTRDSR);
				oSerialData.GetBool( ci.SupportIntervalTimeouts);
				oSerialData.GetBool( ci.SupportParityCheck);
				oSerialData.GetBool( ci.SupportRTSCTS);
				oSerialData.GetBool( ci.SupportXonXoff);
				oSerialData.GetBool( ci.SettableBaudRate);
				oSerialData.GetBool( ci.SettableDataBits);
				oSerialData.GetBool( ci.SettableFlowControl);
				oSerialData.GetBool( ci.SettableParity);
				oSerialData.GetBool( ci.SettableParityCheck);
				oSerialData.GetBool( ci.SettableStopBits);
				oSerialData.GetBool( ci.IsBusy);

				// populate the instance
				pInstance->SetDWORD(IDS_BaudRate,			ci.BaudRate);
				pInstance->SetDWORD(IDS_XOnXMitThreshold,	ci.XonXmitThreshold);
				pInstance->SetDWORD(IDS_XOffXMitThreshold,	ci.XoffXmitThreshold);
				pInstance->SetDWORD(IDS_BitsPerByte,		ci.BitsPerByte);
				pInstance->SetDWORD(IDS_XOnCharacter,		ci.XonCharacter);
				pInstance->SetDWORD(IDS_XOffCharacter,		ci.XoffCharacter);
				pInstance->Setbool(IDS_ParityCheckEnabled,  ci.ParityCheckEnable ? TRUE : FALSE);


				pInstance->SetCHString(IDS_Parity, ci.Parity == ODDPARITY ? L"ODD" :
									  ci.Parity == EVENPARITY ? L"EVEN" :
									  ci.Parity == MARKPARITY ? L"MARK" : L"NONE");

				pInstance->SetCHString(IDS_StopBits, ci.StopBits == ONESTOPBIT ? L"1" :
													 ci.StopBits == ONE5STOPBITS ? L"1.5" : L"2");
				pInstance->Setbool( IDS_IsBusy, ci.IsBusy);

				return WBEM_S_NO_ERROR;
			}
			bValid = oSerialData.NextInstance();
		}
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\serverdefs0.h ===
//=================================================================

//

// ServerDefs0.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __WMI_P_SERVER_DEFS_ALREADY_INCLUDED
#define __WMI_P_SERVER_DEFS_ALREADY_INCLUDED
// header file needed because these definitions are scattered around 93 different header
// files, none of which are compatible with other header files...


#ifndef CNLEN
#define CNLEN 15
#endif

// This structure comes from svrapi.h, which can't be included since it conflicts with the 
// nt header.  Grrr.
#pragma pack(1)
struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char FAR *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\share.cpp ===
//=================================================================

//

// Share.CPP -- Logical Disk property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//
//=================================================================

#include "precomp.h"

#include <winioctl.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmshare.h>
#include <lmapibuf.h>
#include <assertbreak.h>
#ifdef NTONLY
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"					// CSACL class
#include "securitydescriptor.h"
#include "secureshare.h"
#include "Win32Securitydescriptor.h"
#endif

#include "wbemnetapi32.h"

#include "Share.h"

#include "sid.h"
#include "accessentrylist.h"
#include "accctrl.h"
#include "AccessRights.h"
#include "ObjAccessRights.h"
#include "winspool.h"



// Property set declaration
//=========================

Share  MyShareSet(PROPSET_NAME_SHARE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Share::Share
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Share :: Share (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Share::~Share
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

Share::~Share()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Share::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Share :: GetObject (

	CInstance* pInstance,
	long lFlags /*= 0L*/
)
{
	HRESULT hRetCode =  WBEM_E_FAILED;
	CNetAPI32 NetAPI ;

	if ( NetAPI.Init() == ERROR_SUCCESS )
	{
		CHString shareName;
		pInstance->GetCHString(IDS_Name, shareName);

#ifdef NTONLY
		{
			// The nt versions take a wchar

			hRetCode = GetShareInfoNT (

				NetAPI,
				shareName,
				pInstance
			);

		}
#endif
#ifdef WIN9XONLY
		{
#ifndef _UNICODE
			 shareName.MakeUpper();

			 // Win95 takes ansi

			 hRetCode = GetShareInfo95 (

				NetAPI,
				TOBSTRT(shareName),
				pInstance
			);
#endif
		}
#endif
	}

	return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Share::EnumerateInstances
 *
 *  DESCRIPTION : Calls appropriate Enum function
 *
 *  INPUTS      : MethodContext*  pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Share :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
#ifdef NTONLY
		return EnumerateInstancesNT ( pMethodContext ) ;
#endif
#ifdef WIN9XONLY
		return EnumerateInstances95 ( pMethodContext ) ;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : Share::EnumerateInstancesNT
 *
 *  DESCRIPTION : Enums shares for NT
 *
 *  INPUTS      : MethodContext*  pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT Share :: EnumerateInstancesNT (

	MethodContext *pMethodContext
)
{
    DWORD i;
    DWORD dwShareCount, dwTotalShareCount, dwResume, dwResume2;
    NET_API_STATUS nRetCode ;
    SHARE_INFO_0 *pShareInfo = NULL ;
	CNetAPI32 NetAPI ;
    if ( NetAPI.Init() != ERROR_SUCCESS )
	{
        return WBEM_E_FAILED ;
    }

    dwShareCount = dwTotalShareCount = dwResume = dwResume2 = 0;

    HRESULT hr = WBEM_S_NO_ERROR;
	
    try
	{
        nRetCode = NetAPI.NetShareEnum(
            NULL, 
            0, 
            (LPBYTE *) &pShareInfo,
		    MAX_PREFERRED_LENGTH, 
            &dwShareCount, 
            &dwTotalShareCount, 
            &dwResume);
	
        if(nRetCode == ERROR_SUCCESS && pShareInfo)
        {
			for(i = 0 ; i < dwShareCount && SUCCEEDED(hr); i++)
			{
       			CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false )  ;
				if(pInstance != NULL)
				{
                    if ( SUCCEEDED( GetShareInfoNT ( NetAPI , (WCHAR *)pShareInfo[i].shi0_netname , pInstance) ) )
					{
						hr = pInstance->Commit ();
					}
				}
			}
        }
	}
	catch ( ... )
	{
		if ( pShareInfo )
		{
			NetAPI.NetApiBufferFree ( pShareInfo ) ;
			pShareInfo = NULL ;
		}

		throw ;
	}

	if ( pShareInfo )
	{
		NetAPI.NetApiBufferFree ( pShareInfo ) ;
		pShareInfo = NULL ;
	}

	return hr;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Share::EnumerateInstances95
 *
 *  DESCRIPTION : Enums shares for 95
 *
 *  INPUTS      : MethodContext*  pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT Share :: EnumerateInstances95 (

	MethodContext*  pMethodContext
)
{
	DWORD i, dwSize;
	unsigned short dwShareCount, dwTotalShareCount, dwResume;
	NET_API_STATUS nRetCode ;
	share_info_1 *pShareInfo = NULL ;
	CNetAPI32 NetAPI ;
    HRESULT hRes = WBEM_S_NO_ERROR;

	if ( NetAPI.Init() != ERROR_SUCCESS)
	{
		return WBEM_E_FAILED ;
	}

	dwShareCount = dwTotalShareCount = dwResume = 0;
	try
	{
		// Calculate a buffer size, then ask for a bunch of them
		dwSize = 50 * (sizeof(SHARE_INFO_1) + (LM20_MAXCOMMENTSZ + 1));
		pShareInfo = (struct share_info_1 *) new BYTE[dwSize];

		if (pShareInfo != NULL)
		{
			nRetCode = NetAPI.NetShareEnum95 (

				NULL,
				1,
				(char FAR *) pShareInfo,
				dwSize,
				&dwShareCount,
				&dwTotalShareCount
			) ;
		}
		else
		{
			LogErrorMessage(IDS_LogOutOfMemory);
			nRetCode = ERROR_OUTOFMEMORY;
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

	   // As near as I can tell, there is no way to loop.  You get them all or you don't.
	   // So, if the buffer wasn't big enough, re-size it and try again.

		if (nRetCode == ERROR_MORE_DATA)
		{
			dwSize = dwTotalShareCount * (sizeof(SHARE_INFO_1) + (LM20_MAXCOMMENTSZ + 1));
            delete [] pShareInfo;
            pShareInfo = (struct share_info_1 *) new BYTE [dwSize];

			if ( pShareInfo != NULL )
			{
				nRetCode = NetAPI.NetShareEnum95 (

					NULL,
					1,
					(char FAR *) pShareInfo,
					dwSize,
					&dwShareCount,
					&dwTotalShareCount
				) ;
			}
			else
			{
				nRetCode = ERROR_OUTOFMEMORY;
			}
		}

	   // If there is still something wrong, forget it, we're outta here.

		if(!nRetCode)
		{
		  // Walk the shares and populate instances

			for(i = 0 ; i < dwShareCount && SUCCEEDED(hRes); i++)
			{
				CInstancePtr pInstance ( CreateNewInstance(pMethodContext), false ) ;
				if(pInstance != NULL)
				{
					if ( SUCCEEDED(GetShareInfo95(NetAPI, (CHAR *)pShareInfo[i].shi1_netname, pInstance)))
					{
						hRes = pInstance->Commit ();
					}
				}
			}

			//hRes = WBEM_S_NO_ERROR ;
		}

		if ( nRetCode == ERROR_OUTOFMEMORY )
		{
			hRes = WBEM_E_OUT_OF_MEMORY ;
		}
		// If the server isn't started, there just aren't any instances.
		else if ((nRetCode == NERR_ServerNotStarted) || (nRetCode == NERR_Success))
		{
			hRes = WBEM_S_NO_ERROR;
		}
		// Something else went wrong
		else
		{
			hRes = WBEM_E_FAILED ;
		}
	}
	catch ( ... )
	{
		if (pShareInfo)
		{
			delete [] pShareInfo;
			pShareInfo = NULL ;

		}

		throw ;
	}

	if (pShareInfo)
	{
		delete [] pShareInfo;
		pShareInfo = NULL ;

	}

	return hRes;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Share::GetShareInfoNT
 *
 *  DESCRIPTION : Loads SHARE_INFO struct w/property values
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : You may wonder why we don't just call NetShareEnum with 502
 *                and populate from there.  There are two reasons.  One,
 *                structuring it this way makes GetObject easier.  Two, 502
 *                doesn't always seem to return all the shares. <sigh>
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT Share :: GetShareInfoNT (

	CNetAPI32 &NetAPI,
	const WCHAR *pShareName,
	CInstance* pInstance
)
{
	SHARE_INFO_502 *pShareInfo502 = NULL;
	SHARE_INFO_1	*pShareInfo1 = NULL;
	NET_API_STATUS dwRetCode;

	// yes, we're casting away the const on shareName
	// yes, we think we know what we're doing....

	// First get the basic share information with level 1 since no rights
	// are needed.
	try
	{
		dwRetCode = NetAPI.NetShareGetInfo (

			NULL,
			(LPTSTR) pShareName,
			1,
			(LPBYTE *) &pShareInfo1
		) ;

		if (NERR_Success != dwRetCode )
		{
			return WinErrorToWBEMhResult ( dwRetCode ) ;
		}

		pInstance->SetWCHARSplat(IDS_Name, (WCHAR *) pShareInfo1->shi1_netname);

		if ( wcslen((WCHAR *) pShareInfo1->shi1_remark ) == 0)
		{
			pInstance->SetWCHARSplat(IDS_Caption, (WCHAR *) pShareInfo1->shi1_netname);
		}
		else
		{
			pInstance->SetWCHARSplat(IDS_Caption, (WCHAR *) pShareInfo1->shi1_remark);
		}

		pInstance->SetWCHARSplat(IDS_Description, (WCHAR *) pShareInfo1->shi1_remark);
		pInstance->SetCharSplat(_T("Status"), _T("OK"));

		// Now try to get the advanced properties using the admin-level 502.
		dwRetCode = NetAPI.NetShareGetInfo (

			NULL,
			(LPTSTR) pShareName,
			502,
			(LPBYTE *) &pShareInfo502
		) ;

		if (dwRetCode == NERR_Success)
		{
			pInstance->SetWCHARSplat(_T("Path"), (WCHAR *)pShareInfo502->shi502_path);
			pInstance->SetDWORD(_T("Type"), pShareInfo502->shi502_type);

			if (pShareInfo502->shi502_max_uses == -1)
			{
				pInstance->Setbool(IDS_AllowMaximum, true);
			}
			else
			{
				pInstance->Setbool(IDS_AllowMaximum, false);
				pInstance->SetDWORD(IDS_MaximumAllowed, (DWORD) pShareInfo502->shi502_max_uses);
			}
		}
	}
	catch ( ... )
	{
		if ( pShareInfo502 )
		{
			NetAPI.NetApiBufferFree ( pShareInfo502 ) ;
			pShareInfo502 = NULL ;
		}

		if ( pShareInfo1 )
		{
			NetAPI.NetApiBufferFree ( pShareInfo1 ) ;
			pShareInfo502 = NULL ;
		}

		throw ;
	}

	if ( pShareInfo502 )
	{
		NetAPI.NetApiBufferFree ( pShareInfo502 ) ;
		pShareInfo502 = NULL ;
	}

	if ( pShareInfo1 )
	{
		NetAPI.NetApiBufferFree ( pShareInfo1 ) ;
		pShareInfo502 = NULL ;
	}

	return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Share::GetShareInfo95
 *
 *  DESCRIPTION : Loads SHARE_INFO struct w/property values
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : You may wonder why we don't just call NetShareEnum with 50
 *                and populate from there.  There are two reasons.  One,
 *                structuring it this way makes GetObject easier.  Two, 50
 *                doesn't always seem to return all the shares. <sigh>
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT Share :: GetShareInfo95 (

	CNetAPI32 &NetAPI,
	const char *pShareName,
	CInstance* pInstance
)
{
    HRESULT hRetCode = WBEM_E_FAILED;
#ifndef _UNICODE
    share_info_50 *pShareInfo;
    NET_API_STATUS dwRetCode ;
    unsigned short shReqSize;
    DWORD dwSize;

    // Fixed structure + (comment + null) + (path + drive + null) + fudge
    dwSize = sizeof(share_info_50) + (LM20_MAXCOMMENTSZ + 1) + (PATHLEN + 3) + 20;
	try
	{
		pShareInfo = (share_info_50 *) new BYTE[dwSize];

		if ( pShareInfo == NULL )
		{
			LogErrorMessage(IDS_LogOutOfMemory);
			dwRetCode = ERROR_OUTOFMEMORY;
			hRetCode = WBEM_E_OUT_OF_MEMORY;
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
		else
		{
			// Get the detailed info
			dwRetCode = NetAPI.NetShareGetInfo95 (

				NULL,
				(char *)pShareName,
				50,
				(char *)pShareInfo,
				dwSize,
				&shReqSize
			) ;
		}

		// This shouldn't ever happen, but if it does, they give use the size, so what the heck...
		if (dwRetCode == NERR_BufTooSmall)
		{
           delete [] pShareInfo;
		   pShareInfo = (share_info_50 *) new BYTE [shReqSize];

		   dwRetCode = NetAPI.NetShareGetInfo95 (

				NULL,
				(char *)pShareName,
				50,
				(char *)pShareInfo,
				shReqSize,
				&shReqSize
			) ;
		}

		if(dwRetCode == NERR_Success)
		{
			hRetCode = WBEM_S_NO_ERROR;

			pInstance->SetCharSplat(IDS_Name, pShareInfo->shi50_netname);

			if ((pShareInfo->shi50_remark == NULL) || (_tcslen(pShareInfo->shi50_remark) == 0))
			{
				pInstance->SetCharSplat(IDS_Caption, pShareInfo->shi50_netname);
			}
			else
			{
				pInstance->SetCharSplat(IDS_Caption, pShareInfo->shi50_remark);
			}
			pInstance->SetCharSplat(IDS_Description, pShareInfo->shi50_remark);
			pInstance->SetCharSplat(L"Status", L"OK");
			pInstance->SetCharSplat(L"Path", pShareInfo->shi50_path);
			pInstance->SetDWORD(L"Type", pShareInfo->shi50_type);
		}
		else
		{
			if ((dwRetCode == NERR_NetNameNotFound) || (dwRetCode == NERR_ShareNotFound) || (dwRetCode == NERR_ServerNotStarted) )
			{
				hRetCode = WBEM_E_NOT_FOUND;
			}
		}

	#endif
	}
	catch ( ... )
	{
		if ( pShareInfo != NULL )
		{
			delete [] pShareInfo;
			pShareInfo = NULL ;
		}

		throw ;
	}

	if ( pShareInfo != NULL )
	{
		delete [] pShareInfo;
		pShareInfo = NULL ;
	}

	return hRetCode;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Share :: DeleteInstance (

	const CInstance &a_Instance,
	long a_Flags /*= 0L*/
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_Status = STATUS_SUCCESS ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_Name ;
	if ( a_Instance.GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( METHOD_ARG_NAME_NAME , t_Name ) && ! t_Name.IsEmpty () )
			{

				CNetAPI32 t_NetAPI ;

				if( ( t_Result = t_NetAPI.Init() ) == ERROR_SUCCESS )
				{
					NET_API_STATUS t_ShareStatus = NERR_Success;
#ifdef NTONLY
                    // If is a printer share, we have some extra work...
                    // In order to get the type property, we need to 
                    // get a fully flushed out instance (the one we
                    // have here via a DeleteInstanceAsynch call only
                    // has the object path).  We need to do this before
                    // the call to NetShareDel, as we do a GetObject
                    // below, which will fail if we have already deleted
                    // the printer.  Furthermore, as this acutally
                    // deletes the share from Netapi's perspective as
                    // well, we don't need to call that api we do it this 
                    // way.
                    CHString chstr__PATH;
                    DWORD dwType = 0;
                    chstr__PATH.Format(L"Win32_Share.Name=\"%s\"",(LPCWSTR)t_Name); 
                    CInstancePtr pinstPrinter;
                    if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(
                        chstr__PATH, 
                        &pinstPrinter, 
                        a_Instance.GetMethodContext())))
                    {
                        pinstPrinter->GetDWORD(L"Type", dwType);

                        if(dwType == STYPE_PRINTQ)
                        {
                            HANDLE hPrinter = INVALID_HANDLE_VALUE;

                            try
                            {
                                PRINTER_DEFAULTS pd;
                                ZeroMemory(&pd, sizeof(PRINTER_DEFAULTS));
                                pd.DesiredAccess = PRINTER_ALL_ACCESS;

                                if(::OpenPrinter(
                                    _bstr_t(t_Name), 
                                    &hPrinter, 
                                    &pd))
                                {
                                    PPRINTER_INFO_2 ppi2 = NULL;
                                    DWORD dwNeeded;

                                    if(!::GetPrinter(
                                        hPrinter, 
                                        2, 
                                        NULL, 
                                        0, 
                                        &dwNeeded) && 
                                        ERROR_INSUFFICIENT_BUFFER == ::GetLastError())
                                    {
                                        CSmartBuffer pBuff(dwNeeded);
                                
                                        if(::GetPrinter(
                                            hPrinter, 
                                            2, 
                                            pBuff, 
                                            dwNeeded, 
                                            &dwNeeded))
                                        {
                                            ppi2 = (PPRINTER_INFO_2)(LPBYTE) pBuff;
                                            ppi2->Attributes = ppi2->Attributes & (~PRINTER_ATTRIBUTE_SHARED);
                                            if(!::SetPrinter(
                                                hPrinter,
                                                2,
                                                pBuff,
                                                0))
                                            {
                                                t_Result = WinErrorToWBEMhResult(::GetLastError());
                                            }
                                        }
                                        else
                                        {
                                            t_Result = WinErrorToWBEMhResult(::GetLastError());
                                        }
                                    }
                                    else
                                    {
                                        t_Result = WinErrorToWBEMhResult(::GetLastError());  
                                    }
                                
                                    ::ClosePrinter(hPrinter);
                                    hPrinter = INVALID_HANDLE_VALUE;
                                }
                                else
                                {
                                    t_Result = WinErrorToWBEMhResult(::GetLastError());
                                }
                            }
                            catch(...)
                            {
                                if(hPrinter != INVALID_HANDLE_VALUE)
                                {
                                    ::ClosePrinter(hPrinter);
                                    hPrinter = INVALID_HANDLE_VALUE;
                                }
                                throw;
                            }
                        }
                    }

                    // So now do the NetShareDel.
                    if(dwType != STYPE_PRINTQ)
                    {
						_bstr_t t_BStr_Name ( t_Name.AllocSysString (), false )  ;

						t_ShareStatus = t_NetAPI.NetShareDel (

							NULL ,
							(LPTSTR) (LPCTSTR) t_BStr_Name ,
							0
						) ;
					}


#endif
#ifdef WIN9XONLY
					{
						t_Name.MakeUpper() ;

						_bstr_t t_BStr_Name ( t_Name ) ;

						t_ShareStatus = t_NetAPI.NetShareDel95 (

							NULL ,
							( char* ) t_BStr_Name ,
							0
						) ;
					}
#endif

					if ( t_ShareStatus != NERR_Success )
					{
						t_Result = GetShareResultCode ( t_ShareStatus ) ;
					}
				}
			}
			else
			{
// Zero Length string

				t_Result = WBEM_E_TYPE_MISMATCH ;
			}
		}
		else
		{
			t_Result = WBEM_E_TYPE_MISMATCH ;
		}
	}
	else
	{
		t_Result = WBEM_E_TYPE_MISMATCH ;
	}

	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Share ::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Share::ExecMethod (

	const CInstance& a_Instance,
	const BSTR a_MethodName ,
	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	long a_Flags
)
{
	if ( ! a_OutParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

   // Do we recognize the method?

	if ( _wcsicmp ( a_MethodName , METHOD_NAME_CREATE ) == 0 )
	{
		return ExecCreate ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_DELETE ) == 0 )
	{
		return ExecDelete ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_SETSHAREINFO ) == 0 )
	{
		return ExecSetShareInfo ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_GETACCESSMASK ) == 0 )
	{
		return ExecGetShareAccessMask ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}


	return WBEM_E_INVALID_METHOD;
}

DWORD Share :: GetShareErrorCode ( DWORD a_Error )
{
	DWORD t_Status ;
	switch ( a_Error )
	{
		case ERROR_INVALID_NAME:
		{
			t_Status = STATUS_INVALID_NAME ;
		}
		break ;

		case ERROR_INVALID_LEVEL:
		{
			t_Status = STATUS_INVALID_LEVEL;
		}
		break ;

		case ERROR_ACCESS_DENIED:
		{
			t_Status = STATUS_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			t_Status = STATUS_INVALID_PARAMETER ;
		}
		break;

		//gone with the w...
		//case NERR_ShareExists:
		case NERR_DuplicateShare:
		{
			t_Status = STATUS_DUPLICATE_SHARE ;
		}
		break ;

		case NERR_RedirectedPath:
		{
			t_Status = STATUS_REDIRECTED_PATH ;
		}
		break ;

		case NERR_UnknownDevDir:
		case ERROR_BAD_NETPATH://win95
		case ERROR_FILE_NOT_FOUND: // NetShareAdd returns this if dir not present
		case ERROR_INVALID_PRINTER_NAME:// NetShareAdd returns this if printer name is not correct
		{
			t_Status = STATUS_UNKNOWN_DEVICE_OR_DIRECTORY ;
		}
		break ;

		case NERR_ShareNotFound:
		case NERR_NetNameNotFound:
		{
			t_Status = STATUS_NET_NAME_NOT_FOUND ;
		}
		break ;

		default:
		{
			t_Status = STATUS_UNKNOWN_FAILURE ;
		}
		break ;
	}

	return t_Status ;
}

HRESULT Share :: GetShareResultCode ( DWORD a_Error )
{
	HRESULT t_Result ;
	switch ( a_Error )
	{
		case ERROR_ACCESS_DENIED:
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
		break;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}

typedef void (*GETDESCRIPTOR)(
	CInstance* pInstance, PSECURITY_DESCRIPTOR *ppDescriptor);


HRESULT Share :: CheckShareCreation (

	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	DWORD &a_Status
)
{
	HRESULT t_Result = S_OK ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_Name ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_InParams->GetCHString ( METHOD_ARG_NAME_NAME , t_Name ) && ! t_Name.IsEmpty () )
			{
			}
			else
			{
// Zero Length string

				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CHString t_Path ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_PATH , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_InParams->GetCHString ( METHOD_ARG_NAME_PATH , t_Path ) && ! t_Path .IsEmpty () )
			{

#ifdef WIN9XONLY
				// The older 9x NetApi32 does not bother to check that
				// the directory actually exists.
				bstr_t t_bstrPath( t_Path ) ;

				if( 0xFFFFFFFF == GetFileAttributes( t_bstrPath ) )
				{
					DWORD t_dwError = GetLastError() ;

					a_Status = STATUS_UNKNOWN_DEVICE_OR_DIRECTORY ;
					return t_Result ;
				}
#endif
			}
			else
			{
// Zero Length string

				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_CommentSpecified = false ;
	CHString t_Comment ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_COMMENT , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_CommentSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_COMMENT , t_Comment ) )
				{
					t_CommentSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_PasswordSpecified = false ;
	CHString t_Password ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_PASSWORD , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_PasswordSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_PASSWORD , t_Password ) )
				{
					t_PasswordSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	DWORD t_ShareType ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_TYPE , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_Share ;
			if ( a_InParams->GetDWORD ( METHOD_ARG_NAME_TYPE , t_Share ) )
			{
				if ( ( t_Share <= STYPE_IPC ) ||
					( t_Share >= (STYPE_DISKTREE + STYPE_SPECIAL) && t_Share <= (STYPE_IPC + STYPE_SPECIAL) ) )
				{
					t_ShareType = t_Share ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	DWORD t_Permissions = 0 ;

	DWORD t_MaximumAllowed = SHI_USES_UNLIMITED ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_MAXIMUMALLOWED , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetDWORD ( METHOD_ARG_NAME_MAXIMUMALLOWED , t_MaximumAllowed ) )
				{
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CInstancePtr t_EmbeddedObject;

	bool t_AccessSpecified = true ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_ACCESS , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_UNKNOWN || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_AccessSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetEmbeddedObject ( METHOD_ARG_NAME_ACCESS , &t_EmbeddedObject , a_InParams->GetMethodContext () ) )
				{
					t_AccessSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	PSECURITY_DESCRIPTOR pSD = NULL ;

	if ( t_AccessSpecified )
	{
		CHString t_ClassProperty ( L"__CLASS" ) ;
		if ( t_EmbeddedObject->GetStatus ( t_ClassProperty , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR ) )
			{
				CHString t_Class ;
				if ( t_EmbeddedObject->GetCHString ( t_ClassProperty , t_Class ) )
				{
					if ( t_Class.CompareNoCase ( PROPSET_NAME_SECURITYDESCRIPTOR ) != 0 )
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
					else // now get the SD
					{
#ifdef NTONLY
                        GetDescriptorFromMySecurityDescriptor(t_EmbeddedObject, &pSD);
#endif
					}
				}
			}
			else
			{
				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
	}

	if ( a_Status == STATUS_SUCCESS )
	{

#ifdef NTONLY
		{
			try
			{
				SHARE_INFO_502 t_ShareInfo ;

				_bstr_t t_BStr_Name ( t_Name.AllocSysString (), false ) ;
				_bstr_t t_BStr_Path ( t_Path.AllocSysString (), false ) ;
				_bstr_t t_BStr_Comment = t_CommentSpecified ? t_Comment : ( ( PWCHAR ) NULL ) ;
				_bstr_t t_BStr_Password = t_PasswordSpecified ? t_Password  : ( ( PWCHAR ) NULL ) ;

				t_ShareInfo.shi502_netname = ( TCHAR * ) t_BStr_Name ;
				t_ShareInfo.shi502_type = t_ShareType ;
				t_ShareInfo.shi502_remark = ( TCHAR * ) t_BStr_Comment ;
				t_ShareInfo.shi502_permissions = t_Permissions ;
				t_ShareInfo.shi502_max_uses = t_MaximumAllowed ;
				t_ShareInfo.shi502_current_uses = 0 ;
				t_ShareInfo.shi502_path = ( TCHAR * ) t_BStr_Path ;
				t_ShareInfo.shi502_passwd = ( TCHAR * ) t_BStr_Password ;
				t_ShareInfo.shi502_reserved = 0 ;
				t_ShareInfo.shi502_security_descriptor = pSD ;

				DWORD t_ErrorIndex = 0 ;

				NET_API_STATUS t_ShareStatus ;

				CNetAPI32 t_NetAPI ;

				if( ( t_Result = t_NetAPI.Init() ) == ERROR_SUCCESS )
				{
					t_ShareStatus = t_NetAPI.NetShareAdd (

						NULL ,
						502 ,
						( LPBYTE ) & t_ShareInfo ,
						& t_ErrorIndex
					) ;

					if ( t_ShareStatus != NERR_Success )
					{
						a_Status = GetShareErrorCode ( t_ShareStatus ) ;
					}
				}
			}
			catch ( ... )
			{
				if ( pSD )
				{
					free( pSD ) ;
					pSD = NULL ;
				}

				throw ;
			}

			if ( pSD )
			{
				free( pSD ) ;
				pSD = NULL ;
			}
		}
#endif
#ifdef WIN9XONLY
		{
			NET_API_STATUS t_ShareStatus ;
			share_info_50 stShareInfo ;

			_tcscpy(stShareInfo.shi50_netname, TOBSTRT(t_Name)) ;
			stShareInfo.shi50_type = (char) t_ShareType ;

			/* These flags are relevant for share-level security on VSERVER
			* When operating with user-level security, use SHI50F_FULL - the actual
			* access rights are determined by the NetAccess APIs.
			*/
			stShareInfo.shi50_flags = 0x0001 | 0x0100 ; // SHI50F_RDONLY | SHI50F_PERSIST in svrapi.h

			if(t_Permissions )
			{
				stShareInfo.shi50_flags = t_Permissions ;
			}

			bstr_t t_bstrComment( t_Comment ) ;

			stShareInfo.shi50_remark= t_CommentSpecified ? (char*)t_bstrComment : NULL ;

			t_Path.MakeUpper();

			bstr_t t_bstrPath( t_Path ) ;

			stShareInfo.shi50_path = (char*)t_bstrPath;

			//only for share-level security on 95
			ZeroMemory(stShareInfo.shi50_rw_password,SHPWLEN+1) ;
			ZeroMemory(stShareInfo.shi50_ro_password,SHPWLEN+1) ;

			if(t_PasswordSpecified)
			{
				_tcscpy(stShareInfo.shi50_rw_password, TOBSTRT(t_Password));
				_tcscpy(stShareInfo.shi50_ro_password, TOBSTRT(t_Password));
			}

			CNetAPI32 t_NetAPI ;

			if( ( t_Result = t_NetAPI.Init() ) == ERROR_SUCCESS )
			{
				t_ShareStatus = t_NetAPI.NetShareAdd95 (

					NULL ,
					50 ,
					( const char FAR * ) &stShareInfo ,
					sizeof(share_info_50)
				) ;
			}

            if ( t_ShareStatus != NERR_Success )
			{
				a_Status = GetShareErrorCode ( t_ShareStatus ) ;
			}
		}
#endif
	}

	return t_Result ;
}

HRESULT Share :: CheckShareModification (

	const CInstance &a_Instance ,
	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	DWORD &a_Status
)
{
	HRESULT t_Result = S_OK ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_Name ;
	if ( a_Instance.GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( METHOD_ARG_NAME_NAME , t_Name ) && ! t_Name.IsEmpty () )
			{
			}
			else
			{
// Zero Length string

				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_CommentSpecified = false ;
	CHString t_Comment ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_COMMENT , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_CommentSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_COMMENT , t_Comment ) )
				{
					t_CommentSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	DWORD t_Permissions = 0 ;

	DWORD t_MaximumAllowed = 0 ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_MAXIMUMALLOWED , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetDWORD ( METHOD_ARG_NAME_MAXIMUMALLOWED , t_MaximumAllowed ) )
				{
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CInstancePtr t_EmbeddedObject;

	bool t_AccessSpecified = true ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_ACCESS , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_UNKNOWN || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_AccessSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetEmbeddedObject ( METHOD_ARG_NAME_ACCESS , &t_EmbeddedObject , a_InParams->GetMethodContext () ) )
				{
					t_AccessSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	PSECURITY_DESCRIPTOR pSD = NULL ;

	if ( t_AccessSpecified )
	{
		CHString t_ClassProperty ( L"__CLASS" ) ;
		if ( t_EmbeddedObject->GetStatus ( t_ClassProperty , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR ) )
			{
				CHString t_Class ;
				if ( t_EmbeddedObject->GetCHString ( t_ClassProperty , t_Class ) )
				{
					if ( t_Class.CompareNoCase ( PROPSET_NAME_SECURITYDESCRIPTOR ) != 0 )
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
					else // now get the SD
					{
#ifdef NTONLY
                        GetDescriptorFromMySecurityDescriptor(t_EmbeddedObject, &pSD);
#endif
					}
				}
			}
			else
			{
				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
	}

    if ( a_Status == STATUS_SUCCESS )
	{
#ifdef NTONLY
		{
			try
			{
				SHARE_INFO_502 t_ShareInfo ;

				bstr_t t_BStr_Name ( t_Name.AllocSysString (), false ) ;
				bstr_t t_BStr_Comment = t_CommentSpecified ? t_Comment : ( ( PWCHAR ) NULL ) ;

				t_ShareInfo.shi502_netname = ( TCHAR * ) t_BStr_Name ;
				t_ShareInfo.shi502_type = 0 ;
				t_ShareInfo.shi502_remark = ( TCHAR * ) t_BStr_Comment ;
				t_ShareInfo.shi502_permissions = t_Permissions ;
				t_ShareInfo.shi502_max_uses = t_MaximumAllowed ;
				t_ShareInfo.shi502_current_uses = 0 ;
				t_ShareInfo.shi502_path = 0 ;
				t_ShareInfo.shi502_passwd = NULL ;
				t_ShareInfo.shi502_reserved = 0 ;
				t_ShareInfo.shi502_security_descriptor = pSD ;

				DWORD t_ErrorIndex = 0 ;

				CNetAPI32 t_NetAPI ;
				if( ( t_Result = t_NetAPI.Init() ) == ERROR_SUCCESS )
				{
					NET_API_STATUS t_ShareStatus ;

					t_ShareStatus = t_NetAPI.NetShareSetInfo (

						NULL ,
						( LPTSTR ) t_BStr_Name ,
						502 ,
						( LPBYTE ) & t_ShareInfo ,
						& t_ErrorIndex
					) ;

					if ( t_ShareStatus != NERR_Success )
					{
						a_Status = GetShareErrorCode ( t_ShareStatus ) ;
					}
				}
			}
			catch ( ... )
			{
				if ( pSD )
				{
					free( pSD ) ;
					pSD = NULL ;
				}
				throw ;
			}

			if ( pSD )
			{
				free( pSD ) ;
				pSD = NULL ;
			}
		}
#endif
#ifdef WIN9XONLY
		{
			NET_API_STATUS t_ShareStatus ;

			CNetAPI32 t_NetAPI ;

			if( ( t_Result = t_NetAPI.Init() ) == ERROR_SUCCESS )
			{
                char buff[sizeof(share_info_50) + MAXCOMMENTSZ + PATHLEN + 3];
			    share_info_50 *stShareInfo = (share_info_50 *)&buff;

                // NetShareGetInfo insists on upper case
                t_Name.MakeUpper();

                bstr_t t_bstrNameBuf( t_Name ) ;
                unsigned short t_shTotalAvail;

                // Need to get the current values, and only overwrite what we want
                // to change
                t_ShareStatus = t_NetAPI.NetShareGetInfo95(

                    NULL,
                    (char *)t_bstrNameBuf,
                    50,
                    buff,
                    sizeof(buff),
                    &t_shTotalAvail
                );

                if (t_ShareStatus == NERR_Success)
                {
    			    bstr_t t_bstrComment( t_Comment ) ;

    			    stShareInfo->shi50_remark = t_CommentSpecified ? (char*)t_bstrComment : NULL ;

				    t_ShareStatus = t_NetAPI.NetShareSetInfo95 (

					    NULL ,
					    (char*) t_bstrNameBuf,
					    50,
					    buff ,
					    sizeof(buff) ,
					    PARMNUM_ALL
				    ) ;
                }

			}

            if ( t_ShareStatus != NERR_Success )
			{
				a_Status = GetShareErrorCode ( t_ShareStatus ) ;
			}
		}
#endif

	} //if ( a_Status == STATUS_SUCCESS )

	return t_Result ;

}

HRESULT Share :: ExecCreate (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_Status = STATUS_SUCCESS ;

	if ( a_InParams && a_OutParams )
	{
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CheckShareCreation (

				a_InParams ,
				a_OutParams ,
				t_Status
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

HRESULT Share :: ExecDelete (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_Status = STATUS_SUCCESS ;

	if ( a_OutParams )
	{
		bool t_Exists ;
		VARTYPE t_Type ;

		CHString t_Name ;
		if ( a_Instance.GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR ) )
			{
				if ( a_Instance.GetCHString ( METHOD_ARG_NAME_NAME , t_Name ) && ! t_Name.IsEmpty () )
				{
					_bstr_t t_BStr_Name ( t_Name.AllocSysString (), false ) ;

					CNetAPI32 t_NetAPI ;

					if( ( t_Result = t_NetAPI.Init() ) == ERROR_SUCCESS )
					{
						NET_API_STATUS t_ShareStatus ;
	#ifdef NTONLY
						{
							t_ShareStatus = t_NetAPI.NetShareDel (

								NULL ,
								( LPTSTR ) t_BStr_Name ,
								0
							) ;
						}
	#endif
	#ifdef WIN9XONLY
						{
							t_Name.MakeUpper();

							bstr_t t_bstrNameUpper( t_Name ) ;

							t_ShareStatus = t_NetAPI.NetShareDel95 (

								NULL ,
								(char*) t_bstrNameUpper,
								0
							) ;
						}
	#endif

						if ( t_ShareStatus != NERR_Success )
						{
							t_Status = GetShareErrorCode ( t_ShareStatus ) ;
						}
					}
				}
				else
				{
	// Zero Length string

					t_Status = STATUS_INVALID_PARAMETER ;

				}
			}
			else
			{
				t_Status = STATUS_INVALID_PARAMETER ;
			}
		}
		else
		{
			t_Status = STATUS_INVALID_PARAMETER ;
			return WBEM_E_PROVIDER_FAILURE ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

HRESULT Share :: ExecSetShareInfo (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_Status = STATUS_SUCCESS ;

	if ( a_InParams && a_OutParams )
	{
		t_Result = CheckShareModification (

			a_Instance ,
			a_InParams ,
			a_OutParams ,
			t_Status
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

HRESULT Share :: ExecGetShareAccessMask (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_Name ;
	if ( a_Instance.GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( METHOD_ARG_NAME_NAME , t_Name ) && ! t_Name.IsEmpty () )
			{
			}
			else
			{
// Zero Length string
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if (SUCCEEDED(t_Result))
	{
		if ( a_OutParams )
		{
			t_Result = WBEM_E_FAILED ;
			ACCESS_MASK t_AccessMask;
			CObjAccessRights t_coar(t_Name, SE_LMSHARE, true);
			if(t_coar.GetError() == ERROR_SUCCESS)
			{
				if(t_coar.GetEffectiveAccessRights(&t_AccessMask) == ERROR_SUCCESS)
				{
					if (SUCCEEDED(a_OutParams->SetDWORD( METHOD_ARG_NAME_RETURNVALUE, t_AccessMask )))
					{
						t_Result = S_OK ;
					}
				}
			}
			else if(t_coar.GetError() == ERROR_ACCESS_DENIED)
			{
				if (SUCCEEDED(a_OutParams->SetDWORD( METHOD_ARG_NAME_RETURNVALUE, 0L )))
				{
					t_Result = S_OK ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\service.h ===
//=================================================================

//

// Service.h -- Service property set provider (Windows NT only)

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_SERVICE			L"Win32_Service"

#define PROPERTY_VALUE_STATE_RUNNING			L"Running"
#define PROPERTY_VALUE_STATE_PAUSED				L"Paused"
#define PROPERTY_VALUE_STATE_STOPPED			L"Stopped"

// Get/set function protos
//========================

///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
//                                                                                   //
//                           PROPERTY SET DEFINITION                                 //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

class CWin32Service:public Win32_BaseService 
{
public:

        // Constructor/destructor
        //=======================

	CWin32Service (

		LPCWSTR name, 
		LPCWSTR pszNamespace
	) ;

	~CWin32Service() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *pInstance, 
		long lFlags,
        CFrameworkQuery& pQuery
	);

	HRESULT EnumerateInstances (

		MethodContext *pMethodContext, 
		long lFlags = 0L
	);

	HRESULT ExecQuery (

		MethodContext *pMethodContext, 
		CFrameworkQuery& pQuery, 
		long lFlags /*= 0L*/ 
	);

	HRESULT	PutInstance ( 

		const CInstance &a_Instance, 
		long lFlags /*= 0L*/ 
	) ;

private:

    CHPtrArray m_ptrProperties;

        // Utility function(s)
        //====================

	HRESULT RefreshInstanceNT (

		CInstance *pInstance,
        DWORD dwProperties
	) ;

	HRESULT RefreshInstanceWin95 (

		CInstance *pInstance
	) ;

	HRESULT AddDynamicInstancesNT (

		MethodContext *pMethodContext, 
		DWORD dwProperties
	) ;

	HRESULT AddDynamicInstancesWin95 (

		MethodContext *pMethodContext
	) ;

	HRESULT LoadPropertyValuesNT (

		SC_HANDLE hDBHandle, 
		LPCTSTR szServiceName, 
		CInstance *pInstance, 
		DWORD dwProperties,
		CAdvApi32Api *a_pAdvApi32
	) ;

	void LoadPropertyValuesWin95 (

		LPCTSTR szServiceName, 
		CInstance *pInstance
	);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\serialportcfg.h ===
//=================================================================

//

// SerialPortCfg.h -- Serial port configuration set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/24/97    jennymc        Moved to new framework
//
//=================================================================

#define PROPSET_NAME_SERIALCONFIG L"Win32_SerialPortConfiguration"

class CWin32SerialPortConfiguration : public Provider{

    public:

        // Constructor/destructor
        //=======================

        CWin32SerialPortConfiguration(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32SerialPortConfiguration() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);


        // Utility
        //========
    private:
        // Utility function(s)
        //====================
        HRESULT LoadPropertyValues(CInstance *pInstance,CHString &sPortName, bool bIsMouse) ;
		BOOL TryToFindNTCommPort(DWORD dwPort, CHString& strSerialPort, bool& bIsMouse); 
        BOOL TryToFindNTCommPortFriendlyName();
        static LONG CountCommas(LPCWSTR szText);
        static BOOL GetDCBPropsViaIni(LPCTSTR szPort, DCB &dcb);

		HRESULT hLoadWmiSerialData( CInstance* pInstance );
		HRESULT GetWMISerialInfo(	CInstance* pInstance,
									CWdmInterface& rWdm, 
									CHString& chsName, 
									CHString& chsNameInstanceName );
} ;

// WMI 
typedef struct _MSSerial_CommInfo
{
	DWORD	BaudRate;
	DWORD	BitsPerByte;
	DWORD	Parity;
	BYTE	ParityCheckEnable;
	DWORD	StopBits;
	DWORD	XoffCharacter;
	DWORD	XoffXmitThreshold;
	DWORD	XonCharacter;
	DWORD	XonXmitThreshold;
	DWORD	MaximumBaudRate;
	DWORD	MaximumOutputBufferSize;
	DWORD	MaximumInputBufferSize;
	BYTE	Support16BitMode;		
	BYTE	SupportDTRDSR;
	BYTE	SupportIntervalTimeouts;
	BYTE	SupportParityCheck;
	BYTE	SupportRTSCTS;
	BYTE	SupportXonXoff;
	BYTE	SettableBaudRate;
	BYTE	SettableDataBits;
	BYTE	SettableFlowControl;
	BYTE	SettableParity;
	BYTE	SettableParityCheck;
	BYTE	SettableStopBits;
	BYTE	IsBusy;
} MSSerial_CommInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\service.cpp ===
//=================================================================

//

// Service.CPP --Service property set provider (Windows NT only)

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

#include "precomp.h"
#include <winsvc.h>

#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include <frqueryex.h>

#include "bservice.h"
#include "Service.h"
#include "computersystem.h"

#define BIT_ALL_PROPERTIES          0xffffffff
#define BIT_Name                    0x00000001
#define BIT_State                   0x00000002
#define BIT_Started                 0x00000004
#define BIT_AcceptStop              0x00000008
#define BIT_AcceptPause             0x00000010
#define BIT_ProcessId               0x00000020
#define BIT_ExitCode                0x00000040
#define BIT_ServiceSpecificExitCode 0x00000080
#define BIT_CheckPoint              0x00000100
#define BIT_WaitHint                0x00000200
#define BIT_Status                  0x00000400
#define BIT_Caption                 0x00000800
#define BIT_DisplayName             0x00001000
#define BIT_Description             0x00002000
#define BIT_TagId                   0x00004000
#define BIT_ServiceType             0x00008000
#define BIT_DesktopInteract         0x00010000
#define BIT_StartMode               0x00020000
#define BIT_ErrorControl            0x00040000
#define BIT_PathName                0x00080000
#define BIT_StartName               0x00100000
#define BIT_CreationClassName       0x00200000
#define BIT_SystemCreationClassName 0x00400000
#define BIT_SystemName              0x00800000


// Property set declaration
//=========================

CWin32Service MyServiceSet ( PROPSET_NAME_SERVICE , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::CWin32Service
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Service::CWin32Service (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Win32_BaseService ( name , pszNamespace )
{
    m_ptrProperties.SetSize(24);

    m_ptrProperties[0] = ((LPVOID) IDS_Name);
    m_ptrProperties[1] = ((LPVOID) IDS_State);
    m_ptrProperties[2] = ((LPVOID) IDS_Started);
    m_ptrProperties[3] = ((LPVOID) IDS_AcceptStop);
    m_ptrProperties[4] = ((LPVOID) IDS_AcceptPause);
    m_ptrProperties[5] = ((LPVOID) IDS_ProcessId);
    m_ptrProperties[6] = ((LPVOID) IDS_ExitCode);
    m_ptrProperties[7] = ((LPVOID) IDS_ServiceSpecificExitCode);
    m_ptrProperties[8] = ((LPVOID) IDS_CheckPoint);
    m_ptrProperties[9] = ((LPVOID) IDS_WaitHint);
    m_ptrProperties[10] = ((LPVOID) IDS_Status);
    m_ptrProperties[11] = ((LPVOID) IDS_Caption);
    m_ptrProperties[12] = ((LPVOID) IDS_DisplayName);
    m_ptrProperties[13] = ((LPVOID) IDS_Description);
    m_ptrProperties[14] = ((LPVOID) IDS_TagId);
    m_ptrProperties[15] = ((LPVOID) IDS_ServiceType);
    m_ptrProperties[16] = ((LPVOID) IDS_DesktopInteract);
    m_ptrProperties[17] = ((LPVOID) IDS_StartMode);
    m_ptrProperties[18] = ((LPVOID) IDS_ErrorControl);
    m_ptrProperties[19] = ((LPVOID) IDS_PathName);
    m_ptrProperties[20] = ((LPVOID) IDS_StartName);
    m_ptrProperties[21] = ((LPVOID) IDS_CreationClassName);
    m_ptrProperties[22] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[23] = ((LPVOID) IDS_SystemName);

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::~CWin32Service
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

CWin32Service :: ~CWin32Service ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Service :: ExecQuery (

	MethodContext *pMethodContext,
	CFrameworkQuery& pQuery,
	long lFlags /*= 0L*/
)
{
    HRESULT hRes ;

#ifdef NTONLY

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties = BIT_ALL_PROPERTIES;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    hRes = AddDynamicInstancesNT ( pMethodContext , dwProperties ) ;

#endif

#ifdef WIN9XONLY

	hRes = WBEM_E_PROVIDER_NOT_CAPABLE ;

#endif

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Service :: GetObject (

	CInstance *pInstance,
	long lFlags,
    CFrameworkQuery& pQuery
)
{

#ifdef NTONLY

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

	HRESULT hRes = RefreshInstanceNT(pInstance, dwProperties) ;
	if ( hRes == WBEM_E_ACCESS_DENIED )
	{
		hRes = WBEM_S_NO_ERROR ;
	}

#endif

#ifdef WIN9XONLY

	HRESULT hRes = RefreshInstanceWin95 ( pInstance ) ;

#endif

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each service
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Service :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hRes;

#ifdef NTONLY

	hRes = AddDynamicInstancesNT ( pMethodContext , BIT_ALL_PROPERTIES ) ;

#endif

#ifdef WIN9XONLY

	hRes = AddDynamicInstancesWin95 ( pMethodContext ) ;

#endif

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::RefreshInstanceNT
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32Service :: RefreshInstanceNT (

	CInstance *pInstance,
    DWORD dwProperties

)
{
	HRESULT hRes = WBEM_E_FAILED;

   // Check to see if this is us...

	CHString sName;
	if( !pInstance->GetCHString( IDS_Name, sName ) || sName.IsEmpty() )
	{
		return WBEM_E_NOT_FOUND ;
	}

	// Get an scman handle

	SmartCloseServiceHandle hDBHandle = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
	if(hDBHandle != NULL)
	{
	  // Create copy of name & pass to LoadPropertyValues
	  //=================================================

		CAdvApi32Api *t_pAdvApi32 = NULL;

		if ( IsWinNT5 () )
		{
			t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource ( g_guidAdvApi32Api , NULL ) ;
		}

		try
		{
			hRes = LoadPropertyValuesNT (

				hDBHandle,
				(LPCTSTR)sName,
				pInstance,
				dwProperties,
				t_pAdvApi32
			);
		}
		catch ( ... )
		{
			if ( t_pAdvApi32 != NULL )
			{
				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidAdvApi32Api , t_pAdvApi32 ) ;
			}

			throw ;
		}

		if ( t_pAdvApi32 != NULL )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidAdvApi32Api , t_pAdvApi32 ) ;
		}
	}

	return hRes;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::AddDynamicInstancesNT
 *
 *  DESCRIPTION : Creates instance of property set for each service
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32Service::AddDynamicInstancesNT (

	MethodContext *a_pMethodContext,
	DWORD dwProperties
)
{
    HRESULT t_hResult = WBEM_E_FAILED;

    // Get handle to the services database
    //====================================

	SmartCloseServiceHandle hDBHandle = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
    if ( hDBHandle )
	{
		// Make call once to get buffer size (should return
		// FALSE but fill in buffer size)
		//=================================================

		DWORD i, hEnumHandle = 0, dwByteCount = 0, dwEntryCount ;
		LPENUM_SERVICE_STATUS pServiceList = NULL ;

		BOOL t_EnumStatus = EnumServicesStatus (

			hDBHandle,
			SERVICE_WIN32 ,
			SERVICE_ACTIVE | SERVICE_INACTIVE,
			pServiceList,
			dwByteCount,
			&dwByteCount,
			&dwEntryCount,
			&hEnumHandle
		) ;

		if ( t_EnumStatus == FALSE && GetLastError() == ERROR_MORE_DATA)
		{
			// Allocate the required buffer
			//=============================

			pServiceList = reinterpret_cast<LPENUM_SERVICE_STATUS> (new char[dwByteCount]) ;
			if(pServiceList != NULL)
			{
				try
				{
					memset(pServiceList, 0, dwByteCount) ;

					t_EnumStatus = EnumServicesStatus(

						hDBHandle,
						SERVICE_WIN32 ,
						SERVICE_ACTIVE | SERVICE_INACTIVE,
						pServiceList,
						dwByteCount,
						&dwByteCount,
						&dwEntryCount,
						&hEnumHandle
					) ;

					if ( t_EnumStatus == TRUE )
					{
						t_hResult = WBEM_S_NO_ERROR;

						// Create instance for each returned service
						//==========================================

						CAdvApi32Api *t_pAdvApi32 = NULL;

						if ( IsWinNT5 () )
						{
							t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
						}

						try
						{
							// smart ptr
							CInstancePtr t_pInst ;

							for ( i = 0 ; i < dwEntryCount; i++ )
							{
								t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

								// Load and save
								t_hResult = LoadPropertyValuesNT (

									hDBHandle,
									pServiceList[i].lpServiceName,
									t_pInst,
									dwProperties ,
									t_pAdvApi32
								);

								if ( t_hResult == WBEM_S_NO_ERROR ||
									 t_hResult == WBEM_E_ACCESS_DENIED ) // can enumerate the service but can't open it
								{
									t_hResult = t_pInst->Commit() ;
								}

								// we reset to WBEM_S_NO_ERROR as the return is used
								// in ExecQuery and EnumerateInstances
								t_hResult = WBEM_S_NO_ERROR ;
							}
						}
						catch ( ... )
						{
							if ( t_pAdvApi32 != NULL )
							{
								CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
							}

							throw ;
						}

						if ( t_pAdvApi32 != NULL )
						{
							CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
						}
					}
				}
				catch ( ... )
				{
					delete [] reinterpret_cast<char *> (pServiceList) ;

					throw ;
				}

				delete [] reinterpret_cast<char *> (pServiceList) ;
			}
		}
	}

    return t_hResult;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::LoadPropertyValuesNT
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32Service::LoadPropertyValuesNT (

	SC_HANDLE hDBHandle,
	LPCTSTR szServiceName,
	CInstance *pInstance,
	DWORD dwProperties,
	CAdvApi32Api* a_pAdvApi32
)
{
    HRESULT hRes = WBEM_S_NO_ERROR; // Since we have the name, we can populate the key.

    // Open the service
    //=================

    // Check to see if we HAVE to open the service.  If we are running as a
    // query and they didn't request some of these properties, let's not waste the time.


  // If they want any of these, we'll have to do StatusInfo

	BOOL bStatusInfo = dwProperties &
        (BIT_State | BIT_Started | BIT_AcceptStop | BIT_AcceptPause | BIT_Status |
         BIT_ProcessId | BIT_ExitCode | BIT_ServiceSpecificExitCode | BIT_CheckPoint |
         BIT_WaitHint );

  // If they want any of these, we'll have to do ConfigInfo

	BOOL bConfigInfo = dwProperties &
        (BIT_TagId | BIT_ServiceType | BIT_DesktopInteract | BIT_StartMode |
         BIT_ErrorControl | BIT_PathName | BIT_DisplayName | BIT_Caption |
         BIT_Description | BIT_StartName);

    SmartCloseServiceHandle hSvcHandle = OpenService (

		hDBHandle,
		szServiceName,
		SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_INTERROGATE
	) ;

	DWORD t_dwLastError = GetLastError();

	if ( ( hSvcHandle == NULL ) && ( ERROR_SERVICE_DOES_NOT_EXIST == t_dwLastError || ERROR_INVALID_NAME == t_dwLastError) )
	{
		return WBEM_E_NOT_FOUND ;
	}

	// If all they wanted was the name, skip all this.
	if ( bStatusInfo || bConfigInfo )
	{
		// If the service could not be opened
		// drop through and collect up the defaults
		// ========================================
		if ( bStatusInfo )
		{
			DWORD t_ProcessId = 0 ;
			DWORD t_CurrentState ;
			DWORD t_ControlsAccepted ;
			DWORD t_Win32ExitCode = 0 ;
			DWORD t_ServiceSpecific = 0 ;
			DWORD t_CheckPoint = 0 ;
			DWORD t_WaitHint = 0 ;

			BOOL t_Status = FALSE ;

			if( NULL != (SC_HANDLE)hSvcHandle )
			{
				if ( IsWinNT5() && a_pAdvApi32 != NULL)
				{
					SERVICE_STATUS_PROCESS StatusInfo ;

					DWORD t_ExpectedSize = 0 ;

					DWORD t_dwRet = a_pAdvApi32->QueryServiceStatusEx (

						hSvcHandle,
						SC_STATUS_PROCESS_INFO ,
						( UCHAR * ) &StatusInfo ,
						sizeof ( StatusInfo ) ,
						& t_ExpectedSize ,
						&t_Status
					) ;

					if ( t_dwRet )
					{
						  // the function did indeed exist

						if ( t_Status == TRUE )
						{
							t_ProcessId = StatusInfo.dwProcessId ;
							t_CurrentState = StatusInfo.dwCurrentState ;
							t_ControlsAccepted = StatusInfo.dwControlsAccepted ;
							t_Win32ExitCode = StatusInfo.dwWin32ExitCode ;
							t_ServiceSpecific = StatusInfo.dwServiceSpecificExitCode ;
							t_CheckPoint = StatusInfo.dwCheckPoint ;
							t_WaitHint = StatusInfo.dwWaitHint ;
						}
					}
				}
				else
				{
					SERVICE_STATUS StatusInfo ;
					t_Status = QueryServiceStatus(hSvcHandle, &StatusInfo) ;
					if(t_Status == TRUE)
					{
						t_CurrentState = StatusInfo.dwCurrentState ;
						t_ControlsAccepted = StatusInfo.dwControlsAccepted ;
						t_Win32ExitCode = StatusInfo.dwWin32ExitCode ;
						t_ServiceSpecific = StatusInfo.dwServiceSpecificExitCode ;
						t_CheckPoint = StatusInfo.dwCheckPoint ;
						t_WaitHint = StatusInfo.dwWaitHint ;
					}
				}
			}

			bool bStarted = true;

			if ( t_Status )
			{
				switch (t_CurrentState)
				{
					case SERVICE_STOPPED:
					{
						pInstance->SetCharSplat(IDS_State, _T("Stopped"));
						bStarted = false;
					}
					break;

					case SERVICE_START_PENDING:
					{
						pInstance->SetCharSplat(IDS_State, _T("Start Pending"));
						bStarted = true;
					}
					break;

					case SERVICE_STOP_PENDING:
					{
						pInstance->SetCharSplat(IDS_State, _T("Stop Pending"));
						bStarted = true;
					}
					break;

					case SERVICE_RUNNING:
					{
						pInstance->SetCharSplat(IDS_State, _T("Running"));
						bStarted = true;
					}
					break;

					case SERVICE_CONTINUE_PENDING:
					{
						pInstance->SetCharSplat(IDS_State, _T("Continue Pending"));
						bStarted = true;
					}
					break;

					case SERVICE_PAUSE_PENDING:
					{
						pInstance->SetCharSplat(IDS_State, _T("Pause Pending"));
						bStarted = true;
					}
					break;

					case SERVICE_PAUSED:
					{
						pInstance->SetCharSplat(IDS_State, _T("Paused"));
						bStarted = true;
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_State, _T("Unknown") );
						bStarted = true;
					}
					break;
				}

				pInstance->Setbool(IDS_Started, bStarted);
				pInstance->Setbool(IDS_AcceptStop, (t_ControlsAccepted) & SERVICE_ACCEPT_STOP);
				pInstance->Setbool(IDS_AcceptPause, (t_ControlsAccepted) & SERVICE_ACCEPT_PAUSE_CONTINUE);

				pInstance->SetDWORD ( IDS_ProcessId , t_ProcessId ) ;
				pInstance->SetDWORD ( IDS_ExitCode , t_Win32ExitCode ) ;
				pInstance->SetDWORD ( IDS_ServiceSpecificExitCode , t_ServiceSpecific ) ;
				pInstance->SetDWORD ( IDS_CheckPoint , t_CheckPoint ) ;
				pInstance->SetDWORD ( IDS_WaitHint , t_WaitHint ) ;

			}
			else
			{
				pInstance->SetCharSplat(IDS_State, _T("Unknown") );
			}

            if (dwProperties & BIT_Status)
            {
			    if( hSvcHandle )
			    {
				    SERVICE_STATUS StatusInfo ;
				    if ( ( ! bStarted ) || ( ControlService ( hSvcHandle , SERVICE_CONTROL_INTERROGATE , &StatusInfo ) != 0 ) )
				    {
					    pInstance->SetCharSplat(IDS_Status, IDS_OK);
				    }
				    else
				    {
					    pInstance->SetCharSplat(IDS_Status, IDS_Degraded);
				    }
			    }
			    else
			    {
				    pInstance->SetCharSplat(IDS_Status, IDS_Unknown);
			    }
            }
		}

		if (bConfigInfo)
		{
			// Get the rest of the config info
			//================================
			char ConfigBuffer[1024] ;
			LPQUERY_SERVICE_CONFIG pConfigInfo = ( LPQUERY_SERVICE_CONFIG ) ConfigBuffer ;

			// These may get overwritten below if we can find something better

			pInstance->SetCharSplat(IDS_Caption, szServiceName );
			pInstance->SetCharSplat(IDS_DisplayName, szServiceName );
			

			// We need to make another call for getting the Description of the Service
			if ( NULL != (SC_HANDLE)hSvcHandle )
			{
				DWORD dwBufSize = 0;
				DWORD dwBytesNeeded = 0;
				SERVICE_DESCRIPTION *pBuffer = NULL;
				BOOL bSuccess = QueryServiceConfig2(
									(SC_HANDLE) hSvcHandle, 
									SERVICE_CONFIG_DESCRIPTION,      
									( LPBYTE ) pBuffer, 
									dwBufSize,
									&dwBytesNeeded  
								 );
				if ( !bSuccess )
				{
					DWORD dwError = GetLastError ();
					if ( dwError == ERROR_INSUFFICIENT_BUFFER )
					{
						pBuffer = ( SERVICE_DESCRIPTION *) new BYTE [ dwBytesNeeded ];
						if ( pBuffer != NULL )
						{
							try
							{
								BOOL bSuccess = QueryServiceConfig2(
													(SC_HANDLE) hSvcHandle, 
													SERVICE_CONFIG_DESCRIPTION,      
													( LPBYTE ) pBuffer, 
													dwBytesNeeded,
													&dwBytesNeeded  
												 );

								if ( bSuccess )
								{
									pInstance->SetCharSplat(IDS_Description, pBuffer->lpDescription );
								}
							}
							catch ( ... )
							{
								delete [] pBuffer;
								throw;
							}
							delete [] pBuffer;
						}
					}
				}
			}

			BOOL t_QueryStatus = FALSE ;

			if( NULL != (SC_HANDLE)hSvcHandle )
			{
				DWORD dwByteCount = 0 ;

				memset(ConfigBuffer, 0, sizeof(ConfigBuffer)) ;

				t_QueryStatus = QueryServiceConfig (

					hSvcHandle,
					pConfigInfo,
					sizeof(ConfigBuffer),
					&dwByteCount
				) ;
			}

			if ( t_QueryStatus == TRUE )
			{
				pInstance->SetDWORD(IDS_TagId, pConfigInfo->dwTagId );

				switch ( pConfigInfo->dwServiceType & ( ~SERVICE_INTERACTIVE_PROCESS ) )
				{
					case SERVICE_WIN32_OWN_PROCESS:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Own Process"));
					}
					break;

					case SERVICE_WIN32_SHARE_PROCESS:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Share Process"));
					}
					break;

					case SERVICE_KERNEL_DRIVER:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Kernel Driver"));
						hRes = WBEM_E_NOT_FOUND;  // Not a service
					}
					break;

					case SERVICE_FILE_SYSTEM_DRIVER:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("File System Driver"));
						hRes = WBEM_E_NOT_FOUND;  // Not a service
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Unknown"));
					}
					break;
				}

				pInstance->Setbool(IDS_DesktopInteract, pConfigInfo->dwServiceType & SERVICE_INTERACTIVE_PROCESS);

				switch (pConfigInfo->dwStartType)
				{
					case SERVICE_BOOT_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Boot"));
					}
					break;

					case SERVICE_SYSTEM_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("System"));
					}
					break;

					case SERVICE_AUTO_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Auto"));
					}
					break;

					case SERVICE_DEMAND_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Manual"));
					}
					break;

					case SERVICE_DISABLED:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Disabled"));
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Unknown"));
					}
					break;
				}

				switch (pConfigInfo->dwErrorControl)
				{
					case SERVICE_ERROR_IGNORE:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Ignore"));
					}
					break;

					case SERVICE_ERROR_NORMAL:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Normal"));
					}
					break;

					case SERVICE_ERROR_SEVERE:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Severe"));
					}
					break;

					case SERVICE_ERROR_CRITICAL:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Critical"));
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Unknown"));
					}
					break;
				}

				if ( pConfigInfo->lpBinaryPathName && pConfigInfo->lpBinaryPathName [ 0 ] )
				{
					pInstance->SetCharSplat ( IDS_PathName, pConfigInfo->lpBinaryPathName );
				}

				if ( pConfigInfo->lpServiceStartName && pConfigInfo->lpServiceStartName [ 0 ] )
				{
					pInstance->SetCharSplat ( IDS_StartName, pConfigInfo->lpServiceStartName ) ;
				}

				if ( pConfigInfo->lpDisplayName && pConfigInfo->lpDisplayName [ 0 ] )
				{
					pInstance->SetCharSplat ( IDS_DisplayName, pConfigInfo->lpDisplayName ) ;
					pInstance->SetCharSplat ( IDS_Caption, pConfigInfo->lpDisplayName ) ;
					// Not Required, since another API is made to get the description.
					//pInstance->SetCharSplat ( IDS_Description, pConfigInfo->lpDisplayName ) ;
				}
			}
			else
			{
				pInstance->SetCharSplat ( IDS_ServiceType, _T("Unknown") ) ;
				pInstance->SetCharSplat ( IDS_StartMode, _T("Unknown") ) ;
				pInstance->SetCharSplat ( IDS_ErrorControl, _T("Unknown") ) ;
			}
		}

		if( NULL == (SC_HANDLE)hSvcHandle && ERROR_ACCESS_DENIED == t_dwLastError )
		{
			// could enumerate the service but could not open it
			hRes = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			// Service not started, etc...
			hRes = WBEM_NO_ERROR ;
		}
	}
	else
	{
	   hRes = WBEM_S_NO_ERROR;
	}

    pInstance->SetCharSplat ( IDS_CreationClassName , PROPSET_NAME_SERVICE ) ;
    pInstance->SetCharSplat ( IDS_SystemCreationClassName , PROPSET_NAME_COMPSYS ) ;
    pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;

    // Redundant for getobject, but hey...
    pInstance->SetCharSplat ( IDS_Name, szServiceName ) ;

    return hRes;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::RefreshInstanceWin95
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32Service :: RefreshInstanceWin95 (

	CInstance *pInstance
)
{
   return WBEM_E_NOT_FOUND;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::AddDynamicInstancesWin95
 *
 *  DESCRIPTION : Creates instance of property set for each service
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32Service :: AddDynamicInstancesWin95 (

	MethodContext *pMethodContext
)
{
    return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::LoadPropertyValuesWin95
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
void CWin32Service :: LoadPropertyValuesWin95 (

	LPCTSTR szServiceName,
	CInstance *pInstance
)
{
    return;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PutInstance
 *
 *  DESCRIPTION : Allows caller to assign state to service
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : BOOL indicating success/failure
 *
 *  COMMENTS    : We don't wait around for the service to start, pause or stop --
 *                the return code simply indicates that the command was success-
 *                fully received by the Service Control Manager.
 *
 *****************************************************************************/

HRESULT CWin32Service::PutInstance (

	const CInstance &a_Instance,
	long lFlags /*= 0L*/
)
{
    DWORD dwFlags = lFlags & 3;

#ifdef WIN9XONLY
	HRESULT t_Result = WBEM_E_NOT_SUPPORTED ;
#endif

#ifdef NTONLY
	if ( ( dwFlags != WBEM_FLAG_CREATE_OR_UPDATE ) && ( dwFlags != WBEM_FLAG_UPDATE_ONLY ) )
	{
		return WBEM_E_UNSUPPORTED_PARAMETER ;
	}

    CInstancePtr t_Instance;

	CHString t_State ;
    CHString t_RelPath;

    a_Instance.GetCHString ( IDS___Relpath, t_RelPath);
	a_Instance.GetCHString ( IDS_State , t_State ) ;

    // Only need to make sure it exists
	HRESULT t_Result = CWbemProviderGlue :: GetInstanceKeysByPath ( t_RelPath, &t_Instance, a_Instance.GetMethodContext() ) ;
	if ( FAILED(t_Result) )
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			if ( dwFlags == WBEM_FLAG_CREATE_OR_UPDATE )
			{
				return WBEM_E_UNSUPPORTED_PARAMETER ;
			}
			else if ( ( dwFlags & WBEM_FLAG_UPDATE_ONLY ) == dwFlags )
			{
				return t_Result ;
			}
			else
			{
				return t_Result ;
			}
		}
		else
		{
			return t_Result ;
		}
	}

	t_Result = WBEM_E_NOT_SUPPORTED ;

	CInstance *t_OutParam = NULL ;
	if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_RUNNING ) == 0 )
	{
		t_Result = ExecStart ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_PAUSED ) == 0 )
	{
		t_Result = ExecPause ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_STOPPED ) == 0 )
	{
		t_Result = ExecStop ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else
	{
	}
#endif

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\sharetodir.h ===
//=================================================================

//

// ShareToDir.h -- Share to Directory

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/31/98    davwoh         Created
//
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_SHARETODIR L"Win32_ShareToDirectory"

class CShareToDir:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CShareToDir(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CShareToDir() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\sharetodir.cpp ===
//=================================================================

//

// ShareToDir.cpp -- Share to Directory

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/31/98    davwoh         Created
//
//
//=================================================================

#include "precomp.h"

#include "ShareToDir.h"

// Property set declaration
//=========================

CShareToDir MyShareToDir(PROPSET_NAME_SHARETODIR, IDS_CimWin32Namespace);

/*****************************************************************************
*
*  FUNCTION    : CShareToDir::CShareToDir
*
*  DESCRIPTION : Constructor
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    : Registers property set with framework
*
*****************************************************************************/

CShareToDir::CShareToDir(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
*
*  FUNCTION    : CShareToDir::~CShareToDir
*
*  DESCRIPTION : Destructor
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    : Deregisters property set from framework
*
*****************************************************************************/

CShareToDir::~CShareToDir()
{
}

/*****************************************************************************
*
*  FUNCTION    : CShareToDir::GetObject
*
*  DESCRIPTION : Assigns values to property set according to key value
*                already set by framework
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : HRESULT
*
*  COMMENTS    :
*
*****************************************************************************/

HRESULT CShareToDir::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
    CHString sPath, sName, sPath2, sPath3, sPath4;
    CInstancePtr pShare;
    CInstancePtr pDirInst;
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Get the two paths
    pInstance->GetCHString(L"SharedElement", sPath);
    pInstance->GetCHString(L"Share", sName);

    // Note that since directory is a property of share, I get the share, path-ify the path, and do
    // the compare.
    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(sName, &pShare, pInstance->GetMethodContext())))
    {
        pShare->GetCHString(IDS_Path, sPath2);
        
        EscapeBackslashes(sPath2, sPath3);
        sPath4.Format(L"Win32_Directory.Name=\"%s\"", (LPCWSTR)sPath3);
        
        // Why get the file system?  Because asking for it
        // forces us to hit the disk.  Why would we want to
        // do that?  Because if one shared a cd drive, a GetObject
        // on the cd drive's root directory would work
        // even if a cd were not in the drive, if we only ask
        // for the key properties (since we wouldn't hit the
        // disk, since we weren't asking for the file system).
        CHStringArray csaProperties;
        csaProperties.Add(IDS___Path);
        csaProperties.Add(IDS_FSName);

        if(SUCCEEDED(hr = CWbemProviderGlue::GetInstancePropertiesByPath(
            sPath4, 
            &pDirInst, 
            pInstance->GetMethodContext(), 
            csaProperties)))
        {
            hr = WBEM_S_NO_ERROR;
        }
    }

    return hr;
}

/*****************************************************************************
*
*  FUNCTION    : CShareToDir::EnumerateInstances
*
*  DESCRIPTION : Creates instance of property set for cd rom
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : HRESULT
*
*  COMMENTS    :
*
*****************************************************************************/

HRESULT CShareToDir::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_FAILED;

    TRefPointerCollection<CInstance>	elementList;

    CInstancePtr pElement;
    CInstancePtr pDirInst;

    REFPTRCOLLECTION_POSITION	pos;

    // Get all the shares. 
    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"Select Name, Path from Win32_Share Where type = 0 or type = 2147483648",
        &elementList, pMethodContext, IDS_CimWin32Namespace)))
    {
        if ( elementList.BeginEnum( pos ) )
        {

            CHString sPath, sPath2, sPath3, sTemp1;

            for (pElement.Attach(elementList.GetNext( pos ) ) ;
                   SUCCEEDED(hr) && ( pElement != NULL ) ;
                   pElement.Attach(elementList.GetNext( pos ) ) )

            {
                pElement->GetCHString(IDS_Path, sPath);

                EscapeBackslashes(sPath, sPath2);
                sPath3.Format(L"Win32_Directory.Name=\"%s\"", (LPCWSTR)sPath2);

                // Why get the file system?  Because asking for it
                // forces us to hit the disk.  Why would we want to
                // do that?  Because if one shared a cd drive, a GetObject
                // on the cd drive's root directory would work
                // even if a cd were not in the drive, if we only ask
                // for the key properties (since we wouldn't hit the
                // disk, since we weren't asking for the file system).
                CInstancePtr pDirInst;
                CHStringArray csaProperties;
                csaProperties.Add(IDS___Path);
                csaProperties.Add(IDS_FSName);

                if(SUCCEEDED(CWbemProviderGlue::GetInstancePropertiesByPath(
                    sPath3, 
                    &pDirInst, 
                    pMethodContext, 
                    csaProperties)))
                {
                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                    if (pInstance)
                    {
                        // Path-ify the path from win32_share
                        if(pDirInst->GetCHString(IDS___Path, sTemp1))
                        {
                            pInstance->SetCHString(L"SharedElement", sTemp1);
                            if(GetLocalInstancePath(pElement, sTemp1))
                            {
                                pInstance->SetCHString(L"Share", sTemp1);
                                hr = pInstance->Commit();
                            }
                        }
                    }
                }
            }	// IF GetNext Computer System
            elementList.EndEnum();
        }	// IF BeginEnum
    }	// IF GetInstancesByQuery
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\shortcutfile.cpp ===
//=================================================================

//

// CIMDataFile.CPP -- CIMDataFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    a-kevhu         Created
//
//=================================================================

#include "precomp.h"
#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"

#include "ShortcutFile.h"
#include <comdef.h>
#include <process.h>  // Note: NOT the one in the current directory!

#include <exdisp.h>
#include <shlobj.h>

#include "sid.h"
#include "ImpLogonUser.h"

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"


// Property set declaration
//=========================

CShortcutFile MyCShortcutFile(PROPSET_NAME_WIN32SHORTCUTFILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CShortcutFile::CShortcutFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CShortcutFile::CShortcutFile(LPCWSTR a_setName, LPCWSTR a_pszNamespace )
    : CCIMDataFile( a_setName, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CShortcutFile::~CShortcutFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CShortcutFile::~CShortcutFile()
{
}



void CShortcutFile::Flush(void)
{
    // We can't wait until m_csh's destructor because the helper thread
    // will have already gotten ripped out.
    m_csh.StopHelperThread();
}

/*****************************************************************************
 *
 *  FUNCTION    : CShortcutFile::IsOneOfMe
 *
 *  DESCRIPTION : The guts of this class, actually.  IsOneOfMe is inherrited
 *                from CIM_LogicalFile.  That class returns files or
 *                directories where this one should only return directories,
 *                in response to queries, getobject commands, etc.  It is
 *                overridden here to return TRUE only if the file (the
 *                information for which is contained in the function arguement
 *                pstFindData) is of type directory.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/


BOOL CShortcutFile::IsOneOfMe(LPWIN32_FIND_DATAW a_pstFindData,
                             LPCWSTR a_wstrFullPathName )
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    BOOL	t_fRet = FALSE ;

    if( a_wstrFullPathName != NULL )
    {
        WCHAR t_wstrExt[ _MAX_EXT ] ;

        ZeroMemory( t_wstrExt, sizeof( t_wstrExt ) ) ;

        _wsplitpath( a_wstrFullPathName, NULL, NULL, NULL, t_wstrExt ) ;

		if( _wcsicmp( t_wstrExt, L".LNK" ) == 0 )
        {
            // it has the right extension, but can we get lnk data from it?
            if( ConfirmLinkFile( CHString(a_wstrFullPathName) ) )
            {
                t_fRet = TRUE ;
            }
        }
    }
    return t_fRet ;
}


BOOL CShortcutFile::IsOneOfMe( LPWIN32_FIND_DATAA a_pstFindData,
                             LPCSTR a_strFullPathName )
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    BOOL t_fRet = FALSE;

	#ifndef _UNICODE
		if( a_strFullPathName != NULL )
		{
			CHAR t_strExt[ _MAX_EXT ] ;

			ZeroMemory( t_strExt, sizeof( t_strExt ) ) ;

			_splitpath( a_strFullPathName, NULL, NULL, NULL, t_strExt ) ;

			if( _stricmp( t_strExt,".LNK") == 0 )
			{
				// it has the right extension, but can we get lnk data from it?
				if( ConfirmLinkFile( CHString(a_strFullPathName) ) )
				{
					t_fRet = TRUE;
				}
			}
		}
	#endif

    return t_fRet ;
}


/*****************************************************************************
 *
 *  FUNCTION    : CShortcutFile::GetExtendedProperties
 *
 *  DESCRIPTION : Sets properties unique to this provider (not common to all
 *                CIM_LogicalFile derived classes).
 *
 *  INPUTS      : CInstance pointer and flags
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
 void CShortcutFile::GetExtendedProperties(CInstance* a_pInst,
                                          long a_lFlags )
{
    if( a_pInst == NULL )
	{
		return;
	}

    CHString t_chstrShortcutPathName;
	// Examine lFlags to determine if any of the shortcut file related properties
	// are required.  In NONE of them are, don't proceed further.
	if( a_lFlags & PROP_TARGET ) // DEVNOTE:  add || statements to this test as additional ShortcutFile properties are added to this class
	{
		a_pInst->GetCHString( IDS_Name, t_chstrShortcutPathName ) ;

		if( !t_chstrShortcutPathName.IsEmpty() )
		{
			// If the extension isn't .LNK, don't even bother.  This check is worthwhile since
			// this GetExtendedProperties WILL get called for every instance of a CIM_DataFile
			// at this level of CIM derivation or higher.
			 WCHAR t_wstrExt[ _MAX_EXT ] ;

			 ZeroMemory( t_wstrExt, sizeof( t_wstrExt ) ) ;
			_wsplitpath( (LPCWSTR)t_chstrShortcutPathName, NULL, NULL, NULL, t_wstrExt ) ;
			if( _wcsicmp( t_wstrExt, L".LNK" ) == 0 )
			{
			    CHString chstrTargetPathName;
                if(SUCCEEDED(m_csh.RunJob(t_chstrShortcutPathName, chstrTargetPathName, a_lFlags)))
                {
                    if(a_lFlags & PROP_TARGET)
                    {
                        if(!chstrTargetPathName.IsEmpty())
						{
                            a_pInst->SetCHString(IDS_Target, chstrTargetPathName ) ;
						}
                    }
                }
			} // had a LNK extension
		}   // chstrLinkFileName not empty
	} // needed one or more shortcut file related properties
}




/*****************************************************************************
 *
 *  FUNCTION    : CShortcutFile::ConfirmLinkFile
 *
 *  DESCRIPTION : Tries to access lnk file data to determine if really a link file.
 *
 *  INPUTS      : CInstance pointer and flags
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
BOOL CShortcutFile::ConfirmLinkFile(CHString &a_chstrFullPathName )
{
    // This is godawful, but have to try to access the link data to really
    // know if we have a link file or not.

	BOOL			t_fRet	= FALSE ;

	// Only continue if it is a link file...
	if( !a_chstrFullPathName.IsEmpty() )
	{
		CHString chstrTargetPathName;
        if(SUCCEEDED(m_csh.RunJob(a_chstrFullPathName, chstrTargetPathName, 0L)))
        {
            t_fRet = TRUE;
        }
	}   // a_chstrFullPathName not empty

	return t_fRet;
}


// This enumerateinstances is essentially the parent class's EnumDrives function (normally called
// by the parent's EnumerateInstances function), with one important difference: we specify an LNK
// extension to optimize our search.  This version also differs from the parent's in that it does
// not support a pszPath parameter.
HRESULT CShortcutFile::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    TCHAR tstrDrive[4];
    int x;
    DWORD dwDrives;
    TCHAR tstrFSName[_MAX_PATH];
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bRoot = false;


    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    // Walk all the logical drives
    dwDrives = GetLogicalDrives();
    for (x=0; (x < 32) && SUCCEEDED(hr); x++)
    {
        // If the bit is set, the drive letter is active
        if (dwDrives & (1<<x))
        {
            tstrDrive[0] = x + _T('A');
            tstrDrive[1] = _T(':');
            tstrDrive[2] = _T('\\');
            tstrDrive[3] = _T('\0');

            // Only local drives
            if (IsValidDrive(tstrDrive))
            {
                BOOL bRet;
                try
                {
                    bRet = GetVolumeInformation(tstrDrive, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                }
                catch ( ... )
                {
                    bRet = FALSE;
                }

                if (bRet)
                {
                   tstrDrive[2] = '\0';
                    // If we were asked for a specific path, then we don't want to recurse, else
                    // start from the root.
#ifdef NTONLY
				    {
						bstr_t bstrDrive(tstrDrive);
                        bstr_t bstrName(tstrFSName);
                        {
                            CNTEnumParm p(pMethodContext, bstrDrive, L"", L"*", L"*", true, bstrName, PROP_ALL_SPECIAL, true, NULL);
					        hr = EnumDirsNT(p);
                        }
				    }
#endif
#ifdef WIN9XONLY
                    {
                        C95EnumParm p(pMethodContext, tstrDrive, _T(""), _T("*"), _T("*"), true, tstrFSName, PROP_ALL_SPECIAL, true, NULL);
					 	hr = EnumDirs95(p);
                    }
#endif
                }
            }
        }
    }

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return WBEM_S_NO_ERROR;
}

/*
#ifdef NTONLY
BOOL CShortcutFile::GetSecAttribs(SECURITY_ATTRIBUTES *secattribs)
{
    BOOL fRet = FALSE;
    SECURITY_INFORMATION secinfo;
    secinfo = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
    DWORD dwLen = 0L;
    DWORD dwLenNeeded = 0L;
    HANDLE hThread = GetCurrentThread();
    BYTE *pBuff = NULL;

    if(!GetKernelObjectSecurity(hThread, secinfo, NULL, 0, &dwLenNeeded))
    {
        try
        {
            // the caller will need to free this memory using 'delete'...
            pBuff = new BYTE[dwLenNeeded];
            if(pBuff != NULL)
            {
                dwLen = dwLenNeeded;
                if(GetKernelObjectSecurity(hThread, secinfo, (PSECURITY_DESCRIPTOR)pBuff, dwLen, &dwLenNeeded))
                {
                    //CSecurityDescriptor csd((PSECURITY_DESCRIPTOR)pBuff);
                    //csd.DumpDescriptor(L"g:\\descriptor.txt");

                    secattribs->nLength = sizeof(SECURITY_ATTRIBUTES);
                    secattribs->lpSecurityDescriptor = (LPVOID)pBuff;
                    secattribs->bInheritHandle = TRUE;
                    fRet = TRUE;
                }
            }
        }
        catch(...)
        {
            if(pBuff != NULL)
            {
                delete pBuff;
                pBuff = NULL;
            }
            throw;
        }
    }
    return fRet;
}
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\shortcutfile.h ===
//=================================================================

//

// ShortcutFile.h -- Win32_ShortcutFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/12/98    a-kevhu         Created
//
//=================================================================

// Property set identification
//============================
#ifndef _SHORTCUTFILE_H_
#define _SHORTCUTFILE_H_

#define  PROPSET_NAME_WIN32SHORTCUTFILE L"Win32_ShortcutFile"


#include "ShortcutHelper.h"


#define _MAX_WAIT_TIME_FOR_SHORTCUTFILEINFO 100   // milliseconds




class CShortcutFile : public CCIMDataFile
{
   private:
        CShortcutHelper m_csh;
/*
#ifdef NTONLY
        BOOL GetSecAttribs(SECURITY_ATTRIBUTES *secattribs);
#endif
*/
   protected:

        // Overridable function inherrited from CImplement_LogicalFile
        virtual BOOL IsOneOfMe( LPWIN32_FIND_DATAA a_pstFindData,
                                LPCSTR a_strFullPathName ) ;

        virtual BOOL IsOneOfMe( LPWIN32_FIND_DATAW a_pstFindData,
                                LPCWSTR a_wstrFullPathName ) ;

        // Overridable function inherrited from CProvider
        virtual void GetExtendedProperties( CInstance *a_pInst, long a_lFlags = 0L ) ;
        BOOL ConfirmLinkFile( CHString &a_chstrFullPathName ) ;
        virtual void Flush(void);
   
   public:

        // Constructor/destructor
        //=======================

        CShortcutFile( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CShortcutFile() ; 
       
       virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, 
                                           long lFlags = 0L);   
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\shortcuthelper.h ===
//=================================================================

//

// ShortcutHelper.h -- CIMDataFile property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/24/99    a-kevhu         Created
//
//=================================================================
#ifndef _SHORTCUTFILE_HELPER_H
#define _SHORTCUTFILE_HELPER_H

#define MAX_KILL_TIME         10000
#define MAX_HELPER_WAIT_TIME  60000
#define MAX_JOB_TIME          2 * MAX_HELPER_WAIT_TIME



class CShortcutHelper
{
    public:
        CShortcutHelper();
        ~CShortcutHelper();
        HRESULT RunJob(CHString &chstrFileName, CHString &m_chstrTargetPathName, DWORD dwReqProps);
        
        void StopHelperThread();        

#ifdef NTONLY
        friend unsigned int __stdcall GetShortcutFileInfoW( void* a_lParam );
#endif
#ifdef WIN9XONLY
        friend unsigned int __stdcall GetShortcutFileInfoA( void* a_lParam );
#endif

    protected:

    private:

        CCritSec m_cs;
        HRESULT m_hrJobResult;
        HANDLE m_hTerminateEvt;
        HANDLE m_hRunJobEvt;
        HANDLE m_hJobDoneEvt;
        HANDLE m_hAllDoneEvt;
        CHString m_chstrLinkFileName;
        CHString m_chstrTargetPathName;
        unsigned m_uThreadID;
        DWORD m_dwReqProps;

        void StartHelperThread();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\shortcuthelper.cpp ===
//=================================================================

//

// ShortcutHelper.h -- CIMDataFile property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/24/99    a-kevhu         Created
//
//=================================================================

#include "precomp.h"
#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"
#include "ShortcutFile.h"
#include "ShortcutHelper.h"

#include <comdef.h>
#include <process.h>  // Note: NOT the one in the current directory!

#include <exdisp.h>
#include <shlobj.h>




CShortcutHelper::CShortcutHelper()
 : m_hTerminateEvt(NULL),
   m_hRunJobEvt(NULL),
   m_hJobDoneEvt(NULL),
   m_hAllDoneEvt(NULL),
   m_dwReqProps(0L)
{
    m_hTerminateEvt = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hRunJobEvt    = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hJobDoneEvt   = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hAllDoneEvt   = ::CreateEvent(NULL, FALSE, TRUE, NULL);  // Initially, we are all done, essentially.
}


CShortcutHelper::~CShortcutHelper()
{
    StopHelperThread();

    ::CloseHandle(m_hTerminateEvt);
    ::CloseHandle(m_hRunJobEvt);
    ::CloseHandle(m_hJobDoneEvt);
    ::CloseHandle(m_hAllDoneEvt);
}

void CShortcutHelper::StartHelperThread()
{
    HANDLE hWorkerThread = NULL;

#ifdef NTONLY
	hWorkerThread = (void*)_beginthreadex((void*)NULL,
									                (unsigned)0,
									                (unsigned (__stdcall*)(void*))GetShortcutFileInfoW,
									                (void*)this,
									                (unsigned)0,
									                &m_uThreadID ) ;


#endif
#ifdef WIN9XONLY
	hWorkerThread = (void*)(unsigned long)_beginthreadex((void*)NULL,
									                (unsigned)0,
									                (unsigned (__stdcall*)(void*))GetShortcutFileInfoA,
									                (void*)this,
									                (unsigned)0,
									                (unsigned*)&m_puThreadID);
#endif

    // Go ahead and close this now since no one will be waiting on it.
    CloseHandle(hWorkerThread);
}

void CShortcutHelper::StopHelperThread()
{
    // Tell the thread to go away.
    SetEvent(m_hTerminateEvt);

    // Don't do anything if this times out.  We just want to give the
    // thread time to finish what it's doing and clean up.
    ::WaitForSingleObject(m_hAllDoneEvt, MAX_KILL_TIME);

    // Set this again so the RunJob will know to restart the thread if
    // necessary.
    SetEvent(m_hAllDoneEvt);
}

HRESULT CShortcutHelper::RunJob(CHString &chstrFileName, CHString &chstrTargetPathName, DWORD dwReqProps)
{
    HRESULT hr = E_FAIL;

    // Start the thread if it idled out...
    if(::WaitForSingleObject(m_hAllDoneEvt, 0) == WAIT_OBJECT_0)
    {
        StartHelperThread();
    }

    // Need to synchronize access to member variables by running just
    // one job at a time...
    m_cs.Enter();

    // Initialize the variables the thread uses for the job...
    m_chstrLinkFileName = chstrFileName;
    m_dwReqProps = dwReqProps;

    // Tell the helper we are ready to run a job...
    ::SetEvent(m_hRunJobEvt);
    DWORD dwWaitResult = WAIT_TIMEOUT;
    if((dwWaitResult = ::WaitForSingleObject(m_hJobDoneEvt, MAX_JOB_TIME)) == WAIT_OBJECT_0)
    {
        hr = m_hrJobResult;
        chstrTargetPathName = m_chstrTargetPathName;
    }

    if(dwWaitResult == WAIT_TIMEOUT)
    {
        hr = S_OK;  // its ok, we just didn't get the target name in time
    }

    m_cs.Leave();

    return hr;
}




#ifdef NTONLY
unsigned int __stdcall GetShortcutFileInfoW( void* a_lParam )
{
    CShortcutHelper *t_this_ti = (CShortcutHelper*) a_lParam;
    HRESULT t_hResult = E_FAIL ;
	try
    {
        t_hResult = ::CoInitialize(NULL) ;

		if( SUCCEEDED( t_hResult )  && t_this_ti != NULL )
        {
			// The thread is ready to work.  Wait for a job, or for termination signal...
            HANDLE t_hHandles[2];
            t_hHandles[0] = t_this_ti->m_hRunJobEvt;
            t_hHandles[1] = t_this_ti->m_hTerminateEvt;

            while(::WaitForMultipleObjects(2, t_hHandles, FALSE, MAX_HELPER_WAIT_TIME) == WAIT_OBJECT_0)
            {
                // We have a job, so run it...
                WIN32_FIND_DATAW	t_wfdw ;
			    WCHAR				t_wstrGotPath[ _MAX_PATH * sizeof ( WCHAR ) ] ;
			    IShellLinkWPtr      t_pslw;

                ZeroMemory(t_wstrGotPath,sizeof(t_wstrGotPath));

                t_hResult = ::CoCreateInstance(CLSID_ShellLink,
										       NULL,
										       CLSCTX_INPROC_SERVER,
										       IID_IShellLinkW,
										       (void**)&t_pslw ) ;

                if( SUCCEEDED( t_hResult ) && ( NULL != t_pslw ) )
                {
                    IPersistFilePtr t_ppf;

                    // Get a pointer to the IPersistFile interface.
                    t_hResult = t_pslw->QueryInterface( IID_IPersistFile, (void**)&t_ppf ) ;

				    if( SUCCEEDED( t_hResult ) && ( NULL != t_ppf ) && !t_this_ti->m_chstrLinkFileName.IsEmpty() )
                    {
                        t_hResult = t_ppf->Load( (LPCWSTR)t_this_ti->m_chstrLinkFileName, STGM_READ ) ;
					    if(SUCCEEDED( t_hResult ) )
                        {
                            // Get the path to the link target, if required...
                            if( t_this_ti->m_dwReqProps & PROP_TARGET )
                            {
                                t_hResult = t_pslw->GetPath( t_wstrGotPath, (_MAX_PATH - 1)*sizeof(WCHAR), &t_wfdw, SLGP_UNCPRIORITY);
                                if ( t_hResult == NOERROR )
                                {
                                    if(wcslen(t_wstrGotPath) > 0)
                                    {
                                        t_this_ti->m_chstrTargetPathName = t_wstrGotPath ;
                                    }
                                }
                            }
                        }
                    }
                }
                t_this_ti->m_hrJobResult = t_hResult;
		        ::SetEvent(t_this_ti->m_hJobDoneEvt);
            }
        }
    }
    catch(...)
    {
        ::CoUninitialize();
        ::SetEvent(t_this_ti->m_hAllDoneEvt);
        throw;
    }

	::CoUninitialize();
    ::SetEvent(t_this_ti->m_hAllDoneEvt);

	 return(777);
}
#endif










#ifdef WIN9XONLY
unsigned int __stdcall GetShortcutFileInfoA( void* a_lParam )
{
#ifndef _UNICODE
    CShortcutHelper *t_this_ti = (CShortcutHelper*) a_lParam;
    HRESULT t_hResult = E_FAIL ;
	try
    {
        t_hResult = ::CoInitialize(NULL) ;

		if( SUCCEEDED( t_hResult )  && t_this_ti != NULL )
        {
			// The thread is ready to work.  Wait for a job, or for termination signal...
            HANDLE t_hHandles[2];
            t_hHandles[0] = t_this_ti->m_hRunJobEvt;
            t_hHandles[1] = t_this_ti->m_hTerminateEvt;

            while(::WaitForMultipleObjects(2,t_hHandles, FALSE, MAX_HELPER_WAIT_TIME) == WAIT_OBJECT_0)
            {
                // We have a job, so run it...
                WIN32_FIND_DATA     t_wfd ;
			    CHAR				t_strGotPath[ _MAX_PATH ] ;
			    IShellLinkAPtr      t_psla;

                ZeroMemory(t_strGotPath,sizeof(t_strGotPath));

                t_hResult = ::CoCreateInstance(CLSID_ShellLink,
										       NULL,
										       CLSCTX_INPROC_SERVER,
										       IID_IShellLinkA,
										       (void**)&t_psla ) ;

                if( SUCCEEDED( t_hResult ) && ( NULL != t_psla ) )
                {
                    IPersistFilePtr t_ppf;

                    // Get a pointer to the IPersistFile interface.
                    t_hResult = t_psla->QueryInterface( IID_IPersistFile, (void**)&t_ppf ) ;

				    if( SUCCEEDED( t_hResult ) && ( NULL != t_ppf ) && !t_this_ti->m_chstrLinkFileName.IsEmpty() )
                    {
                        t_hResult = t_ppf->Load( (LPCWSTR)t_this_ti->m_chstrLinkFileName, STGM_READ ) ;
					    if(SUCCEEDED( t_hResult ) )
                        {
                            // Get the path to the link target, if required...
                            if( t_this_ti->m_dwReqProps & PROP_TARGET )
                            {
                                t_hResult = t_psla->GetPath( t_strGotPath, (_MAX_PATH - 1)*sizeof(CHAR), &t_wfd, SLGP_UNCPRIORITY);
                                if ( t_hResult == NOERROR )
                                {
                                    if(_tcslen(t_strGotPath) > 0)
                                    {
                                        t_this_ti->m_chstrTargetPathName = t_strGotPath ;
                                    }
                                }
                            }
                        }
                    }
                }
                t_this_ti->m_hrJobResult = t_hResult;
		        ::SetEvent(t_this_ti->m_hJobDoneEvt);
            }
        }
    }
    catch(...)
    {
        ::CoUninitialize();
        ::SetEvent(t_this_ti->m_hAllDoneEvt);
        throw;
    }

    ::CoUninitialize();
    ::SetEvent(t_this_ti->m_hAllDoneEvt);
	return(777);

#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\share.h ===
//=================================================================

//

// Share.h -- Logical disk property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_SHARE L"Win32_Share"
#define  PROPSET_NAME_SECURITYDESCRIPTOR L"Win32_SecurityDescriptor"

#define METHOD_NAME_CREATE				L"Create"
#define METHOD_NAME_DELETE				L"Delete"
#define METHOD_NAME_SETSHAREINFO		L"SetShareInfo"
#define METHOD_NAME_GETACCESSMASK		L"GetAccessMask"

#define METHOD_ARG_NAME_RETURNVALUE		L"ReturnValue"
#define METHOD_ARG_NAME_PATH			L"Path"
#define METHOD_ARG_NAME_NAME			L"Name"
#define METHOD_ARG_NAME_TYPE			L"Type"
#define METHOD_ARG_NAME_PERMISSIONS		L"Permissions"
#define METHOD_ARG_NAME_COMMENT			L"Description"
#define METHOD_ARG_NAME_MAXIMUMALLOWED	L"MaximumAllowed"
#define METHOD_ARG_NAME_PASSWORD		L"Password"
#define METHOD_ARG_NAME_ACCESS			L"Access"


#define PROPERTY_VALUE_TYPE_DISKTREE	0
#define PROPERTY_VALUE_TYPE_PRINTQ		1
#define PROPERTY_VALUE_TYPE_DEVICE		2
#define PROPERTY_VALUE_TYPE_IPC			3
#define	PROPERTY_VALUE_TYPE_SPECIAL		4

#define PROPERTY_VALUE_PERMISSIONS_READ			ACCESS_READ		// 0x01
#define PROPERTY_VALUE_PERMISSIONS_WRITE		ACCESS_WRITE	// 0x02
#define PROPERTY_VALUE_PERMISSIONS_CREATE		ACCESS_CREATE	// 0x04
#define PROPERTY_VALUE_PERMISSIONS_EXEC			ACCESS_EXEC		// 0x08
#define PROPERTY_VALUE_PERMISSIONS_DELETE		ACCESS_DELETE	// 0x10
#define PROPERTY_VALUE_PERMISSIONS_ATTRIB		ACCESS_ATRIB	// 0x20
#define PROPERTY_VALUE_PERMISSIONS_PERM			ACCESS_PERM		// 0x40

#define PROPERTY_VALUE_PERMISSIONS_ALL     (PROPERTY_VALUE_PERMISSIONS_READ|PROPERTY_VALUE_PERMISSIONS_WRITE|PROPERTY_VALUE_PERMISSIONS_CREATE|PROPERTY_VALUE_PERMISSIONS_EXEC|PROPERTY_VALUE_PERMISSIONS_DELETE|PROPERTY_VALUE_PERMISSIONS_ATTRIB|PROPERTY_VALUE_PERMISSIONS_PERM)

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS							0
#endif

#undef STATUS_NOT_SUPPORTED					
#define STATUS_NOT_SUPPORTED					1

// Control
#undef STATUS_ACCESS_DENIED					
#define STATUS_ACCESS_DENIED					2
#define STATUS_UNKNOWN_FAILURE					8

// Start
#define STATUS_INVALID_NAME						9
#undef STATUS_INVALID_LEVEL					
#define STATUS_INVALID_LEVEL					10
#undef STATUS_INVALID_PARAMETER				
#define STATUS_INVALID_PARAMETER				21

#define STATUS_DUPLICATE_SHARE					22
#define STATUS_REDIRECTED_PATH					23
#define STATUS_UNKNOWN_DEVICE_OR_DIRECTORY		24
#define STATUS_NET_NAME_NOT_FOUND				25

// These structures stolen from svrapi.h which conflicts with other .h files
struct share_info_1 {
    char		shi1_netname[LM20_NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char FAR *		shi1_remark;
};  /* share_info_1 */

struct share_info_50 {
	char		shi50_netname[LM20_NNLEN+1];    /* share name */
	unsigned char 	shi50_type;                 /* see below */
    unsigned short	shi50_flags;                /* see below */
	char FAR *	shi50_remark;                   /* ANSI comment string */
	char FAR *	shi50_path;                     /* shared resource */
	char		shi50_rw_password[SHPWLEN+1];   /* read-write passwod (share-level security) */
	char		shi50_ro_password[SHPWLEN+1];   /* read-only password (share-level security) */
};	/* share_info_50 */

class Share:public Provider {

    public:

        // Constructor/destructor
        //=======================

        Share(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~Share() ;

        // Functions provide properties with current values
        //=================================================
		HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

		HRESULT ExecMethod (

			const CInstance& a_Instance,
			const BSTR a_MethodName,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags = 0L
		);

		HRESULT DeleteInstance (

			const CInstance& a_Instance,
			long a_Flags = 0L
		) ;

        // Utility
        //========
    private:

#ifdef NTONLY
        HRESULT EnumerateInstancesNT(MethodContext*  pMethodContext);
        HRESULT GetShareInfoNT(CNetAPI32 &NetAPI, const WCHAR *pShareName, CInstance* pInstance);
        bool GetAccessMask(LPCTSTR wstrShareName, ACCESS_MASK *pAccessMask);
#endif
#ifdef WIN9XONLY
        HRESULT EnumerateInstances95(MethodContext*  pMethodContext);
        HRESULT GetShareInfo95(CNetAPI32 &NetAPI, const char *pShareName, CInstance* pInstance);
#endif

		DWORD GetShareErrorCode ( DWORD a_ErrorCode ) ;

		HRESULT GetShareResultCode ( DWORD a_ErrorCode ) ;

		HRESULT CheckShareModification (

			const CInstance &a_Instance ,
			CInstance *a_InParams ,
			CInstance *a_OutParams ,
			DWORD &a_Status
		) ;

		HRESULT CheckShareCreation (

			CInstance *a_InParams ,
			CInstance *a_OutParams ,
			DWORD &a_Status
		) ;

		HRESULT ExecGetShareAccessMask (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecCreate (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecDelete (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecSetShareInfo (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\smbassoc.cpp ===
//=================================================================

//

// smbassoc.cpp --

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "SmbAssoc.h"

#include "smbios.h"
#include "smbstruc.h"

BOOL ValidateTagProperty( CInstance *a_pInst, LPCWSTR a_szAltTag, LPCWSTR a_szBaseTag, UINT *a_index ) ;


//==============================================================================
// Processor to cache info association

CWin32AssocProcMemory MyAssocProcMemorySet( PROPSET_NAME_ASSOCPROCMEMORY, IDS_CimWin32Namespace ) ;

//
CWin32AssocProcMemory::CWin32AssocProcMemory( LPCWSTR a_setName, LPCWSTR a_pszNamespace )
:Provider( a_setName, a_pszNamespace )
{

}

//
CWin32AssocProcMemory::~CWin32AssocProcMemory()
{
}

//
HRESULT CWin32AssocProcMemory::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT		t_hResult = WBEM_E_NOT_FOUND ;

	CHString	t_sAntecedent,
				t_sDependent ;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;

	// Get the two paths
	a_pInst->GetCHString( IDS_Antecedent, t_sAntecedent ) ;
	a_pInst->GetCHString( IDS_Dependent,  t_sDependent  ) ;

	if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sAntecedent, &t_pAntecedent, a_pInst->GetMethodContext() ) ) )
	{
		if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sDependent, &t_pDependent, a_pInst->GetMethodContext() ) ) )
		{
			t_hResult = WBEM_S_NO_ERROR ;
		}
	}

	return t_hResult ;
}

//
HRESULT CWin32AssocProcMemory::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	HRESULT t_hResult = WBEM_E_NOT_FOUND ;

	CHString	t_sAntecedent,
				t_sDependent ;

	TRefPointerCollection<CInstance> t_Antecedent ;
	REFPTRCOLLECTION_POSITION t_pos ;

	DWORD	t_instanceCount = 0 ;
    CSMBios	t_smbios ;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;
	CInstancePtr t_pInst;

	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_CacheMemory",
													&t_Antecedent,
													NULL,
													a_pMethodContext ) ;
	if ( SUCCEEDED( t_hResult ) && t_smbios.Init() )
	{
		int			t_cpuid,
                    t_cacheid = 0 ;
        PCACHEINFO  t_pci ;

        // I would have liked to assume this was always true on NT, but the
        // BIOS might actually report 2 CPUs on 9x, even though only one is
        // used.
        BOOL        bSingleCPU = t_smbios.GetNthStruct(4, 1) == NULL;

    	// get smbios struct and wbem instance simultaneously
		if ( t_Antecedent.BeginEnum( t_pos ) )
		{
            for (t_pAntecedent.Attach(t_Antecedent.GetNext( t_pos ));
                 SUCCEEDED( t_hResult ) &&
                 (t_pci = (PCACHEINFO) t_smbios.GetNthStruct( 7, t_cacheid++ )) &&
                 (t_pAntecedent != NULL);
                 t_pAntecedent.Attach(t_Antecedent.GetNext( t_pos )))
			{
                PSTLIST	        pstl = t_smbios.GetStructList(4);

				for ( t_cpuid = 0; SUCCEEDED( t_hResult ) && pstl; t_cpuid++ )
				{
            		PPROCESSORINFO t_ppi  = (PPROCESSORINFO) pstl->pshf;

                    // If we only have a single CPU, assume all cache instances
                    // belong to the single CPU.
                    // Matching cache handles are the binding check.  Cache handles are
					// in ver 2.1 and better.
					if ( bSingleCPU || (t_smbios.GetVersion() >= 0x00020001 &&
							(t_pci->Handle == t_ppi->L1_Cache_Handle ||
							t_pci->Handle == t_ppi->L2_Cache_Handle ||
							t_pci->Handle == t_ppi->L3_Cache_Handle)))
					{
						t_sDependent.Format( L"\\\\%s\\%s:Win32_Processor.DeviceID=\"CPU%d\"",
								GetLocalComputerName(), IDS_CimWin32Namespace, t_cpuid ) ;

						if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceKeysByPath( t_sDependent, &t_pDependent, a_pMethodContext ) ) )
						{
							GetLocalInstancePath( t_pAntecedent, t_sAntecedent ) ;

                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
							if (t_pInst != NULL)
							{
								t_pInst->SetCHString( IDS_Antecedent, t_sAntecedent ) ;
								t_pInst->SetCHString( IDS_Dependent,  t_sDependent  ) ;

								t_instanceCount++ ;

								t_hResult = t_pInst->Commit(  ) ;
							}
							else
							{
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
							}
						}
					}
					pstl = pstl->next;
				}
			}

			t_Antecedent.EndEnum() ;
		}
	}

	if ( SUCCEEDED( t_hResult ) && t_instanceCount < 1 )
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}


//==============================================================================
// Associate physical memory to logical memory device

CWin32MemoryDeviceLocation MyMemoryDeviceLocationSet( PROPSET_NAME_MEMORYDEVICELOCATION, IDS_CimWin32Namespace ) ;

//
CWin32MemoryDeviceLocation::CWin32MemoryDeviceLocation( LPCWSTR a_setName, LPCWSTR a_pszNamespace )
:Provider( a_setName, a_pszNamespace )
{

}

//
CWin32MemoryDeviceLocation::~CWin32MemoryDeviceLocation()
{
}

//
HRESULT CWin32MemoryDeviceLocation::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;

	UINT				t_AntecedentIndex,
						t_DependentIndex ;
	CHString			t_sAntecedent,
						t_sDependent ;

    CSMBios				t_smbios;
	PMEMDEVICE			t_pmd ;
	PMEMDEVICEMAPADDR	t_pmdma ;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;

	// Get the two paths
	a_pInst->GetCHString( IDS_Antecedent, t_sAntecedent ) ;
	a_pInst->GetCHString( IDS_Dependent,  t_sDependent  ) ;

    // Bug 161318: invalid to have exact same
    // antecedent and dependent (association with
    // equivalent endpoints.
    if(t_sAntecedent.CompareNoCase(t_sDependent) != 0)
    {
	    if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sAntecedent, &t_pAntecedent, a_pInst->GetMethodContext() ) ) )
	    {
		    if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sDependent, &t_pDependent, a_pInst->GetMethodContext() ) ) )
		    {
			    if ( ValidateTagProperty( t_pAntecedent, L"Tag", L"Physical Memory", &t_AntecedentIndex ) )
			    {
				    if ( t_smbios.Init() )
				    {
					    t_pmd = (PMEMDEVICE) t_smbios.GetNthStruct( 17, t_AntecedentIndex ) ;

					    if ( t_pmd && ValidateTagProperty(	t_pDependent,
														    L"DeviceID",
														    L"Memory Device",
														    &t_DependentIndex ) )
					    {
						    t_pmdma = (PMEMDEVICEMAPADDR) t_smbios.GetNthStruct( 20, t_DependentIndex ) ;

						    if ( t_pmdma && ( t_pmd->Handle == t_pmdma->Memory_Device_Handle ) )
						    {
							    t_hResult = WBEM_S_NO_ERROR ;
						    }
					    }
				    }
				    else
				    {
					    t_hResult = t_smbios.GetWbemResult() ;
				    }
			    }
		    }
	    }
    }
	return t_hResult ;
}

//
HRESULT CWin32MemoryDeviceLocation::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR;

	UINT		t_AntecedentIndex,
				t_DependentIndex ;
	CHString	t_AntecedentPath,
				t_DependentPath ;


	// Perform queries
	//================
	TRefPointerCollection<CInstance> t_antecedents ;
	TRefPointerCollection<CInstance> t_dependents ;

	REFPTRCOLLECTION_POSITION t_posAntecedent ;
	REFPTRCOLLECTION_POSITION t_posDependent ;

    CSMBios	t_smbios ;
	PMEMDEVICE t_pmd ;
	PMEMDEVICEMAPADDR t_pmdma ;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;
	CInstancePtr t_pInst;

	// grab all of both items that could be endpoints
	t_hResult = CWbemProviderGlue::GetAllInstances(	L"Win32_PhysicalMemory",
													&t_antecedents,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED( t_hResult ) )
	{
		return t_hResult ;
	}

	t_hResult = CWbemProviderGlue::GetAllInstances(	L"Win32_MemoryDevice",
													&t_dependents,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED( t_hResult ) )
	{
		return t_hResult ;
	}

	if ( !t_smbios.Init() )
	{
		return t_smbios.GetWbemResult() ;
	}

	if ( t_antecedents.BeginEnum( t_posAntecedent ) )
	{
        for (t_pAntecedent.Attach(t_antecedents.GetNext( t_posAntecedent ) );
             SUCCEEDED(t_hResult) && (t_pAntecedent != NULL);
             t_pAntecedent.Attach(t_antecedents.GetNext( t_posAntecedent ) ) )
		{
			// Extract element's binding property value
			//=========================================

			if ( ValidateTagProperty( t_pAntecedent, L"Tag", L"Physical Memory", &t_AntecedentIndex ) )
			{
				t_pmd = (PMEMDEVICE) t_smbios.GetNthStruct( 17, t_AntecedentIndex ) ;
			}
			else
			{
				t_pmd = NULL ;
			}
			// Associate w/all settings with matching props
			//=============================================
			if ( t_pmd && t_dependents.BeginEnum( t_posDependent ) )
			{
                for (t_pDependent.Attach(t_dependents.GetNext( t_posDependent ) );
                     SUCCEEDED (t_hResult) && (t_pDependent != NULL);
                     t_pDependent.Attach(t_dependents.GetNext( t_posDependent ) ))
				{
					if ( ValidateTagProperty(	t_pDependent,
												L"DeviceID",
												L"Memory Device",
												&t_DependentIndex ) )
					{
						t_pmdma = (PMEMDEVICEMAPADDR) t_smbios.GetNthStruct( 20, t_DependentIndex ) ;
					}
					else
					{
						t_pmdma = NULL;
					}

					if ( t_pmdma && ( t_pmd->Handle == t_pmdma->Memory_Device_Handle ) )
					{
						if ( GetLocalInstancePath( t_pAntecedent,  t_AntecedentPath ) &&
							 GetLocalInstancePath( t_pDependent, t_DependentPath ) )
						{
							// we got all the pieces - put them together...
                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
							if (t_pInst != NULL)
							{
								t_pInst->SetCHString( IDS_Antecedent, t_AntecedentPath ) ;
								t_pInst->SetCHString( IDS_Dependent,  t_DependentPath ) ;

								t_hResult = t_pInst->Commit(  ) ;
							}
							else
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
						}
					} // if variants equal

				} // while pDependent = dependents.GetNext

				t_dependents.EndEnum() ;
			} // if	dependents.BeginEnum

		} // while anty get next

		t_antecedents.EndEnum() ;
	} // if (antecedents.BeginEnum(

	return t_hResult ;
}

//==============================================================================
// Associate physical memory array to a logical memory array

CWin32MemoryArrayLocation MyMemoryArrayLocationSet( PROPSET_NAME_MEMORYARRAYLOCATION, IDS_CimWin32Namespace ) ;

//
CWin32MemoryArrayLocation::CWin32MemoryArrayLocation( LPCWSTR a_setName, LPCWSTR a_pszNamespace )
:Provider( a_setName, a_pszNamespace )
{

}

//
CWin32MemoryArrayLocation::~CWin32MemoryArrayLocation()
{
}

//
HRESULT CWin32MemoryArrayLocation::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;

	UINT				t_AntecedentIndex,
						t_DependentIndex ;
	CHString			t_sAntecedent,
						t_sDependent ;
	CSMBios				t_smbios;
	PPHYSMEMARRAY		t_ppma ;
	PMEMARRAYMAPADDR	t_pmama ;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;

	// Get the two paths
	a_pInst->GetCHString( IDS_Antecedent, t_sAntecedent ) ;
	a_pInst->GetCHString( IDS_Dependent,  t_sDependent  ) ;

    // Bug 161318: invalid to have exact same
    // antecedent and dependent (association with
    // equivalent endpoints.
    if(t_sAntecedent.CompareNoCase(t_sDependent) != 0)
    {
	    if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sAntecedent, &t_pAntecedent, a_pInst->GetMethodContext() ) ) )
	    {
		    if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sDependent, &t_pDependent, a_pInst->GetMethodContext() ) ) )
		    {
			    if ( ValidateTagProperty( t_pAntecedent, L"Tag", L"Physical Memory Array", &t_AntecedentIndex ) )
			    {
				    if ( t_smbios.Init() )
				    {
					    t_ppma = (PPHYSMEMARRAY) t_smbios.GetNthStruct( 16, t_AntecedentIndex ) ;

					    if ( t_ppma && ValidateTagProperty( t_pDependent,
														    L"DeviceID",
														    L"Memory Array",
														    &t_DependentIndex ) )
					    {
						    t_pmama = (PMEMARRAYMAPADDR) t_smbios.GetNthStruct( 19, t_DependentIndex ) ;

						    if ( t_pmama && ( t_ppma->Handle == t_pmama->Memory_Array_Handle ) )
						    {
							    t_hResult = WBEM_S_NO_ERROR ;
						    }
					    }
				    }
				    else
				    {
					    t_hResult = t_smbios.GetWbemResult() ;
				    }
			    }
		    }
	    }
    }

	return t_hResult ;
}


HRESULT CWin32MemoryArrayLocation::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;

	UINT		t_AntecedentIndex,
				t_DependentIndex;
	CHString	t_AntecedentPath,
				t_DependentPath ;

	// Perform queries
	//================
	TRefPointerCollection<CInstance> t_antecedents ;
	TRefPointerCollection<CInstance> t_dependents ;

	REFPTRCOLLECTION_POSITION t_posAntecedent;
	REFPTRCOLLECTION_POSITION t_posDependent;
    CSMBios				t_smbios;
	PPHYSMEMARRAY		t_ppma;
	PMEMARRAYMAPADDR	t_pmama;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;
	CInstancePtr t_pInst;

	// grab all of both items that could be endpoints
	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_PhysicalMemoryArray",
													&t_antecedents,
													NULL,
													a_pMethodContext ) ;

	if ( FAILED( t_hResult ) )
	{
		return t_hResult ;
	}

	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_MemoryArray",
													&t_dependents,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED( t_hResult ) )
	{
		return t_hResult ;
	}

	if ( !t_smbios.Init() )
	{
		return t_smbios.GetWbemResult() ;
	}

	if ( t_antecedents.BeginEnum( t_posAntecedent ) )
	{
        for (t_pAntecedent.Attach(t_antecedents.GetNext( t_posAntecedent ) );
             SUCCEEDED( t_hResult ) && (t_pAntecedent != NULL);
             t_pAntecedent.Attach(t_antecedents.GetNext( t_posAntecedent ) ))
		{
			// Extract element's binding property value
			//=========================================

			if ( ValidateTagProperty( t_pAntecedent, L"Tag", L"Physical Memory Array", &t_AntecedentIndex ) )
			{
				t_ppma = (PPHYSMEMARRAY) t_smbios.GetNthStruct( 16, t_AntecedentIndex ) ;
			}
			else
			{
				t_ppma = NULL ;
			}
			// Associate w/all settings with matching props
			//=============================================
			if ( t_ppma && t_dependents.BeginEnum( t_posDependent ) )
			{
                for (t_pDependent.Attach(t_dependents.GetNext( t_posDependent ) ) ;
                     SUCCEEDED( t_hResult ) && (t_pDependent != NULL);
                     t_pDependent.Attach(t_dependents.GetNext( t_posDependent ) ) )
				{
					if ( ValidateTagProperty( t_pDependent, L"DeviceID", L"Memory Array", &t_DependentIndex ) )
					{
						t_pmama = (PMEMARRAYMAPADDR) t_smbios.GetNthStruct( 19, t_DependentIndex ) ;
					}
					else
					{
						t_pmama = NULL ;
					}

					if ( t_pmama && ( t_ppma->Handle == t_pmama->Memory_Array_Handle ) )
					{
						if ( GetLocalInstancePath( t_pAntecedent,  t_AntecedentPath ) &&
							 GetLocalInstancePath( t_pDependent, t_DependentPath ) )
						{
							// we got all the pieces - put them together...
                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
							if ( t_pInst != NULL )
							{
								t_pInst->SetCHString( IDS_Antecedent, t_AntecedentPath ) ;
								t_pInst->SetCHString( IDS_Dependent,  t_DependentPath ) ;

								t_hResult = t_pInst->Commit(  ) ;
							}
							else
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
						}
					} // if variants equal

				} // while pDependent = dependents.GetNext

				t_dependents.EndEnum() ;

			} // if	dependents.BeginEnum

		} // while any get next

		t_antecedents.EndEnum() ;

	} // if (antecedents.BeginEnum(


	return t_hResult ;
}

//==============================================================================
// Associate physical memory to a physical memory array

CWin32PhysicalMemoryLocation MyPhysicalMemoryLocationSet( PROPSET_NAME_PHYSICALMEMORYLOCATION, IDS_CimWin32Namespace ) ;

//
CWin32PhysicalMemoryLocation::CWin32PhysicalMemoryLocation( LPCWSTR a_setName, LPCWSTR a_pszNamespace )
:Provider( a_setName, a_pszNamespace )
{}

//
CWin32PhysicalMemoryLocation::~CWin32PhysicalMemoryLocation()
{
}

//
HRESULT CWin32PhysicalMemoryLocation::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;

	UINT				t_GroupIndex,
						t_PartIndex ;
	CHString			t_sGroup,
						t_sPart ;
    CSMBios				t_smbios ;
	PPHYSMEMARRAY		t_ppma ;
	PMEMDEVICE			t_pmd ;

	// guarded resources
	CInstancePtr t_pGroup;
	CInstancePtr t_pPart;

	// Get the two paths
	a_pInst->GetCHString( IDS_GroupComponent, t_sGroup ) ;
	a_pInst->GetCHString( IDS_PartComponent,  t_sPart  ) ;

	if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sGroup, &t_pGroup, a_pInst->GetMethodContext()) ) )
	{
		if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sPart, &t_pPart, a_pInst->GetMethodContext() ) ) )
		{
			if ( ValidateTagProperty( t_pGroup, L"Tag", L"Physical Memory Array", &t_GroupIndex ) )
			{
				if ( t_smbios.Init() )
				{
					t_ppma = (PPHYSMEMARRAY) t_smbios.GetNthStruct( 16, t_GroupIndex ) ;
					if ( t_ppma && ValidateTagProperty( t_pPart, L"Tag", L"Physical Memory", &t_PartIndex ) )
					{
						t_pmd = (PMEMDEVICE) t_smbios.GetNthStruct( 17, t_PartIndex ) ;
						if ( t_pmd && ( t_ppma->Handle == t_pmd->Mem_Array_Handle ) )
						{
							t_hResult = WBEM_S_NO_ERROR ;
						}
					}
				}
				else
				{
					t_hResult = t_smbios.GetWbemResult() ;
				}
			}
		}
	}

	return t_hResult ;
}


HRESULT CWin32PhysicalMemoryLocation::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR ;

	UINT		t_GroupIndex,
				t_PartIndex ;
	CHString	t_GroupPath,
				t_PartPath ;

	// Perform queries
	//================
	TRefPointerCollection<CInstance> t_groups ;
	TRefPointerCollection<CInstance> t_parts ;

	REFPTRCOLLECTION_POSITION t_posGroup ;
	REFPTRCOLLECTION_POSITION t_posPart ;

	CSMBios			t_smbios ;
	PPHYSMEMARRAY	t_ppma ;
	PMEMDEVICE		t_pmd ;

	// guarded resources
	CInstancePtr t_pGroup;
	CInstancePtr t_pPart;
	CInstancePtr t_pInst;

	// grab all of both items that could be endpoints
	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_PhysicalMemoryArray",
													&t_groups,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED ( t_hResult ) )
	{
		return t_hResult ;
	}

	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_PhysicalMemory",
													&t_parts,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED ( t_hResult ) )
	{
		return t_hResult ;
	}

	if ( !t_smbios.Init() )
	{
		return t_smbios.GetWbemResult() ;
	}

	if ( t_groups.BeginEnum( t_posGroup ) )
	{
        for (t_pGroup.Attach(t_groups.GetNext( t_posGroup ) );
             SUCCEEDED( t_hResult ) && (t_pGroup != NULL);
             t_pGroup.Attach(t_groups.GetNext( t_posGroup ) ))
		{
			// Extract element's binding property value
			//=========================================
			if ( ValidateTagProperty( t_pGroup, L"Tag", L"Physical Memory Array", &t_GroupIndex ) )
			{
				t_ppma = (PPHYSMEMARRAY) t_smbios.GetNthStruct( 16, t_GroupIndex ) ;
			}
			else
			{
				t_ppma = NULL ;
			}
			// Associate w/all settings with matching props
			//=============================================
			if ( t_ppma && t_parts.BeginEnum( t_posPart ) )
			{
                for (t_pPart.Attach(t_parts.GetNext( t_posPart ) );
                     SUCCEEDED( t_hResult ) && (t_pPart != NULL);
                     t_pPart.Attach(t_parts.GetNext( t_posPart ) ))
				{
					if ( ValidateTagProperty( t_pPart, L"Tag", L"Physical Memory", &t_PartIndex ) )
					{
						t_pmd = (PMEMDEVICE) t_smbios.GetNthStruct( 17, t_PartIndex ) ;
					}
					else
					{
						t_pmd = NULL ;
					}

					if ( t_pmd && ( t_ppma->Handle == t_pmd->Mem_Array_Handle ) )
					{
						if ( GetLocalInstancePath( t_pGroup, t_GroupPath ) &&
							 GetLocalInstancePath( t_pPart,  t_PartPath ) )
						{
							// we got all the pieces - put them together...
                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
							if ( t_pInst != NULL )
							{
								t_pInst->SetCHString( IDS_GroupComponent, t_GroupPath ) ;
								t_pInst->SetCHString( IDS_PartComponent,  t_PartPath ) ;

								t_hResult = t_pInst->Commit(  ) ;
							}
							else
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
						}
					} // if variants equal
				} // while pDependent = dependents.GetNext

				t_parts.EndEnum() ;

			} // if	dependents.BeginEnum

		} // while any get next

		t_groups.EndEnum() ;

	} // if (antecedents.BeginEnum(

	return t_hResult ;
}


//==============================================================================
// Associate logial memory devices to logical memory arrays

CWin32MemoryDeviceArray MyMemoryDeviceArraySet( PROPSET_NAME_MEMDEVICEARRAY, IDS_CimWin32Namespace ) ;

//
CWin32MemoryDeviceArray::CWin32MemoryDeviceArray( LPCWSTR a_setName, LPCWSTR a_pszNamespace )
:Provider( a_setName, a_pszNamespace )
{
}

//
CWin32MemoryDeviceArray::~CWin32MemoryDeviceArray()
{
}

//
HRESULT CWin32MemoryDeviceArray::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;

	UINT				t_GroupIndex,
						t_PartIndex ;
	CHString			t_sGroup,
						t_sPart ;

    CSMBios				t_smbios ;
	PMEMARRAYMAPADDR	t_pmama ;
	PMEMDEVICEMAPADDR	t_pmdma ;

	// guarded resources
	CInstancePtr t_pGroup;
	CInstancePtr t_pPart;

	// Get the two paths
	a_pInst->GetCHString( IDS_GroupComponent, t_sGroup ) ;
	a_pInst->GetCHString( IDS_PartComponent,  t_sPart  ) ;

	if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sGroup, &t_pGroup, a_pInst->GetMethodContext()) ) )
	{
		if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sPart, &t_pPart, a_pInst->GetMethodContext() ) ) )
		{
			if ( ValidateTagProperty( t_pGroup, L"DeviceID", L"Memory Array", &t_GroupIndex ) )
			{
				if ( t_smbios.Init() )
				{
					t_pmama = (PMEMARRAYMAPADDR) t_smbios.GetNthStruct( 19, t_GroupIndex ) ;
					if ( t_pmama && ValidateTagProperty( t_pPart, L"DeviceID", L"Memory Device", &t_PartIndex ) )
					{
						t_pmdma = (PMEMDEVICEMAPADDR) t_smbios.GetNthStruct( 20, t_PartIndex ) ;

						if ( t_pmdma && ( t_pmama->Handle == t_pmdma->Mem_Array_Map_Addr_Handle ) )
						{
							t_hResult = WBEM_S_NO_ERROR ;
						}
					}
				}
				else
				{
					t_hResult = t_smbios.GetWbemResult() ;
				}
			}
		}
	}

	return t_hResult ;
}


HRESULT CWin32MemoryDeviceArray::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;

	UINT		t_GroupIndex,
				t_PartIndex ;
	CHString	t_GroupPath,
				t_PartPath ;

	// Perform queries
	//================
	TRefPointerCollection<CInstance> t_groups ;
	TRefPointerCollection<CInstance> t_parts ;

	REFPTRCOLLECTION_POSITION t_posGroup ;
	REFPTRCOLLECTION_POSITION t_posPart ;
    CSMBios				t_smbios;
	PMEMARRAYMAPADDR	t_pmama ;
	PMEMDEVICEMAPADDR	t_pmdma ;

	// guarded resources
	CInstancePtr t_pGroup;
	CInstancePtr t_pPart;
	CInstancePtr t_pInst;

	// grab all of both items that could be endpoints
	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_MemoryArray",
													&t_groups,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED(t_hResult ) )
	{
		return t_hResult ;
	}

	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_MemoryDevice",
													&t_parts,
													NULL,
													a_pMethodContext) ;
	if ( FAILED(t_hResult ) )
	{
		return t_hResult ;
	}

	if ( !t_smbios.Init() )
	{
		return t_smbios.GetWbemResult() ;
	}

	if ( t_groups.BeginEnum( t_posGroup ) )
	{
        for (t_pGroup.Attach(t_groups.GetNext( t_posGroup ) );
             SUCCEEDED( t_hResult ) && (t_pGroup != NULL);
             t_pGroup.Attach(t_groups.GetNext( t_posGroup ) ))
		{
			// Extract element's binding property value
			//=========================================

			if ( ValidateTagProperty( t_pGroup, L"DeviceID", L"Memory Array", &t_GroupIndex ) )
			{
				t_pmama = (PMEMARRAYMAPADDR) t_smbios.GetNthStruct( 19, t_GroupIndex ) ;
			}
			else
			{
				t_pmama = NULL ;
			}
			// Associate w/all settings with matching props
			//=============================================
			if ( t_pmama && t_parts.BeginEnum( t_posPart ) )
			{
                for (t_pPart.Attach(t_parts.GetNext( t_posPart ) );
                     SUCCEEDED( t_hResult ) && (t_pPart != NULL);
                     t_pPart.Attach(t_parts.GetNext( t_posPart ) ))
				{
					if ( ValidateTagProperty( t_pPart, L"DeviceID", L"Memory Device", &t_PartIndex ) )
					{
						t_pmdma = (PMEMDEVICEMAPADDR) t_smbios.GetNthStruct( 20, t_PartIndex ) ;
					}
					else
					{
						t_pmdma = NULL ;
					}

					if ( t_pmdma && ( t_pmama->Handle == t_pmdma->Mem_Array_Map_Addr_Handle ) )
					{
						if ( GetLocalInstancePath( t_pGroup, t_GroupPath ) &&
							 GetLocalInstancePath( t_pPart,  t_PartPath ) )
						{
							// we got all the pieces - put them together...
                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
							if ( t_pInst != NULL )
							{
								t_pInst->SetCHString( IDS_GroupComponent, t_GroupPath ) ;
								t_pInst->SetCHString( IDS_PartComponent,  t_PartPath ) ;

								t_hResult = t_pInst->Commit(  ) ;
							}
							else
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
						}
					} // if variants equal

				} // while pDependent = dependents.GetNext

				t_parts.EndEnum() ;

			} // if	dependents.BeginEnum

		} // while anty get next

		t_groups.EndEnum() ;

	} // if (antecedents.BeginEnum(

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\smbios.h ===
//=================================================================

//

// SMBIOS.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================


#ifndef _SMBIOS_H_
#define _SMBIOS_H_

#pragma pack(push,1)

// Entry point structure for SMBIOS
typedef struct tagSMB_EPS
{
	char	anchor[4];	
	BYTE	checksum;
	BYTE	length;
	BYTE	version_major;
	BYTE	version_minor;
	USHORT	max_struct_size;
	BYTE	revision;
	BYTE	formatted[5];
	char	ianchor[5];
	BYTE	ieps_checksum;
	USHORT	table_length;
	ULONG	table_addr;
	USHORT	struct_count;
	BYTE	bcd_revision;

} SMB_EPS;

// Entry point structure for DMIBIOS
typedef struct tagDMI_EPS
{
	char	anchor[5];
	BYTE	checksum;
	USHORT	table_length;
	ULONG	table_addr;
	USHORT	struct_count;
	BYTE	bcd_revision;

} DMI_EPS;

//==============================================================================
// 3.1.2 Structure Header Format 

typedef struct _tagSHF
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;

} SHF, *PSHF;


//==============================================================================
// 3.2.1 BIOS Information (Type 0)

typedef struct _tagBIOSINFO
{
	BYTE	Type;							// 0	BIOS Information Indicator
	BYTE	Length;							// Varies, 12h + number of BIOS Characteristics Extension Bytes
	WORD	Handle;
	BYTE	Vendor;
	BYTE	BIOS_Version;
	WORD	BIOS_Starting_Address_Segment;
	BYTE	BIOS_Release_Date;
	BYTE	BIOS_ROM_Size;
	BYTE	BIOS_Characteristics[8];
	BYTE	BIOS_Characteristics_Ext[1];	// usually, one could be more.  see note on length.

} BIOSINFO, *PBIOSINFO;


// 3.2.1.1 BIOS Characteristics 
//QWORD Bit Position	Meaning if Set

#define TYPE0_RESERVED00					0x0000000000000001
#define	TYPE0_RESERVED01					0x0000000000000002
#define UNKNOWN								0x0000000000000004
#define	BIOS_CHARACTERISTICS_NOT_SUPPORTED	0x0000000000000008
#define ISA_SUPPORT							0x0000000000000010
#define	MCA_SUPPORT							0x0000000000000020
#define EISA_SUPPORT						0x0000000000000040
#define	PCI_SUPPORT							0x0000000000000080
#define PC_CARD_SUPPORT						0x0000000000000100
#define	PNP_SUPPORT							0x0000000000000200
#define APM_SUPPORT							0x0000000000000400
#define	BIOS_IS_FLASH_UPGRADEABLE			0x0000000000000800
#define BIOS_SHADOWING						0x0000000000001000
#define	VL_VESA								0x0000000000002000
#define ESCD_SUPPORT						0x0000000000004000
#define	BOOT_FROM_CD						0x0000000000008000
#define SELECTABLE_BOOT						0x0000000000010000
#define	BIOS_ROM_SOCKETED 					0x0000000000020000
#define BOOT_FROM_PC_CARD					0x0000000000040000
#define	EDD_SPEC_SUPPORTED					0x0000000000080000
#define INT_13H_JPN_FLOPPY_NEC_9800_1_2MB	0x0000000000100000
#define	INT_13H_JPN_FLOPPY_TOSHIBA_1_2MB	0x0000000000200000
#define INT_13H_5_25_360KB_FLOPPY			0x0000000000400000
#define	INT_13H_5_25_1_2MB_FLOPPY			0x0000000000800000
#define INT_13H_3_5_720KB_FLOPPY			0x0000000001000000
#define	INT_13H_3_5_2_88MB_FLOPPY			0x0000000002000000
#define INT_5H_PRINT_SCREEN					0x0000000004000000
#define	INT_9H_8042_KEYBOARD				0x0000000008000000
#define INT_14H_SERIAL						0x0000000010000000
#define	INT_17H_PRINTER						0x0000000020000000
#define INT_10H_CGA_MONO_VIDEO				0x0000000040000000
#define	NEC_PC_98							0x0000000080000000
#define BIOS_VENDOR_RESERVED				0x0000ffff00000000
#define	SYSTEM_VENDOR_RESERVED				0xffff000000000000

// 3.2.1.2 BIOS Characteristics Extension Byte 1

#define ACPI_SUPPORT					0x01
#define USB_LEGACY_SUPPORT				0x02
#define AGP_SUPPORT						0x04
#define I2O BOOT_SUPPORT				0x08
#define LS_120_BOOT_SUPPORT				0x10
#define ATAPI_ZIP_DRIVE_BOOT_SUPPORT	0x20
#define IEEE1394_BOOT_SUPPORT			0x40
#define SMART_BATTERY_SUPPORT			0x80


//==============================================================================
// 3.2.2 System Information (Type 1)

typedef struct tagSYSTEMINFO
{
	BYTE	Type; 		// 1	Component ID Information  Indicator
	BYTE	Length;		// 08h or 19h	Length dependent on version supported
	WORD	Handle;
	BYTE	Manufacturer;
	BYTE	Product_Name;
	BYTE	Version;
	BYTE	Serial_Number;
	// Ver 2.1+ beyond here
	BYTE	UUID[16];
	BYTE	Wakeup_Type;

} SYSTEMINFO, *PSYSTEMINFO;

// 3.2.2.1 System - Wake-up Type

#define WU_RESERVED				0x00	
#define WU_OTHER				0x01	
#define WU_UNKNOWN				0x02	
#define WU_APM_TIMER			0x03	
#define WU_MODEM_RING			0x04	
#define WU_LAN_REMOTE 			0x05	
#define WU_POWER_SWITCH			0x06
#define WU_PCI_PME				0x07	



//==============================================================================
// 3.2.3 Base Board Information (Type 2)

typedef struct tagBOARDINFO
{
	BYTE	Type;			// 2	Base Board Information Indicator
	BYTE	Length;			// 08h	
	WORD	Handle;
	BYTE	Manufacturer;
	BYTE	Product;
	BYTE	Version;
	BYTE	Serial_Number;

} BOARDINFO, *PBOARDINFO;



//==============================================================================
// 3.2.4 System Enclosure or Chassis (Type 3)

typedef struct tagENCLOSURE
{
	BYTE 	Type;	// 3	System Enclosure Indicator
	BYTE	Length;	// Varies	09h for v2.0 implementations; 0Dh for v2.1 and later implementations.
	WORD	Handle;
	BYTE	Manufacturer;		// string offset
	BYTE	Chassis_Type;		// byte enum
	BYTE	Version;			// string offset
	BYTE	Serial_Number;		// string offset
	BYTE	Asset_Tag_Number;	// string offset
	// Ver 2.1+
	BYTE	Bootup_State;		// byte enum
	BYTE	Power_Supply_State;	// byte enum
	BYTE	Thermal_State;		// byte enum
	BYTE	Security_Status;	// byte enum
	// Ver 2.3+
	DWORD	OEM_Defined;

} ENCLOSURE, *PENCLOSURE;

// 3.2.4.1 System Enclosure or Chassis Types


#define CT_OTHER					0x01
#define CT_UNKNOWN					0x02
#define CT_DESKTOP					0x03
#define CT_LOW_PROFILE_DESKTOP		0x04
#define CT_PIZZA_BOX				0x05
#define CT_MINI_TOWER				0x06
#define CT_TOWER					0x07
#define CT_PORTABLE					0x08
#define CT_LAPTOP					0x09
#define CT_NOTEBOOK					0x0A
#define CT_HAND_HELD				0x0B
#define CT_DOCKING_STATION			0x0C
#define CT_ALL_IN_ONE				0x0D
#define CT_SUB_NOTEBOOK				0x0E
#define CT_SPACE_SAVING				0x0F
#define CT_LUNCH_BOX				0x10
#define CT_MAIN_SERVER				0x11
#define CT_EXPANSION				0x12
#define CT_SUBCHASSIS				0x13
#define CT_BUS_EXPANSION			0x14
#define CT_PERIPHERAL				0x15
#define CT_RAID						0x16
#define CT_RACK_MOUNT				0x17
#define CT_SEALED_CASE_PC			0x18

#define CT_UPPER					CT_SEALED_CASE_PC
#define CT_LOWER					CT_OTHER

// 3.2.4.1 Bit field indicating if a chasis lock is present
#define CT_LOCK_PRESENT				0x80


// 3.2.4.2 System Enclosure or Chassis States

#define CS_OTHER					0x01
#define CS_UNKNOWN					0x02
#define CS_SAFE						0x03
#define CS_WARNING					0x04
#define CS_CRITICAL					0x05
#define CS_NON_RECOVERABLE			0x06


// 3.2.4.3 System Enclosure or Chassis Security Status

#define CSS_OTHER							0x01
#define CSS_UNKNOWN							0x02
#define CSS_NONE							0x03
#define CSS_EXTERNAL_INTERFACE_LOCKED OUT	0x04
#define CSS_EXTERNAL_INTERFACE_ENABLED		0x05


//==============================================================================
// 3.2.5 Processor  Information (Type 4)

typedef struct tagPROCESSORINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Socket_Designation;		// string offset
	BYTE	Processor_Type;			// byte enum
	BYTE	Processor_Family;		// byte enum
	BYTE	Processor_Manufacturer;	// string offset
	BYTE	Processor_ID[8];		// byte array
	BYTE	Processor_Version;		// string offset
	BYTE	Voltage;				// byte enum and flags
	WORD	External_Clock;
	WORD	Max_Speed;
	WORD	Current_Speed;
	BYTE	Status;					// byte enum and flags
	BYTE	Processor_Upgrade;		// byte enum
	// Ver 2.1+ beyond here
	WORD	L1_Cache_Handle;		//	WORD	Varies	The handle of a Cache Information structure which defines the attributes of the primary (Level 1) cache for this processor.  The value is 0FFFFh if the processor has no L1 cache.
	WORD	L2_Cache_Handle;
	WORD	L3_Cache_Handle;

} PROCESSORINFO, *PPROCESSORINFO;

// 3.2.5.1 Processor Information - Processor Type
#define PT_OTHER					0x01	
#define PT_UNKNOWN					0x02	
#define PT_CENTRAL_PROCESSOR		0x03	
#define PT_MATH_PROCESSOR			0x04	
#define PT_DSP_ PROCESSOR			0x05	
#define PT_VIDEO_PROCESSOR			0x06	


// 3.2.5.2 Processor Information - Processor Family

#define PF_OTHER					0x01	
#define PF_UNKNOWN					0x02	
#define PF_8086						0x03	
#define PF_80286					0x04	
#define PF_INTEL386					0x05	
#define PF_INTEL486					0x06	
#define PF_8087						0x07	
#define PF_80287					0x08	
#define PF_80387					0x09	
#define PF_80487					0x0A	
#define PF_PENTIUM					0x0B	
#define PF_PENTIUM_PRO				0x0C	
#define PF_PENTIUM_II				0x0D	
#define PF_PENTIUM_MMX				0x0E	
#define PF_INTEL_CELERON			0x0F	
#define PF_RESERVED0_PENTIUM		0x10 
#define PF_RESERVED1_PENTIUM		0x11 
#define PF_M1						0x12	
#define PF_RESERVED0_M1				0x13 
#define PF_RESERVED1_M1				0x14 
#define PF_RESERVED2_M1				0x15 
#define PF_RESERVED3_M1				0x16 
#define PF_RESERVED4_M1				0x17 
#define PF_RESERVED5_M1				0x18 
#define PF_K5						0x19	
#define PF_RESERVED0_K5				0x1A 
#define PF_RESERVED1_K5				0x1B 
#define PF_RESERVED2_K5				0x1C 
#define PF_RESERVED3_K5				0x1D 
#define PF_RESERVED4_K5				0x1E 
#define PF_RESERVED5_K5				0x1F 
#define PF_POWER_PC					0x20	
#define PF_POWER_PC_601				0x21	
#define PF_POWER_PC_603				0x22	
#define PF_POWER_PC_603_PLUS		0x23	
#define PF_POWER_PC_604				0x24	
#define PF_ALPHA					0x30	
#define PF_MIPS						0x40	
#define PF_SPARC					0x50	
#define PF_68040					0x60	
#define PF_68XXX					0x61	
#define PF_68000					0x62	
#define PF_68010					0x63	
#define PF_68020					0x64	
#define PF_68030					0x65	
#define PF_HOBBIT					0x70	
#define PF_WEITEK					0x80	
#define PF_PA_RISC					0x90	
#define PF_V30						0xA0	


// 3.2.5.3 Processor ID Field Format

// 3.2.5.4 Processor Information - Voltage

#define V_LEGACY					0x80	// bit 7 legacy field

// if legacy is clear, these bits are defined as:
#define V_RESERVED					0x70	// bits 6 - 4 reserved
#define V_5V						0x01	// bit 0 indicates 5v support
#define V_3_3V						0x02	// bit 1 indicates 3.3v support
#define V_2_9V						0x04	// bit 2 indicates 2.9v support
#define V_RESERVED3					0x08	// bits 6 - 4 reserved

// if legacy is set, the the lower seven bits are the current processor voltage
#define V_VOLTAGE					0x7f	// voltage = ( value & V_VOLTAGE ) / 10;


// Processor Information - Status

#define	S_RESERVED					0x80	// bit 7 reserved
#define	S_SOCKET					0x40	// bit 6 set if socket is populated

#define	S_UNKNOWN					0x00
#define	S_CPU_ENABLED				0x01
#define	S_CPU_DISABLED_BY_USER		0x02
#define	S_CPU_DISABLED_BY_BIOS		0x03
#define	S_CPU_IDLE					0x04
#define S_RESERVED5					0x05
#define S_RESERVED6					0x06
#define	S_OTHER						0x07

// 3.2.5.5 Processor Information - Processor Upgrade

#define PU_OTHER					0x01
#define PU_UNKNOWN					0x02
#define PU_DAUGHTER_BOARD			0x03
#define PU_ZIF SOCKET				0x04
#define PU_REPLACEABLE_PIGGY_BACK	0x05
#define PU_NONE						0x06
#define PU_LIF_SOCKET				0x07
#define PU_SLOT_1					0x08
#define PU_SLOT_2					0x09


//==============================================================================
// 3.2.6 Memory Controller Information (Type 5)

typedef struct tagMEMCONTROLINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Error_Detecting_Method;			// byte enum
	BYTE	Error_Correcting_Capability;	// flags
	BYTE	Supported_Interleave;			// byte enum
	BYTE	Current_Interleave;				// byte enum
	BYTE	Maximum_Memory_Module_Size;		// value
	WORD	Supported_Speeds;				// flags
	WORD	Supported_Memory_Types;			// flags
	BYTE	Memory_Module_Voltage;			// flags
	BYTE	Associated_Memory_Slots;			// value
	WORD	Memory_Module_Cfg_Handles[1];	// word array
	// Ver 2.1+ beyond here
	// todo...
	// Enabled_Error_Correcting_Capabilities byte is here.  Depends on the above array size

} MEMCONTROLINFO, *PMEMCONTROLINFO;


// 3.2.6.1 Memory Controller Error Detecting Method
#define ED_OTHER					0x01
#define ED_UNKNOWN					0x02
#define ED_NONE						0x03
#define ED_8_BIT_PARITY				0x04
#define ED_32_BIT_ECC				0x05
#define ED_64_BIT_ECC				0x06
#define ED_128_BIT_ECC				0x07
#define ED_CRC						0x08


// 3.2.6.2 Memory Controller Error Correcting Capability
#define EC_OTHER					0x01
#define EC_UNKNOWN					0x02
#define EC_NONE						0x04
#define EC_SINGLE_BIT				0x08
#define EC_DOUBLE_BIT				0x10
#define EC_ERROR_SCRUBBING			0x20


//3.2.6.3 Memory Controller Information - Interleave Support
#define IS_OTHER					0x01	
#define IS_UNKNOWN					0x02	
#define IS_ONE_WAY					0x03	
#define IS_TWO_WAY					0x04	
#define IS_FOUR_WAY					0x05	
#define IS_EIGHT_WAY				0x06	
#define IS_SIXTEEN_WAY				0x07	


// 3.2.6.4 Memory Controller Information - Memory Speeds

#define MS_OTHER					0x0001
#define MS_UNKNOWN					0x0002
#define MS_70NS						0x0004
#define MS_60NS						0x0008
#define MS_50NS						0x0010





//==============================================================================
// 3.2.7 Memory Module Information (Type 6) 

typedef struct tagMEMMODULEINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Socket_Designation;
	BYTE	Bank_Connections;
	BYTE	Current_Speed;
	WORD	Current_Memory_Type;
	BYTE	Installed_Size;
	BYTE	Enabled_Size;
	BYTE	Error_Status;

} MEMMODULEINFO, *PMEMMODULEINFO;

//==============================================================================
//	3.2.8 Cache Information (Type 7)

typedef struct tagCACHEINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Socket_Designation;
	WORD	Cache_Configuration;		
	WORD	Maximum_Cache_Size;
	WORD	Installed_Size;
	WORD	Supported_SRAM_Type;
	WORD	Current_SRAM_Type;
	BYTE	Cache_Speed;
	BYTE	Error_Correction_Type;
	BYTE	System_Cache_Type;
	BYTE	Associativity;

} CACHEINFO, *PCACHEINFO;

//==============================================================================
// 3.2.9 Port Connector Information (Type 8)

typedef struct tagPORTCONNECTORINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Int_Reference_Designator;
	BYTE	Int_Connector_Type;
	BYTE	Ext_Reference_Designator;
	BYTE	Ext_Connector_Type;
	BYTE	Port_Type;

} PORTCONNECTORINFO, *PPORTCONNECTORINFO;


//==============================================================================
// 3.2.10 System Slots (Type 9)

typedef struct tagSYSTEMSLOTS
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Slot_Designation;
	BYTE	Slot_Type;
	BYTE	Slot_Data_Bus_Width;
	BYTE	Current_Usage;
	BYTE	Slot_Length;
	WORD	Slot_ID;
	BYTE	Slot_Characteristics1;
	BYTE	Slot_Characteristics2;

} SYSTEMSLOTS, *PSYSTEMSLOTS;

// Slot types
#define ST_OTHER	0x01
#define ST_UNKNOWN	0x02
#define ST_ISA		0x03
#define ST_MCA		0x04
#define ST_EISA		0x05
#define	ST_PCI		0x06
#define ST_PCMCIA	0x07
#define ST_PCI66	0x0e
#define ST_AGP		0x0f
#define ST_AGP2X	0x10
#define ST_AGP4X	0x11

//==============================================================================
// 3.2.12 OEM Strings (Type 11) 
typedef struct tagOEMSTRINGS
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Count;			// byte enum

} OEMSTRINGS, *POEMSTRINGS;


//==============================================================================
// 3.2.13 System Configuration Options (Type 12) 
typedef struct tagSYSCFGOPTIONS
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Count;			// byte enum

} SYSCFGOPTIONS, *PSYSCFGOPTIONS;


//==============================================================================
// 3.2.14 BIOS Language Information (Type 13) 
typedef struct tagBIOSLANGINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Installable_Languages;
	BYTE	Flags;
	BYTE	Reserved[15];
	BYTE	Current_Language;

} BIOSLANGINFO, *PBIOSLANGINFO;

//==============================================================================
// 3.2.17 Physical Memory Array (Type 16)
typedef struct tagPHYSMEMARRAY
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Location;
	BYTE	Use;
	BYTE	Mem_Error_Correction;
	DWORD	Max_Capacity;
	WORD	Mem_Error_Info_Handle;
	WORD	Memory_Devices;

} PHYSMEMARRAY, *PPHYSMEMARRAY;

//==============================================================================
// 3.2.18 Memory Device (Type 17)
typedef struct tagMEMDEVICE
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	WORD	Mem_Array_Handle;
	WORD	Mem_Error_Info_Handle;
	WORD	Total_Width;
	WORD	Data_Width;
	WORD	Size;
	BYTE	Form_Factor;
	BYTE	Device_Set;
	BYTE	Device_Locator;
	BYTE	Bank_Locator;
	BYTE	Memory_Type;
	WORD	Type_Detail;
	// Ver 2.3+
	WORD	Speed;

} MEMDEVICE, *PMEMDEVICE;


//==============================================================================
// 3.2.19 32-bit Memory Error Information (Type 18)
typedef struct tagMEMERRORINFO32
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Error_Type;
	BYTE	Error_Granularity;
	BYTE	Error_Operation;
	DWORD	Vendor_Syndrome;
	DWORD	Mem_Array_Error_Addr;
	DWORD	Device_Error_Addr;
	DWORD	Error_Resolution;

} MEMERRORINFO32, *PMEMERRORINFO32;


//==============================================================================
// 3.2.20 32-bit Memory Array Mapped Address (Type 19)
typedef struct tagMEMARRAYMAPADDR
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	DWORD	Starting_Address;
	DWORD	Ending_Address;
	WORD	Memory_Array_Handle;
	BYTE	Partition_Width;

} MEMARRAYMAPADDR, *PMEMARRAYMAPADDR;


//==============================================================================
// 3.2.21 32-bit Memory Device Mapped Address (Type 20)
typedef struct tagMEMDEVICEMAPADDR
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	DWORD	Starting_Address;
	DWORD	Ending_Address;
	WORD	Memory_Device_Handle;
	WORD	Mem_Array_Map_Addr_Handle;
	BYTE	Partition_Row;
	BYTE	Interleave_Position;
	BYTE	Interleaved_Data_Depth;

} MEMDEVICEMAPADDR, *PMEMDEVICEMAPADDR;


//==============================================================================
// 1.1.22 Built-in Pointing Device (Type 21)
typedef struct tagBUILTINPOINTDEVICE
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	DeviceType;
	BYTE	Interface;
	BYTE	Buttons;

} BUILTINPOINTDEVICE, *PBUILTINPOINTDEVICE;


//==============================================================================
// 1.1.23 Portable Battery (Type 22)
typedef struct tagPORTABLEBATTERY
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Location;
	BYTE	Manufacturer;
	BYTE	Manufacture_Date;
	BYTE	Serial_Number;
	BYTE	Device_Name;
	BYTE	Device_Chemistry;
	WORD	Design_Capacity;
	WORD	Design_Voltage;
	BYTE	SBDS_Version;
	BYTE	Max_Error;
	// Ver. 2.2+
	WORD	SBDS_Serial_Number;
	WORD	SBDS_Manufacture_Date;
	BYTE	SBDS_Device_Chemistry;
	BYTE	Design_Capacity_Mult;
	// Ver 2.3+
	DWORD	OEM_Specific;

} PORTABLEBATTERY, *PPORTABLEBATTERY;



//==============================================================================
// System Reset (Type 23)
typedef struct tagSYSTEMRESET
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Capabilities;
	WORD	ResetCount;
	WORD	ResetLimit;
	WORD	TimerInterval;
	WORD	Timeout;

} SYSTEMRESET, *PSYSTEMRESET;


//==============================================================================
// Hardware Security (Type 24)
typedef struct tagHARDWARESECURITY
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	SecuritySettings;

} HARDWARESECURITY, *PHARDWARESECURITY;


//==============================================================================
// Cooling Device (Types 27)
typedef struct tagCOOLINGDEVICE
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	WORD	TempProbeHandle;
	BYTE	Type_Status;
	BYTE	CoolingUnitGroup;
	DWORD	OEM_Defined;
	WORD	NominalSpeed;

} COOLINGDEVICE, *PCOOLINGDEVICE;


//==============================================================================
// Probe Info (Types 26, 28 and 29)
typedef struct tagPROBEINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Description;
	BYTE	Location_Status;
	WORD	MaxValue;
	WORD	MinValue;
	WORD	Resolution;
	WORD	Tolerance;
	WORD	Accuracy;
	DWORD	OEM_Defined;

} PROBEINFO, *PPROBEINFO;

//==============================================================================
// Voltage Probe (Type 26)
typedef PROBEINFO VOLTAGEPROBE, *PVOLTAGEPROBE;

//==============================================================================
// Temperature Probe (Type 28)
typedef PROBEINFO TEMPERATUREPROBE, *PTEMPERATUREPROBE;

//==============================================================================
// Electrical Current Probe (Type 29)
typedef PROBEINFO CURRENTPROBE, *PCURRENTPROBE;

#pragma pack(pop)

#endif	// #define _SMBIOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\smbiosprov.cpp ===
//=================================================================

//

// SmbiosProv.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "smbios.h"
#include "smbstruc.h"
#include "smbiosprov.h"
#include "smbtocim.h"
#include "resource.h"

// these are self contained in this source file
#define SMB_SYSTEMPRODUCT
#define SMB_BASEBOARD
#define SMB_SYSTEMENCLOSURE
#define SMB_CACHEMEMORY
#define SMB_PORTCONNECTOR
#define SMB_SYSTEMSLOT
#define SMB_PHYSICALMEMORY
#define SMB_PHYSMEMARRAY
#define SMB_PORTABLEBATTERY
#define SMB_PROBES
#define SMB_OEMBUCKET
#define SMB_MEMORYDEVICE
#define SMB_MEMORYARRAY
#define SMB_COOLINGDEVICE
#define SMB_ONBOARDDEVICE

//  mm/dd/yyyy
void FormatWBEMDate(WBEMTime &wbemdate, LPWSTR datestr)
{
	WCHAR	timestr[] = L"yyyymmdd000000.000000+000";
	int		len		= lstrlenW(datestr);

	if (len > 7)
	{
		if (len > 8)	// four digit year
		{
			timestr[ 0 ] = datestr[ 6 ];
			timestr[ 1 ] = datestr[ 7 ];
			timestr[ 2 ] = datestr[ 8 ];
			timestr[ 3 ] = datestr[ 9 ];
		}
		else			// two digit year
		{
			timestr[ 0 ] = '1';
			timestr[ 1 ] = '9';
			timestr[ 2 ] = datestr[ 6 ];
			timestr[ 3 ] = datestr[ 7 ];
		}
		timestr[ 4 ] = datestr[ 0 ];
		timestr[ 5 ] = datestr[ 1 ];
		timestr[ 6 ] = datestr[ 3 ];
		timestr[ 7 ] = datestr[ 4 ];
	}

#ifdef _UNICODE
	wbemdate = timestr;
#else
    wbemdate = _bstr_t(timestr);
#endif
}

BOOL ValidateTagProperty(CInstance *pInst, LPCWSTR szAltTag, LPCWSTR szBaseTag, UINT *index)
{
	CHString sTag;
	CHString sBaseTag;

	BOOL	bogus = TRUE;

	if (pInst)
	{
		if (szAltTag)
		{
			pInst->GetCHString(szAltTag, sTag);
		}
		else
		{
			pInst->GetCHString(L"Tag", sTag);
		}

		sTag.TrimRight();
		sTag.MakeUpper();

		sBaseTag = szBaseTag;
		sBaseTag.MakeUpper();

		if (sTag.Find(sBaseTag) == 0)
		{
			int spot, limit;
			TCHAR cTest = '\0';
			UINT tempindex = 0;

			limit = sTag.GetLength();
			spot  = sBaseTag.GetLength();
			cTest = sTag.GetAt(spot++);

			if (cTest == ' ')
			{
				bogus = FALSE;
				while (spot < limit && !bogus)
				{
    				cTest = sTag.GetAt(spot++);
					if (cTest >= '0' && cTest <= '9')
					{
						// Look out for bogus numbers like 01:
                        // If the number is '0' and tempindex is empty and
                        // we're not at the end, it's one of those bogus numbers.
                        if (cTest == '0' && !tempindex && spot != limit)
						{
                            bogus = TRUE;
                        }
						else
                        {
                            tempindex *= 10;
						    tempindex += (UINT) cTest - '0';
                        }
					}
					else
						bogus = TRUE;
				}
				if (!bogus)
				{
					*index = tempindex;
				}
			}
		}
	}

	return !bogus;
}

#ifdef SMB_SYSTEMPRODUCT
CWin32SystemProduct	MySystemProductSet(PROPSET_NAME_SYSTEMPRODUCT, IDS_CimWin32Namespace);

// The register/unregister caches the smbios data.
CWin32SystemProduct::CWin32SystemProduct(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32SystemProduct::~CWin32SystemProduct()
{
}

//
HRESULT CWin32SystemProduct::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
	HRESULT     hResult = WBEM_E_NOT_FOUND;

	CHString    strPathBefore,
                strPathAfter;

    CSMBios		smbios;

    // Get the previous __RELPATH
    GetLocalInstancePath(pInst, strPathBefore);

    if (smbios.Init())
    {
        PSTLIST	pstl = smbios.GetStructList(1);

		if (pstl)
		{
			hResult = LoadPropertyValues(pInst, smbios,
                (PSYSTEMINFO) pstl->pshf);
		}
	}

    // If we were able to get the properties but the new __RELPATH doesn't
    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
         strPathAfter.CompareNoCase(strPathBefore) != 0))
	{
        hResult = WBEM_E_NOT_FOUND;
	}
	return hResult;
}

//
HRESULT CWin32SystemProduct::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
	CSMBios		smbios;

	// guarded resource
	CInstance	*pInst = NULL;

	if (smbios.Init())
	{
        PSTLIST	pstl = smbios.GetStructList(1);

		if (pstl)
		{
			CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PSYSTEMINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32SystemProduct::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PSYSTEMINFO psi)
{
	WCHAR tempstr[MIF_STRING_LENGTH+1];

    CHString sTemp;
    LoadStringW(sTemp, IDR_ComputerSystemProduct);

	pInst->SetCHString(IDS_Caption, sTemp);
	pInst->SetCHString(IDS_Description, sTemp);

	if (smbios.GetStringAtOffset((PSHF) psi, tempstr, psi->Product_Name))
	{
		pInst->SetCharSplat(L"Name", tempstr);
	}
	else
	{
		pInst->SetCharSplat(L"Name", L"");
	}
	if (smbios.GetStringAtOffset((PSHF) psi, tempstr, psi->Version))
	{
    	pInst->SetCharSplat(L"Version", tempstr);
	}
	else
	{
    	pInst->SetCharSplat(L"Version", L"");
	}

	smbios.GetStringAtOffset((PSHF) psi, tempstr, psi->Manufacturer);
    pInst->SetCharSplat(L"Vendor", tempstr);

	smbios.GetStringAtOffset((PSHF) psi, tempstr, psi->Serial_Number);
    pInst->SetCharSplat(L"IdentifyingNumber", tempstr);

	if (smbios.GetVersion() > 0x00020000 && psi->Length >= sizeof(SYSTEMINFO))
	{
		// {8F680850-A584-11d1-BF38-00A0C9062910}
		swprintf(tempstr, L"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
					*(UNALIGNED ULONG*) psi->UUID,
					*(UNALIGNED USHORT*) &psi->UUID[ 4 ],
					*(UNALIGNED USHORT*) &psi->UUID[ 6 ],
					psi->UUID[ 8 ],
					psi->UUID[ 9 ],
					psi->UUID[ 10 ],
					psi->UUID[ 11 ],
					psi->UUID[ 12 ],
					psi->UUID[ 13 ],
					psi->UUID[ 14 ],
					psi->UUID[ 15 ]);

		pInst->SetCharSplat(L"UUID", tempstr);
	}
	else
	{
		// need somethimg to complete the key
	    lstrcpyW(tempstr, L"00000000-0000-0000-0000-000000000000");

		pInst->SetCharSplat(L"UUID", tempstr);
	}

    return WBEM_S_NO_ERROR;
}

#endif // SMB_SMBIOSINFO
//==============================================================================

//==============================================================================
// Base Board Class
//------------------------------------------------------------------------------
#ifdef SMB_BASEBOARD
CWin32BaseBoard	MyBaseBoardSet(PROPSET_NAME_BASEBOARD, IDS_CimWin32Namespace);

//
CWin32BaseBoard::CWin32BaseBoard(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32BaseBoard::~CWin32BaseBoard()
{
}

//
HRESULT CWin32BaseBoard::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
	HRESULT     hResult;
    CHString    strPathBefore,
                strPathAfter;
    CSMBios		smbios;

    // Get the previous __RELPATH
    GetLocalInstancePath(pInst, strPathBefore);

    if (smbios.Init())
    {
        PSTLIST	pstl = smbios.GetStructList(2);

		if (pstl)
		{
			hResult = LoadPropertyValues(pInst, smbios,
                (PBOARDINFO) pstl->pshf);
		}
	}

    // If we were able to get the properties but the new __RELPATH doesn't
    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
        strPathAfter.CompareNoCase(strPathBefore) != 0))
        hResult = WBEM_E_NOT_FOUND;

	return hResult;
}

HRESULT CWin32BaseBoard::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
	CSMBios		smbios;

	if (smbios.Init())
	{
        PSTLIST	pstl = smbios.GetStructList(2);
		if (pstl)
		{
			CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PBOARDINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32BaseBoard::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PBOARDINFO pbi)
{
	WCHAR tempstr[ MIF_STRING_LENGTH + 1 ];

	// guarded resource
	SAFEARRAY *psa = NULL;

	try
	{
		pInst->SetCharSplat(L"Tag", L"Base Board");
		pInst->Setbool(L"HostingBoard", true);
		pInst->Setbool(L"PoweredOn", true);

		pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_BASEBOARD);

        CHString sTemp;
        LoadStringW(sTemp, IDR_BaseBoard);

		pInst->SetCHString(IDS_Name, sTemp);
		pInst->SetCHString(IDS_Caption, sTemp );
		pInst->SetCHString(IDS_Description, sTemp);

		smbios.GetStringAtOffset((PSHF) pbi, tempstr, pbi->Manufacturer);
		pInst->SetCharSplat(L"Manufacturer", tempstr);

		smbios.GetStringAtOffset((PSHF) pbi, tempstr, pbi->Product);
		pInst->SetCharSplat(L"Product", tempstr);

		smbios.GetStringAtOffset((PSHF) pbi, tempstr, pbi->Version);
		pInst->SetCharSplat(L"Version", tempstr);

		smbios.GetStringAtOffset((PSHF) pbi, tempstr, pbi->Serial_Number);
		pInst->SetCharSplat(L"SerialNumber", tempstr);

		{
			//PSYSCFGOPTIONS psco = (PSYSCFGOPTIONS) smbios.GetFirstStruct(12);
    		PSTLIST			pstl = smbios.GetStructList(12);
			SAFEARRAY       *psa;
			SAFEARRAYBOUND  sab;

			if (pstl)
			{
	    		PSYSCFGOPTIONS	psco = (PSYSCFGOPTIONS) pstl->pshf;

				sab.lLbound = 0;
				sab.cElements = psco->Count;
				psa = SafeArrayCreate(VT_BSTR, 1, &sab);
				if (psa)
				{
					int i;

					for (i = 0; i < psco->Count; i++)
					{
    					_bstr_t bstr;
						int     len;

						len = smbios.GetStringAtOffset((PSHF) psco, tempstr, i + 1);
						bstr = tempstr;
						SafeArrayPutElement(psa, (long *) &i, (LPVOID) (BSTR) bstr);
					}

					pInst->SetStringArray(L"ConfigOptions", *psa);

				}
			}
		}
	}
	catch(...)
	{
		if(psa)
		{
			SafeArrayDestroy(psa);
		}
		throw;
	}

	SafeArrayDestroy(psa);
	psa = NULL;
	return WBEM_S_NO_ERROR;

}

#endif // SMB_BASEBOARD
//==============================================================================

//==============================================================================
// System Enclosure Class
//------------------------------------------------------------------------------
#ifdef SMB_SYSTEMENCLOSURE
CWin32SystemEnclosure	MySystemEnclosureSet(PROPSET_NAME_SYSTEMENCLOSURE, IDS_CimWin32Namespace);

//
CWin32SystemEnclosure::CWin32SystemEnclosure(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32SystemEnclosure::~CWin32SystemEnclosure()
{
}

//
HRESULT CWin32SystemEnclosure::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"Tag", L"System Enclosure", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PENCLOSURE pEnclosure =
                            (PENCLOSURE) smbios.GetNthStruct(3, instanceNum);

			if (pEnclosure)
			{
				hResult = LoadPropertyValues(pInst, smbios, pEnclosure);

			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
					hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}

HRESULT CWin32SystemEnclosure::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_S_NO_ERROR;
	CSMBios		smbios;

	if (smbios.Init())
	{
		int			    i;
		CHString	    sTemp;
        PSTLIST		    pstl = smbios.GetStructList(3);
		CInstancePtr    pInst;

		for (i = 0; pstl != NULL && i < 1000 && SUCCEEDED(hResult); i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"System Enclosure %d", i);
			pInst->SetCharSplat(L"Tag", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PENCLOSURE) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}

			pstl = pstl->next;
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32SystemEnclosure::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PENCLOSURE pe)
{
	WCHAR tempstr[ MIF_STRING_LENGTH + 1 ];

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_SYSTEMENCLOSURE);

    CHString sTemp;
    LoadStringW(sTemp, IDR_SystemEnclosure);

	pInst->SetCHString(IDS_Name, sTemp);
	pInst->SetCHString(IDS_Caption, sTemp);
	pInst->SetCHString(IDS_Description, sTemp);

	smbios.GetStringAtOffset((PSHF) pe, tempstr, pe->Manufacturer);
	pInst->SetCharSplat(L"Manufacturer", tempstr);

    pInst->Setbool(L"LockPresent", (0x80 & pe->Chassis_Type) ? true : false);


    // Create a safearray for the ChassisType
	SAFEARRAYBOUND  rgsabound[1];
	variant_t       vValue;

    rgsabound[0].cElements = 1;
    rgsabound[0].lLbound = 0;
    V_ARRAY(&vValue) = SafeArrayCreate(VT_I2, 1, rgsabound);
	if (V_ARRAY(&vValue))
	{
		long    ix[1] = { 0 };
		DWORD   dwVal = 0x7f & pe->Chassis_Type;

		if ((dwVal < CT_LOWER) || (dwVal > CT_UPPER))
		{
			dwVal = CT_UNKNOWN;
		}

		V_VT(&vValue) = VT_I2 | VT_ARRAY;

		HRESULT Result = SafeArrayPutElement(V_ARRAY(&vValue), ix, &dwVal);
		if (Result == E_OUTOFMEMORY)
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		pInst->SetVariant(L"ChassisTypes", vValue);
	}
	else
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}



	smbios.GetStringAtOffset((PSHF) pe, tempstr, pe->Version);
	pInst->SetCharSplat(L"Version", tempstr);

	smbios.GetStringAtOffset((PSHF) pe, tempstr, pe->Serial_Number);
	pInst->SetCharSplat(L"SerialNumber", tempstr);

	smbios.GetStringAtOffset((PSHF) pe, tempstr, pe->Asset_Tag_Number);
	pInst->SetCharSplat(L"SMBIOSAssetTag", tempstr);

	if (smbios.GetVersion() > 0x00020000 && pe->Length >= sizeof(ENCLOSURE))
	{
	    pInst->SetByte(L"SecurityStatus", pe->Security_Status);
	}

    return WBEM_S_NO_ERROR;
}

#endif // SMB_SYSTEMENCLOSURE
//==============================================================================


//==============================================================================
#ifdef SMB_CACHEMEMORY

CWin32CacheMemory	MyCacheMemorySet(PROPSET_NAME_CACHEMEMORY, IDS_CimWin32Namespace);

//
CWin32CacheMemory::CWin32CacheMemory(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32CacheMemory::~CWin32CacheMemory()
{
}

//
HRESULT CWin32CacheMemory::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"DeviceID", L"Cache Memory", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PCACHEINFO	pci = (PCACHEINFO) smbios.GetNthStruct(7, instanceNum);

			if (pci)
			{
				hResult = LoadPropertyValues(pInst, smbios, pci);

			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
					hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}


HRESULT CWin32CacheMemory::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_S_NO_ERROR;
	CSMBios		smbios;

	if (smbios.Init())
	{
		int			i;
		CHString	sTemp(L"Cache Memory XXX");
		//PCACHEINFO	pci = (PCACHEINFO) smbios.GetFirstStruct(7);
        PSTLIST		pstl = smbios.GetStructList(7);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000 && SUCCEEDED(hResult); i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"Cache Memory %d", i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PCACHEINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}

			pstl = pstl->next;
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32CacheMemory::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PCACHEINFO pci)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	DWORD		dwTemp;
	CHString	sTemp;

	pInst->GetCHString(L"DeviceID", sTemp);

	pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
	pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());
	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_CACHEMEMORY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_CacheMemory);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);
	pInst->SetCharSplat(IDS_Status, L"OK");

	smbios.GetStringAtOffset((PSHF) pci, tempstr, pci->Socket_Designation);
	pInst->SetCharSplat(L"Purpose", tempstr);

	// Write policy mapped here
	// ValueMap {"1", "2", "3", "4", "5"}: ToSubClass,
	// Values {"Other", "Unknown", "Write Back", "Write Through", "Varies with Address"}: ToSubClass,

	DWORD wp;

	switch ((pci->Cache_Configuration & 0x0300) >> 8)
	{
		case 0x00:	wp = 4; break;
		case 0x01:	wp = 3; break;
		case 0x02:	wp = 5; break;
		case 0x03:	wp = 2; break;
	}

	pInst->SetDWORD(L"WritePolicy", wp);

	pInst->SetDWORD(L"Availability", (pci->Cache_Configuration & 0x0080) ? 3 : 8);
	pInst->SetDWORD(L"StatusInfo", (pci->Cache_Configuration & 0x0080) ? 3 : 4);
	pInst->SetByte(L"Location", (BYTE) (pci->Cache_Configuration & 0x0060) >> 5);
	//pInst->Setbool("Socketed", (pci->Cache_Configuration & 0x0008) ? true : false);
	pInst->SetWBEMINT16(L"Level", (WORD) (pci->Cache_Configuration & 0x0007) + 3);

	dwTemp = pci->Maximum_Cache_Size & 0x8000 ? (pci->Maximum_Cache_Size & 0x7fff) * 64 : pci->Maximum_Cache_Size;
	pInst->SetDWORD(L"MaxCacheSize", dwTemp);

	dwTemp = pci->Installed_Size & 0x8000 ? (pci->Installed_Size & 0x7fff) * 64 : pci->Installed_Size;
	pInst->SetDWORD(L"InstalledSize", dwTemp);

	// use granularity as block size
	pInst->SetWBEMINT64(L"BlockSize",
        (__int64) ((pci->Installed_Size & 0x8000) ? 65536 : 1024));

	// the rest of installed size is the # of blocks
	pInst->SetWBEMINT64(L"NumberOfBlocks",
        (__int64) (pci->Installed_Size & 0x7fff));


	SAFEARRAYBOUND	sab;
	int				i;

	// count of supported SRAM types
	sab.lLbound	= 0;
	sab.cElements = 0;
	for (i = 0; i < 7; i++)
	{
		if (pci->Supported_SRAM_Type & (1 << i))
		{
			sab.cElements++;
		}
	}

	if (sab.cElements > 0)
	{
		variant_t vSRAM;

        if ((V_ARRAY(&vSRAM) = SafeArrayCreate(VT_UI1, 1, &sab)))
        {
			V_VT(&vSRAM) = VT_ARRAY | VT_UI1;

			long lElement = 0;

			for (BYTE b = 0; b < 7; b++)
			{
				if (pci->Supported_SRAM_Type & (1 << b))
				{
					SafeArrayPutElement(V_ARRAY(&vSRAM), &lElement, &b);
					lElement++;
				}
			}

			pInst->SetVariant(L"SupportedSRAM", vSRAM);
		}
    }

	// count of current SRAM types
	sab.lLbound	= 0;
	sab.cElements = 0;
	for (i = 0; i < 7; i++)
	{
		if (pci->Current_SRAM_Type & (1 << i))
		{
			sab.cElements++;
		}
	}

	if (sab.cElements > 0)
	{
		variant_t vSRAM;

        if ((V_ARRAY(&vSRAM) = SafeArrayCreate(VT_UI1, 1, &sab)))
		{
			V_VT(&vSRAM) = VT_ARRAY | VT_UI1;

			long lElement = 0;

            for (BYTE b = 0; b < 7; b++)
			{
			    if (pci->Current_SRAM_Type & (1 << b))
				{
					SafeArrayPutElement(V_ARRAY(&vSRAM), &lElement, &b);
					lElement++;
				}
			}

			pInst->SetVariant(L"CurrentSRAM", vSRAM);
		}
	}

	if (smbios.GetVersion() > 0x00020000 && pci->Length >= sizeof(CACHEINFO))
	{
		// Only set this if it's non zero.
        if (pci->Cache_Speed)
            pInst->SetDWORD(L"CacheSpeed", pci->Cache_Speed);

		pInst->SetDWORD(L"ErrorCorrectType", pci->Error_Correction_Type);
		pInst->SetDWORD(L"CacheType", pci->System_Cache_Type);
		pInst->SetDWORD(L"Associativity", pci->Associativity);
	}

	return WBEM_S_NO_ERROR;
}
#endif // SMB_CACHEINFO


//==============================================================================
// Port Connector class
//------------------------------------------------------------------------------
#ifdef SMB_PORTCONNECTOR
CWin32PortConnector	MyPortConnectorSet(PROPSET_NAME_PORTCONNECTOR, IDS_CimWin32Namespace);

//
CWin32PortConnector::CWin32PortConnector(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32PortConnector::~CWin32PortConnector()
{
}

//
HRESULT CWin32PortConnector::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, NULL, L"Port Connector", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PPORTCONNECTORINFO	ppci = (PPORTCONNECTORINFO) smbios.GetNthStruct(8, instanceNum);

			if (ppci)
			{
				hResult = LoadPropertyValues(pInst, smbios, ppci);

			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}

HRESULT CWin32PortConnector::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
	CSMBios		smbios;

	// guarded resource
	CInstance	*pInst = NULL;

	if (smbios.Init())
	{
		int 			i;
		CHString		sTemp(L"Port Connector XXX");
		//PPORTCONNECTORINFO	ppci = (PPORTCONNECTORINFO) smbios.GetFirstStruct(8);
        PSTLIST		    pstl = smbios.GetStructList(8);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"Port Connector %d", i);

			pInst->SetCharSplat(L"Tag", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PPORTCONNECTORINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			//ppci = (PPORTCONNECTORINFO) smbios.GetNextStruct(8);
			pstl = pstl->next;
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}


HRESULT CWin32PortConnector::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PPORTCONNECTORINFO ppci)
{
	WCHAR			tempstr[ MIF_STRING_LENGTH + 1 ];
	ULONG			CimVal;
	ULONG			ConnType[3];
	int				i;

	SAFEARRAYBOUND	sab;
	CHString		sTemp;

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PORTCONNECTOR);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PortConnector);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	smbios.GetStringAtOffset((PSHF) ppci, tempstr, ppci->Int_Reference_Designator);
	pInst->SetCharSplat(L"InternalReferenceDesignator", tempstr);

	smbios.GetStringAtOffset((PSHF) ppci, tempstr, ppci->Ext_Reference_Designator);
	pInst->SetCharSplat(L"ExternalReferenceDesignator", tempstr);

	// Put both the internal and external connector types into the array

	i = 0;
	CimVal = GetCimVal(ConnectorType, ppci->Ext_Connector_Type);
	if (CimVal == 0xff)
	{
		CimVal = 0;
	}
	if (CimVal)
	{
		ConnType[i++] = CimVal;
		CimVal = GetCimVal(ConnectorGender, ppci->Ext_Connector_Type);
		if (CimVal)
		{
			ConnType[i++] = CimVal;
		}
	}
	CimVal = GetCimVal(ConnectorType, ppci->Int_Connector_Type);
	if (CimVal == 0xff)
	{
		CimVal = 0;
	}
	if (CimVal)
	{
		ConnType[i++] = CimVal;
	}

	// if no connector types are found set just the first one to "unknown"
	if (i == 0)
	{
		ConnType[i++] = 0;
	}

	variant_t vType;

	sab.lLbound = 0;
	sab.cElements = i;	// max of 2 types plus a gender value
	if (i > 0 && (V_ARRAY(&vType) = SafeArrayCreate(VT_I4, 1, &sab)))
	{
		V_VT(&vType) = VT_ARRAY | VT_I4;

		for (i = 0; i < sab.cElements; i++)
		{
			SafeArrayPutElement(V_ARRAY(&vType), (long *) &i, &ConnType[i]);
		}

		pInst->SetVariant(L"ConnectorType", vType);

		pInst->SetDWORD(L"PortType", ppci->Port_Type == 0xff ? 0 : ppci->Port_Type);
    }

	return WBEM_S_NO_ERROR;
}
#endif // SMB_PORTCONNECTOR


//==============================================================================
// System Slot class
//------------------------------------------------------------------------------
#ifdef SMB_SYSTEMSLOT
CWin32SystemSlot	MySystemSlotSet(PROPSET_NAME_SYSTEMSLOT, IDS_CimWin32Namespace);

//
CWin32SystemSlot::CWin32SystemSlot(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32SystemSlot::~CWin32SystemSlot()
{
}

//
HRESULT CWin32SystemSlot::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, NULL, L"System Slot", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PSYSTEMSLOTS pss = (PSYSTEMSLOTS) smbios.GetNthStruct(9, instanceNum);

			if (pss)
			{
				hResult = LoadPropertyValues(pInst, smbios, pss);

			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}

	return hResult;
}

HRESULT CWin32SystemSlot::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
	CSMBios		smbios;

	if (smbios.Init())
    {
        int 			i;
		CHString		sTemp(L"System Slot XXX");
        //PSYSTEMSLOTS	pss = (PSYSTEMSLOTS) smbios.GetFirstStruct(9);
        PSTLIST		    pstl = smbios.GetStructList(9);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"System Slot %d", i);
			pInst->SetCharSplat(L"Tag", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PSYSTEMSLOTS) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
			//pss = (PSYSTEMSLOTS) smbios.GetNextStruct(9);
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32SystemSlot::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PSYSTEMSLOTS pss)
{
	WCHAR			tempstr[MIF_STRING_LENGTH+1];
	BOOL			cardbus;
	SAFEARRAYBOUND	sab;
	CHString		sTemp;

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_SYSTEMSLOT);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_SystemSlot);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	// Properties in Win32_SystemSlot
	smbios.GetStringAtOffset((PSHF) pss, tempstr, pss->Slot_Designation);
	pInst->SetCharSplat(L"SlotDesignation", tempstr);
	pInst->SetByte(L"CurrentUsage", pss->Current_Usage);

	// status
	switch(pss->Current_Usage)
	{
		case 0x04:
		case 0x03:
			pInst->SetCHString(IDS_Status, L"OK");
			break;

		case 0x02:
		case 0x01:
			pInst->SetCHString(IDS_Status, L"Unknown");
			break;

		default:
			pInst->SetCHString(IDS_Status, IDS_STATUS_Error);
	}

	// Properties in CIM_Slot
	switch (pss->Slot_Type)
	{
		case ST_MCA:
		case ST_EISA:
		case ST_PCI:
		case ST_PCI66:
		case ST_AGP:
			pInst->SetWBEMINT16(L"Number", pss->Slot_ID & 0x00ff);
			break;

		case ST_PCMCIA:
			pInst->SetWBEMINT16(L"Number", pss->Slot_ID & 0x00ff);
			// need to do something with socket number (pss->SloID >> 8) in case of PCMCIA
			break;

		default:
			break;
	}

	// SMBIOS to CIM mapping skewed by 3 for data width
	//	 ValueMap {"8", "16", "32", "64", "128"},
	if (pss->Slot_Data_Bus_Width > 2)
	{
		pInst->SetByte(L"MaxDataWidth", pss->Slot_Data_Bus_Width - 3);
	}

	// Is slot shared?
	pInst->Setbool(L"Shared", pss->Slot_Characteristics1 & 0x08 ? true : false);

	// Slot Length only differentiates between short and long.  Length in inches is not known
	// unless there are standard values for short and long.
	//pInstance->SetWBEMINT16(L"LengthAllowed", pss->SloLength);
	sab.lLbound = 0;
	sab.cElements = 1;

	// check for special case of PCMCIA - is cardbus supported
	cardbus = (pss->Slot_Characteristics1 & 0x20) ? true : false;
	if (cardbus)
	{
		sab.cElements++;
	}

    variant_t vType;
	if ((V_ARRAY(&vType) = SafeArrayCreate(VT_I4, 1, &sab)))
	{
		ULONG CimVal;
		int i = 0;

		V_VT(&vType) = VT_ARRAY | VT_I4;

		CimVal = GetCimVal(SlotType, pss->Slot_Type);
		SafeArrayPutElement(V_ARRAY(&vType), (long *) &i, &CimVal);
		if (cardbus)
		{
			i++;
			CimVal = 52;
			//CimVal = CIM_SLOT_TYPE_CARDBUS;
			SafeArrayPutElement(V_ARRAY(&vType), (long *) &i, &CimVal);
		}

		pInst->SetVariant(L"ConnectorType", vType);
	}

	// pick apart the Characteristics1 byte

	// set slot voltage
    // Values {"Unknown", "Other", "3.3V", "5V"},

	ULONG voltages[4];

	sab.lLbound = 0;
	sab.cElements = 0;
	if ((pss->Slot_Characteristics1 & 0x01) || (!(pss->Slot_Characteristics1 & 0x06)))
	{
		voltages[ sab.cElements ] = 0;	// "Unknown"
		sab.cElements++;
	}
	else
	{
		if (pss->Slot_Characteristics1 & 0x02)
		{
			voltages[ sab.cElements ] = 3;	// "5V"
			sab.cElements++;
		}
		if (pss->Slot_Characteristics1 & 0x04)
		{
			voltages[ sab.cElements ] = 2;	// "3.3V"
			sab.cElements++;
		}
	}

    variant_t vVoltage;
	if (V_ARRAY(&vVoltage) = SafeArrayCreate(VT_I4, 1, &sab))
	{
		int i;

		V_VT(&vVoltage) = VT_ARRAY | VT_I4;

		for (i = 0; i < sab.cElements; i++)
		{
			SafeArrayPutElement(V_ARRAY(&vVoltage), (long *) &i, &voltages[ i ]);
		}

		pInst->SetVariant(L"VccMixedVoltageSupport", vVoltage);
	}

	// NOTE!! add shared slots association here
	if (smbios.GetVersion() > 0x00020000 && pss->Length >= sizeof(SYSTEMSLOTS))
	{
		pInst->Setbool(L"SupportsHotPlug", pss->Slot_Characteristics2 & 0x02 ? true : false);
		pInst->Setbool(L"PMESignal", pss->Slot_Characteristics2 & 0x01 ? true : false);
	}

	return WBEM_S_NO_ERROR;
}
#endif // SMB_SYSTEMSLOT
//==============================================================================


//==============================================================================
// On Board Devices class
//------------------------------------------------------------------------------
#ifdef SMB_ONBOARDDEVICE
CWin32OnBoardDevice	MyOnBoardDevice(PROPSET_NAME_ONBOARDDEVICE, IDS_CimWin32Namespace);

//
CWin32OnBoardDevice::CWin32OnBoardDevice(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32OnBoardDevice::~CWin32OnBoardDevice()
{
}

//
HRESULT CWin32OnBoardDevice::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, NULL, L"On Board Device", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PSTLIST pstl = smbios.GetStructList(10);
			PSHF pshf = NULL;
			if (pstl)
			{
				pshf = pstl->pshf;
				if ((instanceNum > 0) && (pshf->Length < (4 + 2 * (instanceNum + 1))))
		        {
		        	pshf = smbios.GetNthStruct(10, instanceNum);
				}
			}

			if (pshf)
			{
				hResult = LoadPropertyValues(pInst, smbios, pshf, instanceNum);
			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
			        hResult = WBEM_E_NOT_FOUND;
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}

HRESULT CWin32OnBoardDevice::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hr			=	WBEM_E_NOT_FOUND;
    CSMBios smbios;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        PSTLIST			pstl = smbios.GetStructList(10);

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
		    CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

			sTemp.Format(L"On Board Device %d", i);
			pInst->SetCharSplat(L"Tag", sTemp);
			if ((hr = LoadPropertyValues(pInst, smbios, pstl->pshf, i)) == WBEM_S_NO_ERROR)
			{
                hr = pInst->Commit();
			}

			if (pstl->pshf->Length <= (4 + 2 * (i + 1)))
	        {
	        	pstl = pstl->next;
			}
        }
		// Commit will Release pInstance
	}
	else
	{
		hr = smbios.GetWbemResult();
	}

	return hr;
}

//
HRESULT CWin32OnBoardDevice::LoadPropertyValues(
												CInstance *pInst,
												CSMBios &smbios,
												PSHF pshf,
												UINT instanceNum)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString	sTemp;
	ULONG		byteoff;

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_ONBOARDDEVICE);
	pInst->SetCharSplat(IDS_Name, L"On Board Device");
	pInst->SetCharSplat(IDS_Caption, L"On Board Device");
	pInst->SetCharSplat(IDS_Description, L"On Board Device");

	byteoff = 4;
	if (pshf->Length > (4 + (instanceNum * 2)))
	{
		byteoff += (instanceNum * 2);
	}

	pInst->SetDWORD(L"DeviceType", *((PBYTE) pshf + byteoff) & 0x7f);
	pInst->Setbool(L"Enabled", (*((PBYTE) pshf + byteoff) & 0x80) ? true : false);

	smbios.GetStringAtOffset(pshf, tempstr, *((PBYTE) pshf + byteoff + 1));
	pInst->SetCharSplat(L"Description", tempstr);

    return WBEM_S_NO_ERROR;
}
#endif // SMB_ONBOARDDEVICES
//==============================================================================


//==============================================================================
// BIOS Language class
//------------------------------------------------------------------------------
#ifdef SMB_BIOSLANG
CWin32BIOSLanguage	MyBIOSLanguageSet(PROPSET_NAME_BIOSLANG, IDS_CimWin32Namespace);

//
CWin32BIOSLanguage::CWin32BIOSLanguage(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32BIOSLanguage::~CWin32BIOSLanguage()
{
}

//
HRESULT CWin32BIOSLanguage::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult;
    CSMBios		smbios;

    if (smbios.Init())
    {
        //PBIOSLANGINFO pbli = (PBIOSLANGINFO) smbios.GetFirstStruct(13);
		PSTLIST	pstl = smbios.GetStructList(13);

        if (pstl)
		{
			hResult = LoadPropertyValues(pInst, smbios,
                (PBIOSLANGINFO) pstl->pshf);
		}
	}

    // If we were able to get the BIOS properties but the new __RELPATH doesn't
    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
    //if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
    //    strPathAfter.CompareNoCase(strPathBefore) != 0))
    //    hResult = WBEM_E_NOT_FOUND;

	return hResult;
}

HRESULT CWin32BIOSLanguage::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT	hResult = WBEM_E_NOT_FOUND;
    CSMBios smbios;

    if (smbios.Init())
    {
        //PBIOSLANGINFO pbli = (PBIOSLANGINFO) smbios.GetFirstStruct(13);
		PSTLIST	pstl = smbios.GetStructList(13);

		CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

		if (pbli)
		{
			pInst->SetCharSplat(L"InstanceName", L"Bios Language");
			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PBIOSLANGINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;

}

HRESULT CWin32BIOSLanguage::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PBIOSLANGINFO pbli)
{
	WCHAR tempstr[ MIF_STRING_LENGTH + 1 ];

	pInst->SetByte(L"InstallableLanguages", pbli->Installable_Languages);

	if (smbios.GetVersion() > 0x00020000 && pbli->Length >= sizeof(BIOSLANGINFO))
	{
	    pInst->Setbool(L"AbbrStrings", pbli->Flags & 0x01 ? true : false);
	}

	smbios.GetStringAtOffset((PSHF) pbli, tempstr, pbli->CurrenLanguage);
	pInst->SetCharSplat(L"CurrentLanguage", tempstr);

    return WBEM_S_NO_ERROR;
}
#endif // SMB_BIOSLANG
//==============================================================================


//==============================================================================
#ifdef SMB_PHYSICALMEMORY

CWin32PhysicalMemory	MyPhysicalMemorySet(PROPSET_NAME_PHYSICALMEMORY, IDS_CimWin32Namespace);

//
CWin32PhysicalMemory::CWin32PhysicalMemory(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32PhysicalMemory::~CWin32PhysicalMemory()
{
}

//
HRESULT CWin32PhysicalMemory::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hr = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"Tag", L"Physical Memory", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PSHF	pshf = smbios.GetNthStruct(17, instanceNum);

			if (pshf)
			{
				hr = LoadPropertyValues_MD(pInst, smbios, (PMEMDEVICE) pshf);
			}
			else
			{
		        pshf = smbios.GetNthStruct(6, instanceNum);
				if (pshf)
				{
					hr = LoadPropertyValues_MI(pInst, smbios, (PMEMMODULEINFO) pshf);
				}
			}
		    // If we were able to get the BIOS properties but the new __RELPATH doesn't
		    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
		    if (SUCCEEDED(hr) && (!GetLocalInstancePath(pInst, strPathAfter) ||
		        strPathAfter.CompareNoCase(strPathBefore) != 0))
		        hr = WBEM_E_NOT_FOUND;
		}
		else
		{
			hr = smbios.GetWbemResult();
		}
	}

	return hr;
}

HRESULT CWin32PhysicalMemory::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hr			=	WBEM_E_NOT_FOUND;
    CSMBios		smbios;
	BOOL		altstruct = FALSE;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        PSTLIST			pstl = smbios.GetStructList(17);

		if (!pstl)
		{
	        pstl = smbios.GetStructList(6);
			altstruct = TRUE;
		}

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
    		CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

			sTemp.Format(L"Physical Memory %d", i);
			pInstance->SetCharSplat(L"Tag", sTemp);
			if (altstruct)
			{
                hr =
                    LoadPropertyValues_MI(
                        pInstance,
                        smbios,
                        (PMEMMODULEINFO) pstl->pshf);
			}
			else
			{
				hr = LoadPropertyValues_MD(pInstance, smbios, (PMEMDEVICE) pstl->pshf);
			}
			if (hr == WBEM_S_NO_ERROR)
			{
				hr = pInstance->Commit();
			}
            // No big deal if the memory wasn't found (means the slot was empty).
            else if (hr == WBEM_E_NOT_FOUND)
                hr = WBEM_S_NO_ERROR;

			//pshf = smbios.GetNthStruct(altstruct ? 6 : 17, i + 1);
			pstl = pstl->next;
        }
		// Commit will Release pInstance
	}
	else
	{
		hr = smbios.GetWbemResult();
	}

	return hr;
}

HRESULT CWin32PhysicalMemory::LoadPropertyValues_MD(CInstance *pInst, CSMBios &smbios, PMEMDEVICE pmd)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString	sTemp;

	// This is not a valid memory if the size is 0 (means the bank is empty).
    if (!pmd->Size)
        return WBEM_E_NOT_FOUND;

    pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PHYSICALMEMORY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PhysicalMemory);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	// V2.1 properties
	if (smbios.GetVersion() > 0x00020000 && pmd->Length >= ((PBYTE) &pmd->Speed - (PBYTE) pmd))
	{
		__int64 memsize;

		// this goes into an association later
		//pInstance->SetDWORD(L"MemArrayHandle", pmd->Mem_Array_Handle);
		// this goes into an association later
		//pInstance->SetDWORD(L"MemErrorInfoHandle", pmd->Mem_Error_Info_Handle);

		if (pmd->Total_Width != 0xffff )
		{
			pInst->SetDWORD(L"TotalWidth", pmd->Total_Width);
		}
		if (pmd->Data_Width != 0xffff)
		{
			pInst->SetDWORD(L"DataWidth", pmd->Data_Width);
		}

		if (pmd->Size != 0xffff)
		{
			memsize = (__int64)(pmd->Size & 0x7fff);
			if (pmd->Size & 0x8000) // check multiplier
			{
				// one K multiplier
				memsize <<= 10;
			}
			else
			{
				// one Meg multiplier
				memsize <<= 20;
			}
            swprintf(tempstr, L"%I64d", memsize);
			pInst->SetWBEMINT64(L"Capacity", tempstr);
        }

		// this needs a CIM mapper -- FormFactor
		pInst->SetDWORD(L"FormFactor", GetCimVal(FormFactor, pmd->Form_Factor));

		// this goes into an association later
		//pInst->SetDWORD(L"DeviceSet", pmd->Device_Set);

		smbios.GetStringAtOffset((PSHF) pmd, tempstr, pmd->Device_Locator);
		pInst->SetCharSplat(L"DeviceLocator", tempstr);

		smbios.GetStringAtOffset((PSHF) pmd, tempstr, pmd->Bank_Locator);
		pInst->SetCharSplat(L"BankLabel", tempstr);

		// this needs a CIM mapper -- MemoryType
 		pInst->SetDWORD(L"MemoryType", GetCimVal(MemoryType, pmd->Memory_Type));
		pInst->SetDWORD(L"TypeDetail", pmd->Type_Detail);


		//PMEMDEVICEMAPADDR pmdma = (PMEMDEVICEMAPADDR) smbios.GetFirstStruct(20);
    	PMEMDEVICEMAPADDR pmdma;
	    PSTLIST pstl = smbios.GetStructList(20);

		while (pstl)
		{
            pmdma = (PMEMDEVICEMAPADDR) pstl->pshf;

            if (pmdma->Memory_Device_Handle == pmd->Handle)
			{
			    if (pmdma->Partition_Row > 0 && pmdma->Partition_Row < 0xff)
				{
					pInst->SetDWORD(L"PositionInRow", pmdma->Partition_Row);
				}
				if (pmdma->Interleave_Position < 0xff)
				{
					pInst->SetDWORD(L"InterleavePosition", pmdma->Interleave_Position);
				}
				if (pmdma->Interleaved_Data_Depth < 0xff)
				{
					pInst->SetDWORD(L"InterleaveDataDepth", pmdma->Interleaved_Data_Depth);
				}
				break;
			}
			else
			{
    			pstl = pstl->next;
			}
		}
	}

	// V2.3 properties
	if (smbios.GetVersion() > 0x00020002 && pmd->Length > ((PBYTE) &pmd->Speed - (PBYTE) pmd))
	{
		if (pmd->Speed)
            pInst->SetDWORD(L"Speed", pmd->Speed);
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CWin32PhysicalMemory::LoadPropertyValues_MI(CInstance *pInst, CSMBios &smbios, PMEMMODULEINFO pmmi)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString	sTemp;
	UINT		Form_Factor;
	UINT		Memory_Type;
	__int64     memsize;

	switch (pmmi->Installed_Size & 0x7f)
	{
		case 0x7d:
		case 0x7f:
			memsize = 0;
    		break;

		default:
			memsize = (1 << pmmi->Installed_Size) * 1024;
    		break;
	}

	// This is not a valid memory if the size is 0 (means the bank is empty).
    if (!memsize)
        return WBEM_E_NOT_FOUND;

	// one K multiplier
	memsize <<= 10;
	swprintf(tempstr, L"%I64d", memsize);
	pInst->SetWBEMINT64(L"Capacity", tempstr);

    if (pmmi->Current_Speed)
        pInst->SetDWORD(L"Speed", pmmi->Current_Speed);

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PHYSICALMEMORY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PhysicalMemory);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	// this goes into an association later
	smbios.GetStringAtOffset((PSHF) pmmi, tempstr, pmmi->Socket_Designation);
	pInst->SetCharSplat(L"DeviceLocator", tempstr);

	BYTE bank0 = pmmi->Bank_Connections & 0x0f;
	BYTE bank1 = pmmi->Bank_Connections >> 4;

	if (bank0 != 0xf && bank1 != 0xf)
	{
		swprintf(tempstr, L"RAS %d & %d" , bank0, bank1);
	}
	else if (bank0 != 0xf)
	{
		swprintf(tempstr, L"RAS %d" , bank0);
	}
	else if (bank1 != 0xf)
	{
		swprintf(tempstr, L"RAS %d" , bank1);
	}
	else
	{
		*tempstr = '\0';
	}

	pInst->SetCharSplat(L"BankLabel", tempstr);


	if (pmmi->Current_Memory_Type & 0x00800) // SIMM
	{
		Form_Factor = 3;
	}
	else if (pmmi->Current_Memory_Type & 0x0100) // DIMM
	{
		Form_Factor = 9;
	}
	else if (pmmi->Current_Memory_Type & 0x0002 || pmmi->Current_Memory_Type & 0x0001)
	{
		Form_Factor = pmmi->Current_Memory_Type & 0x0003;
	}
	// this needs a CIM mapper -- FormFactor
	pInst->SetDWORD(L"FormFactor", GetCimVal(FormFactor, Form_Factor));

	if (pmmi->Current_Memory_Type & 0x0004) // DRAM
	{
		Memory_Type = 3;
	}
	else if (pmmi->Current_Memory_Type & 0x0400) // SDRAM
	{
		Memory_Type = 15;
	}
	else if (pmmi->Current_Memory_Type & 0x0002 || pmmi->Current_Memory_Type & 0x0001)
	{
		Memory_Type = pmmi->Current_Memory_Type & 0x0003;
	}
	// this needs a CIM mapper -- MemoryType
	pInst->SetDWORD(L"MemoryType", GetCimVal(MemoryType, Memory_Type));

	DWORD dwTypeDetail = 0;

	if (pmmi->Current_Memory_Type & 0x0010) // EDO
	    dwTypeDetail |= 0x0200;

	if (pmmi->Current_Memory_Type & 0x0008) // Fast Paged
	    dwTypeDetail |= 8;

	// Set to unknown if we didn't find anything useful to put in it.
    if (!dwTypeDetail)
        dwTypeDetail = 4; // 4 == unknown

    pInst->SetDWORD(L"TypeDetail", dwTypeDetail);

	return WBEM_S_NO_ERROR;
}

#endif // SMB_PHYSICALMEMORY


//==============================================================================
#ifdef SMB_PHYSMEMARRAY
//
CWin32PhysMemoryArray	MyPhysMemArray(PROPSET_NAME_PHYSMEMARRAY, IDS_CimWin32Namespace);

//
CWin32PhysMemoryArray::CWin32PhysMemoryArray(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32PhysMemoryArray::~CWin32PhysMemoryArray()
{
}

//
HRESULT CWin32PhysMemoryArray::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, NULL, L"Physical Memory Array", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PSHF pshf = smbios.GetNthStruct(16, instanceNum);

			if (pshf)
			{
				hResult = LoadPropertyValues_PMA(pInst, smbios, (PPHYSMEMARRAY) pshf);
			}
			else
			{
		        pshf = smbios.GetNthStruct(5, instanceNum);

				if (pshf)
				{
					hResult = LoadPropertyValues_MCI(pInst, smbios, (PMEMCONTROLINFO) pshf);
				}
			}

			// If we were able to get the BIOS properties but the new __RELPATH doesn't
		    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
		    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
		        strPathAfter.CompareNoCase(strPathBefore) != 0))
			{
		        hResult = WBEM_E_NOT_FOUND;
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}


HRESULT CWin32PhysMemoryArray::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;
	BOOL		altstruct = FALSE;

    if (smbios.Init())
    {
        int 		i;
		CHString	sTemp(L"Physical Memory Array XXX");
        PSTLIST		pstl = smbios.GetStructList(16);

		if (!pstl)
		{
	        pstl = smbios.GetStructList(5);
			altstruct = TRUE;
		}

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"Physical Memory Array %d", i);
			pInst->SetCharSplat(L"Tag", sTemp);

			if (altstruct)
			{
				hResult = LoadPropertyValues_MCI(pInst, smbios, (PMEMCONTROLINFO) pstl->pshf);
			}
			else
			{
				hResult = LoadPropertyValues_PMA(pInst, smbios, (PPHYSMEMARRAY) pstl->pshf);
			}

			if (hResult == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}


HRESULT CWin32PhysMemoryArray::LoadPropertyValues_PMA(CInstance *pInst, CSMBios &smbios, PPHYSMEMARRAY ppma)
{
	CHString sTemp;

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PHYSMEMARRAY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PhysicalMemoryArray);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	if (smbios.GetVersion() > 0x00020000 && ppma->Length >= sizeof(PHYSMEMARRAY))
	{
		pInst->SetWORD(L"Location", (WORD)ppma->Location);
	    pInst->SetWORD(L"Use", (WORD)ppma->Use);
	    pInst->SetWORD(L"MemoryErrorCorrection", (WORD)ppma->Mem_Error_Correction);
	    pInst->SetDWORD(L"MaxCapacity", ppma->Max_Capacity == 0x80000000 ? 0 : ppma->Max_Capacity);
	    //pInst->SetWBEMINT16(L"MemErrorInfoHandle", ppma->Mem_Error_Info_Handle);
	    pInst->SetDWORD(L"MemoryDevices", ppma->Memory_Devices);
	}

    return WBEM_S_NO_ERROR;
}


HRESULT CWin32PhysMemoryArray::LoadPropertyValues_MCI(CInstance *pInst, CSMBios &smbios, PMEMCONTROLINFO pmci)
{
	CHString sTemp;

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PHYSMEMARRAY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PhysicalMemoryArray);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	// map the error correction capability to that of Physical memory array's values
	BYTE mask = 0x20;
	BYTE ecc = 0;

	while (mask && ecc == 0)
	{
		switch (mask & pmci->Error_Correcting_Capability & 0x20)
		{
			case 0x20:	ecc = 7;	break;
			case 0x10:	ecc = 6;	break;
			case 0x08:	ecc = 5;	break;
			case 0x04:	ecc = 3;	break;
			case 0x02:	ecc = 2;	break;
			case 0x01:	ecc = 1;	break;
		}
		mask >>= 1;
	}
    pInst->SetWORD(L"MemoryErrorCorrection", (WORD) (ecc > 0 ? ecc : 1));

	// size (in K bytes) is module size * # of slots * 1K
	DWORD size = (1 << pmci->Maximum_Memory_Module_Size) * pmci->Associated_Memory_Slots * 1024;
    pInst->SetDWORD(L"MaxCapacity", size);
	pInst->SetDWORD(L"MemoryDevices", pmci->Associated_Memory_Slots);

    return WBEM_S_NO_ERROR;
}
#endif // SMB_PHYSMEMARRAY


//==============================================================================
// Portable Battery
// TODO: Until the Win32_Battery supports more than one internal battery, there's
// no use in this class producing more than one instance (since Win32_PortableBattery
// inherits from Win32_Battery).
//------------------------------------------------------------------------------
#ifdef SMB_PORTABLEBATTERY
CWin32PortableBattery	MyPortableBatterySet(PROPSET_NAME_PORTABLEBATTERY, IDS_CimWin32Namespace);

//
CWin32PortableBattery::CWin32PortableBattery(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32PortableBattery::~CWin32PortableBattery()
{
}

//
HRESULT CWin32PortableBattery::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    HRESULT  hResult = WBEM_E_NOT_FOUND;
	UINT instanceNum = 0;

	if (ValidateTagProperty(pInst, L"DeviceID", L"Portable Battery", &instanceNum))
	{
	    CSMBios smbios;

	    if (smbios.Init())
	    {
	        PPORTABLEBATTERY ppb = (PPORTABLEBATTERY) smbios.GetNthStruct(22, instanceNum);

			if (ppb)
			{
				hResult = LoadPropertyValues(pInst, smbios, ppb);
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}

	return hResult;
}

HRESULT CWin32PortableBattery::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

    if (smbios.Init())
    {
        int i = 0;
		CHString sTemp (L"Portable Battery XXX");
        PSTLIST	pstl = smbios.GetStructList(22);
    	CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));
			sTemp.Format(L"Portable Battery %d", i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios, (PPORTABLEBATTERY) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}

			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}


HRESULT CWin32PortableBattery::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PPORTABLEBATTERY ppb)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	DWORD		dwValue;

    pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
    pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());
	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PORTABLEBATTERY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PortableBattery);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	if (smbios.GetVersion() > 0x00020000)
	{
		WBEMTime wbemdate;

		smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->Location);
    	pInst->SetCharSplat(L"Location", tempstr);

		smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->Manufacturer);
    	pInst->SetCharSplat(L"Manufacturer", tempstr);

		if (smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->Manufacture_Date))
		{
			FormatWBEMDate(wbemdate, tempstr);
	    	pInst->SetDateTime(L"ManufactureDate", wbemdate);
		}

		//smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->Serial_Number);
    	//pInst->SetCharSplat(L"SerialNumber", tempstr);

		smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->Device_Name);
    	pInst->SetCharSplat(L"Name", tempstr);

	    pInst->SetDWORD(L"Chemistry", ppb->Device_Chemistry);

		// note special case when v2.2+, use multiplier
		dwValue = (smbios.GetVersion() > 0x00020001) ?
			(ppb->Design_Capacity * ppb->Design_Capacity_Mult) : ppb->Design_Capacity;
	    pInst->SetDWORD(L"DesignCapacity", dwValue);

	    pInst->SetDWORD(L"DesignVoltage", ppb->Design_Voltage);

		smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->SBDS_Version);
    	pInst->SetCharSplat(L"SmartBatteryVersion", tempstr);

		dwValue = ppb->Max_Error == 0xff ? 0 : ppb->Max_Error;
	    pInst->SetDWORD(L"MaxBatteryError", dwValue);
	}

	if (smbios.GetVersion() > 0x00020001)
	{
		if (ppb->Manufacture_Date != 0)
        {
            struct tm   tm;
            WORD        wDate = ppb->SBDS_Manufacture_Date;

            // Fill out the fields of the time struct so we can pass it on to
            // WBEMTime.

            // Init everything to 0.
            memset(&tm, 0, sizeof(tm));

            // The SMIBOS year is biased by 1980, but the tm version is biased
            // by 1900.  So, add 80 years to make it right.
            tm.tm_year = (wDate >> 9) + 80;

            // SMBIOS month is 1 based, tm is 0 based, so subtract 1.
            tm.tm_mon = ((wDate >> 5) & 0xF) - 1;

            // SMBIOS day and tm are both 1 based.
            tm.tm_mday = wDate & 0x1F;

            WBEMTime wbemTime(tm);

            pInst->SetDateTime(L"ManufactureDate", wbemTime);
        }

        pInst->SetDWORD(L"CapacityMultiplier", ppb->Design_Capacity_Mult);
	}

    return WBEM_S_NO_ERROR;
}

#endif // SMB_PORTABLEBATTERY



//==============================================================================
// Probes class
//------------------------------------------------------------------------------
#ifdef SMB_PROBES

//
CCimNumericSensor		MyCurrentProbeSet(PROPSET_NAME_CURRENTPROBE, IDS_CimWin32Namespace,
							29, L"Electrical Current Probe");
//
CCimNumericSensor		MyTemperatureProbeSet(PROPSET_NAME_TEMPPROBE, IDS_CimWin32Namespace,
							28, L"Temperature Probe");
//
CCimNumericSensor		MyVoltageProbeSet(PROPSET_NAME_VOLTPROBE, IDS_CimWin32Namespace,
							26, L"Voltage Probe");
//
CCimNumericSensor::CCimNumericSensor(
									 LPCWSTR strName,
									 LPCWSTR pszNamespace,
									 UINT StructType,
									 LPCWSTR strTag)
:	Provider(strName, pszNamespace)
{
	m_StructType = StructType;
	m_TagName = pszNamespace;
}

//
CCimNumericSensor::~CCimNumericSensor()
{
}

//
HRESULT CCimNumericSensor::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
	HRESULT     hResult = WBEM_E_NOT_FOUND;
	CHString    strPathBefore,
                strPathAfter;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"DeviceID", m_TagName, &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PPROBEINFO ppi = (PPROBEINFO) smbios.GetNthStruct((BYTE)m_StructType, instanceNum);

			if (ppi)
			{
				hResult = LoadPropertyValues(pInst, smbios, ppi);

			    // If we were able to get the BIOS properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}

	return hResult;
}

HRESULT CCimNumericSensor::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        PSTLIST			pstl = smbios.GetStructList((BYTE)m_StructType);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"%s %d", m_TagName, i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios, (PPROBEINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CCimNumericSensor::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PPROBEINFO ppi)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString	sTemp;

	pInst->GetCHString(L"DeviceID", sTemp);

    pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
    pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());
	SetCreationClassName(pInst);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_NumericSensor);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	smbios.GetStringAtOffset((PSHF) ppi, tempstr, ppi->Description);
    pInst->SetCharSplat(L"Description", tempstr);

	switch (ppi->Location_Status & 0xe0)
	{
		case 0x60:
		    pInst->SetCharSplat(L"Status", L"OK");
			break;
		case 0x80:
		    pInst->SetCharSplat(L"Status", L"Degraded");
			break;
		case 0xa0:
		case 0xc0:
		    pInst->SetCharSplat(L"Status", L"Error");
			break;
		case 0x20:
		case 0x40:
		default:
		    pInst->SetCharSplat(L"Status", L"Unknown");
			break;
	}

	pInst->SetDWORD(L"MaxReadable", ppi->MaxValue);
	pInst->SetDWORD(L"MinReadable", ppi->MinValue);
	pInst->SetDWORD(L"Resolution", ppi->Resolution);
	pInst->SetDWORD(L"Tolerance", ppi->Tolerance);
	pInst->SetDWORD(L"Accuracy", ppi->Accuracy);

    return WBEM_S_NO_ERROR;
}
#endif // SMB_PROBES
//==============================================================================



//==============================================================================
// Memory Array class
//------------------------------------------------------------------------------
#ifdef SMB_MEMORYARRAY

CWin32MemoryArray	MyMemoryArraySet(PROPSET_NAME_MEMORYARRAY, IDS_CimWin32Namespace);

//
CWin32MemoryArray::CWin32MemoryArray(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32MemoryArray::~CWin32MemoryArray()
{
}

//
HRESULT CWin32MemoryArray::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"DeviceID", L"Memory Array", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PMEMARRAYMAPADDR pmama = (PMEMARRAYMAPADDR) smbios.GetNthStruct(19, instanceNum);

			if (pmama)
			{
				hResult = LoadPropertyValues(pInst, smbios, pmama);

			    // If we were able to get the BIOS properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}

HRESULT CWin32MemoryArray::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        //PMEMARRAYMAPADDR pmama = (PMEMARRAYMAPADDR) smbios.GetFirstStruct(19);
        PSTLIST			pstl = smbios.GetStructList(19);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"Memory Array %d", i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios, (PMEMARRAYMAPADDR) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32MemoryArray::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PMEMARRAYMAPADDR pmama)
{
	WCHAR			tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString		sTemp;
	__int64			memaddr;
	PPHYSMEMARRAY	pma;
	PMEMERRORINFO32 pmei;

	pInst->GetCHString(L"DeviceID", sTemp);

    pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
    pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());
	SetCreationClassName(pInst);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_MemoryArray);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	memaddr = pmama->Starting_Address;
	swprintf(tempstr, L"%I64d", memaddr);
	pInst->SetWBEMINT64(IDS_StartingAddress, tempstr);

	memaddr = pmama->Ending_Address;
	swprintf(tempstr, L"%I64d", memaddr);
	pInst->SetWBEMINT64(IDS_EndingAddress, tempstr);

	// Go pickup any error info for this array
	pma = (PPHYSMEMARRAY) smbios.SeekViaHandle(pmama->Memory_Array_Handle);
	if (pma)
	{
		pmei = (PMEMERRORINFO32) smbios.SeekViaHandle(pma->Mem_Error_Info_Handle);

		if (pmei)
		{
			pInst->SetDWORD(L"ErrorInfo", pmei->Error_Type);
			if (pmei->Error_Type != 3)
			{
				pInst->SetDWORD(L"ErrorAccess", pmei->Error_Operation);

				memaddr = pmei->Mem_Array_Error_Addr;
				swprintf(tempstr, L"%I64d", memaddr);
				pInst->SetWBEMINT64(L"ErrorAddress", tempstr);

				memaddr = pmei->Error_Resolution;
				swprintf(tempstr, L"%I64d", memaddr);
				pInst->SetWBEMINT64(L"ErrorResolution", tempstr);

				pInst->Setbool(L"CorrectableError", pmei->Error_Type != 0x0e ? true : false);
				pInst->SetDWORD(L"ErrorGranularity", pmei->Error_Granularity);
			}
		}
	}

    return WBEM_S_NO_ERROR;
}
#endif // SMB_MEMORYARRAY
//==============================================================================



//==============================================================================
// Memory Device class
//------------------------------------------------------------------------------
#ifdef SMB_MEMORYDEVICE
CWin32MemoryDevice	MyMemoryDeviceSet(PROPSET_NAME_MEMORYDEVICE, IDS_CimWin32Namespace);

//
CWin32MemoryDevice::CWin32MemoryDevice(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32MemoryDevice::~CWin32MemoryDevice()
{
}

//
HRESULT CWin32MemoryDevice::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"DeviceID", L"Memory Device", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PMEMDEVICEMAPADDR pmdma = (PMEMDEVICEMAPADDR) smbios.GetNthStruct(20, instanceNum);

			if (pmdma)
			{
				hResult = LoadPropertyValues(pInst, smbios, pmdma);

			    // If we were able to get the BIOS properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}

	return hResult;
}

HRESULT CWin32MemoryDevice::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        //PMEMDEVICEMAPADDR pmdma = (PMEMDEVICEMAPADDR) smbios.GetFirstStruct(20);
        PSTLIST			pstl = smbios.GetStructList(20);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"Memory Device %d", i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios, (PMEMDEVICEMAPADDR) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32MemoryDevice::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PMEMDEVICEMAPADDR pmdma)
{
	WCHAR			tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString		sTemp;
	__int64			memaddr;
	PMEMDEVICE		pmd;
	PMEMERRORINFO32 pmei;

	pInst->GetCHString(L"DeviceID", sTemp);

    pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
    pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());
	SetCreationClassName(pInst);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_MemoryDevice);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	memaddr = pmdma->Starting_Address;
	swprintf(tempstr, L"%I64d", memaddr);
	pInst->SetWBEMINT64(IDS_StartingAddress, tempstr);

	memaddr = pmdma->Ending_Address;
	swprintf(tempstr, L"%I64d", memaddr);
	pInst->SetWBEMINT64(IDS_EndingAddress, tempstr);

	// Go pickup any error info for this device
	pmd = (PMEMDEVICE) smbios.SeekViaHandle(pmdma->Memory_Device_Handle);
	if (pmd)
	{
		pmei = (PMEMERRORINFO32) smbios.SeekViaHandle(pmd->Mem_Error_Info_Handle);

		if (pmei)
		{
			pInst->SetDWORD(L"ErrorInfo", pmei->Error_Type);
			if (pmei->Error_Type != 3)
			{
				pInst->SetDWORD(L"ErrorAccess", pmei->Error_Operation);

				memaddr = pmei->Device_Error_Addr;
				swprintf(tempstr, L"%I64d", memaddr);
				pInst->SetWBEMINT64(L"ErrorAddress", tempstr);

				memaddr = pmei->Error_Resolution;
				swprintf(tempstr, L"%I64d", memaddr);
				pInst->SetWBEMINT64(L"ErrorResolution", tempstr);

				pInst->Setbool(L"CorrectableError", pmei->Error_Type != 0x0e ? true : false);
				pInst->SetDWORD(L"ErrorGranularity", pmei->Error_Granularity);
			}
		}
	}

    return WBEM_S_NO_ERROR;
}
#endif // SMB_MEMORYDEVICE
//==============================================================================

//==============================================================================
// Probes class
//------------------------------------------------------------------------------
#ifdef SMB_COOLINGDEVICE

//
CCimCoolingDevice		MyFanSet(PROPSET_NAME_FAN, IDS_CimWin32Namespace,
							27, L"Fan");
//
CCimCoolingDevice		MyHeatPipeSet(PROPSET_NAME_HEATPIPE, IDS_CimWin32Namespace,
							27, L"Heat Pipe");
//
CCimCoolingDevice		MyRefrigeration(PROPSET_NAME_REFRIG, IDS_CimWin32Namespace,
							27, L"Refrigeration");
//
CCimCoolingDevice::CCimCoolingDevice(
									 LPCWSTR strName,
									 LPCWSTR pszNamespace,
									 UINT StructType,
									 LPCWSTR strTag)
:	Provider(strName, pszNamespace)
{
	m_StructType = StructType;
	m_TagName = pszNamespace;
}

//
CCimCoolingDevice::~CCimCoolingDevice()
{
}

//
HRESULT CCimCoolingDevice::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"DeviceID", m_TagName, &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PCOOLINGDEVICE pcd = (PCOOLINGDEVICE) smbios.GetNthStruct((BYTE)m_StructType, instanceNum);

			if (pcd)
			{
				hResult = LoadPropertyValues(pInst, smbios, pcd);

			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}

	return hResult;
}

HRESULT CCimCoolingDevice::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        PSTLIST			pstl = smbios.GetStructList((BYTE)m_StructType);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"%s %d", m_TagName, i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios, (PCOOLINGDEVICE) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

//
HRESULT CCimCoolingDevice::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PCOOLINGDEVICE pcd)
{
	HRESULT		hResult;
	CHString	sTemp,
				sClass;
    BOOL        bActive;

	// validate device type
    switch(pcd->Type_Status & 0x1F)
	{
		// fan types
        case 3: // Fan
        case 4: // Centrifugal blower
        case 5: // Chip fan
        case 6: // Cabinet fan
        case 7: // Power supply fan
			sTemp = PROPSET_NAME_FAN;
            bActive = TRUE;
			break;

		// heat pipe
		case 8:
			sTemp = PROPSET_NAME_HEATPIPE;
            bActive = FALSE;
			break;

		// refrigeration
		case 9:
			sTemp = PROPSET_NAME_REFRIG;
            bActive = TRUE;
			break;

        case 20: // Active cooling
        case 21: // Passive cooling
		default:
			// We don't know what kind of device this is, so get out.
            return WBEM_E_NOT_FOUND;
	}

	pInst->GetCHString(L"__CLASS", sClass);

    if (sTemp.CompareNoCase(sClass) == 0)
	{
		// Get the status and availability.
        CHString    strStatus;
        int         iAvailabilty;

        switch(pcd->Type_Status >> 5)
        {
            case 4: // Non-critical
            case 1: // Other
            default:
                strStatus = L"Other";
                iAvailabilty = 1;
                break;

            case 2: // Unknown
                strStatus = L"Unknown";
                iAvailabilty = 2;
                break;

            case 3: // OK
                strStatus = L"OK";
                iAvailabilty = 3;
                break;

            case 5: // Critical
            case 6: // Non-recoverable
                strStatus = L"Error";
                iAvailabilty = 1;
                break;
        }

        pInst->SetCharSplat(L"Status", strStatus);
        pInst->SetDWORD(L"Availability", iAvailabilty);

  	    // We'll assume it's always enabled if SMBIOS is reporting it.
        pInst->SetDWORD(L"StatusInfo", 2);

        SetCreationClassName(pInst);
	    pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
  	    pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());

        CHString sTemp2;
        LoadStringW(sTemp2, IDR_CoolingDevice);

		pInst->SetCHString(IDS_Name, sTemp2);
		pInst->SetCHString(IDS_Caption, sTemp2);
		pInst->SetCHString(IDS_Description, sTemp2);
        pInst->Setbool(L"ActiveCooling", bActive);

		hResult = WBEM_S_NO_ERROR;
	}
	else
	{
		hResult = WBEM_E_NOT_FOUND;
	}

    return hResult;
}

#endif // SMB_COOLINGDEVICE
//==============================================================================


//==============================================================================
// OEM Bucket class
//------------------------------------------------------------------------------
#ifdef SMB_OEMBUCKET
//CWin32OEMBucket	MyOEMBucket(PROPSET_NAME_OEMBUCKET, IDS_CimWin32Namespace);
CWin32OEMBucket	MyOEMBucket(PROPSET_NAME_OEMBUCKET, L"root\\VendorSpecific");

//
CWin32OEMBucket::CWin32OEMBucket(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32OEMBucket::~CWin32OEMBucket()
{
}

//
HRESULT CWin32OEMBucket::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult;
    CSMBios		smbios;

    // Get the previous __RELPATH
    GetLocalInstancePath(pInst, strPathBefore);

    if (smbios.Init())
    {
		hResult = LoadPropertyValues(pInst, smbios);
	}

    // If we were able to get the properties but the new __RELPATH doesn't
    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
        strPathAfter.CompareNoCase(strPathBefore) != 0))
	{
        hResult = WBEM_E_NOT_FOUND;
	}

	return hResult;
}

HRESULT CWin32OEMBucket::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

	if (smbios.Init())
    {
		CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

		pInst->SetCharSplat(L"InstanceName", L"OEM Bucket");
		if ((hResult = LoadPropertyValues(pInst, smbios)) == WBEM_S_NO_ERROR)
		{
			hResult = pInst->Commit();
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;

}

HRESULT CWin32OEMBucket::LoadPropertyValues(CInstance *pInst, CSMBios &smbios)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	PSTLIST		pstl;

    pstl = smbios.GetStructList(0);

	if (pstl)
	{
		PBIOSINFO pbi = (PBIOSINFO) pstl->pshf;

		pInst->SetDWORD(L"Type0_BIOSVendorBits", *(WORD *) &pbi->BIOS_Characteristics[ 4 ]);
		pInst->SetDWORD(L"Type0_SystemVendorBits", *(WORD *) &pbi->BIOS_Characteristics[ 6 ]);
	}

   	pstl = smbios.GetStructList(3);

	if (pstl)
	{
    	PENCLOSURE pe = (PENCLOSURE) pstl->pshf;

		if (pe->Length > (PBYTE) &pe->OEM_Defined - (PBYTE) pe)
		{
			pInst->SetDWORD(L"Type3_OEMDefined", pe->OEM_Defined);
		}
	}

   	pstl = smbios.GetStructList(11);

	if (pstl)
	{
		SAFEARRAYBOUND	sab;
		POEMSTRINGS     poem = (POEMSTRINGS) pstl->pshf;
        variant_t       vStrings;

		sab.lLbound = 0;
		sab.cElements = poem->Count;
		if (V_ARRAY(&vStrings) = SafeArrayCreate(VT_BSTR, 1, &sab))
		{
			for (int i = 0; i < poem->Count; i++)
			{
				_bstr_t bstr;

				smbios.GetStringAtOffset((PSHF) poem, tempstr, i + 1);
				bstr = tempstr;
				SafeArrayPutElement(V_ARRAY(&vStrings), (long *) &i, (LPVOID) (BSTR) bstr);
			}

            pInst->SetStringArray(L"Type11_OEMStrings", *V_ARRAY(&vStrings));
		}
    }

	// this really stinks but I have to count how many structures there are
	// allocating the array
	SAFEARRAYBOUND	sab;
    int				count;
    DWORD			dval;

    sab.lLbound = 0;
    sab.cElements = smbios.GetStructCount(22);

    if (sab.cElements > 0)
    {
	    variant_t vVals;

        pstl = smbios.GetStructList(22);

	    if (V_ARRAY(&vVals) = SafeArrayCreate(VT_I4, 1, &sab))
	    {
		    PPORTABLEBATTERY ppb;

			V_VT(&vVals) = VT_ARRAY | VT_I4;

			for (count = 0; pstl && count < sab.cElements; count++)
			{
			    ppb = (PPORTABLEBATTERY) pstl->pshf;
				dval = ppb->Length > ((PBYTE) &ppb->OEM_Specific - (PBYTE) ppb) ? ppb->OEM_Specific : 0;
				SafeArrayPutElement(V_ARRAY(&vVals), (long *) &count, &dval);
				pstl = pstl->next;
			}

			pInst->SetVariant(L"Type22_OEMSpecific", vVals);
		}
	}


    sab.cElements = smbios.GetStructCount(26);
    if (sab.cElements > 0)
    {
	    variant_t vVals;

	    pstl = smbios.GetStructList(26);
	    if (V_ARRAY(&vVals) = SafeArrayCreate(VT_I4, 1, &sab))
	    {
		    PPROBEINFO ppi;

		    V_VT(&vVals) = VT_ARRAY | VT_I4;

		    for (count = 0; pstl && count < sab.cElements; count++)
		    {
			    ppi = (PPROBEINFO) pstl->pshf;
			    dval = ppi->Length > ((PBYTE) &ppi->OEM_Defined - (PBYTE) ppi) ? ppi->OEM_Defined : 0;
			    SafeArrayPutElement(V_ARRAY(&vVals), (long *) &count, &dval);
			    pstl = pstl->next;
		    }

		    pInst->SetVariant(L"Type26_OEMDefined", vVals);
	    }
    }

    sab.cElements = smbios.GetStructCount(28);
    if (sab.cElements > 0)
    {
	    variant_t vVals;

	    pstl = smbios.GetStructList(28);
	    if (V_ARRAY(&vVals) = SafeArrayCreate(VT_I4, 1, &sab))
	    {
		    PPROBEINFO ppi;

		    