phore here because we don't need it.  This call
    //  is either made when we're already holding the semaphore, or is made
    //  when we don't care about the absolute accuracy of the results.
    //However, we do need a shared heap to access _pgfst
    CSafeMultiHeap smh(_ppc);
#ifdef LARGE_DOCFILE
    // This method, used by IProgressNotify, cannot handle large integers
    // If the high water mark is too big to fit, return an error
    ULONGLONG ulWaterMark = _pgfst->GetHighWaterMark();
    if (ulWaterMark < MAX_ULONG)
    {
        *pulWaterMark = (ULONG) ulWaterMark;
        *pulFailurePoint = (ULONG) _pgfst->GetFailurePoint();
        return S_OK;
    }
    else return STG_E_INVALIDFUNCTION;  // file is too big
#else
    *pulWaterMark = _pgfst->GetHighWaterMark();
    *pulFailurePoint = _pgfst->GetFailurePoint();
    return S_OK;
#endif
}

STDMETHODIMP CFileStream::GetTerminationStatus(DWORD *pdwFlags)
{
    SAFE_SEM;
    TakeSafeSem();
    *pdwFlags = _pgfst->GetTerminationStatus();
    return S_OK;
}

#endif //ASYNC

//+---------------------------------------------------------------------------
//
//  Function:   GetNtHandleSectorSize
//
//  Synopsis:   Find a volume's physical sector size
//
//  Arguments:  [Handle] -- file handle
//              [pulSectorSize] -- number of bytes per physical sector
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

HRESULT GetNtHandleSectorSize (HANDLE Handle, ULONG * pulSectorSize)
{
    FILE_FS_SIZE_INFORMATION SizeInfo;
    IO_STATUS_BLOCK iosb;

    NTSTATUS nts = NtQueryVolumeInformationFile( Handle, &iosb,
                &SizeInfo, sizeof(SizeInfo), FileFsSizeInformation );

    if (NT_SUCCESS(nts))
    {
        *pulSectorSize = SizeInfo.BytesPerSector;
        return S_OK;
    }

    return NtStatusToScode(nts);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\marshl.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       marshl.cxx
//
//  Contents:   Marshal/Unmarshal implementation
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <expdf.hxx>
#include <expst.hxx>
#include <pbstream.hxx>
#include <marshl.hxx>
#include <logfile.hxx>

// Standard marshal data is an IID plus a DWORD
#define CBSTDMARSHALSIZE (sizeof(IID)+sizeof(DWORD))

SCODE VerifyIid(REFIID iid, REFIID iidObj)
{
    if ((IsEqualIID(iid, IID_IUnknown) || (IsEqualIID(iid, iidObj))))
    {
        return S_OK;
    }
        
    if (IsEqualIID(iidObj, IID_ILockBytes))
    {
        if (IsEqualIID(iid, IID_IFillLockBytes))
        {
            return S_OK;
        }
    }

    if (IsEqualIID(iidObj, IID_IStorage))
    {
        if (   IsEqualIID(iid, IID_IPropertySetStorage)
            || IsEqualIID(iid, IID_IPropertyBagEx) )
        {
            return S_OK;
        }
    }

    return STG_E_INVALIDPARAMETER;
}

//+--------------------------------------------------------------
//
//  Function:   DfUnMarshalInterface, public
//
//  Synopsis:   Unmarshals marshaled data
//
//  Arguments:  [pstStm] - Stream to read data from
//              [iid] - Interface to unmarshal
//              [fFirst] - First time unmarshalling
//              [ppvObj] - Interface return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI DfUnMarshalInterface(IStream *pstStm,
                            REFIID iid,
                            BOOL fFirst,
                            void **ppvObj)
{
    SCODE sc;
    ULONG cbRead;
    IID iidSt;
    DWORD mshlflags;
    SafeIUnknown punk;

    olLog(("--------::In  DfUnMarshalInterface(%p, iid, %d, %p).  "
        "Context == %lX\n", pstStm, fFirst, ppvObj,
        (ULONG)GetCurrentContextId()));
    olDebugOut((DEB_TRACE, "In  DfUnMarshalInterface("
                "%p, ?, %d, %p)\n", pstStm, fFirst, ppvObj));

    olChk(ValidateOutPtrBuffer(ppvObj));
    *ppvObj = NULL;
    olChk(ValidateInterface(pstStm, IID_IStream));
    olChk(ValidateIid(iid));
    if (!fFirst)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);
    
    olHChk(pstStm->Read(&iidSt, sizeof(iidSt), &cbRead));
    if (cbRead != sizeof(iidSt))
        olErr(EH_Err, STG_E_READFAULT);
    olHChk(pstStm->Read(&mshlflags, sizeof(mshlflags), &cbRead));
    if (cbRead != sizeof(mshlflags))
        olErr(EH_Err, STG_E_READFAULT);
    olChk(VerifyIid(iid, iidSt));

#if !defined(MULTIHEAP)
    olChk(DfSyncSharedMemory());
    DfInitSharedMemBase();
#endif
    if (IsEqualIID(iidSt, IID_ILockBytes))
        sc = CFileStream::Unmarshal(pstStm, (void **)&punk, mshlflags);
    else if (IsEqualIID(iidSt, IID_IStream))
        sc = CExposedStream::Unmarshal(pstStm, (void **)&punk, mshlflags);
    else if (IsEqualIID(iidSt, IID_IStorage))
        sc = CExposedDocFile::Unmarshal(pstStm, (void **)&punk, mshlflags);
    else
        sc = E_NOINTERFACE;

    if (SUCCEEDED(sc))
    {
        if (!IsEqualIID(iid, iidSt))
        {
            sc = punk->QueryInterface(iid, ppvObj);
        }
        else
        {
            TRANSFER_INTERFACE(punk, IUnknown, ppvObj);
#if DBG == 1
        void *pvCheck;
        HRESULT scCheck = ((IUnknown*)*ppvObj)->QueryInterface(iidSt, &pvCheck);
        olAssert (scCheck == S_OK || scCheck == STG_E_REVERTED);
        if (SUCCEEDED(scCheck))
        {
            olAssert( pvCheck == *ppvObj );
            ((IUnknown*)pvCheck)->Release();
        }
#endif
        }
    }

    olDebugOut((DEB_TRACE, "Out DfUnMarshalInterface => %p\n",
                *ppvObj));
EH_Err:
    olLog(("--------::Out DfUnMarshalInterface().  "
        "*ppvObj == %p, ret == %lX\n", *ppvObj, sc));
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Function:	GetCoMarshalSize, private
//
//  Synopsis:	Gets the marshal size for an interface marshalled using
//              CoMarshalInterface
//
//  Arguments:	[riid] - Interface id
//              [punk] - Interface pointer
//              [pv] - Context info
//              [dwDestContext] - Destination context
//              [pvDestContext] - Destination context
//              [mshlflags] - Marshal flags
//              [pcb] - Size return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[pcb]
//
//  Algorithm:  CoMarshalInterface is guaranteed to add no more than
//              MARSHALINTERFACE_MIN bytes of overhead to a marshal
//              Also, the standard marshaller takes no more than that
//              So if the given object supports IMarshal, the return
//              is IMarshal::GetMarshalSizeMax+MARSHALINTERFACE_MIN,
//              otherwise it is just MARSHALINTERFACE_MIN
//
//  History:	03-Aug-93	DrewB	Created
//
//  Notes:	On 32-bit platforms, we can use CoGetMarshalSizeMax
//
//----------------------------------------------------------------------------

#ifndef WIN32
static SCODE GetCoMarshalSize(REFIID riid,
                              IUnknown *punk,
                              void *pv,
                              DWORD dwDestContext,
                              void *pvDestContext,
                              DWORD mshlflags,
                              DWORD *pcb)
{
    IMarshal *pmsh;
    SCODE sc;
    DWORD cb;
    
    olDebugOut((DEB_ITRACE, "In  GetCoMarshalSize("
                "riid, %p, %p, %lu, %p, %lu, %p)\n", pv, punk, dwDestContext,
                pvDestContext, mshlflags, pcb));

    sc = DfGetScode(punk->QueryInterface(IID_IMarshal, (void **)&pmsh));
    if (sc == E_NOINTERFACE)
    {
        *pcb = MARSHALINTERFACE_MIN;
        sc = S_OK;
    }
    else if (SUCCEEDED(sc))
    {        
        sc = DfGetScode(pmsh->GetMarshalSizeMax(riid, pv, dwDestContext,
                                                pvDestContext, mshlflags,
                                                &cb));
        if (SUCCEEDED(sc))
            *pcb = MARSHALINTERFACE_MIN+cb;
        pmsh->Release();
    }
    
    olDebugOut((DEB_ITRACE, "Out GetCoMarshalSize => %lu, 0x%lX\n",
                *pcb, sc));
    return sc;
}
#else
#define GetCoMarshalSize(riid, punk, pv, dwDestContext, pvDestContext,\
                         mshlflags, pcb) \
    GetScode(CoGetMarshalSizeMax(pcb, riid, punk, dwDestContext, \
                                 pvDestContext, mshlflags))
#endif

//+--------------------------------------------------------------
//
//  Function:   GetStdMarshalSize, public
//
//  Synopsis:   Returns the size needed for a standard marshal buffer
//
//  Arguments:  [iid] - Requested marshal IID
//              [iidObj] - IID of object being marshalled
//              [dwDestContext] - Destination context
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//              [pcbSize] - Size return
//              [cbSize] - Object private size
//              [ppc] - Context to marshal or NULL
//              [fMarshalOriginal] - Marshal original in context
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE GetStdMarshalSize(REFIID iid,
                        REFIID iidObj,
                        DWORD dwDestContext,
                        LPVOID pvDestContext,
                        DWORD mshlflags,
                        DWORD *pcbSize,
                        DWORD cbSize,
#ifdef ASYNC                        
                        CAsyncConnection *pcpoint,
                        BOOL fMarshalILBs,
#endif                        
                        CPerContext *ppc,
                        BOOL const fMarshalOriginal)
{
    DWORD cbLBSize;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  GetStdMarshalSize("
                "iid, iidObj, %lu, %p, %lu, %p, %lu, %p, %d)\n",
                dwDestContext, pvDestContext, mshlflags, pcbSize, cbSize, ppc,
                fMarshalOriginal));

    olChk(ValidateOutBuffer(pcbSize, sizeof(DWORD)));
    *pcbSize = 0;
    olChk(ValidateIid(iid));
    olChk(VerifyIid(iid, iidObj));
    
    if (((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
        || pvDestContext != NULL)
        olErr(EH_Err, STG_E_INVALIDFLAG);
    
    *pcbSize = CBSTDMARSHALSIZE+cbSize;
#ifdef MULTIHEAP
    *pcbSize += sizeof(ULONG)+sizeof(ContextId)+sizeof(CPerContext*);
#endif
#ifdef POINTER_IDENTITY
    *pcbSize += sizeof(CMarshalList*);
#endif
#ifdef ASYNC    
    if ((ppc) && fMarshalILBs)
#else
    if (ppc)
#endif        
    {
        *pcbSize += sizeof(CGlobalContext *);
        olChk(GetCoMarshalSize(IID_ILockBytes,
                               (ILockBytes *)ppc->GetBase(),
                               NULL, dwDestContext, pvDestContext,
                               mshlflags, &cbLBSize));
        *pcbSize += cbLBSize;
        olChk(GetCoMarshalSize(IID_ILockBytes,
                               (ILockBytes *)ppc->GetDirty(),
                               NULL, dwDestContext, pvDestContext,
                               mshlflags, &cbLBSize));
        *pcbSize += cbLBSize;
        if (fMarshalOriginal)
        {
            olChk(GetCoMarshalSize(IID_ILockBytes,
                                   (ILockBytes *)ppc->GetOriginal(),
                                   NULL, dwDestContext, pvDestContext,
                                   mshlflags, &cbLBSize));
            *pcbSize += cbLBSize;
        }
    }
#ifdef ASYNC
    //BOOL determines whether we have a connection to marshal or not
    *pcbSize += sizeof(BOOL);
    if ((pcpoint) && (pcpoint->GetMarshalPoint() != NULL))
    {
        ULONG cbConnectSize;
        //Async flags
        *pcbSize += sizeof(DWORD);
        olChk(GetCoMarshalSize(IID_IDocfileAsyncConnectionPoint,
                               pcpoint->GetMarshalPoint(),
                               NULL, dwDestContext, pvDestContext,
                               mshlflags, &cbConnectSize));
        *pcbSize += cbConnectSize;
    }
#endif

    olDebugOut((DEB_ITRACE, "Out GetStdMarshalSize\n"));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     StartMarshal, public
//
//  Synopsis:   Writes standard marshal header
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [iid] - Interface to marshal
//              [iidObj] - Object being marshalled
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE StartMarshal(IStream *pstStm,
                   REFIID iid,
                   REFIID iidObj,
                   DWORD mshlflags)
{
    SCODE sc;
    ULONG cbWritten;

    olDebugOut((DEB_ITRACE, "In  StartMarshal(%p, iid, iidObj, %lu)\n",
                pstStm, mshlflags));
    
    olChk(ValidateInterface(pstStm, IID_IStream));
    olChk(ValidateIid(iid));
    olChk(VerifyIid(iid, iidObj));
    olHChk(pstStm->Write((void *)&iidObj, sizeof(iidObj), &cbWritten));
    if (cbWritten != sizeof(iidObj))
        olErr(EH_Err, STG_E_WRITEFAULT);
#if defined(_WIN64)
    mshlflags |= MSHLFLAGS_STG_WIN64;
#endif
    olHChk(pstStm->Write((void *)&mshlflags, sizeof(mshlflags), &cbWritten));
    if (cbWritten != sizeof(mshlflags))
        olErr(EH_Err, STG_E_WRITEFAULT);

    olDebugOut((DEB_ITRACE, "Out StartMarshal\n"));
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   SkipStdMarshal, public
//
//  Synopsis:   Skips over the standard marshal data
//
//  Arguments:  [pstm] - Marshal stream
//              [piid] - IID return
//              [pmshlflags] - Return marshal flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [piid]
//              [pmshlflags]
//
//  History:    20-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef WIN32
SCODE SkipStdMarshal(IStream *pstm, IID *piid, DWORD *pmshlflags)
{
    SCODE sc;
    ULONG cbRead;

    olDebugOut((DEB_ITRACE, "In  SkipStdMarshal(%p, %p, %p)\n", pstm,
                piid, pmshlflags));
    
    olHChk(pstm->Read(piid, sizeof(IID), &cbRead));
    if (cbRead != sizeof(IID))
        olErr(EH_Err, STG_E_READFAULT);
    olHChk(pstm->Read(pmshlflags, sizeof(DWORD), &cbRead));
    if (cbRead != sizeof(DWORD))
        olErr(EH_Err, STG_E_READFAULT);
    
    olDebugOut((DEB_ITRACE, "Out SkipStdMarshal => %lX\n", sc));
 EH_Err:
    return sc;
}
#endif

//+--------------------------------------------------------------
//
//  Function:   MarshalPointer, public
//
//  Synopsis:   Marshals a pointer
//
//  Arguments:  [pstm] - Marshal stream
//              [pv] - Pointer
//
//  Returns:    Appropriate status code
//
//  History:    20-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE MarshalPointer(IStream *pstm, void *pv)
{
    SCODE sc;
    ULONG cbWritten;

    olDebugOut((DEB_ITRACE, "In  MarshalPointer(%p, %p)\n", pstm, pv));
    
#ifdef USEBASED
    ULONG ul = (ULONG)((ULONG_PTR)pv - (ULONG_PTR)DFBASEPTR);
#endif
    
    sc = DfGetScode(pstm->Write(&ul, sizeof(ul), &cbWritten));
    if (SUCCEEDED(sc) && cbWritten != sizeof(ul))
        sc = STG_E_WRITEFAULT;
    
    olDebugOut((DEB_ITRACE, "Out MarshalPointer\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   MarshalContext, public
//
//  Synopsis:   Marshals a context
//
//  Arguments:  [pstm] - Marshal stream
//              [ppc] - Context
//              [dwDestContext] - Destination context
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//              [fMarshalOriginal] - Marshal original or not
//
//  Returns:    Appropriate status code
//
//  History:    20-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE MarshalContext(IStream *pstm,
                     CPerContext *ppc,
                     DWORD dwDestContext,
                     LPVOID pvDestContext,
                     DWORD mshlflags,
#ifdef ASYNC                     
                     BOOL const fMarshalILBs,
#endif                     
                     BOOL const fMarshalOriginal)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  MarshalContext(%p, %p, %lu, %p, %lu, %d)\n",
                pstm, ppc, dwDestContext, pvDestContext, mshlflags,
                fMarshalOriginal));
    
    olChk(MarshalPointer(pstm, ppc->GetGlobal()));

#ifdef ASYNC    
    if (fMarshalILBs)
#endif        
    {
        olHChk(CoMarshalInterface(pstm, IID_ILockBytes, ppc->GetBase(),
                                  dwDestContext, pvDestContext, mshlflags));
        olHChk(CoMarshalInterface(pstm, IID_ILockBytes,
                                  (ILockBytes *)ppc->GetDirty(),
                                  dwDestContext, pvDestContext, mshlflags));
        if (fMarshalOriginal)
            olHChk(CoMarshalInterface(pstm, IID_ILockBytes, ppc->GetOriginal(),
                                      dwDestContext, pvDestContext, mshlflags));
    }
    
    olDebugOut((DEB_ITRACE, "Out MarshalContext\n"));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   UnmarshalPointer, public
//
//  Synopsis:   Unmarshals a pointer
//
//  Arguments:  [pstm] - Marshal stream
//              [ppv] - Pointer return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    20-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE UnmarshalPointer(IStream *pstm,
                       void **ppv)
{
    SCODE sc;
    ULONG cbRead;
    ULONG ul;

    olDebugOut((DEB_ITRACE, "In  UnmarshalPointer(%p, %p)\n", pstm, ppv));
    
    sc = DfGetScode(pstm->Read(&ul, sizeof(ul), &cbRead));
    if (SUCCEEDED(sc) && cbRead != sizeof(ul))
        sc = STG_E_READFAULT;
    
#ifdef USEBASED
    *ppv = (void *)(ul + (BYTE*)DFBASEPTR);
#endif
    
    olDebugOut((DEB_ITRACE, "Out UnmarshalPointer => %p\n", *ppv));
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   UnmarshalContext, public
//
//  Synopsis:   Unmarshals a context
//
//  Arguments:  [pstm] - Marshal stream
//              [pppc] - Context return
//              [fUnmarshalOriginal] - Marshalled original exists or not
//              [fIsRoot] - Root unmarshal or not
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pppc]
//
//  History:    20-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE UnmarshalContext(IStream *pstm,
                       CGlobalContext *pgc,
                       CPerContext **pppc,
                       DWORD mshlflags,
#ifdef ASYNC                       
                       BOOL const fUnmarshalILBs,
#endif                       
                       BOOL const fUnmarshalOriginal,
#ifdef MULTIHEAP
                       ContextId cntxid,
#endif
                       BOOL const fIsRoot)
{
    BOOL fNewContext;
    ILockBytes *plkbBase = NULL;
    CFileStream *pfstDirty = NULL;
    ILockBytes *plkbOriginal = NULL;
    SCODE sc, sc2;
    CPerContext *ppc;
    CPerContext *ppcNew = NULL;
    ULONG ulOpenLock = 0;

    olDebugOut((DEB_ITRACE, "In  UnmarshalContext(%p, %p, %lu, %d, %d)\n",
                pstm, pppc, mshlflags, fUnmarshalOriginal, fIsRoot));

    ppc = pgc->Find(GetCurrentContextId());

    // ignore leaked contexts from processes that died and their ID got reused
    if (ppc != NULL && !ppc->IsHandleValid())
        ppc = NULL;

    fNewContext = (ppc == NULL);
    
#ifdef MULTIHEAP
    // when marshaling to the same process, use the same heap
    // when marshaling to a different process, check the context list
    // if there is a matching percontext, use that heap

    if (GetCurrentContextId() != cntxid && ppc != NULL)
    {
        ppc->SetThreadAllocatorState(NULL);       // set new base

        // Whenever we unmarshal into a different process, we create 
        // a new mapping (of the same heap),
        // even if a mapping of the same heap may already exist in 
        // the same process.  For pointer identity, it is essential 
        // that we find and use the existing heap.
        //  process A ---marshal--->  process B ---marshal---->  process A
        // The "final" unmarshaled exposed object in process A should 
        // match the original pointer used when the exposed object 
        // was originally marshaled.  To do this, we check the global
        // context list, and if there's a percontext match, we use 
        // its allocator and heap mapping (and don't create a new one).
        // However, to actually search the global context list (it
        // lives in shared memory), we need a temporary mapping until 
        // a matching percontext can be found and reused.
        // If not, then a new percontext is allocated and the temporary
        // mapping becomes "permanent" for the lifetime of the new percontext.
    }
#endif
    if (fNewContext)
    {
        olMemTo(EH_Open,
                ppc = new (pgc->GetMalloc()) CPerContext(pgc->GetMalloc()));
        olChkTo(EH_ppc, ppc->InitFromGlobal(pgc));
        ppcNew = ppc;   // used to release in error paths
    }
    
#ifdef MULTIHEAP
    // take the ownership of the heap away from the temporary
    ppc->SetAllocatorState (NULL, &g_smAllocator);

    //ppc from above may have used incorrect base (base of temporary heap).
    //  Since we're returning and storing an unbased pointer, we need to get
    //  the real absolute pointer here.  At this point, ppc will always be in
    //  the context list, so we don't need to worry about a NULL return.
    ppc = pgc->Find(GetCurrentContextId());

    olAssert(ppc != NULL);
#endif
    
#ifdef ASYNC    
    if (fUnmarshalILBs)
    {
#endif        

    // attempt to unmarshal all the interfaces first. this makes cleanup
    // easier.
    sc	= CoUnmarshalInterface(pstm, IID_ILockBytes, (void **)&plkbBase);
    sc2 = CoUnmarshalInterface(pstm, IID_ILockBytes, (void **)&pfstDirty);

    sc = (SUCCEEDED(sc)) ? sc2 : sc;	// sc = first failure code (if any)

    if (fUnmarshalOriginal)
    {
	sc2 = CoUnmarshalInterface(pstm, IID_ILockBytes,
					 (void **)&plkbOriginal);
	sc = (SUCCEEDED(sc)) ? sc2 : sc; // sc = first failure code (if any)
    }

    // cleanup if any failure so far
    olChkTo(EH_plkbOriginal, sc);

    if (ppc->GetBase() != NULL)
    {
        // already have context, just release the things we unmarshaled.
        plkbBase->Release();
        plkbBase = NULL;
    }

    if (ppc->GetDirty() != NULL)
    {
        pfstDirty->Release();
        pfstDirty = NULL;
    }

    if ((plkbOriginal) && (ppc->GetOriginal() != NULL))
    {
        plkbOriginal->Release();
        plkbOriginal = NULL;
    }
    else if ((NULL == plkbOriginal) && plkbBase)
    {
        plkbBase->AddRef();
        plkbOriginal = plkbBase;
    }
    olAssert (plkbOriginal != NULL || ppc->GetOriginal() != NULL);

    // Make sure there is a reserved handle if this is a root
    // file-based lockbytes
    if (fIsRoot)
    {
        IFileLockBytes *pflkb;

        if (SUCCEEDED(DfGetScode((plkbOriginal ? plkbOriginal :
                                  ppc->GetOriginal())->
                                 QueryInterface(IID_IFileLockBytes,
                                                (void **)&pflkb))))
        {
            sc = DfGetScode(pflkb->ReserveHandle());
            pflkb->Release();
	    olChkTo(EH_plkbOriginal, sc);
        }
    }
#ifdef ASYNC
    }
#endif
    
    if (fNewContext)
    {
        olAssert(plkbOriginal != NULL);
        
        // Take open locks if necessary
        if (fIsRoot && pgc->TakeLock())
        {
	    olChkTo(EH_plkbOriginal,
		    GetOpen(plkbOriginal, pgc->GetOpenLockFlags(),
                            FALSE, &ulOpenLock));
        }
        
        ppc->SetILBInfo(plkbBase, pfstDirty, plkbOriginal, ulOpenLock);
    }
    else 
    {
        if (ppc->GetBase() == NULL)
        {
            //Fill in the ILB fields
            ppc->SetILBInfo(plkbBase, pfstDirty, plkbOriginal, ulOpenLock);
        }
        ppc->AddRef();
        
    }

    *pppc = ppc;
    
    olDebugOut((DEB_ITRACE, "Out UnmarshalContext => %p\n", *pppc));
    return S_OK;

 EH_ppc:
    // Preserve plkbOriginal so the lock is released even after the
    // context releases things;
    plkbOriginal->AddRef();
    ppc->Release();
    ppcNew = NULL;
    pfstDirty = NULL;
    plkbBase = NULL;
 EH_Open:
    if (ulOpenLock != 0)
    {
        olAssert(plkbOriginal != NULL);
        ReleaseOpen(plkbOriginal, pgc->GetOpenLockFlags(), ulOpenLock);
    }
 EH_plkbOriginal:
    if (ppcNew != NULL)
        ppcNew->Release();

    if (plkbOriginal)
    	plkbOriginal->Release();

    if (pfstDirty)
    	pfstDirty->Release();
    if (plkbBase)
    	plkbBase->Release();

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseContext, public
//
//  Synopsis:   Releases references for a context's marshal data
//
//  Arguments:  [pstm] - Marshal stream
//              [fHasOriginal] - Original is marshalled
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  History:    20-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef WIN32
SCODE ReleaseContext(IStream *pstm,
#ifdef ASYNC
                     BOOL const fUnmarshalILBs,
#endif                     
                     BOOL const fHasOriginal,
                     DWORD mshlflags)
{
    CGlobalContext *pgc;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  ReleaseContext(%p, %d, %lu)\n", pstm,
                fHasOriginal, mshlflags));
    
    olChk(UnmarshalPointer(pstm, (void **)&pgc));
    if (fUnmarshalILBs)
    {
        olHChk(CoReleaseMarshalData(pstm));
        olHChk(CoReleaseMarshalData(pstm));
        if (fHasOriginal)
            olHChk(CoReleaseMarshalData(pstm));
    }
    
    olDebugOut((DEB_ITRACE, "Out ReleaseContext\n"));
 EH_Err:
    return sc;
}
#endif

#ifdef MULTIHEAP
//+---------------------------------------------------------------------------
//
//  Function:   MarshalSharedMemory, public
//
//  Synopsis:   marshals the shared memory context
//
//  Arguments:  [pstm] - Marshal stream
//              [ppc] - per context structure
//
//  Returns:    Appropriate status code
//
//  History:    02-Dec-95   HenryLee    Created
//
//----------------------------------------------------------------------------

SCODE MarshalSharedMemory (IStream *pstStm, CPerContext *ppc)
{
    SCODE sc = S_OK;
    ULONG cbWritten;
    ULONG ulHeapName;
    ContextId  cntxid = GetCurrentContextId();
    ULONGLONG ulppc = (ULONGLONG) ppc;

    ulHeapName = g_smAllocator.GetHeapName();
    olHChk(pstStm->Write((void*) &ulHeapName, sizeof(ulHeapName), &cbWritten));
    if (cbWritten != sizeof(ulHeapName))
        olErr(EH_Err, STG_E_WRITEFAULT);
    olHChk(pstStm->Write((void*) &cntxid, sizeof(cntxid), &cbWritten));
    if (cbWritten != sizeof(cntxid))
        olErr(EH_Err, STG_E_WRITEFAULT);
    olHChk(pstStm->Write((void*) &ulppc, sizeof(ulppc), &cbWritten));
    if (cbWritten != sizeof(ulppc))
        olErr(EH_Err, STG_E_WRITEFAULT);

EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   SkipSharedMemory, public
//
//  Synopsis:   Cleanup marshaling packet during CoReleaseMarshalData
//
//  Arguments:  [pstm] - Marshal stream
//
//  Returns:    Appropriate status code
//
//  History:    02-Dec-95   HenryLee    Created
//
//----------------------------------------------------------------------------

SCODE SkipSharedMemory (IStream *pstStm, DWORD mshlflags)
{
    SCODE sc = S_OK;
    ULONG cbRead;
    ULONG ulHeapName;
    ContextId cntxid;
    ULONGLONG ulppc;

    olChk(pstStm->Read(&ulHeapName, sizeof(ulHeapName), &cbRead));
    if (cbRead != sizeof(ulHeapName))
        olErr(EH_Err, STG_E_READFAULT);
    olChk(pstStm->Read(&cntxid, sizeof(cntxid), &cbRead));
    if (cbRead != sizeof(cntxid))
        olErr(EH_Err, STG_E_READFAULT);
    olChk(pstStm->Read(&ulppc, sizeof(ulppc), &cbRead));
    if (cbRead != sizeof(ulppc))
        olErr(EH_Err, STG_E_READFAULT);

EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnMarshalSharedMemory, public
//
//  Synopsis:   Unmarshals the shared memory context
//
//  Arguments:  [pstm] - Marshal stream
//
//  Returns:    Appropriate status code
//
//  History:    02-Dec-95   HenryLee    Created
//
//----------------------------------------------------------------------------

SCODE UnmarshalSharedMemory (IStream *pstStm, DWORD mshlflags,
                             CPerContext *ppcOwner, ContextId *pcntxid)
{
    SCODE sc = S_OK;
    ULONG cbRead;
    ULONG ulHeapName;
    ContextId cntxid;
    CPerContext *ppc;
    ULONGLONG ulppc;

    olHChk(pstStm->Read(&ulHeapName, sizeof(ulHeapName), &cbRead));
    if (cbRead != sizeof(ulHeapName))
        olErr(EH_Err, STG_E_READFAULT);
    olHChk(pstStm->Read(&cntxid, sizeof(cntxid), &cbRead));
    if (cbRead != sizeof(cntxid))
        olErr(EH_Err, STG_E_READFAULT);
    olHChk(pstStm->Read(&ulppc, sizeof(ulppc), &cbRead));
    if (cbRead != sizeof(ulppc))
        olErr(EH_Err, STG_E_READFAULT);
    
    ppc = (CPerContext *) ulppc;

#if defined(_WIN64)
    if ((mshlflags & MSHLFLAGS_STG_WIN64) == 0)
        olErr (EH_Err, STG_E_INVALIDFUNCTION);
#else
    if ((mshlflags & MSHLFLAGS_STG_WIN64) != 0)
        olErr (EH_Err, STG_E_INVALIDFUNCTION);
#endif

    *pcntxid = cntxid;
    if (GetCurrentContextId() == cntxid)
    {
        // marshaling to the same process, reuse the per context and heap
        // in the case of marshaling to another thread
        // the per context takes ownership of the thread's allocator
        ppc->SetThreadAllocatorState(NULL);
    }
    else
    {
        // marshaling to another process on the same machine
        // if the name of heap is different that current one, open it
        if (g_smAllocator.GetHeapName() != ulHeapName)
        {
            DfInitSharedMemBase();
            olChk(DfSyncSharedMemory(ulHeapName));
        }

        // Because the unmarshaling code calls IStream::Read,
        // possibly using another shared heap, we need a temporary
        // owner until the real CPerContext is unmarshaled
        ppcOwner->GetThreadAllocatorState(); 
        ppcOwner->SetThreadAllocatorState(NULL); 
    }
EH_Err:
    return sc;
}
#endif


#ifdef ASYNC
SCODE MarshalConnection(IStream *pstm,
                        CAsyncConnection *pcpoint,
                        DWORD dwDestContext,
                        LPVOID pvDestContext,
                        DWORD mshlflags)
{
    SCODE sc;
    ULONG cbWritten;
    IDocfileAsyncConnectionPoint *pdacp = pcpoint->GetMarshalPoint();
    BOOL fIsInitialized = (pdacp != NULL);

    //Write out the pointer.
    olHChk(pstm->Write(&fIsInitialized,
                       sizeof(BOOL),
                       &cbWritten));
    if (cbWritten != sizeof(BOOL))
    {
        olErr(EH_Err, STG_E_READFAULT);
    }
    
    if (fIsInitialized)
    {
        //If the pointer was NULL, we don't need to worry about actually
        //marshalling anything, and we can detect this in the unmarshal
        //path.  If it wasn't NULL, we need to store some additional
        //information:  The async flags and the actual connection point,
        //which will be standard marshalled.
        DWORD dwAsyncFlags = pcpoint->GetAsyncFlags();

        olChk(pstm->Write(&dwAsyncFlags, sizeof(DWORD), &cbWritten));
        if (cbWritten != sizeof(DWORD))
        {
            olErr(EH_Err, STG_E_WRITEFAULT);
        }

        //Finally, standard marshal the connection point itself.
        olHChk(CoMarshalInterface(pstm,
                                  IID_IDocfileAsyncConnectionPoint,
                                  pdacp,
                                  dwDestContext,
                                  pvDestContext,
                                  mshlflags));
    }
EH_Err:
    return sc;
}

SCODE UnmarshalConnection(IStream *pstm,
                          DWORD *pdwAsyncFlags,
                          IDocfileAsyncConnectionPoint **ppdacp,
                          DWORD mshlflags)
{
    SCODE sc;
    BOOL fIsInitialized;
    ULONG cbRead;

    *ppdacp = NULL;
    *pdwAsyncFlags = 0;

    olHChk(pstm->Read(&fIsInitialized, sizeof(BOOL), &cbRead));
    if (cbRead != sizeof(BOOL))
    {
        olErr(EH_Err, STG_E_READFAULT);
    }

    if (fIsInitialized)
    {
        olChk(pstm->Read(pdwAsyncFlags, sizeof(DWORD), &cbRead));
        if (cbRead != sizeof(DWORD))
        {
            olErr(EH_Err, STG_E_READFAULT);
        }
        sc = CoUnmarshalInterface(pstm,
                                  IID_IDocfileAsyncConnectionPoint,
                                  (void **)ppdacp);
    }
EH_Err:
    return sc;
}

SCODE ReleaseConnection(IStream *pstm, DWORD mshlflags)
{
    SCODE sc;
    ULONG cbRead;
    BOOL fIsInitialized;
    DWORD dwAsyncFlags;
    
    olHChk(pstm->Read(&fIsInitialized, sizeof(BOOL), &cbRead));
    if (cbRead != sizeof(BOOL))
    {
        olErr(EH_Err, STG_E_READFAULT);
    }
    if (fIsInitialized)
    {
        olChk(pstm->Read(&dwAsyncFlags, sizeof(DWORD), &cbRead));
        if (cbRead != sizeof(DWORD))
        {
            olErr(EH_Err, STG_E_READFAULT);
        }
        olHChk(CoReleaseMarshalData(pstm));
    }

 EH_Err:
    return sc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\lock.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       lock.cxx
//
//  Contents:   Remote exclusion stuff for docfile
//
//  Functions:  GetAccess
//              ReleaseAccess
//              GetOpen
//              ReleaseOpen
//
//  History:    09-Mar-92   PhilipLa    Created.
//              20-Jul-93   DrewB       Added dual locking for Mac
//                                      compatibility
//
//--------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <header.hxx>
#include <lock.hxx>

// Offset to next lock group from a particular group
#define OLOCKGROUP 1

// The docfile originally locked at 0xffffff00
// It turned out that the Mac can only lock to 0x7fffffff,
// so for compatibility reasons it was decided that the
// docfile would lock at both places.  Thus, we have one routine
// that locks with a mask for the offset so that we can
// selectively suppress the high bit
// Since lock indices fit easily within 16 bits, the two
// lock indices are now combined into the existing ULONG
// value to preserve compatibility with other code.  This
// implies that lock indices from these routines must be
// handled opaquely since they are no longer simple numbers

// 09/23/1993 - Further change:
// To avoid a Netware 2.2 problem we are offsetting the lock regions
// so that they differ by more than just the high bit.  The high
// lock region was moved to 0xffffff80, moving the low region to
// 0x7fffff80.  The 0x80 was then taken out of the high mask so that
// the net is no change for high locks and the low locks moved up by 0x80

// Masks for separate lock locations
// moved to lock.hxx

//In a specific open case (Read-only, deny-write), we don't need to
//take locks.
#define P_NOLOCK(df) (!P_WRITE(df) && P_READ(df) && \
                      P_DENYWRITE(df) && !P_DENYREAD(df))

//+--------------------------------------------------------------
//
//  Function:   GetAccessWithMask, private
//
//  Synopsis:   Takes appropriate access locks on an LStream,
//              masking the offset with the given mask
//
//  Arguments:  [plst] - LStream
//              [df] - Permissions needed
//              [ulMask] - Mask
//              [poReturn] - Index of lock taken
//
//  Returns:    Appropriate status code
//
//  Modifies:   [poReturn]
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE GetAccessWithMask(ILockBytes *plst,
                               DFLAGS df,
                               ULONG ulMask,
                               ULONG *poReturn)
{
    SCODE sc;
    ULARGE_INTEGER ulOffset, cbLength;

    olDebugOut((DEB_ITRACE, "In  GetAccessWithMask(%p, %X, %lX, %p)\n",
                plst, df, ulMask, poReturn));
    olAssert((df & ~(DF_READ | DF_WRITE)) == 0 && P_READ(df) != P_WRITE(df));
    *poReturn = NOLOCK;
    ULISet32(ulOffset, OACCESS & ulMask);
    if (P_READ(df))
    {
        ULISet32(cbLength, 1);
        olHChk(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
        for (USHORT i = 0; i < CREADLOCKS; i++)
        {
            ULISetLow(ulOffset, (OREADLOCK+i) & ulMask);
            sc = DfGetScode(plst->LockRegion(ulOffset, cbLength,
                                             LOCK_ONLYONCE));
            if (SUCCEEDED(sc))
            {
                *poReturn = i+1;
                break;
            }
        }
        ULISetLow(ulOffset, OACCESS & ulMask);
        olHVerSucc(sc = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
        if (i == CREADLOCKS)
            olErr(EH_Err, STG_E_TOOMANYOPENFILES);
    }
    else
    {
        olAssert((OACCESS + 1 == OREADLOCK) && aMsg("Bad lock dependency"));
        ULISet32(cbLength, 1 + CREADLOCKS);
        olChk(DfGetScode(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE)));
        *poReturn = 0xFFFF;
    }
    olDebugOut((DEB_ITRACE, "Out GetAccessWithMask => %lu\n", *poReturn));
    olAssert(*poReturn != NOLOCK);
    return S_OK;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   ReleaseAccessWithMask, private
//
//  Synopsis:   Releases an access lock at the given offset
//
//  Arguments:  [plst] - LStream that is locked
//              [df] - Permission to release
//              [offset] - Offset of locks taken
//              [ulMask] - Mask
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void ReleaseAccessWithMask(ILockBytes *plst,
                                  DFLAGS df,
                                  ULONG offset,
                                  ULONG ulMask)
{
    ULARGE_INTEGER ulOffset, cbLength;
    SCODE scTemp;

    olDebugOut((DEB_ITRACE, "In  ReleaseAccessWithMask(%p, %lX, %lu, %lX)\n",
                plst, df, offset, ulMask));
    olAssert((df & ~(DF_READ | DF_WRITE)) == 0 && P_READ(df) != P_WRITE(df));
    if (offset == NOLOCK)
        return;
    if (P_READ(df))
    {
        ULISet32(ulOffset, (offset+OREADLOCK-1) & ulMask);
        ULISet32(cbLength, 1);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE); 
    }
    else
    {
        olAssert((OACCESS + 1 == OREADLOCK) && aMsg("Bad lock dependency"));
        ULISet32(ulOffset, OACCESS & ulMask);
        ULISet32(cbLength, 1 + CREADLOCKS);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
    olDebugOut((DEB_ITRACE, "Out ReleaseAccessWithMask\n"));
}

//+--------------------------------------------------------------
//
//  Function:   GetAccess, public
//
//  Synopsis:   Takes appropriate access locks on an LStream
//
//  Arguments:  [plst] - LStream
//              [df] - Permissions needed
//              [poReturn] - Index of lock taken
//
//  Returns:    Appropriate status code
//
//  Modifies:   [poReturn]
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE GetAccess(ILockBytes *plst,
                DFLAGS df,
                ULONG *poReturn)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  GetAccess(%p, %X, %p)\n",
                plst, df, poReturn));

    // Make sure our lock region hasn't overflowed 32 bits
    olAssert(OLOCKREGIONEND > OACCESS);

    olChk(GetAccessWithMask(plst, df, 0xFFFFFFFF, poReturn));
    olAssert(*poReturn < 0x10000);

    olDebugOut((DEB_ITRACE, "Out GetAccess => %lu\n", *poReturn));
    return S_OK;

 EH_Err:
    *poReturn = NOLOCK;
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   ReleaseAccess, public
//
//  Synopsis:   Releases access locks
//
//  Arguments:  [plst] - LStream that is locked
//              [df] - Permission to release
//              [offset] - Offset of locks taken
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void ReleaseAccess(ILockBytes *plst, DFLAGS df, ULONG offset)
{
    olDebugOut((DEB_ITRACE, "In  ReleaseAccess(%p, %lX, %lu)\n",
                plst, df, offset));

    ReleaseAccessWithMask(plst, df, offset & 0xffff, 0xFFFFFFFF);

    olDebugOut((DEB_ITRACE, "Out ReleaseAccess\n"));
}

//+--------------------------------------------------------------
//
//  Function:   GetOpenWithMask, private
//
//  Synopsis:   Gets locks on an LStream during opening, masking the offset
//
//  Arguments:  [plst] - LStream
//              [df] - Permissions to take
//              [fCheck] - Whether to check for existing locks or not
//              [ulMask] - Mask
//              [puReturn] - Index of lock taken
//
//  Returns:    Appropriate status code
//
//  Modifies:   [puReturn]
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

#define WAITUPDATE_INITIAL 100
#define WAITUPDATE_TIMEOUT 10000

SCODE GetOpenWithMask(ILockBytes *plst,
                             DFLAGS df,
                             BOOL fCheck,
                             ULONG ulMask,
                             ULONG *puReturn)
{
    SCODE sc;
    ULONG i;
    ULARGE_INTEGER ulOffset, cbLength;
#ifdef DIRECTWRITERLOCK
    BOOL fDirectWriterMode = P_READWRITE(df) && !P_TRANSACTED(df) &&
                            !P_DENYREAD(df) && P_DENYWRITE(df);
    BOOL fDirectReaderMode = P_READ(df) && !P_WRITE(df) && !P_TRANSACTED(df) &&
                            !P_DENYREAD(df) && !P_DENYWRITE(df);
#endif

    olDebugOut((DEB_ITRACE, "In  GetOpenWithMask(%p, %lX, %d, %lX, %p)\n",
                plst, df, fCheck, ulMask, puReturn));
    *puReturn = NOLOCK;

    ULISet32(ulOffset, OUPDATE & ulMask);
    ULISet32(cbLength, 1);

    //Do a graceful fallback.
    DWORD dwWait = WAITUPDATE_INITIAL;
    for (;;)
    {
        sc = plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
        if (sc != STG_E_LOCKVIOLATION ||
            dwWait >= WAITUPDATE_TIMEOUT)
            break;
        Sleep(dwWait);
        dwWait *= (GetTickCount() & 1) ? 1 : 2;
    }
    olChk(sc);

    if (fCheck)
    {
        ULISetLow(cbLength, COPENLOCKS);
        if (P_DENYREAD(df))
        {
            ULISetLow(ulOffset, OOPENREADLOCK & ulMask);
            olHChkTo(EH_UnlockUpdate, plst->LockRegion(ulOffset, cbLength,
                                                       LOCK_ONLYONCE));
            olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
        }
#ifndef USE_NOSNAPSHOT
        if (P_DENYWRITE(df))
#else            
        if (P_DENYWRITE(df) || P_NOSNAPSHOT(df))
#endif            
        {
            ULISetLow(ulOffset, OOPENWRITELOCK & ulMask);
            sc = plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
            if (SUCCEEDED(sc))
            {
                olHVerSucc(plst->UnlockRegion(ulOffset,
                                              cbLength,
                                              LOCK_ONLYONCE));
            }
#ifdef USE_NOSNAPSHOT            
            else if (P_NOSNAPSHOT(df))
            {
                //There is an existing writer.  In order for this
                //open to succeed, there must also be a lock in the
                //no-snapshot region.  Otherwise we have a case where
                //a normal open proceeded a no-snapshot open attempt,
                //and mixing modes is not allowed.
                ULISetLow(ulOffset, OOPENNOSNAPSHOTLOCK & ulMask);
                sc = plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
                if (SUCCEEDED(sc))
                {
                    //There was no no-snapshot lock.  No mixing modes,
                    //so fail here.
                    olHVerSucc(plst->UnlockRegion(ulOffset,
                                                  cbLength,
                                                  LOCK_ONLYONCE));
                    olErr(EH_UnlockUpdate, STG_E_LOCKVIOLATION);
                }
            }
#endif            
            else
            {
                olErr(EH_UnlockUpdate, sc);
            }
        }
        if (P_READ(df))
        {
            ULISetLow(ulOffset, OOPENDENYREADLOCK & ulMask);
            olHChkTo(EH_UnlockUpdate, plst->LockRegion(ulOffset, cbLength,
                                                       LOCK_ONLYONCE));
            olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
        }
        if (P_WRITE(df))
        {
            ULISetLow(ulOffset, OOPENDENYWRITELOCK & ulMask);
#ifndef USE_NOSNAPSHOT            
            olHChkTo(EH_UnlockUpdate, plst->LockRegion(ulOffset, cbLength,
                                                       LOCK_ONLYONCE));
            olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
#else
            sc = plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
            if (P_NOSNAPSHOT(df) && (sc == STG_E_LOCKVIOLATION))
            {
                //The deny-write lock may be the fake holder we use for
                //no-snapshot mode.  Check then no-snapshot region - if
                //there is a lock there too, then this succeeds, otherwise
                //the deny-write lock is real and we must fail the call.
                ULISetLow(ulOffset, OOPENNOSNAPSHOTLOCK & ulMask);
                sc = plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
                if (sc != STG_E_LOCKVIOLATION)
                {
                    if (SUCCEEDED(sc))
                    {
                        olHVerSucc(plst->UnlockRegion(ulOffset,
                                                      cbLength,
                                                      LOCK_ONLYONCE));
                        olErr(EH_UnlockUpdate, STG_E_LOCKVIOLATION);
                    }
                    else
                    {
                        olErr(EH_UnlockUpdate, sc);
                    }
                }
            }
            else
            {
                olHChkTo(EH_UnlockUpdate, sc);
                olHVerSucc(plst->UnlockRegion(ulOffset,
                                              cbLength,
                                              LOCK_ONLYONCE));
            }
#endif            
        }
    }
    
    //If we are read-only and deny-write, and we are on our
    //  ILockBytes, we don't need to lock and can rely on the FS
    //  to handle the access control.
    if (P_NOLOCK(df))
    {
        //QueryInterface to see if this ILockBytes is ours

        IFileLockBytes *pfl;
        if (SUCCEEDED(plst->QueryInterface(IID_IFileLockBytes,
                                          (void **) &pfl)))
        {
            pfl->Release();
            
            ULISetLow(ulOffset, OUPDATE & ulMask);
            ULISetLow(cbLength, 1);
            olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
            
            *puReturn = NOLOCK;
            return S_OK;
        }
    }
    

    ULISetLow(cbLength, 1);
    for (i = 0; i < COPENLOCKS; i = i + OLOCKGROUP)
    {
        ULISetLow(ulOffset, (OOPENREADLOCK+i) & ulMask);
        olHChkTo(EH_Loop, plst->LockRegion(ulOffset, cbLength,
                                          LOCK_ONLYONCE));
        ULISetLow(ulOffset, (OOPENWRITELOCK+i) & ulMask);
        olHChkTo(EH_UnlockR, plst->LockRegion(ulOffset, cbLength,
                                             LOCK_ONLYONCE));
        ULISetLow(ulOffset, (OOPENDENYREADLOCK+i) & ulMask);
#ifdef DIRECTWRITERLOCK
        if (fCheck == TRUE || fDirectWriterMode == FALSE)
#endif
        olHChkTo(EH_UnlockW, plst->LockRegion(ulOffset, cbLength,
                                             LOCK_ONLYONCE));
        ULISetLow(ulOffset, (OOPENDENYWRITELOCK+i) & ulMask);
#ifdef USE_NOSNAPSHOT
        olHChkTo(EH_UnlockDR, plst->LockRegion(ulOffset, cbLength,
                                               LOCK_ONLYONCE));
        if (P_NOSNAPSHOT(df))
        {
            //Note that in the non no-snapshot case we don't need to
            //grab this lock, unlike the others where we must grab all
            //four to make sure we have a valid slot.  This is because
            //a no-snapshot open will always have a corresponding
            //deny-write lock in the same slot.
            ULISetLow(ulOffset, (OOPENNOSNAPSHOTLOCK+i) & ulMask);
            if (SUCCEEDED(DfGetScode(plst->LockRegion(ulOffset, cbLength,
                                                      LOCK_ONLYONCE))))
            {
                break;
            }
            //Unlock the deny-write lock, then all the rest.
            ULISetLow(ulOffset, (OOPENDENYWRITELOCK + i));
            olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
        }
        else
        {
            //We're not no-snapshot, and we've gotten all our locks
            //  successfully, so bail.
#ifdef DIRECTWRITERLOCK
            if (fDirectReaderMode)
            {
                ULISetLow(ulOffset, (ODIRECTWRITERLOCK+i) & ulMask);
                if(SUCCEEDED(plst->LockRegion(ulOffset,cbLength,LOCK_ONLYONCE)))
                    break;
            }
            else
#endif
            break;
        }
    EH_UnlockDR:
#else
        if (SUCCEEDED(DfGetScode(plst->LockRegion(ulOffset, cbLength,
                                                  LOCK_ONLYONCE))))
#ifdef DIRECTWRITERLOCK
            if (fDirectReaderMode)
            {
                ULISetLow(ulOffset, (ODIRECTWRITERLOCK+i) & ulMask);
                if(SUCCEEDED(plst->LockRegion(ulOffset,cbLength,LOCK_ONLYONCE)))
                    break;
            }
            else
#endif
            break;
#endif //USE_NOSNAPSHOT
        ULISetLow(ulOffset, (OOPENDENYREADLOCK+i) & ulMask);
#ifdef DIRECTWRITERLOCK
        if (fCheck == TRUE || fDirectWriterMode == FALSE)
#endif
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    EH_UnlockW:
        ULISetLow(ulOffset, (OOPENWRITELOCK+i) & ulMask);
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    EH_UnlockR:
        ULISetLow(ulOffset, (OOPENREADLOCK+i) & ulMask);
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    EH_Loop:
        ;
    }
    if (i >= COPENLOCKS)
        olErr(EH_UnlockUpdate, STG_E_TOOMANYOPENFILES);
    if (!P_READ(df))
    {
        ULISetLow(ulOffset, (OOPENREADLOCK+i) & ulMask);
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }
    if (!P_WRITE(df))
    {
        ULISetLow(ulOffset, (OOPENWRITELOCK+i) & ulMask);
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }
    if (!P_DENYREAD(df))
    {
        ULISetLow(ulOffset, (OOPENDENYREADLOCK+i) & ulMask);
#ifdef DIRECTWRITERLOCK
        if (fCheck == TRUE || fDirectWriterMode == FALSE)
#endif
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }
#ifdef USE_NOSNAPSHOT    
    if (!P_DENYWRITE(df) && !P_NOSNAPSHOT(df))
#else
    if (!P_DENYWRITE(df))
#endif        
    {
        ULISetLow(ulOffset, (OOPENDENYWRITELOCK+i) & ulMask);
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }
    ULISetLow(ulOffset, OUPDATE & ulMask);
    olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));

    //  0 <= i < COPENLOCKS, but 0 is the invalid value, so increment
    //  on the way out
    *puReturn = i + 1;
    olAssert(*puReturn != NOLOCK);

    olDebugOut((DEB_ITRACE, "Out GetOpenWithMask => %lu\n", *puReturn));
    return S_OK;
EH_UnlockUpdate:
    ULISetLow(ulOffset, OUPDATE & ulMask);
    ULISetLow(cbLength, 1);
    olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   ReleaseOpenWithMask, private
//
//  Synopsis:   Releases opening locks with offset masking
//
//  Arguments:  [plst] - LStream
//              [df] - Locks taken
//              [offset] - Index of locks
//              [ulMask] - Mask
//
//  Requires:   offset != NOLOCK
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void ReleaseOpenWithMask(ILockBytes *plst,
                                DFLAGS df,
                                ULONG offset,
                                ULONG ulMask)
{
    ULARGE_INTEGER ulOffset, cbLength;
    SCODE scTemp;

    olDebugOut((DEB_ITRACE, "In  ReleaseOpenWithMask(%p, %lX, %lu, %lX)\n",
                plst, df, offset, ulMask));

    olAssert(offset != NOLOCK);

    //  we incremented at the end of GetOpen, so we decrement here
    //  to restore the proper lock index
    offset--;

    ULISetHigh(ulOffset, 0);
    ULISet32(cbLength, 1);
    if (P_READ(df))
    {
        ULISetLow(ulOffset, (OOPENREADLOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
    if (P_WRITE(df))
    {
        ULISetLow(ulOffset, (OOPENWRITELOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
    if (P_DENYREAD(df))
    {
        ULISetLow(ulOffset, (OOPENDENYREADLOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
#ifdef USE_NOSNAPSHOT    
    if (P_DENYWRITE(df) || P_NOSNAPSHOT(df))
#else
    if (P_DENYWRITE(df))
#endif            
    {
        ULISetLow(ulOffset, (OOPENDENYWRITELOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
#ifdef USE_NOSNAPSHOT    
    if (P_NOSNAPSHOT(df))
    {
        ULISetLow(ulOffset, (OOPENNOSNAPSHOTLOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
#endif
#ifdef DIRECTWRITERLOCK
    BOOL fDirectReaderMode = P_READ(df) && !P_WRITE(df) && !P_TRANSACTED(df) &&
                            !P_DENYREAD(df) && !P_DENYWRITE(df);
    if (fDirectReaderMode)
    {
        ULISetLow(ulOffset, (ODIRECTWRITERLOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
#endif
    
    olDebugOut((DEB_ITRACE, "Out ReleaseOpenWithMask\n"));
}

//+--------------------------------------------------------------
//
//  Function:   GetOpen, public
//
//  Synopsis:   Gets locks on an LStream during opening
//
//  Arguments:  [plst] - LStream
//              [df] - Permissions to take
//              [fCheck] - Whether to check for existing locks or not
//              [puReturn] - Index of lock taken
//
//  Returns:    Appropriate status code
//
//  Modifies:   [puReturn]
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE GetOpen(ILockBytes *plst,
              DFLAGS df,
              BOOL fCheck,
              ULONG *puReturn)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  GetOpen(%p, %lX, %d, %p)\n",
                plst, df, fCheck, puReturn));

    // Make sure our lock region hasn't overflowed 32 bits
    olAssert(OLOCKREGIONEND > OACCESS);

    olChk(GetOpenWithMask(plst, df, fCheck, 0xFFFFFFFF, puReturn));
    olAssert(*puReturn < 0x10000);

    olDebugOut((DEB_ITRACE, "Out GetOpen => %lu\n", *puReturn));
    return S_OK;

 EH_Err:
    *puReturn = NOLOCK;
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   ReleaseOpen, public
//
//  Synopsis:   Releases opening locks
//
//  Arguments:  [plst] - LStream
//              [df] - Locks taken
//              [offset] - Index of locks
//
//  Requires:   offset != NOLOCK
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void ReleaseOpen(ILockBytes *plst, DFLAGS df, ULONG offset)
{
    olDebugOut((DEB_ITRACE, "In  ReleaseOpen(%p, %lX, %lu)\n",
                plst, df, offset));

    if (offset != NOLOCK)
    {
        ReleaseOpenWithMask(plst, df, offset & 0xffff, 0xFFFFFFFF);
    }
    olDebugOut((DEB_ITRACE, "Out ReleaseOpen\n"));
}

//+---------------------------------------------------------------------------
//
//  Function:	WaitForAccess, public, 32-bit only
//
//  Synopsis:	Attempts to get access locks, retrying if necessary
//              using exponential backoff
//
//  Arguments:	[plst] - ILockBytes
//              [df] - Access desired
//              [poReturn] - Lock index return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[poReturn]
//
//  History:	23-Sep-93	DrewB	Created
//
//----------------------------------------------------------------------------

#ifdef WIN32
#define WAITACCESS_INITIAL 100
#define WAITACCESS_TIMEOUT 100000

SCODE WaitForAccess(ILockBytes *plst,
                    DFLAGS df,
                    ULONG *poReturn)
{
    SCODE sc;
    DWORD dwWait;

    olDebugOut((DEB_ITRACE, "In  WaitForAccess(%p, %X, %p)\n",
                plst, df, poReturn));

    dwWait = WAITACCESS_INITIAL;
    for (;;)
    {
        sc = GetAccess(plst, df, poReturn);
        if (sc != STG_E_LOCKVIOLATION ||
            dwWait >= WAITACCESS_TIMEOUT
            )
            break;

        Sleep(dwWait);
        dwWait *= (GetTickCount() & 1) ? 1 : 2;
    }

    olDebugOut((DEB_ITRACE, "Out WaitForAccess => 0x%lX, %lu\n",
                sc, poReturn));
    return sc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\seekptr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       seekptr.cxx
//
//  Contents:   Seek pointer non-inline implementation
//
//  History:    11-Aug-92       PhilipLa        Created.
//
//--------------------------------------------------------------------------
#include <exphead.cxx>
#pragma hdrstop

#include <seekptr.hxx>

//+--------------------------------------------------------------
//
//  Member:     CSeekPointer::Release, public
//
//  Synopsis:   Decrements _cReferences and delete's on noref
//
//  History:    30-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void CSeekPointer::vRelease(void)
{
    LONG lRet;
    
    olDebugOut((DEB_ITRACE, "In  CSeekPointer::Release()\n"));
    olAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
        delete this;
    olDebugOut((DEB_ITRACE, "Out CSeekPointer::Release()\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\h\dfver.h ===
#define rmj		3
#define rmm		62
#define rup		0
#define rmjlarge 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\time32.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       Time32.CXX, 32-bit only
//
//  Contents:   time routine
//
//  Functions:  DfGetTOD
//
//  History:    13-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------
#include <exphead.cxx>
#pragma hdrstop

SCODE DfGetTOD(TIME_T *pft)
{
    SCODE sc;

    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);

    olAssert(sizeof(TIME_T) == sizeof(FILETIME));
    BOOL b = SystemTimeToFileTime(&SystemTime, pft);

    if (b)
    {
        sc = S_OK;
    }
    else
    {
        olAssert(!aMsg("Unable to convert time"));
        sc = E_FAIL;
    }

    return(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\h\storagep.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       storagep.h
//
//  Contents:   Internal storage information
//
//  History:    09-Oct-92	DrewB	Created
//
//--------------------------------------------------------------------------

#ifndef __STORAGEP_H__
#define __STORAGEP_H__

STDAPI StgIsStorageFileHandle( HANDLE hFile, LPOVERLAPPED povlp );

// The byte combination that identifies that a file is a storage of
// some kind

const BYTE SIGSTG[] = {0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1};
const BYTE CBSIGSTG = sizeof(SIGSTG);

// The first portion of a storage file
struct SStorageFile
{
    BYTE	abSig[CBSIGSTG];		//  Signature
    CLSID	_clid;				//  Class Id
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\difat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       difat.cxx
//
//  Contents:   Double Indirected Fat Code
//
//  Classes:    None.
//
//  Functions:
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include <msfhead.cxx>

#pragma hdrstop

#include <difat.hxx>
#include <mread.hxx>

#ifdef DIFAT_OPTIMIZATIONS
#define OPTIMIZE_LOOKUP
#define OPTIMIZE_FIXUP
#endif


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::CDIFat, public
//
//  Synopsis:   CDIFat copy constructor
//
//  Arguments:  [fatOld] -- reference to CDIFat to be copied.
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

CDIFat::CDIFat(CDIFat *pfatOld)
        :   _pmsParent(NULL),
            _fv(SIDDIF)
{
#ifdef DIFAT_LOOKUP_ARRAY
    _cUnmarked = 0;
    _fDoingFixup = FALSE;
#endif    
}

//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::CDIFat, public
//
//  Synopsis:   CDIFat constructor
//
//  Arguments:  [pmsParent] -- Pointer to parent CMStream
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

CDIFat::CDIFat()
:   _pmsParent(NULL),
    _fv(SIDDIF)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat constructor\n"));
    _cfsTable = 0;
#ifdef DIFAT_LOOKUP_ARRAY
    _cUnmarked = 0;
    _fDoingFixup = FALSE;
#endif    
    msfDebugOut((DEB_ITRACE,"Out CDIFat constructor\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CDIFat::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CDIFat::Empty(void)
{
    _fv.Empty();
    _pmsParent = NULL;
    _cfsTable = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CIDFat::Flush, private
//
//  Synopsis:   Flush a sector to disk
//
//  Arguments:  [oSect] -- Indicated which sector to flush
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Write sector up to parent mstream.
//
//  History:    11-May-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::Flush(void)
{
    return _fv.Flush();
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::GetFatSect, public
//
//  Synopsis:   Given an offset into the Fat chain, return the sector
//              value for that FatSect.
//
//  Arguments:  [oSect] -- offset in Fat chain
//
//  Returns:    Sector value of FatSect.
//
//  Algorithm:  If sector is stored in the header, retrieve it from
//                  there.
//              If not, retrieve it from the FatVector.
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDIFat::GetFatSect(const FSINDEX oSect, SECT *psect)
{
    SCODE sc = S_OK;
    SECT sectReturn;

    msfDebugOut((DEB_ITRACE,"In CDIFat::GetFatSect(%lu)\n",oSect));
    if (oSect < CSECTFAT)
    {
        msfDebugOut((DEB_ITRACE,"Getting sect from header\n"));
        sectReturn = _pmsParent->GetHeader()->GetFatSect(oSect);
    }
    else
    {
        FSINDEX ipfs;
        FSOFFSET isect;

        SectToPair(oSect,&ipfs,&isect);

        msfAssert(ipfs < _cfsTable);

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
        sectReturn = pfs->GetSect(isect);
        _fv.ReleaseTable(ipfs);
    }

    msfDebugOut((DEB_ITRACE,"Out CDIFat::GetFatSect(%lu)=>%lu\n",oSect,sectReturn));
    *psect = sectReturn;

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::SetFatSect, public
//
//  Synopsis:   Given an offset into the Fat chain, set the sector
//              value.
//
//  Arguments:  [oSect] -- Offset into fat chain
//              [sect] -- New sector value for that offset.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  If the sector is stored in the header, set it and
//                  flush the header.
//              Otherwise, if the sector will not fit in the current
//                  CFatVector, resize it.
//              Set the sector in the FatVector and flush it.
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDIFat::SetFatSect(const FSINDEX oSect, const SECT sect)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::SetFatSect(%lu,%lu)\n",oSect,sect));
    SCODE sc = S_OK;

    if (oSect < CSECTFAT)
    {
        msfDebugOut((DEB_ITRACE,"Setting sect in header: %lu, %lu\n",oSect,sect));
        _pmsParent->GetHeader()->SetFatSect(oSect, sect);
    }
    else
    {
        FSINDEX ipfs;
        FSOFFSET isect;

        SectToPair(oSect,&ipfs,&isect);
        if (ipfs >= _cfsTable)
        {
            msfChk(Resize(_cfsTable + 1));
        }

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));

        pfs->SetSect(isect, sect);
        _fv.ReleaseTable(ipfs);

        msfDebugOut((DEB_ITRACE,"In CDIFat::SetFatSect(%lu,%lu)\n",oSect,sect));
    }

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::GetSect, public
//
//  Synopsis:   Given an offset into the DIFat chain, return the
//              sector value
//
//  Arguments:  [oSect] -- Offset into DIFat chain.
//
//  Returns:    Sector value for given offset.
//
//  Algorithm:  Retrieve the information from the NextFat fields of
//                  the CFatVector
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDIFat::GetSect(const FSINDEX oSect, SECT *psect)
{
    SCODE sc = S_OK;

    SECT sectReturn;

    msfDebugOut((DEB_ITRACE,"In CDIFat::GetSect(%lu)\n",oSect));
    msfAssert(oSect < _cfsTable);

    sectReturn = _pmsParent->GetHeader()->GetDifStart();

    //Possible optimization here:  Do some sort of check to
    //find the last page that's actually cached in the vector,
    //then start the loop from there.  Probably not a terribly
    //important optimization, but it is possible.
    for (FSINDEX oCurrent = 0; oCurrent < oSect; oCurrent++)
    {
        msfAssert(sectReturn != ENDOFCHAIN);
        
        CFatSect *pfs;
        msfChk(_fv.GetTableWithSect(oCurrent,
                                    FB_NONE,
                                    sectReturn,
                                    (void **)&pfs));
        
        sectReturn = pfs->GetNextFat(_fv.GetSectTable());
        _fv.ReleaseTable(oCurrent);
    }

    msfDebugOut((DEB_ITRACE,"Out CDIFat::GetSect(%lu)=>%lu\n",oSect,sectReturn));
    *psect = sectReturn;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::Init, public
//
//  Synopsis:   Init function for previously stored DIFat.
//
//  Arguments:  [cFatSect] -- Length of DIFat in sectors
//
//  Returns:    S_OK if call completed properly.
//
//  Algorithm:  *Finish This*
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDIFat::Init(CMStream * pmsParent, const FSINDEX cFatSect)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::Init(%lu)\n",cFatSect));
    SCODE sc;

    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);
    ULONG cbSector = pmsParent->GetSectorSize();
    _fv.InitCommon(
            (FSOFFSET)(cbSector / sizeof(SECT)),
            (FSOFFSET)((cbSector / sizeof(SECT)) - 1));

    msfChk(_fv.Init(pmsParent, cFatSect));

    _cfsTable = cFatSect;

    msfDebugOut((DEB_ITRACE,"Out CDIFat::Init(%lu)\n",cFatSect));

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::InitNew, public
//
//  Synopsis:   Init function for new DIFat
//
//  Arguments:  [pmsParent] -- Pointer to parent multistream
//
//  Returns:    S_OK if call completed successfully.
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDIFat::InitNew(CMStream *pmsParent)
{
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    ULONG cbSector = pmsParent->GetSectorSize();
    _fv.InitCommon(
            (FSOFFSET)(cbSector / sizeof(SECT)),
            (FSOFFSET)((cbSector / sizeof(SECT)) - 1));
    _fv.Init(pmsParent, 0);
    _cfsTable = 0;
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::InitConvert, public
//
//  Synopsis:   Init function for conversion
//
//  Arguments:  [sectMax] -- Last used sector in existing file
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    02-Jun-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::InitConvert(CMStream *pmsParent, SECT sectMax)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::InitConvert(%lu)\n",sectMax));
    SCODE sc;

    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    USHORT cbSector = pmsParent->GetSectorSize();
    FSOFFSET csectPer = cbSector / sizeof(SECT);

    cbSector = pmsParent->GetSectorSize();
    _fv.InitCommon(cbSector / sizeof(SECT), (cbSector / sizeof(SECT)) - 1);

    FSINDEX csectFat = 0;
    FSINDEX csectFatLast;

    FSINDEX csectDif = 0;
    FSINDEX csectDifLast;
    do
    {
        //Number of fat sectors needed to represent:
        //    Number of Data Sectors (sectMax) +
        //    Number of Fat Sectors (csectFat) +
        //    Number of DIF sectors (csectDif) +
        //    Number of Directory Sectors (1)

        //We must use a loop here, since the fat must be large
        //    enough to represent itself and the DIFat.  See
        //    CFat::InitConvert for a more lengthy discussion of
        //    this method.

        csectFatLast = csectFat;

        csectFat = (sectMax + csectFatLast + csectDif + 1 + csectPer - 1) /
            csectPer;

        csectDifLast = csectDif;

        if (csectFat < CSECTFAT)
        {
            csectDif = 0;
        }
        else
        {
            FSOFFSET ciSect;

            SectToPair(csectFat, &csectDif, &ciSect);
            csectDif++;
        }
    }
    while ((csectDif != csectDifLast) || (csectFat != csectFatLast));


    _cfsTable = csectDif;

    msfChk(_fv.Init(pmsParent, _cfsTable));

    pmsParent->GetHeader()->SetDifLength(_cfsTable);

    if (_cfsTable > 0)
    {
        pmsParent->GetHeader()->SetDifStart(sectMax);

        FSINDEX i;
        for (i = 0; i < _cfsTable; i++)
        {
            CFatSect *pfs;

            msfChk(_fv.GetTable(i, FB_NEW, &pfs));
            _fv.SetSect(i, sectMax);

            sectMax++;
            pfs->SetNextFat(_fv.GetSectTable(),sectMax);
            _fv.ReleaseTable(i);
        }
    }

    msfDebugOut((DEB_ITRACE,"Out CDIFat::InitConvert()\n"));

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::Remap, public
//
//  Synopsis:   Remap a Fat sector for copy-on-write
//
//  Arguments:  [oSect] -- Offset into fat chain to be remapped.
//              [psectReturn] -- pointer to return value
//
//  Returns:    S_OK if call was successful.
//
//  Algorithm:  *Finish This*
//
//  History:    11-May-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::Remap(const FSINDEX oSect, SECT * psectReturn)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::Remap(%lu)\n",oSect));
    SCODE sc = S_OK;

    SECT sectNew;
    SECT sectTemp;
    msfChk(GetFatSect(oSect, &sectTemp));

    msfChk(_pmsParent->GetFat()->QueryRemapped(sectTemp));

    if (sc == S_FALSE)
    {
        msfChk(_pmsParent->GetFat()->GetFree(1, &sectNew, GF_READONLY));
#ifdef DIFAT_LOOKUP_ARRAY
        CacheUnmarkedSect(sectNew, FATSECT, sectTemp);
#endif        

        msfDebugOut((DEB_ITRACE,"Remapping fat sector %lu from %lu to %lu\n",oSect,sectTemp,sectNew));

        msfChk(SetFatSect(oSect, sectNew));
    }
    else
    {
        sectNew = ENDOFCHAIN;
    }
    msfDebugOut((DEB_ITRACE,"In CDIFat::Remap(%lu)=>%lu\n",oSect,sectNew));
    *psectReturn = sectNew;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::RemapSelf, public
//
//  Synopsis:   Remap the entire DIFat for copy-on-write.
//
//  Arguments:  None.
//
//  Returns:    S_OK if DIFat was remapped successfully.
//
//  Algorithm:  *Finish This*
//
//  History:    11-May-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::RemapSelf(VOID)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::RemapSelf()\n"));
    SECT sectNew, sect;
    SCODE sc = S_OK;
    CFatSect *pfs;
    FSINDEX i = 0;

    if (_cfsTable > 0)
    {
        sect = _pmsParent->GetHeader()->GetDifStart();

        msfChk(_fv.GetTable(0, FB_DIRTY, &pfs));
        msfChkTo(Err_Rel0, _pmsParent->GetFat()->GetFree(1, &sectNew, GF_READONLY));

#ifdef DIFAT_LOOKUP_ARRAY
        SECT sectOld;
        sectOld = _pmsParent->GetHeader()->GetDifStart();
        CacheUnmarkedSect(sectNew, DIFSECT, sectOld);
#endif        
        _pmsParent->GetHeader()->SetDifStart(sectNew);

        _fv.SetSect(0, sectNew);

        _fv.ReleaseTable(0);
    }


    for (i = 1; i < _cfsTable; i++)
    {
        CFatSect *pfs2;

        msfChk(_fv.GetTable(i - 1, FB_DIRTY, &pfs));
        msfChkTo(Err_Rel1, _fv.GetTable(i, FB_DIRTY, &pfs2));

        msfChkTo(Err_Rel, _pmsParent->GetFat()->GetFree(
            1,
            &sectNew,
            GF_READONLY));
#ifdef DIFAT_LOOKUP_ARRAY
        SECT sectOld;
        sectOld = pfs->GetNextFat(_fv.GetSectTable());
        CacheUnmarkedSect(sectNew, DIFSECT, sectOld);
#endif        

        pfs->SetNextFat(_fv.GetSectTable(), sectNew);
        _fv.SetSect(i, sectNew);

        _fv.ReleaseTable(i - 1);
        _fv.ReleaseTable(i);
    }
    msfDebugOut((DEB_ITRACE,"In CDIFat::RemapSelf()\n"));

Err:
    return sc;

Err_Rel0:
    _fv.ReleaseTable(0);
    return sc;
Err_Rel:
    _fv.ReleaseTable(i);
Err_Rel1:
    _fv.ReleaseTable(i - 1);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::Resize, private
//
//  Synopsis:   Resize an existing DIFat.
//
//  Arguments:  [fsiSize] -- New size for object
//
//  Returns:    Nothing right now.
//
//  Algorithm:  *Finish This*
//
//  History:    11-May-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::Resize(FSINDEX fsiSize)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::Resize(%lu)\n",fsiSize));
    msfAssert(fsiSize == _cfsTable + 1);

    SCODE sc;

    msfChk(_fv.Resize(fsiSize));
    ULONG ipfs;
    ipfs = fsiSize - 1;

    CFatSect *pfs1;
    msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs1));

    FSINDEX csect;
    csect = _cfsTable;
    _cfsTable = fsiSize;

    SECT sectNew;

#ifdef USE_NOSCRATCH    
    //If we're in no-scratch mode, passing GF_WRITE to the fat here can
    //   cause a nasty loop on Resize().  Do a read-only GetFree in that
    //   case, and don't try to update the fat.

    if ((_pmsParent->HasNoScratch()
#ifdef USE_NOSNAPSHOT         
         ||
         (_pmsParent->GetFat()->GetNoSnapshotFree() != ENDOFCHAIN)
#endif        
        ))
    {
        msfChk(_pmsParent->GetFat()->GetFree(1, &sectNew, GF_READONLY));
#ifdef DIFAT_LOOKUP_ARRAY
        CacheUnmarkedSect(sectNew, DIFSECT, ENDOFCHAIN);
#endif        
    }
    else
    {
#endif        
        msfChk(_pmsParent->GetFat()->GetFree(1, &sectNew, GF_WRITE));
        msfChk(_pmsParent->GetFat()->SetNext(sectNew, DIFSECT));
#ifdef USE_NOSCRATCH        
    }
#endif
    
#if DBG == 1
    STATSTG stat;

    msfHChk(_pmsParent->GetILB()->Stat(&stat, STATFLAG_NONAME));
#ifdef LARGE_DOCFILE
    //msfAssert(
    //        ConvertSectOffset(sectNew + 1, 0, _pmsParent->GetSectorShift()) <=
    //        stat.cbSize.QuadPart);
#else
    //msfAssert(
    //        ConvertSectOffset(sectNew + 1, 0, _pmsParent->GetSectorShift()) <=
    //        ULIGetLow(stat.cbSize));
#endif
#endif

    _fv.SetSect(ipfs, sectNew);
    _fv.ReleaseTable(ipfs);

    if (csect == 0)
    {
        _pmsParent->GetHeader()->SetDifStart(sectNew);
    }
    else
    {
        CFatSect *pfs;
        msfChk(_fv.GetTable(csect - 1, FB_DIRTY, &pfs));

        pfs->SetNextFat(_fv.GetSectTable(),sectNew);
        _fv.ReleaseTable(csect - 1);
    }

    _pmsParent->GetHeader()->SetDifLength(_cfsTable);

    msfDebugOut((DEB_ITRACE,"Out CDIFat::Resize(%lu)\n",fsiSize));

Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDIFat::Lookup, public
//
//  Synopsis:	Lookup a sector and see if it is in the DIFat.  If it
//              is, return FATSECT if it is allocated to a fat sector
//              or DIFSECT if it is allocated to the DIF.
//
//  Arguments:	[sect] -- Sector to look up
//              [psectRet] -- Location for return value
//              [fReadOnly] -- If FALSE, decrement the dirty count
//                              after returning the page.
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	23-Feb-93	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CDIFat::Lookup(const SECT sect, SECT *psectRet)
{
    SCODE sc = S_OK;

    *psectRet = FREESECT;
#ifdef DIFAT_LOOKUP_ARRAY

    if (_cUnmarked <= DIFAT_ARRAY_SIZE)
    {
        for (USHORT iArray = 0; iArray < _cUnmarked; iArray++)
        {
            if (_sectUnmarked[iArray] == sect)
            {
                *psectRet = _sectMarkTo[iArray];
                return S_OK;
            }
        }
        return S_OK;
    }
#endif    

    for (FSINDEX i = 0; i < _pmsParent->GetHeader()->GetDifLength(); i++)
    {
        SECT sectDif;

        msfChk(GetSect(i, &sectDif));
        if (sectDif == sect)
        {
            *psectRet = DIFSECT;
            return S_OK;
        }
    }
#ifdef OPTIMIZE_LOOKUP
    CFatSect *pfs;
    pfs = NULL;
    FSINDEX ipfsLast;
    ipfsLast = (FSOFFSET) -1;
    FSINDEX ipfs = 0;
    FSOFFSET isect;
#endif    
    for (i = 0; i < _pmsParent->GetHeader()->GetFatLength(); i++)
    {
#ifndef OPTIMIZE_LOOKUP
        SECT sectFat;

        msfChk(GetFatSect(i, &sectFat));        
        if (sectFat == sect)
        {
            *psectRet = FATSECT;
            return S_OK;
        }
#else
        SECT sectFat;
        if (i < CSECTFAT)
        {
            sectFat = _pmsParent->GetHeader()->GetFatSect(i);
        }
        else 
        {
            SectToPair(i, &ipfs, &isect);
            if (ipfs != ipfsLast)
            {
                if (pfs != NULL)
                {
                    _fv.ReleaseTable(ipfsLast);
                }
                msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
            }
            sectFat = pfs->GetSect(isect);
            ipfsLast = ipfs;
        }
        if (sect == sectFat)
        {
            if (pfs != NULL)
            {
                _fv.ReleaseTable(ipfs);
            }
            *psectRet = FATSECT;
            return S_OK;
        }
#endif        
    }

#ifdef OPTIMIZE_LOOKUP    
    if (pfs != NULL)
    {
        _fv.ReleaseTable(ipfs);
    }
#endif    
Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDIFat::Fixup, public
//
//  Synopsis:	Fixup the Fat after a copy-on-write commit.
//
//  Arguments:	[pmsShadow] -- Pointer to shadow multistream
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	23-Feb-93	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CDIFat::Fixup(CMStream *pmsShadow)
{
    SCODE sc = S_OK;

    BOOL fChanged;

    CFat *pfat = _pmsParent->GetFat();
#if DBG == 1    
    pfat->CheckFreeCount();
#endif
    
#ifdef DIFAT_LOOKUP_ARRAY
    if (_fDoingFixup)
        return S_OK;

    _fDoingFixup = TRUE;

    if (_cUnmarked <= DIFAT_ARRAY_SIZE)
    {
        for (USHORT iArray = 0;
             (iArray < _cUnmarked) && (_cUnmarked <= DIFAT_ARRAY_SIZE);
             iArray++)
        {
            //sectNew may be out of the range of the current fat.
            //Check and resize if necessary.  This is needed for
            //no-scratch mode.
            FSINDEX ipfs;
            FSOFFSET isect;
            pfat->SectToPair(_sectUnmarked[iArray], &ipfs, &isect);
            if (ipfs >= pfat->GetFatVectorLength())
            {
                msfChk(pfat->Resize(ipfs + 1));
            }

            msfChk(pfat->SetNext(_sectUnmarked[iArray],
                                 _sectMarkTo[iArray]));
            if (_sectFree[iArray] != ENDOFCHAIN)
            {
                msfChk(pfat->SetNext(_sectFree[iArray], FREESECT));
            }
        }
    }

    if (_cUnmarked <= DIFAT_ARRAY_SIZE)
    {
        _cUnmarked = 0;
        pfat->ResetUnmarkedSects();
        _fDoingFixup = FALSE;
        return S_OK;
    }
#endif
    
#ifdef USE_NOSCRATCH    
    if (pmsShadow != NULL)
    {
#endif        
        CDIFat *pdifOld = pmsShadow->GetDIFat();
        FSINDEX cFatOld = pmsShadow->GetHeader()->GetFatLength();
        FSINDEX cDifOld = pmsShadow->GetHeader()->GetDifLength();

        for (FSINDEX i = 0; i < _pmsParent->GetHeader()->GetDifLength(); i++)
        {
            SECT sectNew;
            SECT sectOld = ENDOFCHAIN;
            SECT sectCurrent;

            msfChk(GetSect(i, &sectNew));

            if (i < cDifOld)
                msfChk(pdifOld->GetSect(i, &sectOld));

            if ((sectNew != sectOld) || (sectOld == ENDOFCHAIN))
            {
#ifdef USE_NOSCRATCH                
                //sectNew may be out of the range of the current fat.
                //Check and resize if necessary.
                FSINDEX ipfs;
                FSOFFSET isect;
                pfat->SectToPair(sectNew, &ipfs, &isect);
                if (ipfs >= pfat->GetFatVectorLength())
                {
                    msfChk(pfat->Resize(ipfs + 1));
                }
#endif
                
                msfChk(pfat->GetNext(sectNew, &sectCurrent));
                if (sectCurrent != DIFSECT)
                {
                    msfChk(pfat->SetNext(sectNew, DIFSECT));
                }

                if (sectOld != ENDOFCHAIN)
                {
                    //sectOld should always be within the range of the
                    //fat, so we don't need to check and resize here.
                    msfChk(pfat->GetNext(sectOld, &sectCurrent));
                    if (sectCurrent != FREESECT)
                    {
                        msfChk(pfat->SetNext(sectOld, FREESECT));
                    }
                }
            }
        }


        do
        {
            fChanged = FALSE;
#ifdef OPTIMIZE_FIXUP
            CFatSect *pfs;
            pfs = NULL;
            FSINDEX ipfsLast;
            ipfsLast = (FSOFFSET) - 1;
            FSINDEX ipfs;
            FSOFFSET isect;

            CFatSect *pfsShadow;
            pfsShadow = NULL;
            FSINDEX ipfsLastShadow;
            ipfsLastShadow = (FSOFFSET) - 1;
            FSINDEX ipfsShadow;
            FSOFFSET isectShadow;
            
#endif            
            for (i = 0; i < _pmsParent->GetHeader()->GetFatLength(); i++)
            {
                SECT sectNew;
                SECT sectCurrent;
                SECT sectOld = ENDOFCHAIN;

#ifndef OPTIMIZE_FIXUP                
                msfChk(GetFatSect(i, &sectNew));
#else
                if (i < CSECTFAT)
                {
                    sectNew = _pmsParent->GetHeader()->GetFatSect(i);
                }
                else
                {
                    SectToPair(i, &ipfs, &isect);
                    if (ipfs != ipfsLast)
                    {
                        if (pfs != NULL)
                        {
                            _fv.ReleaseTable(ipfsLast);
                        }
                        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
                    }
                    sectNew = pfs->GetSect(isect);
                    ipfsLast = ipfs;
                }
#endif                

#ifndef OPTIMIZE_FIXUP                
                if (i < cFatOld)
                    msfChk(pdifOld->GetFatSect(i, &sectOld));
#else
                if (i < cFatOld)
                {
                    if (i < CSECTFAT)
                    {
                        sectOld = pmsShadow->GetHeader()->GetFatSect(i);
                    }
                    else
                    {
                        SectToPair(i, &ipfsShadow, &isectShadow);
                        if (ipfsShadow != ipfsLastShadow)
                        {
                            if (pfsShadow != NULL)
                            {
                                pdifOld->_fv.ReleaseTable(ipfsLastShadow);
                            }
                            msfChk(pdifOld->_fv.GetTable(ipfsShadow,
                                                         FB_NONE,
                                                         &pfsShadow));
                        }
                        sectOld = pfsShadow->GetSect(isectShadow);
                        ipfsLastShadow = ipfsShadow;
                    }
                }
#endif                

                if ((sectNew != sectOld) || (sectOld == ENDOFCHAIN))
                {
                    //Sector has been remapped.

#ifdef USE_NOSCRATCH                    
                    //sectNew may be outside the range of the current
                    //fat.  Check and resize if necessary.
                    //If we resize, set fChanged, since we may need to
                    //go through again.

                    FSINDEX ipfs2;
                    FSOFFSET isect2;
                    pfat->SectToPair(sectNew, &ipfs2, &isect2);
                    if (ipfs2 >= pfat->GetFatVectorLength())
                    {
                        msfChk(pfat->Resize(ipfs2 + 1));
                        fChanged = TRUE;
                    }
#endif
                    
                    msfChk(pfat->GetNext(sectNew, &sectCurrent));

                    if (sectCurrent != FATSECT)
                    {
                        msfChk(pfat->SetNext(sectNew, FATSECT));
                        fChanged = TRUE;
                    }

                    if (sectOld != ENDOFCHAIN)
                    {
                        //sectOld is always inside the existing fat,
                        //so we don't need to check and resize.
                        msfChk(pfat->GetNext(sectOld, &sectCurrent));
                        if (sectCurrent != FREESECT)
                        {
                            msfChk(pfat->SetNext(sectOld, FREESECT));
                            fChanged = TRUE;
                        }
                    }
                }
            }
#ifdef OPTIMIZE_FIXUP
            if (pfs != NULL)
                _fv.ReleaseTable(ipfsLast);
            if (pfsShadow != NULL)
                pdifOld->_fv.ReleaseTable(ipfsLastShadow);
#endif            
        }
        while (fChanged);
#ifdef USE_NOSCRATCH        
    }
    else
    {
        //This is for fixing the fat while in overwrite mode with
        //  no-scratch.
        do
        {
            fChanged = FALSE;
            for (FSINDEX i = 0;
                 i < _pmsParent->GetHeader()->GetFatLength();
                 i++)
            {
                SECT sectNew;
                SECT sectCurrent;

                msfChk(GetFatSect(i, &sectNew));
                
                //sectNew may be outside the range of the current fat.  If
                //so, resize the fat.
                FSINDEX ipfs;
                FSOFFSET isect;
                pfat->SectToPair(sectNew, &ipfs, &isect);
                if (ipfs >= pfat->GetFatVectorLength())
                {
                    msfChk(pfat->Resize(ipfs + 1));
                    fChanged = TRUE;
                }
                
                msfChk(pfat->GetNext(sectNew, &sectCurrent));
                if (sectCurrent != FATSECT)
                {
                    msfChk(pfat->SetNext(sectNew, FATSECT));
                    fChanged = TRUE;
                }
            }
        }
        while (fChanged);
    }
#endif        
    pfat->ResetUnmarkedSects();
#ifdef DIFAT_LOOKUP_ARRAY
    _cUnmarked = 0;
#endif    
Err:
#ifdef DIFAT_LOOKUP_ARRAY    
    _fDoingFixup = FALSE;
#endif
#if DBG == 1    
    pfat->CheckFreeCount();
#endif    
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\dirp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	DirP.CXX
//
//  Contents:	Private CDirectory child tree methods
//
//  History:    17-Nov-92 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"
#pragma hdrstop


#include <dirfunc.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::InsertEntry, private
//
//  Synopsis:   insert entry into child tree
//
//  Arguments:  [sidTree] -- storage entry in which to insert entry
//		[sidNew]  -- new entry
//		[pdfnNew] -- new entry name
//
//  Returns:	S_OK, STG_E_FILEALREADYEXISTS, or other error
//
//  Modifies:	sidParent's child tree
//
//  Algorithm:	Search down the binary tree to find the leaf node to which
//		to add the new entry (failing if we find the name already
//		exists).  Along the way we split nodes where needed to keep
//		the tree balanced.
//
//  History:    16-Nov-92 AlexT     Created
//		18-Nov-92 AlexT	    Balanced tree
//
//--------------------------------------------------------------------------

SCODE CDirectory::InsertEntry(
	SID sidTree,
        SID sidNew,
        CDfName const *pdfnNew)
{
    SCODE sc = S_OK;
    SID sidCount = 0;
    const SID sidMax = (_cdsTable+1) * _cdeEntries;

    //  To insert the key and keep the tree balanced, we need to know
    //  the parent, grandparent, and greatgrandparent of the node we're
    //  inserting.

    SID sidChild, sidParent, sidGrandParent, sidGreatGrandParent;
    CDirEntry *pdeParent;
    int iCmp = 0;

    //  When we're ready to insert, sidParent will be the entry to which we
    //  attach sidNew

    sidParent = sidGrandParent = sidGreatGrandParent = sidTree;

    //  Begin the search with the root of the child tree

    msfChk(GetDirEntry(sidTree, FB_NONE, &pdeParent));
    sidChild = pdeParent->GetChild();

    //  Search down the child tree to find the correct leaf entry

    while (sidChild != NOSTREAM)
    {
        //  The sidParent entry has a child along the search path, so we
        //  move down the tree (letting go of sidParent and taking hold of
        //  its child)

        ReleaseEntry(sidParent);

        //  Check to see if we need to split this node (nothing is held)

        do
        {
            SID sidLeft, sidRight;
            BOOL fRed;

            if (++sidCount > sidMax)
                msfChkTo (Err, STG_E_DOCFILECORRUPT);

            {
                CDirEntry *pdeChild;

                msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));

                msfAssert(((sidTree != sidParent) ||
                           (pdeChild->GetColor() == DE_BLACK)) &&
                           aMsg("Dir tree corrupt - root child not black!"));

                sidLeft = pdeChild->GetLeftSib();
                sidRight = pdeChild->GetRightSib();

                ReleaseEntry(sidChild);
            }

            if (sidLeft == NOSTREAM || sidRight == NOSTREAM)
                break;

	        {
                CDirEntry *pdeLeft;

                msfChk(GetDirEntry(sidLeft, FB_NONE, &pdeLeft));
                fRed = (pdeLeft->GetColor() == DE_RED);
                ReleaseEntry(sidLeft);
            }

            if (!fRed)
                break;

            {
                CDirEntry *pdeRight;

		msfChk(GetDirEntry(sidRight, FB_NONE, &pdeRight));
		fRed = (pdeRight->GetColor() == DE_RED);
		ReleaseEntry(sidRight);
            }

            if (fRed)
                msfChk(SplitEntry(pdfnNew, sidTree, sidGreatGrandParent,
			          sidGrandParent, sidParent, sidChild,
                                  &sidChild));
        }
        while (FALSE);

        //

        msfAssert(sidChild != NOSTREAM);

        //  Advance the search

        sidGreatGrandParent = sidGrandParent;
        sidGrandParent = sidParent;
        sidParent = sidChild;

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));

        iCmp = NameCompare(pdfnNew, pdeParent->GetName());

        if (iCmp == 0)
        {
            //  The new name exactly matched an existing name.  Fail.
            msfChkTo(EH_RelParent, STG_E_FILEALREADYEXISTS);
        }

        //  Move down the tree, left or right depending on the comparison

        if (iCmp < 0)
            sidChild = pdeParent->GetLeftSib();
        else
            sidChild = pdeParent->GetRightSib();
    }

    msfAssert(sidChild == NOSTREAM);

    //  We've found the position to insert the new entry.

    //  We're going to dirty sidParent, so we need to change our holding flags
    ReleaseEntry(sidParent);
    msfChk(GetDirEntry(sidParent, FB_DIRTY, &pdeParent));

    if (sidParent == sidTree)
    {
        //  sidParent never made it past sidTree - we must be inserting the
        //  first child into sidTree

        msfAssert(pdeParent->GetChild() == NOSTREAM);

        //  The SplitInsert call below will make sidNew black.
        pdeParent->SetChild(sidNew);
    }
    else
    {
        msfAssert(iCmp != 0);

        //  Use the comparison to determine which side to insert the new entry

        if (iCmp < 0)
        {
            msfAssert(pdeParent->GetLeftSib() == NOSTREAM);
            msfAssert(NameCompare(pdfnNew, pdeParent->GetName()) < 0);

            pdeParent->SetLeftSib(sidNew);
        }
        else
        {
            msfAssert(pdeParent->GetRightSib() == NOSTREAM);
            msfAssert(NameCompare(pdfnNew, pdeParent->GetName()) > 0);

            pdeParent->SetRightSib(sidNew);
        }
    }

EH_RelParent:
    ReleaseEntry(sidParent);

    if (SUCCEEDED(sc))
    {
        SID sidTemp;
        sc = SplitEntry(pdfnNew, sidTree, sidGreatGrandParent, sidGrandParent,
		        sidParent, sidNew, &sidTemp);
    }
Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SplitEntry, private
//
//  Synopsis:   Split 4-node
//
//  Effects:    Passes up red link to parent
//
//  Arguments:  [pdfn]      -- search key
//		[sidTree]   -- child tree sid
//		[sidGreat]  -- greatgrandparent of child to split
//		[sidGrand]  -- grandparent of child to split
//		[sidParent] -- parent of child to split
//		[sidChild]  -- child to split
//		[psid]      -- place holder for tree position
//
//  Returns:	S_OK, or error
//
//  Modifies:	psid, tree
//
//  Algorithm:
//
//  History:    18-Nov-92 AlexT     Created
//
//  Notes:	
//
//--------------------------------------------------------------------------

SCODE CDirectory::SplitEntry(
	CDfName const *pdfn,
        SID sidTree,
        SID sidGreat,
        SID sidGrand,
        SID sidParent,
        SID sidChild,
        SID *psid)
{
    SCODE sc;
    CDirEntry *pdeChild;
    SID sidLeft, sidRight;

    //  pn is a 4-node;  start split by moving red link up

    //  pn->GetLeft()->SetColor(BLACK);

    msfChk(GetDirEntry(sidChild, FB_DIRTY, &pdeChild));
    sidLeft = pdeChild->GetLeftSib();
    sidRight = pdeChild->GetRightSib();

    //  The root must always be black;  new non-root children are red
    pdeChild->SetColor((sidParent == sidTree) ? DE_BLACK : DE_RED);

    ReleaseEntry(sidChild);

    if (sidLeft != NOSTREAM)
    {
        msfChk(SetColorBlack(sidLeft));
    }

    //  pn->GetRight()->SetColor(BLACK);

    if (sidRight != NOSTREAM)
    {
        msfChk(SetColorBlack(sidRight));
    }

    if (sidParent != sidTree)
    {
        CDirEntry *pdeParent;
        BOOL fRedParent;
        int iCmpParent = 0;

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));

        fRedParent = (pdeParent->GetColor() == DE_RED);

        if (fRedParent)
            iCmpParent = NameCompare(pdfn, pdeParent->GetName());

        ReleaseEntry(sidParent);

        //  if (pnp->IsRed())

        if (fRedParent)
        {
            int iCmpGrand;

            //  parent is red - adjacent red links are not allowed

            //  Note - grandparent may be sidTree

            if (sidGrand == sidTree)
            {
                iCmpGrand = 1;
            }
            else
            {
                CDirEntry *pdeGrand;
                msfChk(GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

                iCmpGrand = NameCompare(pdfn, pdeGrand->GetName());

                //  png->SetColor(RED);
                pdeGrand->SetColor(DE_RED);

                ReleaseEntry(sidGrand);
            }

            //  if ((ikey < png->GetKey()) != (ikey < pnp->GetKey()))

            if ((iCmpGrand < 0) != (iCmpParent < 0))
            {
                /*  two cases:
                //
                //    | |
                //    g g
                //   /   \
                //  p     p
                //   \   /
                //    x x
                //
                //  the red links are oriented differently
                */

                //  pn = Rotate(ikey, png);
                msfChk(RotateEntry(pdfn, sidTree, sidGrand, &sidChild));

                /*
                //      | |
                //      g g
                //     /   \
                //    x     x
                //   /       \
                //  p         p
                */
            }

            //  the red links are now oriented the same - we balance the tree
            //  by rotating

            //  pn = Rotate(ikey, pngg);
            msfChk(RotateEntry(pdfn, sidTree, sidGreat, &sidChild));

            //  pn->SetColor(BLACK);
            msfAssert(sidChild != sidTree);
            msfChk(SetColorBlack(sidChild));
        }
    }

    //  return(pn);
    *psid = sidChild;

    //  The first node's link must always be black.
#if DBG == 1
    CDirEntry *pdeTree;
    msfChk(GetDirEntry(sidTree, FB_NONE, &pdeTree));
    sidChild = pdeTree->GetChild();
    ReleaseEntry(sidTree);

    msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));
    msfAssert(pdeChild->GetColor() == DE_BLACK);
    ReleaseEntry(sidChild);
#endif

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::RotateEntry
//
//  Synopsis:   rotation for balancing
//
//  Effects:    rotates localized portion of child tree
//
//  Arguments:  [pdfn] -- search key
//		[sidTree] -- child tree sid
//		[sidParent] -- root of rotation
//		[psid]      -- placeholder for root after rotation
//
//  Returns:    S_OK, or error
//
//  Modifies:   child tree
//
//  Algorithm:
//
//  History:    17-Nov-92 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectory::RotateEntry(
	CDfName const *pdfn,
        SID sidTree,
        SID sidParent,
        SID *psid)
{
    SCODE sc;
    int iCmp;
    //  PNODE pnc, pngc;
    SID sidChild, sidGrand;

    //  find the child

    CDirEntry *pdeParent, *pdeChild, *pdeGrand;
    msfChk(GetDirEntry(sidParent, FB_DIRTY, &pdeParent));

    if (sidParent == sidTree)
    {
        sidChild = pdeParent->GetChild();
    }
    else
    {
        iCmp = NameCompare(pdfn, pdeParent->GetName());

        if (iCmp < 0)
            sidChild = pdeParent->GetLeftSib();
        else
            sidChild = pdeParent->GetRightSib();
    }

    //  find the grandchild

    msfChkTo(EH_RelParent, GetDirEntry(sidChild, FB_DIRTY, &pdeChild));
    msfAssert(sidChild != sidTree);

    iCmp = NameCompare(pdfn, pdeChild->GetName());

    if (iCmp < 0)
    {
        //  pngc = pnc->GetLeft();
        sidGrand = pdeChild->GetLeftSib();

        msfChkTo(EH_RelChild, GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

        /*
        //     |
        //     c
        //    / \
        //   /   \
        //  g     X
        //   \
        //    Y
        */

        //  pnc->SetLeft(pngc->GetRight());
        pdeChild->SetLeftSib(pdeGrand->GetRightSib());

        /*
        //     |
        //     c
        //    / \
        //    |  \
        //  g |   X
        //   \|
        //    Y
        */

        //  pngc->SetRight(pnc);
        pdeGrand->SetRightSib(sidChild);

        /*
        //  g
        //   \
        //    \|
        //     c
        //    / \
        //    |  \
        //    |   X
        //    |
        //    Y
        */
    }
    else
    {
        //  pngc = pnc->GetRight();
        sidGrand = pdeChild->GetRightSib();

        msfChkTo(EH_RelChild, GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

        // pnc->SetRight(pngc->GetLeft());
        pdeChild->SetRightSib(pdeGrand->GetLeftSib());

        // pngc->SetLeft(pnc);
        pdeGrand->SetLeftSib(sidChild);
    }


    //  update parent

    if (sidParent == sidTree)
    {
        //  The root must always be black
        pdeGrand->SetColor(DE_BLACK);
        pdeParent->SetChild(sidGrand);
    }
    else
    {
        iCmp = NameCompare(pdfn, pdeParent->GetName());

        if (iCmp < 0)
        {
            //  pnp->SetLeft(pngc);
            pdeParent->SetLeftSib(sidGrand);
        }
        else
        {
            //  pnp->SetRight(pngc);
            pdeParent->SetRightSib(sidGrand);
        }
    }

    ReleaseEntry(sidGrand);

    /*
    //  |
    //  g
    //   \
    //    \
    //     c
    //    / \
    //    |  \
    //    |   X
    //    |
    //    Y
    */

    //  return(pngc);
    *psid = sidGrand;

EH_RelChild:
    ReleaseEntry(sidChild);

EH_RelParent:
    ReleaseEntry(sidParent);

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::FindEntry, private
//
//  Synopsis:	find entry info based on name (optionally removing it)
//
//  Effects:	find - none, remove - takes entry out of child list
//
//  Arguments:	[sidParent] -- sid of parent entry to search
//		[pdfn]      -- name to search for
//		[deop]      -- entry operation (find or remove)
//		[peb]       -- entry information buffer
//
//  Returns:	S_OK, STG_E_FILENOTFOUND, or other error
//
//  Modifies:	peb
//
//  Algorithm:	To find the entry we search down the binary tree.
//		To remove the entry, we need to patch the tree to keep it
//		as a valid binary tree.
//
//  History:    16-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

SCODE CDirectory::FindEntry(
	SID sidParent,
        CDfName const *pdfn,
        DIRENTRYOP deop,
        SEntryBuffer *peb)
{
    SCODE sc;
    SID sidPrev, sidFind;
    CDirEntry *pdePrev, *pdeFind;
    int iCmp = 0;
    SID sidCount = 0;
    const SID sidMax = (_cdsTable+1) * _cdeEntries;

    //  Once we've found the right child, sidPrev will be that entry's parent
    //  in the child tree

    sidPrev = sidParent;

    //  Begin the search with the root of the child tree

    msfChk(GetDirEntry(sidPrev, FB_NONE, &pdePrev));
    sidFind = pdePrev->GetChild();

    //  sidPrev is held

    for(;;)
    {
        if (++sidCount > sidMax)
            msfChkTo (EH_RelPrev, STG_E_DOCFILECORRUPT);

        if (sidFind == NOSTREAM)
        {
            //  we didn't find the child.  fail.
            sc = STG_E_FILENOTFOUND;
            goto EH_RelPrev;
// Removed this line to supress the debug error print.
//	    msfChkTo(EH_RelPrev, STG_E_FILENOTFOUND);
        }

        msfChkTo(EH_RelPrev, GetDirEntry(sidFind, FB_NONE, &pdeFind));

        //  sidPrev and sidFind are held

        int tmpCmp = NameCompare(pdfn, pdeFind->GetName());

        if (tmpCmp == 0)
        {
            //  We found the entry that matches our search name
            break;
        }

        //  The names did not match.  Advance the search down the tree.
        ReleaseEntry(sidPrev);
        pdePrev = pdeFind;
        sidPrev = sidFind;

        //  sidPrev is held

        //  remember the comparison with sidPrev so we can use it to insert
        //  an entry when we patch the tree

        iCmp = tmpCmp;

        if (iCmp < 0)
            sidFind = pdePrev->GetLeftSib();
        else
            sidFind = pdePrev->GetRightSib();
    }

    msfAssert(sidFind != NOSTREAM);

    //  sidFind is held
    //  sidPrev is held

    msfAssert(NameCompare(pdfn, pdeFind->GetName()) == 0);

    //  fill in entry information

    peb->sid = sidFind;
    peb->dwType = pdeFind->GetFlags();
    peb->luid = DF_NOLUID;

    if (deop == DEOP_REMOVE)
    {
        ReleaseEntry(sidFind);
        ReleaseEntry(sidPrev);

        msfChk(GetDirEntry(sidPrev, FB_DIRTY, &pdePrev));
        msfChkTo(EH_RelPrev, GetDirEntry(sidFind, FB_DIRTY, &pdeFind));

        //  Remove the found child from tree (carefully!).  We remove it by
        //  finding another entry in the tree with which to replace it.
        //    sidFind is the node we're removing
        //    sidPrev is the parent of sidFind in the child tree
        //    sidInsert is the entry which will replace sidFind

        SID sidInsert = pdeFind->GetRightSib();

        if (sidInsert == NOSTREAM)
        {
            //  sidFind has no right child, so we can patch the tree by
            //  replacing sidFind with the sidFind's left child

            sidInsert = pdeFind->GetLeftSib();

            //  set the inserted to the right color
            if (sidInsert != NOSTREAM)
            {
                //  we always set the inserted node to black (since the
                //  parent may not exist (we could be inserting at the
                //  root)
                msfChkTo(EH_RelPrev, SetColorBlack(sidInsert));
            }
        }
        else
        {
            CDirEntry *pdeInsert;

            //  The node we're removing has a right child

            msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_NONE, &pdeInsert));

            //  sidPrev, sidFind, and sidInsert are all held

            if (pdeInsert->GetLeftSib() != NOSTREAM)
            {
                //  sidFind's right child has a left child.
                //  sidInsert will be the leftmost child of sidFind's right
                //    child (which will keep the tree ordered)

                //  sidPreInsert will be the leftmost child's parent int the
                //    child tree

                SID sidPreInsert = sidInsert;
                CDirEntry *pdePreInsert = pdeInsert;

                //  we wait to assign sidInsert so we can clean up
                msfChkTo(EH_RelIns, GetDirEntry(pdePreInsert->GetLeftSib(),
						FB_NONE, &pdeInsert));

                sidInsert = pdePreInsert->GetLeftSib();

                //  sidPrev, sidFind, sidPreInsert, sidInsert are held

                //  find the leftmost child of sidFind's right child

                SID sidLeft;
                while ((sidLeft = pdeInsert->GetLeftSib()) != NOSTREAM)
                {
                    ReleaseEntry(sidPreInsert);

                    //  sidPrev, sidFind, sidInsert are held

                    sidPreInsert = sidInsert;
                    pdePreInsert = pdeInsert;

                    //  we wait to assign sidInsert to we can clean up
                    msfChkTo(EH_RelIns, GetDirEntry(sidLeft,
						    FB_NONE, &pdeInsert));

                    sidInsert = sidLeft;
                }

                msfAssert(pdeInsert->GetLeftSib() == NOSTREAM);

                //  sidPrev, sidFind, sidPreInsert, sidInsert are held

                //  Remove sidInsert so we can reinsert it in place of sidFind.
                //  We remove sidInsert (which has no left child) by making
                //  sidPreInsert's left child point to sidInsert's right child

                ReleaseEntry(sidPreInsert);
                msfChkTo(EH_RelIns, GetDirEntry(sidPreInsert, FB_DIRTY,
				                &pdePreInsert));

                pdePreInsert->SetLeftSib(pdeInsert->GetRightSib());
                ReleaseEntry(sidPreInsert);

                //  sidPrev, sidFind, sidInsert is held

                //  Begin to replace sidFind with sidInsert by setting the
                //  right child of sidInsert to be the right child of sidFind

                ReleaseEntry(sidInsert);
                msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_DIRTY,
						 &pdeInsert));
                pdeInsert->SetRightSib(pdeFind->GetRightSib());
            }
            else
            {
                //  sidFind's right child has no left child, so we can patch
		//  the tree by making sidFind's right child's left child
                //  point to sidFind's left child, and then replacing sidFind
                //  with sidFind's right child.

                ReleaseEntry(sidInsert);
                msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_DIRTY,
				                 &pdeInsert));

                //  fall through to do the work
            }

            pdeInsert->SetColor(DE_BLACK);

            //  Complete sidInsert's patching by setting its left child to be
            //  the left child of sidFind

            pdeInsert->SetLeftSib(pdeFind->GetLeftSib());

EH_RelIns:
            ReleaseEntry(sidInsert);
        }

        if (SUCCEEDED(sc))
        {
            if (sidPrev == sidParent)
            {
                //  We're removing the first child;  update sidParent.
                //  We made sure sidInsert is black (above).
                pdePrev->SetChild(sidInsert);
            }
            else if (iCmp < 0)
            {
                pdePrev->SetLeftSib(sidInsert);
            }
            else
                pdePrev->SetRightSib(sidInsert);

            //  make sure sidFind is clean

            pdeFind->SetLeftSib(NOSTREAM);
            pdeFind->SetRightSib(NOSTREAM);
        }
    }

EH_RelFind:
    ReleaseEntry(sidFind);

EH_RelPrev:
    ReleaseEntry(sidPrev);

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::NameCompare, private static
//
//  Synopsis:   name ordering function for child tree
//
//  Arguments:  [pdfn1] - name 1
//              [pdfn2] - name 2
//
//  Requires:   One but not both names cannot may have zero length.
//
//  Returns:    <0 if name 1 < name 2
//               0 if name 1 = name 2
//              >0 if name 1 > name 2
//
//  Algorithm:  To speed the comparision (and to allow zero length names),
//              we first compare the name lengths.  (Shorter names are "less"
//              than longer names).  If the lengths are equal we compare the
//              strings.
//
//  History:    16-Nov-92 AlexT     Created
//
//
//--------------------------------------------------------------------------

int CDirectory::NameCompare(CDfName const *pdfn1, CDfName const *pdfn2)
{
    int iCmp = pdfn1->GetLength() - pdfn2->GetLength();

    if (iCmp == 0)
    {
        msfAssert(pdfn1->GetLength() != 0);

        iCmp = dfwcsnicmp((WCHAR *)pdfn1->GetBuffer(),
                          (WCHAR *)pdfn2->GetBuffer(),
                          pdfn1->GetLength() / sizeof(WCHAR));
    }

    return(iCmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::SetColorBlack, private
//
//  Synopsis:   Sets a directory entry to black
//
//  Arguments:  [sid] -- SID of entry to be modified
//
//  Returns:    S_OK or error
//
//  History:    19-Jan-93   AlexT       Created.
//
//  Notes:      Added to reduce code size
//
//--------------------------------------------------------------------------

SCODE CDirectory::SetColorBlack(const SID sid)
{
    SCODE sc;

    CDirEntry *pde;
    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetColor(DE_BLACK);
    ReleaseEntry(sid);

 Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\dir.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       dir.cxx
//
//  Contents:   Directory Functions
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//---------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <dirfunc.hxx>
#include <mread.hxx>

#define DEB_DIR (DEB_ITRACE | 0x00040000)

//+-------------------------------------------------------------------------
//
//  Member:     CMStream::KillStream, public
//
//  Synopsis:   Eliminate a given chain
//
//  Arguments:  [sectStart] -- Beginning of chain to eliminate
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    14-Sep-92       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef LARGE_STREAMS
inline SCODE CMStream::KillStream(SECT sectStart, ULONGLONG ulSize)
#else
inline SCODE MSTREAM_CLASS CMStream::KillStream(SECT sectStart, ULONG ulSize)
#endif
{
    CFat *pfat;

#ifndef REF
    pfat = ((!_fIsScratch) && (ulSize < MINISTREAMSIZE)) ? &_fatMini: &_fat;
#else
    pfat = (ulSize < MINISTREAMSIZE) ?&_fatMini: &_fat;
#endif //!REF

    return pfat->SetChainLength(sectStart, 0);
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirEntry::CDirEntry, public
//
//  Synopsis:   Constructor for CDirEntry class
//
//  Effects:
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirEntry::CDirEntry()
{
    msfAssert(sizeof(CDirEntry) == DIRENTRYSIZE);
    Init(STGTY_INVALID);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirSect::Init, public
//
//  Synopsis:   Initializer for directory sectors
//
//  Arguments:  [cdeEntries] -- Number of DirEntries in the sector
//
//  Returns:    S_OK if call completed OK.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              27-Dec-91   PhilipLa    Converted from const to var size
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirSect::Init(USHORT cbSector)
{
    msfDebugOut((DEB_DIR,"Allocating sector with size %u\n",cbSector));

#if WIN32 == 200
    //Make sure to zero out the memory, since Win95 doesn't do it for
    //  you.  NT does, so we don't need to do this there.
    memset(_adeEntry, 0, cbSector);
#endif
    
    DIROFFSET cdeEntries = cbSector / sizeof(CDirEntry);

    for (ULONG i = 0; i < cdeEntries; i++)
    {
        _adeEntry[i].Init(STGTY_INVALID);
    }

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirSect::InitCopy, public
//
//  Synopsis:   CDirSect initializer for copying
//
//  Arguments:  [dsOld] -- Const reference to dir to be copied
//
//  Returns:    S_OK if call completed successfully.
//
//  History:    18-Feb-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirSect::InitCopy(USHORT cbSector,
                                   const CDirSect *pdsOld)
{
    msfDebugOut((DEB_DIR,"In CDirSect copy constructor\n"));

    memcpy(_adeEntry, pdsOld->_adeEntry, cbSector);

    msfDebugOut((DEB_DIR,"Out CDirSect copy constructor\n"));
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::CDirectory
//
//  Synopsis:   Default constructor
//
//  History:    22-Apr-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirectory::CDirectory() 
        : _pmsParent(NULL)
{
    _cdsTable = _cdeEntries = 0;
    _sidFirstFree = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:	CDirectory::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CDirectory::Empty(void)
{
    _dv.Empty();
    _pmsParent = NULL;
    _cdsTable = 0;
    _cdeEntries = 0;
    _sidFirstFree = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::InitCopy, public
//
//  Synopsis:   Init function for copying.
//
//  Arguments:  [dirOld] -- Const reference to dir object to be copied
//
//  History:    18-Feb-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDirectory::InitCopy(CDirectory *pdirOld)
{
    msfDebugOut((DEB_DIR,"In CDirectory copy constructor\n"));

    _pmsParent = pdirOld->_pmsParent;

    _cdeEntries = pdirOld->_cdeEntries;

    _dv.InitCommon(_pmsParent->GetSectorSize());
    _dv.InitCopy(&pdirOld->_dv);
    _cdsTable = pdirOld->_cdsTable;
    _sidFirstFree = pdirOld->_sidFirstFree;

    msfDebugOut((DEB_DIR,"Out CDirectory copy constructor\n"));
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::GetFree, public
//
//  Synposis:   Locates a free directory entry
//
//  Arguments:  None.
//
//  Returns:    Stream ID of free directory entry
//
//  Algorithm:  Do a linear search of all available directories.
//              If no free spot is found, resize the directory and
//              perform the search again.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::GetFree(SID * psid)
{
    msfDebugOut((DEB_DIR,"In CDirectory::GetFree()\n"));

    SCODE sc = S_OK;
    SID sidRet = NOSTREAM;
    CDirSect * pds;

    DIRINDEX ipdsStart;
    DIROFFSET ideStart;

    SidToPair(_sidFirstFree, &ipdsStart, &ideStart);
    while (TRUE)
    {
        for (DIRINDEX ipds = ipdsStart; ipds < _cdsTable; ipds++)
        {
            msfChk(_dv.GetTable(ipds, FB_NONE, &pds));
            for (DIROFFSET ide = ideStart; ide < _cdeEntries; ide++)
            {
                if (pds->GetEntry(ide)->IsFree())
                {
                    msfDebugOut((DEB_ITRACE,"GetFree found sid %lu\n",
                            PairToSid(ipds,ide)));

                    *psid = PairToSid(ipds, ide);
                    _sidFirstFree = *psid + 1;
                    _dv.ReleaseTable(ipds);
                    return S_OK;
                }
            }
            _dv.ReleaseTable(ipds);
            ideStart = 0;
        }
        ipdsStart = ipds;
        msfChk(Resize(_cdsTable+1));
    }

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::FindGreaterEntry
//
//  Synopsis:   finds next entry (for iteration)
//
//  Arguments:  [sidStart]   -- child sid to start looking
//		[pdfn]       -- previous entry name
//		[psidResult] -- place holder for returned sid
//
//  Requires:   sidStart != NOSTREAM
//
//  Returns:    S_OK, STG_E_NOMOREFILES, or other error
//
//  Modifies:   psidResult
//
//  Algorithm:  Iterate by returning the sid that has a name larger
//		than the given name.
//
//  History:    16-Oct-92 AlexT     Created
//
//  Notes:      This method is called recursively
//              When sc != S_OK, *psidReturn contains the recursion count
//              The caller must initialize *psidResult to 0 or SIDROOT
//
//--------------------------------------------------------------------------

SCODE CDirectory::FindGreaterEntry(SID sidStart,
                                   CDfName const *pdfn,
                                   SID *psidResult)
{
    SCODE sc;
    CDirEntry *pde;
    msfAssert(sidStart != NOSTREAM);
    const SID sidMax = (_cdsTable+1) * _cdeEntries;

    if ((*psidResult)++ > sidMax)
        msfErr (Err, STG_E_DOCFILECORRUPT);  // prevent infinite recursion

    msfChk(GetDirEntry(sidStart, FB_NONE, &pde));

    int iCmp;
    iCmp = NameCompare(pdfn, pde->GetName());

    if (iCmp < 0)
    {
        //  Since the last name returned is less than this name,
        //  the sid to return must either be to our left or this sid

        SID sidLeft = pde->GetLeftSib();

        //  We can't hold onto sidStart as we recurse, (because we'll ask for
        //  a page each time we recurse)
        
        ReleaseEntry(sidStart);
        if (sidLeft == sidStart)
        {
            //Corrupt docfile - return error.
            return STG_E_DOCFILECORRUPT;
        }

        if ((sidLeft == NOSTREAM) ||
            (sc = FindGreaterEntry(sidLeft, pdfn, psidResult)) == STG_E_NOMOREFILES)
        {
            //  There was no left child with a name greater than pdfn, so
            //  we return ourself

            *psidResult = sidStart;
            sc = S_OK;
        }
    }
    else
    {
        //  The last name returned is greater than this one, so we've already
        //  returned this sidStart.  Look in the right subtree.

        SID sidRight = pde->GetRightSib();

        //  We can't hold onto sidStart as we recurse, (because we'll ask for
        //  a page each time we recurse)

        ReleaseEntry(sidStart);

        if (sidRight == sidStart)
        {
            //Corrupt docfile - return error.
            return STG_E_DOCFILECORRUPT;
        }
        
        if (sidRight == NOSTREAM)
            sc = STG_E_NOMOREFILES;
        else
            sc = FindGreaterEntry(sidRight, pdfn, psidResult);
    }
Err:
    return(sc);
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::SetStart, public
//
//  Synopsis:   Set starting sector for a dir entry
//
//  Arguments:  [sid] -- SID of entry to be modified
//              [sect] -- New starting sector for entry
//
//  Returns:    SID of modified entry
//
//  History:    18-Feb-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectory::SetStart(const SID sid, const SECT sect)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetStart(sect);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetChild, public
//
//  Synposis:   Set the child SID of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [sidChild] -- SID of first child of this stream
//
//  Returns:    SID of modified entry
//
//  Algorithm:  Change child field on entry, then write to stream.
//
//  History:    24-Sep-91   PhilipLa    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetChild(const SID sid, const SID sidChild)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetChild(sidChild);
    ReleaseEntry(sid);

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetSize, public
//
//  Synposis:   Set the size of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [cbSize] -- Size
//
//  Returns:    SID of modified entry
//
//  Algorithm:  Change size field on entry, then write to stream.
//
//  History:    24-Sep-91   PhilipLa    Created.
//
//---------------------------------------------------------------------------

#ifdef LARGE_STREAMS
SCODE CDirectory::SetSize(const SID sid, const ULONGLONG cbSize)
#else
SCODE CDirectory::SetSize(const SID sid, const ULONG cbSize)
#endif
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetSize(cbSize);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetTime, public
//
//  Synposis:   Set the time of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [tt] - WT_*
//              [nt] - New time
//
//  Returns:    Apropriate status code
//
//  Algorithm:  Change time field on entry, then write to stream.
//
//  History:    24-Sep-91   PhilipLa    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetTime(const SID sid, WHICHTIME tt, TIME_T nt)
{
    SCODE sc;

    CDirEntry *pde;

    // We don't support ACCESS times, so just ignore sets
    if (tt == WT_ACCESS)
        return S_OK;
    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetTime(tt, nt);
    ReleaseEntry(sid);

 Err:
    return sc;
}
//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetAllTimes, public
//
//  Synposis:   Set the times of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [atm] - ACCESS time
//              [mtm] - MODIFICATION time
//				[ctm] - Creation Time
//
//  Returns:    Appropriate Status Code
//
//  Algorithm:  Change time fields on entry, then write to stream.
//
//  History:    24-Nov-95   SusiA    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetAllTimes(const SID sid, 
										TIME_T atm,
										TIME_T mtm,
										TIME_T ctm)
{
    SCODE sc;

    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetAllTimes(atm, mtm, ctm);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetFlags, public
//
//  Synposis:   Set the flags of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [mse] - New flags
//
//  Returns:    Status code
//
//  Algorithm:  Change Luid field on entry, then write to stream.
//
//  History:    08-Oct-92	PhilipLa	Created
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetFlags(const SID sid, const MSENTRYFLAGS mse)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetFlags(mse);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetClassId, public
//
//  Synposis:   Set the class ID of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [cls] - Class ID
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92   DrewB    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetClassId(const SID sid, const GUID cls)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetClassId(cls);
    ReleaseEntry(sid);
 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetUserFlags, public
//
//  Synposis:   Set the user flags of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [dwUserFlags] - Flags
//              [dwMask] - Mask
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92   DrewB    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetUserFlags(SID const sid,
                                        DWORD dwUserFlags,
                                        DWORD dwMask)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetUserFlags(dwUserFlags, dwMask);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::resize, private
//
//  Synposis:   Resize a directory.
//
//  Effects:    Reallocates space for directory table, copying over
//              old pointers as necessary.  Any new tables needed are
//              created here.
//
//  Arguments:  [uNewsize] -- New size for Directory
//
//  Returns:    void
//
//  Algorithm:  Allocate a new array of pointers of the necessary size.
//              Then, copy over all pointers from old array and allocate
//              new CDirSects for all new tables.
//
//  History:    20-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::Resize(DIRINDEX uNewsize)
{
    msfDebugOut((DEB_DIR,"In CDirectory::Resize(%i)\n",uNewsize));
    SCODE sc;

    if (uNewsize == _cdsTable) return S_OK;

    SECT sect1;
    //GetESect call will make sure we have enough Fat space.
    msfChk(_pmsParent->GetESect(SIDDIR, uNewsize - 1, &sect1));

    msfChk(_dv.Resize(uNewsize));

    ULONG ipds;
    for (ipds = _cdsTable; ipds < uNewsize; ipds++)
    {
        CDirSect *pds;
        msfChk(_dv.GetTable(ipds, FB_NEW, &pds));

        SECT sect;
        msfChk(_pmsParent->GetESect(SIDDIR, ipds, &sect));
        _cdsTable = ipds + 1;
        _dv.SetSect(ipds, sect);
        _dv.ReleaseTable(ipds);
    }

    msfChk(_pmsParent->GetHeader()->SetDirLength (_cdsTable));
 Err:
#if DBG == 1
    ULONG cbSect;
    SECT sectStart;

    sectStart = _pmsParent->GetHeader()->GetDirStart();
    _pmsParent->GetFat()->GetLength(sectStart, &cbSect);

    msfAssert((cbSect == _cdsTable) &&
              aMsg("Directory length in FAT does not match cached size."));
#endif    
    
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::Init, public
//
//  Synposis:   Sets up a Directory instance and reads in all tables
//              from the stream
//
//  Arguments:  [cSect] -- Number of sectors in directory
//
//  Returns:    S_OK if call completed OK.
//              STG_E_READFAULT if not enough bytes were read for
//                                  a DirSector
//              Error code of read if read returned an error.
//
//  Algorithm:  Create array to hold appropriate number of tables.
//              Read in each table from disk.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::Init(
        CMStream *pmsParent,
        DIRINDEX cSect)
{
    msfDebugOut((DEB_DIR,"In CDirectory::Init(%lu)\n",cSect));
    SCODE sc;

    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    _cdeEntries = pmsParent->GetSectorSize() / sizeof(CDirEntry);

    _dv.InitCommon(pmsParent->GetSectorSize());
    msfChk(_dv.Init(pmsParent, cSect));

    _cdsTable = cSect;

    msfDebugOut((DEB_DIR,"Out CDirectory::Init()\n"));

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::InitNew, public
//
//  Synposis:   Sets up a new Directory instance for a new Mstream
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//              STG_E_WRITEFAULT if not enough bytes were written.
//              Error code of write if write failed.
//
//  Algorithm:  Write initial DirSector to disk.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::InitNew(CMStream *pmsParent)
{
    SCODE sc;
    CDfName const dfnRoot(wcsRootEntry);

    msfDebugOut((DEB_DIR,"In CDirectory::setupnew()\n"));
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    _cdeEntries = pmsParent->GetSectorSize() / sizeof(CDirEntry);

    _dv.InitCommon(pmsParent->GetSectorSize());
    msfChk(_dv.Init(pmsParent, 1));

    CDirSect *pds;

    msfChk(_dv.GetTable(0, FB_NEW, &pds));
    _dv.SetSect(0, pmsParent->GetHeader()->GetDirStart());
    _dv.ReleaseTable(0);

    _cdsTable = 1;

    SID sidRoot;

    msfChk(GetFree(&sidRoot));
    CDirEntry *pdeTemp;

    msfChk(GetDirEntry(sidRoot, FB_DIRTY, &pdeTemp));
    pdeTemp->Init(STGTY_ROOT);

    msfAssert(sidRoot == SIDROOT);

    pdeTemp->SetName(&dfnRoot);

    ReleaseEntry(sidRoot);

    msfDebugOut((DEB_DIR,"Exiting CDirectory::setupnew()\n"));

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::CreateEntry, public
//
//  Synopsis:   Create a new directory entry
//
//  Arguments:  [sidParent] -- SID of parent for new entry
//		[pwcsName] -- Name of new entry
//		[mef] -- Flags for new entry
//		[psidNew] -- Return location for new SID
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Allocate new entry.
//              Try to insert.
//              If unsuccessful, return new entry to free pool.
//
//  History:    19-Aug-92 	PhilipLa	Created.
//              20-Jul-93   AlexT       Optimized (skip initial search)
//
//--------------------------------------------------------------------------

SCODE CDirectory::CreateEntry(
	SID sidParent,
	CDfName const *pdfn,
	MSENTRYFLAGS mef,
	SID *psidNew)
{
    SCODE sc;
    SID sidNew;
    CDirEntry *pdeNew;

    //  Allocate new sid

    msfChk(GetFree(psidNew));
    sidNew = *psidNew;

    msfChk(GetDirEntry(sidNew, FB_DIRTY, &pdeNew));

    //  Initialize new entry

    pdeNew->Init(mef);

    TIME_T timetemp;
    if (STORAGELIKE(mef))
    {
        if (FAILED(sc = DfGetTOD(&timetemp)))
        {
            ReleaseEntry(sidNew);
            msfErr(Err, sc);
        }
    }
    else
    {
        timetemp.dwLowDateTime = timetemp.dwHighDateTime = 0;
    }

    pdeNew->SetTime(WT_CREATION, timetemp);
    pdeNew->SetTime(WT_MODIFICATION, timetemp);
    pdeNew->SetName(pdfn);

    ReleaseEntry(sidNew);

    //  Insert new entry into the tree

    msfChkTo(EH_Sid, InsertEntry(sidParent, sidNew, pdfn));
    return(sc);

EH_Sid:
    //  We were unable to insert the new entry (most likely because of a
    //  name conflict).  Here we try to return the entry to the free list.
    //  If we can't, the only consequence is that we leak a dir entry on
    //  disk (128 bytes of disk space).

    if (SUCCEEDED(GetDirEntry(sidNew, FB_DIRTY, &pdeNew)))
    {
        pdeNew->SetFlags(STGTY_INVALID);
        ReleaseEntry(sidNew);

        if (sidNew < _sidFirstFree)
        {
            _sidFirstFree = sidNew;
        }
    }

Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::RenameEntry, public
//
//  Synopsis:   Rename an entry
//
//  Arguments:  [sidParent] -- Sid of parent of entry to be renamed
//              [pwcsName] -- Old name of entry to be renamed
//              [pwcsName] -- New name
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Remove old entry
//		Rename entry
//		Insert as new entry
//
//  History:    10-Sep-92    PhilipLa    Created.
//		16-Nov-92    AlexT	 Binary tree structure
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectory::RenameEntry(SID const sidParent,
        CDfName const *pdfn,
        CDfName const *pdfnNew)
{
    //  Make sure new name doesn't already exist
    SCODE sc;
    SEntryBuffer eb;

    sc = IsEntry(sidParent, pdfnNew, &eb);
    if (sc != STG_E_FILENOTFOUND)
    {
        if (SUCCEEDED(sc))
        {
            //  Entry did exist - fail this call
            sc = STG_E_ACCESSDENIED;
        }

        return(sc);
    }

    //  We can't just rename in place (because the tree is ordered)

    CDirEntry *pdeRename;
    SEntryBuffer ebRename;

    msfChk(FindEntry(sidParent, pdfn, DEOP_REMOVE, &ebRename));

    sc = GetDirEntry(ebRename.sid, FB_DIRTY, &pdeRename);

    msfAssert(SUCCEEDED(sc) && aMsg("Could get dir entry to rename"));

    msfChk(sc);

    pdeRename->SetName(pdfnNew);

    ReleaseEntry(ebRename.sid);

    //  If this InsertEntry fails, we've potentially lost the entry. This
    //  doesn't matter becase:
    //  a)  The only way we could fail is if we couldn't read or write
    //      the disk (hard error)
    //  b)  No one's going to call RenameEntry anyways
    //  c)  If we're transacted, the whole operation is made robust by
    //      CopyOnWrite mode
    //  d)  If we're direct, we already know we can fail in ways that leave
    //      the Docfile corrupt.

    sc = InsertEntry(sidParent, ebRename.sid, pdfnNew);

    msfAssert(SUCCEEDED(sc) && aMsg("Couldn't reinsert renamed dir entry"));

    msfChk(sc);

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::DestroyAllChildren
//
//  Synopsis:   destroy all child entries
//
//  Effects:    destroys child tree
//
//  Arguments:  [sidParent] -- storage entry
//
//  Returns:    S_OK or error code
//
//  Modifies:   sidParent's entry
//
//  Algorithm:  While there's a child
//		  destroy it
//
//  History:    16-Nov-92 AlexT     Created
//
//  Notes:	We may want to consider a more efficient implementation
//
//--------------------------------------------------------------------------

SCODE CDirectory::DestroyAllChildren(
	SID const sidParent,
    ULONG ulDepth)
{
    SCODE sc;
    CDirEntry *pdeParent, *pdeChild;
    SID sidChild;
    CDfName dfnChild;
    ULONG ulCount = 0;
    const ULONG ulMax = _cdsTable * _cdeEntries;

    for (;;)
    {
        CDfName dfnChild;

        if (ulCount > ulMax || ulDepth > ulMax)
            msfErr (Err, STG_E_DOCFILECORRUPT);

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));
        sidChild = pdeParent->GetChild();
        ReleaseEntry(sidParent);

        if (sidChild == NOSTREAM)
            break;

        msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));

        dfnChild.Set(pdeChild->GetName());
        ReleaseEntry(sidChild);

        msfChk(DestroyChild(sidParent, &dfnChild, ulDepth + 1));

        ulCount++;
    }

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::DestroyChild
//
//  Synopsis:   destroy a named child
//
//  Effects:    destroys named child's entry
//
//  Arguments:  [sidParent] -- storage entry
//		[pdfn]      -- child name
//
//  Returns:    S_OK, STG_E_FILENOTFOUND, or other error code
//
//  Modifies:   child's entry
//
//  Algorithm:  Find and remove child
//		Free child entry
//
//  History:    16-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

SCODE CDirectory::DestroyChild(
	SID const sidParent,
    CDfName const *pdfn,
    ULONG ulDepth)
{
    SCODE sc;
    SEntryBuffer ebChild;

    msfAssert(pdfn != NULL);

    //  Find the entry

    msfChk(FindEntry(sidParent, pdfn, DEOP_FIND, &ebChild));

    msfAssert(ebChild.sid != NOSTREAM);

    //  Before we remove this entry, we need to destroy it (including all
    //  its children).  Note that we can't hold onto the entry because it
    //  might have children which get destroyed, which have children which
    //  get destroyed, etc.

    if (STORAGELIKE(ebChild.dwType))
    {
        msfChk(DestroyAllChildren(ebChild.sid, ulDepth));
    }

    CDirEntry *pdeChild;
    msfChk(GetDirEntry(ebChild.sid, FB_DIRTY, &pdeChild));

    if (STREAMLIKE(ebChild.dwType))
    {
        //  Deallocate any used streams
        SECT sectStart = pdeChild->GetStart();
        pdeChild->SetStart(ENDOFCHAIN);
#ifdef LARGE_STREAMS
        msfChkTo(EH_Rel, _pmsParent->KillStream(sectStart,
				                pdeChild->GetSize(IsLargeSector())));
#else
        msfChkTo(EH_Rel, _pmsParent->KillStream(sectStart,
                                pdeChild->GetSize()));
#endif
    }

    //  remove the entry from the tree

    msfChkTo(EH_Rel, FindEntry(sidParent, pdfn, DEOP_REMOVE, &ebChild));

    pdeChild->SetFlags(STGTY_INVALID);
    pdeChild->ZeroName();                // zero out the name for security 
    if (ebChild.sid < _sidFirstFree)
    {
        _sidFirstFree = ebChild.sid;
    }

EH_Rel:
    ReleaseEntry(ebChild.sid);

Err:
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::StatEntry
//
//  Synopsis:   For a given handle, fill in the Multistream specific
//                  information of a STATSTG.
//
//  Arguments:  [sid] -- SID that information is requested on.
//              [pib] -- Fast iterator buffer to fill in.
//              [pstatstg] -- STATSTG to fill in.
//
//  Returns:    Appropriate status code
//
//  Algorithm:  Fill in information
//
//  History:    25-Mar-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDirectory::StatEntry(SID const sid,
                                     SIterBuffer *pib,
                                     STATSTGW *pstat)
{
    SCODE sc;
    CDirEntry *pde = NULL;
    size_t cbString = 0;

    msfAssert(pib == NULL || pstat == NULL);

    msfChk(GetDirEntry(sid, FB_NONE, &pde));

    SHORT sLength = pde->GetName()->GetLength();

    // The entry name must be a NULL terminated wide char string
    // or else it can cause an infinite loop in IEnumSTATSTG::Next
    // or overflow the CDfName internal buffer
    //
    if (sLength > CBSTORAGENAME ||
        FAILED(StringCbLength((WCHAR*) pde->GetName()->GetBuffer(),
                              CBSTORAGENAME, &cbString)) ||
        sLength != cbString + sizeof(L'\0'))
        msfErr (EH_Rel, STG_E_DOCFILECORRUPT);

    if (pde->GetFlags() != STGTY_STORAGE && pde->GetFlags() != STGTY_STREAM)
        msfErr (EH_Rel, STG_E_DOCFILECORRUPT);

    if (pib)
    {
        pib->dfnName.Set(pde->GetName());
        pib->type = pde->GetFlags();
    }
    else
    {
        pstat->type = pde->GetFlags();

        msfMemTo(EH_Rel, pstat->pwcsName = (WCHAR *)TaskMemAlloc(sLength));
        memcpy(pstat->pwcsName, pde->GetName()->GetBuffer(), sLength);

        pstat->ctime = pde->GetTime(WT_CREATION);
        pstat->mtime = pde->GetTime(WT_MODIFICATION);
        // Don't currently keep access times
        pstat->atime = pstat->mtime;

        if (pstat->type == STGTY_STORAGE)
        {
            ULISet32(pstat->cbSize, 0);
            pstat->clsid = pde->GetClassId();
            pstat->grfStateBits = pde->GetUserFlags();
        }
        else if (pstat->type == STGTY_STREAM)
        {
#ifdef LARGE_STREAMS
            pstat->cbSize.QuadPart = pde->GetSize(IsLargeSector());
#else
            ULISet32(pstat->cbSize, pde->GetSize());
#endif
            pstat->clsid = CLSID_NULL;
            pstat->grfStateBits = 0;
        }
    }

EH_Rel:    
    ReleaseEntry(sid);
    
Err:
    return sc;
}

#ifdef CHKDSK
//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::InitCorrupted, public
//
//  Synposis:   Sets up a Directory instance and reads in all tables
//              from a corrupted stream.
//
//  Arguments:  [pmsParent] -- Pointer to parent Mstream
//
//  Returns:    S_OK.
//
//  Algorithm:  Determine number of tables needed by querying FAT.
//              Resize array to hold appropriate number of tables.
//              Read in each table from disk.
//              Set parent pointer.
//
//  History:    18-Jul-91   PhilipLa    Created.
//		24-Aug-92   t-chrisy	copied from Init routine
//				force corrupted dir object to instantiate.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::InitCorrupted(DIRINDEX cSect)
{
    msfDebugOut((DEB_DIR,"In CDirectory::setup(%lu)\n",cSect));
    SCODE sc;

    _cdeEntries = _pmsParent->GetSectorSize() / sizeof(CDirEntry);

    _dv.InitCommon(_pmsParent->GetSectorSize());
    sc = _dv.Init(_pmsParent, 1));

    if (FAILED(sc))
        msfDebugOut((DEB_DIR,"Error in CDirVector::Init. Cannot recover\n"));

    _cdsTable = cSect;

    DIRINDEX i;
    for (i = 0; i < cSect; i++)
    {
        ULONG ulRetval;
        CDirEntry *pds;
        msfChk(_dv.GetBlock(i, &pds));
        sc = _pmsParent->ReadSect(SIDDIR,i,pds,ulRetval);
        if (!FAILED(sc))
        {
            if (ulRetval != _pmsParent->GetSectorSize())
                msfDebugOut((DEB_DIR, "STG_E_READFAULT\n"));
        }
    }
    msfDebugOut((DEB_DIR,"Out CDirectory::setup()\n"));
    sc = S_OK;

 Err:
    return sc;
}
#endif

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::GetDirEntry
//
//  Synopsis:   Get a directory entry with given permissions
//
//  Arguments:  [sid]     -- SID
//              [dwFlags] -- permissions
//              [ppde]    -- placeholder for directory entry
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//  History:    ??-???-??    PhilipLa    Created.
//              19-Jan-93    AlexT       Made non-inline for code savings
//
//--------------------------------------------------------------------------

SCODE CDirectory::GetDirEntry(
	const SID sid,
	const DWORD dwFlags,
	CDirEntry **ppde)
{
    SCODE sc;
    CDirSect *pds;
    DIRINDEX id;

    id = sid / _cdeEntries;

    msfChk(_dv.GetTable(id, dwFlags, &pds));

    *ppde = pds->GetEntry((DIROFFSET)(sid % _cdeEntries));

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::ReleaseEntry
//
//  Synopsis:   Releases a directory entry
//
//  Arguments:  [sid]     -- SID
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//  History:    ??-???-??    PhilipLa    Created.
//              19-Jan-93    AlexT       Made non-inline for code savings
//
//--------------------------------------------------------------------------

void CDirectory::ReleaseEntry(SID sid)
{
    _dv.ReleaseTable(sid / _cdeEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\cache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	cache.cxx
//
//  Contents:	Stream cache code
//
//  Classes:	
//
//  Functions:	
//
//  History:	26-May-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <sstream.hxx>
#include <cache.hxx>
#include <mread.hxx>

#if DBG == 1
static ULONG csTotalWalked = 0;
static ULONG csSeqWalked = 0;
static ULONG csRealWalked = 0;
static ULONG cTotalCalls = 0;
#endif


inline SECT CacheStart(SCacheEntry cache)
{
    return cache.sect;
}

inline SECT CacheEnd(SCacheEntry cache)
{
    return cache.sect + cache.ulRunLength - 1;
}

inline ULONG CacheLength(SCacheEntry cache)
{
    return cache.ulRunLength;
}

inline ULONG CacheStartOffset(SCacheEntry cache)
{
    return cache.ulOffset;
}

inline ULONG CacheEndOffset(SCacheEntry cache)
{
    return cache.ulOffset + cache.ulRunLength - 1;
}


        
//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::CheckSegment, private
//
//  Synopsis:	Given a bunch of information, determine if there is
//              a cache hit on a given segment and set return variables
//              to represent best hit.
//
//  Arguments:	[ulOffset] -- Offset being sought.
//              [sce] -- Stream cache entry being checked
//              [pulCount] -- Pointer to count of best hit so far
//              [psectCache] -- Pointer to sect of best hit so far
//              [pulCacheOffset] -- Pointer to offset of best hit so far
//
//  Returns:	TRUE if this is the best hit, FALSE otherwise.
//
//  History:	11-Jul-94	PhilipLa	Created
//
//  Notes:	This function has mega side effects.  Think of it as
//              a typesafe #define.
//
//----------------------------------------------------------------------------

inline BOOL CStreamCache::CheckSegment(ULONG ulOffset,
                         SCacheEntry sce,
                         ULONG *pulCount,
                         SECT *psectCache,
                         ULONG *pulCacheOffset)
{
    if (CacheStartOffset(sce) <= ulOffset)
    {
        //We have a potential cache hit.  Check the runlength to
        //  get the best fit.
        if (ulOffset <= CacheEndOffset(sce))
        {
            //Direct hit.
            *pulCount = 0;
            *pulCacheOffset = ulOffset;
            *psectCache = CacheStart(sce) + (ulOffset - CacheStartOffset(sce));
        }
        else
        {
            if (*pulCount > ulOffset - CacheEndOffset(sce))
            {
                //The requested sector is past the end of the cached
                //  segment.  Use the endpoint as the closest hit.
                *pulCount = ulOffset - CacheEndOffset(sce);
                *psectCache = CacheEnd(sce);
                *pulCacheOffset = CacheEndOffset(sce);
            }
            else
            {
                return FALSE;
            }
        }
        msfAssert(*pulCacheOffset <= ulOffset);
        return TRUE;
    }
    return FALSE;
}


inline CDirectory * CStreamCache::GetDir(void)
{
    return _pmsParent->GetDir();
}

inline CFat * CStreamCache::GetFat(void)
{
    return _pmsParent->GetFat();
}

inline CFat * CStreamCache::GetMiniFat(void)
{
    return _pmsParent->GetMiniFat();
}

#ifdef LARGE_STREAMS
inline ULONGLONG CStreamCache::GetSize(void)
#else
inline ULONG CStreamCache::GetSize(void)
#endif
{
#ifdef LARGE_STREAMS
    ULONGLONG ulSize = 0;
#else
    ULONG ulSize = 0;
#endif
    if (_pds != NULL)
    {
        _pds->CDirectStream::GetSize(&ulSize);
    }
    else
    {
        _pmsParent->GetSize(_sid, &ulSize);
    }
    
    return ulSize;
}

inline SID CStreamCache::GetSid(void)
{
    return _sid;
}



//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::SelectFat, private
//
//  Synopsis:	Returns the appropriate CFat object for the cache.
//              If we are a control structure, then the real fat is
//              always the right one.  Otherwise (we are a real stream)
//              key off of size to determine whether the minifat or
//              the real fat is appropriate.
//
//  Arguments:	None.
//
//  Returns:	Appropriate CFat pointer
//
//  History:	16-Jun-94	PhilipLa	Created
//----------------------------------------------------------------------------

inline CFat * CStreamCache::SelectFat(void)
{
    return ((_pds == NULL) || (GetSize() >= MINISTREAMSIZE) ||
            (GetSid() == SIDMINISTREAM)) ? GetFat() : GetMiniFat();
}


//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::CacheSegment, private
//
//  Synopsis:	Store a segment in the cache.
//
//  Arguments:	[pseg] -- Pointer to segment to store
//
//  Returns:	void
//
//  History:	19-Oct-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CStreamCache::CacheSegment(SSegment *pseg)
{
    USHORT iCache;
    
    if (_uNextCacheIndex >= CACHESIZE)
    {
        _uNextCacheIndex = 0;
    }

    iCache = _uNextCacheIndex;
    _ase[iCache].ulOffset = SegStartOffset(*pseg);
    _ase[iCache].ulRunLength = SegLength(*pseg);
    _ase[iCache].sect = SegStart(*pseg);
    
    _uNextCacheIndex++;
    
    _uHighCacheIndex = (USHORT) max(_uHighCacheIndex, iCache + 1);

    //_uCacheState can be used to determine if the cache has changed.
    _uCacheState++;
}


//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::GetStart, private
//
//  Synopsis:	Get start sector for this chain
//
//  Arguments:	[psectStart] -- Return location
//
//  Returns:	Appropriate status code
//
//  History:	01-Jun-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::GetStart(SECT *psectStart)
{
    SCODE sc = S_OK;

    if (_pds != NULL)
    {
        //We're a normal stream, so get the start sect from the
        //   directory.
        sc = GetDir()->GetStart(_sid, psectStart);
    }
    else
    {
        //We're a control stream, so get the start sect from the
        //   multistream.
        *psectStart = _pmsParent->GetStart(_sid);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::CStreamCache, public
//
//  Synopsis:	CStreamCache constructor
//
//  History:	14-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

CStreamCache::CStreamCache()
{
    _sid = NOSTREAM;
    _pmsParent = NULL;
    _pds = NULL;
    _uHighCacheIndex = 0;
    _uNextCacheIndex = 0;
    _uCacheState = 0;
}

CStreamCache::~CStreamCache()
{
#if DBG == 1
    msfDebugOut((DEB_ITRACE,
    "Cache stats: Total = %lu     Seq = %lu     Real = %lu    Calls = %lu\n",
            csTotalWalked, csSeqWalked, csRealWalked, cTotalCalls));
#endif
}

void CStreamCache::Init(CMStream *pmsParent, SID sid, CDirectStream *pds)
{
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);
    _sid = sid;
    _pds = P_TO_BP(CBasedDirectStreamPtr, pds);
    Empty();
}

void CStreamCache::Empty(void)
{
    for (USHORT uIndex = 0; uIndex < CACHESIZE; uIndex++)
    {
        _ase[uIndex].ulOffset = MAX_ULONG;
        _ase[uIndex].sect = ENDOFCHAIN;
        _ase[uIndex].ulRunLength = 0;
    }

    _uHighCacheIndex = 0;
    _uNextCacheIndex = 0;
    _uCacheState++;
}

//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::GetSect, public
//
//  Synopsis:	Retrieve a SECT from the cache given an offset
//
//  Arguments:	[ulOffset] -- Offset to look up.
//              [psect] -- Location for return value
//
//  Returns:	Appropriate status code
//
//  History:	26-May-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::GetSect(ULONG ulOffset, SECT *psect)
{
    SCODE sc = S_OK;
    CFat *pfat;
    USHORT iCache = 0;
    ULONG ulCount = MAX_ULONG;
    SECT sectCache = ENDOFCHAIN;
    ULONG ulCacheOffset = MAX_ULONG;

    *psect = ENDOFCHAIN;

    pfat = SelectFat();

    for (USHORT iCacheLoop = 0; iCacheLoop < _uHighCacheIndex; iCacheLoop++)
    {
        if (CheckSegment(ulOffset,
                         _ase[iCacheLoop],
                         &ulCount,
                         &sectCache,
                         &ulCacheOffset))
        {
            //Cache hit.
        }
    }

    //We now have the best hit from the cache.  If it is exact, return
    //   now.
    if (ulCount == 0)
    {
        *psect = sectCache;
        return S_OK;
    }

    if (ulCacheOffset == MAX_ULONG)
    {
        //No cache hit.
        msfChk(GetStart(&sectCache));
        ulCacheOffset = 0;
    }

    //Otherwise, go to the fat and get the real thing.
#if DBG == 1 && defined(CHECKLENGTH)
    SECT sectStart;
    ULONG ulLengthOld, ulLengthNew;
    GetStart(&sectStart);
    pfat->GetLength(sectStart, &ulLengthOld);
#endif
    
    SSegment segtab[CSEG + 1];
    ULONG ulSegCount;
    
    while (TRUE)
    {
        msfChk(pfat->Contig(
                segtab,
                FALSE,
                sectCache,
                ulOffset - ulCacheOffset + 1,
                &ulSegCount));

        if (ulSegCount <= CSEG)
        {
            //We're done.
            break;
        }

        //We need to call Contig again.  Update ulCacheOffset and
        //sectCache to be the last sector in the current table.

        ulCacheOffset = ulCacheOffset + SegEndOffset(segtab[CSEG - 1]);
        sectCache = SegEnd(segtab[CSEG - 1]);
    }

    //Last segment is in segtab[ulSegCount - 1].

    //ulSegOffset is the absolute offset within the stream of the first
    //sector in the last segment.
    ULONG ulSegOffset;
    ulSegOffset = ulCacheOffset + SegStartOffset(segtab[ulSegCount - 1]);

    msfAssert(ulSegOffset <= ulOffset);

    msfAssert(ulOffset < ulSegOffset + SegLength(segtab[ulSegCount - 1]));
    
    *psect = SegStart(segtab[ulSegCount - 1]) + (ulOffset - ulSegOffset);

    //Now, stick the last segment into our cache.  We need to update
    //  the ulOffset field to be the absolute offset (i.e. ulSegOffset)
    //  before calling CacheSegment().

    segtab[ulSegCount - 1].ulOffset = ulSegOffset;
    CacheSegment(&(segtab[ulSegCount - 1]));
    
#if DBG == 1 && defined(CHECKLENGTH)
    //Confirm that the chain hasn't grown.
    pfat->GetLength(sectStart, &ulLengthNew);
    msfAssert(ulLengthOld == ulLengthNew);
    
    //Confirm that we're getting the right sector.
    SECT sectCheck;
        
    pfat->GetSect(sectStart, ulOffset, &sectCheck);

    msfAssert(*psect == sectCheck);
#endif
    
 Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::GetESect, public
//
//  Synopsis:	Retrieve a SECT from the cache given an offset, extending
//              the stream if necessary.
//
//  Arguments:	[ulOffset] -- Offset to look up.
//              [psect] -- Location for return value
//
//  Returns:	Appropriate status code
//
//  History:	26-May-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::GetESect(ULONG ulOffset, SECT *psect)
{
    SCODE sc = S_OK;
    CFat *pfat;
    USHORT iCache = 0;
    ULONG ulCount = MAX_ULONG;
    SECT sectCache = ENDOFCHAIN;
    ULONG ulCacheOffset = MAX_ULONG;
    USHORT uCacheHit = CACHESIZE + 1;
    
    *psect = ENDOFCHAIN;

    pfat = SelectFat();

    for (USHORT iCacheLoop = 0; iCacheLoop < _uHighCacheIndex; iCacheLoop++)
    {
        if (CheckSegment(ulOffset,
                         _ase[iCacheLoop],
                         &ulCount,
                         &sectCache,
                         &ulCacheOffset))
        {
            uCacheHit = iCacheLoop;
            //Cache hit.
        }
    }

    //We now have the best hit from the cache.  If it is exact, return
    //   now.
    if (ulCount == 0)
    {
        *psect = sectCache;
        return S_OK;
    }

    if (ulCacheOffset == MAX_ULONG)
    {
        //No cache hit.
        msfChk(GetStart(&sectCache));
        ulCacheOffset = 0;
    }
    
    //Otherwise, go to the fat and get the real thing.

    SSegment segtab[CSEG + 1];
    ULONG ulSegCount;
    
    while (TRUE)
    {
        msfChk(pfat->Contig(
                segtab,
                TRUE,
                sectCache,
                ulOffset - ulCacheOffset + 1,
                &ulSegCount));

        if (ulSegCount <= CSEG)
        {
            //We're done.
            break;
        }

        //We need to call Contig again.  Update ulCacheOffset and
        //sectCache to be the last sector in the current table.

        ulCacheOffset = ulCacheOffset + SegEndOffset(segtab[CSEG - 1]);
        sectCache = SegEnd(segtab[CSEG - 1]);
    }

    //Last segment is in segtab[ulSegCount - 1].

    //ulSegOffset is the absolute offset within the stream of the first
    //sector in the last segment.
    ULONG ulSegOffset;
    ulSegOffset = ulCacheOffset + SegStartOffset(segtab[ulSegCount - 1]);

    msfAssert(ulSegOffset <= ulOffset);

    msfAssert(ulOffset < ulSegOffset + SegLength(segtab[ulSegCount - 1]));
    
    *psect = SegStart(segtab[ulSegCount - 1]) + (ulOffset - ulSegOffset);
    segtab[ulSegCount - 1].ulOffset = ulSegOffset;
    
    //If we grew the chain with this call, we may need to merge the
    //   new segment with the previous best-hit in our cache.
    //   Otherwise, we end up with excessive fragmentation.

    if ((uCacheHit != CACHESIZE + 1) &&
        (SegStart(segtab[ulSegCount - 1]) <= CacheEnd(_ase[uCacheHit]) + 1) &&
        (SegStart(segtab[ulSegCount - 1]) > CacheStart(_ase[uCacheHit])) &&
        (SegStartOffset(segtab[ulSegCount - 1]) <=
         CacheEndOffset(_ase[uCacheHit]) + 1))
    {
        //We can merge the two.
        _ase[uCacheHit].ulRunLength += (SegLength(segtab[ulSegCount - 1]) -
            (CacheEnd(_ase[uCacheHit]) + 1 -
             SegStart(segtab[ulSegCount - 1])));

        _uCacheState++;
    }
    else
    {        
        //Now, stick the last segment into our cache.  We need to update
        //  the ulOffset field to be the absolute offset (i.e. ulSegOffset)
        //  before calling CacheSegment().
        CacheSegment(&(segtab[ulSegCount - 1]));
    }
    
#if DBG == 1
    //Confirm that we're getting the right sector.
    SECT sectCheck;
    SECT sectStart;
        
    msfChk(GetStart(&sectStart));

    pfat->GetESect(sectStart, ulOffset, &sectCheck);

    msfAssert(*psect == sectCheck);
#endif

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::EmptyRegion, public
//
//  Synopsis:	Invalidate cached values for a segment that has been
//              remapped
//
//  Arguments:	[oStart] -- Offset marking first remapped sector
//              [oEnd] -- Offset marking last remapped sector
//
//  Returns:	Appropriate status code
//
//  History:	26-May-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::EmptyRegion(ULONG oStart, ULONG oEnd)
{
    for (USHORT i = 0; i < CACHESIZE; i ++)
    {
        ULONG ulStart = CacheStartOffset(_ase[i]);
        ULONG ulEnd = CacheEndOffset(_ase[i]);
        
        if ((ulStart <= oEnd) && (ulEnd >= oStart))
        {
            //There are 3 possible cases:
            //  1)  The cache entry is completely contained in the
            //        region being invalidated.
            //  2)  The front part of the cache entry is contained in
            //        the region being invalidated.
            //  3)  The tail part of the cache entry is contained in
            //        the region being validated.

            if ((oStart <= ulStart) && (oEnd >= ulEnd))
            {
                //Invalidate the entire thing.
                _ase[i].ulOffset = MAX_ULONG;
                _ase[i].sect = ENDOFCHAIN;
                _ase[i].ulRunLength = 0;
            }
            else if (oStart <= ulStart)
            {
#if DBG == 1
                ULONG ulCacheStart = _ase[i].ulOffset;
                SECT sectCache = _ase[i].sect;
                ULONG ulCacheLength = _ase[i].ulRunLength;
#endif
                //Invalidate the front of the cache entry
                ULONG ulInvalid;
                
                ulInvalid = oEnd - ulStart + 1;

                _ase[i].ulOffset += ulInvalid;
                
                msfAssert(_ase[i].ulRunLength > ulInvalid);
                _ase[i].sect += ulInvalid;
                
                _ase[i].ulRunLength -= ulInvalid;
#if DBG == 1
                //Make sure our cache is still within the old valid range.
                msfAssert((_ase[i].ulOffset >= ulCacheStart) &&
                          (_ase[i].ulOffset <=
                           ulCacheStart + ulCacheLength - 1));
                msfAssert(_ase[i].ulRunLength <= ulCacheLength);
                msfAssert(_ase[i].ulRunLength > 0);
                msfAssert((_ase[i].sect >= sectCache) &&
                          (_ase[i].sect <= sectCache + ulCacheLength - 1));
#endif
            }
            else
            {
#if DBG == 1
                ULONG ulCacheStart = _ase[i].ulOffset;
                SECT sectCache = _ase[i].sect;
                ULONG ulCacheLength = _ase[i].ulRunLength;
#endif
                //Invalidate the tail of the cache entry
                ULONG ulInvalid;
                ulInvalid = ulEnd - oStart + 1;
                msfAssert(_ase[i].ulRunLength > ulInvalid);
                _ase[i].ulRunLength -= ulInvalid;
#if DBG == 1
                //Make sure our cache is still within the old valid range.
                msfAssert((_ase[i].ulOffset >= ulCacheStart) &&
                          (_ase[i].ulOffset <=
                           ulCacheStart + ulCacheLength - 1));
                msfAssert(_ase[i].ulRunLength <= ulCacheLength);
                msfAssert(_ase[i].ulRunLength > 0);
                msfAssert((_ase[i].sect >= sectCache) &&
                          (_ase[i].sect <= sectCache + ulCacheLength - 1));
#endif
            }
            _uCacheState++;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::Contig, public
//
//  Synopsis:	Return a contig table from a given offset and runlength
//
//  Arguments:	[ulOffset] -- Offset to begin contiguity check at
//              [fWrite] -- TRUE if segment is to be written to.
//              [aseg] -- Pointer to SSegment array
//              [ulLength] -- Run length of sectors to return table for
//
//  Returns:	Appropriate status code
//
//  History:	21-Apr-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::Contig(
        ULONG ulOffset,
        BOOL fWrite,
        SSegment STACKBASED *aseg,
        ULONG ulLength,
        ULONG *pcSeg)
{
    SCODE sc;
    msfDebugOut((DEB_ITRACE, "In  CStreamCache::Contig:%p()\n", this));
    SECT sect;
    USHORT uCacheState;
    
    CFat *pfat;

    for (USHORT iCache = 0; iCache < _uHighCacheIndex; iCache++)
    {
        //Look for direct hit.
        if ((ulOffset >= _ase[iCache].ulOffset) &&
            (ulOffset < _ase[iCache].ulOffset + _ase[iCache].ulRunLength))
        {
            //Direct hit.  Return this segment.
            ULONG ulCacheOffset = ulOffset - _ase[iCache].ulOffset;
            
            aseg[0].ulOffset = ulOffset;
            aseg[0].sectStart = _ase[iCache].sect + ulCacheOffset;
            aseg[0].cSect = _ase[iCache].ulRunLength - ulCacheOffset;
            *pcSeg = 1;
            return S_OK;
        }
    }

    uCacheState = _uCacheState;
    if (fWrite)
    {
        //This can grow the chain, so get the whole thing at once
        //  instead of one sector at a time.  Chances are good that
        //  the second GetESect call will be fed from the cache, so
        //  this won't be too expensive in the common case.
        //Ideally, we'd like to make this first call only when we
        //  know the stream is growing.  There isn't a convenient
        //  way to detect that here, though.
        msfChk(GetESect(ulOffset + ulLength - 1, &sect));
        msfChk(GetESect(ulOffset, &sect));
    }
    else
    {
        msfChk(GetSect(ulOffset, &sect));
    }

    //The GetSect() or GetESect() call may have actually snagged the
    //  segment we need, so check the cache again.  If _uCacheState
    //  changed in the duration of the call, we know that something
    //  new is in the cache, so we go look again.
    if (uCacheState != _uCacheState)
    {
        for (USHORT iCache = 0; iCache < _uHighCacheIndex; iCache++)
        {
            //Look for direct hit.
            if ((ulOffset >= _ase[iCache].ulOffset) &&
                (ulOffset < _ase[iCache].ulOffset + _ase[iCache].ulRunLength))
            {
                //Direct hit.  Return this segment.
                ULONG ulCacheOffset = ulOffset - _ase[iCache].ulOffset;
            
                aseg[0].ulOffset = ulOffset;
                aseg[0].sectStart = _ase[iCache].sect + ulCacheOffset;
                aseg[0].cSect = _ase[iCache].ulRunLength - ulCacheOffset;
                *pcSeg = 1;
                return S_OK;
            }
        }
    }

    pfat = SelectFat();
    msfChk(pfat->Contig(aseg, fWrite, sect, ulLength, pcSeg));

    //At this point, we can peek at the contig table and pick out
    //  the choice entries to put in the cache.
    
    //For the first pass, we just grab the last thing in the Contig
    //table and cache it.
    aseg[*pcSeg - 1].ulOffset += ulOffset;
    CacheSegment(&(aseg[*pcSeg - 1]));
    
 Err:    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::Allocate, public
//
//  Synopsis:	Allocate a new chain for a stream, returning the start
//              sector and caching the appropriate amount of contig
//              information.
//
//  Arguments:	[pfat] -- Pointer to fat to allocate in
//              [cSect] -- Number of sectors to allocate
//              [psectStart] -- Returns starts sector for chain
//
//  Returns:	Appropriate status code
//
//  History:	19-Oct-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::Allocate(CFat *pfat, ULONG cSect, SECT *psectStart)
{
    SCODE sc;

    msfAssert((_uHighCacheIndex == 0) &&
              aMsg("Called Allocate with non-empty buffer"));

#ifndef CACHE_ALLOCATE_OPTIMIZATION
    //This will allocate the complete requested chain.  We'll then
    //  walk over that chain again in the Contig() call, which isn't
    //  optimal.  Ideally, we'd like GetFree() to return us the
    //  contiguity information, but that's a fairly major change.
    //  Consider it for future optimization work.
    msfChk(pfat->GetFree(cSect, psectStart, GF_WRITE));
#else
    //Get the first sector (to simplify Contig code)

    //First reserve enough free sectors for the whole thing.
    msfChk(pfat->ReserveSects(cSect));
    msfChk(pfat->GetFree(1, psectStart, GF_WRITE));
#endif    

    SSegment segtab[CSEG + 1];
    ULONG ulSegCount;
    ULONG ulSegStart;
    SECT sectSegStart;

    sectSegStart = *psectStart;
    ulSegStart = 0;
    
    while (TRUE)
    {
        msfChk(pfat->Contig(
                segtab,
                TRUE,
                sectSegStart,
                cSect - ulSegStart,
                &ulSegCount));

        if (ulSegCount <= CSEG)
        {
            //We're done.
            break;
        }

        //We need to call Contig again.  Update ulSegStart and
        //sectSegStart to be the last sector in the current table.

        ulSegStart = ulSegStart + SegEndOffset(segtab[CSEG - 1]);
        sectSegStart = SegEnd(segtab[CSEG - 1]);
    }

    //Last segment is in segtab[ulSegCount - 1].

    //ulSegOffset is the absolute offset within the stream of the first
    //sector in the last segment.
    ULONG ulSegOffset;
    ulSegOffset = ulSegStart + SegStartOffset(segtab[ulSegCount - 1]);

    //Now, stick the last segment into our cache.  We need to update
    //  the ulOffset field to be the absolute offset (i.e. ulSegOffset)
    //  before calling CacheSegment().

    segtab[ulSegCount - 1].ulOffset = ulSegOffset;
    CacheSegment(&(segtab[ulSegCount - 1]));

#if DBG == 1 && defined(CHECKLENGTH)
    ULONG ulLength;

    pfat->GetLength(*psectStart, &ulLength);
    msfAssert(ulLength == cSect);
#endif
 Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\exp\storage.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       storage.cxx
//
//  Contents:   Contains generic storage APIs
//
//  History:    05-Oct-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <dfentry.hxx>
#include <storagep.h>
#include <logfile.hxx>
#include <df32.hxx>
#ifdef COORD
#include <oledb.h>
#endif //COORD

#include <trace.hxx>

#include <ole2sp.h>


//+--------------------------------------------------------------
//
//  Function:   StgOpenStorage, public
//
//  Synopsis:   Instantiates a root storage from a file
//              by binding to the appropriate implementation
//              and starting things up
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority mode reopen IStorage
//              [grfMode] - Permissions
//              [snbExclude] - Exclusions for priority reopen
//              [reserved]
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    05-Oct-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI StgOpenStorage(OLECHAR const *pwcsName,
                      IStorage *pstgPriority,
                      DWORD grfMode,
                      SNB snbExclude,
                      LPSTGSECURITY reserved,
                      IStorage **ppstgOpen)
{
    return DfOpenDocfile(pwcsName, NULL, pstgPriority, grfMode,
                         snbExclude, reserved, NULL, 0, ppstgOpen);
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckSignature, private
//
//  Synopsis:   Checks the given memory against known signatures
//
//  Arguments:  [pb] - Pointer to memory to check
//
//  Returns:    S_OK - Current signature
//              S_FALSE - Beta 2 signature, but still successful
//              Appropriate status code
//
//  History:    23-Jul-93       DrewB   Created from header.cxx code
//
//----------------------------------------------------------------------------

//Identifier for first bytes of Beta 1 Docfiles
const BYTE SIGSTG_B1[] = {0xd0, 0xcf, 0x11, 0xe0, 0x0e, 0x11, 0xfc, 0x0d};
const USHORT CBSIGSTG_B1 = sizeof(SIGSTG_B1);

//Identifier for first bytes of Beta 2 Docfiles
const BYTE SIGSTG_B2[] = {0x0e, 0x11, 0xfc, 0x0d, 0xd0, 0xcf, 0x11, 0xe0};
const BYTE CBSIGSTG_B2 = sizeof(SIGSTG_B2);

SCODE CheckSignature(BYTE *pb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CheckSignature(%p)\n", pb));

    // Check for ship Docfile signature first
    if (memcmp(pb, SIGSTG, CBSIGSTG) == 0)
        sc = S_OK;

    // Check for Beta 2 Docfile signature
    else if (memcmp(pb, SIGSTG_B2, CBSIGSTG_B2) == 0)
        sc = S_FALSE;

    // Check for Beta 1 Docfile signature
    else if (memcmp(pb, SIGSTG_B1, CBSIGSTG_B1) == 0)
        sc = STG_E_OLDFORMAT;
    else
        sc = STG_E_INVALIDHEADER;

    olDebugOut((DEB_ITRACE, "Out CheckSignature => %lX\n", sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   StgIsStorageFileHandle, private
//
//  Synopsis:   Determines whether a handle is open on a storage file.
//              Spun off from StgIsStorageFile.  Internaly we use this
//
//  Arguments:  [hf] - Open File Handle (caller must seek it to 0)
//
//  Returns:    S_OK, S_FALSE or error codes
//
//  History:    07-May-98   MikeHill   Created
//              05-June-98  BChapman   Return Errors not just S_FALSE.
//                                     Add optional Overlapped pointer.
//
//---------------------------------------------------------------


STDAPI StgIsStorageFileHandle( HANDLE hf, LPOVERLAPPED povlp )
{
    DWORD cbRead;
    BYTE stgHeader[sizeof(SStorageFile)];
    SCODE sc;
    LONG status;
    OVERLAPPED ovlp;

    FillMemory( stgHeader, sizeof(SStorageFile), 0xDE );

    if (povlp == NULL)
    {
    ovlp.Offset = 0;
    ovlp.OffsetHigh = 0;
    ovlp.hEvent = NULL;
    }

    if( !ReadFile( hf,
           stgHeader,
           sizeof( stgHeader ),
           &cbRead,
           (povlp == NULL) ? &ovlp : povlp ) )
    {
        if( NULL != povlp )
        {
            status = GetLastError();
            if( ERROR_IO_PENDING == status)
            {
                status = ERROR_SUCCESS;
                if( !GetOverlappedResult( hf, povlp, &cbRead, TRUE ) )
                    status = GetLastError();
            }
            if(ERROR_SUCCESS != status && ERROR_HANDLE_EOF != status)
                olChk( HRESULT_FROM_WIN32( status ) );
        }
        else
            olErr( EH_Err, S_FALSE );
    }

    // Don't worry about short reads.  If the read is short then
    // the signature checks will fail.

    sc = CheckSignature( ((SStorageFile*)stgHeader)->abSig );
    if(S_OK == sc)
        goto EH_Err;    // Done, return "Yes"

    olChk(sc);

    // It didn't error.  sc != S_OK then it
    // Must be S_FALSE.
    olAssert(S_FALSE == sc);

EH_Err:
    if( (STG_E_OLDFORMAT == sc) || (STG_E_INVALIDHEADER == sc) )
        sc = S_FALSE;

    return sc;
}


//+--------------------------------------------------------------
//
//  Function:   StgIsStorageFile, public
//
//  Synopsis:   Determines whether the named file is a storage or not
//
//  Arguments:  [pwcsName] - Filename
//
//  Returns:    S_OK, S_FALSE or error codes
//
//  History:    05-Oct-92       DrewB   Created
//
//---------------------------------------------------------------


STDAPI StgIsStorageFile(OLECHAR const *pwcsName)
{
    HANDLE hf;
    SCODE sc;

    olLog(("--------::In  StgIsStorageFile(" OLEFMT ")\n", pwcsName));

    TRY
    {
#ifndef OLEWIDECHAR
        if (FAILED(sc = ValidateNameA(pwcsName, _MAX_PATH)))
#else
        if (FAILED(sc = ValidateNameW(pwcsName, _MAX_PATH)))
#endif
            return ResultFromScode(sc);

#if !defined(UNICODE)

    // Chicago - call ANSI CreateFile

    char szName[_MAX_PATH + 1];

    if (!WideCharToMultiByte(
            AreFileApisANSI() ? CP_ACP : CP_OEMCP,
            0,
            pwcsName,
            -1,
            szName,
            _MAX_PATH + 1,
            NULL,
            NULL))
        return ResultFromScode(STG_E_INVALIDNAME);

    hf = CreateFileA (
            szName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

#else

        hf = CreateFile (
            pwcsName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
#endif // !defined(UNICODE)

        if (hf == INVALID_HANDLE_VALUE)
            return ResultFromScode(STG_SCODE(GetLastError()));

        sc = StgIsStorageFileHandle( hf, NULL );
        CloseHandle (hf);

    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    olLog(("--------::Out StgIsStorageFile().  ret == %lx\n", sc));

    return(ResultFromScode(sc));
}

//+--------------------------------------------------------------
//
//  Function:   StgIsStorageILockBytes, public
//
//  Synopsis:   Determines whether the ILockBytes is a storage or not
//
//  Arguments:  [plkbyt] - The ILockBytes
//
//  Returns:    S_OK, S_FALSE or error codes
//
//  History:    05-Oct-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI StgIsStorageILockBytes(ILockBytes *plkbyt)
{
    OLETRACEIN((API_StgIsStorageILockBytes, PARAMFMT("plkbyt= %p"), plkbyt));

    HRESULT hr;
    SCODE sc;
    SStorageFile stgfile;
    ULONG cbRead;
    ULARGE_INTEGER ulOffset;

    TRY
    {
        if (FAILED(sc = ValidateInterface(plkbyt, IID_ILockBytes)))
        {
            hr = ResultFromScode(sc);
            goto errRtn;
        }
        ULISet32(ulOffset, 0);
        hr = plkbyt->ReadAt(ulOffset, &stgfile, sizeof(stgfile), &cbRead);
        if (FAILED(GetScode(hr)))
        {
            goto errRtn;
        }
    }
    CATCH(CException, e)
    {
        hr = ResultFromScode(e.GetErrorCode());
        goto errRtn;
    }
    END_CATCH

    if (cbRead == sizeof(stgfile))
    {
        if ((memcmp((void *)stgfile.abSig, SIGSTG, CBSIGSTG) == 0) ||
            (memcmp((void *)stgfile.abSig, SIGSTG_B2, CBSIGSTG_B2) == 0))
        {
            hr = ResultFromScode(S_OK);
            goto errRtn;
        }
    }

    hr = ResultFromScode(S_FALSE);

errRtn:
    OLETRACEOUT((API_StgIsStorageILockBytes, hr));

    return hr;
}

//+--------------------------------------------------------------
//
//  Function:   StgSetTimes
//
//  Synopsis:   Sets file time stamps
//
//  Arguments:  [lpszName] - Name
//              [pctime] - create time
//              [patime] - access time
//              [pmtime] - modify time
//
//  Returns:    Appropriate status code
//
//  History:    05-Oct-92       AlexT   Created
//
//---------------------------------------------------------------

STDAPI StgSetTimes(OLECHAR const *lpszName,
                   FILETIME const *pctime,
                   FILETIME const *patime,
                   FILETIME const *pmtime)
{
    SCODE sc;
    HANDLE hFile;

    TRY
    {
#ifndef OLEWIDECHAR
        sc = ValidateNameA(lpszName, _MAX_PATH);
#else
        sc = ValidateNameW(lpszName, _MAX_PATH);
#endif
        if (SUCCEEDED(sc))
        {
#if !defined(UNICODE) && defined(OLEWIDECHAR)
            //Chicago - call ANSI CreateFile
            char szName[_MAX_PATH];

            if (!WideCharToMultiByte(
                    AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                    0,
                    lpszName,
                    -1,
                    szName,
                    _MAX_PATH,
                    NULL,
                    NULL))
                return ResultFromScode(STG_E_INVALIDNAME);
            hFile = CreateFileA(szName, GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                               NULL);
#else
            hFile = CreateFile(lpszName, GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
#endif
            if (hFile == INVALID_HANDLE_VALUE)
                sc = LAST_STG_SCODE;
            else
            {
                if (!SetFileTime(hFile, (FILETIME *)pctime, (FILETIME *)patime,
                                 (FILETIME *)pmtime))
                    sc = LAST_STG_SCODE;
                CloseHandle(hFile);
            }
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    return ResultFromScode(sc);
}


#if DBG==1
extern "C" unsigned long filestInfoLevel; //  File I/O layer of Docfile
extern "C" unsigned long nffInfoLevel;    //  NTFS Flat File
extern ULONG GetInfoLevel(CHAR *pszKey, ULONG *pulValue, CHAR *pszdefval);

void
StgDebugInit()
{
    GetInfoLevel("filest", &filestInfoLevel, "0x0003");
    GetInfoLevel(   "nff", &nffInfoLevel,    "0x0003");
}

#endif // DBG==1


//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer, public
//
//  Returns:    Appropriate status code
//
//  History:    15-jan-98       BChpaman   Created
//
//----------------------------------------------------------------------------

STDAPI Storage32DllRegisterServer(void)
{
    HRESULT hrAccum=S_OK;

    return hrAccum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\msfhead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:   msfhead.cxx
//
//  Contents:   Precompiled headers
//
//  History:    23-Oct-92 AlexT    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
}

#include <ole2.h>

#include <propset.h>
#include <propapi.h>
#include <propstm.hxx>

#include <dfexcept.hxx>
#include <msf.hxx>
#include <header.hxx>
#include <vect.hxx>
#include <page.hxx>
#include <vectfunc.hxx>
#include <fat.hxx>
#include <dir.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\dl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       dl.cxx
//
//  Contents:   Delta list code for streams
//
//  Classes:    Defined in dl.hxx
//
//  History:    28-Jul-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <mread.hxx>
#include <dl.hxx>
#include <tstream.hxx>

#ifndef _MAC
inline
#endif
void *SDeltaBlock::operator new(size_t size, IMalloc * const pMalloc)
{
    return pMalloc->Alloc(size);
}

//+-------------------------------------------------------------------------
//
//  Method:     SDeltaBlock::SDeltaBlock, public
//
//  Synopsis:   SDeltaBlock constructor
//
//  History:    10-Jul-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


#ifndef _MAC
inline
#endif
SDeltaBlock::SDeltaBlock()
{
    for (USHORT i = 0; i < CSECTPERBLOCK; i++)
    {
        _sect[i] = ENDOFCHAIN;
    }
    for (i = 0; i < CSECTPERBLOCK / CBITPERUSHORT; i++)
    {
        _fOwn[i] = 0;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::CDeltaList, public
//
//  Synopsis:   CDeltaList constructor
//
//  History:    21-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------


CDeltaList::CDeltaList(CMStream *pms, CMStream *pmsScratch)
{
    _pms = P_TO_BP(CBasedMStreamPtr, pms);
    _pmsScratch = P_TO_BP(CBasedMStreamPtr, pmsScratch);
    _apdb = NULL;
    _sectStart = ENDOFCHAIN;
    _ulSize = 0;
    _ptsParent = NULL;
}


inline CBasedDeltaBlockPtr * CDeltaList::GetNewDeltaArray(ULONG ulSize)
{
    msfAssert(ulSize > 0);
    if (ulSize > (_HEAP_MAXREQ / sizeof(SDeltaBlock *)))
    {
        return NULL;
    }
    return (CBasedDeltaBlockPtr *) _pmsScratch->GetMalloc()->
        Alloc(sizeof(SDeltaBlock *) * ulSize);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::Init, public
//
//  Synopsis:   Init function for CDeltaList
//
//  Arguments:  [ulSize] -- Size of delta list to be initialized
//              [ptsParent] -- Pointer to transacted stream that contains
//                      this delta list.
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  *Finish This*
//
//  History:    21-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#ifdef LARGE_STREAMS
SCODE CDeltaList::Init(ULONGLONG ulSize, CTransactedStream *ptsParent)
#else
SCODE CDeltaList::Init(ULONG ulSize, CTransactedStream *ptsParent)
#endif
{
    SCODE sc = S_OK;
    ULONG ulNewSize;
    CBasedDeltaBlockPtr *apdbTemp = NULL;

    msfAssert(IsEmpty() &&
            aMsg("Init called on non-empty delta list."));

    ULONG cbSector = GetDataSectorSize();

    ULONG csect = (ULONG)((ulSize + cbSector - 1) / cbSector);


    ulNewSize = (csect + CSECTPERBLOCK - 1) / CSECTPERBLOCK;

    _ulSize = ulNewSize;
    _ptsParent = P_TO_BP(CBasedTransactedStreamPtr, ptsParent);

    CDeltaList *pdlParent = NULL;

    if (_ptsParent->GetBase() != NULL)
    {
        pdlParent = _ptsParent->GetBase()->GetDeltaList();
    }

    msfAssert(_ulSize > 0);
    msfAssert(IsEmpty());

    //  if the parent is InStream, we stay in low-memory mode
    if ((pdlParent == NULL) || (pdlParent->IsInMemory()))
    {
        //Try to copy it down.  If it doesn't work, put it in a stream
        //instead.
        msfMem(apdbTemp = GetNewDeltaArray(_ulSize));

        MAXINDEXTYPE i;
        for (i = 0; i < _ulSize; i++)
        {
            apdbTemp[i] = NULL;
        }

        if (pdlParent != NULL)
        {
            for (i = 0; i < _ulSize; i++)
            {
                if ((i < pdlParent->_ulSize) && (pdlParent->_apdb[i] != NULL))
                {
                    SDeltaBlock *pdbTemp;
                    msfMemTo(Err_Alloc, pdbTemp =
                             new(_pmsScratch->GetMalloc()) SDeltaBlock);

                    apdbTemp[i] = P_TO_BP(CBasedDeltaBlockPtr, pdbTemp);

                    for (USHORT j = 0; j < CSECTPERBLOCK; j++)
                    {
                        pdbTemp->_sect[j] = pdlParent->_apdb[i]->_sect[j];
                    }
                }
            }
        }
        _apdb = P_TO_BP(CBasedDeltaBlockPtrPtr, apdbTemp);

        return S_OK;

 Err_Alloc:
        for (i = 0; i < _ulSize; i++)
        {
            _pmsScratch->GetMalloc()->Free(BP_TO_P(SDeltaBlock *, apdbTemp[i]));
            apdbTemp[i] = NULL;
        }
    }


 Err:
    _apdb = NULL;

    //We'll end up here if we get an error allocating memory for
    //  the InMemory case above or if the parent is InStream.  We
    //  must allocate a new stream and copy down the parent.
    if (pdlParent == NULL)
    {
        for (ULONG i = 0; i < _ulSize; i++)
        {
            msfChkTo(Err_Init, InitStreamBlock(i));
        }
    }
    else
    {
        //Copy the parent into a stream representation.

        for (ULONG i = 0;
             i < min(_ulSize, pdlParent->_ulSize) * CSECTPERBLOCK;
             i++)
        {
            SECT sectOld;
            msfChkTo(Err_Init, pdlParent->GetMap(i, DL_READ, &sectOld));
            msfChkTo(Err_Init, WriteMap(&_sectStart, i, sectOld));
        }
        for (i = pdlParent->_ulSize; i < _ulSize; i++)
        {
            msfChkTo(Err_Init, InitStreamBlock(i));
        }
    }


 Err_Init:
    return sc;

}


//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::InitResize, public
//
//  Synopsis:   Resize initializer for deltalists
//
//  Arguments:  [ulSize] -- Size of new deltalist
//              [pdlOld] -- Pointer to deltalist to be resized
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    21-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


#ifdef LARGE_STREAMS
SCODE CDeltaList::InitResize(ULONGLONG ulSize)
#else
SCODE CDeltaList::InitResize(ULONG ulSize)
#endif
{
    msfDebugOut((DEB_ITRACE,"In CDeltaList copy constructor\n"));
    SCODE sc = S_OK;
    CBasedDeltaBlockPtr *temp = NULL;
    CBasedDeltaBlockPtr *apdbTemp = NULL;

    ULONG cbSector = GetDataSectorSize();

    ULONG csect = (ULONG)((ulSize + cbSector - 1) / cbSector);

    ULONG ulNewSize = (csect + CSECTPERBLOCK - 1) / CSECTPERBLOCK;

    msfAssert(ulNewSize > 0);

    if (ulNewSize == _ulSize)
    {
        return S_OK;
    }

    if (IsInStream())
    {
        //We have already copied the delta list contents out to the
        //  stream, and will not attempt to read them back in.
        //
        //All we need to do is adjust the size and return.
        if (ulNewSize > _ulSize)
        {
            for (ULONG i = _ulSize; i < ulNewSize; i++)
            {
                msfChk(InitStreamBlock(i));
            }
        }

        _ulSize = ulNewSize;
        return S_OK;
    }


    if (ulNewSize > (_HEAP_MAXREQ / sizeof(SDeltaBlock *)))
    {
        //This is not an error.  Write the current delta information
        //  to the stream and use that.

        msfChk(DumpList());
        if (ulNewSize > _ulSize)
        {
            for (ULONG i = _ulSize; i < ulNewSize; i++)
            {
                msfChk(InitStreamBlock(i));
            }
        }

        _ulSize = ulNewSize;
        return S_OK;
    }


    msfMemTo(ErrMem, temp = GetNewDeltaArray(ulNewSize));

    //apdbTemp is an unbased version of _apdb, for efficiency.
    apdbTemp = BP_TO_P(CBasedDeltaBlockPtr *, _apdb);

    ULONG i;

    if (apdbTemp != NULL)
    {
        for (i = 0; i < min(_ulSize, ulNewSize); i++)
        {
            temp[i] = apdbTemp[i];
            apdbTemp[i] = NULL;
        }
    }

    for (i = _ulSize; i < ulNewSize; i++)
    {
        temp[i] = NULL;
    }

    for (i = ulNewSize; i < _ulSize; i++)
    {
        ReleaseBlock(i);
    }

    _ulSize = ulNewSize;
    _pmsScratch->GetMalloc()->Free(apdbTemp);
    _apdb = P_TO_BP(CBasedDeltaBlockPtrPtr, temp);
    return S_OK;

 ErrMem:
    //The only error that can get us here is an error allocating temp.
    //If this happens, dump the current vector to a stream and use
    //   the stream for all future delta list operations.
    msfChk(DumpList());
    if (ulNewSize > _ulSize)
    {
        for (i = _ulSize; i < ulNewSize; i++)
        {
            msfChk(InitStreamBlock(i));
        }
    }

    _ulSize = ulNewSize;
    return S_OK;

 Err:
    //We only get here if we error out on the DumpList() or
    //InitStreamBlock calls (i.e. Disk Error)
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::InitStreamBlock, private
//
//  Synopsis:	Initialize a new block in a stream
//
//  Arguments:	[ulBlock] -- Block to initialize
//
//  Returns:	Appropriate status code
//
//  History:	20-Nov-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------


SCODE CDeltaList::InitStreamBlock(ULONG ulBlock)
{
    SCODE sc = S_OK;

    ULONG cSectOld = ulBlock * CSECTPERBLOCK;
    ULONG cSectNew = (ulBlock + 1) * CSECTPERBLOCK;

    //NOTE: This can potentially be optimized to avoid the loop.
    for (ULONG i = cSectOld; i < cSectNew; i++)
    {
        msfChk(WriteMap(&_sectStart, i, ENDOFCHAIN));
    }
 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::ReleaseBlock, private
//
//  Synopsis:   Release an SDeltaBlock, freeing its storage in the
//                  scratch MS.
//
//  Arguments:  [oBlock] -- Offset of block to release.
//
//  Returns:    void.
//
//  History:    10-Jul-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


void CDeltaList::ReleaseBlock(ULONG oBlock)
{
    CFat *pfat = GetDataFat();

    msfAssert(IsInMemory());

    SDeltaBlock *temp = BP_TO_P(SDeltaBlock *, _apdb[(MAXINDEXTYPE)oBlock]);

    if (temp != NULL)
    {
        for (USHORT i = 0; i < CSECTPERBLOCK; i++)
        {
            if ((temp->_sect[i] != ENDOFCHAIN) && temp->IsOwned(i))
            {
                SECT sectCurrent = FREESECT;

                pfat->GetNext(temp->_sect[i], &sectCurrent);
                if (sectCurrent == STREAMSECT)
                    pfat->SetNext(temp->_sect[i], FREESECT);
            }
        }
        _pmsScratch->GetMalloc()->Free(temp);
        _apdb[(MAXINDEXTYPE)oBlock] = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::~CDeltaList, public
//
//  Synopsis:   CDeltaList destructor
//
//  History:    21-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


CDeltaList::~CDeltaList()
{
    Empty();
}

//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::GetMap, public
//
//  Synopsis:   Get mapping information for a sector
//
//  Arguments:  [sectOld] -- Sector to get mapping information for
//              [dwFlags] -- DL_GET or DL_CREATE
//              [psectRet] -- Location for return value
//              [pfIsOwner] -- Returns TRUE if the returned sector
//                      is owned by this delta list, FALSE if it
//                      if owned by an ancestor.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  If DL_READ is specified, return the current existing
//                  mapping for the sector.  It is not required that
//                  the delta list own the sector.  Return ENDOFCHAIN
//                  if no mapping exists.
//              If DL_GET is specified, return the current existing
//                  mapping for the sector if it is owned by this delta
//                  list.  If none exists, return ENDOFCHAIN.
//              If DL_CREATE, check the existing mapping.  If none
//                  exists, or one exists but is not owned, get a free
//                  sector from the fat and set the mapping.  Return
//                  the new mapping (or the existing one if it had
//                  previously been mapped).
//
//  History:    21-Jan-92   PhilipLa    Created.
//              10-Jul-92   PhilipLa    Changed for copy reductions.
//
//--------------------------------------------------------------------------


SCODE CDeltaList::GetMap(SECT sectOld, const DWORD dwFlags, SECT *psectRet)
{
    msfDebugOut((DEB_ITRACE,"In CDeltaList::GetMap()\n"));
    SCODE sc = S_OK;

    msfAssert(!IsEmpty());
    msfAssert((dwFlags == DL_GET) || (dwFlags == DL_CREATE) ||
            (dwFlags == DL_READ));

    MAXINDEXTYPE odb = (MAXINDEXTYPE)(sectOld / CSECTPERBLOCK);
    USHORT os = (USHORT)(sectOld % CSECTPERBLOCK);

    msfAssert(odb < _ulSize);

    if (IsInStream())
    {
        BOOL fOwn = TRUE;
        msfChk(ReadMap(&_sectStart, sectOld, psectRet));

        if (dwFlags == DL_READ)
        {
            return S_OK;
        }

        CDeltaList *pdlParent = NULL;
        if (_ptsParent->GetBase() != NULL)
            pdlParent = _ptsParent->GetBase()->GetDeltaList();

        if (pdlParent != NULL)
        {
            msfChk(pdlParent->IsOwned(sectOld, *psectRet, &fOwn));
        }

        if (fOwn == FALSE)
            *psectRet = ENDOFCHAIN;

        if ((dwFlags == DL_CREATE) && (*psectRet == ENDOFCHAIN))
        {
            msfChk(GetDataFat()->GetFree(1, psectRet, GF_WRITE));
            msfChk(GetDataFat()->SetNext(*psectRet, STREAMSECT));

            if(!IsNoScratch())
                msfChk(_pmsScratch->SetSize());
            else
                msfChk(_pms->SetSize());

            msfChk(WriteMap(&_sectStart, sectOld, *psectRet));
        }

        return S_OK;
    }

    msfAssert(odb < _ulSize);

    // If _apdb[odb] == NULL, there is no existing mapping so we
    //   don't need to check ownership.
    if (_apdb[odb] == NULL)
    {
        if (dwFlags & DL_CREATE)
        {
            SDeltaBlock * pdbTemp = new(_pmsScratch->GetMalloc()) SDeltaBlock;
            _apdb[odb] = P_TO_BP(CBasedDeltaBlockPtr, pdbTemp);

            if (_apdb[odb] == NULL)
            {
                msfChk(DumpList());
                msfAssert(IsInStream());
                return GetMap(sectOld, dwFlags, psectRet);
            }
        }
        else
        {
            *psectRet = ENDOFCHAIN;
            return S_OK;
        }
    }

    SECT sectTemp;
    sectTemp = _apdb[odb]->_sect[os];

    if (dwFlags != DL_READ)
    {
        BOOL fOwn = _apdb[odb]->IsOwned(os);
        if (fOwn == FALSE)
            sectTemp = ENDOFCHAIN;

        if ((dwFlags == DL_CREATE) && (sectTemp == ENDOFCHAIN))
        {
            //
            // Don't grow the file (w/ SetSize) here.  As an optimzation
            // it is the responsibility of the caller to grow the file after
            // possibly multiple calls to GetMap(DL_CREATE).
            //
            msfChk(GetDataFat()->GetFree(1, &sectTemp, GF_WRITE));
            msfChk(GetDataFat()->SetNext(sectTemp, STREAMSECT));

            _apdb[odb]->_sect[os] = sectTemp;
            _apdb[odb]->MakeOwn(os);
        }
    }

    *psectRet = sectTemp;
    msfDebugOut((DEB_ITRACE,"Out CDeltaList::GetMap()\n"));
 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::ReleaseInvalidSects, public
//
//  Synopsis:   Release sectors allocated in the FAT that are not in the
//              MStream.
//
//  Arguments:  [sectMaxValid] -- Release all SECTS greater than this one.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//  History:    26-Mar-97   BChapman    Created.
//
//--------------------------------------------------------------------------

SCODE CDeltaList::ReleaseInvalidSects(SECT sectMaxValid)
{
    msfDebugOut((DEB_ITRACE,"In CDeltaList::ReleaseInvalidSects(%x)\n",
                                                        sectMaxValid));

    msfAssert(!IsEmpty());

    CBasedDeltaBlockPtr *apdbTemp;      // Real Ptr to array of Based Pointers
    SDeltaBlock *pdbTemp;

    CFat *pfat = GetDataFat();

    if (IsInStream())
    {
        // We don't need to do this if we are InStream.
        return S_OK;
    }

    apdbTemp = _apdb;   // Convert the array BasedPtr to a Ptr.

    //
    //   Walk the entire Delta List looking for SECTS in the FAT that are
    // greater than sectMaxValid, and free them.
    //   If all the entries in any block are freed, then free the block.
    //
    for (MAXINDEXTYPE i = 0; i < _ulSize; i++)
    {
        pdbTemp = _apdb[i];  // Convert BasedPtr to Ptr

        if (pdbTemp != NULL)
        {
            BOOL fFreeAll = TRUE;

            for (USHORT k=0; k < CSECTPERBLOCK; k++)
            {
                SECT sectType=FREESECT;
                SECT sectEntryK = pdbTemp->_sect[k];

                if(sectEntryK != ENDOFCHAIN)
                {
                    if(pdbTemp->IsOwned(k) && (sectEntryK > sectMaxValid))
                    {
                        //
                        // This routins is already in the error path.  So we
                        // don't check for errors.  Just keep pluggin away.
                        // BTW.  There shouldn't be any errors because we just
                        // allocated all this stuff and we are only tring to
                        // give it back.
                        //
                        pfat->GetNext(sectEntryK, &sectType);
                        if (sectType == STREAMSECT)
                        {
                            pfat->SetNext(sectEntryK, FREESECT);
                            pdbTemp->DisOwn(k);
                            pdbTemp->_sect[k] = ENDOFCHAIN;
                        }
                    }
                    else
                    {
                        // don't free this DeltaBlock if any non-ENDOFCHAIN
                        // entries are not owned or are valid (<= MaxValid)
                        fFreeAll = FALSE;
                    }
                }
            }
            if(fFreeAll)
            {
                _pmsScratch->GetMalloc()->Free(pdbTemp);
                _apdb[i] = NULL;
            }
        }
    }
    msfDebugOut((DEB_ITRACE,"Out CDeltaList::ReleaseInvalidSects()\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::BeginCommit, public
//
//  Synopsis:	Begin the commit of a delta list
//
//  Arguments:	[ptsParent] -- Pointer to containing Tstream.
//
//  Returns:	Appropriate status code
//
//  History:	19-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


void CDeltaList::BeginCommit(CTransactedStream *ptsParent)
{
    _ptsParent = P_TO_BP(CBasedTransactedStreamPtr, ptsParent);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::EndCommit, public
//
//  Synopsis:   Take the new delta list passed up and release the old.
//              Free any sectors used and owned in the old list but not
//              in the new.
//
//  Arguments:  [pdlNew] -- Pointer to new delta list to take
//
//  Returns:    void.
//
//  History:    10-Jul-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


void CDeltaList::EndCommit(CDeltaList *pdlNew, DFLAGS df)
{
    msfAssert(pdlNew != NULL);

    if (pdlNew->IsEmpty()) return;

    ULONG ulMaxSize = min(_ulSize, pdlNew->_ulSize);

    if (P_COMMIT(df))
    {
#if DBG == 1
        msfDebugOut((DEB_ITRACE, "Beginning commit process:\n"));
        PrintList();

        msfDebugOut((DEB_ITRACE, "New list is:\n"));
        pdlNew->PrintList();
#endif

        ULONG iMax = ulMaxSize * CSECTPERBLOCK;

        for (ULONG i = 0; i < iMax; i++)
        {
            SECT sectOld = ENDOFCHAIN, sectNew = ENDOFCHAIN;

            GetMap(i, DL_GET, &sectOld);
            pdlNew->GetMap(i, DL_GET, &sectNew);

            if ((sectOld != sectNew) && (sectOld != ENDOFCHAIN) &&
                (sectNew != ENDOFCHAIN))
            {
                CFat *pfat = GetDataFat();
                SECT sectChk;

                pfat->GetNext(sectOld, &sectChk);
                if (sectChk == STREAMSECT)
                    pfat->SetNext(sectOld, FREESECT);
            }
        }


        //At this point, all the sectors in the current delta list
        //   that are not used in the new delta list have been freed.
        //   We still need to clean up the actual representation of
        //   the delta list, and merge the ownership bitvectors if
        //   we are InMemory.

        if (IsInMemory())
        {
            for (i = pdlNew->_ulSize; i < _ulSize; i++)
            {
                ReleaseBlock(i);
            }

            CBasedDeltaBlockPtr * apdbTemp;
            apdbTemp = BP_TO_P(CBasedDeltaBlockPtr *, _apdb);

            for (MAXINDEXTYPE i = 0; i < ulMaxSize; i++)
            {
                if ((apdbTemp[i] != NULL) && (pdlNew->IsInMemory()))
                {
                    msfAssert(pdlNew->_apdb[i] != NULL);
                    for (USHORT j = 0; j < CSECTPERBLOCK / CBITPERUSHORT; j++)
                    {
                        pdlNew->_apdb[i]->_fOwn[j] |= apdbTemp[i]->_fOwn[j];
                    }
                }
                _pmsScratch->GetMalloc()->Free(BP_TO_P(SDeltaBlock *, apdbTemp[i]));
            }
            _pmsScratch->GetMalloc()->Free(apdbTemp);
        }
        else if (IsInStream())
        {
            for (i = pdlNew->_ulSize * CSECTPERBLOCK;
                 i < _ulSize * CSECTPERBLOCK;
                 i++)
            {
                SECT sectOld = ENDOFCHAIN;
                GetMap(i, DL_GET, &sectOld);
                if (sectOld != ENDOFCHAIN)
                {
                    CFat *pfat = GetDataFat();
#if DBG == 1
                    SECT sectChk;
                    pfat->GetNext(sectOld, &sectChk);
                    msfAssert((sectChk == STREAMSECT) &&
                              aMsg("Freeing non-dirty stream sector"));
#endif
                    pfat->SetNext(sectOld, FREESECT);
                }
            }

            GetControlFat()->SetChainLength(_sectStart, 0);
        }

        _apdb = pdlNew->_apdb;
        _ulSize = pdlNew->_ulSize;
        _sectStart = pdlNew->_sectStart;

        pdlNew->_apdb = NULL;
        pdlNew->_ulSize = 0;
        pdlNew->_sectStart = ENDOFCHAIN;
        pdlNew->_ptsParent = NULL;
#if DBG == 1
        msfDebugOut((DEB_ITRACE, "Completed commit process:\n"));
        PrintList();
#endif
    }

    return;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::Empty, public
//
//  Synopsis:	Empty the delta list
//
//  Arguments:	None.
//
//  History:	18-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


void CDeltaList::Empty(void)
{
    if (IsInMemory())
    {
        msfAssert(_sectStart == ENDOFCHAIN);

        CBasedDeltaBlockPtr * apdbTemp;
        apdbTemp = BP_TO_P(CBasedDeltaBlockPtr *, _apdb);

        for (ULONG i = 0; i < _ulSize; i++)
        {
            if (apdbTemp[i] != NULL)
            {
                ReleaseBlock(i);
            }
        }
        _pmsScratch->GetMalloc()->Free(apdbTemp);
        _apdb = NULL;
    }
    else if (IsInStream())
    {
        msfAssert(_apdb == NULL);

        if (_sectStart != ENDOFCHAIN)
        {
            FreeStream(_sectStart, _ulSize);
        }
        _sectStart = ENDOFCHAIN;
    }

    _ptsParent = NULL;
    _ulSize = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::DumpList, public
//
//  Synopsis:	Dump a delta list out to a stream, then release its
//                      in memory representation.
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	20-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CDeltaList::DumpList(void)
{
    SCODE sc = S_OK;

    ULONG cSect = _ulSize * CSECTPERBLOCK;

    msfAssert(IsInMemory());
    for (ULONG i = 0; i < cSect; i++)
    {
        SECT sectNew;
        msfChk(GetMap(i, DL_GET, &sectNew));
        msfChk(WriteMap(&_sectStart, i, sectNew));
    }

    CBasedDeltaBlockPtr * apdbTemp;
    apdbTemp = BP_TO_P(CBasedDeltaBlockPtr *, _apdb);
    if (apdbTemp != NULL)
    {
        for (i = 0; i < _ulSize; i++)
        {
            SDeltaBlock *temp = BP_TO_P(SDeltaBlock *, apdbTemp[i]);
            if (temp != NULL)
            {
                _pmsScratch->GetMalloc()->Free(temp);
            }
        }
        _pmsScratch->GetMalloc()->Free(apdbTemp);
        _apdb = NULL;
    }

    msfAssert(IsInStream());
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::FindOffset, private
//
//  Synopsis:	Compute the correct offset from which to read a mapping
//
//  Arguments:  [psectStart] -- Pointer to start sector
//              [sect] -- Sector to find mapping for
//              [pulRet] -- Pointer to return location
//              [fWrite] -- TRUE if the sector will be written to
//
//  Returns:	Appropriate status code
//
//  History:	20-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CDeltaList::FindOffset(
        SECT *psectStart,
        SECT sect,
        ULARGE_INTEGER *pulRet,
        BOOL fWrite)
{
    SCODE sc;

    ULONG ulOffset = sect * sizeof(SECT);

    ULONG cbSector = GetControlSectorSize();
    msfAssert(cbSector == SCRATCHSECTORSIZE);

    SECT sectChain = ulOffset / cbSector;

    SECT sectReal;

    CFat *pfat = GetControlFat();

    if (fWrite)
    {
        if (*psectStart == ENDOFCHAIN)
        {
            msfChk(pfat->Allocate(1, psectStart));
        }
        msfChk(pfat->GetESect(*psectStart, sectChain, &sectReal));
    }
    else
    {
        msfChk(pfat->GetSect(*psectStart, sectChain, &sectReal));
    }

    msfAssert(sectReal != ENDOFCHAIN);

    ULARGE_INTEGER ul;
#ifdef LARGE_DOCFILE
    ul.QuadPart = ConvertSectOffset(sectReal,
            (OFFSET)(ulOffset % cbSector),
            _pmsScratch->GetSectorShift());
#else
    ULISet32(ul, ConvertSectOffset(sectReal,
            (OFFSET)(ulOffset % cbSector),
            _pmsScratch->GetSectorShift()));
#endif

    *pulRet = ul;

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::ReadMap, private
//
//  Synopsis:	Read a mapping from a stream representation.
//
//  Arguments:	[sect] -- Sector to read mapping for
//              [psectRet] -- Location to return mapping in.
//
//  Returns:	Appropriate status code
//
//  History:	20-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CDeltaList::ReadMap(SECT *psectStart, SECT sect, SECT *psectRet)
{
    SCODE sc;

    if (_sectStart == ENDOFCHAIN)
    {
        //We haven't written anything yet, so the sector must be
        //  unmapped.
        *psectRet = ENDOFCHAIN;
        return S_OK;
    }

    ULARGE_INTEGER ul;
    ULONG ulRetval;

    msfChk(FindOffset(psectStart, sect, &ul, FALSE));

    msfHChk(GetControlILB()->ReadAt(ul, psectRet, sizeof(SECT),
            &ulRetval));

    if (ulRetval != sizeof(SECT))
    {
        //The ILB isn't long enough to contain that mapping,
        *psectRet = ENDOFCHAIN;
    }
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::WriteMap, private
//
//  Synopsis:	Write a mapping to a stream representation
//
//  Arguments:	[sect] -- Sect to write mapping for
//              [sectMap] -- Mapping of sect
//
//  Returns:	Appropriate status code
//
//  History:	20-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CDeltaList::WriteMap(SECT *psectStart, SECT sect, SECT sectMap)
{
    SCODE sc;

    ULARGE_INTEGER ul;
    ULONG ulRetval;

    SECT sectOld = *psectStart;

    msfAssert(_pmsScratch->IsScratch());

    msfChk(FindOffset(psectStart, sect, &ul, TRUE));

    msfHChk(GetControlILB()->WriteAt(ul, &sectMap, sizeof(SECT),
            &ulRetval));

    if (ulRetval != sizeof(SECT))
    {
        msfErr(Err, STG_E_WRITEFAULT);
    }

    return S_OK;

Err:
    //If we failed, we may have allocated sectors for storage that
    //   cannot be written to - we should ignore these sectors.  This
    //   can leave some wasted space in the fat, but we don't really
    //   care since this is the scratch.

    *psectStart = sectOld;
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::FreeStream, private
//
//  Synopsis:	Free the scratch sectors associated with a stream
//              representation of a delta list.
//
//  Arguments:	[sectStart] -- Start sector of representation to
//                              free.
//
//  Returns:	void.
//
//  History:	23-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


void CDeltaList::FreeStream(SECT sectStart, ULONG ulSize)
{
    ULONG cSect = ulSize * CSECTPERBLOCK;

    SECT sectOld = ENDOFCHAIN;
    BOOL fOwn = TRUE;

    CDeltaList *pdlParent = NULL;
    if (_ptsParent->GetBase() != NULL)
        pdlParent = _ptsParent->GetBase()->GetDeltaList();

    for (ULONG i = 0; i < cSect; i++)
    {
        ReadMap(&sectStart, i, &sectOld);

        if (pdlParent != NULL)
        {
            pdlParent->IsOwned(i, sectOld, &fOwn);
        }

        if ((sectOld != ENDOFCHAIN) && fOwn)
        {
            CFat *pfat = GetDataFat();
            SECT sectChk = FREESECT;
            pfat->GetNext(sectOld, &sectChk);
            if (sectChk == STREAMSECT)
                pfat->SetNext(sectOld, FREESECT);
        }
    }
    GetControlFat()->SetChainLength(sectStart, 0);
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::IsOwned, public
//
//  Synopsis:	Return TRUE if the caller owns the sector given,
//              FALSE otherwise.
//
//  Arguments:	[sect] -- Sector for mapping given
//              [sectMap] -- Sector mapping
//              [fOwn] -- Return value
//
//  Returns:	Appropriate status code
//
//  History:	30-Jul-93	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CDeltaList::IsOwned(SECT sect, SECT sectMap, BOOL *fOwn)
{
    SCODE sc = S_OK;
    //To determine ownership of a sector:
    //    1)  If the sector mapping does not exist at the current level,
    //          then the caller must own it.
    //    2)  If the sector mapping does exist at the current level, then
    //          the caller cannot own it.
    SECT sectOld;

    if (sect < _ulSize * CSECTPERBLOCK)
    {
        if (IsInMemory())
        {
            MAXINDEXTYPE odb = (MAXINDEXTYPE)(sect / CSECTPERBLOCK);
            USHORT os = (USHORT)(sect % CSECTPERBLOCK);

            sectOld = _apdb[odb]->_sect[os];
        }
        else
        {
            msfChk(GetMap(sect, DL_READ, &sectOld));
        }

        *fOwn = (sectOld != sectMap);
    }
    else
    {
        *fOwn = TRUE;
    }

Err:
    return sc;
}


#if DBG == 1
void CDeltaList::PrintList(void)
{
    if (!IsEmpty())
    {
        for (ULONG i = 0; i < _ulSize * CSECTPERBLOCK; i++)
        {
            SECT sect;
            GetMap(i, DL_READ, &sect);

            msfDebugOut((DEB_NOCOMPNAME|DEB_ITRACE, "%lx ",sect));
        }
        msfDebugOut((DEB_NOCOMPNAME|DEB_ITRACE,"\n"));
    }
    else
    {
        msfDebugOut((DEB_NOCOMPNAME|DEB_ITRACE,"List is empty\n"));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\header.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       header.cxx
//
//  Contents:   Code to manage MSF header
//
//  Classes:    Defined in header.hxx
//
//  History:    11-Dec-91   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <dfver.h>

CMSFHeaderData::CMSFHeaderData(USHORT uSectorShift)
{
    msfAssert((CSECTFATREAL != CSECTFAT) || (sizeof(CMSFHeaderData) == HEADERSIZE));
    _uSectorShift = uSectorShift;
    _uMiniSectorShift = MINISECTORSHIFT;
    _ulMiniSectorCutoff = MINISTREAMSIZE;

    _clid = IID_NULL;

    _uByteOrder = 0xFFFE;

    _uMinorVersion = rmm;
    _uDllVersion = (USHORT) (uSectorShift > SECTORSHIFT512 ? rmjlarge : rmj);

    for (SECT sect = 0; sect < CSECTFAT; sect ++)
    {
        _sectFat[sect] = FREESECT;
    }

    _csectDif = 0;
    _sectDifStart = ENDOFCHAIN;

    _csectFat = 1;
    _sectFat[0] = SECTFAT;
    _sectDirStart = SECTDIR;

    _csectMiniFat = 0;
    _sectMiniFatStart = ENDOFCHAIN;

    _signature = 0;
    _usReserved = 0;
    _ulReserved1 = 0;
    _csectDir = (uSectorShift > SECTORSHIFT512) ? 1 : 0;

    //  Write DocFile signature
    memcpy(abSig, SIGSTG, CBSIGSTG);
}


CMSFHeader::CMSFHeader(USHORT uSectorShift)
        :_hdr(uSectorShift)
{
    //We set this to dirty here.  There are three cases in which a header
    //  can be initialized:
    //1)  Creating a new docfile.
    //2)  Converting a flat file to a docfile.
    //3)  Opening an existing file.
    //
    //We have a separate CMStream::Init* function for each of these cases.
    //
    //We set the header dirty, then explicitly set it clean in case 3
    //   above.  For the other cases, it is constructed dirty and we
    //   want it that way.
    
    _fDirty = TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMSFHeader::Validate, public
//
//  Synopsis:   Validate a header.
//
//  Returns:    S_OK if header is valid.
//
//  History:    21-Aug-92 	PhilipLa	Created.
//              27-Jan-93       AlexT           Changed to final signature
//
//--------------------------------------------------------------------------

SCODE CMSFHeader::Validate(VOID) const
{
    SCODE sc;
    USHORT uShift;

    sc = CheckSignature((BYTE *)_hdr.abSig);
    if (sc == S_OK)
    {
        uShift = GetSectorShift();

        // Check file format verson number
        if (GetDllVersion() > rmjlarge)
            return STG_E_OLDDLL;
	
        // check for invalid sector shifts
        if ((uShift != SECTORSHIFT512 && uShift != SECTORSHIFT4K) ||
            GetMiniSectorShift() != MINISECTORSHIFT )
        {    	
            return STG_E_DOCFILECORRUPT;
        }

        // for default sector sizes, Korean apps write into the cutoff field
        // so the ministream cutoff is not validated for 512 byte sectors
        if (uShift == SECTORSHIFT4K && 
            GetMiniSectorCutoff() != MINISTREAMSIZE)
        {
            return STG_E_DOCFILECORRUPT;
        }
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\page.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	page.cxx
//
//  Contents:	Paging code for MSF
//
//  Classes:	Defined in page.hxx
//
//  Functions:	
//
//  History:	20-Oct-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop


#include <mread.hxx>
#include <filest.hxx>


#define FLUSH_MULTIPLE

//+---------------------------------------------------------------------------
//
//  Member:     CMSFPage::SetSect, public
//
//  Synopsis:   Sets the SECT for this page
//
//  History:    20-Oct-92       PhilipLa        Created
//
//----------------------------------------------------------------------------
#ifdef SORTPAGETABLE    
inline void CMSFPage::SetSect(const SECT sect)
{
    msfAssert(_pmpNext != NULL && _pmpPrev != NULL);
    
    msfAssert((_pmpPrev->_sect >= _pmpNext->_sect) || //Edge
              ((_sect >= _pmpPrev->_sect) && (_sect <= _pmpNext->_sect)));
    _sect = sect;
}
#endif    


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::IsSorted, public
//
//  Synopsis:	Return TRUE if the specified page is in the right place
//                in the list.
//
//  Arguments:	[pmp] -- Page to check
//
//  History:	13-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

inline BOOL CMSFPageTable::IsSorted(CMSFPage *pmp)
{
    //There are three cases:
    //1)  Page is first in the list.
    //2)  Page is last in the list.
    //3)  Page is in the middle of the list.

    SECT sect = pmp->GetSect();
    CMSFPage *pmpStart = BP_TO_P(CMSFPage *, _pmpStart);
    CMSFPage *pmpNext = pmp->GetNext();

    if (pmp == pmpStart)
    {
        return (sect <= pmpNext->GetSect());
    }
    if (pmpNext == pmpStart)
    {
        return (sect >= pmp->GetPrev()->GetSect());
    }
    return ((sect <= pmpNext->GetSect()) &&
            (sect >= pmp->GetPrev()->GetSect()));
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::SetSect, public
//
//  Synopsis:	Set the sector stamp on a page, and sort the list if
//              necessary.
//
//  Arguments:	[pmp] -- Pointer to page to stamp
//              [sect] -- SECT to stamp it with
//
//  Returns:	void
//
//  History:	12-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CMSFPageTable::SetSect(CMSFPage *pmp, SECT sect)
{
    msfDebugOut((DEB_ITRACE, "In  CMSFPageTable::SetSect:%p(%p, %lX)\n",
                 this,
                pmp,
                sect));
    pmp->SetSect(sect);

    //Resort list if necessary.
    if (!IsSorted(pmp))
    {
        CMSFPage *pmpTemp, *pmpStart;
        pmpStart = BP_TO_P(CMSFPage *, _pmpStart);

        if (pmpStart == pmp)
        {
            pmpStart = pmp->GetNext();
            _pmpStart = P_TO_BP(CBasedMSFPagePtr , pmpStart);
        }
        pmp->Remove();
    
        pmpTemp = pmpStart;
        while (sect > pmpTemp->GetSect())
        {
            pmpTemp = pmpTemp->GetNext();
            if (pmpTemp == pmpStart)
            {
                break;
            }
        }
        //Insert node before pmpTemp.
        pmpTemp->GetPrev()->SetNext(pmp);
        pmp->SetChain(pmpTemp->GetPrev(), pmpTemp);
        pmpTemp->SetPrev(pmp);

        if (sect <= pmpStart->GetSect())
        {
            _pmpStart = P_TO_BP(CBasedMSFPagePtr, pmp);
        }
    }
    msfAssert(IsSorted(pmp));
    
    msfDebugOut((DEB_ITRACE, "Out CMSFPageTable::SetSect\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::CMSFPageTable, public
//
//  Synopsis:	CMSFPageTable constructor.
//
//  Arguments:	[pmsParent] -- Pointer to multistream for this page table.
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

CMSFPageTable::CMSFPageTable(
        CMStream *const pmsParent,
        const ULONG cMinPages,
        const ULONG cMaxPages)
        : _cbSector(pmsParent->GetSectorSize()),
          _cMinPages(cMinPages), _cMaxPages(cMaxPages)
{
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);
    _cActivePages = 0;
    _cPages = 0;
    _pmpCurrent = NULL;
#ifdef SORTPAGETABLE
    _pmpStart = NULL;
#endif    
    _cReferences = 1;
#if DBG == 1
    _cCurrentPageRef = 0;
    _cMaxPageRef = 0;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:	CMSFPage::CMSFPage, public
//
//  Synopsis:	CMSFPage default constructor
//
//  History:	20-Oct-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
CMSFPage::CMSFPage(CMSFPage *pmp, CMSFPageTable *pmpt)
#else
CMSFPage::CMSFPage(CMSFPage *pmp)
#endif
{
    if (pmp == NULL)
    {
        SetChain(this, this);
    }
    else
    {
        SetChain(pmp->GetPrev(), pmp);
        GetPrev()->SetNext(this);
        GetNext()->SetPrev(this);
    }

#if DBG == 1
    _pmpt = P_TO_BP(CBasedMSFPageTablePtr, pmpt);
#endif

    SetSid(NOSTREAM);
    SetOffset(0);
//    SetSect(ENDOFCHAIN);
    //SetSect() contains assertions to verify sortedness of the list,
    //which we don't want here.
    _sect = ENDOFCHAIN;
    SetFlags(0);
    SetVector(NULL);
    _cReferences = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::GetNewPage, private
//
//  Synopsis:	Insert a new page into the list and return a pointer to it.
//
//  Arguments:	None.
//
//  Returns:	Pointer to new page.  Null if there was an allocation error.
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

inline CMSFPage * CMSFPageTable::GetNewPage(void)
{
#ifndef SORTPAGETABLE    
#if DBG == 1
    return new (_pmsParent->GetMalloc(), (size_t)_cbSector)
               CMSFPage(BP_TO_P(CMSFPage *, _pmpCurrent), this);
#else
    return new (_pmsParent->GetMalloc(), (size_t)_cbSector)
               CMSFPage(BP_TO_P(CMSFPage *, _pmpCurrent));
#endif
#else
#if DBG == 1
    return new (_pmsParent->GetMalloc(), (size_t)_cbSector)
               CMSFPage(BP_TO_P(CMSFPage *, _pmpStart), this);
#else
    return new (_pmsParent->GetMalloc(), (size_t)_cbSector)
               CMSFPage(BP_TO_P(CMSFPage *, _pmpStart));
#endif
#endif //SORTPAGETABLE    
}

//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::~CMSFPageTable, public
//
//  Synopsis:	CMSFPageTable destructor
//
//  History:	26-Oct-92	PhilipLa	Created
//		21-Jul-95	SusiA		Modified to delete the object without
//						obtaining the mutex.  Calling functions
//						should have locked the mutex first.
//
//----------------------------------------------------------------------------

CMSFPageTable::~CMSFPageTable()
{
    if (_pmpCurrent != NULL)
    {
        CMSFPage *pmp = BP_TO_P(CMSFPage *, _pmpCurrent);
        CMSFPage *pmpNext;

        while (pmp != pmp->GetNext())
        {
            pmpNext = pmp->GetNext();
            msfAssert(pmpNext != NULL &&
                      aMsg("NULL found in page table circular list."));
#if DBG == 1
            msfAssert(!pmp->IsInUse() &&
                    aMsg("Active page left at page table destruct time."));

            if (!_pmsParent->IsScratch())
            {
                //Dirty paged can be thrown away if we are unconverted or
                //   in a commit.
                if ((!_pmsParent->IsUnconverted()) &&
                    (_pmsParent->GetParentSize() == 0))
                {
                    msfAssert(!pmp->IsDirty() &&
                        aMsg("Dirty page left at page table destruct time."));
                }
            }
#endif
            pmp->~CMSFPage();
	    pmp->deleteNoMutex(pmp);
            	    
	    pmp = pmpNext;
        }
        pmp->~CMSFPage();
        pmp->deleteNoMutex(pmp);
	
	
    }
#if DBG == 1
    msfDebugOut((DEB_ITRACE,
            "Page Table Max Page Count for %s: %lu\n",
            (_pmsParent->IsScratch()) ? "Scratch" : "Base",
            _cMaxPageRef));
#endif

}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::Init, public
//
//  Synopsis:	Initialize a CMSFPageTable
//
//  Arguments:	[cPages] -- Number of pages to preallocate.
//
//  Returns:	Appropriate status code
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::Init(void)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE, "In  CMSFPageTable::Init:%p()\n", this));

    for (ULONG i = 0; i < _cMinPages; i++)
    {
        CMSFPage *pmp;

        msfMem(pmp = GetNewPage());
#ifndef SORTPAGETABLE        
        _pmpCurrent = P_TO_BP(CBasedMSFPagePtr, pmp);
#else
        _pmpStart = P_TO_BP(CBasedMSFPagePtr, pmp);
#endif        
    }
    _cPages = _cMinPages;
    _cActivePages = 0;
#ifdef SORTPAGETABLE
    _pmpCurrent = _pmpStart;
#endif

    msfDebugOut((DEB_ITRACE, "Out CMSFPageTable::Init\n"));

 Err:

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FlushPage, public
//
//  Synopsis:	Flush a page
//
//  Arguments:	[pmp] -- Pointer to page to flush
//
//  Returns:	Appropriate status code
//
//  History:	09-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::FlushPage(CMSFPage *pmp)
{
    SCODE sc = S_OK;

    pmp->AddRef();

    CMStream *pms;
    pms = pmp->GetVector()->GetParent();

    //Flush the page, reset the dirty bit.

    msfAssert((pmp->GetSect() != ENDOFCHAIN) &&
            aMsg("Page location not set - don't know where to flush to."));
    msfAssert (pms != NULL);

    ULONG ulRet;

    ILockBytes *pilb;
#if DBG == 1
    if ((pmp->GetSid() == SIDFAT) && (pms->IsInCOW()))
    {
        msfDebugOut((DEB_ITRACE, "** Fat sect %lu written to %lX\n",
                pmp->GetOffset(), pmp->GetSect()));
    }
    if ((pmp->GetSid() == SIDDIF) && (pms->IsInCOW()))
    {
        msfDebugOut((DEB_ITRACE, "** DIF sect %lu written to %lX\n",
                pmp->GetOffset(), pmp->GetSect()));
    }

#endif
    ULARGE_INTEGER ul;
#ifdef LARGE_DOCFILE
    ul.QuadPart = ConvertSectOffset(
            pmp->GetSect(),
            0,
            pms->GetSectorShift());
#else
    ULISet32(ul, ConvertSectOffset(
            pmp->GetSect(),
            0,
            pms->GetSectorShift()));
#endif

    pilb = pms->GetILB();

    msfAssert(!pms->IsUnconverted() &&
            aMsg("Tried to flush page to unconverted base."));

    sc = GetScode(pilb->WriteAt(ul,
                                (BYTE *)(pmp->GetData()),
                                _cbSector,
                                &ulRet));
    if (sc == E_PENDING)
    {
        sc = STG_E_PENDINGCONTROL;
    }
    msfChk(sc);

    pmp->ResetDirty();

 Err:
    pmp->Release();
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::GetFreePage, public
//
//  Synopsis:	Return a pointer to a free page.
//
//  Arguments:	[ppmp] -- Pointer to storage for return pointer
//
//  Returns:	Appropriate status code
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::GetFreePage(CMSFPage **ppmp)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;
    if (_cPages > _cActivePages)
    {
        //We have some unused page already allocated.  Find and return it.
        pmp = BP_TO_P(CMSFPage *, _pmpCurrent);

        do
        {
            pmp = pmp->GetNext();
        }
        while ((pmp != _pmpCurrent) && (pmp->GetSid() != NOSTREAM));

        msfAssert((pmp->GetSid() == NOSTREAM) &&
                aMsg("Expected empty page, none found."));

        *ppmp = pmp;
        _cActivePages++;
    }
    else if (_cPages == _cMaxPages)
    {
        msfMem(pmp = FindSwapPage());
        msfDebugOut((DEB_ITRACE, "Got swap page %p\n",pmp));

        msfAssert((pmp->GetVector() != NULL) &&
                aMsg("FindSwapPage returned unowned page."));

        msfDebugOut((DEB_ITRACE, "Freeing page %lu from vector %p\n",
                pmp->GetOffset(), pmp->GetVector()));


        if (pmp->IsDirty())
        {
            msfChk(FlushPage(pmp));
            msfAssert(!pmp->IsDirty() &&
                    aMsg("Page remained dirty after flush call"));
        }

        pmp->GetVector()->FreeTable(pmp->GetOffset());
#if DBG == 1
        pmp->SetVector(NULL);
#endif
        *ppmp = pmp;
    }
    else
    {
        //Create a new page and return it.
        pmp = GetNewPage();
        if (pmp != NULL)
        {
            *ppmp = pmp;
            _cActivePages++;
            _cPages++;
        }
        else
        {
            msfMem(pmp = FindSwapPage());
            if (pmp->IsDirty())
            {
                msfChk(FlushPage(pmp));
                msfAssert(!pmp->IsDirty() &&
                        aMsg("Page remained dirty after flush call"));
            }
            if (pmp->GetVector() != NULL)
                pmp->GetVector()->FreeTable(pmp->GetOffset());
#if DBG == 1
            pmp->SetVector(NULL);
#endif
            *ppmp = pmp;
        }
    }

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FindPage, public
//
//  Synopsis:	Find and return a given page
//
//  Arguments:  [ppv] -- Pointer to vector of page to return
//              [sid] -- SID of page to return
//              [ulOffset] -- Offset of page to return
//              [ppmp] -- Location to return pointer
//
//  Returns:	Appropriate status code
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::FindPage(
        CPagedVector *ppv,
        SID sid,
        ULONG ulOffset,
        CMSFPage **ppmp)
{
    SCODE sc;
    CMSFPage *pmp = BP_TO_P(CMSFPage *, _pmpCurrent);

    do
    {
        if ((pmp->GetVector() == ppv) && (pmp->GetOffset() == ulOffset))
        {
            //Bingo!

            *ppmp = pmp;
            return STG_S_FOUND;
        }

        pmp = pmp->GetNext();
    }
    while (pmp != _pmpCurrent);

    //The page isn't currently in memory.  Get a free page and
    //bring it into memory.

    msfChk(GetFreePage(&pmp));

    msfAssert((pmp->GetVector() == NULL) &&
            aMsg("Attempting to reassign owned page."));
    pmp->SetVector(ppv);
    pmp->SetSid(sid);
    pmp->SetOffset(ulOffset);
#ifdef SORTPAGETABLE
    SetSect(pmp, ENDOFCHAIN);
#else    
    pmp->SetSect(ENDOFCHAIN);
#endif
    
    *ppmp = pmp;

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::GetPage, public
//
//  Synopsis:	Find and return a given page
//
//  Arguments:	[sid] -- SID of page to return
//              [ulOffset] -- Offset of page to return
//              [ppmp] -- Location to return pointer
//
//  Returns:	Appropriate status code
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::GetPage(
        CPagedVector *ppv,
        SID sid,
        ULONG ulOffset,
        SECT sectKnown,
        CMSFPage **ppmp)
{
    SCODE sc;

    *ppmp = NULL;
    msfChk(FindPage(ppv, sid, ulOffset, ppmp));

    (*ppmp)->AddRef();

    if (sc != STG_S_FOUND)
    {
        ULONG ulRet;
        SECT sect;

        if (sectKnown != ENDOFCHAIN)
        {
            sect = sectKnown;
        }
        else
        {
            msfChk(ppv->GetParent()->GetSect(sid, ulOffset, &sect));
        }
#ifdef SORTPAGETABLE
        SetSect(*ppmp, sect);
#else        
        (*ppmp)->SetSect(sect);
#endif        

        CMStream *pms = (*ppmp)->GetVector()->GetParent();
#if DBG == 1
        if ((sid == SIDFAT) && (pms->IsInCOW()))
        {
            msfDebugOut((DEB_ITRACE, "Fat sect %lu read from %lX\n",
                    ulOffset, sect));
        }
        if ((sid == SIDDIF) && (pms->IsInCOW()))
        {
            msfDebugOut((DEB_ITRACE, "DIF sect %lu read from %lX\n",
                    ulOffset, sect));
        }

#endif

        ULARGE_INTEGER ul;
#ifdef LARGE_DOCFILE
        ul.QuadPart = ConvertSectOffset(
                (*ppmp)->GetSect(),
                0,
                pms->GetSectorShift());
#else
        ULISet32(ul, ConvertSectOffset(
                (*ppmp)->GetSect(),
                0,
                pms->GetSectorShift()));
#endif

        msfAssert(pms->GetILB() != NULL &&
                  aMsg("NULL ILockBytes - missing SetAccess?"));

        sc = GetScode(pms->GetILB()->ReadAt(ul,
                                            (BYTE *)((*ppmp)->GetData()),
                                            _cbSector,
                                            &ulRet));
        if (sc == E_PENDING)
        {
            sc = STG_E_PENDINGCONTROL;
        }
        msfChk(sc);
        
        if (ulRet != _cbSector)
        {
                //  09/23/93 - No error, but insufficient bytes read
                sc = STG_E_READFAULT;
        }
    }

Err:
    if (*ppmp != NULL)
    {
        if (FAILED(sc))
        {
            //  09/19/93 - Reset page so that we don't accidentally use it

            (*ppmp)->SetSid(NOSTREAM);
            (*ppmp)->SetOffset(0);
#ifdef SORTPAGETABLE
            SetSect(*ppmp, ENDOFCHAIN);
#else
            (*ppmp)->SetSect(ENDOFCHAIN);
#endif            
            (*ppmp)->SetFlags(0);
            (*ppmp)->SetVector(NULL);
            _cActivePages--;
        }
        (*ppmp)->Release();
    }

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::ReleasePage, public
//
//  Synopsis:	Release a given page
//
//  Arguments:	[sid] -- SID of page to release
//              [ulOffset] -- Offset of page to release
//
//  History:	28-Oct-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CMSFPageTable::ReleasePage(CPagedVector *ppv,
                                SID sid, ULONG ulOffset)
{
    SCODE sc;
    CMSFPage *pmp;

    sc = FindPage(ppv, sid, ulOffset, &pmp);

    if (SUCCEEDED(sc))
    {
        pmp->Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::Flush, public
//
//  Synopsis:	Flush dirty pages to disk
//
//  Returns:	Appropriate status code
//
//  History:	02-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::Flush(void)
{
#ifndef SORTPAGETABLE
    SCODE sc = S_OK;

    CMSFPage *pmp = BP_TO_P(CMSFPage *, _pmpCurrent);

    //We use pmpLast in case FlushPage changes _pmpCurrent.
    CMSFPage *pmpLast = pmp;

    do
    {
        if ((pmp->IsDirty()) && !(pmp->IsInUse()) &&
            !(pmp->GetVector()->GetParent()->IsScratch()))
        {
            msfChk(FlushPage(pmp));
        }

        pmp = pmp->GetNext();

    }
    while (pmp != pmpLast);

 Err:
    return sc;
#else
    SCODE sc = S_OK;
    msfDebugOut((DEB_ITRACE, "In CMSFPageTable::Flush()\n"));

    CMSFPage *pmp;
    CMSFPage *pmpStart;
    BYTE *pb = NULL;
    ULONG ulBufferSize = 0;

    pmpStart = BP_TO_P(CMSFPage *, _pmpStart);
    pmp = pmpStart;
    do
    {
        CMSFPage *pmpFirst = NULL;
        CMSFPage *pmpLast = NULL;

        //Find first page that needs to be flushed.
        while (!pmp->IsFlushable())
        {
            pmp = pmp->GetNext();
            if (pmp == pmpStart)
                break;
        }

        //If we haven't hit the end of the list, then find a contiguous
        //   range of pages to flush.
        if (pmp->IsFlushable())
        {
            pmpFirst = pmp;
            //Store pointer to last page in range in pmpLast.
            while (pmp->IsFlushable())
            {
                pmpLast = pmp;
                pmp = pmp->GetNext();
                if (pmp->GetSect() != pmpLast->GetSect() + 1)
                {
                    break;
                }
            }
            //At this point, we can flush everything from pmpFirst to
            //  pmpLast, and they are all contiguous.  pmp points to the
            //  next sector after the current range.

            if (pmpFirst == pmpLast)
            {
                msfDebugOut((DEB_ITRACE,
                             "Flushing page to %lx\n",
                             pmpFirst->GetSect()));
                
                //Only one page:  Call FlushPage.
                msfChk(FlushPage(pmpFirst));
            }
            else
            {
                ULONG ulWriteSize;
                ULONG cSect;
                CMSFPage *pmpTemp;
                ULONG i;

                msfDebugOut((DEB_ITRACE,
                             "Flushing pages from %lx to %lx\n",
                             pmpFirst->GetSect(),
                             pmpLast->GetSect()));
                
                cSect = pmpLast->GetSect() - pmpFirst->GetSect() + 1;
                ulWriteSize = cSect * _cbSector;
                
                if (ulWriteSize > ulBufferSize)
                {
                    delete [] pb;
                    pb = new BYTE[ulWriteSize];
                    ulBufferSize = ulWriteSize;
                }

                pmpTemp = pmpFirst;
                if (pb == NULL)
                {
                    ulBufferSize = 0;
                    
                    //Low memory case - write out pages one at a time
                    for (i = 0; i < cSect; i++)
                    {
                        msfChk(FlushPage(pmpTemp));
                        pmpTemp = pmpTemp->GetNext();
                    }
                }
                else
                {
                    for (i = 0; i < cSect; i++)
                    {
                        memcpy(pb + (i * _cbSector),
                               pmpTemp->GetData(),
                               _cbSector);
                        pmpTemp = pmpTemp->GetNext();
                    }
                    //The buffer is loaded up - now write it out.
                    ULARGE_INTEGER ul;
                    ULONG cbWritten;
                    ULONG cbTotal = 0;
                    BYTE *pbCurrent = pb;
#ifdef LARGE_DOCFILE
                    ul.QuadPart = ConvertSectOffset(pmpFirst->GetSect(),
                                                  0,
                                                 _pmsParent->GetSectorShift());
#else
                    ULISet32(ul, ConvertSectOffset(pmpFirst->GetSect(),
                                                  0,
                                                 _pmsParent->GetSectorShift()));
#endif
                    while (cbTotal < ulWriteSize)
                    {
                        sc = _pmsParent->GetILB()->WriteAt(ul,
                                                       pbCurrent,
                                                       ulWriteSize - cbTotal,
                                                       &cbWritten);
                        if (sc == E_PENDING)
                        {
                            sc = STG_E_PENDINGCONTROL;
                        }
                        msfChk(sc);
                        if (cbWritten == 0)
                        {
                            msfErr(Err, STG_E_WRITEFAULT);
                        }
                        cbTotal += cbWritten;
                        pbCurrent += cbWritten;
                        ul.QuadPart += cbWritten;
                    }
                
                    //Mark all the pages as clean.
                    pmpTemp = pmpFirst;
                    for (i = 0; i < cSect; i++)
                    {
                        pmpTemp->ResetDirty();
                        pmpTemp = pmpTemp->GetNext();
                    }
                }
            }            
        }
        else
        {
            //We've hit the end of the list, do nothing.
        }
    }
    while (pmp != pmpStart);
    msfDebugOut((DEB_ITRACE, "Out CMSFPageTable::Flush() => %lX\n", sc));
Err:
    if (pb != NULL)
    {
        delete [] pb;
    }
    return sc;
#endif //SORTPAGETABLE    
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FreePages, public
//
//  Synopsis:	Free all the pages associated with a vector.
//
//  Arguments:	[ppv] -- Pointer to vector to free pages for.
//
//  History:	09-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CMSFPageTable::FreePages(CPagedVector *ppv)
{
    CMSFPage *pmp = BP_TO_P(CMSFPage *, _pmpCurrent);

    do
    {
        if (pmp->GetVector() == ppv)
        {
            pmp->SetSid(NOSTREAM);
            pmp->SetVector(NULL);
            pmp->ResetDirty();
            _cActivePages--;
        }
        pmp = pmp->GetNext();
    }
    while (pmp != _pmpCurrent);

}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FindSwapPage, private
//
//  Synopsis:	Find a page to swap out.
//
//  Arguments:	None.
//
//  Returns:	Pointer to page to swap out.
//
//  History:	22-Oct-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

CMSFPage * CMSFPageTable::FindSwapPage(void)
{
#if DBG == 1
    ULONG cpInUse = 0;
#endif

    while (TRUE)
    {
        if (!_pmpCurrent->IsInUse())
        {
            DWORD dwFlags;

            dwFlags = _pmpCurrent->GetFlags();
            _pmpCurrent->SetFlags(dwFlags & ~FB_TOUCHED);
            
            CMSFPage *pmpTemp = _pmpCurrent->GetNext();
            _pmpCurrent = P_TO_BP(CBasedMSFPagePtr, pmpTemp);

            if (!(dwFlags & FB_TOUCHED))
            {
                return _pmpCurrent->GetPrev();
            }
        }
        else
        {
            CMSFPage *pmpTemp = _pmpCurrent->GetNext();
            _pmpCurrent = P_TO_BP(CBasedMSFPagePtr, pmpTemp);
        }
#if DBG == 1
        cpInUse++;
        msfAssert((cpInUse < 3 * _cPages) &&
                aMsg("No swappable pages."));
#endif

    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::CopyPage, public
//
//  Synopsis:	Copy a page in memory, returning NULL if there is
//              insufficient space for a new page without swapping.
//
//  Arguments:	[ppv] -- Pointer to vector that will own the copy.
//              [pmpOld] -- Pointer to page to copy.
//              [ppmp] -- Pointer to return value
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	04-Dec-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::CopyPage(
        CPagedVector *ppv,
        CMSFPage *pmpOld,
        CBasedMSFPagePtr *ppmp)
{
    CMSFPage *pmp;

    pmp = NULL;

    if (pmpOld != NULL)
    {
        msfAssert(!pmpOld->IsDirty() &&
                aMsg("Copying dirty page."));

        if (_cPages > _cActivePages)
        {

            //We have some unused page already allocated.  Find and return it.
            pmp = BP_TO_P(CMSFPage *, _pmpCurrent);

            do
            {
                pmp = pmp->GetNext();
            }
            while ((pmp != _pmpCurrent) && (pmp->GetSid() != NOSTREAM));


            msfAssert((pmp->GetSid() == NOSTREAM) &&
                    aMsg("Expected empty page, none found."));
            _cActivePages++;

        }
        else if (_cPages < _cMaxPages)
        {
            //Create a new page and return it.
            pmp = GetNewPage();
            if (pmp != NULL)
            {
                _cActivePages++;
                _cPages++;
            }
        }

        if (pmp != NULL)
        {
            msfAssert((pmp->GetVector() == NULL) &&
                    aMsg("Attempting to reassign owned page."));
            pmp->SetVector(ppv);
            pmp->SetSid(pmpOld->GetSid());
            pmp->SetOffset(pmpOld->GetOffset());
#ifdef SORTPAGETABLE
            SetSect(pmp, pmpOld->GetSect());
#else            
            pmp->SetSect(pmpOld->GetSect());
#endif            

            memcpy(pmp->GetData(), pmpOld->GetData(), (USHORT)_cbSector);
        }
    }

    *ppmp = P_TO_BP(CBasedMSFPagePtr, pmp);

    return S_OK;
}


#if DBG == 1

void CMSFPageTable::AddPageRef(void)
{
    msfAssert((LONG) _cCurrentPageRef >= 0);
    _cCurrentPageRef++;
    if (_cCurrentPageRef > _cMaxPageRef)
    {
        _cMaxPageRef = _cCurrentPageRef;
    }
}

void CMSFPageTable::ReleasePageRef(void)
{
    _cCurrentPageRef--;
    msfAssert((LONG) _cCurrentPageRef >= 0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\mstream.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:           mstream.cxx
//
//  Contents:       Mstream operations
//
//  Classes:        None. (defined in mstream.hxx)
//
//  History:        18-Jul-91   Philipla    Created.
//
//--------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <dirfunc.hxx>
#include <sstream.hxx>
#include <difat.hxx>
#include <time.h>
#include <mread.hxx>
#include <docfilep.hxx>
#include <df32.hxx>
#include <smalloc.hxx>
#include <filelkb.hxx>


#if DBG == 1
DECLARE_INFOLEVEL(msf)
#endif

#define MINPAGES 6 
#define MAXPAGES 128

#define MINPAGESSCRATCH 2
#define MAXPAGESSCRATCH 16

//#define SECURETEST

const WCHAR wcsContents[] = L"CONTENTS";  //Name of contents stream for
                                         // conversion
const WCHAR wcsRootEntry[] = L"Root Entry";  //Name of root directory
                                            // entry

SCODE ILBFlush(ILockBytes *pilb, BOOL fFlushCache);

//+---------------------------------------------------------------------------
//
//  Function:	GetBuffer, public
//
//  Synopsis:	Gets a chunk of memory to use as a buffer
//
//  Arguments:	[cbMin] - Minimum size for buffer
//              [cbMax] - Maximum size for buffer
//              [ppb] - Buffer pointer return
//              [pcbActual] - Actual buffer size return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[ppb]
//              [pcbActual]
//
//  Algorithm:  Attempt to dynamically allocate [cbMax] bytes
//              If that fails, halve allocation size and retry
//              If allocation size falls below [cbMin], fail
//
//  History:	04-Mar-93	DrewB	Created
//
//  Notes:	Buffer should be released with FreeBuffer
//
//----------------------------------------------------------------------------


SCODE GetBuffer(ULONG cbMin, ULONG cbMax, BYTE **ppb, ULONG *pcbActual)
{
    ULONG cbSize;
    BYTE *pb;

    msfDebugOut((DEB_ITRACE, "In  GetBuffer(%u, %u, %p, %p)\n",
                 cbMin, cbMax, ppb, pcbActual));
    msfAssert(cbMin > 0);
    msfAssert(cbMax >= cbMin);
    msfAssert(ppb != NULL);
    msfAssert(pcbActual != NULL);

    cbSize = cbMax;
    for (;;)
    {
        pb = (BYTE *) DfMemAlloc(cbSize);
        if (pb == NULL)
        {
            cbSize >>= 1;
            if (cbSize < cbMin)
                break;
        }
        else
        {
            *pcbActual = cbSize;
            break;
        }
    }

    *ppb = pb;

    msfDebugOut((DEB_ITRACE, "Out GetBuffer => %p, %u\n", *ppb, *pcbActual));
    return pb == NULL ? STG_E_INSUFFICIENTMEMORY : S_OK;
}

// Define the safe buffer size
//#define SCRATCHBUFFERSIZE SCRATCHSECTORSIZE
BYTE s_bufSafe[SCRATCHBUFFERSIZE];
LONG s_bufSafeRef = 0;



// Critical Section will be initiqalized in the shared memory allocator
// constructor and deleted in the SmAllocator destructor
CRITICAL_SECTION g_csScratchBuffer;

//+---------------------------------------------------------------------------
//
//  Function:	GetSafeBuffer, public
//
//  Synopsis:	Gets a buffer by first trying GetBuffer and if that fails,
//              returning a pointer to statically allocated storage.
//              Guaranteed to return a pointer to some storage.
//
//  Arguments:	[cbMin] - Minimum buffer size
//              [cbMax] - Maximum buffer size
//              [ppb] - Buffer pointer return
//              [pcbActual] - Actual buffer size return
//
//  Modifies:	[ppb]
//              [pcbActual]
//
//  History:	04-Mar-93	DrewB	Created
//
//----------------------------------------------------------------------------


void GetSafeBuffer(ULONG cbMin, ULONG cbMax, BYTE **ppb, ULONG *pcbActual)
{
    msfAssert(cbMin > 0);
    msfAssert(cbMin <= SCRATCHBUFFERSIZE &&
              aMsg("Minimum too large for GetSafeBuffer"));
    msfAssert(cbMax >= cbMin);
    msfAssert(ppb != NULL);

    // We want to minimize contention for the
    // static buffer so we always try dynamic allocation, regardless
    // of the size
    if (
        FAILED(GetBuffer(cbMin, cbMax, ppb, pcbActual)))
    {

		EnterCriticalSection(&g_csScratchBuffer);
        msfAssert(s_bufSafeRef == 0 &&
                  aMsg("Tried to use scratch buffer twice"));
        s_bufSafeRef = 1;
        *ppb = s_bufSafe;
        *pcbActual = min(cbMax, SCRATCHBUFFERSIZE);
    }
    msfAssert(*ppb != NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:	FreeBuffer, public
//
//  Synopsis:	Releases a buffer allocated by GetBuffer or GetSafeBuffer
//
//  Arguments:	[pb] - Buffer
//
//  History:	04-Mar-93	DrewB	Created
//
//----------------------------------------------------------------------------


void FreeBuffer(BYTE *pb)
{
    if (pb == s_bufSafe)
    {
        msfAssert((s_bufSafeRef == 1) && aMsg("Bad safe buffer ref count"));
        s_bufSafeRef = 0;
        LeaveCriticalSection(&g_csScratchBuffer);
    }
    else
        DfMemFree(pb);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::CMStream, public
//
//  Synopsis:   CMStream constructor
//
//  Arguments:  [pplstParent] -- Pointer to ILockBytes pointer of parent
//              [plGen] -- Pointer to LUID Generator to use.
//                         Note:  May be NULL, in which case a new
//              [uSectorShift] -- Sector shift for this MStream
//
//  History:    18-Jul-91   PhilipLa    Created.
//              05-Sep-95   MikeHill    Initialize '_fMaintainFLBModifyTimestamp'.
//              26-Apr-99   RogerCh     Removed _fMaintainFLBModifyTimestamp
//
//--------------------------------------------------------------------------



CMStream::CMStream(
        IMalloc *pMalloc,
        ILockBytes **pplstParent,
	BOOL fIsScratch,
#if defined(USE_NOSCRATCH) || defined(USE_NOSNAPSHOT)
        DFLAGS df,
#endif
        USHORT uSectorShift)
:_uSectorShift(uSectorShift),
 _uSectorSize(1 << uSectorShift),
 _uSectorMask(_uSectorSize - 1),
 _pplstParent(P_TO_BP(CBasedILockBytesPtrPtr, pplstParent)),
 _fIsScratch(fIsScratch),
 _fIsNoScratch(P_NOSCRATCH(df)),
 _pmsScratch(NULL),
 _fIsNoSnapshot(P_NOSNAPSHOT(df)),
 _hdr(uSectorShift),
 _fat(SIDFAT),
 _fatMini(SIDMINIFAT),
 _pMalloc(pMalloc)
{
    _pmsShadow = NULL;
    _pCopySectBuf = NULL;
#if DBG == 1
    _uBufferRef = 0;
#endif
    _fIsShadow = FALSE;

    _ulParentSize = 0;

    _pdsministream = NULL;
    _pmpt = NULL;
    _fBlockWrite = _fTruncate = _fBlockHeader = _fNewConvert = FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::CMStream, public
//
//  Synopsis:   CMStream copy constructor
//
//  Arguments:  [ms] -- MStream to copy
//
//  History:    04-Nov-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


CMStream::CMStream(const CMStream *pms)
:_uSectorShift(pms->_uSectorShift),
 _uSectorSize(pms->_uSectorSize),
 _uSectorMask(pms->_uSectorMask),
 _pplstParent(pms->_pplstParent),
 _fIsScratch(pms->_fIsScratch),
 _hdr(*(CMSFHeader *)&pms->_hdr),
 _dir(*(CDirectory *)pms->GetDir()),
 _fat(pms->GetFat()),
 _fatMini(pms->GetMiniFat()),
 _fatDif(pms->GetDIFat()),
 _pdsministream(pms->_pdsministream),
 _pmpt(pms->_pmpt),
 _fBlockWrite(pms->_fBlockWrite),
 _fTruncate(pms->_fTruncate),
 _fBlockHeader(pms->_fBlockHeader),
 _fNewConvert(pms->_fNewConvert),
 _pmsShadow(NULL),
 _fIsShadow(TRUE),
 _pMalloc(pms->_pMalloc)
{
    _pCopySectBuf = pms->_pCopySectBuf;
#if DBG == 1
    _uBufferRef = pms->_uBufferRef;
#endif
    _dir.SetParent(this);
    _fat.SetParent(this);
    _fatMini.SetParent(this);
    _fatDif.SetParent(this);

    _ulParentSize = 0;
    _pmpt->AddRef();
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::InitCommon, private
//
//  Synopsis:   Common code for initialization routines.
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    20-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


SCODE CMStream::InitCommon(VOID)
{
    msfDebugOut((DEB_ITRACE,"In CMStream InitCommon()\n"));
    SCODE sc = S_OK;

#ifdef SECURE_BUFFER
    memset(s_bufSecure, SECURECHAR, MINISTREAMSIZE);
#endif

    CMSFPageTable *pmpt;
    msfMem(pmpt = new (GetMalloc()) CMSFPageTable(
            this,
            (_fIsScratch) ? MINPAGESSCRATCH: MINPAGES,
            (_fIsScratch) ? MAXPAGESSCRATCH: MAXPAGES));
    _pmpt = P_TO_BP(CBasedMSFPageTablePtr, pmpt);

    msfChk(pmpt->Init());
    if (!_fIsScratch)
    {
        CMStream *pms;
        msfMem(pms = (CMStream *) new (GetMalloc()) CMStream(this));
        _pmsShadow = P_TO_BP(CBasedMStreamPtr, pms);
    }

    _stmcDir.Init(this, SIDDIR, NULL);
    _stmcMiniFat.Init(this, SIDMINIFAT, NULL);

    msfDebugOut((DEB_ITRACE,"Leaving CMStream InitCommon()\n"));

Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::InitCopy, public
//
//  Synopsis:	Copy the structures from one multistream to yourself
//
//  Arguments:	[pms] -- Pointer to multistream to copy.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------


void CMStream::InitCopy(CMStream *pms)
{
    _stmcDir.Init(this, SIDDIR, NULL);
    _stmcMiniFat.Init(this, SIDMINIFAT, NULL);

    _fat.InitCopy(pms->GetFat());
    _fatMini.InitCopy(pms->GetMiniFat());
    _fatDif.InitCopy(pms->GetDIFat());
    _dir.InitCopy(pms->GetDir());

    _dir.SetParent(this);
    _fat.SetParent(this);
    _fatMini.SetParent(this);
    _fatDif.SetParent(this);

    memcpy(&_hdr, pms->GetHeader(), sizeof(CMSFHeader));
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::Empty, public
//
//  Synopsis:	Empty all of the control structures of this CMStream
//
//  Arguments:	None.
//
//  Returns:	void.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


void CMStream::Empty(void)
{
    _fat.Empty();
    _fatMini.Empty();
    _fatDif.Empty();
    _dir.Empty();
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::~CMStream, public
//
//  Synopsis:   CMStream destructor
//
//  History:    18-Jul-91   PhilipLa    Created.
//		20-Jul-95   SusiA	Modified to eliminate mutex in allocator
//					Caller must already have the mutex.
//
//--------------------------------------------------------------------------


CMStream::~CMStream()
{

    msfDebugOut((DEB_ITRACE,"In CMStream destructor\n"));



    if (_pmsShadow != NULL)
    {
	_pmsShadow->~CMStream();
        _pmsShadow->deleteNoMutex (BP_TO_P(CMStream *, _pmsShadow));
    }	

#if DBG == 1
    msfAssert((_uBufferRef == 0) &&
            aMsg("CopySect buffer left with positive refcount."));
#endif
      g_smAllocator.FreeNoMutex(BP_TO_P(BYTE *, _pCopySectBuf));


    if ((!_fIsShadow) && (_pdsministream != NULL))
    {
            _pdsministream->Release();
    }

    if (_pmpt != NULL)
    {
        _pmpt->Release();
    }

    msfDebugOut((DEB_ITRACE,"Leaving CMStream destructor\n"));
}


//+-------------------------------------------------------------------------
//
//  Member:     CMStream::Init, public
//
//  Synposis:   Set up an mstream instance from an existing stream
//
//  Effects:    Modifies Fat and Directory
//
//  Arguments:  void.
//
//  Returns:    S_OK if call completed OK.
//              Error of Fat or Dir setup otherwise.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CMStream::Init(VOID)
{
    ULONG ulTemp;
    SCODE sc;
    ULARGE_INTEGER ulOffset;


    msfDebugOut((DEB_ITRACE,"In CMStream::Init()\n"));

    msfAssert(!_fIsScratch &&
            aMsg("Called Init() on scratch multistream."));

    ULONG ulSectorSize = HEADERSIZE;
    IFileLockBytes *pfl;
    if (SUCCEEDED((*_pplstParent)->QueryInterface(IID_IFileLockBytes, 
                                                 (void**) &pfl)))
    {
        ulSectorSize = pfl->GetSectorSize();
        pfl->Release();
    }

    ULISet32(ulOffset, 0);

    if (ulSectorSize == sizeof(CMSFHeaderData))
    {
        sc = (*_pplstParent)->ReadAt(ulOffset, (BYTE *)_hdr.GetData(),
                                    sizeof(CMSFHeaderData), &ulTemp);
    }
    else
    {
        void *pvBuf = TaskMemAlloc(ulSectorSize);
        msfMem(pvBuf);
        sc = (*_pplstParent)->ReadAt(ulOffset, pvBuf, ulSectorSize, &ulTemp);
        if (SUCCEEDED(sc) && ulTemp >= sizeof(CMSFHeaderData))
            memcpy (_hdr.GetData(), pvBuf, sizeof(CMSFHeaderData));
        TaskMemFree (pvBuf);
    }

    if (sc == E_PENDING)
    {
        sc = STG_E_PENDINGCONTROL;
    }
    msfChk(sc);

    //We need to mark the header as not dirty, since the constructor
    //   defaults it to the dirty state.  This needs to happen before
    //   any possible failures, otherwise we can end up writing a
    //   brand new header over an existing file.
    _hdr.ResetDirty();

    _uSectorShift = _hdr.GetSectorShift();
    _uSectorSize = 1 << _uSectorShift;
    _uSectorMask = _uSectorSize - 1;

    if (ulTemp != ulSectorSize)
    {
        msfErr(Err,STG_E_INVALIDHEADER);
    }

    msfChk(_hdr.Validate());

    msfChk(InitCommon());

    msfChk(_fatDif.Init(this, _hdr.GetDifLength()));
    msfChk(_fat.Init(this, _hdr.GetFatLength(), 0));

    FSINDEX fsiLen;
    if (_uSectorShift > SECTORSHIFT512)
        fsiLen = _hdr.GetDirLength ();
    else
        msfChk(_fat.GetLength(_hdr.GetDirStart(), &fsiLen));
    msfChk(_dir.Init(this, fsiLen));

    msfChk(_fatMini.Init(this, _hdr.GetMiniFatLength(), 0));

    BYTE *pbBuf;

    msfMem(pbBuf = (BYTE *) GetMalloc()->Alloc(GetSectorSize()));
    _pCopySectBuf = P_TO_BP(CBasedBytePtr, pbBuf);

#ifdef LARGE_STREAMS
    ULONGLONG ulSize;
#else
    ULONG ulSize;
#endif
    msfChk(_dir.GetSize(SIDMINISTREAM, &ulSize));
    CDirectStream *pdsTemp;

    msfMem(pdsTemp = new(GetMalloc()) CDirectStream(MINISTREAM_LUID));
    _pdsministream = P_TO_BP(CBasedDirectStreamPtr, pdsTemp);
    _pdsministream->InitSystem(this, SIDMINISTREAM, ulSize);

    msfDebugOut((DEB_ITRACE,"Out CMStream::Init()\n"));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMStream::InitNew, public
//
//  Synposis:   Set up a brand new mstream instance
//
//  Effects:    Modifies FAT and Directory
//
//  Arguments:  [fDelay] -- If TRUE, then the parent LStream
//                  will be truncated at the time of first
//                  entrance to COW, and no writes to the
//                  LStream will happen before then.
//
//  Returns:    S_OK if call completed OK.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              12-Jun-92   PhilipLa    Added fDelay.
//
//---------------------------------------------------------------------------


SCODE CMStream::InitNew(BOOL fDelay, ULARGE_INTEGER uliSize)
{
    SCODE sc;

    msfDebugOut((DEB_ITRACE,"In CMStream::InitNew()\n"));

#ifdef LARGE_DOCFILE
    ULONGLONG ulParentSize = 0;
#else
    ULONG ulParentSize = 0;
#endif

    msfChk(InitCommon());

    if (!_fIsScratch)
    {
#ifdef LARGE_DOCFILE
        ulParentSize = uliSize.QuadPart;
#else
        msfAssert (ULIGetHigh(uliSize) == 0);
        ulParentSize = ULIGetLow(uliSize);
#endif

        if (!fDelay && ulParentSize > 0)
        {
            ULARGE_INTEGER ulTmp;

            ULISet32(ulTmp, 0);
            (*_pplstParent)->SetSize(ulTmp);
        }
    }

    _fBlockWrite = (ulParentSize == 0) ? FALSE : fDelay;

    msfChk(_fatDif.InitNew(this));
    msfChk(_fat.InitNew(this));

    if (!_fIsScratch || _fIsNoScratch)
    {
        msfChk(_fatMini.InitNew(this));
    }

    if (!_fIsScratch)
    {

        msfChk(_dir.InitNew(this));

        BYTE *pbBuf;

        msfMem(pbBuf = (BYTE *) GetMalloc()->Alloc(GetSectorSize()));
        _pCopySectBuf = P_TO_BP(CBasedBytePtr, pbBuf);

#ifdef LARGE_STREAMS
        ULONGLONG ulSize;
#else
        ULONG ulSize;
#endif
        msfChk(_dir.GetSize(SIDMINISTREAM, &ulSize));

        CDirectStream *pdsTemp;

        msfMem(pdsTemp = new(GetMalloc()) CDirectStream(MINISTREAM_LUID));
        _pdsministream = P_TO_BP(CBasedDirectStreamPtr, pdsTemp);
	_pdsministream->InitSystem(this, SIDMINISTREAM, ulSize);
    }

    //If we have a zero length original file, this will create an
    //   empty Docfile on the disk.  If the original file was
    //   not zero length, then the Flush operations will be skipped
    //   by _fBlockWrite and the file will be unmodified.
    if (!_fBlockWrite)
    {
        msfChk(Flush(0));

    }

    _fTruncate = (ulParentSize != 0);
    _fBlockWrite = fDelay;


    msfDebugOut((DEB_ITRACE,"Out CMStream::InitNew()\n"));
    return S_OK;

Err:
    Empty();

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::ConvertILB, private
//
//  Synopsis:	Copy the first sector of the underlying ILockBytes
//                      out to the end.
//
//  Arguments:	[sectMax] -- Total number of sectors in the ILockBytes
//
//  Returns:	Appropriate status code
//
//  History:	03-Feb-93	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CMStream::ConvertILB(SECT sectMax)
{
    SCODE sc;
    BYTE *pb;
    ULONG cbNull;

    GetSafeBuffer(GetSectorSize(), GetSectorSize(), &pb, &cbNull);

    ULONG ulTemp;

    ULARGE_INTEGER ulTmp;
    ULISet32(ulTmp, 0);

    msfHChk((*_pplstParent)->ReadAt(ulTmp, pb, GetSectorSize(), &ulTemp));

    ULARGE_INTEGER ulNewPos;
#ifdef LARGE_DOCFILE
    ulNewPos.QuadPart = (ULONGLONG)(sectMax) << GetSectorShift();
#else
    ULISet32(ulNewPos, sectMax << GetSectorShift());
#endif

    msfDebugOut((DEB_ITRACE,"Copying first sector out to %lu\n",
            ULIGetLow(ulNewPos)));

    msfHChk((*_pplstParent)->WriteAt(
            ulNewPos,
            pb,
            GetSectorSize(),
            &ulTemp));

Err:
    FreeBuffer(pb);
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::InitConvert, public
//
//  Synopsis:   Init function used in conversion of files to multi
//              streams.
//
//  Arguments:  [fDelayConvert] -- If true, the actual file is not
//                                 touched until a BeginCopyOnWrite()
//
//  Returns:    S_OK if everything completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    28-May-92   Philipla    Created.
//
//  Notes:	We are allowed to fail here in low memory
//
//--------------------------------------------------------------------------


SCODE CMStream::InitConvert(BOOL fDelayConvert)
{
    SCODE sc;
    SECT sectMax;
    CDfName const dfnContents(wcsContents);

    msfAssert(!_fIsScratch &&
            aMsg("Called InitConvert on scratch multistream"));

    _fBlockWrite = fDelayConvert;

    msfAssert(!_fBlockWrite &&
            aMsg("Delayed conversion not supported in this release."));

    msfChk(InitCommon());

    STATSTG stat;
    msfChk((*_pplstParent)->Stat(&stat, STATFLAG_NONAME));

    msfDebugOut((DEB_ITRACE,"Size is: %lu\n",ULIGetLow(stat.cbSize)));


#ifdef LARGE_DOCFILE
    sectMax = (SECT) ((stat.cbSize.QuadPart + GetSectorSize() - 1) >>
        GetSectorShift());
#else
    sectMax = (ULIGetLow(stat.cbSize) + GetSectorSize() - 1) >>
        GetSectorShift();
#endif

    SECT sectMaxMini = 0;
    BOOL fIsMini;
    fIsMini = FALSE;

    //If the CONTENTS stream will be in the Minifat, compute
    //  the number of Minifat sectors needed.
#ifdef LARGE_DOCFILE
    if (stat.cbSize.QuadPart < MINISTREAMSIZE)
#else
    if (ULIGetLow(stat.cbSize) < MINISTREAMSIZE)
#endif
    {
        sectMaxMini = (ULIGetLow(stat.cbSize) + MINISECTORSIZE - 1) >>
            MINISECTORSHIFT;
        fIsMini = TRUE;
    }

    BYTE *pbBuf;

    msfMem(pbBuf = (BYTE *) GetMalloc()->Alloc(GetSectorSize()));
    _pCopySectBuf = P_TO_BP(CBasedBytePtr, pbBuf);

    msfChk(_fatDif.InitConvert(this, sectMax));
    msfChk(_fat.InitConvert(this, sectMax));
    msfChk(_dir.InitNew(this));
    msfChk(fIsMini ? _fatMini.InitConvert(this, sectMaxMini)
                   : _fatMini.InitNew(this));

    SID sid;

    msfChk(CreateEntry(SIDROOT, &dfnContents, STGTY_STREAM, &sid));
#ifdef LARGE_STREAMS
    msfChk(_dir.SetSize(sid, stat.cbSize.QuadPart));
#else
    msfChk(_dir.SetSize(sid, ULIGetLow(stat.cbSize)));
#endif

    if (!fIsMini)
        msfChk(_dir.SetStart(sid, sectMax - 1));
    else
    {
        msfChk(_dir.SetStart(sid, 0));
        msfChk(_dir.SetStart(SIDMINISTREAM, sectMax - 1));
#ifdef LARGE_STREAMS
        msfChk(_dir.SetSize(SIDMINISTREAM, stat.cbSize.QuadPart));
#else
        msfChk(_dir.SetSize(SIDMINISTREAM, ULIGetLow(stat.cbSize)));
#endif
    }

#ifdef LARGE_STREAMS
    ULONGLONG ulMiniSize;
#else
    ULONG ulMiniSize;
#endif
    msfChk(_dir.GetSize(SIDMINISTREAM, &ulMiniSize));

    CDirectStream *pdsTemp;

    msfMem(pdsTemp = new(GetMalloc()) CDirectStream(MINISTREAM_LUID));
    _pdsministream = P_TO_BP(CBasedDirectStreamPtr, pdsTemp);

    _pdsministream->InitSystem(this, SIDMINISTREAM, ulMiniSize);

    if (!_fBlockWrite)
    {
        msfChk(ConvertILB(sectMax));

        msfChk(Flush(0));
    }

    return S_OK;

Err:
    Empty();

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::FlushHeader, public
//
//  Synopsis:   Flush the header to the LStream.
//
//  Arguments:  [uForce] -- Flag to determine if header should be
//                          flushed while in copy on write mode.
//
//  Returns:    S_OK if call completed OK.
//              S_OK if the MStream is in copy on write mode or
//                  is Unconverted and the header was not flushed.
//
//  Algorithm:  Write the complete header out to the 0th position of
//              the LStream.
//
//  History:    11-Dec-91   PhilipLa    Created.
//              18-Feb-92   PhilipLa    Added copy on write support.
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CMStream::FlushHeader(USHORT uForce)
{
    ULONG ulTemp;
    SCODE sc;

    msfDebugOut((DEB_ITRACE,"In CMStream::FlushHeader()\n"));

    if (_fIsScratch || _fBlockWrite ||
	((_fBlockHeader) && (!(uForce & HDR_FORCE))))
    {
        return S_OK;
    }


    //If the header isn't dirty, we don't flush it unless forced to.
    if (!(uForce & HDR_FORCE) && !(_hdr.IsDirty()))
    {
        return S_OK;
    }

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);

    USHORT usSectorSize = GetSectorSize();
    if (usSectorSize == HEADERSIZE || _fIsScratch)
    {
        sc = (*_pplstParent)->WriteAt(ulOffset, (BYTE *)_hdr.GetData(),
                                             sizeof(CMSFHeaderData), &ulTemp);
    }
    else
    {
        msfAssert (_pCopySectBuf != NULL);
        memset (_pCopySectBuf, 0, usSectorSize);
        memcpy (_pCopySectBuf, _hdr.GetData(), sizeof(CMSFHeaderData));
        sc = (*_pplstParent)->WriteAt(ulOffset, _pCopySectBuf, 
                                      usSectorSize, &ulTemp);
    }

    if (sc == E_PENDING)
    {
        sc = STG_E_PENDINGCONTROL;
    }

    msfDebugOut((DEB_ITRACE,"Out CMStream::FlushHeader()\n"));
    if (SUCCEEDED(sc))
    {
        _hdr.ResetDirty();
    }
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::BeginCopyOnWrite, public
//
//  Synopsis:   Switch the multistream into copy on write mode
//
//  Effects:    Creates new in-core copies of the Fat, Directory, and
//              header.
//
//  Arguments:  None.
//
//  Requires:   The multistream cannot already be in copy on write
//              mode.
//
//  Returns:    S_OK if the call completed OK.
//              STG_E_ACCESSDENIED if multistream was already in COW mode
//
//  Algorithm:  Retrieve and store size of parent LStream.
//              If _fUnconverted & _fTruncate, call SetSize(0)
//                  on the parent LStream.
//              If _fUnconverted, then flush all control structures.
//              Copy all control structures, and switch in the shadow
//                  copies for current use.
//              Return S_OK.
//
//  History:    18-Feb-92   PhilipLa    Created.
//              09-Jun-92   PhilipLa    Added support for fUnconverted
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CMStream::BeginCopyOnWrite(DWORD const dwFlags)
{
    msfDebugOut((DEB_ITRACE,"In CMStream::BeginCopyOnWrite()\n"));

    SCODE sc;

    msfAssert(!_fBlockHeader &&
            aMsg("Tried to reenter Copy-on-Write mode."));

    msfAssert(!_fIsScratch &&
            aMsg("Tried to enter Copy-on-Write mode in scratch."));

    msfAssert(!_fIsNoScratch &&
              aMsg("Copy-on-Write started for NoScratch."));

    //_fBlockWrite is true if we have a delayed conversion or
    //          truncation.
    if (_fBlockWrite)
    {

        //In the overwrite case, we don't want to release any
        //  disk space, so we skip this step.
        if ((_fTruncate) && !(dwFlags & STGC_OVERWRITE) &&
            (_pmsScratch == NULL))
        {
	        ULARGE_INTEGER ulTmp;
            ULISet32(ulTmp, 0);
            msfHChk((*_pplstParent)->SetSize(ulTmp));
        }


        if (!(dwFlags & STGC_OVERWRITE))
        {
            _fBlockHeader = TRUE;
        }

        _fBlockWrite = FALSE;
        msfChk(Flush(0));

        _fBlockHeader = FALSE;
        _fTruncate = FALSE;
    }

    STATSTG stat;
    msfHChk((*_pplstParent)->Stat(&stat, STATFLAG_NONAME));
#ifdef LARGE_DOCFILE
    _ulParentSize = stat.cbSize.QuadPart;
    msfDebugOut((DEB_ITRACE,"Parent size at begin is %Lu\n",_ulParentSize));
#else
    msfAssert(ULIGetHigh(stat.cbSize) == 0);
    _ulParentSize = ULIGetLow(stat.cbSize);

    msfDebugOut((DEB_ITRACE,"Parent size at begin is %lu\n",_ulParentSize));
#endif

    if (_fIsNoSnapshot)
    {
        SECT sectNoSnapshot;
#ifdef LARGE_DOCFILE
        sectNoSnapshot = (SECT) ((_ulParentSize - GetSectorSize() + 
#else
        sectNoSnapshot = (SECT) ((_ulParentSize - HEADERSIZE + 
#endif
                                 GetSectorSize() - 1) / GetSectorSize());

        _fat.SetNoSnapshot(sectNoSnapshot);
    }

    //We flush out all of our current dirty pages - after this point,
    //   we know that any dirty pages should be remapped before being
    //   written out, assuming we aren't in overwrite mode.
    msfChk(Flush(0));

    if (!(dwFlags & STGC_OVERWRITE))
    {
        SECT sectTemp;

        if (_pmsScratch == NULL)
        {
            msfChk(_fat.FindMaxSect(&sectTemp));
        }
        else
        {
            msfChk(_fat.FindLast(&sectTemp));
        }

        _pmsShadow->InitCopy(this);

        _pmsShadow->_pdsministream = NULL;

        _fat.SetCopyOnWrite(_pmsShadow->GetFat(), sectTemp);

        _fBlockHeader = TRUE;
        msfChk(_fatDif.RemapSelf());

        if (_fIsNoSnapshot)
            msfChk(_fat.ResizeNoSnapshot());

        msfChk(_fatDif.Fixup(BP_TO_P(CMStream *, _pmsShadow)));

        if (_fIsNoSnapshot)
            _fat.ResetNoSnapshotFree();
#if DBG == 1
        _fat.CheckFreeCount();
#endif
    }
    else
    {
        _fat.SetCopyOnWrite(NULL, 0);
    }

    msfDebugOut((DEB_ITRACE,"Out CMStream::BeginCopyOnWrite()\n"));

    return S_OK;

Err:
    _fBlockHeader = FALSE;

    _pmsShadow->Empty();
    _fat.ResetCopyOnWrite();

    if (_fIsNoSnapshot)
        _fat.ResetNoSnapshotFree();

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CMStream::EndCopyOnWrite, public
//
//  Synopsis:   End copy on write mode, either by committing the current
//              changes (in which case a merge is performed), or by
//              aborting the changes, in which case the persistent form
//              of the multistream should be identical to its form
//              before copy on write mode was entered.
//
//  Effects:    *Finish This*
//
//  Arguments:  [df] -- Flags to determine commit or abort status.
//
//  Requires:   The multistream must be in copy on write mode.
//
//  Returns:    S_OK if call completed OK.
//              STG_E_ACCESSDENIED if MStream was not in COW mode.
//
//  Algorithm:  If aborting, delete all shadow structures,
//                  call SetSize() on parent LStream to restore
//                  original size, and switch active controls back
//                  to originals.
//              If committing, delete all old structures, switch
//                  shadows into original position.
//
//  History:    18-Feb-92   PhilipLa    Created.
//              09-Jun-92   Philipla    Added support for fUnconverted
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CMStream::EndCopyOnWrite(
        DWORD const dwCommitFlags,
        DFLAGS const df)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE,"In CMStream::EndCopyOnWrite(%lu)\n",df));

    BOOL fFlush = FLUSH_CACHE(dwCommitFlags);

    if (dwCommitFlags & STGC_OVERWRITE)
    {
        if (_pmsScratch != NULL)
        {
            msfChk(_fatDif.Fixup(NULL));
            _fat.ResetCopyOnWrite();
        }
        msfChk(Flush(fFlush));
    }
    else
    {
        msfAssert(_fBlockHeader &&
                aMsg("Tried to exit copy-on-write mode without entering."));

        ULARGE_INTEGER ulParentSize = {0,0};

        if (P_ABORT(df))
        {
            msfDebugOut((DEB_ITRACE,"Aborting Copy On Write mode\n"));

            Empty();

            InitCopy(BP_TO_P(CMStream *, _pmsShadow));

#ifdef LARGE_DOCFILE
            ulParentSize.QuadPart = _ulParentSize;
#else
            ULISetLow(ulParentSize, _ulParentSize);
#endif
        }
        else
        {
            SECT sectMax;

            msfChk(_fatDif.Fixup(BP_TO_P(CMStream *, _pmsShadow)));

            msfChk(Flush(fFlush));

            _fat.ResetCopyOnWrite();

            msfChk(_fat.GetMaxSect(&sectMax));

#ifdef LARGE_DOCFILE
            ulParentSize.QuadPart = ConvertSectOffset(sectMax, 0,
                    GetSectorShift());
#else
            ULISetLow(ulParentSize, ConvertSectOffset(sectMax, 0,
                    GetSectorShift()));
#endif

            msfChk(FlushHeader(HDR_FORCE));
            msfVerify(SUCCEEDED(ILBFlush(*_pplstParent, fFlush)) &&
                      aMsg("CMStream::EndCopyOnWrite ILBFLush failed.  "
                           "Non-fatal, hit Ok."));
        }

        //
        // Shrink the file if the size got smaller.
        // Don't shrink if we are in NoSnapshot mode, unless the NoSnapshot
        // limit has been set to 0 by Consolidate.
        //We don't ever expect this SetSize to fail, since it
        //   should never attempt to enlarge the file.
        if (!_fIsNoSnapshot || 0 == _fat.GetNoSnapshot())
        {
#ifdef LARGE_DOCFILE
            if (ulParentSize.QuadPart < _ulParentSize)
#else
            if (ULIGetLow(ulParentSize) < _ulParentSize)
#endif
            {
                olHVerSucc((*_pplstParent)->SetSize(ulParentSize));
            }
        }

        _pmsShadow->Empty();
        _fBlockHeader = FALSE;
        _fNewConvert = FALSE;
    }

    if (_pmsScratch != NULL)
    {
        //Let the no-scratch fat pick up whatever changed we've made.
        _pmsScratch->InitScratch(this, FALSE);
    }

    if (!_fIsNoSnapshot)
    {
        //In no-snapshot mode, we can't let the file shrink, since
        //we might blow away someone else's state.
        _ulParentSize = 0;
    }


    {
        SCODE sc2 = SetSize();
        msfVerify((SUCCEEDED(sc2) || (sc2 == E_PENDING)) &&
                  aMsg("SetSize after copy-on-write failed."));
    }

    if (_fIsNoSnapshot)
    {
        _ulParentSize = 0;
        _fat.SetNoSnapshot(0);
    }

#if DBG == 1
    STATSTG stat;
    msfHChk((*_pplstParent)->Stat(&stat, STATFLAG_NONAME));
#ifndef LARGE_DOCFILE
    msfAssert(ULIGetHigh(stat.cbSize) == 0);
#endif
    msfDebugOut((DEB_ITRACE, "Parent size at end is %lu\n",
                 ULIGetLow(stat.cbSize)));
#endif

    msfDebugOut((DEB_ITRACE,"Out CMStream::EndCopyOnWrite()\n"));
Err:

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::Consolidate, public
//
//  Synopsis:   Fill in the holes of a file by moving blocks toward the front.
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Algorithm:  1) Find a limit that all blocks should be moved below.
//                 The limit includes all the data, a new FAT, DIFAT and
//                 DirStream, and doesn't disturb the old fat/dif/dir blocks.
//              2) Move new fat/dif/dir sectors down. We do this with the
//                 cache's copy-on-write DIRTY behaviour.
//              3) Stream by stream move all the high sectors down.
//
//  History:	11-Feb-1997     BChapman    Created
//
//  Notes:  1) This is called in the contex of Begin/End Copy-on-Write.
//          2) We assume throughout that the underlying free sector allocator
//             returns the first free sector of the file.
//          3) The old fat/dif/dir may leave small holes in the finished file.
//----------------------------------------------------------------------------

SCODE CMStream::Consolidate(void)
{
    //
    // We don't support NOSCRATCH and this should have already
    // been checked in the caller.
    //
    msfAssert(_pmsScratch == NULL);

    SCODE sc=S_OK;

    ULONG cAllocatedSects;
    ULONG cDirEntries;
    CDirEntry *pde=NULL;

    SID sid;
    ULONG sectLast = 0;     // Last allocated Sector #.
    ULONG csectFree = 0;    // #sects that are  free.
    SECT sectLimit;         // #sects we will try to shrink the file into.
    ULONG csectLowDIF;      // #DIF sects below sectLimit.
    ULONG csectLowFAT;      // #FAT sects below sectLimit.
    ULONG csectLowControl;  // #motion sensitive sects below sectLimit.
    SECT *psectControl;     // list of Dir and Mini Fat sectors
    ULONG csectControl;     // # of sects in psectControl
    ULONG i;
    SECT sectType;

    //
    // It is quite impossible to consolidate a file when the Snapshot
    // limits are in effect.  This routine is only called when we have
    // confirmed there are no other "seperate" writers.  So it should be
    // safe to turn off the snapshot limits.
    //
    if(_fIsNoSnapshot)
    {
        _fat.SetNoSnapshot(0);
        _fat.ResetNoSnapshotFree();
    }
    //
    // Compute the Number of allocated sectors in the file.
    // Ignore the header.
    //
    msfChk(_fat.FindLast(&sectLast));
    sectLast--;
    msfChk(_fat.CountSectType(&csectFree, 0, sectLast, FREESECT));

    //
    // Compute the expected size of the consolidated file.  We will
    // use this limit to determine when a sector is too high and needs
    // to be copied down.
    //
    sectLimit = sectLast - csectFree;

    //
    //  We will move the stream data sectors by copying them to free
    // sectors and releasing the old sector.
    //  But, there are a class of sectors (control structures: FAT, DIF,
    // miniFat, Directory Stream) that the old sector cannot be freed until
    // end-copy-on-write.
    //  It is possible that the old (original) versions of these sectors
    // could exist below sectLimit and with therefore be taking up "dead"
    // space in the resulting file.  So we need to adjust sectLimit.
    //
    //  We are in Copy-On-Write mode so any FAT, DIF, Directory Stream, or
    // MiniFat sector that is modified (by moving other sectors) will be
    // copied to a free sector by the cache manager.
    //  It is difficult to know ahead of time which Low FAT sectors won't
    // be touched, and therefore can avoid being copied, so we just assume
    // we need to make a complete copy of the FAT, DIF, Directory Stream,
    // and MiniFAT.
    //

    // Count the number of FAT (and DIFat) blocks up to sectLimit.
    //
    msfChk(_fat.CountSectType(&csectLowFAT, 0, sectLimit, FATSECT));
    msfChk(_fat.CountSectType(&csectLowDIF, 0, sectLimit, DIFSECT));

    //
    // Build a list of sectors in the Directory Stream and MiniFat
    //
    msfChk(BuildConsolidationControlSectList(&psectControl, &csectControl));

    //
    // Sum all the copy-on-write control sectors below sectLimit.
    //
    csectLowControl = csectLowFAT + csectLowDIF;
    for(i=0; i<csectControl; i++)
    {
        if(psectControl[i] < sectLimit)
            ++csectLowControl;
    }

    //
    // Now we adjust sectLimit.  (see large comment above)
    // We want to increase it by csectLowControl # of sectors.
    // But, advancing over new control sectors doesn't help make space
    // so skip over those.
    // Note: In a well packed file we can hit EOF while doing this.
    //
    for( ; csectLowControl > 0; ++sectLimit)
    {
        if(sectLimit >= sectLast)
        {
            delete [] psectControl;
            return S_OK;
        }

        msfChkTo(Err_FreeList, _fat.GetNext(sectLimit, &sectType));
        if(    FATSECT != sectType
            && DIFSECT != sectType
            && (! IsSectorInList(sectLimit, psectControl, csectControl)) )
        {
            --csectLowControl;
        }
    }

    //
    // We are done with the control sector list.
    //
    delete [] psectControl;
    psectControl = NULL;

    //
    // At Last!  We begin to move some data.
    // Iterate through the directory.
    // Remapping the sectors of each Stream to below sectLimit.
    //
    cDirEntries = _dir.GetNumDirEntries();
    for(sid=0; sid<cDirEntries; sid++)
    {
        //
        // Always get the directory entry "for-writing".
        // This has the effect of remapping each sector of the directory
        // stream down into the front of the file.
        //
        msfChk(_dir.GetDirEntry(sid, FB_DIRTY, &pde));
        switch(pde->GetFlags())
        {
        case STGTY_LOCKBYTES:
        case STGTY_PROPERTY:
        case STGTY_STORAGE:
        case STGTY_INVALID:
        default:
            break;
        //
        // Remap The Mini-stream
        //
        case STGTY_ROOT:
            msfChkTo(Err_Release, ConsolidateStream(pde, sectLimit));
            GetMiniStream()->EmptyCache();
            break;

        //
        // Remap the regular streams.
        // Don't remap streams in the mini-streams
        //
        case STGTY_STREAM:
#ifdef LARGE_STREAMS
            if(pde->GetSize(_dir.IsLargeSector()) < MINISTREAMSIZE)
#else
            if(pde->GetSize() < MINISTREAMSIZE)
#endif
                break;

            msfChkTo(Err_Release, ConsolidateStream(pde, sectLimit));
            break;
        }
        _dir.ReleaseEntry(sid);
    }

    //
    // If there are any remaining un-remapped FAT blocks, remap them now.
    //  (begin-copy-on-write already remapped the DIF).
    //
    msfChk(_fat.DirtyAll());
    msfChk(_fatMini.DirtyAll());

    return sc;

Err_FreeList:
    delete [] psectControl;
    return sc;

Err_Release:
    _dir.ReleaseEntry(sid);
Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMStream::BuildConsolidationControlSectList, private
//
//  Synopsis:	Makes a list of all the sectors that are copy-on-write
//              for the purpose of computing how much space we need to
//              make to Consolidate a file.
//
//  Arguments:	[ppsectList] -- [out] pointer to a list of sectors.
//              [pcsect]     -- [out] count of sectors on the list.
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	25-feb-1997	BChapman	Created
//
//----------------------------------------------------------------------------

SCODE CMStream::BuildConsolidationControlSectList(
        SECT **ppsectList,
        ULONG *pcsect)
{
    SECT sect;
    SECT *psectList;
    ULONG i, csect;
    SCODE sc;

    csect = _dir.GetNumDirSects() + _hdr.GetMiniFatLength();
    msfMem(psectList = (SECT*) new SECT[csect]);

    i = 0;
    //
    // Walk the Directory Stream FAT chain and record all
    // the sector numbers.
    //
    sect = _hdr.GetDirStart();
    while(sect != ENDOFCHAIN)
    {
        msfAssert(i < csect);

        psectList[i++] = sect;
        msfChkTo(Err_Free, _fat.GetNext(sect, &sect));
    }
    msfAssert(i == _dir.GetNumDirSects());

    //
    // Walk the MiniFat FAT chain and record all
    // the sector numbers.
    //
    sect = _hdr.GetMiniFatStart();
    while(sect != ENDOFCHAIN)
    {
        msfAssert(i < csect);

        psectList[i++] = sect;
        msfChkTo(Err_Free, _fat.GetNext(sect, &sect));
    }
    msfAssert((i == csect) && aMsg("Directory Stream + MiniFat too short\n"));

    *ppsectList = psectList;
    *pcsect = csect;
    return S_OK;

Err_Free:
    if (psectList != NULL)
        delete [] psectList;
    return sc;
Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMStream::IsSectorOnList, private
//
//  Synopsis:	Searches a list of sector values for a given value.
//
//  Arguments:	[sect]      -- [in]  value to search for.
//              [psectList] -- [in]  list of sectors.
//              [csect]     -- [in]  count of sectors on the list.
//
//  Returns:	TRUE if the sector is on the list, otherwise FALSE.
//
//  Modifies:	
//
//  History:	25-feb-1997	BChapman	Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CMStream::IsSectorInList(
        SECT sect,
        SECT *psectList,
        ULONG csectList)
{
    ULONG i;
    for(i=0; i < csectList; i++)
    {
        if(sect == psectList[i])
            return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMStream::ConsolidateStream, private
//
//  Synopsis:	Scan the stream FAT chain and remap sectors that are
//              above the given limit.
//
//  Arguments:	[pde]       -- Directory entry of the stream (DIRTY)
//              [sectLimit] -- sector limit that all sectors should be below
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	18-feb-1997	BChapman	Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE CMStream::ConsolidateStream(
        CDirEntry *pde,     // Current CDirEntry Object (read-only)
        SECT sectLimit)     // Move all sectors below this sector#
{
    SECT sectPrev, sectCurrent, sectNew;
    ULONG cbLength;
    SCODE sc=S_OK;

    //
    // This code should not be used in NOSCRATCH mode.
    //
    msfAssert(_pmsScratch == NULL);

    //
    // Check the first sector of the stream as a special case.
    //
    sectCurrent = pde->GetStart();
    if(ENDOFCHAIN != sectCurrent && sectCurrent > sectLimit)
    {
        msfChk(_fat.GetFree(1, &sectNew, GF_WRITE));

        //  This is only here because I don't understand GetFree().
        msfAssert(ENDOFCHAIN != sectNew);

        msfChk(MoveSect(ENDOFCHAIN, sectCurrent, sectNew));
        sectCurrent = sectNew;
        pde->SetStart(sectCurrent);
    }

    //
    // Do the rest of the stream FAT chain.
    //
    sectPrev = sectCurrent;
    while(ENDOFCHAIN != sectPrev)
    {
        msfChk(_fat.GetNext(sectPrev, &sectCurrent));
        if(ENDOFCHAIN != sectCurrent && sectCurrent > sectLimit)
        {
            msfChk(_fat.GetFree(1, &sectNew, GF_WRITE));

            //  This is only here because I don't understand GetFree().
            msfAssert(ENDOFCHAIN != sectNew);

            msfChk(MoveSect(sectPrev, sectCurrent, sectNew));
            sectCurrent = sectNew;
        }
        sectPrev = sectCurrent;
    }

Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::MoveSect, private
//
//  Synopsis:	Move Data Sector for Consolidation Support.
//
//  Arguments:	[sectPrev] -- Previous sector, so the link can be updated.
//              [sectOld]  -- Location to copy from
//              [sectNew]  -- Location to copy to
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-1997	BChapman	Created
//
//  Notes:
//
//----------------------------------------------------------------------------


SCODE CMStream::MoveSect(
        SECT sectPrev,
        SECT sectOld,
        SECT sectNew)
{
    ULONG cb;
    SCODE sc=S_OK;
    ULARGE_INTEGER ulOff;
    BYTE *pbScratch = BP_TO_P(BYTE HUGEP *, _pCopySectBuf);

    //
    // This code does not expect NOSCRATCH mode.
    //
    msfAssert(_pmsScratch == NULL);

    //
    // Copy the data from the old sector to the new sector.
    //
    ulOff.QuadPart = ConvertSectOffset(sectOld, 0, GetSectorShift());
    msfChk((*_pplstParent)->ReadAt(ulOff,
                                   pbScratch,
                                   GetSectorSize(),
                                   &cb));

    ulOff.QuadPart = ConvertSectOffset(sectNew, 0, GetSectorShift());
    msfChk((*_pplstParent)->WriteAt(ulOff,
                                    pbScratch,
                                    GetSectorSize(),
                                    &cb));

    //
    // Update the previous sector's link (if this isn't the first sector)
    //
    if(ENDOFCHAIN != sectPrev)
    {
        msfChk(_fat.SetNext(sectPrev, sectNew));
    }

    //
    // Update the link to the next sector.
    //
    SECT sectTemp;
    msfChk(_fat.GetNext(sectOld, &sectTemp));
    msfChk(_fat.SetNext(sectNew, sectTemp));

    //
    // Free the old sector.
    //
    msfChk(_fat.SetNext(sectOld, FREESECT));

Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::CopySect, private
//
//  Synopsis:	Do a partial sector delta for copy-on-write support
//
//  Arguments:	[sectOld] -- Location to copy from
//              [sectNew] -- Location to copy to
//              [oStart] -- Offset into sector to begin delta
//              [oEnd] -- Offset into sector to end delta
//              [pb] -- Buffer to delta from
//              [pulRetval] -- Return location for number of bytes written
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	22-Jan-93	PhilipLa	Created
//
//  Notes:	[pb] may be unsafe memory
//
//----------------------------------------------------------------------------


//This pragma is to avoid a C7 bug when building RETAIL
#if _MSC_VER == 700 && DBG == 0
#pragma function(memcpy)
#endif

SCODE CMStream::CopySect(
        SECT sectOld,
        SECT sectNew,
        OFFSET oStart,          // First byte of the sector to copy.
        OFFSET oEnd,            // Last byte of the sector to copy.
        BYTE const HUGEP *pb,
        ULONG *pulRetval)
{
    SCODE sc;

    ULONG cb;
    ULARGE_INTEGER ulOff;

    ULISetHigh(ulOff, 0);

    BYTE HUGEP *pbScratch = BP_TO_P(BYTE HUGEP *, _pCopySectBuf);

#if DBG == 1
    msfAssert((_uBufferRef == 0) &&
            aMsg("Attempted to use CopySect buffer while refcount != 0"));
    AtomicInc(&_uBufferRef);
#endif

    msfAssert((pbScratch != NULL) && aMsg("No CopySect buffer found."));

#ifdef LARGE_DOCFILE
    ulOff.QuadPart = ConvertSectOffset(sectOld, 0, GetSectorShift());
#else
    ULISetLow(ulOff, ConvertSectOffset(sectOld, 0, GetSectorShift()));
#endif
    msfHChk((*_pplstParent)->ReadAt(
            ulOff,
            pbScratch,
            GetSectorSize(),
            &cb));

    //Now do delta in memory.
    BYTE HUGEP *pstart;
    pstart = pbScratch + oStart;

    USHORT memLength;
    memLength = oEnd - oStart + 1;

    TRY
    {
        memcpy(pstart, pb, memLength);
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        msfErr(Err, STG_E_INVALIDPOINTER);
    }
    END_CATCH

#ifdef LARGE_DOCFILE
    ulOff.QuadPart = ConvertSectOffset(sectNew, 0, GetSectorShift());
#else
    ULISetLow(ulOff, ConvertSectOffset(sectNew, 0, GetSectorShift()));
#endif
    msfHChk((*_pplstParent)->WriteAt(
            ulOff,
            pbScratch,
            GetSectorSize(),
            &cb));

    *pulRetval = memLength;

 Err:
#if DBG == 1
    AtomicDec(&_uBufferRef);
#endif
    return sc;
}


//This returns the compiler to the default behavior
#if _MSC_VER == 700 && DBG == 0
#pragma intrinsic(memcpy)
#endif

//+-------------------------------------------------------------------------
//
//  Member:     CMStream::MWrite, public
//
//  Synposis:   Do multiple sector writes
//
//  Effects:    Causes multiple stream writes.  Modifies fat and directory
//
//  Arguments:  [ph] -- Handle of stream doing write
//              [start] -- Starting sector to write
//              [oStart] -- offset into sector to begin write at
//              [end] -- Last sector to write
//              [oEnd] -- offset into last sector to write to
//              [buffer] -- Pointer to buffer into which data will be written
//              [ulRetVal] -- location to return number of bytes written
//
//  Returns:    Error code of any failed call to parent write
//              S_OK if call completed OK.
//
//  Modifies:   ulRetVal returns the number of bytes written
//
//  Algorithm:  Using a segment table, perform writes on parent stream
//              until call is completed.
//
//  History:    16-Aug-91   PhilipLa    Created.
//              10-Sep-91   PhilipLa    Converted to use sector table
//              11-Sep-91   PhilipLa    Modified interface, modified to
//                                      allow partial sector writes.
//              07-Jan-92   PhilipLa    Converted to use handle.
//              18-Feb-92   PhilipLa    Added copy on write support.
//
//  Notes:      [pvBuffer] may be unsafe memory
//
//---------------------------------------------------------------------------


SCODE CMStream::MWrite(
        SID sid,
        BOOL fIsMini,
#ifdef LARGE_STREAMS
        ULONGLONG ulOffset,
#else
        ULONG ulOffset,
#endif
        VOID const HUGEP *pvBuffer,
        ULONG ulCount,
        CStreamCache *pstmc,
        ULONG *pulRetval)
{
    SCODE sc;
    BYTE const HUGEP *pbBuffer = (BYTE const HUGEP *) pvBuffer;

    USHORT cbSector = GetSectorSize();
    CFat *pfat = &_fat;
    USHORT uShift = GetSectorShift();
    ULONG ulLastBytes = 0;

    ULARGE_INTEGER ulOff;
    ULISetHigh(ulOff, 0);

#ifdef LARGE_STREAMS
    ULONGLONG ulOldSize = 0;
#else
    ULONG ulOldSize = 0;
#endif

    //  Check if it's a small stream and whether this is a real or
    //  scratch multistream.

    if ((fIsMini) &&
        (!_fIsScratch) &&
        (SIDMINISTREAM != sid))
    {
        msfAssert(sid <= MAXREGSID &&
                aMsg("Invalid SID in MWrite"));
        //  This stream is stored in the ministream

        cbSector = MINISECTORSIZE;
        uShift = MINISECTORSHIFT;
        pfat = GetMiniFat();
    }

    USHORT uMask = cbSector - 1;

    SECT start = (SECT)(ulOffset >> uShift);
    OFFSET oStart = (OFFSET)(ulOffset & uMask);

    SECT end = (SECT)((ulOffset + ulCount - 1) >> uShift);
    OFFSET oEnd = (OFFSET)((ulOffset + ulCount - 1) & uMask);

    msfDebugOut((DEB_ITRACE,"In CMStream::MWrite(%lu,%u,%lu,%u)\n",
            start,oStart,end,oEnd));

    ULONG bytecount;
    ULONG total = 0;

    msfChk(_dir.GetSize(sid, &ulOldSize));


//BEGIN COPYONWRITE

    //  Note that we don't do this for ministreams (the second pass through
    //  this code will take care of it).

    msfAssert(!_fBlockWrite &&
            aMsg("Called MWrite on Unconverted multistream"));

    if ((_fBlockHeader) && (GetMiniFat() != pfat))
    {
        msfDebugOut((DEB_ITRACE,"**MWrite preparing for copy-on-write\n"));

        SECT sectOldStart, sectNewStart, sectOldEnd, sectNewEnd;

        SECT sectNew;
        if (start != 0)
        {
            msfChk(pstmc->GetESect(start - 1, &sectNew));
        }
        else
        {
            msfChk(_dir.GetStart(sid, &sectNew));
        }

        msfChk(_fat.Remap(
                sectNew,
                (start == 0) ? 0 : 1,
                (end - start + 1),
                &sectOldStart,
                &sectNewStart,
                &sectOldEnd,
                &sectNewEnd));

        msfAssert(((end != start) || (sectNewStart == sectNewEnd)) &&
                aMsg("Remap postcondition failed."));

        if (sc != S_FALSE)
        {
            msfChk(pstmc->EmptyRegion(start, end));
        }

        if ((start == 0) && (sectNewStart != ENDOFCHAIN))
        {
            msfDebugOut((DEB_ITRACE,
                    "*** Remapped first sector.  Changing directory.\n"));
            msfChk(_dir.SetStart(sid, sectNewStart));
        }

#ifdef LARGE_STREAMS
        ULONGLONG ulSize = ulOldSize;
#else
        ULONG ulSize = ulOldSize;
#endif

        if (((oStart != 0) ||
             ((end == start) && (ulOffset + ulCount != ulSize)
              && ((USHORT)oEnd != (cbSector - 1)))) &&
            (sectNewStart != ENDOFCHAIN))
        {
            //Partial first sector.
            ULONG ulRetval;

            msfChk(CopySect(
                    sectOldStart,
                    sectNewStart,
                    oStart,
                    (OFFSET) (end == start ? oEnd : (cbSector - 1)),
                    pbBuffer,
                    &ulRetval));

            pbBuffer = pbBuffer + ulRetval;
            total = total + ulRetval;
            start++;
            oStart = 0;
        }

        if (((end >= start) && ((USHORT)oEnd != cbSector - 1) &&
             (ulCount + ulOffset != ulSize)) &&
            (sectNewEnd != ENDOFCHAIN))
        {
            //Partial last sector.

            msfAssert(((end != start) || (oStart == 0)) &&
                    aMsg("CopySect precondition failed."));

            msfChk(CopySect(
                    sectOldEnd,
                    sectNewEnd,
                    0,
                    oEnd,
                    pbBuffer + ((end - start) << uShift) - oStart,
                    &ulLastBytes));

            end--;
            oEnd = cbSector - 1;
            //We don't need to update pbBuffer, since the change
            //    is at the end.
        }
    }


//  At this point, the entire block has been moved into the copy-on-write
//   area of the multistream, and all partial writes have been done.
//END COPYONWRITE

    msfAssert(end != 0xffffffffL);

    if (end < start)
    {
        *pulRetval = total + ulLastBytes;
        goto Err;
    }

    ULONG ulRunLength;
    ulRunLength = end - start + 1;

    USHORT offset;
    offset = oStart;

    while (TRUE)
    {
        SSegment segtab[CSEG + 1];

        ULONG cSeg;
        msfChk(pstmc->Contig(
                start,
                TRUE,
                (SSegment STACKBASED *) segtab,
                ulRunLength,
                &cSeg));

        msfAssert(cSeg <= CSEG);

        USHORT oend = cbSector - 1;
        ULONG i;
        SECT sectStart;
        for (USHORT iseg = 0; iseg < cSeg;)
        {
            sectStart = segtab[iseg].sectStart;
            i = segtab[iseg].cSect;
            if (i > ulRunLength)
                i = ulRunLength;

            ulRunLength -= i;
            start += i;

            iseg++;
            if (ulRunLength == 0)
                oend = oEnd;

            ULONG ulSize = ((i - 1) << uShift) - offset + oend + 1;

            msfDebugOut((
                    DEB_ITRACE,
                    "Calling lstream WriteAt(%lu,%p,%lu)\n",
                    ConvertSectOffset(sectStart,offset,uShift),
                    pbBuffer,
                    ulSize));

            if (GetMiniFat() == pfat)
            {
                sc = _pdsministream->CDirectStream::WriteAt(
                        (sectStart << uShift) + offset,
                        pbBuffer, ulSize,
                        (ULONG STACKBASED *)&bytecount);
            }
            else
            {
#ifdef LARGE_DOCFILE
                ulOff.QuadPart = ConvertSectOffset(sectStart, offset, uShift);
#else
                ULISetLow(ulOff, ConvertSectOffset(sectStart, offset,
                        uShift));
#endif
                sc = DfGetScode((*_pplstParent)->WriteAt(ulOff, pbBuffer,
                        ulSize, &bytecount));
            }

            total += bytecount;

            //Check if this write is the last one in the stream,
                //   and that the stream ends as a partial sector.
                //If so, fill out the remainder of the sector with
                //   something.
            if ((0 == ulRunLength) && (total + ulOffset > ulOldSize) &&
                (((total + ulOffset) & (GetSectorSize() - 1)) != 0))
            {
                //This is the last sector and the stream has grown.
                ULONG csectOld = (ULONG)((ulOldSize + GetSectorSize() - 1) >>
                    GetSectorShift());

                ULONG csectNew = (ULONG)((total + ulOffset + GetSectorSize() - 1) >>
                    GetSectorShift());

                if (csectNew > csectOld)
                {
                    msfAssert(!fIsMini &&
                            aMsg("Small stream grew in MWrite"));

                    SECT sectLast = sectStart + i - 1;

                    msfVerify(SUCCEEDED(SecureSect(
                            sectLast,
                            total + ulOffset,
                            FALSE)));
                }
            }

            if (0 == ulRunLength || FAILED(sc))
            {
                break;
            }

            pbBuffer = pbBuffer + bytecount;
            offset = 0;
        }

        if (0 == ulRunLength || FAILED(sc))
        {
            *pulRetval = total + ulLastBytes;
            msfDebugOut((
                    DEB_ITRACE,
                    "Out CMStream::MWrite()=>%lu, retval = %lu\n",
                    sc,
                    total));
            break;
        }
    }

 Err:

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMStream::Flush, public
//
//  Synopsis:	Flush control structures.
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	16-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CMStream::Flush(BOOL fFlushCache)
{
    SCODE sc = S_OK;

    msfAssert(!_fBlockWrite &&
            aMsg("Flush called on unconverted base."));

    if ((!_fIsScratch) && (*_pplstParent != NULL))
    {
        msfChk(_pmpt->Flush());
        msfChk(FlushHeader(HDR_NOFORCE));
        msfChk(ILBFlush(*_pplstParent, fFlushCache));
    }
Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:   ILBFlush
//
//  Synopsis:   Flush as thoroughly as possible
//
//  Effects:    Flushes ILockBytes
//
//  Arguments:  [pilb]        - ILockBytes to flush
//              [fFlushCache] - Flush thoroughly iff TRUE
//
//  Returns:    SCODE
//
//  Algorithm:
//
//  History:    12-Feb-93 AlexT     Created
//
//--------------------------------------------------------------------------


SCODE ILBFlush(ILockBytes *pilb, BOOL fFlushCache)
{
    //  Try to query interface to our own implementation

    IFileLockBytes *pfl;
    SCODE sc;

    msfDebugOut((DEB_ITRACE, "In ILBFlushCache(%p)\n", pilb));

    // Check for FileLockBytes

    if (!fFlushCache ||
        FAILED(DfGetScode(pilb->QueryInterface(IID_IFileLockBytes, (void **)&pfl))))
    {
        //  Either we don't have to flush the cache or its not our ILockBytes
        sc = DfGetScode(pilb->Flush());
    }
    else
    {
        //  We have to flush the cache and its our ILockBytes
        sc = DfGetScode(pfl->FlushCache());
        pfl->Release();
    }

    msfDebugOut((DEB_ITRACE, "Out ILBFlushCache()\n"));

    return(sc);
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::SecureSect, public
//
//  Synopsis:	Zero out the unused portion of a sector
//
//  Arguments:	[sect] -- Sector to zero out
//              [ulSize] -- Size of stream
//              [fIsMini] -- TRUE if stream is in ministream
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	05-Apr-93	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------


SCODE CMStream::SecureSect(
        const SECT sect,
#ifdef LARGE_STREAMS
        const ULONGLONG ulSize,
#else
        const ULONG ulSize,
#endif
        const BOOL fIsMini)
{
#ifdef SECURE_TAIL
    SCODE sc = S_OK;
    BYTE *pb = NULL;

    if (!_fIsScratch)
    {
        ULONG cbSect = fIsMini ? MINISECTORSIZE : GetSectorSize();

        msfAssert(ulSize != 0);

        ULONG ulOffset = (ULONG)(((ulSize - 1) % cbSect) + 1);

        ULONG cb = cbSect - ulOffset;

        msfAssert(cb != 0);

        //We can use any initialized block of memory here.  The header
        // is available and is the correct size, so we use that.
#ifdef SECURE_BUFFER
        pb = s_bufSecure;
#else
        pb = (BYTE *)_hdr.GetData();
#endif

#ifdef SECURETEST
        pb = (BYTE *) DfMemAlloc(cb);
        if (pb != NULL)
            memset(pb, 'Y', cb);
#endif
        ULONG cbWritten;

        if (!fIsMini)
        {
            ULARGE_INTEGER ulOff;
#ifdef LARGE_DOCFILE
            ulOff.QuadPart = ConvertSectOffset(
                    sect,
                    (OFFSET)ulOffset,
                    GetSectorShift());
#else
            ULISet32 (ulOff, ConvertSectOffset(
                    sect,
                    (OFFSET)ulOffset,
                    GetSectorShift()));
#endif

            msfChk(DfGetScode((*_pplstParent)->WriteAt(
                    ulOff,
                    pb,
                    cb,
                    &cbWritten)));
        }
        else
        {
            msfChk(_pdsministream->WriteAt(
                    (sect << MINISECTORSHIFT) + ulOffset,
                    pb,
                    cb,
                    (ULONG STACKBASED *)&cbWritten));
        }

        if (cbWritten != cb)
        {
            sc = STG_E_WRITEFAULT;
        }
    }

Err:
#ifdef SECURETEST
    DfMemFree(pb);
#endif

    return sc;
#else
    //On NT, our sectors get zeroed out by the file system, so we don't
    //  need this whole rigamarole.
    return S_OK;
#endif // WIN32 == 200
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::SetFileLockBytesTime, public
//
//  Synopsis:   Set the IFileLockBytes time.
//
//  Arguments:  [tt] -- Timestamp requested (WT_CREATION, WT_MODIFICATION,
//                          WT_ACCESS)
//              [nt] -- New timestamp
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Query for IFileLockBytes and call its SetTime member.
//
//  History:    01-Sep-95       MikeHill        Created.
//
//--------------------------------------------------------------------------

SCODE CMStream::SetFileLockBytesTime(
    WHICHTIME const tt,
    TIME_T nt)
{
     SCODE sc = S_OK;
     ILockBytes *pilb = *_pplstParent;
     IFileLockBytes *pfl;

     
     if (pilb && 
         (SUCCEEDED(pilb->QueryInterface(IID_IFileLockBytes, (void **)&pfl))))
     {

         sc = ((CFileStream *)pfl)->SetTime(tt, nt);
         pfl->Release();

     }

     return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::SetAllFileLockBytesTimes, public
//
//  Synopsis:   Set the IFileLockBytes time.
//
//  Arguments:
//              [atm] -- ACCESS time
//              [mtm] -- MODIFICATION time
//				[ctm] -- CREATION time
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Query for IFileLockBytes and call its SetAllTimes member.
//
//  History:    29-Nov-95       SusiA        Created.
//
//--------------------------------------------------------------------------

SCODE CMStream::SetAllFileLockBytesTimes(
        TIME_T atm,
        TIME_T mtm,
        TIME_T ctm)
{
     SCODE sc = S_OK;
     ILockBytes *pilb = *_pplstParent;
     IFileLockBytes *pfl;

     if (SUCCEEDED(pilb->QueryInterface( IID_IFileLockBytes, (void **)&pfl)))
     {

         sc = ((CFileStream *)pfl)->SetAllTimes(atm, mtm, ctm);
         pfl->Release();

     }

     return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::SetTime, public
//
//  Synopsis:   Set the time for a given handle
//
//  Arguments:  [sid] -- SID to retrieve time for
//              [tt] -- Timestamp requested (WT_CREATION, WT_MODIFICATION,
//                          WT_ACCESS)
//              [nt] -- New timestamp
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Call through to directory
//
//  History:    01-Apr-92       PhilipLa        Created.
//              14-Sep-92       PhilipLa        inlined.
//              <Missing history>
//              26-APR-99       RogerCh         Removed faulty optimization
//
//--------------------------------------------------------------------------

SCODE CMStream::SetTime(
    SID const sid,
    WHICHTIME const tt,
    TIME_T nt)
{

    if ( sid == SIDROOT )
    {
        SCODE sc;

        if( FAILED( sc = SetFileLockBytesTime( tt, nt )))
        {
          return sc;
        }
    }// if( sid == SIDROOT)

    return _dir.SetTime(sid, tt, nt);
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::SetAllTimes, public
//
//  Synopsis:   Set all the times for a given handle
//
//  Arguments:  [sid] -- SID to retrieve time for
//              [atm] -- ACCESS time
//              [mtm] -- MODIFICATION time
//				[ctm] -- CREATION time
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Call through to directory
//
//  History:    27-Nov-95	SusiA	Created
//
//--------------------------------------------------------------------------

SCODE CMStream::SetAllTimes(
    SID const sid,
    TIME_T atm,
    TIME_T mtm,
	TIME_T ctm)
{

    if ( sid == SIDROOT )
    {

        SCODE sc;

           if( FAILED( sc = SetAllFileLockBytesTimes(atm, mtm, ctm )))
           {
              return sc;
           }
    }
    return _dir.SetAllTimes(sid, atm, mtm, ctm);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::GetTime, public
//
//  Synopsis:   Get the time for a given handle
//
//  Arguments:  [sid] -- SID to retrieve time for
//              [tt] -- Timestamp requested (WT_CREATION, WT_MODIFICATION,
//                          WT_ACCESS)
//              [pnt] -- Pointer to return location
//
//  Returns:    S_OK if call completed OK.
//
//  History:    01-Apr-92       PhilipLa        Created.
//              14-Sep-92       PhilipLa        inlined.
//
//--------------------------------------------------------------------------

SCODE CMStream::GetTime(SID const sid,
        WHICHTIME const tt,
        TIME_T *pnt)
{
    SCODE sc = S_OK;

    if (sid == SIDROOT)
    {
        //Get timestamp from ILockBytes
        STATSTG stat;

        msfChk((*_pplstParent)->Stat(&stat, STATFLAG_NONAME));

        if (tt == WT_CREATION)
        {
            *pnt = stat.ctime;
        }
        else if (tt == WT_MODIFICATION)
        {
            *pnt = stat.mtime;
        }
        else
        {
            *pnt = stat.atime;
        }
    }
    else
        sc = _dir.GetTime(sid, tt, pnt);
Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::GetAllTimes, public
//
//  Synopsis:   Get the times for a given handle
//
//  Arguments:  [sid] -- SID to retrieve time for
//              [patm] -- Pointer to the ACCESS time
//              [pmtm] -- Pointer to the MODIFICATION time
//		[pctm] -- Pointer to the CREATION time
//
//  Returns:    S_OK if call completed OK.
//
//  History:    26-May-95	SusiA	Created
//
//--------------------------------------------------------------------------

SCODE CMStream::GetAllTimes(SID const sid,
        TIME_T *patm,
        TIME_T *pmtm,
	TIME_T *pctm)
{
    SCODE sc = S_OK;

    if (sid == SIDROOT)
    {
        //Get timestamp from ILockBytes
        STATSTG stat;

        msfChk((*_pplstParent)->Stat(&stat, STATFLAG_NONAME));

        *pctm = stat.ctime;
        *pmtm = stat.mtime;
        *patm = stat.atime;

    }
    else
        sc = _dir.GetAllTimes(sid, patm, pmtm, pctm);
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::InitScratch, public
//
//  Synopsis:	Set up a multistream for NoScratch operation
//
//  Arguments:	[pms] -- Pointer to base multistream
//              [fNew] -- True if this is the first time the function has
//                        been called (init path), FALSE if merging behavior
//                        is required (EndCopyOnWrite)
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	02-Mar-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMStream::InitScratch(CMStream *pms, BOOL fNew)
{
    msfDebugOut((DEB_ITRACE, "In  CMStream::InitScratch:%p()\n", this));

    msfAssert(GetSectorSize() == SCRATCHSECTORSIZE);
    msfAssert(_fIsNoScratch &&
              aMsg("Called InitScratch on Multistream not in NoScratch mode"));

    return _fatMini.InitScratch(pms->GetFat(), fNew);
}

#ifdef MULTIHEAP
//+--------------------------------------------------------------
//
//  Member: CMStream::GetMalloc, public
//
//  Synopsis:   Returns the allocator associated with this multistream
//
//  History:    05-May-93   AlexT   Created
//
//---------------------------------------------------------------

IMalloc * CMStream::GetMalloc(VOID) const
{
    return (IMalloc *) &g_smAllocator;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\msf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       msf.cxx
//
//  Contents:   Entry points for MSF DLL
//
//  Classes:    None.
//
//  Functions:  DllMuliStreamFromStream
//              DllConvertStreamToMultiStream
//              DllReleaseMultiStream
//              DllGetScratchMultiStream
//              DllIsMultiStream
//
//  History:    17-Aug-91   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <handle.hxx>
#include <filelkb.hxx>
#include <ole.hxx>
#include <entry.hxx>
#include <smalloc.hxx>

//+-------------------------------------------------------------------------
//
//  Function:   DllMultiStreamFromStream
//
//  Synopsis:   Create a new multistream instance from an existing stream.
//              This is used to reopen a stored multi-stream.
//
//  Effects:    Creates a new CMStream instance
//
//  Arguments:  [ppms] -- Pointer to storage for return of multistream
//              [pplstStream] -- Stream to be used by multi-stream for
//                           reads and writes
//		[dwFlags] - Startup flags
//
//  Returns:    STG_E_INVALIDHEADER if signature on pStream does not
//                  match.
//              STG_E_UNKNOWN if there was a problem in setup.
//              S_OK if call completed OK.
//
//  Algorithm:  Check the signature on the pStream and on the contents
//              of the pStream.  If either is a mismatch, return
//              STG_E_INVALIDHEADER.
//              Create a new CMStream instance and run the setup function.
//              If the setup function fails, return STG_E_UNKNOWN.
//              Otherwise, return S_OK.
//
//  History:    17-Aug-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllMultiStreamFromStream(IMalloc *pMalloc,
                               CMStream **ppms,
			       ILockBytes **pplstStream,
			       DWORD dwStartFlags,
                               DFLAGS df)
{
    SCODE sc;
    CMStream *temp;


    BOOL fConvert = ((dwStartFlags & RSF_CONVERT) != 0);
    BOOL fDelay = ((dwStartFlags & RSF_DELAY) != 0);
    BOOL fTruncate = ((dwStartFlags & RSF_TRUNCATE) != 0);
    BOOL fCreate = ((dwStartFlags & RSF_CREATE) != 0);


    msfDebugOut((DEB_ITRACE,"In DllMultiStreamFromStream\n"));

#ifdef USE_NOSCRATCH
    msfMem(temp = new (pMalloc)
           CMStream(pMalloc, pplstStream,
                    FALSE,
                    (df & ~DF_NOSCRATCH),
                    (dwStartFlags & RSF_SECTORSIZE_MASK) ?
                         (USHORT)((dwStartFlags & RSF_SECTORSIZE_MASK) >> 12) :
                         SECTORSHIFT512));
#else
    msfMem(temp = new (pMalloc)
           CMStream(pMalloc, pplstStream,
                    FALSE,
                    (dwStartFlags & RSF_SECTORSIZE_MASK) ?
                         (USHORT)((dwStartFlags & RSF_SECTORSIZE_MASK) >> 12) :
                         SECTORSHIFT512));
#endif //USE_NOSCRATCH    

    STATSTG stat;
    HRESULT hr;
    IFileLockBytes *pfl;

    //  ILockBytes::Stat is an expensive operation;  for our own file
    //  stream we call our faster GetSize method.

    if (SUCCEEDED((*pplstStream)->QueryInterface(IID_IFileLockBytes,
                                                    (void**) &pfl)))
    {
        msfAssert(pfl != NULL &&
               aMsg("ILockBytes::QueryInterface succeeded but returned NULL"));
        hr = pfl->GetSize(&stat.cbSize);
        pfl->Release();
    }
    else
        hr = (*pplstStream)->Stat(&stat, STATFLAG_NONAME);
    msfHChk(hr);

    msfDebugOut((DEB_ITRACE,"Size is: %lu\n",ULIGetLow(stat.cbSize)));

    do
    {
        if ((stat.cbSize.QuadPart != 0) && (fConvert))
        {
            msfChk(temp->InitConvert(fDelay));
            break;
        }

        if ((stat.cbSize.QuadPart == 0 && fCreate) || (fTruncate))
        {
            msfChk(temp->InitNew(fDelay, stat.cbSize));
            break;
        }
        msfChk(temp->Init());
    }
    while (FALSE);

    *ppms = temp;

    msfDebugOut((DEB_ITRACE,"Leaving DllMultiStreamFromStream\n"));

    if (fConvert && (stat.cbSize.QuadPart != 0) && !fDelay)
    {
        return STG_S_CONVERTED;
    }

    return S_OK;

Err:
#if !defined(MULTIHEAP)
     //take the mutex here instead of in the allocator.
     g_smAllocator.GetMutex()->Take(DFM_TIMEOUT); 
#endif
     delete temp;
#if !defined(MULTIHEAP)
     g_smAllocator.GetMutex()->Release();
#endif
     return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllReleaseMultiStream
//
//  Synopsis:   Release a CMStream instance
//
//  Effects:    Deletes a multi-stream instance
//
//  Arguments:  [pms] -- pointer to object to be deleted
//
//  Returns:    S_OK.
//
//  Modifies:   Deletes the object pointed to by pMultiStream
//
//  Algorithm:  Delete the passed in pointer.
//
//  History:    17-Aug-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void DllReleaseMultiStream(CMStream *pms)
{
    msfDebugOut((DEB_ITRACE,"In DllReleaseMultiStream(%p)\n",pms));
#if !defined(MULTIHEAP)
    //take the mutex here instead of in the allocator.
    g_smAllocator.GetMutex()->Take(DFM_TIMEOUT); 
#endif
    delete pms;
#if !defined(MULTIHEAP)
    g_smAllocator.GetMutex()->Release();
#endif
   
    msfDebugOut((DEB_ITRACE,"Out DllReleaseMultiStream()\n"));
}



//+-------------------------------------------------------------------------
//
//  Function:   DllGetScratchMultiStream
//
//  Synopsis:   Get a scratch multistream for a given LStream
//
//  Effects:    Creates new MStream instance and new handle
//
//  Arguments:  [ppms] -- pointer to location in which root
//                   	  handle is to be returned.
//              [pplstStream] -- pointer to LStream object to be used
//              [pmsMaster] - Multistream to pattern scratch after
//
//  Returns:    S_OK if call completed OK.
//              STG_E_UNKNOWN if there was a problem in setup.
//
//  Algorithm:  *Finish This*
//
//  History:    08-Jan-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllGetScratchMultiStream(CMStream **ppms,
#ifdef USE_NOSCRATCH                               
                               BOOL fIsNoScratch,
#endif                               
                               ILockBytes **pplstStream,
                               CMStream *pmsMaster)
{
    msfDebugOut((DEB_ITRACE,"In DllGetScratchMultiStream(%p,%p,%p)\n",ppms,pplstStream,pmsMaster));
    SCODE sc;
    ULARGE_INTEGER uliZero;

    CMStream *temp = NULL;

#ifdef USE_NOSCRATCH                               
    msfMem(temp = new (pmsMaster->GetMalloc())
                      CMStream(pmsMaster->GetMalloc(), pplstStream,
                               TRUE,
                               (fIsNoScratch) ? DF_NOSCRATCH : 0,
                               SCRATCHSECTORSHIFT));
#else
    msfMem(temp = new (pmsMaster->GetMalloc())
                      CMStream(pmsMaster->GetMalloc(), pplstStream,
                               TRUE,
                               SCRATCHSECTORSHIFT));
#endif                               

    ULISetHigh(uliZero, 0);
    ULISetLow(uliZero, 0);
    msfChk(temp->InitNew(FALSE, uliZero));
    *ppms = temp;

    msfDebugOut((DEB_ITRACE,"Out DllGetScratchMultiStream()\n"));
    return S_OK;

Err:
#if !defined(MULTIHEAP)
    //take the mutex here instead of in the allocator
    g_smAllocator.GetMutex()->Take(DFM_TIMEOUT);
#endif
    delete temp;
#if !defined(MULTIHEAP)
    g_smAllocator.GetMutex()->Release();
#endif
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllIsMultiStream
//
//  Synopsis:   Check a given Lstream to determine if it is a valid
//              multistream.
//
//  Arguments:  [plst] -- Pointer to lstream to check
//
//  Returns:    S_OK if lstream is a valid multistream
//              STG_E_UNKNOWN otherwise
//
//  History:    20-Feb-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllIsMultiStream(ILockBytes *plst)
{
    SCODE sc;
    CMSFHeader *phdr;
    ULONG ul;
    ULONG ulSectorSize = HEADERSIZE;

    IFileLockBytes *pfl;
    if (SUCCEEDED(plst->QueryInterface(IID_IFileLockBytes, (void**) &pfl)))
    {
        ulSectorSize = pfl->GetSectorSize();
        pfl->Release();
    }

    // CMSFHeader can be larger than a sector due to its dirty flag
    ul = (ULONG) (ulSectorSize < sizeof(CMSFHeader) ? sizeof(CMSFHeader) : ulSectorSize);
    GetSafeBuffer(ul, ul, (BYTE **) &phdr, &ul);

    ULONG ulTemp;

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);
    msfHChk(plst->ReadAt(
            ulOffset,
            phdr->GetData(),
            ulSectorSize,
            &ulTemp));

    if (ulTemp != ulSectorSize)
    {
        msfErr(Err, STG_E_UNKNOWN);
    }

    msfChk(phdr->Validate());

Err:
    FreeBuffer((BYTE *) phdr);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllSetCommitSig
//
//  Synopsis:   Set the commit signature on a given lstream, for use
//              in OnlyIfCurrent support
//
//  Arguments:  [plst] -- Pointer to the LStream to modify.
//              [sig] -- New signature
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//  History:    22-Apr-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllSetCommitSig(ILockBytes *plst, DFSIGNATURE sig)
{
    SCODE sc;
    CMSFHeader *phdr;
    ULONG ul;
    ULONG ulSectorSize = HEADERSIZE;

    IFileLockBytes *pfl;
    if (SUCCEEDED(plst->QueryInterface(IID_IFileLockBytes, (void**) &pfl)))
    {
        ulSectorSize = pfl->GetSectorSize();
        pfl->Release();
    }
    // CMSFHeader can be larger than a sector due to its dirty flag
    ul = (ULONG) (ulSectorSize < sizeof(CMSFHeader) ? sizeof(CMSFHeader) : ulSectorSize);
    GetSafeBuffer(ul, ul, (BYTE **) &phdr, &ul);

    ULONG ulTemp;

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);
    msfHChk(plst->ReadAt(
            ulOffset,
            phdr->GetData(),
            ulSectorSize,
            &ulTemp));

    if (ulTemp != ulSectorSize)
    {
        msfErr(Err, STG_E_UNKNOWN);
    }

    msfChk(phdr->Validate());

    phdr->SetCommitSig(sig);

    msfHChk(plst->WriteAt(ulOffset,
                          phdr->GetData(),
                          ulSectorSize,
                          &ulTemp));

    if (ulTemp != ulSectorSize)
    {
        msfErr(Err,STG_E_UNKNOWN);
    }

Err:
    FreeBuffer((BYTE *) phdr);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllGetCommitSig
//
//  Synopsis:   Get the commit signature from an lstream
//
//  Arguments:  [plst] -- Pointer to lstream to be operated on
//              [psig] -- Storage place for signature return
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//  History:    22-Apr-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllGetCommitSig(ILockBytes *plst, DFSIGNATURE *psig)
{
    CMSFHeader *phdr;
    SCODE sc;
    ULONG ul;
    ULONG ulSectorSize = HEADERSIZE;

    IFileLockBytes *pfl;
    if (SUCCEEDED(plst->QueryInterface(IID_IFileLockBytes, (void**) &pfl)))
    {
        ulSectorSize = pfl->GetSectorSize();
        pfl->Release();
    }

    // CMSFHeader can be larger than a sector due to its dirty flag
    ul = (ULONG) (ulSectorSize < sizeof(CMSFHeader) ? sizeof(CMSFHeader) : ulSectorSize);
    GetSafeBuffer(ul, ul, (BYTE **) &phdr, &ul);

    ULONG ulTemp;

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);
    msfHChk(plst->ReadAt(
            ulOffset,
            phdr->GetData(),
            ulSectorSize,
            &ulTemp));

    if (ulTemp != ulSectorSize)
    {
        msfErr(Err, STG_E_UNKNOWN);
    }
    msfChk(phdr->Validate());
    *psig = phdr->GetCommitSig();

Err:
    FreeBuffer((BYTE *) phdr);
    return sc;
}


#if DBG == 1

//The following is a private function so I can set the debug level easily.
VOID SetInfoLevel(ULONG x)
{

#if DBG == 1
    msfInfoLevel=x;
    _SetWin4InfoLevel(0xFFFFFFFF);
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\pbstream.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       pbstream.cxx
//
//  Contents:   CPubStream code
//
//  Classes:
//
//  Functions:
//
//  History:    16-Jan-92   PhilipLa    Created.
//              12-Jun-96   MikeHill    Renamed FlushNoException to Write,
//                                      and removed the Commit.
//              21-Jun-96   MikeHill    Fixed an Assert.
//              01-Jul-96   MikeHill    - Removed Win32 SEH from PropSet code.
//                                      - Added propset byte-swapping support.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <sstream.hxx>
#include <publicdf.hxx>
#include <pbstream.hxx>
#include <tstream.hxx>
#include <docfilep.hxx>
#include <reserved.hxx>
#include <propdbg.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CPubStream::CPubStream, public
//
//  Synopsis:   Constructor
//
//  History:    16-Jan-92       PhilipLa        Created
//
//----------------------------------------------------------------------------

CPubStream::CPubStream(CPubDocFile *ppdf,
                       DFLAGS df,
                       CDfName const *pdfn)
#pragma warning(disable: 4355)
    : _PubMappedStream(this)
#pragma warning(default: 4355)
{
    _psParent = NULL;
    _df = df;
    _ppdfParent = P_TO_BP(CBasedPubDocFilePtr, ppdf);
    _cReferences = 1;
    _dfn.Set(pdfn->GetLength(), pdfn->GetBuffer());
    _ppdfParent->AddChild(this);
    _fDirty = FALSE;
    _sig = CPUBSTREAM_SIG;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPubStream::Init, public
//
//  Synopsis:   Init function
//
//  Arguments:  [psParent] - Stream in transaction set
//              [dlLUID] - LUID
//
//  History:    16-Jan-92       PhilipLa        Created
//
//----------------------------------------------------------------------------

void CPubStream::Init(PSStream *psParent,
                      DFLUID dlLUID)
{
    _psParent = P_TO_BP(CBasedSStreamPtr, psParent);
    _luid = dlLUID;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPubStream::~CPubStream, public
//
//  Synopsis:   Destructor
//
//  History:    16-Jan-92       PhilipLa        Created
//
//----------------------------------------------------------------------------

CPubStream::~CPubStream()
{
    msfAssert(_cReferences == 0);
    _sig = CPUBSTREAM_SIGDEL;

    if (SUCCEEDED(CheckReverted()))
    {
        if (_ppdfParent != NULL)
            _ppdfParent->ReleaseChild(this);
        if (_psParent)
        {
            _psParent->Release();
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CPubStream::Release, public
//
//  Synopsis:   Release a pubstream object
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Delete 'this' - all real work done by destructor.
//
//  History:    24-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void CPubStream::vRelease(VOID)
{
    LONG lRet;
    
    msfDebugOut((DEB_ITRACE,"In CPubStream::Release()\n"));
    msfAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);

    msfAssert(!P_TRANSACTED(_df));

    if (lRet == 0)
    {
        _PubMappedStream.Cleanup();
        delete this;
    }
    msfDebugOut((DEB_ITRACE,"Out CPubStream::Release()\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CPubStream::Stat, public
//
//  Synopsis:   Fills in a stat buffer
//
//  Arguments:  [pstatstg] - Buffer
//              [grfStatFlag] - stat flags
//
//  Returns:    S_OK or error code
//
//  Modifies:   [pstatstg]
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CPubStream::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE, "In  CPubStream::Stat(%p)\n", pstatstg));
    msfChk(CheckReverted());

    msfAssert(_ppdfParent != NULL);
    pstatstg->grfMode = DFlagsToMode(_df);

    pstatstg->clsid = CLSID_NULL;
    pstatstg->grfStateBits = 0;

    pstatstg->pwcsName = NULL;
    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        msfMem(pstatstg->pwcsName = (WCHAR *)TaskMemAlloc(_dfn.GetLength()));
        memcpy(pstatstg->pwcsName, _dfn.GetBuffer(), _dfn.GetLength());
    }

#ifdef LARGE_STREAMS
    ULONGLONG cbSize;
#else
    ULONG cbSize;
#endif
    _psParent->GetSize(&cbSize);
    pstatstg->cbSize.QuadPart = cbSize;

    msfDebugOut((DEB_ITRACE, "Out CPubStream::Stat\n"));

Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubStream::RevertFromAbove, public
//
//  Synopsis:   Parent has asked for reversion
//
//  History:    29-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

void CPubStream::RevertFromAbove(void)
{
    msfDebugOut((DEB_ITRACE, "In  CPubStream::RevertFromAbove:%p()\n", this));
    _df |= DF_REVERTED;
    _psParent->Release();
    _psParent = NULL;
    msfDebugOut((DEB_ITRACE, "Out CPubStream::RevertFromAbove\n"));
}

//+--------------------------------------------------------------
//
//  Member:         CPubStream::FlushBufferedData, public
//
//  Synopsis:   Flush out the property buffers.
//
//  History:    5-May-1995      BillMo Created
//
//---------------------------------------------------------------

SCODE CPubStream::FlushBufferedData(int recursionlevel)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE, "In  CPubStream::FlushBufferedData:%p()\n", this));

    _PubMappedStream.Flush(&sc);

    msfDebugOut((DEB_ITRACE, "Out CPubStream::FlushBufferedData\n"));

    propDbg((DEB_ITRACE, "CPubStream(%08X):FlushBufferedData returns %08X\n",
        this, sc));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPubStream::Commit, public
//
//  Synopsis:   Flush stream changes to disk in the direct case.
//
//  Arguments:  None
//
//  Returns:    Appropriate status code
//
//  History:    12-Jan-93       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE CPubStream::Commit(DWORD dwFlags)
{
    SCODE sc = S_OK;
    msfDebugOut((DEB_ITRACE, "In  CPubStream::Commit:%p()\n", this));

    msfAssert(!P_TRANSACTED(_df));
    if (SUCCEEDED(sc = CheckReverted()))
    {
        if (P_WRITE(_df))
        {
            if (_ppdfParent->GetTransactedDepth() == 0)
            {
                //Parent is direct, so call commit on it and return.
                sc = _ppdfParent->GetBaseMS()->Flush(FLUSH_CACHE(dwFlags));
            }
            SetClean();
        }
    }
    msfDebugOut((DEB_ITRACE, "Out CPubStream::Commit\n"));
    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Open
//
//  Synopsis:   Opens mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Gets the size of the underlying stream and reads it
//              into memory so that it can be "mapped." 
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Open(IN VOID *powner, OUT LONG *phr)
{
    *phr = S_OK;
    olAssert(!_fLowMem);

    // If given a pointer to the owner of this mapped stream,
    // save it.  This could be NULL (i.e., when called from
    // ReOpen).

    if( NULL != powner  )
        _powner = P_TO_BP( CBasedBytePtr, ((BYTE*) powner) );

    if (_pb == NULL)
    {
        VOID *pv;
#ifdef LARGE_STREAMS
        ULONGLONG ulSize;
#else
        ULONG ulSize;
#endif

        _cbUsed = 0;

        *phr = _pst->GetSize(&ulSize);
        if (*phr != S_OK)
            goto Throw;

        if (ulSize > CBMAXPROPSETSTREAM)
        {
            *phr = STG_E_INVALIDHEADER;
            goto Throw;
        }

        _cbOriginalStreamSize = (ULONG) ulSize;
        _cbUsed = _cbOriginalStreamSize;

        pv = GetMalloc()->Alloc(_cbOriginalStreamSize);

        if (pv == NULL)
        {
            pv = g_ReservedMemory.LockMemory();
            if( NULL == pv )
            {
                *phr = E_OUTOFMEMORY;
                goto Throw;
            }

            _fLowMem = TRUE;
        }
        _pb = P_TO_BP(CBasedBytePtr, ((BYTE*)pv));
        *phr = _pst->ReadAt(0, 
                      pv, 
                      _cbOriginalStreamSize, 
                      &_cbUsed);

#if BIGENDIAN==1
        // Notify our owner that we've read in new data.
        if (*phr == S_OK && _powner != NULL && 0 != _cbUsed)
        {
            *phr = RtlOnMappedStreamEvent( BP_TO_P(VOID*, _powner), pv, _cbUsed );
        }
#endif

        if (*phr != S_OK)
        {
            if (_fLowMem)
                g_ReservedMemory.UnlockMemory();
            else
                GetMalloc()->Free(pv);

            _pb = NULL;
            _cbUsed = 0;
            _fLowMem = FALSE;
            goto Throw;
        }

    }

    propDbg((DEB_ITRACE, "CPubStream(%08X):Open returns normally\n", this));
    return;

Throw:

    propDbg((DEB_ERROR, "CPubStream(%08X):Open exception returns %08X\n", this, *phr));

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Flush
//
//  Synopsis:   Flush the mapped Stream to the underlying Stream,
//              and Commit that Stream.
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Flush(OUT LONG *phr)
{
    // Write out any data we have cached to the Stream.
    *phr = Write();

    // Commite the Stream.
    if( SUCCEEDED(*phr) )
    {
        *phr = _pst->Commit(STGC_DEFAULT);
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Close
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Does nothing because the object may be mapped in
//              another process.
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Close(OUT LONG *phr)
{
    // Write the changes.  We don't need to Commit them,
    // they will be implicitely committed when the 
    // Stream is Released.

    *phr = Write();

    if( FAILED(*phr) )
    {
        propDbg((DEB_ERROR, "CPubStream(%08X)::Close exception returns %08X\n", this, *phr));
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::ReOpen
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Combined open and map.
//
//--------------------------------------------------------------------

VOID CPubMappedStream::ReOpen(IN OUT VOID **ppv, OUT LONG *phr)
{
    *ppv = NULL;

    Open(NULL,  // Unspecified owner.
         phr);

    if( SUCCEEDED(*phr) )
        *ppv = BP_TO_P(VOID*, _pb); 

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Quiesce
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Meaningless for docfile mapped stream.
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Quiesce(VOID)
{
    olAssert(_pb != NULL); 
    DfpdbgCheckUnusedMemory();
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Map
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Return the address of the "mapping" buffer.
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Map(BOOLEAN fCreate, VOID **ppv) 
{ 
    olAssert(_pb != NULL); 
    DfpdbgCheckUnusedMemory();
    *ppv = BP_TO_P(VOID*, _pb); 
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Unmap
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Unmapping is merely zeroing the pointer.  We don't
//              flush because that's done explicitly by the 
//              CPropertyStorage class.
//              
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Unmap(BOOLEAN fFlush, VOID **pv)
{
    DfpdbgCheckUnusedMemory();
    *pv = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Write
//
//  Synopsis:   Writes a mapped view of an exposed Stream to the
//              underlying Stream.  Used by RtlCreatePropertySet et al.
//
//  Notes:      The Stream is not commited.  To commit the Stream, in
//              addition to writing it, the Flush method should be used.
//              The Commit is omitted so that it can be skipped in
//              the Property Set Close path, thus eliminating a
//              performance penalty.
//
//--------------------------------------------------------------------

HRESULT CPubMappedStream::Write ()
{
    HRESULT hr;
    ULONG cbWritten;

    if (!_fDirty)
    {
        propDbg((DEB_ITRACE, "CPubStream(%08X):Flush returns with not-dirty\n", this));

        return S_FALSE;  // flushing a stream which isn't a property stream
                         // this could be optimized by propagating a 'no property streams'
                         // flag up the storage hierachy such that FlushBufferedData is
                         // not even called for non-property streams.
    }

    olAssert( _pst != NULL );
    olAssert( _pb != NULL );
    olAssert( _powner != NULL );

#if BIGENDIAN==1
    // Notify our owner that we're about to perform a Write.
    hr = RtlOnMappedStreamEvent( BP_TO_P(VOID*, _powner), BP_TO_P(VOID *, _pb), _cbUsed );
    if( S_OK != hr ) goto Exit;
#endif

    hr = _pst->WriteAt(0, BP_TO_P(VOID *, _pb), _cbUsed, &cbWritten);
    if( S_OK != hr ) goto Exit;

#if BIGENDIAN==1
    // Notify our owner that we're done with the Write.
    hr = RtlOnMappedStreamEvent( BP_TO_P(VOID*, _powner), BP_TO_P(VOID *, _pb), _cbUsed );
    if( S_OK != hr ) goto Exit;
#endif

    if (_cbUsed < _cbOriginalStreamSize)
    {
        // if the stream is shrinking, this is a good time to do it.
        hr = _pst->SetSize(_cbUsed);
        if( S_OK != hr ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    if (hr == S_OK || hr == STG_E_REVERTED)
    {
        _fDirty = FALSE;
    }

    propDbg((DEB_ITRACE, "CPubStream(%08X):Flush %s returns hr=%08X\n",
        this, hr != S_OK ? "exception" : "", hr));

    return hr;

}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::GetSize
//
//  Synopsis:   Returns size of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//--------------------------------------------------------------------

ULONG CPubMappedStream::GetSize(OUT LONG *phr)
{
    *phr = S_OK;

    if (_pb == NULL)
        Open(NULL,  // Unspecified owner
             phr);

    if( SUCCEEDED(*phr) )
    {
        olAssert(_pb != NULL); 
        DfpdbgCheckUnusedMemory();
    }
    
    return _cbUsed;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::SetSize
//
//  Synopsis:   Sets size of "map." Called by 
//              NtCreatePropertySet et al.
//
//  Arguments:  [cb] -- requested size.
//		[fPersistent] -- FALSE if expanding in-memory read-only image
//              [ppv] -- new mapped address.
//
//  Signals:    Not enough disk space.
//
//  Notes:      In a low memory situation we may not be able to
//              get the requested amount of memory.  In this
//              case we must fall back on disk storage as the
//              actual map.
//
//--------------------------------------------------------------------

VOID
CPubMappedStream::SetSize(ULONG cb, IN BOOLEAN fPersistent, VOID **ppv, OUT LONG *phr)
{
    VOID *pv;

    *phr = S_OK;
    olAssert(cb != 0);    
    
    DfpdbgCheckUnusedMemory();

    //
    // if we are growing the data, we should grow the stream
    //

    if (fPersistent && cb > _cbUsed)
    {
        *phr = _pst->SetSize(cb);
        if (*phr != S_OK)
            goto Throw;
    }
    
    if (!_fLowMem)
    {
        pv = GetMalloc()->Realloc(BP_TO_P(VOID*, _pb), cb);
        
        if (pv == NULL)
        {
            // allocation failed: we need to try using a backup mechanism for
            // more memory.
            // copy the data to the global reserved chunk... we will wait until
            // someone else has released it.  it will be released on the way out
            // of the property code.

            pv = g_ReservedMemory.LockMemory();
            if( NULL == pv )
            {
                *phr = E_OUTOFMEMORY;
                goto Throw;
            }

            _fLowMem = TRUE;

            if (NULL != BP_TO_P(BYTE*, _pb))
            {
                __try
                {
                    memcpy(pv, BP_TO_P(VOID*, _pb), _cbUsed);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    g_ReservedMemory.UnlockMemory();
                    _fLowMem = FALSE;
                    *phr = E_OUTOFMEMORY;
                    goto Throw;
                }
            }
            GetMalloc()->Free(BP_TO_P(VOID*, _pb));
        }
	    _pb = P_TO_BP(CBasedBytePtr, ((BYTE*)pv));
	    *ppv = pv;
    }
    else
    {
        *ppv = BP_TO_P(VOID*, _pb);
    }       
            
    _cbUsed = cb;
    DfpdbgFillUnusedMemory();

Throw:

    propDbg((DEB_ITRACE, "CPubStream(%08X):SetSize %s returns hr=%08X\n",
        this, *phr != S_OK ? "exception" : "", *phr));

}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Lock
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//              the exposed stream has enforced the locking.
//
//              we use the lock to indicate whether the object is
//              dirty
//
//--------------------------------------------------------------------

NTSTATUS CPubMappedStream::Lock(BOOLEAN fExclusive)
{
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Unlock
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

NTSTATUS CPubMappedStream::Unlock(VOID)
{
    // if at the end of the properties set/get call we have the low
    // memory region locked, we flush to disk.
    HRESULT hr = S_OK;

    if (_fLowMem)
    {
        Flush(&hr);

        g_ReservedMemory.UnlockMemory();
        _pb = NULL;
        _cbUsed = 0;
        _fLowMem = FALSE;
        propDbg((DEB_ITRACE, "CPubStream(%08X):Unlock low-mem returns NTSTATUS=%08X\n",
            this, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::QueryTimeStamps
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CPubMappedStream::QueryTimeStamps(STATPROPSETSTG *pspss, BOOLEAN fNonSimple) const
{
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::QueryModifyTime
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CPubMappedStream::QueryModifyTime(OUT LONGLONG *pll) const
{
    return(FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::QuerySecurity
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CPubMappedStream::QuerySecurity(OUT ULONG *pul) const
{
    return(FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::QueryTimeStamps
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CPubMappedStream::IsWriteable() const
{
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::SetChangePending
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBG == 1
BOOLEAN CPubMappedStream::SetChangePending(BOOLEAN f)
{
    BOOLEAN fOld = _fChangePending;
    _fChangePending = f;
    return(_fChangePending);
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::IsNtMappedStream
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBG == 1
BOOLEAN CPubMappedStream::IsNtMappedStream(VOID) const
{
    return(FALSE);
}
#endif


//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::GetHandle
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

HANDLE CPubMappedStream::GetHandle(VOID) const
{
    return(INVALID_HANDLE_VALUE);
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::SetModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CPubMappedStream::SetModified(OUT LONG *phr)
{
    _fDirty = TRUE;
    *phr = S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::IsModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CPubMappedStream::IsModified(VOID) const
{
    return _fDirty;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::DfpdbgFillUnusedMemory
//
//--------------------------------------------------------------------

#if DBG == 1
VOID CPubMappedStream::DfpdbgFillUnusedMemory(VOID)
{

    if (_pb == NULL)
        return;

    BYTE * pbEndPlusOne = BP_TO_P(BYTE*, _pb) + BytesCommitted();

    for (BYTE *pbUnused = BP_TO_P(BYTE*, _pb) + _cbUsed;
         pbUnused < pbEndPlusOne;
         pbUnused++)
    {
        *pbUnused = (BYTE)(ULONG_PTR)pbUnused;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::DfpdbgCheckUnusedMemory
//
//--------------------------------------------------------------------

VOID CPubMappedStream::DfpdbgCheckUnusedMemory(VOID)
{

    if (_pb == NULL)
        return;

    if (_cbUsed == 0)
        return;

    BYTE * pbEndPlusOne = BP_TO_P(BYTE*, _pb) + BytesCommitted();

    for (BYTE *pbUnused = BP_TO_P(BYTE*, _pb + _cbUsed) ;
         pbUnused < pbEndPlusOne;
         pbUnused ++)
    {
        olAssert(*pbUnused == (BYTE)(ULONG_PTR)pbUnused);
    }
}

#endif    // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\fat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       fat.cxx
//
//  Contents:   Allocation functions for MStream
//
//  Classes:    None. (defined in fat.hxx)
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <difat.hxx>
#include <sstream.hxx>
#include <mread.hxx>

#define USE_NOSCRATCHINMARKSECT

//#define SECURETEST
//+---------------------------------------------------------------------------
//
//  Member:	CFat::IsFree, private
//
//  Synopsis:	Check and see if a given sector is really free, given all
//              the permutations of ways a sector can be assigned.
//
//  Arguments:	[sect] -- Sector to check
//
//  Returns:	S_OK if sector is really free.
//              S_FALSE if sector is really allocated.
//              Appropriate error in error case.
//
//  Modifies:	
//
//  History:	30-Mar-95	PhilipLa	Created
//              15-Mar-97       BChapman        Calls IsSectType()
//
//----------------------------------------------------------------------------

inline SCODE CFat::IsFree(SECT sect)
{
    return IsSectType(sect, FREESECT);
}

//
//+---------------------------------------------------------------------------
//
//  Member:	CFat::IsSectType, private
//
//  Synopsis:	Check and see if a given sector is really of a given type,
//              given all the permutations of ways a sector can be assigned.
//              If we are looking for FREESECT there are extra checks.
//
//  Arguments:	[sect]     -- Sector to check
//              [sectType] -- Sector type to check against FREE, FAT, DIF.
//
//  Returns:	S_OK if sector is really free.
//              S_FALSE if sector is really allocated.
//              Appropriate error in error case.
//
//  Modifies:	
//
//  History:	18-Feb-97	BChapman	Created
//
//----------------------------------------------------------------------------

inline SCODE CFat::IsSectType(SECT sect, SECT sectType)
{
    SCODE sc = S_OK;
    SECT sectCurrent = sectType;

#ifdef DEBUG_ISSECTTYPE
    msfDebugOut((DEB_ITRACE, "In  CFat::IsSectType:%p(%x, %x)\n",
                                    this, sect, sectType));
#endif

    if((FREESECT == sectType))
    {
        if (sect < _sectNoSnapshot)
        {
            return S_FALSE;
        }
        if ((_sectNoSnapshotFree != ENDOFCHAIN)
                        && (sect < _sectNoSnapshotFree))
        {
            return S_FALSE;
        }
    }

    if (_pfatNoScratch != NULL)
    {
        msfAssert((!_pmsParent->IsScratch()) &&
                  aMsg("Scratch MS in Noscratch mode"));

        FSINDEX ipfs;
        FSOFFSET isect;

        _pfatNoScratch->SectToPair(sect, &ipfs, &isect);

        if (ipfs < _pfatNoScratch->_cfsTable)
        {
            //We need to check the NoScratch fat to make sure
            //that this sector isn't already allocated into
            //scratch space for a stream.

            msfChk(_pfatNoScratch->GetNext(
                sect,
                &sectCurrent));
        }
    }
    //Since the no-scratch fat will have a complete copy of everything
    //  in the shadow fat, we don't need to check both.  So only do this
    //  when we're not in no-scratch mode.
    //The no-scratch fat also has a copy of the read-only GetFree()
    //  returned stuff, so we only need to do that check when not in
    //  no-scratch.
    else
    {
        if (_cUnmarkedSects > 0)
        {
            //We are in copy-on-write mode.  Lookup this
            //sector in the DIF and make sure that it is
            //actually free.
            msfAssert((_sectLastUsed > 0) &&
                      aMsg("Doing DIFat check when not in COW."));

            msfChk(_pmsParent->GetDIFat()->Lookup(
                sect,
                &sectCurrent));
        }

        if (FREESECT == sectType)
        {
            if ((sect < _sectLastUsed) && (sectCurrent == FREESECT))
            {
                //We're in copy-on-write mode, so
                //   this sector may not be really free.
                msfAssert(_sid != SIDMINIFAT &&
                          aMsg("Minifat in Copy-on-Write mode"));
                msfAssert(_pfatReal != NULL &&
                          aMsg("Copy-On-Write mode without fat copy"));
                msfAssert(_pfatReal->_cfsTable != 0 &&
                          aMsg("Copy-on-Write mode with empty fat copy"));
                msfAssert(_pfatReal->_pmsParent->IsShadow() &&
                          aMsg("Copy-on-Write mode with non-shadow fat copy"));

                msfChk(_pfatReal->GetNext(sect, &sectCurrent));
            }
        }
    }

    if (sectCurrent != sectType)
    {
        sc = S_FALSE;
    }

#ifdef DEBUG_ISSECTTYPE
    msfDebugOut((DEB_ITRACE, "Out CFat::IsSectType\n"));
#endif

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFatSect::Init, public
//
//  Synopsis:   CFatSect initialization function
//
//  Effects:    [uEntries] -- Number of entries in sector
//
//  Algorithm:  Allocate an array of SECT with size uEntries from
//              the heap.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              27-Dec-91   PhilipLa    Converted to dynamic allocation
//
//--------------------------------------------------------------------------


SCODE CFatSect::Init(FSOFFSET uEntries)
{
    msfDebugOut((DEB_FAT,"In CFatSect constructor\n"));

    //This assumes that FREESECT is always 0xFFFFFFFF
    memset(_asectEntry, 0xFF, uEntries * sizeof(SECT));

    msfDebugOut((DEB_FAT,"Out CFatSect constructor\n"));
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFatSect::InitCopy, public
//
//  Synopsis:   Initialization function for copying FatSects
//
//  Arguments:  [fsOld] -- Reference to FatSect to be copies
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  Allocate a new array of SECT and copy old
//                  information in.
//
//  History:    06-Feb-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


SCODE CFatSect::InitCopy(USHORT uSize, CFatSect *pfsOld)
{
    msfDebugOut((DEB_FAT,"In CFatSect copy constructor\n"));
    msfDebugOut((DEB_FAT,"This = %p,  fsOld = %p\n",this, pfsOld));

    msfDebugOut((DEB_FAT,"Sector size is %u sectors\n", uSize));

    memcpy(_asectEntry, &pfsOld->_asectEntry, sizeof(SECT)*uSize);
    msfDebugOut((DEB_FAT,"Out CFatSect copy constructor\n"));
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::CFat, public
//
//  Synopsis:   CFat constructor.
//
//  Arguments:  [pmsParent] -- Pointer to parent multistream.
//
//  Algorithm:  Set uFatEntries to match parent MS header info.
//              Initialize all member variables.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              27-Dec-91   PhilipLa    Converted to use FatVector
//              30-Dec-91   PhilipLa    Converted to use variable size sect.
//
//  Notes:
//
//--------------------------------------------------------------------------


CFat::CFat(SID sid)
: _fv(sid),
  _pfatReal(NULL),
  _pfatNoScratch(NULL),
  _sectNoSnapshot(0),
  _sectNoSnapshotFree(ENDOFCHAIN),
  _sid(sid),
  _pmsParent(NULL),
  _sectFirstFree(0),
  _sectLastUsed(0),
  _sectMax(ENDOFCHAIN)
{
    _cUnmarkedSects = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::CFat, public
//
//  Synopsis:   CFat copy constructor
//
//  Arguments:  [fatOld] -- Fat to be copied.
//
//  Algorithm:  Set member variables to match fat being copied.
//
//  History:    27-Dec-91   PhilipLa    Created.
//
//  Notes:      This is for use in transactioning.  It is the only proper
//              way to create a Shadow Fat.
//
//--------------------------------------------------------------------------


CFat::CFat(CFat *pfatOld)
  :    _pmsParent(pfatOld->_pmsParent),
       _fv(pfatOld->_sid),
       _pfatReal(NULL),
       _sid(pfatOld->_sid),
       _sectFirstFree(0),
       _sectLastUsed(0),
       _sectMax(ENDOFCHAIN),
       _sectNoSnapshot(pfatOld->_sectNoSnapshot)
{
    _cUnmarkedSects = 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFat::InitCopy, public
//
//  Synopsis:   Init function for CFat copying
//
//  Arguments:  [fatOld] -- reference to CFat to be copied
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    18-Feb-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------


void CFat::InitCopy(CFat *pfatOld)
{
    msfDebugOut((DEB_FAT,"In CFat Copy Constructor\n"));

    _pmsParent = pfatOld->_pmsParent;

    _uFatShift = pfatOld->_uFatShift;
    _uFatMask = pfatOld->_uFatMask;

    _fv.InitCommon(1 << _uFatShift, 1 << _uFatShift);

    _cfsTable = pfatOld->_cfsTable;

    _fv.InitCopy(&pfatOld->_fv);

    _ulFreeSects = MAX_ULONG;
    _sectFirstFree = pfatOld->_sectFirstFree;
    _sectLastUsed = pfatOld->_sectLastUsed;
    _sectMax = pfatOld->_sectMax;
    _ipfsRangeLocks = pfatOld->_ipfsRangeLocks;
    _isectRangeLocks = pfatOld->_isectRangeLocks;

    msfDebugOut((DEB_FAT,"Out CFat Copy Constructor\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CFat::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


void CFat::Empty(void)
{
    _fv.Empty();
    _pmsParent = NULL;
    _pfatReal = NULL;
    _cfsTable = 0;
    _ulFreeSects = MAX_ULONG;
    _sectFirstFree = 0;
    _sectLastUsed = 0;
    _sectMax = ENDOFCHAIN;
    _cUnmarkedSects = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::~CFat, public
//
//  Synopsis:   CFat Destructor
//
//  Algorithm:  delete dynamically allocated storage
//
//  History:    18-Jul-91   PhilipLa    Created.
//              27-Jul-91   PhilipLa    Converted to use FatVect.
//
//  Notes:
//
//--------------------------------------------------------------------------


CFat::~CFat()
{
    msfDebugOut((DEB_FAT,"In CFat destructor.  Size of fat is %lu\n",_cfsTable));

    msfDebugOut((DEB_FAT,"Exiting CFat destructor\n"));
}

struct SGetFreeStruct
{
    CVectBits *pfb;

    SECT sect;
    CFatSect *pfs;
    FSOFFSET isect;
    FSINDEX ipfs;

    SECT sectLast;
    FSINDEX ipfsLast;
    FSOFFSET isectLast;

#ifdef USE_NOSCRATCHINMARKSECT
    CFatSect *pfsNoScratch;
    FSINDEX ipfsNoScratch;
#endif
};



//+---------------------------------------------------------------------------
//
//  Member:	CFat::InitGetFreeStruct, private
//
//  Synopsis:	Initialize an SGetFreeStruct
//
//  Arguments:	[pgf] -- Pointer to structure to initialize
//
//  History:	03-Nov-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CFat::InitGetFreeStruct(SGetFreeStruct *pgf)
{
    pgf->sectLast = ENDOFCHAIN;
    pgf->pfs = NULL;
#ifdef USE_NOSCRATCHINMARKSECT
    pgf->pfsNoScratch = NULL;
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:	CFat::ReleaseGetFreeStruct, private
//
//  Synopsis:	Release an SGetFreeStruct
//
//  Arguments:	[pgf] -- Pointer to structure to release
//
//  History:	03-Nov-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CFat::ReleaseGetFreeStruct(SGetFreeStruct *pgf)
{
    if (pgf->pfs != NULL)
    {
        _fv.ReleaseTable(pgf->ipfs);
    }
#ifdef USE_NOSCRATCHINMARKSECT
    if (pgf->pfsNoScratch != NULL)
    {
        _pfatNoScratch->_fv.ReleaseTable(pgf->ipfsNoScratch);
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:	CFat::MarkSect, private
//
//  Synopsis:	Mark a sector as used, for use from GetFree and GetFreeContig
//
//  Arguments:	[pgf] -- Pointer to SGetFreeStruct with information about
//                       which sector to mark.  This structure also returns
//                       information to the caller, so that state can be
//                       preserved across multiple calls for optimization.
//
//  Returns:	Appropriate status code
//
//  History:	27-Oct-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

inline SCODE CFat::MarkSect(SGetFreeStruct *pgf)
{
    msfAssert(_ulFreeSects != MAX_ULONG &&
              aMsg("Free sect count not set"));

    SCODE sc = S_OK;

    _ulFreeSects--;

    CVectBits * &pfb = pgf->pfb;

    SECT &sect = pgf->sect;
    FSOFFSET &isect = pgf->isect;
    FSINDEX &ipfs = pgf->ipfs;
    CFatSect * &pfs = pgf->pfs;
#ifdef USE_NOSCRATCHINMARKSECT
    CFatSect * &pfsNoScratch = pgf->pfsNoScratch;
    FSINDEX &ipfsNoScratch = pgf->ipfsNoScratch;
#endif

    SECT &sectLast = pgf->sectLast;
    FSINDEX &ipfsLast = pgf->ipfsLast;
    FSOFFSET &isectLast = pgf->isectLast;

    //If we're tracking the first free sector, we know it must be
    //  after this one, so set firstfree.
    if (pfb != NULL)
    {
        pfb->firstfree = isect + 1;
    }

    //Update _sectFirstFree, since the first free sector must be after then
    //  current one.
    msfAssert(sect >= _sectFirstFree &&
              aMsg("Found free sector before _sectFirstFree"));
    _sectFirstFree = sect + 1;

    //Mark the current sector as ENDOFCHAIN in the fat.
    pfs->SetSect(isect, ENDOFCHAIN);

    if (_pfatNoScratch != NULL)
    {
#ifdef USE_NOSCRATCHINMARKSECT
        //In no-scratch, update the no-scratch fat
        //as well.
        FSINDEX  ipfsNoScratchChk;
        FSOFFSET isectNoScratchChk;
        _pfatNoScratch->SectToPair(sect,
                                   &ipfsNoScratchChk,
                                   &isectNoScratchChk);

        if ((pfsNoScratch != NULL) && (ipfsNoScratch != ipfsNoScratchChk))
        {
            _pfatNoScratch->_fv.ReleaseTable(ipfsNoScratch);
            pfsNoScratch = NULL;
        }

        if (pfsNoScratch == NULL)
        {
            //SetNext call will grow the no-scratch fat if necessary.
            msfChk(_pfatNoScratch->SetNext(sect, ENDOFCHAIN));
            msfChk(_pfatNoScratch->_fv.GetTable(ipfsNoScratchChk,
                                                FB_DIRTY,
                                                &pfsNoScratch));
            ipfsNoScratch = ipfsNoScratchChk;
        }
        else
        {
            pfsNoScratch->SetSect(isectNoScratchChk, ENDOFCHAIN);
            _pfatNoScratch->_ulFreeSects--;
        }
#else
        msfChk(_pfatNoScratch->SetNext(sect, ENDOFCHAIN)); // slow, unoptimized
#endif
    }

    //Dirty the current page.
    if ((sectLast == ENDOFCHAIN) || (ipfs != ipfsLast))
    {
        //We only need to make this call if we're touching a new
        //  page for the first time.
        msfChk(_fv.SetDirty(ipfs));
    }

    //If we're building a chain, we want to update it here.
    if (sectLast != ENDOFCHAIN)
    {
        if (_pfatNoScratch != NULL)
        {
#ifdef USE_NOSCRATCHINMARKSECT
            FSINDEX ipfsNoScratchChk;
            FSOFFSET isectNoScratchChk;
            _pfatNoScratch->SectToPair(sectLast,
                                       &ipfsNoScratchChk,
                                       &isectNoScratchChk);

            if (ipfsNoScratchChk == ipfsNoScratch)
            {
                msfAssert(pfsNoScratch != NULL);
                pfsNoScratch->SetSect(isectNoScratchChk, sect);
            }
            else
            {
                msfChk(_pfatNoScratch->SetNext(sectLast, sect));
            }
#else
            msfChk(_pfatNoScratch->SetNext(sectLast, sect)); //slow,unoptimized
#endif
        }
        //If we're in the same page, we can do this cheaply.
        if (ipfsLast == ipfs)
        {
            pfs->SetSect(isectLast, sect);
        }
        else
        {
            //If we're NOT on the same page, we have to go grab the
            //  old one again, which can be expensive if the page table is full
            CFatSect *pfsLast;

            //Since we may only have one available page for the scratch MS,
            //  we need to release the current one before proceeding.
            //  
            if (_pmsParent->IsScratch())
            {
                _fv.ReleaseTable(ipfs);
            }

            msfChk(_fv.GetTable(ipfsLast,
                                FB_DIRTY,
                                &pfsLast));

            pfsLast->SetSect(isectLast, sect);
            _fv.ReleaseTable(ipfsLast);

            //Reacquire the current page if we're in the scratch.
            if (_pmsParent->IsScratch())
            {
                msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));
            }
        }
    }

    return S_OK;
Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetFree, private
//
//  Synposis:   Locate and return a free sector in the FAT
//
//  Effects:    May modify full bit on full sectors
//
//  Arguments:  [psectRet] -- Pointer to return value
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  Do a linear search of all tables until a free sector is
//              found.  If all tables are full, extend the FAT by one
//              sector.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              22-Jul-91   PhilipLa    Added FAT extension.
//              17-Aug-91   PhilipLa    Added full bits optimization
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::GetFree(ULONG ulCount, SECT *psectRet, BOOL fReadOnly)
{
    SGetFreeStruct gf;

    SECT &sect = gf.sect;
    CVectBits * &pfb = gf.pfb;
    FSOFFSET &isect = gf.isect;
    FSINDEX &ipfs = gf.ipfs;
    CFatSect * &pfs = gf.pfs;
    SECT &sectLast = gf.sectLast;
    FSINDEX &ipfsLast = gf.ipfsLast;
    FSOFFSET &isectLast = gf.isectLast;

    InitGetFreeStruct(&gf);

    SCODE sc;

    *psectRet = ENDOFCHAIN;

    msfAssert((!_pmsParent->IsShadow()) &&
              aMsg("Modifying shadow fat."));

    msfAssert(((!fReadOnly) || (ulCount == 1)) &&
              aMsg("Read-only GetFree called with ulCount != 1"));
    if (_sectNoSnapshotFree != ENDOFCHAIN)
    {
        //We're resizing our control structures to prepare for
        //  no-snapshot commit.
        msfAssert((ulCount == 1) &&
                  aMsg("No-snapshot GetFree called with ulCount != 1"));
        msfAssert(fReadOnly &&
                  aMsg("No-snapshot GetFree called without fReadOnly"));
        *psectRet = _sectNoSnapshotFree++;
        _cUnmarkedSects++;
        if ((_ulFreeSects != 0) && (_ulFreeSects != MAX_ULONG))
        {
            _ulFreeSects--;
        }
        if (*psectRet >= _sectMax)
        {
            _sectMax = *psectRet + 1;
        }
        return S_OK;
    }

    if ((fReadOnly) && (_pfatNoScratch != NULL))
    {
        //As an optimization, and to prevent loops, we can dispatch
        //this call directly to the no-scratch fat, since it has a
        //complete picture of everything allocated in this fat.

        //Note that we don't need to pass the read-only flag to the
        //no-scratch, since it's perfectly OK to scribble on it
        //as much as we want.

        //Further note that if fReadOnly is true, then ulCount must be
        //  1, so we can just work with the constant.
        msfChk(_pfatNoScratch->GetFree(1, psectRet, GF_WRITE));
        if (_ulFreeSects != MAX_ULONG)
        {
            _ulFreeSects--;
        }

        _cUnmarkedSects++;
        if (*psectRet >= _sectMax)
        {
            _sectMax = *psectRet + 1;
        }
        return S_OK;
    }

    while (TRUE)
    {
        //Make sure there are enough free sectors to hold the whole chain
        //  we're trying to allocate.
        if (_ulFreeSects == MAX_ULONG)
        {
            msfChk(CountFree(&_ulFreeSects));
        }
#if DBG == 1
        else
        {
            CheckFreeCount();
        }
#endif

        while (ulCount > _ulFreeSects)
        {
#if DBG == 1 && !defined(USE_NOSCRATCH)
            ULONG ulFree = _ulFreeSects;
#endif
            msfChk(Resize(_cfsTable +
                          ((ulCount - _ulFreeSects + _fv.GetSectTable() - 1) >>
                           _uFatShift)));
#if DBG == 1 && !defined(USE_NOSCRATCH)
            msfAssert(_ulFreeSects > ulFree &&
                      aMsg("Number of free sectors didn't increase after Resize."));
#endif

        }

        //Starting at the first known free sector, loop until we find
        //  enough sectors to complete the chain.
        FSOFFSET isectStart;
        FSINDEX ipfsStart;

        SectToPair(_sectFirstFree, &ipfsStart, &isectStart);

        for (ipfs = ipfsStart; ipfs < _cfsTable; ipfs++)
        {
            //Only check a page if it is not known to be full.
            pfb = _fv.GetBits(ipfs);

            if ((pfb == NULL) || (!pfb->full))
            {
                msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

                //Eliminate part of the search based on the first-known
                //  free entry for the page
                if (pfb != NULL)
                {
                    isectStart = pfb->firstfree;
                }

                for (isect = isectStart; isect < _fv.GetSectTable(); isect++)
                {
                    SECT sectCurrent = pfs->GetSect(isect);
                    sect = PairToSect(ipfs, isect);

                    //If the sector is marked FREESECT, it still may not
                    //  really be free.  The IsFree function will return
                    //  S_OK if it is OK to allocate.
                    if ((sectCurrent == FREESECT) &&
                        ((sc = IsFree(sect)) == S_OK))
                    {
                        //If fReadOnly is TRUE (meaning we're being called
                        //  by the DIFat), then we don't want to actually
                        //  mark anything in the current fat.  We'll return
                        //  the current sector and then be done with it.
                        if (fReadOnly)
                        {
                            _cUnmarkedSects++;
                            _ulFreeSects--;
                        }
                        else
                        {
                            //Mark the sector as free and return it.
                            msfChkTo(Err_Rel, MarkSect(&gf));
                        }

                        if (*psectRet == ENDOFCHAIN)
                        {
                            *psectRet = sect;
                        }

                        ulCount--;

                        if (ulCount == 0)
                        {
                            //If we're done, release the current table,
                            //  update _sectMax, and return.

                            if (sect >= _sectMax)
                            {
                                _sectMax = sect + 1;
                            }

                            ReleaseGetFreeStruct(&gf);
                            return S_OK;
                        }
                        else
                        {
                            //Otherwise update the internal counters and
                            //  keep going.
                            sectLast = sect;
                            ipfsLast = ipfs;
                            isectLast = isect;
                        }
                    }
                    else
                    {
                        msfChkTo(Err_Rel, sc);
                    }

                }
                _fv.ReleaseTable(ipfs);
                //If we are keeping a full bit, we can set it here, since
                //  we know we've allocated everything out of the current
                //  page.
                // the vectbits pointer may have changed due to a resize
                pfb = _fv.GetBits(ipfs);
                if (pfb != NULL)
                {
                    pfb->full = TRUE;
                }
            }
            isectStart = 0;
        }

        //Keep _sectMax up to date for SetSize purposes.
        if (sectLast >= _sectMax)
        {
            _sectMax = sectLast + 1;
        }
    }
    msfAssert(0 &&
              aMsg("GetFree exited improperly."));
    sc = STG_E_ABNORMALAPIEXIT;

Err:
    ReleaseGetFreeStruct(&gf);
    return sc;

Err_Rel:
    ReleaseGetFreeStruct(&gf);
    return sc;
}






//+---------------------------------------------------------------------------
//
//  Member:	CFat::GetFreeContig, public
//
//  Synopsis:	Return a chain of free sectors, including contiguity
//              information about the chain.
//
//  Arguments:	[ulCount] -- Number of sectors to allocate
//              [aseg] -- Contig table to fill in
//              [cSeg] -- Index of last used segment in contig table.
//              [pcSegReturned] -- Pointer to return location for total
//                                 number of segments returned.
//
//  Returns:	Appropriate status code
//
//  History:	27-Oct-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CFat::GetFreeContig(ULONG ulCount,
                                    SSegment STACKBASED *aseg,
                                    ULONG cSeg,
                                    ULONG *pcSegReturned)
{
    SGetFreeStruct gf;

    SECT &sect = gf.sect;
    CVectBits * &pfb = gf.pfb;
    FSOFFSET &isect = gf.isect;
    FSINDEX &ipfs = gf.ipfs;
    CFatSect * &pfs = gf.pfs;
    SECT &sectLast = gf.sectLast;
    FSINDEX &ipfsLast = gf.ipfsLast;
    FSOFFSET &isectLast = gf.isectLast;

    InitGetFreeStruct(&gf);

    FSINDEX ipfsFirstDirty;

    SCODE sc;

    //Variables used for tracking contiguity.
    //cSegCurrent is the current segment being processed.
    ULONG cSegCurrent = cSeg;

    //sectLast is the last sector returned.  We start this with the
    //  last thing in the current contig table, and the MarkSect
    //  function will patch up the chain for us.
    sectLast = aseg[cSeg].sectStart + aseg[cSeg].cSect - 1;
    SectToPair(sectLast, &ipfsLast, &isectLast);
    ipfsFirstDirty = ipfsLast;
#if DBG == 1
    SECT sectTest;
    GetNext(sectLast, &sectTest);
    msfAssert(sectTest == ENDOFCHAIN);
#endif

    msfAssert((!_pmsParent->IsShadow()) &&
              aMsg("Modifying shadow fat."));

    while (TRUE)
    {
        //Make sure there are enough free sectors to hold the whole chain
        //  we're trying to allocate.
        if (_ulFreeSects == MAX_ULONG)
        {
            msfChk(CountFree(&_ulFreeSects));
        }
#if DBG == 1
        else
        {
            CheckFreeCount();
        }
#endif

        while (ulCount > _ulFreeSects)
        {
#if DBG == 1 && !defined(USE_NOSCRATCH)
            ULONG ulFree = _ulFreeSects;
#endif
            msfChk(Resize(_cfsTable +
                          ((ulCount - _ulFreeSects + _fv.GetSectTable() - 1) >>
                           _uFatShift)));
#if DBG == 1 && !defined(USE_NOSCRATCH)
            msfAssert(_ulFreeSects > ulFree &&
                      aMsg("Number of free sectors didn't increase after Resize."));
#endif

        }

        //Starting at the first known free sector, loop until we find
        //  enough sectors to complete the chain.
        FSOFFSET isectStart;
        FSINDEX ipfsStart;

        SectToPair(_sectFirstFree, &ipfsStart, &isectStart);

        for (ipfs = ipfsStart; ipfs < _cfsTable; ipfs++)
        {
            //Only check a page if it is not known to be full.
            pfb = _fv.GetBits(ipfs);

            if ((pfb == NULL) || (!pfb->full))
            {
                //This little contortion is necessary because the
                //  page containing the first sector may not get marked
                //  as dirty by MarkSect.
                if (ipfs == ipfsFirstDirty)
                {
                    msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));
                }
                else
                {
                    msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
                }

                //Eliminate part of the search based on the first-known
                //  free entry for the page
                if (pfb != NULL)
                {
                    isectStart = pfb->firstfree;
                }

                for (isect = isectStart; isect < _fv.GetSectTable(); isect++)
                {
                    SECT sectCurrent = pfs->GetSect(isect);
                    sect = PairToSect(ipfs, isect);

                    //If the sector is marked FREESECT, it still may not
                    //  really be free.  The IsFree function will return
                    //  TRUE if it is OK to allocate.
                    if ((sectCurrent == FREESECT) &&
                        ((sc = IsFree(sect)) == S_OK))
                    {
                        //Mark the sector as free and return it.
                        msfChkTo(Err_Rel, MarkSect(&gf));

                        ulCount--;

                        //Update the contig table with this new information.

                        if (cSegCurrent < CSEG)
                        {
                            if (sect != sectLast + 1)
                            {
                                //Use a new entry in the contig table.
                                cSegCurrent++;
                                if (cSegCurrent < CSEG)
                                {
                                    aseg[cSegCurrent].ulOffset =
                                        aseg[cSegCurrent - 1].ulOffset +
                                        aseg[cSegCurrent - 1].cSect;
                                    aseg[cSegCurrent].sectStart = sect;
                                    aseg[cSegCurrent].cSect = 1;
                                }
                            }
                            else
                            {
                                //Grow the current segment
                                aseg[cSegCurrent].cSect++;
                            }
                        }

                        if (ulCount == 0)
                        {
                            //If we're done, release the current table,
                            //  update _sectMax, and return.

                            if (sect >= _sectMax)
                            {
                                _sectMax = sect + 1;
                            }

                            *pcSegReturned = cSegCurrent;
                            ReleaseGetFreeStruct(&gf);
#if DBG == 1
                            _fv.ResetBits();
                            CheckFreeCount();
#endif

                            return S_OK;
                        }
                        else
                        {
                            //Otherwise update the internal counters and
                            //  keep going.
                            sectLast = sect;
                            ipfsLast = ipfs;
                            isectLast = isect;
                        }
                    }
                    else
                    {
                        msfChkTo(Err_Rel, sc);
                    }

                }

                _fv.ReleaseTable(ipfs);
                //If we are keeping a full bit, we can set it here, since
                //  we know we've allocated everything out of the current
                //  page.
                // the vectbits pointer may have changed due to a resize
                pfb = _fv.GetBits(ipfs);
                if (pfb != NULL)
                {
                    pfb->full = TRUE;
                }
            }
            isectStart = 0;
        }

        //Keep _sectMax up to date for SetSize purposes.
        if (sectLast >= _sectMax)
        {
            _sectMax = sectLast + 1;
        }
    }
    msfAssert(0 &&
              aMsg("GetFree exited improperly."));
    sc = STG_E_ABNORMALAPIEXIT;

Err:
    ReleaseGetFreeStruct(&gf);
    return sc;

Err_Rel:
    ReleaseGetFreeStruct(&gf);
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::Contig, public
//
//  Synposis:   Create contiguous sector table
//
//  Effects:    Return contiguity information about a chain.
//
//  Arguments:  [aseg] -- Segment table to return data in
//              [sect] -- Starting sector for table to begin
//              [ulength] -- Runlength in sectors of table to produce
//              [pcSeg] -- Returns count of segments in table
//
//  Returns:    Appropriate status code.
//
//  Algorithm:  Perform calls to CFat::GetNext().  Any call that is
//              1 higher than the previous represents contiguous blocks.
//              Construct the Segment table on that basis.
//
//  History:    16-Aug-91   PhilipLa    Created.
//              20-May-92   AlexT       Moved to CFat
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE  CFat::Contig(
    SSegment STACKBASED *aseg,
    BOOL fWrite,
    SECT sectStart,
    ULONG ulLengthStart,
    ULONG *pcSeg)
{
    msfDebugOut((DEB_ITRACE,"In CFat::Contig(%lu,%lu)\n",sectStart,ulLengthStart));
    SCODE sc = S_OK;

    ULONG ulLength = ulLengthStart;
    SECT sect = sectStart;
    SECT stemp = sect;
    ULONG ulCount = 1;
    USHORT iseg = 0;
    FSINDEX ipfs = (FSINDEX) -1;
    FSINDEX ipfsOld = ipfs;
    FSOFFSET isect;
    CFatSect *pfs = NULL;

    msfAssert(sect != ENDOFCHAIN &&
              aMsg("Called Contig with ENDOFCHAIN start"));

    msfAssert((ulLength > 0) && aMsg("Bad length passed to Contig()"));
    aseg[iseg].sectStart = sect;
    aseg[iseg].cSect = 1;
    aseg[iseg].ulOffset = 0;
    ulLength--;

    while (TRUE)
    {
        msfAssert(sect != ENDOFCHAIN &&
                  aMsg("Contig found premature ENDOFCHAIN"));

        SectToPair(sect, &ipfs, &isect);

        if (ipfs != ipfsOld)
        {
            if (ipfsOld != (FSINDEX) -1)
            {
                _fv.ReleaseTable(ipfsOld);
            }
            msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
            ipfsOld = ipfs;
        }

        if (pfs != NULL)
            sect = pfs->GetSect(isect);

        if (sect == ENDOFCHAIN)
        {
            if ((ulLength < 1) || !fWrite)
                break;

            //Allocate new sectors.
#if 0
            SECT sectNew;
            msfChk(GetFree(ulLength, &sectNew, GF_WRITE));
            msfChk(SetNext(stemp, sectNew));
            sect = sectNew;
#else
            //GetFreeContig will allocate new sectors and fill up
            //  our contig table.  After this call, the chain will
            //  be the proper length and the contig table will either
            //  contain the entire chain, or will be full.  Either
            //  way we can exit immediately.

            if (ipfs != (FSINDEX) - 1)
            {
                _fv.ReleaseTable(ipfs);
            }

            ULONG isegRet = 0;
            aseg[iseg].cSect = ulCount;
            msfChk(GetFreeContig(ulLength, aseg, iseg, &isegRet));
            if (isegRet == CSEG)
            {
                aseg[isegRet].ulOffset = 0;
                aseg[isegRet].cSect = 0;
                aseg[isegRet].sectStart = FREESECT;
            }
            else
            {
                aseg[isegRet + 1].sectStart = ENDOFCHAIN;
            }
            *pcSeg = isegRet + 1;
#if DBG == 1
            SSegment segtab[CSEG + 1];
            ULONG cSeg;
            Contig(segtab, FALSE, sectStart, ulLengthStart, &cSeg);
            msfAssert(cSeg == *pcSeg);
            for (USHORT i = 0; i < cSeg; i++)
            {
                msfAssert(segtab[i].sectStart == aseg[i].sectStart);
                msfAssert(segtab[i].ulOffset == aseg[i].ulOffset);
                msfAssert(segtab[i].cSect == aseg[i].cSect);
            }
#endif
            return S_OK;
#endif
        }

        if (sect != (stemp + 1))
        {
            if (ulLength < 1)
                break;

            aseg[iseg].cSect = ulCount;
            iseg++;
            aseg[iseg].ulOffset = aseg[iseg - 1].ulOffset + ulCount;
            aseg[iseg].sectStart = sect;
            ulCount = 1;
            stemp = sect;
        }
        else
        {
            ulCount++;
            stemp = sect;
        }
        if (ulLength > 0)
            ulLength--;

        if (iseg >= CSEG)
            break;
    }
    if (ipfs != (FSINDEX) -1)
    {
        _fv.ReleaseTable(ipfs);
    }

    if (iseg < CSEG)
    {
        aseg[iseg].cSect = ulCount;
        aseg[iseg + 1].sectStart = ENDOFCHAIN;
    }
    else
    {
        aseg[iseg].ulOffset = 0;
        aseg[iseg].cSect = 0;
        aseg[iseg].sectStart = FREESECT;
    }

    *pcSeg = iseg + 1;
    msfDebugOut((DEB_ITRACE,"Exiting Contig()\n"));

Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CFat::ReserveSects, public
//
//  Synopsis:	Make sure the fat has at least a given number of free
//              sectors in it.
//
//  Arguments:	[cSect] -- Number of sectors to reserve.
//
//  Returns:	Appropriate status code
//
//  History:	18-Sep-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CFat::ReserveSects(ULONG cSect)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE, "In  CFat::ReserveSects:%p()\n", this));

    //Make sure there are enough free sectors to hold the whole chain
    //  we're trying to allocate.
    if (_ulFreeSects == MAX_ULONG)
    {
        msfChk(CountFree(&_ulFreeSects));
    }
#if DBG == 1
    else
    {
        CheckFreeCount();
    }
#endif

    while (cSect > _ulFreeSects)
    {
#if DBG == 1 && !defined(USE_NOSCRATCH)
        ULONG ulFree = _ulFreeSects;
#endif
        msfChk(Resize(_cfsTable +
                      ((cSect - _ulFreeSects + _fv.GetSectTable() - 1) >>
                       _uFatShift)));
#if DBG == 1 && !defined(USE_NOSCRATCH)
        msfAssert(_ulFreeSects > ulFree &&
                  aMsg("Number of free sectors didn't increase after Resize."));
#endif

    }

    msfDebugOut((DEB_ITRACE, "Out CFat::ReserveSects\n"));
Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetLength, public
//
//  Synposis:   Return the length of a fat chain.
//
//  Arguments:  [sect] -- Sector to begin count at.
//
//  Returns:    Length of the chain, in sectors
//
//  Algorithm:  Traverse the chain until ENDOFCHAIN is reached.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::GetLength(SECT sect, ULONG * pulRet)
{
    msfDebugOut((DEB_FAT,"In CFat::GetLength(%lu)\n",sect));
    SCODE sc = S_OK;
    ULONG csect = 0;
    const ULONG csectMax = PairToSect(_cfsTable+1,0);

    while (sect != ENDOFCHAIN)
    {
        msfChk(GetNext(sect, &sect));
        csect++;
        if (csect > csectMax)            // infinite loop in the chain
            msfErr (Err, STG_E_DOCFILECORRUPT);
    }

    msfDebugOut((DEB_FAT,"FAT: GetLength returned %u\n",csect));
    *pulRet =  csect;
Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::Init, public
//
//  Synposis:   Sets up a FAT, reading data from an existing stream
//
//  Effects:    Changes all _apfsTable entries, _cfsTable, and all
//              flags fields
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Read size from first FAT in stream.
//              Resize array to necessary size.
//              Read in FAT sectors sequentially.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::Init(CMStream *pmsParent,
                           FSINDEX cFatSect,
                           BOOL fConvert)
{
    SCODE sc;

    msfDebugOut((DEB_FAT,"CFat::setup thinks the FAT is size %lu\n",cFatSect));

    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    _uFatShift = pmsParent->GetSectorShift() - 2;
    _uFatMask = (pmsParent->GetSectorSize() >> 2) - 1;
    _fv.InitCommon(1 << _uFatShift, 1 << _uFatShift);

    msfChk(_fv.Init(pmsParent, cFatSect));

    _cfsTable = cFatSect;

    USHORT cbSectorSize;
    cbSectorSize = pmsParent->GetSectorSize();
    InitRangeLocksSector();

    _ulFreeSects = MAX_ULONG;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::InitConvert, public
//
//  Synopsis:   Init function used for conversion
//
//  Arguments:  [sectData] -- number of sectors used by file
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    28-May-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CFat::InitConvert(CMStream *pmsParent,
                                  SECT sectData)
{
    SCODE sc;
    msfDebugOut((DEB_FAT,"Doing conversion\n"));
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    msfAssert((sectData != 0) &&
            aMsg("Attempt to convert zero length file."));

    SECT sectMax = 0;
    FSINDEX csectFat = 0;
    FSINDEX csectLast;

    _uFatShift = pmsParent->GetSectorShift() - 2;
    _uFatMask = (pmsParent->GetSectorSize() >> 2) - 1;
    _fv.InitCommon(1 << _uFatShift, 1 << _uFatShift);
    InitRangeLocksSector ();

    if (_sid == SIDFAT)
    {
        SECT sectTotal;

        //Since the fat needs to represent itself, we can't determine
        //   the actual number of sectors needed in one pass.  We
        //   therefore loop, factoring in the number of fat sectors
        //   at each iteration, until we reach a stable state.
        //
        //As an example, consider the case where each fat sector represents
        //   128 sectors and the file being converted is 128 sectors long.
        //   There will be no DIFat - therefore, we have 128 sectors needed
        //   on the first pass, which will require 1 fat sector to
        //   represent them.  On the second pass, we discover that we
        //   actually need 2 fat sectors, since we now have 129 total
        //   sectors to allocate space for.  The third pass will result
        //   in a stable state.
        do
        {
            csectLast = csectFat;
            sectTotal = sectData + pmsParent->GetHeader()->GetDifLength() +
                csectFat + 1;
            csectFat = (sectTotal + _fv.GetSectTable() - 1) >> _uFatShift;
        }
        while (csectLast != csectFat);
        sectMax = sectData + pmsParent->GetHeader()->GetDifLength();
    }
    else
    {
        //The minifat doesn't need to represent itself, so we can
        //  compute the number of sectors needed in one pass.
        sectMax = sectData;
        csectFat = (sectMax + _fv.GetSectTable() -1) >> _uFatShift;
    }

    msfChk(_fv.Init(pmsParent, csectFat));

    FSINDEX i;

    if (_sid == SIDMINIFAT)
    {
        SECT sectFirst;
        msfChk(pmsParent->GetFat()->Allocate(csectFat, &sectFirst));

        pmsParent->GetHeader()->SetMiniFatStart(sectFirst);

        pmsParent->GetHeader()->SetMiniFatLength(csectFat);
    }


    for (i = 0; i < csectFat; i++)
    {
        CFatSect *pfs;

        msfChk(_fv.GetTable(i, FB_NEW, &pfs));
        if (_sid == SIDFAT)
        {
            _fv.SetSect(i, sectMax + i);
            pmsParent->GetDIFat()->SetFatSect(i, sectMax + i);
        }
        else
        {
            msfAssert(_pfatNoScratch == NULL);
            SECT sect;
            msfChk(pmsParent->GetESect(_sid, i, &sect));
            _fv.SetSect(i, sect);
        }

        _fv.ReleaseTable(i);
    }


    _cfsTable = csectFat;

    if (_sid != SIDMINIFAT)
    {

        pmsParent->GetHeader()->SetFatLength(_cfsTable);

        SECT sect;

        if (sectData > 1)
        {
            for (sect = 0; sect < sectData - 2; sect++)
            {
                msfChk(SetNext(sect, sect + 1));
            }

            msfChk(SetNext(sectData - 2, ENDOFCHAIN));
            msfChk(SetNext(sectData - 1, 0));
        }
        else
        {
            //In the event that the file to be converted is less
            //  than one sector long, we don't need to create a
            //  real chain, just a single terminated sector.
            msfChk(SetNext(0, ENDOFCHAIN));
        }


        for (sect = sectData; sect < sectMax; sect++)
        {
            msfChk(SetNext(sect, DIFSECT));
        }

        for (USHORT i2 = 0; i2 < csectFat; i2++)
        {
            msfChk(SetNext(sectMax + i2, FATSECT));
        }

        //Set up directory chain.
        msfChk(SetNext(sectMax + i, ENDOFCHAIN));

        pmsParent->GetHeader()->SetDirStart(sectMax + i);

        _ulFreeSects = (_cfsTable << _uFatShift) - (sectMax + csectFat + 1);
    }
    else
    {
        for (SECT sect = 0; sect < sectData -1; sect++)
        {
            msfChk(SetNext(sect, sect + 1));
        }
        msfChk(SetNext(sectData - 1, ENDOFCHAIN));
        _ulFreeSects = (_cfsTable << _uFatShift) - sectData;
    }

    if (!pmsParent->IsScratch())
    {
        msfChk(pmsParent->SetSize());
    }

Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFat::InitNew, public
//
//  Synposis:   Sets up a FAT for a newly created multi-strean
//
//  Effects:    Changes all _apfsTable entries, _cfsTable, and all
//              flags fields
//
//  Arguments:  [pmsparent] -- pointer to parent Mstream
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Set parent pointer.
//              Allocate 1 sector for FAT and 1 for Directory.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              17-Aug-91   PhilipLa    Added dirty bits optimization (Dump)
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::InitNew(CMStream *pmsParent)
{
    msfDebugOut((DEB_FAT,"In CFat::InitNew()\n"));
    SCODE sc;

    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);
    _uFatShift = pmsParent->GetSectorShift() - 2;
    _uFatMask = (pmsParent->GetSectorSize() >> 2) - 1;
    _fv.InitCommon(1 << _uFatShift, 1 << _uFatShift);

    FSINDEX count;
    if (SIDMINIFAT == _sid)
        count = pmsParent->GetHeader()->GetMiniFatLength();
    else
        count = pmsParent->GetHeader()->GetFatLength();

    msfDebugOut((DEB_FAT,"Setting up Fat of size %lu\n",count));

    msfChk(_fv.Init(pmsParent, count));

    _cfsTable = count;

    InitRangeLocksSector();
    if (SIDFAT == _sid)
    {
        FSINDEX ipfs;
        FSOFFSET isect;
        CFatSect *pfs;

        SectToPair(pmsParent->GetHeader()->GetFatStart(), &ipfs, &isect);
        msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));
        _fv.SetSect(ipfs, pmsParent->GetHeader()->GetFatStart());
        _fv.ReleaseTable(ipfs);

        msfChk(SetNext(pmsParent->GetHeader()->GetFatStart(), FATSECT));
        msfDebugOut((DEB_ITRACE,"Set sector %lu (FAT) to ENDOFCHAIN\n",pmsParent->GetHeader()->GetFatStart()));

        msfChk(SetNext(pmsParent->GetHeader()->GetDirStart(), ENDOFCHAIN));
        msfDebugOut((DEB_ITRACE,"Set sector %lu (DIR) to ENDOFCHAIN\n",pmsParent->GetHeader()->GetDirStart()));
        _ulFreeSects = (count << _uFatShift) - 2;
    }
    else
    {
        _ulFreeSects = 0;
    }

    if (!pmsParent->IsScratch())
    {
        msfChk(pmsParent->SetSize());
    }

    msfDebugOut((DEB_FAT,"Exiting CFat::setupnew()\n"));

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::Resize, private
//
//  Synposis:   Resize FAT, both in memory and in the file
//
//  Effects:    Modifies _cfsTable, _apfsTable, and all flags fields
//
//  Arguments:  [ulSize] -- New size (in # of tables) for FAT
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Allocate new array of new size.
//              Copy over all old pointers.
//              Allocate new tables for any necessary.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              18-Aug-91   PhilipLa    Added dirty bits optimization
//
//  Notes:      This routine currently cannot reduce the size of a fat.
//
//---------------------------------------------------------------------------


SCODE CFat::Resize(ULONG ulSize)
{
    msfDebugOut((DEB_FAT,"In CFat::Resize(%lu)\n",ulSize));
    SCODE sc = S_OK;

    if (ulSize == _cfsTable)
    {
        return S_OK;
    }

    ULONG csect = _cfsTable;

    msfAssert(ulSize > _cfsTable &&
            aMsg("Attempted to shrink Fat"));

    // 512byte sector docfiles are restricted to 2G for now
    if (_pmsParent->GetSectorShift() == SECTORSHIFT512 &&
        ulSize > _ipfsRangeLocks)
        return STG_E_DOCFILETOOLARGE;

    ULONG ipfs;
    SECT sectNew = 0;

    CFat *pfat = _pmsParent->GetFat();


    if ((!_pmsParent->IsScratch()) && (_sid == SIDFAT))
    {

        //Make sure we have enough space for all of the sectors
        //  to be allocated.

        ULONG csectFat = ulSize - _cfsTable;
        ULONG csectPerDif = (1 << _uFatShift) - 1;
        ULONG csectDif = (csectFat + csectPerDif - 1) / csectPerDif;


        //Assuming all the free sectors are at the end of the file,
        //   we need a file csectNew sectors long to hold them.

        ULONG csectOld, csectNew;

        msfChk(FindMaxSect(&csectOld));

        // Every new sector added can conceivably cause a remap of
        //   another sector while in COW mode.
        csectNew = csectOld +
            ((csectFat + csectDif) * ((_sectLastUsed > 0) ? 2 : 1));

        ULARGE_INTEGER cbSize;

#ifdef LARGE_DOCFILE
        cbSize.QuadPart = ConvertSectOffset(
                csectNew,
                0,
                _pmsParent->GetSectorShift());
#else
        ULISet32(cbSize, ConvertSectOffset(
                csectNew,
                0,
                _pmsParent->GetSectorShift()));
#endif

#ifdef LARGE_DOCFILE
        if (cbSize.QuadPart > _pmsParent->GetParentSize())
#else
        if (ULIGetLow(cbSize) > _pmsParent->GetParentSize())
#endif
        {
            msfHChk(_pmsParent->GetILB()->SetSize(cbSize));
        }

        //If we are the fat, we have enough space in the file for
        //  ourselves at this point.
    }
    else if (_sid != SIDFAT)
    {
        if (_cfsTable == 0)
        {
            msfChk(pfat->Allocate(ulSize, &sectNew));
            _pmsParent->GetHeader()->SetMiniFatStart(sectNew);
        }
        else
        {
            sectNew = _pmsParent->GetHeader()->GetMiniFatStart();

            SECT sectLast;
            msfChk(pfat->GetESect(sectNew, ulSize - 1, &sectLast));

        }

        if (!_pmsParent->IsScratch())
        {
            msfChk(_pmsParent->SetSize());
        }


        msfChk(pfat->GetSect(sectNew, csect, &sectNew));

        //If we are the Minifat, we have enough space in the underlying
        //  file for ourselves at this point.
    }


    _fv.Resize(ulSize);


    for (ipfs = csect; ipfs < ulSize; ipfs++)
    {
        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));
        _cfsTable = ipfs + 1;


        if (_sid == SIDFAT)
        {
            if (ipfs == _ipfsRangeLocks)
            {
                CVectBits *pfb;
                pfs->SetSect(_isectRangeLocks, ENDOFCHAIN);

                pfb = _fv.GetBits(_ipfsRangeLocks);
                if (pfb != NULL && pfb->full == FALSE &&
                    _isectRangeLocks == pfb->firstfree)
                {
                    pfb->firstfree = _isectRangeLocks + 1;
                }

                _ulFreeSects--;
            }

            if (_sectNoSnapshotFree != ENDOFCHAIN)
            {
                SECT sectStart, sectEnd;

                _pmsParent->GetHeader()->SetFatLength(_cfsTable);

                msfChk(GetFree(1, &sectNew, GF_READONLY));
                _pmsParent->GetDIFat()->CacheUnmarkedSect(sectNew,
                                                          FATSECT,
                                                          ENDOFCHAIN);
                msfChk(_pmsParent->GetDIFat()->SetFatSect(ipfs, sectNew));

                msfAssert((_ulFreeSects != MAX_ULONG) &&
                          aMsg("Free count not set in no-snapshot"));

                //We don't need to look at anything less than
                //_sectNoSnapshotFree, since those are all by definition
                //not free.
                sectStart = max(PairToSect(ipfs, 0), _sectNoSnapshotFree);
                sectEnd = PairToSect(ipfs, 0) + _fv.GetSectTable();

                for (SECT sectChk = sectStart;
                     sectChk < sectEnd;
                     sectChk++)
                {
                    if (IsFree(sectChk) == S_OK)
                    {
                        _ulFreeSects++;
                    }
                }
                CheckFreeCount();
            }
            else
            {
                if (_pfatNoScratch != NULL)
                {
                    SECT sectStart, sectEnd;

                    msfChk(GetFree(1, &sectNew, GF_READONLY));
                    _pmsParent->GetDIFat()->CacheUnmarkedSect(sectNew,
                                                              FATSECT,
                                                              ENDOFCHAIN);
                    if (_ulFreeSects != MAX_ULONG)
                    {
                        sectStart = PairToSect(ipfs, 0);
                        sectEnd = sectStart + _fv.GetSectTable();

                        for (SECT sectChk = sectStart;
                             sectChk < sectEnd;
                             sectChk++)
                        {
                            if (IsFree(sectChk) == S_OK)
                            {
                                _ulFreeSects++;
                            }
                        }
                        CheckFreeCount();
                    }
                }
                else
                {
                    _ulFreeSects += (1 << _uFatShift);
                    msfChk(pfat->GetFree(1, &sectNew, GF_WRITE));
                    msfChk(pfat->SetNext(sectNew, FATSECT));
                }
                msfChk(_pmsParent->GetDIFat()->SetFatSect(ipfs, sectNew));
            }
        }

        msfAssert(sectNew != ENDOFCHAIN &&
                  aMsg("Bad sector returned for fatsect."));

        _fv.SetSect(ipfs, sectNew);
        _fv.ReleaseTable(ipfs);

        if (_sid == SIDMINIFAT)
        {
            _ulFreeSects += (1 << _uFatShift);
            msfChk(pfat->GetNext(sectNew, &sectNew));
        }
    }

    CheckFreeCount();

    msfDebugOut((DEB_FAT,"CFat::Resize() - all new objects allocated\n"));

    if (SIDMINIFAT == _sid)
    {
        _pmsParent->GetHeader()->SetMiniFatLength(_cfsTable);
    }
    else
        _pmsParent->GetHeader()->SetFatLength(_cfsTable);

    //This setsize should only shrink the file.
#if DBG == 1
    STATSTG stat;

    msfHChk(_pmsParent->GetILB()->Stat(&stat, STATFLAG_NONAME));
#endif

    if (!_pmsParent->IsScratch())
    {
        msfChk(_pmsParent->SetSize());
    }

    if ((_pfatNoScratch != NULL) && (_ulFreeSects == MAX_ULONG))
    {
        msfChk(CountFree(&_ulFreeSects));
    }

#if DBG == 1
    STATSTG statNew;

    msfHChk(_pmsParent->GetILB()->Stat(&statNew, STATFLAG_NONAME));

#ifdef LARGE_DOCFILE
    if (ulSize < _ipfsRangeLocks && !(_pmsParent->IsInCOW()))
        msfAssert(statNew.cbSize.QuadPart <= stat.cbSize.QuadPart);
#else
    if (!(_pmsParent->IsInCOW())
        msfAssert(ULIGetLow(statNew.cbSize) <= ULIGetLow(stat.cbSize));
#endif
#endif

    msfDebugOut((DEB_FAT,"Out CFat::Resize(%lu)\n",ulSize));

Err:
    msfAssert((_ulFreeSects != MAX_ULONG) &&
              aMsg("Free sect count not set after Resize()."));
    return sc;
}






//+-------------------------------------------------------------------------
//
//  Member:     CFat::Extend, private
//
//  Synposis:   Increase the size of an existing chain
//
//  Effects:    Modifies ulSize sectors within the fat.  Causes one or
//              more sector writes.
//
//  Arguments:  [sect] -- Sector ID of last sector in chain to be extended
//              [ulSize] -- Number of sectors to add to chain
//
//  Requires:   sect must be at the end of a chain.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Use calls to GetFree to allocate chain.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              17-Aug-91   PhilipLa    Added dirty bits opt (Dump)
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::Extend(SECT sect, ULONG ulSize)
{
    SCODE sc;

    msfDebugOut((DEB_FAT,"In CFat::Extend(%lu,%lu)\n",sect,ulSize));
    SECT sectTemp;

    msfChk(GetFree(ulSize, &sectTemp, GF_WRITE));

    //If this SetSize fails, clean up the new space and don't do anything
    //  to the original chain.
    if (!_pmsParent->IsScratch())
    {
        msfChkTo(EH_OOD, _pmsParent->SetSize());
    }

    //If this SetNext fail calls, we're in trouble.  Return the error but
    //  don't attempt to cleanup.
    msfChk(SetNext(sect, sectTemp));

    msfDebugOut((DEB_FAT,"Out CFat::Extend()\n"));

Err:
    return sc;
EH_OOD:
    SetChainLength(sectTemp, 0);
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetNext, public
//
//  Synposis:   Returns the next sector in a chain, given a sector
//
//  Arguments:  [sect] -- Sector ID of any sector in a chain.
//
//  Returns:    Sector ID of next sector in chain, ENDOFCHAIN if at end
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::GetNext(const SECT sect, SECT * psRet)
{
    SCODE sc;

    FSINDEX ipfs;
    FSOFFSET isect;

    msfAssert(sect <= MAXREGSECT &&
            aMsg("Called GetNext() on invalid sector"));

    SectToPair(sect, &ipfs, &isect);
    CFatSect *pfs;
    msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

    *psRet = pfs->GetSect(isect);

    _fv.ReleaseTable(ipfs);

    if (sect == *psRet)
    {
        msfAssert(sect != *psRet &&
                  aMsg("Detected loop in fat chain."));
        return STG_E_ABNORMALAPIEXIT;
    }
    return S_OK;

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::SetNext, private
//
//  Synposis:   Set the next sector in a chain
//
//  Effects:    Modifies a single entry within the fat.
//
//  Arguments:  [sectFirst] -- Sector ID of first sector
//              [sectNext] -- Sector ID of next sector
//
//  Returns:    void
//
//  History:    18-Jul-91   PhilipLa    Created.
//              17-Aug-91   PhilipLa    Added dirty bits optimization
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::SetNext(SECT sectFirst, SECT sectNext)
{
    FSINDEX ipfs;
    FSOFFSET isect;
    SCODE sc;

    msfAssert((!_pmsParent->IsShadow()) &&
            aMsg("Modifying shadow fat."));

    //  creating infinite loops is a no-no
    msfAssert(sectFirst != sectNext &&
            aMsg("Attempted to create loop in Fat chain"));
    msfAssert(sectFirst <= MAXREGSECT &&
            aMsg("Called SetNext on invalid sector"));

    SectToPair(sectFirst, &ipfs, &isect);

    CFatSect *pfs;
    SECT sectCurrent;

    if (ipfs >= _cfsTable)
    {
        msfChk(Resize(ipfs + 1));
    }

    msfAssert(ipfs <= _cfsTable);

    msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));

    sectCurrent = pfs->GetSect(isect);

    pfs->SetSect(isect,sectNext);

    _fv.ReleaseTable(ipfs);

    if (sectNext == FREESECT)
    {
        CVectBits *pfb;
        pfb = _fv.GetBits(ipfs);

        if ((pfb != NULL) &&
            ((pfb->full == TRUE) || (isect < pfb->firstfree)))
        {
            pfb->full = FALSE;
            pfb->firstfree = isect;
        }

        if (sectFirst == _sectMax - 1)
        {
            _sectMax = ENDOFCHAIN;
        }
        if (sectFirst < _sectFirstFree)
        {
            _sectFirstFree = sectFirst;
        }

        if (_ulFreeSects != MAX_ULONG)
        {
            SECT sectOld = FREESECT;

            msfChk(IsFree(sectFirst));

            if (sc != S_FALSE)
            {
                _ulFreeSects++;
            }
            sc = S_OK;  // Don't return S_FALSE.
        }
    }
    else if (_pfatNoScratch != NULL)
    {
        //We need to update the noscratch fat as well.
        msfChk(_pfatNoScratch->SetNext(sectFirst, sectNext));
    }
    else if (sectFirst >= _sectMax)
    {
        _sectMax = sectFirst + 1;
#if DBG == 1
        SECT sectLast;
        msfChk(FindLast(&sectLast));
        msfAssert(((_sectMax == sectLast) || (_sectMax == _sectLastUsed)) &&
                aMsg("_sectMax doesn't match actual last sector"));
#endif
    }

    //If we're the no-scratch fat, then we may be marking a free sector
    //as allocated due to the real fat allocating it.  In this case, we
    //need to update our free sector count.
    if ((_sid == SIDMINIFAT) && (_pmsParent->IsScratch()) &&
        (sectCurrent == FREESECT) && (sectNext != FREESECT) &&
        (_ulFreeSects != MAX_ULONG))
    {
        _ulFreeSects--;
    }

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::CountFree, private
//
//  Synposis:   Count and return the number of free sectors in the Fat
//
//  Arguments:  void.
//
//  Returns:    void.
//
//  Algorithm:  Do a linear search of the Fat, counting free sectors.
//              If a FatSect has its full bit set, it is not necessary
//              to search that FatSect.
//
//  History:    11-Sep-91   PhilipLa    Created.
//
//  Notes:  This includes all the FREESECT's in the tail of the last FAT
//          block (past the last allocated sector) as free.  So it is possible
//          That CountFree() could be greater than FindLast()!
//---------------------------------------------------------------------------


SCODE CFat::CountFree(ULONG * pulRet)
{
    msfDebugOut((DEB_FAT,"In CFat::CountFree()\n"));
    SCODE sc = S_OK;

    FSINDEX ipfs;
    ULONG csectFree=0;
    FSOFFSET isectStart;
    FSINDEX ipfsStart;

    SectToPair(_sectFirstFree, &ipfsStart, &isectStart);

    for (ipfs = ipfsStart; ipfs < _cfsTable; ipfs++)
    {
        CVectBits *pfb = _fv.GetBits(ipfs);

        if ((pfb == NULL) || (!pfb->full))
        {
            msfDebugOut((DEB_FAT,"Checking table %lu\n",ipfs));
            CFatSect *pfs;
            msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

            if (pfb != NULL)
            {
                isectStart = pfb->firstfree;
            }

            FSOFFSET isect;
            for (isect = isectStart; isect < _fv.GetSectTable(); isect++)
            {
                SECT sectCurrent = pfs->GetSect(isect);
                SECT sectNew = PairToSect(ipfs, isect);

                if (sectCurrent == FREESECT)
                {
                    msfChkTo(Err_Rel, IsFree(sectNew));

                    if (sc == S_FALSE)
                    {
                        sectCurrent = ENDOFCHAIN;
                    }
                }


                if (sectCurrent == FREESECT)
                {
                    csectFree++;
                }
            }
            _fv.ReleaseTable(ipfs);
        }
        isectStart = 0;
    }
    msfDebugOut((DEB_FAT,"Countfree returned %lu\n",csectFree));
    *pulRet = csectFree;

Err:
    return sc;

Err_Rel:
    _fv.ReleaseTable(ipfs);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::CountSectType, private
//
//  Synposis:   Count and return the number of sectors of a given
//              type in the Fat
//
//  Arguments:  [out]   count       The returned count of sectors.
//              [in]    sectStart   The first sector of the range to examine.
//              [in]    sectEnd     The last sector of the range to examine.
//              [in]    sectType    The type of sector looked for.
//
//  Returns:    SCODE.
//
//  Algorithm:  Do a linear search of the Fat, counting sectors of the given
//              type in the given range.
//
//  History:    18-Feb-97   BChapman    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::CountSectType(
        ULONG * pulRet,
        SECT sectStart,
        SECT sectEnd,
        SECT sectType)
{
    msfDebugOut((DEB_FAT,"In CFat::CountSect(0x%x, 0x%x, 0x%x)\n",
                                        sectStart, sectEnd, sectType));
    SCODE sc = S_OK;

    FSINDEX ipfs;
    ULONG csectType=0;
    FSOFFSET isectStart;        // starting index into the current FAT
    FSOFFSET isectEnd;          // ending   index into the current FAT
    FSOFFSET isectFirstStart;   // starting index into the first FAT
    FSOFFSET isectLastEnd;      // ending   index into the last FAT
    FSINDEX ipfsStart;          // Starting FAT block number
    FSINDEX ipfsEnd;            // Ending FAT block number

    SectToPair(sectStart, &ipfsStart, &isectFirstStart);
    SectToPair(sectEnd, &ipfsEnd, &isectLastEnd);

    for (ipfs = ipfsStart; ipfs <= ipfsEnd; ipfs++)
    {
        //
        // If we are counting FREESECTS and this FAT blocks is
        // known to be full then just skip it.
        //
        if(FREESECT == sectType)
        {
            CVectBits *pfb = _fv.GetBits(ipfs);

            if ((pfb != NULL) && pfb->full)
                continue;
        }

        msfDebugOut((DEB_FAT,"Checking table %lu\n",ipfs));
        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

        //
        // If this is the first FAT block in the given range use the given
        // starting offset-index.  Otherwise start at the beginning.
        //
        if(ipfs == ipfsStart)
            isectStart = isectFirstStart;
        else
            isectStart = 0;

        //
        // If this is the last FAT block in the given range use the given
        // ending fooset-index, otherwise scan to the end of the block.
        //
        if(ipfs == ipfsEnd)
            isectEnd = isectLastEnd;
        else
            isectEnd = _fv.GetSectTable();

        FSOFFSET isect;
        for (isect = isectStart; isect < isectEnd; isect++)
        {
            SECT sectCurrent = pfs->GetSect(isect);
            SECT sectNew = PairToSect(ipfs, isect);

            if (sectCurrent == sectType)
            {
                msfChkTo(Err_Rel, IsSectType(sectNew, sectType));
                if (sc != S_FALSE)
                {
                    csectType++;
                }
            }
        }
        _fv.ReleaseTable(ipfs);
        isectStart = 0;
    }
    msfDebugOut((DEB_FAT,"CountSectType returned %lu\n",csectType));
    *pulRet = csectType;

Err:
    return sc;

Err_Rel:
    _fv.ReleaseTable(ipfs);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetSect, public
//
//  Synposis:   Return the nth sector in a chain
//
//  Arguments:  [sect] -- Sector ID of beginning of chain
//              [uNum] -- indicator of which sector is to be returned
//              [psectReturn] -- Pointer to storage for return value
//
//  Returns:    S_OK.
//
//  Algorithm:  Linearly traverse chain until numth sector
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::GetSect(SECT sect, ULONG ulNum, SECT * psectReturn)
{
    msfDebugOut((DEB_FAT,"In CFat::GetSect(%lu,%lu)\n",sect,ulNum));

    SCODE sc = S_OK;

    if (ulNum == 0)
    {
        msfDebugOut((DEB_FAT,"Out CFat::GetSect()=>%lu\n",sect));
    }
    else if ((SIDFAT == _sid) &&
             (_pmsParent->GetHeader()->GetFatStart() == sect))
    {
        msfChk(_pmsParent->GetDIFat()->GetFatSect(ulNum, &sect));
    }
    else for (ULONG i = 0; i < ulNum; i++)
    {
        msfChk(GetNext(sect, &sect));
        if (sect > MAXREGSECT)
        {
            //The stream isn't long enough, so stop.
            msfAssert(sect == ENDOFCHAIN &&
                    aMsg("Found invalid sector in fat chain."));
            break;
        }
    }

    *psectReturn = sect;
    msfDebugOut((DEB_FAT,"Out CFat::GetSect()=>%lu\n",sect));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetESect
//
//  Synposis:   Return the nth sector in a chain, extending the chain
//              if necessary.
//
//  Effects:    Modifies fat (via Extend) if necessary
//
//  Arguments:  [sect] -- Sector ID of beginning of chain
//              [ulNum] -- Indicates which sector is to be returned
//              [psectReturn] -- Pointer to storage for return value
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Linearly search chain until numth sector is found.  If
//              the chain terminates early, extend it as necessary.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::GetESect(SECT sect, ULONG ulNum, SECT *psectReturn)
{
    msfDebugOut((DEB_FAT,"In CFat::GetESect(%lu,%lu)\n",sect,ulNum));

    SCODE sc = S_OK;

    ULONG i = 0;
    while (i < ulNum)
    {
        SECT temp;
        msfChk(GetNext(sect, &temp));

        msfAssert(temp != FREESECT &&
                aMsg("FREESECT found in chain."));

        if (temp == ENDOFCHAIN)
        {

            //The stream isn't long enough, so extend it somehow.
            ULONG need = ulNum - i;

            msfAssert((SIDMINIFAT == _sid ||
                    sect != _pmsParent->GetHeader()->GetFatStart()) &&
                    aMsg("Called GetESect on Fat chain"));
            msfChk(Extend(sect,need));
        }
        else
        {
            sect = temp;
            i++;
        }
    }

    msfDebugOut((DEB_FAT,"Exiting GetESect with result %lu\n",sect));
    *psectReturn = sect;

Err:
    return sc;
}



#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Member:     CFat::checksanity, private
//
//  Synposis:   Print out a FAT chain.  Used for debugging only.
//
//  Arguments:  [sectStart] -- sector to begin run at.
//
//  Returns:    void
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::checksanity(SECT sectStart)
{
    msfDebugOut((DEB_FAT,"Sanity Check (%i)\n\t",sectStart));
    SCODE sc = S_OK;

    while (sectStart != ENDOFCHAIN)
    {
        msfDebugOut((DEB_FAT | DEB_NOCOMPNAME,"%lu, ",sectStart));
        msfChk(GetNext(sectStart, &sectStart));
    }
    msfDebugOut((DEB_FAT | DEB_NOCOMPNAME,"ENDOFCHAIN\n"));
Err:
    return sc;
}

#endif

//+-------------------------------------------------------------------------
//
//  Member:     CFat::SetChainLength, private
//
//  Synposis:   Set the length of a fat chain.  This is used to reduce
//              the length of the chain only.  To extend a chain, use
//              Extend or GetESect
//
//  Effects:    Modifies the fat
//
//  Arguments:  [sectStart] -- Sector to begin at (head of chain)
//              [uLength] -- New length for chain
//
//  Returns:    void.
//
//  Algorithm:  Traverse chain until uLength is reached or the chain
//              terminates.  If it terminates prematurely, return with
//              no other action.  Otherwise, deallocate all remaining
//              sectors in the chain.
//
//  History:    14-Aug-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::SetChainLength(SECT sectStart, ULONG ulLength)
{
    msfDebugOut((DEB_FAT,"In CFat::SetChainLength(%lu,%lu)\n",sectStart,ulLength));
    SCODE sc;

    if (sectStart == ENDOFCHAIN) return S_OK;

    for (ULONG ui = 1; ui < ulLength; ui++)
    {
        msfChk(GetNext(sectStart, &sectStart));
        if (sectStart == ENDOFCHAIN) return S_OK;
    }

    msfAssert(sectStart != ENDOFCHAIN &&
            aMsg("Called SetChainLength is ENDOFCHAIN start"));

    SECT sectEnd;
    sectEnd = sectStart;

    msfChk(GetNext(sectStart, &sectStart));

    if (ulLength != 0)
    {
        msfChk(SetNext(sectEnd, ENDOFCHAIN));
    }
    else
    {
        msfChk(SetNext(sectEnd, FREESECT));
    }

    while (sectStart != ENDOFCHAIN)
    {
        SECT sectTemp;
        msfChk(GetNext(sectStart, &sectTemp));
        msfChk(SetNext(sectStart, FREESECT));
        sectStart = sectTemp;
    }

    msfDebugOut((DEB_FAT,"Out CFat::SetChainLength()\n"));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFat::DirtyAll, public
//
//  Synopsis:   Dirty every sector in the FAT.  This had the effect in
//              consolidation of copying the whole FAT down lower in the
//              file.
//
//  Returns:    SCODE success or failure code.
//
//  Algorithm:  Load each FAT sector into the cache "for-writing".
//
//  History:    24-Feb-1997   BChapman    Created.
//
//  Notes:      For use
//
//--------------------------------------------------------------------------


SCODE CFat::DirtyAll()
{
    SCODE sc = S_OK;
    CFatSect *pfs;
    FSINDEX i;

    for(i=0; i<_cfsTable; i++)
    {
        msfChk(_fv.GetTable(i, FB_DIRTY, &pfs));
        _fv.ReleaseTable(i);
    }
Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFat::FindLast, private
//
//  Synopsis:   Find last used sector in a fat
//
//  Returns:    Location of last used sector
//
//  Algorithm:  Perform a backward linear search until a non-free
//              sector is found.
//
//  History:    18-Dec-91   PhilipLa    Created.
//
//  Notes:      Used for shadow fats only.
//
//--------------------------------------------------------------------------


SCODE CFat::FindLast(SECT * psectRet)
{
    SCODE sc = S_OK;
    FSINDEX ipfs = _cfsTable;
    SECT sect = 0;

    while (ipfs > 0)
    {
        ipfs--;

        FSOFFSET isect = _fv.GetSectTable();

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

        while (isect > 0)
        {
            isect--;

            SECT sectCurrent = pfs->GetSect(isect);
            SECT sectNew = PairToSect(ipfs, isect);
            if (sectCurrent == FREESECT)
            {
                msfChkTo(Err_Rel, IsFree(sectNew));
                if (sc == S_FALSE)
                    sectCurrent = ENDOFCHAIN;
            }

            if (ipfs == _ipfsRangeLocks && isect == _isectRangeLocks)
                sectCurrent = FREESECT;

            if (sectCurrent != FREESECT)
            {
                msfDebugOut((DEB_FAT,"FindLast returns %lu\n",PairToSect(ipfs,isect)));
                sect = sectNew + 1;
                break;
            }
        }

        _fv.ReleaseTable(ipfs);
        if (sect != 0)
            break;
    }

    //We need additional checks here since in some cases there aren't
    //enough pages in the fat to hold _sectNoSnapshot (or _sectNoSnapshotFree).
    //Returning too small a value could result in SetSizing the file to too
    //small a size, which is data loss.
    if (sect < _sectNoSnapshot)
    {
        sect = _sectNoSnapshot;
    }
    if ((_sectNoSnapshotFree != ENDOFCHAIN) && (sect < _sectNoSnapshotFree))
    {
        sect = _sectNoSnapshotFree;
    }

    *psectRet = sect;
Err:
    return sc;
Err_Rel:
    _fv.ReleaseTable(ipfs);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::Remap, public
//
//  Synopsis:   Remap a portion of a chain for copy-on-write
//
//  Effects:
//
//  Arguments:  [sectStart] -- Sector marking the first sector in the chain
//              [oStart] -- Offset in sectors at which to begin the remap
//              [ulRunLength] -- Number of sectors to remap
//              [psectOldStart] -- Returns old location of first remapped
//                                      sector.
//              [psectNewStart] -- Returns new location of first sector
//              [psectOldEnd] -- Returns old location of last sector
//              [psectNewEnd] -- Returns new location of last sector
//
//  Returns:    Appropriate status code.
//              S_FALSE if everything succeeded but no sectors were
//                  remapped.
//
//  History:    18-Feb-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


SCODE CFat::Remap(
        SECT sectStart,
        ULONG oStart,
        ULONG ulRunLength,
        SECT *psectOldStart,
        SECT *psectNewStart,
        SECT *psectOldEnd,
        SECT *psectNewEnd)
{
    msfDebugOut((DEB_FAT,"In CFat::Remap(%lu, %lu, %lu)\n",sectStart,oStart,ulRunLength));

    msfAssert(SIDMINIFAT != _sid &&
            aMsg("Called Remap on Minifat"));
    msfAssert(ulRunLength != 0 &&
            aMsg("Called Remap with 0 runlength"));
    msfAssert(!_pmsParent->IsScratch() &&
            aMsg("Called Remap on scratch."));

    BOOL fRemapped = FALSE;
    SCODE sc = S_OK;
    SECT sectPrev = ENDOFCHAIN;
    SECT sect;
    ULONG uCount = 0;


    *psectNewStart = ENDOFCHAIN;
    *psectNewEnd = ENDOFCHAIN;
#if DBG == 1
    *psectOldStart = ENDOFCHAIN;
    *psectOldEnd = ENDOFCHAIN;
#endif

    if (oStart == 0)
    {
        sectPrev = ENDOFCHAIN;
        sect = sectStart;
    }
    else
    {
        msfChk(GetESect(sectStart, oStart - 1, &sectPrev));
        msfChk(GetNext(sectPrev, &sect));
    }

    *psectOldStart = sect;

    while ((uCount < ulRunLength) && (sect != ENDOFCHAIN))
    {
        if (uCount == ulRunLength - 1)
        {
            *psectOldEnd = sect;
        }

        msfChk(QueryRemapped(sect));
        if (sc == S_FALSE)
        {
            SECT sectNew;

            msfChk(GetFree(1, &sectNew, GF_WRITE));

            msfDebugOut((DEB_ITRACE,"Remapping sector %lu to %lu\n",sect,sectNew));
            if (sectPrev != ENDOFCHAIN)
            {
                msfChk(SetNext(sectPrev, sectNew));

                if (_pfatNoScratch != NULL)
                {
                    msfChk(_pfatNoScratch->SetNext(sectPrev, sectNew));
                }
            }

            msfAssert((sect != ENDOFCHAIN) &&
                    aMsg("Remap precondition failed."));

            SECT sectTemp;
            msfChk(GetNext(sect, &sectTemp));
            msfChk(SetNext(sectNew, sectTemp));

            if (_pfatNoScratch != NULL)
            {
                msfChk(_pfatNoScratch->SetNext(sectNew, sectTemp));
            }

            msfChk(SetNext(sect, FREESECT));


            fRemapped = TRUE;

            if (uCount == 0)
            {
                *psectNewStart = sectNew;
            }

            if (uCount == ulRunLength - 1)
            {
                *psectNewEnd = sectNew;
            }

            sect = sectNew;
        }
        sectPrev = sect;
        msfChk(GetNext(sect, &sect));
        uCount++;
    }

    if ((*psectNewStart != ENDOFCHAIN) && (oStart == 0))
    {
        if (sectStart == _pmsParent->GetHeader()->GetDirStart())
            _pmsParent->GetHeader()->SetDirStart(*psectNewStart);

        if (sectStart == _pmsParent->GetHeader()->GetMiniFatStart())
            _pmsParent->GetHeader()->SetMiniFatStart(*psectNewStart);
    }

    msfDebugOut((DEB_FAT,"Out CFat::Remap()=>%lu\n",*psectNewStart));

Err:
    if ((sc == S_OK) && !fRemapped)
        sc = S_FALSE;
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFat::FindMaxSect, private
//
//  Synopsis:   Return last used sector in current Fat.
//
//  Arguments:  None.
//
//  Returns:    Last used sector in current Fat
//
//  History:    15-Dec-91   PhilipLa    Created.
//
//--------------------------------------------------------------------------


SCODE CFat::FindMaxSect(SECT *psectRet)
{
    SCODE sc = S_OK;

    if (_pfatNoScratch != NULL)
    {
        return _pfatNoScratch->FindMaxSect(psectRet);
    }

    if (_sectMax == ENDOFCHAIN)
    {
        msfChk(FindLast(psectRet));
    }
    else
    {
#if DBG == 1
        SECT sectLast;
        msfChk(FindLast(&sectLast));
        msfAssert(((_sectMax == sectLast) || (_sectMax == _sectLastUsed)) &&
                  aMsg("_sectMax doesn't match actual last sector"));
#endif
        *psectRet = _sectMax;
    }

    if (*psectRet < _sectLastUsed)
    {
        *psectRet = _sectLastUsed;
    }
Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CFat::InitScratch, public
//
//  Synopsis:	Initialize the fat based on another fat.  This is used
//              for NOSCRATCH mode.  The fats may have different sector
//              sizes.
//
//  Arguments:	[pfat] -- Pointer to fat to copy.
//              [fNew] -- TRUE if this is being called on an empty fat.
//
//  Returns:	Appropriate status code
//
//  History:	20-Mar-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CFat::InitScratch(CFat *pfat, BOOL fNew)
{
    SCODE sc = S_OK;

    msfAssert((_sid == SIDMINIFAT) && (_pmsParent->IsScratch()) &&
              aMsg("Called InitScratch on the wrong thing."));

    USHORT cbSectorOriginal = pfat->_pmsParent->GetSectorSize();

    USHORT cSectPerRealSect = _pmsParent->GetSectorSize() /
        cbSectorOriginal;

    //This routine copies the fat from the multistream passed in into
    //  the _minifat_ of the current multistream.

    ULONG cfatOriginal = pfat->_cfsTable;

    //Our minifat must be large enough to hold all of the necessary
    //sectors.  Set the size appropriately.
    ULONG cMiniFatSize = (cfatOriginal + cSectPerRealSect - 1) /
        cSectPerRealSect;

    msfAssert(((!fNew) || (_cfsTable == 0)) &&
              aMsg("fNew TRUE when fat non-empty."));

    msfAssert(((fNew) || (_pfatReal == pfat)) &&
              aMsg("Fat pointer changed between calls to InitScratch"));

    _pfatReal = P_TO_BP(CBasedFatPtr, pfat);

    if (cMiniFatSize > _cfsTable)
    {
        msfChk(Resize(cMiniFatSize));
    }

    ULONG ifs;
    for (ifs = 0; ifs < cfatOriginal; ifs++)
    {
        CFatSect *pfs;
        CFatSect *pfsCurrent;

        //Get the sector from the original fat

        msfChk(pfat->_fv.GetTable(ifs, FB_NONE, &pfs));
        msfAssert(pfs != NULL);

        //Write the sector into the appropriate place in this fat.
        ULONG ifsCurrent;
        ifsCurrent = ifs / cSectPerRealSect;

        OFFSET off;
        off = (USHORT)((ifs % cSectPerRealSect) * cbSectorOriginal);

        msfChk(_fv.GetTable(ifsCurrent, FB_DIRTY, &pfsCurrent));

        if (fNew)
        {
            memcpy((BYTE *)pfsCurrent + off, pfs, cbSectorOriginal);
        }
        else
        {
            //Merge the table into the current one.
            for (USHORT i = 0; i < cbSectorOriginal / sizeof(SECT); i++)
            {
                SECT sectCurrent;
                OFFSET offCurrent;
                offCurrent = i + (off / sizeof(SECT));

                sectCurrent = pfsCurrent->GetSect(offCurrent);

                if (sectCurrent != STREAMSECT)
                {
                    pfsCurrent->SetSect(offCurrent, pfs->GetSect(i));
                }
            }
        }

        _fv.ReleaseTable(ifsCurrent);
        pfat->_fv.ReleaseTable(ifs);
    }

    msfAssert((pfat->_cUnmarkedSects == 0) &&
              aMsg("Fat being copied has changes in DIF"));

    _fv.ResetBits();
    _ulFreeSects = MAX_ULONG;
    _sectFirstFree = 0;
    _sectLastUsed = 0;
    _sectMax = ENDOFCHAIN;
Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CFat::ResizeNoSnapshot, public
//
//  Synopsis:	Resize the fat to handle a no-snapshot commit.  In
//              no-snapshot mode it is possible that another commit has
//              grown the file to the point where it cannot be contained in
//              the existing fat in this open, so we need to grow it before
//              we can continue with anything else.
//
//  Arguments:	None.
//
//  Returns:	Appropriate SCODE.
//
//  History:	19-Jun-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CFat::ResizeNoSnapshot(void)
{
    SCODE sc = S_OK;
    FSINDEX ipfs;
    FSOFFSET isect;

    //If we need to grow the fat to handle the previous commits (which is
    //  possible if other opens are doing a lot of writing), we do it here,
    //  since we know for certain that the first available sector is at
    //  _sectNoSnapshot.
    SectToPair(_sectNoSnapshot, &ipfs, &isect);
    if (ipfs >= _cfsTable)
    {
        //We know we have no free sectors, so we can set this here and
        //  Resize will end up with the correct value.
        _ulFreeSects = 0;

        //This Resize will also cause a resize in the DIFat if necessary.
        sc = Resize(ipfs + 1);
        CheckFreeCount();
    }
    return sc;
}

#if DBG == 1
void CFat::CheckFreeCount(void)
{
    SCODE sc;   // check is disabled if fat grows above >1G
    if ((_ulFreeSects != MAX_ULONG) && (_cfsTable < _ipfsRangeLocks/2))
    {
        ULONG ulFree;
        msfChk(CountFree(&ulFree));
        if (ulFree != _ulFreeSects)
        {
            msfDebugOut((DEB_ERROR,
                         "Free count mismatch.  Cached: %lu, Real: %lu."
                         "   Difference: %li\n",
                         _ulFreeSects,
                         ulFree,
                         ulFree - _ulFreeSects));
        }
        msfAssert((ulFree == _ulFreeSects) &&
                      aMsg("Free count doesn't match cached value."));
    }
Err:
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\sstream.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:           sstream.cxx
//
//  Contents:       Stream operations for Mstream project
//
//  Classes:        None. (defined in sstream.hxx)
//
//  History:        18-Jul-91   PhilipLa    Created.
//                  24-Apr-92   AlexT       Small object support
//
//--------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <dirfunc.hxx>
#include <sstream.hxx>
#include <dl.hxx>
#include <tstream.hxx>
#include <time.h>
#include <mread.hxx>

#define DEB_STREAM (DEB_ITRACE | 0x00020000)




//+--------------------------------------------------------------
//
//  Member:	CDirectStream::CDirectStream, public
//
//  Synopsis:	Empty object constructor
//
//  Arguments:  [dl] - LUID
//
//  History:	25-Aug-92	DrewB	Created
//
//---------------------------------------------------------------

CDirectStream::CDirectStream(DFLUID dl)
: PSStream(dl)
{
    _pdlHolder = NULL;
    _cReferences = 0;
#ifdef SECURE_STREAMS
    _ulSize = 0;
    _ulHighWater = 0;
#endif    
    _sig = CDIRECTSTREAM_SIG;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::~CDirectStream, public
//
//  Synopsis:   CDirectStream destructor
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirectStream::~CDirectStream()
{
    msfAssert(_cReferences == 0);
    _sig = CDIRECTSTREAM_SIGDEL;
#ifdef SECURE_STREAMS
    if (_ulSize > _ulHighWater)
    {
        ClearSects(_ulHighWater, _ulSize);
    }
#endif    
}


//+--------------------------------------------------------------
//
//  Member:	CDirectStream::InitSystem, public
//
//  Synopsis:	Initializes special system streams like the ministream
//
//  Arguments:	[pms] - Multistream
//		[sid] - SID
//		[cbSize] - size
//
//  History:	25-Aug-92	DrewB	Created
//
//---------------------------------------------------------------

void CDirectStream::InitSystem(CMStream *pms,
			       SID sid,
#ifdef LARGE_STREAMS
			       ULONGLONG cbSize)
#else
			       ULONG cbSize)
#endif
{
    _stmh.Init(pms, sid);
    _ulSize = _ulOldSize = cbSize;

    _stmc.Init(pms, sid, this);

#ifdef SECURE_STREAMS
#ifndef SECURE_BUFFER
    //If SECURE_BUFFER is defined, we've already zeroed this in the
    //  multistream.
    memset(s_bufSecure, SECURECHAR, MINISTREAMSIZE);
#endif    
    _ulHighWater = cbSize;
#endif
    
    AddRef();
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::Init, public
//
//  Synopsis:   CDirectStream constructor
//
//  Arguments:  [pstgh] - Parent
//		[pdfn] - Name of entry
//		[fCreate] - Create or get
//
//  Returns:	Appropriate status code
//
//  History:    18-Jul-91   PhilipLa    Created.
//              02-Jan-92   PhilipLa    Converted to use handle.
//		25-Aug-92   DrewB	Converted to use StgHandle
//
//--------------------------------------------------------------------------

SCODE CDirectStream::Init(
        CStgHandle *pstgh,
        CDfName const *pdfn,
        BOOL const fCreate)
{
    SCODE sc;

    if (fCreate)
        sc = pstgh->CreateEntry(pdfn, STGTY_STREAM, &_stmh);
    else
        sc = pstgh->GetEntry(pdfn, STGTY_STREAM, &_stmh);

    if (SUCCEEDED(sc))
    {
	sc = _stmh.GetSize(&_ulSize);
	_ulOldSize = _ulSize;
#ifdef SECURE_STREAMS
        _ulHighWater = (fCreate) ? 0 : _ulSize;
#endif
        
#if DBG == 1
        if (SUCCEEDED(sc))
        {
            //Make sure that the stream is sane.
            SCODE sc2;
            CFat *pfat;
            ULONG cbSector;
            ULONG cSect;
            ULONG cSectReal;
            SECT sectStart;
        
            if (_ulSize < MINISTREAMSIZE)
            {
                cbSector = MINISECTORSIZE;
                pfat = _stmh.GetMS()->GetMiniFat();
            }
            else
            {
                cbSector = _stmh.GetMS()->GetSectorSize();
                pfat = _stmh.GetMS()->GetFat();
            }
        
            cSect = (ULONG)((_ulSize + cbSector - 1) / cbSector);
            sc2 = _stmh.GetMS()->GetDir()->GetStart(
                _stmh.GetSid(),
                &sectStart);
            if (SUCCEEDED(sc2))
            {
                sc2 = pfat->GetLength(sectStart, &cSectReal);
                if (SUCCEEDED(sc2))
                {
                    msfAssert((cSect == cSectReal) &&
                              aMsg("Chain length incorrect at init."));
                }
            }
        }
#endif        
        
        if (SUCCEEDED(sc))
            AddRef();
        _stmc.Init(_stmh.GetMS(), _stmh.GetSid(), this);
    }
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::ReadAt, public
//
//  Synposis:   Reads binary data from a linear single stream
//
//  Arguments:  [ulOffset] -- Position to be read from
//
//              [pBuffer] -- Pointer to the area into which the data
//                           will be read.
//              [ulCount] --  Indicates the number of bytes to be read
//              [pulRetval] -- Area into which return value will be stored
//
//  Returns:    Error Code of parent MStream call
//
//  Algorithm:  Calculate start and end sectors and offsets, then
//              pass call up to parent MStream.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              16-Aug-91   PhilipLa    Converted to use multi-sect read
//              23-Aug-91   PhilipLa    Brought into compliance with protocol
//              11-Sep-91   PhilipLa    Moved most functionality up
//                                      to MStream level.
//              24-Apr-92   AlexT       Move everything to MStream::MRead
//              09-Jun-92   PhilipLa    Added fUnconverted support
//
//  Notes:      [pBuffer] may be unsafe memory
//
//---------------------------------------------------------------------------

SCODE CDirectStream::ReadAt(
#ifdef LARGE_STREAMS
        ULONGLONG ulOffset,
#else
        ULONG ulOffset,
#endif
        VOID HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{
    msfDebugOut((DEB_ITRACE,"In CDirectStream::ReadAt(%lu,%p,%lu)\n",
                           ulOffset,pBuffer,ulCount));

    SCODE sc = S_OK;

    CMStream *pms = _stmh.GetMS();

    *pulRetval = 0;

    if (NULL == pms)
        return STG_E_UNKNOWN;

    //  Check for offset beyond stream size and zero count

    if ((ulOffset >= _ulSize) || (0 == ulCount))
    {
        return S_OK;
    }

    if (ulOffset + ulCount > _ulSize)
    {
        msfDebugOut((DEB_ITRACE,"Truncating Read: ulOffset = %lu, ulCount = %lu, _ulSize = %lu\n",
                                ulOffset,ulCount,_ulSize));
        ulCount = (ULONG)(_ulSize - ulOffset);
    }

#ifdef DELAYCONVERT
    if (pms->IsUnconverted())
    {
	ULARGE_INTEGER ulTmp;
	ULISet32(ulTmp, ulOffset);
        return DfGetScode(pms->GetILB()->ReadAt(ulTmp, pBuffer, ulCount,
                                                pulRetval));
    }
#else
    msfAssert(!pms->IsUnconverted());
#endif

    //  Stream is stored in ministream if size < MINISTREAMSIZE
    //  and this is not a scratch stream.

#ifdef SECURE_STREAMS
    if (ulOffset + ulCount > _ulHighWater)
    {
        if (ulOffset > _ulHighWater)
        {
            //Zero the whole buffer and return.
            memset(pBuffer, SECURECHAR, ulCount);
            *pulRetval = ulCount;
            return S_OK;
        }

        //Need to read into part of the buffer, then zero fill the
        //  rest.
        if (FAILED(sc = ReadAt(ulOffset,
                               pBuffer,
                               _ulHighWater - ulOffset,
                               pulRetval)) ||
            (*pulRetval != _ulHighWater - ulOffset))
        {
            return sc;
        }
        memset((BYTE *)pBuffer + *pulRetval,
               SECURECHAR,
               ulCount - (_ulHighWater - ulOffset));
        
        *pulRetval = ulCount;
        return S_OK;
    }
#endif    
            

    SID sid = _stmh.GetSid();
    CFat *pfat = pms->GetFat();
    USHORT cbSector = pms->GetSectorSize();
    USHORT uShift = pms->GetSectorShift();
    USHORT uMask = pms->GetSectorMask();



    if ((_ulSize < MINISTREAMSIZE) &&
        (!pms->IsScratch()) &&
        (sid != SIDMINISTREAM))
    {
        msfAssert(sid <= MAXREGSID);

        //  This stream is stored in the ministream

        cbSector = MINISECTORSIZE;
        uShift = MINISECTORSHIFT;
        uMask = cbSector - 1;
        pfat = pms->GetMiniFat();
    }

    SECT start = (SECT)(ulOffset >> uShift);
    OFFSET oStart = (OFFSET)(ulOffset & uMask);

    SECT end = (SECT)((ulOffset + ulCount - 1) >> uShift);
    OFFSET oEnd = (OFFSET)((ulOffset + ulCount - 1) & uMask);

    ULONG total = 0;

    ULONG cSect = end - start + 1;

    USHORT offset;
    offset = oStart;

    while (TRUE)
    {
        ULONG cSeg;
        SSegment segtab[CSEG + 1];

        msfChk(_stmc.Contig(start,
                            FALSE,
                            (SSegment STACKBASED *) segtab,
                            cSect,
                            &cSeg));
        msfAssert(cSeg <= CSEG);
        
        USHORT oend = cbSector - 1;
        for (USHORT iseg = 0; iseg < cSeg;)
        {
            msfDebugOut((DEB_ITRACE,"Segment:  (%lu,%lu)\n",segtab[iseg].sectStart,segtab[iseg].cSect));
            SECT sectStart = segtab[iseg].sectStart;
            ULONG i = segtab[iseg].cSect;
            if (i > cSect)
                i = cSect;
            
            cSect -= i;
            start += i;

            iseg++;
            if (cSect == 0)
                oend = oEnd;

            ULONG ulSize = ((i - 1) << uShift) - offset + oend + 1;

            ULONG bytecount;

            if (pms->GetMiniFat() == pfat)
            {
                sc = pms->GetMiniStream()->CDirectStream::ReadAt(
                                            (sectStart << uShift) + offset,
                                             pBuffer, ulSize,
					    (ULONG STACKBASED *)&bytecount);
            }
            else
            {
                ULARGE_INTEGER ulOffset2;
#ifdef LARGE_DOCFILE
                ulOffset2.QuadPart = ConvertSectOffset(sectStart,offset,uShift);
#else
                ULISet32(ulOffset2, ConvertSectOffset(sectStart,offset,uShift));
#endif
                sc = DfGetScode(pms->GetILB()->ReadAt(ulOffset2,
                                                      (BYTE *)pBuffer, ulSize,
                                                      &bytecount));
            }

            total += bytecount;
            if ((0 == cSect) || (FAILED(sc)))
            {
                *pulRetval = total;
                msfDebugOut((DEB_ITRACE,
                    "Leaving CDirectStream::ReadAt()=>%lu, ret is %lu\n",
                     sc,*pulRetval));
                return sc;
            }

            pBuffer = (BYTE HUGEP *)pBuffer + bytecount;
            offset = 0;
        }
    }

    msfDebugOut((DEB_ERROR,"In CDirectStream::ReadAt - reached end of function\n"));
Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::Write, public
//
//  Synposis:   Writes binary data from a linear single stream
//
//  Effects:    Modifies _ulSeekPos.  May cause modification in parent
//                  MStream.
//
//  Arguments:  [pBuffer] -- Pointer to the area from which the data
//                           will be written.
//              [ulCount] --  Indicates the number of bytes to be written
//              [pulRetval] -- Pointer to area in which number of bytes
//                              will be returned
//
//  Returns:    Error code of MStream call.
//
//  Algorithm:  Calculate sector and offset for beginning and end of
//              write, then pass call up to MStream.
//
//
//  History:    18-Jul-91   PhilipLa    Created.
//              16-Aug-91   PhilipLa    Converted to use multi-sect write
//              23-Aug-91   PhilipLa    Brought into compliance with protocol
//              11-Sep-91   PhilipLa    Moved most functionality up
//                                      to MStream level.
//
//  Notes:      [pBuffer] may be unsafe memory
//
//---------------------------------------------------------------------------

SCODE CDirectStream::WriteAt(
#ifdef LARGE_STREAMS
        ULONGLONG ulOffset,
#else
        ULONG ulOffset,
#endif
        VOID const HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{
    msfDebugOut((DEB_ITRACE,"In CDirectStream::WriteAt(%lu,%p,%lu)\n",ulOffset,pBuffer,ulCount));

    *pulRetval = 0;

    if (0 == ulCount)
        return S_OK;

    SCODE sc;

    CMStream *pms;
    pms = _stmh.GetMS();

    if (NULL == pms)
        return STG_E_UNKNOWN;

    if (ulOffset + ulCount > _ulSize)
    {
        if (_ulSize > MINISTREAMSIZE)
        {
        }
        else
        {
            msfChk(SetSize(ulOffset + ulCount));
        }
    }

    //  This should be an inline call to MWrite

#ifdef SECURE_STREAMS    
    if (ulOffset > _ulHighWater)
    {
        ClearSects(_ulHighWater, ulOffset);
    }
#endif
    
    msfChk(pms->MWrite(
            _stmh.GetSid(),
            (_ulSize < MINISTREAMSIZE),
            ulOffset,
            pBuffer,
            ulCount,
            &_stmc,
            pulRetval));

    msfDebugOut((DEB_ITRACE,"Leaving CDirectStream::WriteAt()==>%lu, ret is %lu\n",sc,*pulRetval));

Err:
#ifdef SECURE_STREAMS
    if ((*pulRetval > 0 ) &&
        (ulOffset + *pulRetval > _ulHighWater))
    {
        _ulHighWater = ulOffset + *pulRetval;
    }
#endif
    
    if (*pulRetval > 0 &&
        ulOffset + *pulRetval > _ulSize)
    {
        SCODE scSet;

        _ulSize = ulOffset + *pulRetval;

        scSet = pms->GetDir()->SetSize(_stmh.GetSid(), _ulSize);
        if (SUCCEEDED(sc) && FAILED(scSet))
        {
            sc = scSet;
        }
    }
#ifdef SECURE_STREAMS
    msfAssert(_ulHighWater <= _ulSize);
#endif
    
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::SetSize, public
//
//  Synposis:   Set the size of a linear stream
//
//  Effects:    Modifies _ulSize.  May cause change in parent MStream.
//
//  Arguments:  [ulNewSize] -- New size for stream
//
//  Returns:    Error code returned by MStream call.
//
//  Algorithm:  Pass call up to parent.
//
//  History:    29-Jul-91   PhilipLa    Created.
//              14-May-92   AlexT       Add small object support
//
//  Notes:      When changing the size of a stream, we need to be concerned
//              with the cases where each stream is either zero length,
//  stored in the ministream, or stored in a regular stream.  The following
//  grid shows the actions that we must perform in each case:
//
//                      New Sector Count (Cn)
//
//                      0               S               L
//      O       ------------------------------------------------
//      l       | same size     | allocate Cn   | allocate Cn
//      d   0   |  (fast out)   | small sectors | large sectors
//              ------------------------------------------------
//      S       | small         | Co > Cn:      | cbCopy = cbOld
//      e   S   |  setchain(Cn) |  small        | large allocate Cn
//      c       |               |   setchain(Cn)| copy bytes
//      t       |               | Cn > Co:      | small setchain(0)
//      o       |               |  extend small | copy data
//      r       ------------------------------------------------
//          L   | large         | cbCopy = cbNew| Co > Cn:
//      C       |  setchain(Cn) | small         |  large setchain(Cn)
//      o       |               |  allocate Cn  | Cn > Co:
//      u       |               | copy bytes    |  extend large
//      n       |               | large         |
//      t       |               |  setchain(0)  |
//              |               | copy data     |
//     (Co)     ------------------------------------------------
//
//  where S indicates small sectors, L indicates large sectors, and Cx
//  represents count of sectors.  For example, the middle box represents
//  doing a setsize on a stream which is currently stored in a small
//  stream in Co small sectors and which will end up in a large stream
//  with Cn sectors.
//
//---------------------------------------------------------------------------

#ifdef LARGE_STREAMS
SCODE CDirectStream::SetSize(ULONGLONG cbNewSize)
#else
SCODE CDirectStream::SetSize(ULONG cbNewSize)
#endif
{
    msfDebugOut((DEB_ITRACE,"In CDirectStream::SetSize(%lu)\n",cbNewSize));

    SCODE sc = S_OK;
    BYTE *pBuf = NULL;
    SID sid = _stmh.GetSid();
    CMStream *pms = _stmh.GetMS();
    msfAssert(sid <= MAXREGSID);

    if (NULL == pms)
        return STG_E_UNKNOWN;

    CDirectory *pdir = pms->GetDir();

    if (_ulSize == cbNewSize)
    {
        return S_OK;
    }

#ifdef SECURE_STREAMS
    msfAssert(_ulHighWater <= _ulSize);
#endif

    USHORT cbpsOld = pms->GetSectorSize();
                                        //  Count of Bytes Per Sector
    USHORT cbpsNew = cbpsOld;
    CFat *pfatOld = pms->GetFat();
    CFat *pfatNew = pfatOld;

    if ((!pms->IsScratch()) && (SIDMINISTREAM != sid))
    {
        //  This is not a scratch DocFile, nor is this stream the ministream;
        //  check if this stream is and/or will be stored in the ministream.

        if (cbNewSize < MINISTREAMSIZE)
        {
            cbpsNew = MINISECTORSIZE;
            pfatNew = pms->GetMiniFat();
        }

        if (_ulSize < MINISTREAMSIZE)
        {
            cbpsOld = MINISECTORSIZE;
            pfatOld = pms->GetMiniFat();
        }
    }

    ULONG csectOld = (ULONG)((_ulSize + cbpsOld - 1) / cbpsOld);
    ULONG csectNew = (ULONG)((cbNewSize + cbpsNew - 1) / cbpsNew);

    msfAssert(sid <= MAXREGSID);
    SECT sectstart, sectOldStart;
    msfChk(pdir->GetStart(sid, &sectstart));

    //Save start sector so we can free it later.
    sectOldStart = sectstart;

    msfDebugOut((DEB_ITRACE,"pdbOld size is %lu\n\tSid is %lu\n\tStart is %lu\n",
                _ulSize,sid,sectstart));
    msfDebugOut((DEB_ITRACE,"CMStream::SetSize() needs %lu %u byte sectors\n",
                 csectNew, cbpsNew));
    msfDebugOut((DEB_ITRACE,"SetSize() currently has %lu %u byte sectors\n",
                 csectOld, cbpsOld));

    ULONG cbCopy;
    cbCopy = 0;
    if (cbpsOld != cbpsNew)
    {
        //  Sector sizes are different, so we'll copy the data
        msfAssert((cbNewSize > _ulSize ? _ulSize : cbNewSize) < 0x10000);
        cbCopy = (ULONG)(cbNewSize > _ulSize ? _ulSize : cbNewSize);
    }


    if (cbCopy > 0)
    {
        msfDebugOut((DEB_ITRACE,"Copying between fat and minifat\n"));
        GetSafeBuffer(cbCopy, cbCopy, &pBuf, &cbCopy);
        msfAssert((pBuf != NULL) && aMsg("Couldn't get scratch buffer"));

        ULONG ulRetVal;
        sc = ReadAt(0, pBuf, cbCopy, (ULONG STACKBASED *)&ulRetVal);
#ifdef SECURE_STREAMS
        //Part of the buffer may have gunk in it, so clear it out.
        if (_ulHighWater < cbCopy)
        {
            memset(pBuf + _ulHighWater, SECURECHAR, cbCopy - _ulHighWater);
        }
#endif
        
        if ((FAILED(sc)) ||
            ((ulRetVal != cbCopy) ? (sc = STG_E_UNKNOWN) : 0))
        {
            msfErr(Err, sc);
        }
#ifdef SECURE_STREAMS
        ClearSects(_ulHighWater, _ulSize);
        _ulHighWater = cbNewSize;
#endif

        //The cache is no longer valid, so empty it.
        _stmc.Empty();

        msfChk(_stmc.Allocate(pfatNew, csectNew, &sectstart));
    }
    else
    {
        SECT dummy;

        if ((csectOld > csectNew))
        {
#ifdef SECURE_STREAMS
            ClearSects(_ulHighWater, _ulSize);
            _ulHighWater = cbNewSize;
#endif
            if (0 == csectNew)
            {
                //Note:  We need to set the start sect in the directory
                //  first in case the SetChainLength call fails part way
                //  through, which would leave this directory entry pointing
                //  to a FREESECT.
                SECT sectOldStart2 = sectstart;
                msfChk(pdir->SetStart(sid, ENDOFCHAIN));
                sectstart = ENDOFCHAIN;
                msfChk(pfatOld->SetChainLength(sectOldStart2, 0));
            }
            else
            {
                msfChk(pfatOld->SetChainLength(sectstart, csectNew));
            }

            //If this turns out to be a common case, we can
            //   sometimes keep the cache valid here.
            _stmc.Empty();
        }
        else if (0 == csectOld)
        {
            msfChk(_stmc.Allocate(pfatNew, csectNew, &sectstart));
        }
        else if (csectNew > csectOld)
        {
            ULONG start = csectNew - 1;
            msfChk(_stmc.GetESect(start, &dummy));
        }
    }


    //  Resize the ministream, if necessary
    if (((MINISECTORSIZE == cbpsOld) && (csectOld > 0)) ||
        ((MINISECTORSIZE == cbpsNew) && (csectNew > 0)))
    {
        msfChk(pms->SetMiniSize());
    }

    msfChk(pms->SetSize());

    //If we fail on either of these operations and cbCopy != 0,
    //   we will have data loss.  Ick.

    //  Optimization - we only set the start sector if it has changed.

    if (sectstart != sectOldStart)
    {
        msfChk(pdir->SetStart(sid, sectstart));
    }

    //If we fail here, we're in big trouble.
    msfChk(pdir->SetSize(sid, cbNewSize));

    _ulSize = cbNewSize;
#ifdef SECURE_STREAMS
    if (_ulHighWater > _ulSize)
    {
        _ulHighWater = _ulSize;
    }
#endif    

    if (cbCopy > 0)
    {
        //  now copy the data
        ULONG ulRetVal;

        msfAssert(cbCopy <= _ulSize);
        msfChk(WriteAt(0, pBuf, cbCopy, (ULONG STACKBASED *)&ulRetVal));

        if (ulRetVal != cbCopy)
        {
            msfErr(Err, STG_E_UNKNOWN);
        }

        msfChk(pfatOld->SetChainLength(sectOldStart, 0));
        msfChk(pms->SetMiniSize());
        msfChk(pms->SetSize());
    }

#ifdef SECURE
    if (((csectNew > csectOld) || (cbCopy > 0)) &&
        ((cbNewSize & (cbpsNew - 1)) != 0))
    {
        SECT sectLast;
        msfChk(_stmc.GetSect(csectNew - 1, &sectLast));

        msfVerify(SUCCEEDED(pms->SecureSect(
                sectLast,
                cbNewSize,
                (cbNewSize < MINISTREAMSIZE) && (sid != SIDMINISTREAM))));
    }
#endif //SECURE
#ifdef SECURE_STREAMS
    msfAssert(_ulHighWater <= _ulSize);
#endif
Err:
#ifdef SECURE_STREAMS
    if (_ulHighWater > _ulSize)
    {
        _ulHighWater = _ulSize;
    }
#endif    
    //  Optimization - avoid calling FreeBuffer (which will end up calling
    //  out to CompObj.DLL) when pBuf is NULL (common case).
    if (pBuf != NULL)
        FreeBuffer(pBuf);

    if (FAILED(sc))
        _stmc.Empty();

    
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::BeginCommitFromChild, public
//
//  Synopsis:   Begin a commit from a child stream
//
//  Arguments:  [ulSize] -- Size of child stream
//              [pDelta] -- Pointer to delta list
//              [pstChild] - Child
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  *Finish This*
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectStream::BeginCommitFromChild(
#ifdef LARGE_STREAMS
        ULONGLONG ulSize,
#else
        ULONG ulSize,
#endif
        CDeltaList *pDelta,
        CTransactedStream *pstChild)
{
    msfDebugOut((DEB_ITRACE,"In CDirectStream::BeginCommitFromChild:%p("
                 "%lu, %p, %p)\n", this, ulSize, pDelta, pstChild));

//    msfDebugOut((DEB_ITRACE,"MultiStrean is %p\nStream name is: %ws\n",_stmh.GetMS(),((_stmh.GetMS()))->GetName(_stmh.GetSid())));

    SCODE sc = S_OK;
    ULONG temp;
    BYTE *pb = NULL;

    _pdlHolder = P_TO_BP(CBasedDeltaListPtr, pDelta);

    // Copy-on-write will back out these changes if we fail

#ifdef USE_NOSCRATCH    
    //For no-scratch mode, we commit very differently than we do regularly,
    //   unless this commit is somehow involving the minifat.

    if ((pDelta->IsNoScratch()) &&
        (ulSize >= MINISTREAMSIZE) &&
        ((_ulSize >= MINISTREAMSIZE) || (_ulSize == 0)) &&
        (!pDelta->IsEmpty()))
    {
        USHORT cbSector = pDelta->GetDataSectorSize();
        SECT sectEnd = (SECT)((ulSize + cbSector - 1) / cbSector);
        SECT sectLast = ENDOFCHAIN;
        
        //We update our size and directory first so the stream cache
        //  code knows which fat to get to.
        _ulOldSize = _ulSize;
        _ulSize = ulSize;
        msfChk(_stmh.GetMS()->GetDir()->SetSize(_stmh.GetSid(), ulSize));

        if (_ulOldSize > _ulSize)
        {
            //We need to truncate the chain.
            SECT sectStart;
            _stmh.GetMS()->GetDir()->GetStart(_stmh.GetSid(), &sectStart);
            _stmh.GetMS()->GetFat()->SetChainLength(sectStart, sectEnd);
            _stmc.Empty();
        }
        
        for (ULONG i = 0; i < sectEnd; i++)
        {
            SECT sectDirty;
            SECT sectOld;
            SECT sectNext;
            
            //For each sector, chain the old sector with the
            //existing new one.
            msfChk(pDelta->GetMap(i, DL_READ, &sectDirty));
            if (sectDirty != ENDOFCHAIN)
            {
                if (i > 0)
                {
                    CFat *pfat = _stmh.GetMS()->GetFat();
                    
                    msfChk(_stmc.GetSect(i - 1, &sectLast));
                    msfAssert(sectLast != ENDOFCHAIN);

                    msfChk(pfat->GetNext(sectLast, &sectOld));
                    msfChk(pfat->SetNext(sectLast, sectDirty));
                    if (sectOld != ENDOFCHAIN)
                    {
                        msfChk(pfat->GetNext(sectOld, &sectNext));
                        msfChk(pfat->SetNext(sectOld, FREESECT));
                    }
                    else
                    {
                        sectNext = ENDOFCHAIN;
                    }
                    msfChk(pfat->SetNext(sectDirty, sectNext));
                    msfChk(_stmc.EmptyRegion(i, i));
                }
                else
                {
                    CFat *pfat = _stmh.GetMS()->GetFat();
                    CDirectory *pdir = _stmh.GetMS()->GetDir();
                    
                    sectNext = ENDOFCHAIN;
                    
                    msfChk(pdir->GetStart(_stmh.GetSid(), &sectLast));
                    if (sectLast != ENDOFCHAIN)
                    {
                        msfChk(pfat->GetNext(sectLast, &sectNext));
                        msfChk(pfat->SetNext(sectLast, FREESECT));
                    }
                    msfChk(pfat->SetNext(sectDirty, sectNext));
                    msfChk(pdir->SetStart(_stmh.GetSid(), sectDirty));
                    msfChk(_stmc.EmptyRegion(i, i));
                }
            }
        }
#ifdef SECURE_STREAMS
        _ulHighWater = _ulSize;
#endif
        
#if DBG == 1
        //Make sure that the stream is sane.
#ifdef LARGE_STREAMS
        ULONGLONG ulDirSize;
#else
        ULONG ulDirSize;
#endif
        ULONG cSect;
        ULONG cSectReal;
        SECT sectStart;

        _stmh.GetMS()->GetDir()->GetSize(_stmh.GetSid(), &ulDirSize);
        cSect = (ULONG)((ulDirSize + cbSector - 1) / cbSector);
        _stmh.GetMS()->GetDir()->GetStart(_stmh.GetSid(), &sectStart);
        _stmh.GetMS()->GetFat()->GetLength(sectStart, &cSectReal);
        msfAssert((cSect == cSectReal) &&
                  aMsg("Chain length incorrect after commit."));
#endif        
    }

    else
    {
#endif //USE_NOSCRATCH
        
        //  Note:  It's critical that we do this SetSize first (since we
        //  use our scratch buffer below and SetSize can potentially also
        //  use the scratch buffer.

        msfChk(SetSize(ulSize));
        _ulOldSize = _ulSize;

        msfAssert(pDelta != NULL);

        if (!pDelta->IsEmpty())
        {
            USHORT cbSector = pDelta->GetDataSectorSize();
            USHORT uSectorShift = pDelta->GetDataSectorShift();
            
            ULONG cbActualSize = 0;
            ULONG cbMaxSects = 15;

		    GetSafeBuffer(cbSector, cbSector * cbMaxSects, &pb, &cbActualSize);

            BYTE *pbcurrent = pb;
	    
	    	msfAssert((pb != NULL) && aMsg("Couldn't get scratch buffer"));
            cbMaxSects = cbActualSize / cbSector;

            OFFSET oEnd;
            oEnd = (OFFSET)((_ulSize - 1) % cbSector) + 1;	   

            SECT sectEnd;
            sectEnd = (SECT)((_ulSize + cbSector - 1) / cbSector);

            ULONG ulOffset;
            ILockBytes *pilbDirty;
	    
	    	SECT sectBeginRead  = ENDOFCHAIN;  //the first sector to read	
	    	SECT sectBeginWrite = ENDOFCHAIN;  //the offset of the first place to write 
	    	SECT sectDirty      = ENDOFCHAIN;  //the sector at this offset
	    	
	    	USHORT uReadCount = 0; 	   
	    
            ULARGE_INTEGER ulTmp;
            pilbDirty = pDelta->GetDataILB();
	 

            for (ulOffset = 0; ulOffset < sectEnd; ulOffset++)
            {
               
            	if (sectDirty == ENDOFCHAIN) 
		{   
			sectBeginWrite = ulOffset;
		}

            	msfChk(pDelta->GetMap(ulOffset, DL_READ, &sectDirty));

				
     		// Read will happen when we have determined there is something to read
		// and either
		// we have reached an ENDOFCHAIN
		// we have reached a non-adjacent sector
		// or we have reached the maximun amount that can be read
		if (  (uReadCount) && 
		    ( (sectDirty == ENDOFCHAIN)   		    ||
		      (sectDirty != sectBeginRead + uReadCount)     ||
		      (ulOffset - sectBeginWrite == cbMaxSects)       ))
                {	
		       msfDebugOut((DEB_ITRACE,"Reading %u sectors from sect %lu\n",
                                 uReadCount,
                                 sectBeginRead));

#ifdef LARGE_DOCFILE
                    	ulTmp.QuadPart = ConvertSectOffset(sectBeginRead, 0,
                                        uSectorShift);
#else
                        ULISet32(ulTmp, ConvertSectOffset(sectBeginRead, 0,
                                        uSectorShift));
#endif
		    			msfHChk(pilbDirty->ReadAt(
                            		ulTmp,
                            		pbcurrent,
                            		cbSector * uReadCount,
                            		(ULONG STACKBASED *)&temp));
		    
		    	pbcurrent += cbSector * uReadCount;
		    	sectBeginRead = sectDirty;
		    
		    	//reset the ReadCount now that we are done reading
		    	if (sectDirty == ENDOFCHAIN)
				uReadCount = 0;
		    	else
				uReadCount = 1;
		
		} 	

		// increment the read count
		else if (sectDirty != ENDOFCHAIN)
                {
			if (sectBeginRead == ENDOFCHAIN)
			{   
				sectBeginRead = sectDirty;
                	        uReadCount=1;
		    	}
		    	else if (sectDirty == sectBeginRead + uReadCount)
		    	{
				uReadCount++;
		    	}	
                }
		
		// Write occurs when we have something to write
		// and we have reached an ENDOFCHAIN
		// or the write buffer is full 
		if (((sectDirty == ENDOFCHAIN) &&
		     (sectBeginWrite != ulOffset)      ) ||
		     (ulOffset - sectBeginWrite == cbMaxSects) )
                {

			msfDebugOut((DEB_ITRACE,"Writing %u sectors from sect %lu\n",
                        		ulOffset - sectBeginWrite,
                            		sectBeginWrite));
			
			msfChk(WriteAt(sectBeginWrite * cbSector,
                        	        pb,
                                	cbSector * (ulOffset - sectBeginWrite),
                                   	(ULONG STACKBASED *)&temp));
				   	pbcurrent = pb;
					sectBeginWrite = ulOffset;
		}



            }
	    
	    // After loop, do last read and write
	    if (uReadCount)
	    {
#ifdef LARGE_DOCFILE
  		    ulTmp.QuadPart = ConvertSectOffset(sectBeginRead, 0, uSectorShift);
#else
            ULISet32(ulTmp, ConvertSectOffset(sectBeginRead, 0,
                                                      uSectorShift));
#endif

	        msfDebugOut((DEB_ITRACE,"END::Reading %u sectors from sect %lu\n",
                                 uReadCount,
                                 sectBeginRead));
        
		msfHChk(pilbDirty->ReadAt(
                            ulTmp,
                            pbcurrent,
                            cbSector * uReadCount,
                            (ULONG STACKBASED *)&temp));
	    
		msfDebugOut((DEB_ITRACE,"END::Writing %u sectors from sect %lu\n",
                                 ulOffset - sectBeginWrite,
                                 sectBeginWrite));

		msfChk(WriteAt(sectBeginWrite * cbSector,
                            pb,
			   // all sectors except the last one
                           (cbSector * ((ulOffset-1) -  sectBeginWrite) 
			   // last sector fragment
			   + oEnd  ),
                           (ULONG STACKBASED *)&temp));
	    }        
            
          
	}
#ifdef USE_NOSCRATCH        
    }
#endif    
    msfDebugOut((DEB_ITRACE,"Out CDirectStream::BeginCommitFromChild()\n"));

 Err:
#ifdef SECURE_STREAMS
    msfAssert(_ulHighWater <= _ulSize);
#endif
    FreeBuffer(pb);
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::EndCommitFromChild
//
//  Synopsis:   End a commit sequence from a child stream
//
//  Arguments:  [df] -- Indicates whether to commit or abort
//              [pstChild] - Child
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  *Finish This*
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDirectStream::EndCommitFromChild(DFLAGS df,
                                       CTransactedStream *pstChild)
{
    msfDebugOut((DEB_ITRACE,"In CDirectStream::EndCommitFromChild:%p("
                 "%lu, %p)\n", this, df, pstChild));
    if (!P_COMMIT(df))
    {
        _ulSize = _ulOldSize;
#ifdef SECURE_STREAMS
        _ulHighWater = _ulSize;
#endif        

        //Stream cache is no longer valid, so nuke it.
        _stmc.Empty();
    }

    _pdlHolder = NULL;
    msfDebugOut((DEB_ITRACE,"Out CDirectStream::EndCommitFromChild()\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:	CDirectStream::GetSize, public
//
//  Synopsis:	Gets the size of the stream
//
//  Arguments:	[pulSize] - Size return
//
//  Modifies:	[pulSize]
//
//  History:	08-May-92	DrewB	Created
//
//----------------------------------------------------------------------------

#ifdef LARGE_STREAMS
void CDirectStream::GetSize(ULONGLONG *pulSize)
#else
void CDirectStream::GetSize(ULONG *pulSize)
#endif
{
    *pulSize = _ulSize;
}

//+---------------------------------------------------------------------------
//
//  Member:	CDirectStream::GetDeltaList, public
//
//  Synopsis:	Returns NULL, since a direct stream can never have
//              a delta list.
//
//  Arguments:	None.
//
//  Returns:	NULL
//
//  History:	30-Jul-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

CDeltaList * CDirectStream::GetDeltaList(void)
{
    return NULL;
}

#ifdef SECURE_STREAMS
//+---------------------------------------------------------------------------
//
//  Member:	CDirectStream::ClearSects, private
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	void
//
//  History:	10-Oct-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CDirectStream::ClearSects(ULONG ulStartOffset, ULONG ulEndOffset)
{
    ULONG cbBytesToWrite = ulEndOffset - ulStartOffset;
    ULONG ulOffset = ulStartOffset;
    msfAssert(ulEndOffset >= ulStartOffset);
    //Start offset must be less than high water mark, or the WriteAt
    //  will recurse.
    msfAssert(ulStartOffset <= _ulHighWater);
    
    while (cbBytesToWrite > 0)
    {
        ULONG cbWritten;
        if (FAILED(WriteAt(ulOffset,
                           s_bufSecure,
                           min(MINISTREAMSIZE, cbBytesToWrite),
                           &cbWritten)))
        {
            break;
        }
        ulOffset += cbWritten;
        cbBytesToWrite -= cbWritten;
    }
                
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\tstream.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       tstream.cxx
//
//  Contents:   Transacted stream functions
//
//  Classes:
//
//  Functions:
//
//  History:    23-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include "tstream.hxx"
#include "dl.hxx"
#include "mread.hxx"
#include <handle.hxx>
#include <memory.h>
#include <dfdeb.hxx>

#define DEB_TSTREAM (DEB_ITRACE | 0x00200000)

//+--------------------------------------------------------------
//
//  Member:	CTransactedStream::CTransactedStream, public
//
//  Synopsis:	Empty object ctor
//
//  Arguments:  [pdfn] - Name
//              [dl] - LUID
//              [df] -- Permissions flags
//              [dwType] - Entry type
//              [pmsScratch] -- Scratch multistream
//
//  History:	31-Jul-92	DrewB	Created
//
//---------------------------------------------------------------


CTransactedStream::CTransactedStream(CDfName const *pdfn,
                                     DFLUID dl,
                                     DFLAGS df,
                                     CMStream *pms,
                                     CMStream *pmsScratch)
        : PTSetMember(pdfn, STGTY_STREAM),
          PSStream(dl),
          _dl(pms, pmsScratch)
{
    msfDebugOut((DEB_ITRACE, "In  CTransactedStream::CTransactedStream:%p("
		 "%lu)\n", this, dl));

    _pssBase = NULL;
    _pdlOld = NULL;
    _df = df;
    _cReferences = 0;
    _fDirty = 0;
    _fBeginCommit = FALSE;
    PBasicEntry::_sig = CTRANSACTEDSTREAM_SIG;
    PTSetMember::_sig = CTRANSACTEDSTREAM_SIG;
    msfDebugOut((DEB_ITRACE, "Out CTransactedStream::CTransactedStream\n"));
}

//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::Init, public
//
//  Synopsis:   CTransactedStream constructor
//
//  Arguments:  [pssBase] -- Pointer to base stream
//
//  Returns:	Appropriate status code
//
//  History:    23-Jan-92   PhilipLa    Created.
//		31-Jul-92	DrewB	Converted to Init from ctor
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CTransactedStream::Init(PSStream *pssBase)
{
    SCODE sc;

    msfDebugOut((DEB_ITRACE,"In %p:CTransactedStream constructor(%p)\n",
                 this, pssBase));

    msfChk(SetInitialState(pssBase));

    _pssBase = P_TO_BP(CBasedSStreamPtr, pssBase);

    _sectLastUsed = 0;

    AddRef();
    msfDebugOut((DEB_ITRACE,"Out CTransactedStream constructor\n"));
    // Fall through
Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::~CTransactedStream, public
//
//  Synopsis:   CTransactedStream destructor
//
//  History:    23-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


CTransactedStream::~CTransactedStream()
{

    msfDebugOut((DEB_ITRACE,"In CTransactedStream Destructor\n"));
    msfAssert(_cReferences == 0);

    PBasicEntry::_sig = CTRANSACTEDSTREAM_SIGDEL;
    PTSetMember::_sig = CTRANSACTEDSTREAM_SIGDEL;
    _dl.Empty();

    if (_pssBase)
    {
        _pssBase->Release();
    }


    msfDebugOut((DEB_ITRACE,"Out CTransactedStream Destructor\n"));
}


//+-------------------------------------------------------------------------
//
//  Member:     CTransactedStream::ReadAt, public
//
//  Synposis:   Reads binary data from a transacted stream
//
//  Arguments:  [ulOffset] -- Position to be read from
//
//              [pBuffer] -- Pointer to the area into which the data
//                           will be read.
//              [ulCount] --  Indicates the number of bytes to be read
//              [pulRetval] -- Area into which return value will be stored
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:      [pBuffer] may be unsafe memory
//
//---------------------------------------------------------------------------


SCODE CTransactedStream::ReadAt(
#ifdef LARGE_STREAMS
        ULONGLONG ulOffset,
#else
        ULONG ulOffset,
#endif
        VOID HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{

    msfDebugOut((DEB_ITRACE,"In %p:CTransactedStream::ReadAt(%lu,%p,%lu)\n",this,ulOffset,pBuffer,ulCount));
    SCODE sc;

    if (ulOffset + ulCount > _ulSize)
    {
#ifdef LARGE_STREAMS
        if (_ulSize - ulOffset > ULONG_MAX)  // too far past the end
            ulCount = 0;
        else
#endif
        ulCount = (ULONG)(_ulSize - ulOffset);
    }

    if ((ulCount == 0) || (ulOffset > _ulSize))
    {
        *pulRetval = 0;
        return S_OK;
    }

    msfAssert(P_TRANSACTED(_df));


    if (_dl.IsEmpty())
    {
        //If we have an empty delta list, either our size is 0 (in which
        //  case we'll never get to this line), or we have a parent.

        msfAssert(_pssBase != NULL);
        msfDebugOut((DEB_ITRACE,"Calling up to _pssBase\n"));
        sc = _pssBase->ReadAt(ulOffset,pBuffer,ulCount,pulRetval);
        msfDebugOut((DEB_ITRACE,
                "Out CTransactedStream::ReadAt()=>%lu, ret is %lu\n",
                sc, *pulRetval));

        return sc;
    }

    ILockBytes *pilbDirty = _dl.GetDataILB();
    USHORT cbSector = _dl.GetDataSectorSize();
    USHORT uSectorShift = _dl.GetDataSectorShift();

    ULONG temp = 0;
    ULONG cb = 0;



    SECT snow =(SECT)(ulOffset / cbSector);
    OFFSET off = (OFFSET)(ulOffset % cbSector);

    SECT send = (SECT)((ulOffset + ulCount - 1) / cbSector);
    OFFSET offEnd = (OFFSET)((ulOffset + ulCount - 1) % cbSector);

    USHORT csect = 0;
    SECT sectNext1;
    SECT sectCurrent = snow;
    BYTE HUGEP *pb = (BYTE HUGEP *)pBuffer;
    USHORT oStart = off;
    USHORT oEnd = 0;


    SECT sectLast = ENDOFCHAIN;
    SECT sectFirst = ENDOFCHAIN;

    const USHORT ISDIRTY = 0;
    const USHORT ISBASE = 1;

    USHORT uLast;

    msfChk(_dl.GetMap(sectCurrent, DL_READ, &sectNext1));
    if (sectNext1 != ENDOFCHAIN)
    {
        uLast = ISDIRTY;
        sectLast = sectFirst = sectNext1;
    }
    else
    {
        uLast = ISBASE;
        sectLast = sectFirst = sectCurrent;
    }

    sectCurrent++;

    while (sectCurrent <= send)
    {
        SECT sectNext;
        msfChk(_dl.GetMap(sectCurrent, DL_READ, &sectNext));

        //If any of the following occur, read the current segment:
        //  1)  Sector has mapping and current segment is in base
        //  2)  Sector has mapping and is not contiguous with
        //          current segment.
        //  3)  Sector has no mapping and current segment is in dirty.

        if (((sectNext != ENDOFCHAIN) && (uLast == ISBASE)) ||
            ((sectNext != ENDOFCHAIN) && (sectNext != sectLast + 1)) ||
            ((sectNext == ENDOFCHAIN) && (uLast == ISDIRTY)))

        {
            msfDebugOut((DEB_ITRACE,"Reading block from pssLast\n"));

            if (uLast == ISDIRTY)
            {
                ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
                ulTmp.QuadPart = ConvertSectOffset(
                                sectFirst,
                                oStart,
                                uSectorShift);
#else
                ULISet32(ulTmp, ConvertSectOffset(
                                sectFirst,
                                oStart,
                                uSectorShift));
#endif
                msfHChk(pilbDirty->ReadAt(
			            ulTmp,
                        pb,
                        (sectLast - sectFirst + 1) * cbSector - oStart - oEnd,
                        &temp));
            }
            else
            {
                msfChk(_pssBase->ReadAt(
                        sectFirst * cbSector + oStart,
                        pb,
                        (sectLast - sectFirst + 1) * cbSector - oStart - oEnd,
                        (ULONG STACKBASED *)&temp));
            }

           pb += temp;
           cb += temp;
           oStart = 0;

           if (sectNext == ENDOFCHAIN)
           {
               sectFirst = sectCurrent;
               uLast = ISBASE;
           }
           else
           {
               sectFirst = sectNext;
               uLast = ISDIRTY;
           }
       }

       sectLast = (sectNext == ENDOFCHAIN) ? sectCurrent : sectNext;
       sectCurrent++;

   }

   oEnd = (cbSector - 1) - offEnd;
   msfDebugOut((DEB_ITRACE,"Reading last sector block\n"));
   if (uLast == ISDIRTY)
   {
       ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
       ulTmp.QuadPart = ConvertSectOffset(sectFirst, oStart, uSectorShift);
#else
       ULISet32(ulTmp,
	            ConvertSectOffset(sectFirst, oStart, uSectorShift));
#endif
       msfHChk(pilbDirty->ReadAt(
	       ulTmp,
               pb,
               (sectLast - sectFirst + 1) * cbSector - oStart - oEnd,
               &temp));
   }
   else
   {
       msfChk(_pssBase->ReadAt(
               sectFirst * cbSector + oStart,
               pb,
               (sectLast - sectFirst + 1) * cbSector - oStart - oEnd,
               (ULONG STACKBASED *)&temp));
   }

   pb += temp;
   cb += temp;
   oStart = 0;

    *pulRetval = cb;
    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::ReadAt()=>%lu, ret is %lu\n",(ULONG)S_OK,*pulRetval));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CTransactedStream::WriteAt, public
//
//  Synposis:   Writes binary data to a linear single stream
//
//  Effects:    Modifies _ulSeekPos.  May cause modification in parent
//                  MStream.
//
//  Arguments:  [pBuffer] -- Pointer to the area from which the data
//                           will be written.
//              [ulCount] --  Indicates the number of bytes to be written
//              [pulRetval] -- Pointer to area in which number of bytes
//                              will be returned
//
//  Returns:    Error code of MStream call.
//
//  Algorithm:  Calculate sector and offset for beginning and end of
//              write, then pass call up to MStream.
//
//
//  History:    18-Jul-91   PhilipLa    Created.
//              16-Aug-91   PhilipLa    Converted to use multi-sect write
//              23-Aug-91   PhilipLa    Brought into compliance with protocol
//              11-Sep-91   PhilipLa    Moved most functionality up
//                                      to MStream level.
//
//  Notes:      [pBuffer] may be unsafe memory
//
//---------------------------------------------------------------------------


SCODE CTransactedStream::WriteAt(
#ifdef LARGE_STREAMS
        ULONGLONG ulOffset,
#else
        ULONG ulOffset,
#endif
        VOID const HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{

    msfDebugOut((DEB_ITRACE,"In CTransactedStream::WriteAt(%lu,%p,%lu)\n",ulOffset,pBuffer,ulCount));
    SCODE sc = S_OK;

    msfAssert(P_TRANSACTED(_df));

    USHORT cbSector = _dl.GetDataSectorSize();
    USHORT uSectorShift = _dl.GetDataSectorShift();

    BYTE *pbDirty;
    pbDirty = NULL;
    ULONG temp;
    temp = 0;

    if (ulCount == 0)
    {
        msfDebugOut((DEB_ITRACE,"ulCount==0.  Returning.\n"));
        *pulRetval = 0;
        return S_OK;
    }

    //If size after the write will be greater than the current
    //size, we may need a new delta list.
    if (ulOffset + ulCount > _ulSize)
    {
        msfChk(SetSize(ulOffset + ulCount));
    }


    if (_dl.IsEmpty())
    {
        msfChk(_dl.Init(_ulSize, this));
    }

    ILockBytes *pilbDirty;
    pilbDirty = _dl.GetDataILB();

    SECT sectStart;
    sectStart = (SECT)(ulOffset / cbSector);
    OFFSET oStart;
    oStart = (OFFSET)(ulOffset % cbSector);

    SECT send;
    send = (SECT)((ulOffset + ulCount - 1) / cbSector);
    OFFSET offEnd;
    offEnd = (OFFSET)((ulOffset + ulCount - 1) % cbSector) + 1;
    OFFSET oEnd;
    oEnd = 0;


    BYTE const HUGEP *pb;
    pb = (BYTE const HUGEP *)pBuffer;

    ULONG cb;
    cb = 0;
    USHORT cbBlock;
    cbBlock = 0;

    SECT sectMap = 0;
    SECT sectFirst,sectLast;

    if (sectStart == send)
    {
        oEnd = cbSector - offEnd;
    }


    SECT sectBlockStart;
    msfChk(_dl.GetMap(sectStart, DL_GET, &sectBlockStart));

    //This handles partial first sector and
    //   one sector only writes.
    while ((oStart) || (sectStart == send))
    {

        cbBlock = cbSector - oStart - oEnd;
        if (sectBlockStart == ENDOFCHAIN)
        {
            msfDebugOut((DEB_ITRACE,"Unmapped partial first sector\n"));
            msfChk(_dl.GetMap(sectStart, DL_CREATE, &sectMap));
            msfChk(PartialWrite(
                        sectStart,
                        sectMap,
                        pb,
                        oStart,
                        cbBlock));
        }
        else
        {
            sectMap = sectBlockStart;

            ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
	        ulTmp.QuadPart = ConvertSectOffset(sectMap, oStart, uSectorShift);
#else
            ULISet32 (ulTmp,
                      ConvertSectOffset(sectMap, oStart, uSectorShift));
#endif
            msfHChk(pilbDirty->WriteAt(
		              ulTmp,
                      pb,
				      cbBlock,
                      &temp));
        }

        pb += cbBlock;
        cb += cbBlock;

        //If it was one-sector only, we can return here.
        if (sectStart == send)
        {
            *pulRetval = cb;
            return S_OK;
        }

        sectStart++;

        oStart = 0;
        msfChk(_dl.GetMap(sectStart, DL_GET, &sectBlockStart));
        if (sectStart == send)
        {
            oEnd = cbSector - offEnd;
        }
    }


    if (sectBlockStart == ENDOFCHAIN)
    {
        msfChk(_dl.GetMap(sectStart, DL_CREATE, &sectMap));
    }

    sectLast = sectFirst = (sectBlockStart == ENDOFCHAIN) ? sectMap
                                                          : sectBlockStart;

    SECT sectCurrent;
    sectCurrent = sectStart + 1;

    while (sectCurrent < send)
    {
        msfDebugOut((DEB_ITRACE,"In main loop:  sectCurrent = %lu\n",sectCurrent));
        msfChk(_dl.GetMap(sectCurrent, DL_CREATE, &sectMap));

        if (sectMap != sectLast + 1)
        {
	        ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
	        ulTmp.QuadPart = ConvertSectOffset(sectFirst, oStart, uSectorShift);
#else
            ULISet32 (ulTmp,
                      ConvertSectOffset(sectFirst, oStart, uSectorShift));
#endif
            msfHChk(pilbDirty->WriteAt(
		            ulTmp,
                    pb,
                    (sectLast - sectFirst + 1) * cbSector - oStart,
                    &temp));
            pb += temp;
            cb += temp;
            oStart = 0;

            sectFirst = sectMap;
        }

       sectLast = sectMap;
       sectCurrent++;
   }

   msfAssert(oStart == 0);

   msfChk(_dl.GetMap(sectCurrent, DL_GET, &sectMap));

   oEnd = cbSector - offEnd;

   BOOL fIsMapped;

   if (sectMap == ENDOFCHAIN)
   {
       fIsMapped = FALSE;
       msfChk(_dl.GetMap(sectCurrent,DL_CREATE, &sectMap));
   }
   else
   {
       fIsMapped = TRUE;
   }

   if ((sectMap != sectLast + 1) || (oEnd != 0))
   {
       ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
       ulTmp.QuadPart = ConvertSectOffset(sectFirst, oStart, uSectorShift);
#else
       ULISet32 (ulTmp,
                 ConvertSectOffset(sectFirst, oStart, uSectorShift));
#endif
       msfHChk(pilbDirty->WriteAt(
		           ulTmp,
                   pb,
                   (sectLast - sectFirst + 1) * cbSector - oStart,
                   &temp));
       pb += temp;
       cb += temp;
       oStart = 0;

       sectFirst = sectMap;
   }

   if (oEnd == 0)
   {
       ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
       ulTmp.QuadPart = ConvertSectOffset(sectFirst, oStart, uSectorShift);
#else
       ULISet32 (ulTmp,
                 ConvertSectOffset(sectFirst, oStart, uSectorShift));
#endif
       msfHChk(pilbDirty->WriteAt(
		           ulTmp,
                   pb,
                   (sectMap - sectFirst + 1) * cbSector - oStart - oEnd,
                   &temp));
       pb += temp;
       cb += temp;
       oStart = 0;
   }
   else
   {
       cbBlock = cbSector - oEnd;

       if (!fIsMapped)
       {
           msfChk(PartialWrite(
                       sectCurrent,
                       sectMap,
                       pb,
                       0,
                       cbBlock));
       }
       else
       {
	       ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
           ulTmp.QuadPart = ConvertSectOffset(sectMap, oStart, uSectorShift);
#else
           ULISet32 (ulTmp,
	                 ConvertSectOffset(sectMap, oStart, uSectorShift));
#endif
           msfHChk(pilbDirty->WriteAt(
		           ulTmp,
                   pb,
                   cbBlock,
				   &temp));
       }

       pb += cbBlock;
       cb += cbBlock;
   }

    *pulRetval = cb;

    msfDebugOut((DEB_ITRACE,"Leaving CTransactedStream::WriteAt()==>%lu, ret is %lu\n",(ULONG)S_OK,*pulRetval));
Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTransactedStream::SetSize, public
//
//  Synposis:   Set the size of a linear stream
//
//  Effects:    Modifies _ulSize.  May cause change in parent MStream.
//
//  Arguments:  [ulNewSize] -- New size for stream
//
//  Returns:    Error code returned by MStream call.
//
//  Algorithm:  Pass call up to parent.
//
//  History:    29-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


#ifdef LARGE_STREAMS
SCODE CTransactedStream::SetSize(ULONGLONG ulNewSize)
#else
SCODE CTransactedStream::SetSize(ULONG ulNewSize)
#endif
{
    SCODE sc = S_OK;
    BYTE *pb = NULL;
    SECT sectMaxValid;

    msfDebugOut((DEB_ITRACE,"In CTransactedStream::SetSize(%lu)\n",ulNewSize));
    msfAssert(P_TRANSACTED(_df));

    if (ulNewSize == 0)
    {
        _dl.Empty();
    }
    else if (!_dl.IsEmpty())
    {
        msfChk(_dl.InitResize(ulNewSize));
    }
    else
    {
        msfChk(_dl.Init(ulNewSize, this));
    }

    if (ulNewSize > _ulSize)
    {
        USHORT cbSector = _dl.GetDataSectorSize();
        USHORT uSectorShift = _dl.GetDataSectorShift();

        SECT sectStart, sectEnd, sect, sectNew;

        if (_ulSize == 0)
        {
            sectStart = 0;
        }
        else
        {
            sectStart = (SECT)((_ulSize - 1) / cbSector);
        }

        sectEnd = (SECT)((ulNewSize - 1 ) / cbSector);


        //First, make sure the first sector is copied over OK if necessary.
        msfChk(_dl.GetMap(sectStart, DL_GET, &sectNew));


        if ((sectNew == ENDOFCHAIN) && (_pssBase != NULL) &&
            (_ulSize != 0))
        {
            ULONG cbNull;
            GetSafeBuffer(cbSector, cbSector, &pb, &cbNull);
	    msfAssert((pb != NULL) && aMsg("Couldn't get scratch buffer"));
            ULONG dummy;

            msfChk(_pssBase->ReadAt(
                    (ULONGLONG)(sectStart) << uSectorShift,
                    pb,
                    cbSector,
                    (ULONG STACKBASED *)&dummy));

            msfChk(_dl.GetMap(sectStart, DL_CREATE, &sectNew));

            ULARGE_INTEGER ulTmp;

#ifdef LARGE_DOCFILE
            ulTmp.QuadPart = ConvertSectOffset(sectNew, 0, uSectorShift);
#else
            ULISet32 (ulTmp, ConvertSectOffset(sectNew, 0, uSectorShift));
#endif

            msfHChk(_dl.GetDataILB()->WriteAt(
                    ulTmp,
                    pb,
                    cbSector,
                    &dummy));
            sectStart++;
        }

        //
        // Get the current last valid sector in case there is an error
        // allocating the delta list or MStream space.
        // Warning: FindMaxSect() returns the Max Allocated Sect, Plus One.
        //
        msfChk(_dl.GetDataFat()->FindMaxSect(&sectMaxValid));
        --sectMaxValid;

        //
        // Allocate new sectors one at a time.
        // GetMap() in DL_CREATE mode does not actually grow the MStream.
        // It allocates FAT entries.
        //
        for (sect = sectStart; sect <= sectEnd; sect ++)
        {
            if(FAILED(sc = _dl.GetMap(sect, DL_CREATE, &sectNew)))
                break;
        }

        //
        // Grow the MStream (which in turn grows the ILB) to include
        // any newly allocated SECTs.  If that fails then release entries
        // in the FAT that couldn't be allocated in the ILB.
        // ie. Beyond the previous recorded Max SECT of the MStream.
        //
        if(FAILED(sc) || FAILED(_dl.GetMStream()->SetSize()))
        {
            _dl.ReleaseInvalidSects(sectMaxValid);
            goto Err;
        }
    }
    _ulSize = ulNewSize;

    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::SetSize()\n"));

 Err:
    FreeBuffer(pb);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::BeginCommitFromChild, public
//
//  Synopsis:   Begin a commit from a child TStream
//
//  Arguments:  [ulSize] - New size
//              [pDelta] - Delta list
//              [pstChild] - Child
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


SCODE CTransactedStream::BeginCommitFromChild(
#ifdef LARGE_STREAMS
        ULONGLONG ulSize,
#else
        ULONG ulSize,
#endif
        CDeltaList *pDelta,
        CTransactedStream *pstChild)
{
    msfDebugOut((DEB_ITRACE,"In CTransactedStream::BeginCommitFromChild:%p("
                 "%lu, %p, %p)\n", this, ulSize, pDelta, pstChild));

    msfAssert(P_TRANSACTED(_df));
    _dl.BeginCommit(this);
    _pdlOld = P_TO_BP(CBasedDeltaListPtr, pDelta);
    _ulOldSize = _ulSize;
    _ulSize = ulSize;

    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::BeginCommitFromChild()\n"));
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::EndCommitFromChild, public
//
//  Synopsis:   End a commit from child.
//
//  Arguments:  [df] -- Flags to determine whether to commit or revert
//              [pstChild] - Child
//
//  Returns:    Void.  This can't fail.
//
//  Algorithm:  *Finish This*
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------


void CTransactedStream::EndCommitFromChild(DFLAGS df,
                                           CTransactedStream *pstChild)
{
    msfDebugOut((DEB_ITRACE,"In CTransactedStream::EndCommitFromChild:%p("
                 "%lu, %p)\n", this, df, pstChild));

    msfAssert(P_TRANSACTED(_df));

    _dl.EndCommit(BP_TO_P(CDeltaList *, _pdlOld), df);

    //NOTE: Possible cleanup:  Move _pdlOld into the delta list itself.
    _pdlOld = NULL;

    if (P_COMMIT(df))
    {
        _ulOldSize = 0;
    }
    else
    {
        _ulSize = _ulOldSize;
    }
    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::EndCommitFromChild()\n"));
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::BeginCommit, public
//
//  Synopsis:   Begin a commit of a transacted stream object
//
//  Arguments:  [dwFlags] -- Currently not used (future expansion)
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Call BeginCommitFromChild on base
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:      This is only called by the Transaction Level object.
//
//--------------------------------------------------------------------------


SCODE CTransactedStream::BeginCommit(DWORD const dwFlags)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE,"In CTransactedStream::BeginCommit(%lu)\n",
                 dwFlags));

    msfAssert(_pssBase != NULL);
    msfAssert(P_TRANSACTED(_df));

#if DBG == 1
    if (!HaveResource(DBR_XSCOMMITS, 1))
        msfErr(Err, STG_E_ABNORMALAPIEXIT);
#endif

    _fBeginCommit = TRUE;
    msfChk(_pssBase->BeginCommitFromChild(_ulSize, &_dl, this));

    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::BeginCommit()\n"));

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::EndCommit, public
//
//  Synopsis:   End a commit on a transacted stream object
//
//  Arguments:  [df] -- Indicator of whether to commit or revert
//
//  Returns:    void.  This can't fail.
//
//  Algorithm:  Call EndCommitFromChild on base.
//              If committing, NULL out all previously passed up
//                  dirty information.
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------


void CTransactedStream::EndCommit(DFLAGS const df)
{
    msfDebugOut((DEB_ITRACE,"In CTransactedStream::EndCommit(%lu)\n",df));

    msfAssert(P_TRANSACTED(_df));
    msfAssert((_pssBase != NULL) || (P_ABORT(df)));

    if (!_fBeginCommit)
	return;
    _fBeginCommit = FALSE;

#if DBG == 1
    if (P_COMMIT(df))
        ModifyResLimit(DBR_XSCOMMITS, 1);
#endif

    if (_pssBase != NULL)
    {
        _pssBase->EndCommitFromChild(df, this);
    }

    if (P_COMMIT(df))
    {
        _dl.Empty();
        SetClean();
    }

    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::EndCommit()\n"));
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::Revert, public
//
//  Synopsis:   Revert a transacted stream instance.
//
//  Algorithm:  Destroy dirty stream and delta list.
//              Retrieve size from base.
//              Mark object as Invalid if specified in the flags.
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:      This is only called from the Transaction Level.
//
//--------------------------------------------------------------------------


void CTransactedStream::Revert(void)
{
    msfDebugOut((DEB_ITRACE,"In CTransactedStream::Revert(%lu):  This == %p\n",this));

    _dl.Empty();
    msfVerify(SUCCEEDED(SetInitialState(BP_TO_P(PSStream *, _pssBase))));
    _sectLastUsed = 0;
    SetClean();

    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::Revert()\n"));
}

//+--------------------------------------------------------------
//
//  Member:	CTransactedStream::SetBase, public
//
//  Synopsis:	Sets a new base
//
//  Arguments:	[psst] - New base
//
//  Returns:    Appropriate status code
//
//  History:	31-Jul-92	DrewB	Created
//
//---------------------------------------------------------------


SCODE CTransactedStream::SetBase(PSStream *psst)
{
    msfAssert(_pssBase == NULL || psst == NULL);
    if (_pssBase)
        _pssBase->Release();
    _pssBase = P_TO_BP(CBasedSStreamPtr, psst);
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::PartialWrite, private
//
//  Synopsis:   Do a write of a partial sector
//
//  Arguments:  [sectBase] -- Sector in base to copy
//              [sectDirty] -- Sector in dirty to write to
//              [pb] -- Buffer containing data to be writte
//              [offset] -- Offset into buffer to begin copy
//              [uLen] -- Number of bytes to copy
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    30-Jun-92   PhilipLa    Created.
//
//  Notes:      [pb] may be unsafe memory
//
//--------------------------------------------------------------------------


SCODE CTransactedStream::PartialWrite(
        SECT sectBase,
        SECT sectDirty,
        BYTE const HUGEP *pb,
        USHORT offset,
        USHORT uLen)
{
    msfDebugOut((DEB_ITRACE,"In CTransactedStream::PartialWrite()\n"));
    BYTE *pbMem = NULL;
    SCODE sc;
    ULONG temp;

    USHORT cbSector = _dl.GetDataSectorSize();
    USHORT uSectorShift = _dl.GetDataSectorShift();

    if (uLen != cbSector)
    {
        ULONG cbNull;
        GetSafeBuffer(cbSector, cbSector, &pbMem, &cbNull);
	msfAssert((pbMem != NULL) && aMsg("Couldn't get scratch buffer"));

	if (_pssBase != NULL)
	{
	    msfChk(_pssBase->ReadAt(
	            (ULONGLONG)(sectBase) << uSectorShift,
                pbMem,
                cbSector,
                (ULONG STACKBASED *)&temp));
	}

        TRY
        {
            memcpy(pbMem + offset, pb, uLen);
        }
        CATCH(CException, e)
        {
            UNREFERENCED_PARM(e);
            msfErr(Err, STG_E_INVALIDPOINTER);
        }
        END_CATCH

        pb = pbMem;
    }

    ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
    ulTmp.QuadPart = ConvertSectOffset(sectDirty, 0, uSectorShift);
#else
    ULISet32 (ulTmp,
              ConvertSectOffset(sectDirty, 0, uSectorShift));
#endif

    sc = DfGetScode((_dl.GetDataILB())->WriteAt(
                ulTmp,
                pb,
                cbSector,
                &temp));

Err:
    FreeBuffer(pbMem);
    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::PartialWrite()\n"));
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::GetCommitInfo, public
//
//  Synopsis:   Return the current size of the stream and the size of
//              its base.
//
//  Arguments:  [pulRet1] -- Pointer to return location for old size
//              [pulRet2] -- Pointer to return location for current size
//
//  History:    08-Jul-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


#ifdef LARGE_STREAMS
void CTransactedStream::GetCommitInfo(ULONGLONG *pulRet1, ULONGLONG *pulRet2)
#else
void CTransactedStream::GetCommitInfo(ULONG *pulRet1, ULONG *pulRet2)
#endif
{
    if (_pssBase != NULL)
	_pssBase->GetSize(pulRet1);
    else
	*pulRet1 = 0;
    *pulRet2 = _ulSize;
}

//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::GetSize, public
//
//  Synopsis:   Returns the size of the stream.
//
//  Arguments:  [pulSize] -- Pointer to return location for size.
//
//  Returns:    S_OK
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#ifdef LARGE_STREAMS
void CTransactedStream::GetSize(ULONGLONG *pulSize)
#else
void CTransactedStream::GetSize(ULONG *pulSize)
#endif
{
    msfAssert(P_TRANSACTED(_df));

    *pulSize = _ulSize;

    msfDebugOut((DEB_ITRACE,"CTransactedStream::GetSize()==>%lu\n",*pulSize));
}

//+---------------------------------------------------------------------------
//
//  Member:	CTransactedStream::SetInitialState, public
//
//  Synopsis:	Sets the initial state from a base or defaults
//
//  Arguments:	[pssBase] - Base or NULL
//
//  Returns:	Appropriate status code
//
//  History:	11-Nov-92	DrewB	Created
//
//----------------------------------------------------------------------------


SCODE CTransactedStream::SetInitialState(PSStream *pssBase)
{
    olDebugOut((DEB_ITRACE, "In  CTransactedStream::SetInitialState:%p(%p)\n",
                this, pssBase));
    if (pssBase == NULL)
    {
        _ulSize = 0;
    }
    else
    {
        pssBase->GetSize(&_ulSize);
    }
    olDebugOut((DEB_ITRACE, "Out CTransactedStream::SetInitialState\n"));
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:	CTransactedStream::GetDeltaList, public
//
//  Synopsis:	Return a pointer to the delta list if it is not empty.
//              If it is empty, call GetDeltaList on the parent and
//              return that.
//
//  Arguments:	None.
//
//  Returns:	Pointer as above.
//
//  History:	30-Jul-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

CDeltaList * CTransactedStream::GetDeltaList(void)
{
    if (_dl.IsEmpty())
    {
        if (_pssBase != NULL)
        {
            return _pssBase->GetDeltaList();
        }
        else
        {
            //This case will only be hit if someone creates a new
            //  stream, then commits it to its parent without writing
            //  anything to it.  The parent then has an empty delta
            //  list with no parent set on it.
            msfAssert(_ulSize == 0);
            return NULL;
        }
    }
    else
        return &_dl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\msf\vect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	vect.cxx
//
//  Contents:	Vector common code.
//
//  Classes:	
//
//  Functions:	
//
//  History:	27-Oct-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "msfhead.cxx"
#pragma hdrstop

#include <msffunc.hxx>
#include <vect.hxx>
#include <ole.hxx>
#include <entry.hxx>
#include <smalloc.hxx>


inline CVectBits * CPagedVector::GetNewVectBits(ULONG ulSize)
{
    msfAssert(ulSize > 0);
    CVectBits *pfb = NULL;

    if (ulSize <= (_HEAP_MAXREQ / sizeof(CVectBits)))
    {
        pfb = (CVectBits *) _pmsParent->GetMalloc()->Alloc(ulSize *
                                                           sizeof(CVectBits));
        if (pfb)
        {
            memset(pfb, 0, (ulSize * sizeof(CVectBits)));
        }
    }
    return pfb;
}

inline CBasedMSFPagePtr* VECT_CLASS
    CPagedVector::GetNewPageArray(ULONG ulSize)
{
    msfAssert(ulSize > 0);
    if (ulSize > (_HEAP_MAXREQ / sizeof(CMSFPage *)))
    {
        return NULL;
    }

    return (CBasedMSFPagePtr *)
        _pmsParent->GetMalloc()->Alloc(ulSize * sizeof(CMSFPage *));
}

//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::Init, public
//
//  Synopsis:   CPagedVector initialization function
//
//  Arguments:  [ulSize] -- size of vector
//              [uFatEntries] -- number of entries in each table
//
//  Algorithm:  Allocate an array of pointer of size ulSize
//              For each cell in the array, allocate a CFatSect
//
//  History:    27-Dec-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE VECT_CLASS CPagedVector::Init(CMStream *pmsParent,
                                    ULONG ulSize)
{
    msfDebugOut((DEB_ITRACE,"In CPagedVector::CPagedVector(%lu)\n",ulSize));
    SCODE sc = S_OK;
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    CMSFPageTable *pmptTemp = _pmsParent->GetPageTable();
    _pmpt = P_TO_BP(CBasedMSFPageTablePtr, pmptTemp);

    msfAssert(_pmpt != NULL);

    ULONG i;

    //  We don't bother allocating more than necessary here
    _ulAllocSize = _ulSize = ulSize;

    if (_ulSize > 0)
    {
        CBasedMSFPagePtr *ampTemp;
        msfMem(ampTemp = GetNewPageArray(ulSize));
        for (i = 0; i < _ulSize; i++)
        {
            ampTemp[i] = NULL;
        }
        _amp = P_TO_BP(CBasedMSFPagePtrPtr, ampTemp);

        CVectBits *avbTemp;
        msfMem(avbTemp = GetNewVectBits(ulSize));
        _avb = P_TO_BP(CBasedVectBitsPtr, avbTemp);
    }

    msfDebugOut((DEB_ITRACE,"Out CPagedVector::CPagedVector()\n"));
    return S_OK;

Err:
    //In the error case, discard whatever vectors we were able to allocate
    //   and return S_OK.
    _pmsParent->GetMalloc()->Free(BP_TO_P(CBasedMSFPagePtr *, _amp));
    _amp = NULL;

    _pmsParent->GetMalloc()->Free(BP_TO_P(CVectBits *,_avb));
    _avb = NULL;

    return S_OK;

}

//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::~CPagedVector, public
//
//  Synopsis:   CPagedVector constructor
//
//  Algorithm:  Delete the pointer array.
//
//  History:    27-Oct-92   PhilipLa    Created.
//		20-Jul-95   SusiA	Changed Free to FreeNoMutex
//
//  Notes:   This function freed the SmAllocator object without first obtaining 
//	     the mutex.  Callling functions should already have the DFMutex locked.
//
//--------------------------------------------------------------------------

VECT_CLASS CPagedVector::~CPagedVector()
{
    if (_pmsParent != NULL)
    {
#ifdef MULTIHEAP
        // Free is the same as FreeNoMutex now
        _pmsParent->GetMalloc()->Free(BP_TO_P(CBasedMSFPagePtr*, _amp));
        _pmsParent->GetMalloc()->Free(BP_TO_P(CVectBits *,_avb));
#else
        g_smAllocator.FreeNoMutex(BP_TO_P(CBasedMSFPagePtr*, _amp));
        g_smAllocator.FreeNoMutex(BP_TO_P(CVectBits *, _avb));
#endif
    
    }
    else
        msfAssert(_amp == NULL && _avb == NULL &&
                  aMsg("Can't free arrays without allocator"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::Empty, public
//
//  Synopsis:	Discard the storage associated with this vector.
//
//  Arguments:	None.
//
//  Returns:	void.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CPagedVector::Empty(void)
{
    if (_pmpt != NULL)
    {
        _pmpt->FreePages(this);
    }

    msfAssert(((_pmsParent != NULL) || ((_amp == NULL) && (_avb == NULL))) &&
            aMsg("Can't get to IMalloc for vector memory."));
    
    if (_pmsParent != NULL)
    {
        _pmsParent->GetMalloc()->Free(BP_TO_P(CBasedMSFPagePtr*, _amp));
        _pmsParent->GetMalloc()->Free(BP_TO_P(CVectBits *, _avb));
    }
    
    _amp = NULL;
    _avb = NULL;
    _pmpt = NULL;
    _ulAllocSize = _ulSize = 0;
    _pmsParent = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::Flush, public
//
//  Synopsis:	Flush the dirty pages for this vector
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	02-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CPagedVector::Flush(void)
{
#ifndef SORTPAGETABLE    
    SCODE sc;
    SCODE scRet = S_OK;

    if (_ulSize > 0)
    {
        if (_amp != NULL)
        {
            for (ULONG i = 0; i < _ulSize; i++)
            {
                if ((_amp[i] != NULL) && (_amp[i]->IsDirty()))
                {
                    sc = _pmpt->FlushPage(BP_TO_P(CMSFPage *, _amp[i]));
                    if ((FAILED(sc)) && (SUCCEEDED(scRet)))
                    {
                        scRet = sc;
                    }
                }
            }
        }
        else
        {
            scRet = _pmpt->Flush();
        }
    }

    return scRet;
#else
    return S_OK;
#endif    
}


//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::GetTable, public
//
//  Synopsis:   Return a pointer to a page for the given index
//              into the vector.
//
//  Arguments:  [iTable] -- index into vector
//              [ppmp] -- Pointer to return location
//
//  Returns:    S_OK if call completed OK.
//
//  History:    27-Oct-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE VECT_CLASS CPagedVector::GetTableWithSect(
        const FSINDEX iTable,
        DWORD dwFlags,
        SECT sectKnown,
        void **ppmp)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;

    msfAssert((_pmsParent->GetILB() != NULL) &&
            aMsg("Null ILB found on GetTable - need SetAccess call?"));

    // docfile is corrupted with an invalid iTable size
    if (iTable >= _ulSize)
    {
	msfErr(Err, STG_E_DOCFILECORRUPT);
 
    } 

    if ((_amp == NULL) || (_amp[iTable] == NULL))
    {
        if (dwFlags & FB_NEW)
        {
            //We know that the page isn't in the page table,
            //  so we can just get a free page an allocate it
            //  ourselves.

            msfChk(_pmpt->GetFreePage(&pmp));

            pmp->SetVector(this);
            pmp->SetSid(_sid);
            pmp->SetOffset(iTable);
#ifdef SORTPAGETABLE
            _pmpt->SetSect(pmp, ENDOFCHAIN);
#else            
            pmp->SetSect(ENDOFCHAIN);
#endif            

            sc = STG_S_NEWPAGE;
            dwFlags = (dwFlags & ~FB_NEW) | FB_DIRTY;
        }
        else
        {
            msfChk(_pmpt->GetPage(this,
                                  _sid, iTable, sectKnown, &pmp));
            msfAssert((pmp->GetVector() == this) &&
                    aMsg("GetPage returned wrong page."));
        }


        if (_amp != NULL)
        {
            _amp[iTable] = P_TO_BP(CBasedMSFPagePtr, pmp);
        }

    }
    else
    {
        pmp = BP_TO_P(CMSFPage *, _amp[iTable]);
        msfAssert((pmp->GetVector() == this) &&
                aMsg("Cached page has wrong vector pointer"));
    }

    pmp->AddRef();

    if (((dwFlags & FB_DIRTY) && !(pmp->IsDirty())) &&
        (sc != STG_S_NEWPAGE))
    {
        //If we are not a newly created page, and we are being
        //   dirtied for the first time, make sure that our
        //   _sect field is correct.
        //
        //Newly created pages have to have their sect set manually
        //  _before_ being released.  This is very important.

        msfAssert(!_pmsParent->IsShadow() &&
                aMsg("Dirtying page in shadow multistream."));

        msfChkTo(Err_Rel, _pmsParent->GetFat()->QueryRemapped(pmp->GetSect()));

        if (sc == S_FALSE)
        {
#ifdef SORTPAGETABLE
            _pmpt->SetSect(pmp, ENDOFCHAIN);
#else            
            pmp->SetSect(ENDOFCHAIN);
#endif            

            SECT sect;
            msfChkTo(Err_Rel, _pmsParent->GetESect(
                    pmp->GetSid(),
                    pmp->GetOffset(),
                    &sect));

#ifdef SORTPAGETABLE
            _pmpt->SetSect(pmp, sect);
#else            
            pmp->SetSect(sect);
#endif            
        }
    }
#if DBG == 1
    else if ((pmp->IsDirty()) && (!pmp->IsInUse()) && (sc != STG_S_NEWPAGE))
    {
        msfAssert((_pmsParent->GetFat()->QueryRemapped(pmp->GetSect()) ==
                S_OK) &&
                aMsg("Found unremapped dirty page."));
    }
#endif

    pmp->SetFlags(pmp->GetFlags() | dwFlags | FB_TOUCHED);
    msfAssert((pmp->GetVector() == this) &&
            aMsg("GetTable returned wrong page."));
    *ppmp = pmp->GetData();

Err:
    return sc;

Err_Rel:
    pmp->Release();
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::SetDirty, public
//
//  Synopsis:	Set the dirty bit on the specified page
//
//  Arguments:	[iTable] -- Table to set bit on
//
//  History:	28-Oct-92	PhilipLa	Created
//
//  Notes:  This function is always called on a page with an
//              open reference.  Therefore, the page is
//              guaranteed to be in the page table, and that
//              FindPage call should never return an error.
//
//----------------------------------------------------------------------------

SCODE CPagedVector::SetDirty(ULONG iTable)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;

    msfAssert((!_pmsParent->IsShadow()) &&
            aMsg("Dirtying page in shadow."));

    if (_amp == NULL)
    {

        msfChk(_pmpt->FindPage(this, _sid, iTable, &pmp));
        msfAssert(sc == STG_S_FOUND);
        msfAssert(pmp->IsInUse() &&
                aMsg("Called SetDirty on page not in use."));
    }
    else
    {
        msfAssert(_amp != NULL);
        msfAssert(_amp[iTable] != NULL);
        pmp = BP_TO_P(CMSFPage *, _amp[iTable]);
    }

    if (!pmp->IsDirty())
    {
        //We are not a newly created page, and we are being
        //   dirtied for the first time, make sure that our
        //   _sect field is correct.
        //

        msfAssert(!_pmsParent->IsShadow() &&
                aMsg("Dirtying page in shadow multistream."));
        pmp->AddRef();

        msfChkTo(Err_Rel, _pmsParent->GetFat()->QueryRemapped(pmp->GetSect()));

        if (sc == S_FALSE)
        {
#ifdef SORTPAGETABLE
            _pmpt->SetSect(pmp, ENDOFCHAIN);
#else            
            pmp->SetSect(ENDOFCHAIN);
#endif            

            SECT sect;
            msfChkTo(Err_Rel, _pmsParent->GetESect(
                    pmp->GetSid(),
                    pmp->GetOffset(),
                    &sect));

#ifdef SORTPAGETABLE
            _pmpt->SetSect(pmp, sect);
#else
            pmp->SetSect(sect);
#endif            
        }

        pmp->Release();
    }
#if DBG == 1
    else
    {
        pmp->AddRef();
        sc = _pmsParent->GetFat()->QueryRemapped(pmp->GetSect());
        msfAssert((SUCCEEDED(sc)) &&
                aMsg("QueryRemapped returned error"));
        msfAssert((sc == S_OK) &&
                aMsg("QueryRemapped returned non-TRUE value."));
        pmp->Release();
    }
#endif

    pmp->SetDirty();

 Err:
    return sc;

 Err_Rel:
    pmp->Release();
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::Resize, public
//
//  Synopsis:   Resize a CPagedVector
//
//  Arguments:  [ulSize] -- Size of new vector
//
//  Algorithm:  Create new pointer array of size ulSize.
//              For each entry in old array, copy the pointer over.
//
//  History:    27-Oct-92   PhilipLa    Created.
//              08-Feb-93   AlexT       Add LARGETHRESHOLD support
//
//  Notes:
//
//--------------------------------------------------------------------------

#define LARGETHRESHOLD  1024
#define VECTORBLOCK     1024    //  Must be power of 2

SCODE VECT_CLASS CPagedVector::Resize(FSINDEX ulSize)
{
    msfDebugOut((DEB_ITRACE,"In CPagedVector::CPagedVector(%lu)\n",ulSize));

    msfAssert(ulSize >= _ulSize);
    msfAssert(_ulSize <= _ulAllocSize);
    msfAssert(((VECTORBLOCK & (VECTORBLOCK - 1)) == 0) &&
              aMsg("VECTORBLOCK must be power of 2"));

    msfAssert(!((_amp == NULL) && (_avb != NULL)) &&
            aMsg("Resize precondition failed."));

    if (ulSize > _ulAllocSize)
    {
        //  We don't have room in the existing vector;  grow it
        ULONG ulNewAllocSize = ulSize;

        if (ulNewAllocSize > LARGETHRESHOLD)
        {
            //  We're dealing with a large vector;  grow it a VECTORBLOCK
            //  at a time
            ulNewAllocSize = (ulNewAllocSize + VECTORBLOCK - 1) &
                             ~(VECTORBLOCK - 1);
        }

        CBasedMSFPagePtr *amp = GetNewPageArray(ulNewAllocSize);
        CVectBits *avb = GetNewVectBits(ulNewAllocSize);

        //  Can't fail after this point

        _ulAllocSize = ulNewAllocSize;

        //  Copy over the old entries


        if ((amp != NULL) && (avb != NULL))
        {
            if ((_amp != NULL) && (_avb != NULL))
            {
                //  Both allocations succeeded
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = _amp[iamp];
                    avb[iamp] = _avb[iamp];
                }
            }
            else if (_amp != NULL)
            {
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = _amp[iamp];
                }
            }
            else
            {
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = NULL;
                }
            }
        }
        else
        {
            //  At least one of the allocations failed
            _pmsParent->GetMalloc()->Free(avb);
            avb = NULL;

            _pmsParent->GetMalloc()->Free(amp);
            amp = NULL;
        }

        //  Delete the old vector and put in the new one (if any).
        //  In the error case, throw away the vectors we are currently
        //  holding (since they are of insufficient size) and return S_OK.

        _pmsParent->GetMalloc()->Free(BP_TO_P(CBasedMSFPagePtr*, _amp));
        _amp = P_TO_BP(CBasedMSFPagePtrPtr, amp);

        _pmsParent->GetMalloc()->Free(BP_TO_P(CVectBits *, _avb));
        _avb = P_TO_BP(CBasedVectBitsPtr, avb);
    }

    if (_amp != NULL)
    {
        //  Initialize the new elements in the vector

        for (ULONG iamp = _ulSize; iamp < ulSize; iamp++)
            _amp[iamp] = NULL;
    }

    _ulSize = ulSize;

    msfDebugOut((DEB_ITRACE,"Out CPagedVector resize constructor\n"));
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::InitCopy, public
//
//  Synopsis:   CPagedVector Init function for copying
//
//  Arguments:  [vectOld] -- Reference to vector to be copied.
//
//  Algorithm:  *Finish This*
//
//  History:    27-Oct-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void VECT_CLASS CPagedVector::InitCopy(CPagedVector *pvectOld)
{
    msfDebugOut((DEB_ITRACE,"In CPagedVector copy constructor\n"));
    SCODE sc;
    ULONG i;

    _pmsParent = pvectOld->_pmsParent;

    CMSFPageTable *pmpt;
    pmpt = _pmsParent->GetPageTable();
    _pmpt = P_TO_BP(CBasedMSFPageTablePtr, pmpt);

    _ulAllocSize = _ulSize = pvectOld->_ulSize;

    if (_ulSize > 0)
    {
        CBasedMSFPagePtr* amp;
        msfMem(amp = GetNewPageArray(_ulSize));
        for (i = 0; i < _ulSize; i++)
        {
            amp[i] = NULL;
            if (pvectOld->_amp != NULL)
            {
                _pmpt->CopyPage(this,
                                BP_TO_P(CMSFPage *, pvectOld->_amp[i]),
                                &(amp[i]));
            }
        }
        _amp = P_TO_BP(CBasedMSFPagePtrPtr, amp);

        CVectBits *avb;
        msfMem(avb = GetNewVectBits(_ulSize));
        if (pvectOld->_avb != NULL)
        {
            for (i = 0; i < _ulSize; i++)
            {
                avb[i] = ((CPagedVector *)pvectOld)->_avb[i];
            }
        }
        _avb = P_TO_BP(CBasedVectBitsPtr, avb);
    }

    msfDebugOut((DEB_ITRACE,"Out CPagedVector copy constructor\n"));

    //In the error case, keep whatever vectors we managed to allocate
    //  and return.
Err:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\hforpset.cxx ===
//+============================================================================
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:   hforpset.cxx
//
//          This file provides the definition of the CNtfsStorageForPropSetStg
//          class.  This class presents an IStorage implementation to the
//          CPropertySetStorage implementation of IPropertySetStorage.
//          Mostly, this class forwards to CNtfsStorage.
//
//          The reason this class exists is because CNtfsStorage (which just
//          wraps NTFS) doesn't support storages.  This class supports
//          storages by creating a docfile in an underlying NTFS stream.
//
//  History:
//
//      3/10/98  MikeHill   - Factored out common code in the create/open paths.
//      5/18/98 MikeHill
//              -   Parameter validation in CNtfsStorageForPropSetStg::
//                  Create/OpenStorage.
//      6/11/98 MikeHill
//              -   Dbg output, parameter validation.
//              -   In CreateOrOpenStorage(create), clean up partially
//                  created stream on error.
//
//+============================================================================


#include <pch.cxx>
#include <expparam.hxx> // CExpParameterValidate
#include <docfilep.hxx>


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStorageForPropSetStg::QueryInterface (IUnknown)
//
//  This method only allows QI between IStorage & IUnknown.  This is the only
//  kind of QI that CPropertySetStorage makes.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::QueryInterface( REFIID riid, void** ppvObject )
{
    HRESULT hr = S_OK;

    if( IID_IUnknown == riid || IID_IStorage == riid )
    {
        *ppvObject = static_cast<IStorage*>(this);
        AddRef();
        hr = S_OK;
    }
    else
        hr = E_NOINTERFACE;

    return( hr );

}   // CNtfsStorageForPropSetStg::QueryInterface


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStorage::CNtfsStorageForPropSetStg delegation methods
//
//  These methods all delegate directly to CNtfsStorage's IStorage methods.
//
//+----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::AddRef()
{
    return( _pNtfsStorage->AddRef() );
}

ULONG STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::Release()
{
    return( _pNtfsStorage->Release() );
}


HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::Commit(
            /* [in] */ DWORD grfCommitFlags)
{
    return( _pNtfsStorage->Commit( grfCommitFlags ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::Revert( void)
{
    return( _pNtfsStorage->Revert() );
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::SetElementTimes(
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ const FILETIME __RPC_FAR *pctime,
            /* [unique][in] */ const FILETIME __RPC_FAR *patime,
            /* [unique][in] */ const FILETIME __RPC_FAR *pmtime)
{
    return( _pNtfsStorage->SetElementTimes( pwcsName, pctime, patime, pmtime ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::SetClass(
            /* [in] */ REFCLSID clsid)
{
    return( _pNtfsStorage->SetClass( clsid ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::SetStateBits(
            /* [in] */ DWORD grfStateBits,
            /* [in] */ DWORD grfMask)
{
    return( _pNtfsStorage->SetStateBits( grfStateBits, grfMask ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::Stat(
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag)
{
    return( _pNtfsStorage->Stat( pstatstg, grfStatFlag ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::EnumElements(
    /* [in] */ DWORD reserved1,
    /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
    /* [in] */ DWORD reserved3,
    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    return( _pNtfsStorage->EnumElements( reserved1, reserved2, reserved3, ppenum ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::DestroyElement(
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName)
{
    return( _pNtfsStorage->DestroyElement( pwcsName ));
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStorageForPropSetStg noimpl methods
//
//  These methods are unused by CPropertySetStorage and left unimplemented.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::CopyTo(
    /* [in] */ DWORD ciidExclude,
    /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
    /* [unique][in] */ SNB snbExclude,
    /* [unique][in] */ IStorage __RPC_FAR *pstgDest)
{
    return( E_NOTIMPL );    // No need to implement
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::MoveElementTo(
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
            /* [in] */ DWORD grfFlags)
{
    return( E_NOTIMPL );    // Not necessary to implement
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::RenameElement(
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName)
{
    return( E_NOTIMPL );    // Not necessary to implement
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStorageForPropSetStg::CreateStorage (IStorage)
//
//  CNtfsStorage doesn't support CreateStorage.  For CPropertySetStorage,
//  we support it with the special CNtfsStorageForPropStg, which is created
//  here.
//
//+----------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::CreateStorage(
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg)
{

    HRESULT hr = S_OK;
    IStorage *    pstg = NULL;
    CNtfsStream *pNtfsStream = NULL;

    propXTrace( "CNtfsStorageForPropSetStg::CreateStorage" );

    _pNtfsStorage->Lock( INFINITE );

    // Parameter validation

    hr = CExpParameterValidate::CreateStorage( pwcsName, grfMode, reserved1,
                                               reserved2, ppstg );
    if( FAILED(hr) ) goto Exit;

    // We require STGM_SHARE_EXCLUSIVE

    hr = EnforceSingle(grfMode);
    if( FAILED(hr) ) goto Exit;

    propTraceParameters(( "%ws, 0x%08x, 0x%x, 0x%x, %p",
                          pwcsName, grfMode, reserved1, reserved2, ppstg ));

    // In the underlying CNtfsStorage, we give streams and storages different
    // names (storages have a "Docf_" prefix).  So we require special
    // handling for STGM_CREATE/STGM_FAILIFTHERE - we have to check 
    // to see if a *stream* (which doesn't have the "Docf_" prefix)
    // already exists by that name.

    if( STGM_CREATE & grfMode )
    {
        // Delete any existing stream

        hr = _pNtfsStorage->DestroyStreamElement( pwcsName );
        if( FAILED(hr) && STG_E_FILENOTFOUND != hr )
        {
            propDbg(( DEB_ERROR, "Couldn't destroy %s", pwcsName ));
            goto Exit;
        }
        hr = S_OK;
    }
    else
    {
        // STGM_FAILIFTHERE

        // See if a stream by this name already exists.

        hr = _pNtfsStorage->StreamExists( pwcsName );
        if( FAILED(hr) ) goto Exit;

        if( S_OK == hr )
        {
            hr = STG_E_FILEALREADYEXISTS;
            goto Exit;
        }
    }

    // Create the storage

    hr = CreateOrOpenStorage( pwcsName, NULL, grfMode, NULL, TRUE /* fCreate */, &pstg );
    if( FAILED(hr) ) goto Exit;

    *ppstg = pstg;
    pstg = NULL;

Exit:

    if( pstg )
        pstg->Release();

    _pNtfsStorage->Unlock();

    if( STG_E_FILEALREADYEXISTS == hr )
        propSuppressExitErrors();
    return( hr );

}   // CNtfsStorageForPropSetStg::CreateStorage

//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStorageForPropSetStg::OpenStorage (IStorage)
//
//  CNtfsStorage doesn't support OpenStorage.  For CPropertySetStorage,
//  we support it with the special CNtfsStorageForPropStg, which is created
//  here.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::OpenStorage(
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
            /* [in] */ DWORD grfMode,
            /* [unique][in] */ SNB snbExclude,
            /* [in] */ DWORD reserved,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg)
{
    HRESULT hr = S_OK;

    propXTrace( "CNtfsStorageForPropSetStg::OpenStorage" );

    // Validate parameters

    hr = CExpParameterValidate::OpenStorage( pwcsName, pstgPriority, grfMode,
                                             snbExclude, reserved, ppstg );
    if( FAILED(hr) ) goto Exit;

    // We only support STGM_SHARE_EXCLUSIVE

    hr = EnforceSingle(grfMode);
    if( FAILED(hr) ) goto Exit;

    propTraceParameters(( "%ws, %p, 0x%08x, %p, 0x%x, %p",
                          pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstg ));

    // Try to open the storage

    hr = CreateOrOpenStorage( pwcsName, pstgPriority, grfMode, snbExclude,
                                 FALSE /*!fCreate*/, ppstg );
    if( FAILED(hr) ) goto Exit;

    hr = S_OK;

Exit:

    if( STG_E_FILENOTFOUND == hr )
        propSuppressExitErrors();

    return( hr );

}   // CNtfsStorageForPropSetStg::OpenStorage


//+----------------------------------------------------------------------------
//
//  CNtfsStorageForPropSetStg::CreateOrOpenStorage
//
//  Internal routine to create or open a "storage" (a docfile in an NTFS
//  stream).
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorageForPropSetStg::CreateOrOpenStorage( const OLECHAR *pwcsName,
                                                IStorage *pstgPriority,
                                                DWORD grfMode,
                                                SNB snbExclude,
                                                BOOL fCreate,
                                                IStorage **ppstg )
{
    HRESULT hr = S_OK;
    CNtfsStream * pNtfsStream = NULL;
    IStorage *    pstg = NULL;
    BOOL fCreated = FALSE;

    propITrace( "CNtfsStorageForPropSetStg::CreateOrOpenStorage" );
    propTraceParameters(( "%ws, %p, 0x%08x, %p, %d, %p",
                          pwcsName, pstgPriority, grfMode, snbExclude, fCreate, ppstg ));

    _pNtfsStorage->Lock( INFINITE );

    // Compose the stream name (prepend "Docf_" to pwcsName)

    CDocfileStreamName docfsn(pwcsName);
    const WCHAR* pwcszStreamName = docfsn;

    // Open the NTFS stream

    if( fCreate )
    {
        hr = _pNtfsStorage->CreateStream( docfsn, grfMode, 0, 0,
                                          (IStream**)&pNtfsStream );
    }
    else
    {
        hr = _pNtfsStorage->OpenStream( docfsn, NULL, grfMode, 0,
                                        (IStream**)&pNtfsStream );
    }

    if( FAILED(hr) )
        goto Exit;

    fCreated = TRUE;

    // Get the ILockBytes for the NTFS stream, and put a 
    // docfile on top of it.

    hr = CreateOrOpenStorageOnILockBytes( static_cast<ILockBytes*>(pNtfsStream),
                                          NULL, grfMode, NULL, fCreate, &pstg );
    if( FAILED(hr) ) goto Exit;

    pNtfsStream->Release();
    pNtfsStream = NULL;

    *ppstg = pstg;
    pstg = NULL;

Exit:

    if( NULL != pNtfsStream )
        pNtfsStream->Release();

    if( pstg )
        pstg->Release();

    // If we fail in the create path, we shouldn't leave behind a corrupt
    // docfile.  I.e., if NewCNtfsStream succeded but create-on-ilockbyte failed,
    // we have an empty stream which cannot be opened.

    if( FAILED(hr) && fCreate && fCreated )
        _pNtfsStorage->DestroyElement( CDocfileStreamName(pwcsName) );

    _pNtfsStorage->Unlock();

    if( STG_E_FILENOTFOUND == hr )
        propSuppressExitErrors();

    return( hr );
}

//+----------------------------------------------------------------------------
//
//  Method: CreateOrOpenStorageOnILockBytes
//
//  Given an ILockBytes, create or open a docfile.  The input grfMode is that
//  of the property set, though the docfile may be opened in a different
//  mode as appropriate.
//
//+----------------------------------------------------------------------------

HRESULT // static
CNtfsStorageForPropSetStg::CreateOrOpenStorageOnILockBytes( ILockBytes *plkb,
                                                            IStorage *pstgPriority,
                                                            DWORD grfMode,
                                                            SNB snbExclude,
                                                            BOOL fCreate,
                                                            IStorage **ppstg )
{
    HRESULT hr = S_OK;

    propITraceStatic( "CNtfsStorageForPropSetStg::CreateOrOpenStorageOnILockBytes" );
    propTraceParameters(( "%p, %p, 0x%08x, %p, %d, %p",
                          plkb, pstgPriority, grfMode, snbExclude, fCreate, ppstg ));

    // Create or open the docfile.  We use transacted mode because we guarantee that
    // NTFS property sets are always atomically updated.

    if( fCreate )
    {
        // We have to force the STGM_CREATE bit to avoid an error.  This is OK
        // (though the caller might not have set it) because we already handled
        // stgm_create/stgm_failifthere in the CreateStorage caller.

        hr = StgCreateDocfileOnILockBytes( plkb,
                                           grfMode | STGM_CREATE | STGM_TRANSACTED,
                                           0, ppstg );
    }
    else
    {
        // We only set stgm_transacted if necessary, and we only open deny_write in the
        // read-only open case.  This is so that we can allow multiple read-only/deny-write
        // root opens.

        hr = StgOpenStorageOnILockBytes( plkb, pstgPriority,
                                         grfMode & ~STGM_SHARE_MASK
                                         | (GrfModeIsWriteable(grfMode) ? STGM_SHARE_EXCLUSIVE | STGM_TRANSACTED
                                                                        : STGM_SHARE_DENY_WRITE),
                                         snbExclude, 0, ppstg );

        // STG_E_INVALIDHEADER in some paths of the above call gets converted into
        // STG_E_FILEALREADYEXISTS, which doesn't make a whole lot of sense
        // from our point of view (we already knew it existed, we wanted to open it).  So,
        // translate it back.

        if( STG_E_FILEALREADYEXISTS == hr )
            hr = STG_E_INVALIDHEADER;
    }
    if( FAILED(hr) ) goto Exit;

Exit:

    return( hr );
}



//+----------------------------------------------------------------------------
//
//  Method: CNtfsStorageForPropSetStg::CreateStream (IStorage)
//          CNtfsStorageForPropSetStg::OpenStream (IStorage)
//
//  These methods call to the CreateOrOpenStream method to do most of the
//  work.  CreateStream also needs to do extra work to handle the case where
//  a stream/storage is being created, but a storage/stream by that name
//  already exists.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::CreateStream(
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved1,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    HRESULT hr = S_OK;
    CDocfileStreamName dsName( pwcsName );  // (Name with pre-pended "Docf_")

    propXTrace( "CNtfsStorageForPropSetStg::CreateStream" );
    _pNtfsStorage->Lock( INFINITE );

    // Parameter validation

    hr = CExpParameterValidate::CreateStream( pwcsName, grfMode, reserved1,
                                              reserved2, ppstm );
    if( FAILED(hr) ) goto Exit;

    // We only support STGM_SHARE_EXCLUSIVE

    hr = EnforceSingle(grfMode);
    if( FAILED(hr) ) goto Exit;

    propTraceParameters(( "%ws, 0x%08x, %x, %x, %p",
                          pwcsName, grfMode, reserved1, reserved2, ppstm ));

    // In the underlying CNtfsStorage, we give streams and storages different
    // names (storages have a "Docf_" prefix).  So we require special
    // handling for STGM_CREATE/STGM_FAILIFTHERE.

    if( STGM_CREATE & grfMode )
    {
        hr = _pNtfsStorage->DestroyStreamElement( dsName );
        if( FAILED(hr) && STG_E_FILENOTFOUND != hr )
        {
            propDbg(( DEB_ERROR, "Couldn't destroy %ws",
                            static_cast<const WCHAR*>(dsName) ));
            goto Exit;
        }
        hr = S_OK;
    }
    else
    {
        // STGM_FAILIFTHERE
        hr = _pNtfsStorage->StreamExists( dsName );
        if( FAILED(hr) ) goto Exit;

        if( S_OK == hr )
        {
            hr = STG_E_FILEALREADYEXISTS;
            goto Exit;
        }
    }

    // Instantiate & initialize the *ppstm.

    hr = _pNtfsStorage->CreateStream( pwcsName, grfMode, 0, 0, ppstm );
    if( FAILED(hr) ) goto Exit;

Exit:

    _pNtfsStorage->Unlock();

    if( STG_E_FILEALREADYEXISTS == hr )
        propSuppressExitErrors();
    return( hr );
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::OpenStream(
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ void __RPC_FAR *reserved1,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    HRESULT hr;

    // Parameter validation
    hr = CExpParameterValidate::OpenStream( pwcsName, reserved1, grfMode,
                                            reserved2, ppstm );
    if( FAILED(hr) ) goto Exit;

    // We only support STGM_SHARE_EXCLUSIVE

    hr = EnforceSingle(grfMode);
    if( FAILED(hr) ) goto Exit;

    // Attempt to open the stream

    hr = _pNtfsStorage->OpenStream( pwcsName, NULL, grfMode, 0, ppstm );
    if( FAILED(hr) ) goto Exit;

    hr = S_OK;

Exit:
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\hntfsstm.cxx ===
//+============================================================================
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:   hntfsstg.cxx
//
//  This file provides the NFF (NTFS Flat File) IStream implementation.
//
//  History:
//      5/6/98  MikeHill
//              -   Use CoTaskMem rather than new/delete.
//
//+============================================================================

#include <pch.cxx>
#include <tstr.h>
#include "cli.hxx"
#include "expparam.hxx"

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

DECLARE_INFOLEVEL(nff)

#ifndef DEB_INFO
#define DEB_INFO  DEB_USER1
#endif


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::AddRef (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
CNtfsStream::AddRef()
{
    LONG cRefs;

    cRefs = InterlockedIncrement( &_cRefs );

    nffDebug((DEB_REFCOUNT, "CNtfsStream::AddRef(this=%x) == %d\n",
                            this, cRefs));
    return cRefs;
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Release (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
CNtfsStream::Release()
{
    ULONG ulRet = InterlockedDecrement( &_cRefs );

    if( 0 == ulRet )
    {
        RemoveSelfFromList();
        delete this;
    }
    nffDebug((DEB_REFCOUNT, "CNtfsStream::Release(this=%x) == %d\n",
                            this, ulRet));

    return( ulRet );
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::AddRef (IUnknown)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::QueryInterface(
        REFIID riid,
        void** ppv )
{
    HRESULT sc=S_OK;

#if DBG == 1
    WCHAR strIID[64];
    StringFromGUID2(riid, strIID, 64);
    nffDebug(( DEB_TRACE | DEB_REFCOUNT,
                "CNtfsStream::QueryInterface( %ws )\n", strIID ));
#endif

    NFF_VALIDATE( QueryInterface( riid, ppv ) );

    nffChk( CheckReverted() );

    if( IsEqualIID( riid, IID_IUnknown )
        ||
        IsEqualIID( riid, IID_IStream )
        ||
        IsEqualIID( riid, IID_ISequentialStream ) )
    {
        *ppv = static_cast<IStream*>(this);
        AddRef();
        return( S_OK );
    }
    else if( IsEqualIID( riid, IID_IMappedStream ))
    {
        *ppv = static_cast<IMappedStream*>(&_nffMappedStream);
        AddRef();
        return( S_OK );
    }
    else if( IsEqualIID( riid, IID_ILockBytes ))
    {
        *ppv = static_cast<ILockBytes*>(this);
        AddRef();
        return( S_OK );
    }
#if DBG == 1
    else if( IsEqualIID( riid, IID_IStorageTest ))
    {
        *ppv = static_cast<IStorageTest*>(this);
        AddRef();
        return( S_OK );
    }
#endif // #if DBG
    else
    {
        nffDebug(( DEB_TRACE | DEB_REFCOUNT,
                    "CNtfsStream::QueryInterface() Failed E_NOINTERFACE\n" ));
        return( E_NOINTERFACE );
    }

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Seek (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *puliNewPos)
{
    HRESULT sc = S_OK;
    LARGE_INTEGER liFileSize;
    LARGE_INTEGER liNewPos = { 0, 0 };

    nffDebug(( DEB_TRACE, "CNtfsStream::Seek( %x:%08x, %d, %p );\n",
                                dlibMove.HighPart, dlibMove.LowPart,
                                dwOrigin, puliNewPos ));

    NFF_VALIDATE( Seek( dlibMove, dwOrigin, puliNewPos ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    switch( dwOrigin )
    {
    case STREAM_SEEK_SET:
        liNewPos.QuadPart = dlibMove.QuadPart;
        break;

    case STREAM_SEEK_CUR:
        liNewPos.QuadPart = _liCurrentSeekPosition.QuadPart + dlibMove.QuadPart;
        break;

    case STREAM_SEEK_END:
        liFileSize.LowPart = GetFileSize( _hFile,
                                         (ULONG*)(&liFileSize.HighPart) );

        if( 0xFFFFFFFF == liFileSize.LowPart && NO_ERROR != GetLastError() )
        {
            nffChk( HRESULT_FROM_WIN32( GetLastError() ) );
        }

        liNewPos.QuadPart = liFileSize.QuadPart + dlibMove.QuadPart;
        break;

    default:
        nffChk(STG_E_INVALIDPARAMETER);
        break;
    }

    // Compatibility with Docfile.  Seeking < 0 fails.
    if( liNewPos.QuadPart < 0 )
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );

    _liCurrentSeekPosition = liNewPos;


    // If desired, give the caller the now-current seek position.
    if( NULL != puliNewPos )
        *puliNewPos = _liCurrentSeekPosition;

EH_Err:
    Unlock();
    return( sc );
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::SetSize (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::SetSize(
        ULARGE_INTEGER uliNewSize)
{
    HRESULT sc = S_OK;
    CLargeInteger liEOF;

    if ( uliNewSize.HighPart != 0 )
        nffErr(EH_Err, STG_E_INVALIDFUNCTION);

    nffDebug(( DEB_ITRACE | DEB_INFO | DEB_WRITE,
             "CNtfsStream::SetSize(%x:%x) hdl=%x, stream='%ws'\n",
             uliNewSize.QuadPart,
             _hFile,
             _pwcsName ));

    NFF_VALIDATE( SetSize( uliNewSize ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // If this stream is mapped, set the size accordingly

    if( _nffMappedStream.IsMapped() )
    {
        _nffMappedStream.SetSize( uliNewSize.LowPart, TRUE, NULL, &sc );
    }
    else
    {
        sc = SetFileSize( CULargeInteger(uliNewSize) );
    }

    if( !FAILED(sc) )
        sc = S_OK;

EH_Err:

    Unlock();
    return( sc);

}

//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::CopyTo (IStream)
//
//  There's no way of knowing what the IStream is to which we're copying, so
//  we have to assume that we might be copying to ourself.  And given that
//  assumption, we have to deal with the case that this is an overlapping
//  copy (e.g., "copy 10 bytes from offset 0 to offset 5").
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::CopyTo(
        IStream *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
    
    // Commenting out this code, because it isn't currently used and is
    // not fully tested.

    /*
    nffXTrace( "CNtfsStream::CopyTo" );

    HRESULT sc = S_OK;
    PVOID pv = NULL;
    ULONG cbRead = 0, cbWritten = 0;
    CULargeInteger cbReadTotal = 0, cbWrittenTotal = 0;
    CLargeInteger liZero = 0;
    CULargeInteger uliOriginalSourcePosition, uliOriginalDestPosition;
    CULargeInteger cbSourceSize, cbDestSize;
    ULONG cbPerCopy = 0;
    STATSTG statstg;
    CULargeInteger cbRequested = cb;
    BOOL fCopyForward;

    NFF_VALIDATE( CopyTo( pstm, cb, pcbRead, pcbWritten ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if( NULL == pstm)
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    // Determine how much we'll copy at a time.
    // As of this writing, STREAMBUFFERSIZE is 8192 bytes

    if( cbRequested > STREAMBUFFERSIZE )
        cbPerCopy = STREAMBUFFERSIZE;
    else
        cbPerCopy = cbRequested.LowPart;

    //  ------------------------------------------------------------------
    //  Get the current stream sizes/positions, and adjust the destination
    //  size if necessary
    //  ------------------------------------------------------------------

    nffChk( this->Seek( liZero, STREAM_SEEK_CUR, &uliOriginalSourcePosition ) );

    nffChk( pstm->Seek( liZero, STREAM_SEEK_CUR, &uliOriginalDestPosition ) );

    nffChk( this->Stat( &statstg, STATFLAG_NONAME ) );

    cbSourceSize = statstg.cbSize;

    nffChk( pstm->Stat( &statstg, STATFLAG_NONAME ) );

    cbDestSize = statstg.cbSize;

    // Ensure the sizes are valid (we can't handle anything with the high bit
    // set, because Seek takes a signed offset).

    if( static_cast<CLargeInteger>(cbSourceSize) < 0
        ||
        static_cast<CLargeInteger>(cbDestSize) < 0 )
    {
        nffErr( EH_Err, STG_E_INVALIDHEADER );
    }

    // Don't copy more than the source stream has available
    if( cbRequested > cbSourceSize - uliOriginalSourcePosition )
        cbRequested = cbSourceSize - uliOriginalSourcePosition;

    // If necessary, grow the destination stream.

    if( cbSourceSize - uliOriginalSourcePosition > cbDestSize - uliOriginalDestPosition )
    {
        cbDestSize = cbSourceSize - uliOriginalSourcePosition + uliOriginalDestPosition;
        nffChk( pstm->SetSize( cbDestSize ) );
    }

    //  ----------------------
    //  Allocate a copy buffer
    //  ----------------------

    nffMem( pv = CoTaskMemAlloc( cbPerCopy ) );

    //  -----------------------------------------------------------------------------
    //  Determine if we're copying forwards (high seek position to low) or backwards.
    //  -----------------------------------------------------------------------------

    fCopyForward = TRUE;
    if( uliOriginalSourcePosition < uliOriginalDestPosition )
    {
        // E.g., say we're copying 15 bytes from offset 0 to offset 5,
        // and we're only able to copy 10 bytes at a time.
        // If we copy bytes 0-9 to offset 5, we'll end up overwriting
        // bytes 10-14, and be unable to complete the copy.
        // So instead, we'll copy bytes 5-14 to offset 10, and finish
        // up by copying bytes 0-4 to offset 5.

        fCopyForward = FALSE;

        // To do this kind of backwards copy, we need to start by seeking
        // towards the end of the stream.

        CULargeInteger uliNewSourcePosition, uliNewDestPosition;

        uliNewSourcePosition = cbSourceSize - cbPerCopy;
        nffChk( this->Seek( uliNewSourcePosition, STREAM_SEEK_SET, NULL ) );

        uliNewDestPosition = cbDestSize - cbPerCopy;
        nffChk( pstm->Seek( uliNewDestPosition, STREAM_SEEK_SET, NULL ) );

    }

    //  --------------
    //  Copy in chunks
    //  --------------

    cbPerCopy = cbRequested > cbPerCopy ? cbPerCopy : cbRequested.LowPart;
    while( cbRequested > 0 )
    {
        // Read from the source
        nffChk( this->Read( pv, cbPerCopy, &cbRead ) );

        if( cbRead != cbPerCopy )
            nffErr(EH_Err, STG_E_READFAULT);

        cbReadTotal += cbRead;

        // Write to the dest
        nffChk( pstm->Write( pv, cbPerCopy, &cbWritten ) );

        if( cbWritten != cbPerCopy )
            nffErr( EH_Err, STG_E_WRITEFAULT );

        cbWrittenTotal += cbWritten;

        // Adjust the amount remaining to be copied
        cbRequested -= cbPerCopy;


        // Determine how much to copy in the next iteration (this will
        // always be cbPerCopy until the last iteration).  If copying
        // backwards, we need to manually adjust the seek pointer.

        cbPerCopy = (cbRequested > cbPerCopy) ? cbPerCopy : cbRequested.LowPart;
        if( !fCopyForward )
        {
            nffChk( this->Seek( -static_cast<CLargeInteger>(cbPerCopy),
                                                STREAM_SEEK_CUR, NULL ) );

            nffChk( pstm->Seek( -static_cast<CLargeInteger>(cbPerCopy),
                                                STREAM_SEEK_CUR, NULL ) );
        }

    }

    // If we were backward-copying, adjust the seek pointers
    // as if we had forward-copied

    if( !fCopyForward )
    {
        uliOriginalSourcePosition += cbReadTotal;
        nffChk( this->Seek( uliOriginalSourcePosition, STREAM_SEEK_SET, NULL ) );

        uliOriginalDestPosition += cbWrittenTotal;
        nffChk( pstm->Seek( uliOriginalDestPosition, STREAM_SEEK_SET, NULL ) );
    }

    //  ----
    //  Exit
    //  ----

    if( NULL != pcbRead )
        *pcbRead = cbReadTotal;
    if( NULL != pcbWritten )
        *pcbWritten = cbWrittenTotal;

EH_Err:

    if( NULL != pv )
        CoTaskMemFree(pv);

    Unlock();
    return(sc);
*/

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Commit (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Commit( DWORD grfCommitFlags )
{
    nffXTrace( "CNtfsStream::Commit" );
    HRESULT sc = S_OK;

    NFF_VALIDATE( Commit( grfCommitFlags ) );
    if(~(STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE|STGC_DEFAULT) & grfCommitFlags)
        nffErr( EH_Err, STG_E_INVALIDFLAG );

    Lock( INFINITE );

    nffChkTo ( EH_Unlock, CheckReverted() );

    if( !(STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE  & grfCommitFlags) )
    {
        if( !FlushFileBuffers( _hFile ))
            sc = LAST_SCODE;
    }

EH_Unlock:
    Unlock();
EH_Err:
    return sc;

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Revert (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Revert(void)
{
    nffXTrace( "CNtfsStream::Revert" );
    // We only support direct-mode.

    return CheckReverted();
}



//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::LockRegion (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    nffXTrace( "CNtfsStream::LockRegion" );
    HRESULT sc = S_OK;

    NFF_VALIDATE( LockRegion( libOffset, cb, dwLockType ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );


    if( !LockFile( _hFile, libOffset.LowPart, libOffset.HighPart,
                   cb.LowPart, cb.HighPart))
    {
        nffErr( EH_Err, LAST_SCODE );
    }

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::UnlockRegion (ILockBytes)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    nffXTrace( "CNtfsStream::UnlockRegion" );
    HRESULT sc = S_OK;

    NFF_VALIDATE( UnlockRegion( libOffset, cb, dwLockType ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
    {
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );
    }

    if( !UnlockFile(_hFile, libOffset.LowPart, libOffset.HighPart,
                    cb.LowPart, cb.HighPart))
    {
        nffErr( EH_Err, LAST_SCODE );
    }

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Stat (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Stat(
        STATSTG *pstatstg,
        DWORD grfStatFlag)
{
    nffXTrace( "CNtfsStream::Stat" );
    STATSTG statstg;
    HRESULT sc = S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    FILE_ACCESS_INFORMATION file_access_information;
    IO_STATUS_BLOCK IoStatusBlock;

    BY_HANDLE_FILE_INFORMATION ByHandleFileInformation;

    NFF_VALIDATE( Stat( pstatstg, grfStatFlag ) );

    Lock( INFINITE );

    nffChkTo ( EH_Lock, CheckReverted() );

    ZeroMemory((void*)&statstg, sizeof(STATSTG));

    // Get the name, if desired

    if( (STATFLAG_NONAME & grfStatFlag) )
        statstg.pwcsName = NULL;
    else
    {
        nffAssert( NULL != _pwcsName );
        
        ULONG cbName = sizeof(WCHAR)*((ULONG)wcslen(_pwcsName) + 1);
        nffMem( statstg.pwcsName = reinterpret_cast<WCHAR*>
                                   ( CoTaskMemAlloc( cbName )));
        StringCbCopy( statstg.pwcsName, cbName, _pwcsName );
    }

    // Get the type
    statstg.type = STGTY_STREAM;

    statstg.grfLocksSupported = LOCK_EXCLUSIVE | LOCK_ONLYONCE;

    // Get the size & times.

    if( !GetFileInformationByHandle( _hFile, &ByHandleFileInformation ))
        nffErr( EH_Err, LAST_SCODE );

    statstg.cbSize.LowPart = ByHandleFileInformation.nFileSizeLow;
    statstg.cbSize.HighPart = ByHandleFileInformation.nFileSizeHigh;

    // We get a time back in ByHandleFileInformation, but it's the file's times,
    // not the streams times.  So really the stream times are not supported, and
    // we'll just set them to zero.

    statstg.mtime = statstg.atime = statstg.ctime = CFILETIME(0);

    // Get the STGM modes
    statstg.grfMode = _grfMode & ~STGM_CREATE;

    *pstatstg = statstg;

EH_Err:
    if( FAILED(sc) && NULL != statstg.pwcsName )
        CoTaskMemFree( statstg.pwcsName );

EH_Lock:
    Unlock();
    return( sc );

}



//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Clone (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Clone(
        IStream** ppstm)
{
    nffXTrace( "CNtfsStream::Clone" );
    return( E_NOTIMPL );
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Read (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Read(
        void* pv,
        ULONG cb,
        ULONG* pcbRead)
{
    nffXTrace( "CNtfsStream::Read" );
    HRESULT sc = S_OK;
    ULONG cbRead = 0;

    nffDebug(( DEB_ITRACE, "Read( pv=0x%x, cb=0x%x );\n", pv, cb ));

    NFF_VALIDATE( Read( pv, cb, pcbRead ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    nffChk( ReadAt( _liCurrentSeekPosition, pv, cb, &cbRead ) );

    _liCurrentSeekPosition += cbRead;
    nffDebug(( DEB_ITRACE, "Read() read %x bytes.\n", cbRead ));
    if( NULL != pcbRead )
        *pcbRead = cbRead;

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::ReadAt (ILockBytes)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::ReadAt(
       ULARGE_INTEGER ulOffset,
       void* pv,
       ULONG cb,
       ULONG* pcbRead)
{
    nffXTrace( "CNtfsStream::ReadAt" );
    HRESULT sc = S_OK;

    nffDebug(( DEB_ITRACE, "ReadAt( off=%x:%x, pv=0x%x, cb=0x%x );\n",
                        ulOffset, pv, cb ));

    NFF_VALIDATE( ReadAt( ulOffset, pv, cb, pcbRead ) );

    if( static_cast<LONG>(ulOffset.HighPart) < 0 )
        return TYPE_E_SIZETOOBIG;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // Is this stream mapped?
    if( _nffMappedStream.IsMapped() )
    {
        // This stream is mapped.  We'll read directly from the mapping buffer.
        _nffMappedStream.Read( pv, ulOffset.LowPart, &cb );

        if( NULL != pcbRead )
            *pcbRead = cb;
    }
    else
    {
        // No, just read from the file.

        nffChk( SyncReadAtFile( ulOffset, pv, cb, pcbRead ) );
    }

    nffDebug(( DEB_ITRACE, "ReadAt() read %x bytes.\n",
                      NULL == pcbRead ? -1 : *pcbRead ));


EH_Err:
    Unlock();
    return( sc );
}




//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Write (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Write(
        const void* pv,
        ULONG cb,
        ULONG* pcbWritten)
{
    nffXTrace( "CNtfsStream::Write" );
    HRESULT sc = S_OK;
    ULONG cbWritten = 0;

    nffDebug(( DEB_ITRACE, "Write( pv=0x%x, cb=0x%x );\n", pv, cb ));

    NFF_VALIDATE( Write( pv, cb, pcbWritten ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    nffChk(WriteAt( _liCurrentSeekPosition, pv, cb, &cbWritten ));

    _liCurrentSeekPosition += cbWritten;

    nffDebug(( DEB_ITRACE, "Write() wrote %x bytes.\n", cbWritten ));

    if( NULL != pcbWritten )
        *pcbWritten = cbWritten;

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::WriteAt (ILockBytes)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::WriteAt(
     ULARGE_INTEGER ulOffset,
     const void* pv,
     ULONG cb,
     ULONG* pcbWritten)
{
    nffXTrace( "CNtfsStream::WriteAt" );
    HRESULT sc = S_OK;

    nffDebug(( DEB_ITRACE, "WriteAt( off=%x:%x, pv=0x%x, cb=0x%x );\n",
                        ulOffset, pv, cb ));

    NFF_VALIDATE( WriteAt( ulOffset, pv, cb, pcbWritten ) );

    if( ((LONG)(ulOffset.HighPart)) < 0 )
        return( TYPE_E_SIZETOOBIG );


    Lock( INFINITE );

    nffChk( CheckReverted() );

    // Is this stream mapped?
    if( _nffMappedStream.IsMapped() )
    {
        // This stream is mapped, we'll take the Write to the mapping.

        ULONG iPosition = _nffMappedStream.SizeOfMapping() - _liCurrentSeekPosition.LowPart;

        if( cb > iPosition )
        {
            _nffMappedStream.SetSize( iPosition + cb, TRUE, NULL, &sc );
            nffChk(sc);
        }

        _nffMappedStream.Write( pv, ulOffset.LowPart, &cb );

        if( NULL != pcbWritten )
            *pcbWritten = cb;
    }
    else
    {
        // No, just write to the file.

        nffChk( SyncWriteAtFile( ulOffset, pv, cb, pcbWritten ) );
    }

    nffDebug(( DEB_ITRACE, "WriteAt() wrote %x bytes.\n",
                      NULL == pcbWritten ? -1 : *pcbWritten ));


EH_Err:

    Unlock();
    return( sc );

}



//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStream::Flush
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Flush()
{
    HRESULT sc = S_OK;

    Lock( INFINITE );
    nffChk( CheckReverted() );

    _nffMappedStream.Flush(&sc);

EH_Err:
    Unlock();
    return(sc);

}


//+-------------------------------------------------------------------
//
//  Member:     CNtfsStream  Constructor
//
//--------------------------------------------------------------------

CNtfsStream::CNtfsStream( CNtfsStorage *pnffstg,
                          IBlockingLock *pBlockingLock )
#pragma warning(disable: 4355)
                : _nffMappedStream( this ),
#pragma warning(default: 4355)
                  _pnffstg( pnffstg )
{
    nffXTrace( "CNtfsStream::CNtfsStream" );
    nffDebug(( DEB_REFCOUNT, "new CNtfsStream Constructed with cRefs=1\n" ));

    _sig = NTFSSTREAM_SIG;
    _cRefs = 1;
    _grfMode = 0;
    _hFile = INVALID_HANDLE_VALUE;
    _liCurrentSeekPosition = 0;
    _pnffstmNext = NULL;
    _pnffstmPrev = NULL;
    _pwcsName = NULL;

    nffAssert( NULL != pBlockingLock );
    _pBlockingLock = pBlockingLock;
    _pBlockingLock->AddRef();

    _ovlp.Internal = _ovlp.InternalHigh = 0;
    _ovlp.Offset = _ovlp.OffsetHigh = 0;
    _ovlp.hEvent = NULL;

}


//+-------------------------------------------------------------------
//
//  Member:     CNtfsStream  Destructor
//
//--------------------------------------------------------------------

CNtfsStream::~CNtfsStream()
{

    nffXTrace( "CNtfsStream::~CNtfsStream" );
    nffDebug(( DEB_INFO, "CNtfsStream: Close 0x%x.\n", _hFile ));

    // Shut down the mapped stream
    _nffMappedStream.ShutDown();

    // Close the file
    if( INVALID_HANDLE_VALUE != _hFile )
        NtClose( _hFile );

    if( NULL != _ovlp.hEvent )
        CloseHandle( _ovlp.hEvent );

    if( NULL != _pwcsName )
        CoTaskMemFree( _pwcsName );

    // Release the object that provides access to the tree lock.
    nffAssert( NULL != _pBlockingLock );
    _pBlockingLock->Release();

    _sig = NTFSSTREAM_SIGDEL;
}


//+-------------------------------------------------------------------
//
//  Member:     CNtfsStream::Init
//
//--------------------------------------------------------------------

HRESULT
CNtfsStream::Init(
        HANDLE hFile,               // File handle of this NTFS Stream.
        DWORD grfMode,              // Open Modes
        const OLECHAR * pwcsName,   // Name of the Stream
        CNtfsStream *pnffstm)       // Previously Open NTFS Stream (list)
{
    HRESULT sc=S_OK;
    HANDLE ev;

    nffITrace( "CNtfsStream::Init" );

    // We now own this file handle, and are responsible for closing it.
    _hFile = hFile;

    // Save the STGM_ flags so we can return them in a Stat call.
    _grfMode = grfMode;

    // Save the stream name

    if( NULL != _pwcsName )
    {
        CoTaskMemFree( _pwcsName );
        _pwcsName = NULL;
    }

    if( NULL != pwcsName )
    {
        ULONG cbName = sizeof(WCHAR)*((ULONG)wcslen(pwcsName) + 1);
        nffMem( _pwcsName = reinterpret_cast<WCHAR*>
                            ( CoTaskMemAlloc( cbName )));
        StringCbCopy( _pwcsName, cbName, pwcsName );
    }

    // All the streams live on a list held by the root Storage.
    if(NULL != pnffstm)
        InsertSelfIntoList(pnffstm);

    nffChk( _nffMappedStream.Init( _hFile ));

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStream    Non-Interface::ShutDown
//
//  Flush data, Close File handle and mark the object as reverted.
//  This is called when the Storage is released and when the Oplock Breaks.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::ShutDown()
{
    nffITrace( "CNtfsStream::ShutDown" );
    HRESULT sc=S_OK;

    if( INVALID_HANDLE_VALUE == _hFile )
        return S_OK;

    nffDebug(( DEB_INFO, "CNtfsStream::ShutDown(%x)\n", _hFile ));

    //
    // Shut down the mapped stream
    //
    _nffMappedStream.ShutDown();

    //
    // Close the file/stream handle and mark the IStream object as
    // Reverted by giving the file handle an invalid value.
    //
    CloseHandle(_hFile);
    _hFile = INVALID_HANDLE_VALUE;

    // We don't need the parent CNtfsStorage any longer, and more importantly it could
    // be going away.
    _pnffstg = NULL;

    //
    // Remove IStream object from the Storage's list
    //
    RemoveSelfFromList();

    return S_OK;
}




//+----------------------------------------------------------------------------
//
//  CNtfsStream Non-Interface::Rename
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Rename(
        const WCHAR *pwcsName,
        BOOL fOverWrite )
{
    IO_STATUS_BLOCK io_status_block;
    PFILE_RENAME_INFORMATION pFileRenInfo=NULL;     // _alloca()'ed
    NTSTATUS status;

    CNtfsStreamName nsnName = pwcsName;     // Convert to ":name:$DATA"

    LONG cbBufSize=0;
    HRESULT sc=S_OK;


    nffDebug(( DEB_INFO | DEB_WRITE, "CNtfsStream::Rename(%ws -> %ws)\n",
               _pwcsName, pwcsName ));

    Lock( INFINITE );
    nffChk( CheckReverted() );

    // Size and allocate a FILE_RENAME_INFOMATION buffer.  The size argument
    // to NtSetInformationFile must be correct, so subtract 1 WCHAR for the
    // FileName[1] in the struct we are not using.
    //
    cbBufSize  = sizeof(FILE_RENAME_INFORMATION) - sizeof(WCHAR);
    cbBufSize += (ULONG)nsnName.Count() * sizeof(WCHAR);
    __try
    {
        pFileRenInfo = (PFILE_RENAME_INFORMATION) _alloca( cbBufSize );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        nffErr(EH_Err, STG_E_INSUFFICIENTMEMORY);
    }

    // Load the FILE_RENAME_INFORMATION structure

    pFileRenInfo->ReplaceIfExists = (BOOLEAN) fOverWrite;
    pFileRenInfo->RootDirectory = NULL;
    pFileRenInfo->FileNameLength = (ULONG)nsnName.Count() * sizeof(WCHAR);
    memcpy( pFileRenInfo->FileName,
            (const WCHAR*)nsnName,
            pFileRenInfo->FileNameLength );

    // Rename the stream

    status = NtSetInformationFile( _hFile,
                                   &io_status_block,
                                   pFileRenInfo,
                                   cbBufSize,
                                   FileRenameInformation );
    if( !NT_SUCCESS(status) )
    {
        nffChk( sc = NtStatusToScode(status) );
    }

    // Discard the old name and Save the new name

    CoTaskMemFree( _pwcsName );

    // reuse cbBufSize
    cbBufSize = sizeof(WCHAR)  * ((ULONG)wcslen(pwcsName)+1);

    nffMem( _pwcsName = (WCHAR*) CoTaskMemAlloc( cbBufSize ));
    StringCbCopy( _pwcsName, cbBufSize, pwcsName );

    sc = S_OK;

EH_Err:

    Unlock();
    return( sc );

}



//+----------------------------------------------------------------------------
//
//  CNtfsStream Non-Interface::Delete
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::Delete()
{
    HRESULT sc=S_OK;

    nffDebug(( DEB_INFO | DEB_WRITE, "Delete(stm=%ws)\n", _pwcsName ));

    nffChk( CheckReverted() );

    if( IsWriteable() )
        nffChk( DeleteStream( &_hFile ));

EH_Err:

    return( sc );

}



//+----------------------------------------------------------------------------
//
//  CNtfsStream Non-Interface::DeleteStream
//
//  This method is static so that it can be called globally.
//
//+----------------------------------------------------------------------------

HRESULT // static
CNtfsStream::DeleteStream( HANDLE *phStream )
{
    HRESULT sc=S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    FILE_DISPOSITION_INFORMATION Disposition;
    IO_STATUS_BLOCK IoStatusBlock;

    // Execute the following statement:
    //    Disposition.DeleteFile = TRUE;
    // We can't actually write the code that way, because "DeleteFile" is #defined to
    // "DeleteFileW".

    nffDebug(( DEB_INFO | DEB_WRITE, "DeleteStream(hdl=%x)\n", *phStream ));

    *reinterpret_cast<BOOLEAN*>(&Disposition) = TRUE;
    DfpAssert( sizeof(Disposition) == sizeof(BOOLEAN) );

    // Mark the file for delete on close
    // Note that if this is the Contents stream we can delete it successfully,
    // but NTFS actually just truncates it to zero length.

    status = NtSetInformationFile(
                  *phStream,
                  &IoStatusBlock,
                  &Disposition,
                  sizeof(Disposition),
                  FileDispositionInformation
                  );
    if( !NT_SUCCESS(status) )
    {
        nffErr( EH_Err, NtStatusToScode(status) );
    }

    NtClose( *phStream );
    *phStream = INVALID_HANDLE_VALUE;

EH_Err:

    return( sc );

}

//+----------------------------------------------------------------------------
//
//  CNtfsStream::SetFileSize (private, non-interface method)
//
//  Set the size of the _hFile.  This is used by the IStream & IMappedStream
//  SetSize methods
//
//+----------------------------------------------------------------------------

HRESULT // private
CNtfsStream::SetFileSize( const CULargeInteger &uliNewSize )
{
    nffITrace( "CNtfsStream::SetFileSize" );
    HRESULT sc = S_OK;
    CLargeInteger liEOF;

    // We have to convert uliNewSize into a LARGE_INTEGER, so ensure that it can
    // be cast without loss of data.

    liEOF = static_cast<CLargeInteger>(uliNewSize);
    if( liEOF < 0 )
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    // Move to what will be the new end-of-file position.

    liEOF.LowPart = SetFilePointer( _hFile, liEOF.LowPart,
                                    &liEOF.HighPart, FILE_BEGIN );
    if( 0xFFFFFFFF == liEOF.LowPart && NO_ERROR != GetLastError() )
        nffErr( EH_Err, LAST_SCODE );

    // Set this as the new eof

    if( !SetEndOfFile( _hFile ))
        nffErr( EH_Err, LAST_SCODE );

EH_Err:

    return( sc );

}


//+-------------------------------------------------------------------
//
//  Member:     CNtfsStream::InsertSelfIntoList/RemoveSelfFromList
//
//--------------------------------------------------------------------

// We are passed a "current" element of a doubly linked list.
// Insert "this" right after the given List element.
//
VOID
CNtfsStream::InsertSelfIntoList(CNtfsStream *pnffstmCurrent)
{
    nffDebug(( DEB_ITRACE, "CNtfsStream::InsertSelfIntoList this=%x\n", this ));

    // If we're already in the list, or there is no list, then we're done.
    if( NULL != _pnffstmNext || NULL == pnffstmCurrent )
        return;

	// Note that this lock takes the tree mutex - it locks the whole
	// storage
	Lock( INFINITE );

    // "this" point back to the current element
    // and points forward to current's next element
    _pnffstmPrev = pnffstmCurrent;
    _pnffstmNext = pnffstmCurrent->_pnffstmNext;

    // the current element now points forward to "this"
    // and if the next is not NULL it points back at this.
    pnffstmCurrent->_pnffstmNext = this;
    if(NULL != _pnffstmNext)
        _pnffstmNext->_pnffstmPrev = this;

	Unlock();
}

VOID
CNtfsStream::RemoveSelfFromList()
{
    nffDebug(( DEB_ITRACE, "CNtfsStream::RemoveSelfFromList this=%x\n", this ));

	// Note that this lock takes the tree mutex - it locks the whole
	// storage
	Lock( INFINITE );

    // My next element's previous pointer is given my previous pointer.
    if(NULL != _pnffstmNext)
        _pnffstmNext->_pnffstmPrev = _pnffstmPrev;

    // My previous element's next pointer is given my next pointer.
    if(NULL != _pnffstmPrev)
        _pnffstmPrev->_pnffstmNext = _pnffstmNext;

    _pnffstmNext = NULL;
    _pnffstmPrev = NULL;

	Unlock();
}


//+-------------------------------------------------------------------
//
//  CNtfsStream     Non-Interface::SyncReadAtFile
//
//  Synopsis:       Provide synchronous IO for a file handle open in
//                  asynchronous mode.
//
//--------------------------------------------------------------------

HRESULT
CNtfsStream::SyncReadAtFile(
        ULARGE_INTEGER ulOffset,
        PVOID  pv,
        ULONG  cb,
        PULONG pcbRead)
{
    HRESULT sc=S_OK;
    LONG err=ERROR_SUCCESS;
    //
    // We use the single OVERLAPPED structure in the object.
    // This saves us from creating an Event everytime.  We
    // require the TreeMutex will keep us single threaded.
    //
    _ovlp.Offset = ulOffset.LowPart;
    _ovlp.OffsetHigh = ulOffset.HighPart;

    nffDebug(( DEB_ITRACE | DEB_INFO | DEB_READ,
             "SyncReadAtFile(_hFile=0x%x off=%x:%x, pv=0x%x, cb=0x%x )"
             " stream='%ws'\n",
             _hFile, ulOffset.HighPart, ulOffset.LowPart,
             pv, cb, _pwcsName ));

    if( !ReadFile( _hFile, pv, cb, pcbRead, &_ovlp ) )
    {
        err = GetLastError();

        if(ERROR_SUCCESS != err && ERROR_HANDLE_EOF != err)
            nffChk( HRESULT_FROM_WIN32( err ) );
    }


    nffDebug(( DEB_INFO, "SyncReadAtFile() read 0x%x bytes.\n", *pcbRead ));

EH_Err:
    return sc;
}


//+-------------------------------------------------------------------
//
//  CNtfsStream     Non-Interface::SyncWriteAtFile
//
//  Synopsis:       Provide synchronous IO for a file handle open in
//                  asynchronous mode.
//
//--------------------------------------------------------------------

HRESULT
CNtfsStream::SyncWriteAtFile(
        ULARGE_INTEGER ulOffset,
        const void *pv,
        ULONG cb,
        PULONG pcbWritten)
{
    HRESULT sc=S_OK;
    //
    // We use the single OVERLAPPED structure in the object.
    // We require the TreeMutex will keep us single threaded.
    //
    _ovlp.Offset = ulOffset.LowPart;
    _ovlp.OffsetHigh = ulOffset.HighPart;

    nffDebug(( DEB_ITRACE | DEB_INFO | DEB_WRITE,
             "SyncWriteAtFile(_hFile=0x%x, off=%x:%x, pv=0x%x, cb=0x%x );"
             " stream='%ws'\n",
             _hFile, ulOffset.HighPart, ulOffset.LowPart,
             pv, cb, _pwcsName ));

    //
    // We expect either OK or FALSE/ERROR_IO_PENDING.
    //
    if( !WriteFile( _hFile, pv, cb, pcbWritten, &_ovlp ) )
    {
        nffChk( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    nffDebug(( DEB_ITRACE | DEB_INFO,
             "SyncWriteAtFile() wrote 0x%x bytes.\n", *pcbWritten ));

EH_Err:
    return sc;
}

//+----------------------------------------------------------------------------
//
//  CNtfsStream    Non-Interface::SetStreamTime
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::SetStreamTime( const FILETIME* pctime,
                            const FILETIME* patime,
                            const FILETIME* pmtime)
{
    nffDebug((DEB_INFO | DEB_STATCTRL | DEB_ITRACE,
              "SetStreamTime() hdl=%x, stream='%ws'\n",
              _hFile, _pwcsName ));

    return SetFileHandleTime( _hFile, pctime, patime, pmtime );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStream    Static Non-Interface::SetFileHandleTime
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStream::SetFileHandleTime( HANDLE hFile,
                            const FILETIME* pctime,
                            const FILETIME* patime,
                            const FILETIME* pmtime)
{
    HRESULT sc=S_OK;

    if( INVALID_HANDLE_VALUE == hFile )
    {
        nffDebug(( DEB_IWARN, "CNtfsStream::SetFileHandleTime on hFile == -1\n" ));
        return S_OK;
    }

    nffDebug(( DEB_STATCTRL | DEB_ITRACE,
               "SetFileHandleTime(%p %p %p) hdl=%x\n",
               pctime, patime, pmtime, hFile ));

    nffBool( ::SetFileTime( hFile, pctime, patime, pmtime ) );
EH_Err:
    return sc;
}


#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStream::UseNTFS4Streams( BOOL fUseNTFS4Streams )
{
    return( _nffMappedStream.UseNTFS4Streams( fUseNTFS4Streams ));
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStream::GetFormatVersion(WORD *pw)
{
    return( E_NOTIMPL );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStream::SimulateLowMemory( BOOL fSimulate )
{
    return( _nffMappedStream.SimulateLowMemory( fSimulate ));
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStream::GetLockCount()
{
    return( NULL == _pnffstg ? 0 : _pnffstg->GetLockCount() );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStream::IsDirty()
{
    return( E_NOTIMPL );
}
#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\bag.cxx ===
//+============================================================================
//
//  File:   bag.cxx
//
//          This file implements the IPropertyBagEx implementation used
//          in docfile, NSS (Native Structured Storage) and NFF (NTFS
//          Flat-File).  IPropertyBagEx is required to be QI-able
//          from IStorage, so CPropertyBagEx is instantiated as a 
//          data member of the various IStorage implementations.
//
//  History:
//
//      3/10/98  MikeHill   - Don't create a property set until the bag
//                            is modified
//                          - Add a constructor & IUnknown so that this class can
//                            be instantiated standalone (used by
//                            StgCreate/OpenStorageOnHandle).
//                          - Added dbg tracing.
//                          - Removed Commit-after-writes.
//                          - Chagned from STATPROPS structure to STATPROPBAG.
//                          - Added parameter validation.
//                          - Added a ShutDown method.
//      5/6/98  MikeHill
//              -   Split IPropertyBag from IPropertyBagEx, new BagEx
//                  DeleteMultiple method.
//              -   Added support for VT_UNKNOWN/VT_DISPATCH.
//              -   Beefed up dbg outs.
//              -   Use CoTaskMem rather than new/delete.
//      5/18/98 MikeHill
//              -   Moved some initialization from the constructors
//                  to a new Init method.
//              -   Disallow non-Variant types in IPropertyBag::Write.
//      6/11/98 MikeHill
//              -   Add the new reserved parameter to DeleteMultiple.
//
//+============================================================================                          


#include <pch.cxx>
#include "chgtype.hxx"

#define FORCE_EXCLUSIVE(g) ((g & ~STGM_SHARE_MASK) | STGM_SHARE_EXCLUSIVE)
//
// Add this prototype to chgtype.hxx when chgtype.hxx is finalized.
//
HRESULT ImplicitPropVariantToVariantChangeType(
                    PROPVARIANT *pDest,
                    const PROPVARIANT *pSrc,
                    LCID lcid );

HRESULT HrPropVarVECTORToSAFEARRAY(
                    PROPVARIANT *pDest,
                    const PROPVARIANT *pSrc,
                    LCID lcid,
                    VARTYPE vtCoerce );

HRESULT LoadPropVariantFromVectorElem(
                    PROPVARIANT *pDest,
                    const PROPVARIANT *pSrc,
                    int idx);

HRESULT PutPropVariantDataIntoSafeArray(
                    SAFEARRAY *psa,
                    const PROPVARIANT *pSrc,
                    int idx);

//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx
//
//+----------------------------------------------------------------------------

// Normal constructor
CPropertyBagEx::CPropertyBagEx( DWORD grfMode )
{
    HRESULT hr = S_OK;
    propITrace( "CPropertyBagEx::CPropertyBagEx(IPropertySetStorage)" );
    propTraceParameters(( "0x%x", grfMode ));

    // mask out the stgm_transacted bit; the bag is 
    // interpreted as part of the parent storage, and should therefore
    // be in the storage's transaction set.

    _grfMode = grfMode & ~STGM_TRANSACTED;
    _lcid = LOCALE_NEUTRAL;
    _fLcidInitialized = FALSE;

    _ppropstg = NULL;
    _ppropsetstgContainer = NULL;
    _pBlockingLock = NULL;

    // We won't use this ref-count, we'll rely on _ppropsetstgContainer
    _cRefs = 0;

}   // CPropertyBagEx::CPropertyBagEx(grfMode)

// Constructor for building an IPropertyBagEx on an IPropertyStorage
CPropertyBagEx::CPropertyBagEx( DWORD grfMode,
                                IPropertyStorage *ppropstg,
                                IBlockingLock *pBlockingLock )
{
    HRESULT hr = S_OK;
    propITrace( "CPropertyBagEx::CPropertyBagEx(IPropertyStorage)" );
    propTraceParameters(( "0x%x, 0x%x", ppropstg, pBlockingLock ));

    new(this) CPropertyBagEx( grfMode );

    Init (NULL, pBlockingLock);

    // We addref and keep the IPropertyStorage
    _ppropstg = ppropstg;
    _ppropstg->AddRef();

    // We keep and addref the BlockingLock
    _pBlockingLock->AddRef();

    // We also keep our own ref-count
    _cRefs = 1;

}   // CPropertyBagEx::CPropertyBagEx(grfMode, IPropertyStorage*, IBlockingLock*)


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::Init (non-interface method)
//
//  This method is used by the caller to provide the IPropertySetStorage
//  (and IBlockingLock) that is to contain the property bag.
//  This must be called after the simple grfMode-based constructor.
//
//  This method does *not* addref these interfaces.
//
//+----------------------------------------------------------------------------

void
CPropertyBagEx::Init( IPropertySetStorage *ppropsetstg, IBlockingLock *pBlockingLock )
{
    DfpAssert( NULL == _ppropsetstgContainer
               &&
               NULL == _pBlockingLock
               &&
               NULL == _ppropstg );

    _ppropsetstgContainer = ppropsetstg;
    _pBlockingLock = pBlockingLock;

}


//+----------------------------------------------------------------------------
//
//  Method: ~CPropertyBagEx
//
//+----------------------------------------------------------------------------

CPropertyBagEx::~CPropertyBagEx()
{
#if DBG
    IStorageTest *ptest = NULL;
    HRESULT hr = S_OK;

    if( NULL != _ppropstg )
    {
        hr = _ppropstg->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&ptest) );
        if( SUCCEEDED(hr) )
        {
            hr = ptest->IsDirty();
            DfpAssert( S_FALSE == hr || E_NOINTERFACE == hr );
            RELEASE_INTERFACE(ptest);
        }
    }
#endif // #if DBG

    ShutDown();
}



//+----------------------------------------------------------------------------
//
//  Method: OpenPropStg
//
//  Open the bag's IPropertyStorage.  If FILE_OPEN_IF is specified, we open
//  it only if it already exists.  if FILE_OPEN is specified, we'll create it
//  if necessary.
//
//+----------------------------------------------------------------------------


HRESULT
CPropertyBagEx::OpenPropStg( DWORD dwDisposition )
{
    HRESULT hr = S_OK;
    IPropertyStorage *ppropstg = NULL;
    PROPVARIANT propvarCodePage;
    PROPSPEC    propspecCodePage;
    STATPROPSETSTG statpropsetstg;

    propITrace( "CPropertyBagEx::OpenPropStg" );
    propTraceParameters(( "%s", FILE_OPEN_IF == dwDisposition
                                    ? "OpenIf"
                                    : (FILE_OPEN == dwDisposition ? "Open" : "Unknown disposition")
                          ));

    DfpAssert( FILE_OPEN == dwDisposition || FILE_OPEN_IF == dwDisposition );
    PropVariantInit( &propvarCodePage );

    // Does the IPropertyStorage need to be opened?

    if( NULL == _ppropstg )
    {
        // Ensure we have a _ppropsetstgContainer
        if( NULL == _ppropsetstgContainer )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INTERNAL_ERROR );
            goto Exit;
        }

        // Try to open the property storage
        // We have to open exclusive, no matter how the parent was opened.

        hr = _ppropsetstgContainer->Open( FMTID_PropertyBag,
                                          FORCE_EXCLUSIVE(_grfMode) & ~STGM_CREATE,
                                          &ppropstg );

        if( STG_E_FILENOTFOUND == hr && FILE_OPEN == dwDisposition )
        {
            // It didn't exist, and we're supposed to remedy that.
            hr = _ppropsetstgContainer->Create( FMTID_PropertyBag, NULL, 
                                                PROPSETFLAG_CASE_SENSITIVE | PROPSETFLAG_NONSIMPLE,
                                                FORCE_EXCLUSIVE(_grfMode) | STGM_CREATE,
                                                &ppropstg );
        }
        else if( STG_E_FILENOTFOUND == hr && FILE_OPEN_IF == dwDisposition )
        {
            // This is an expected error.
            propSuppressExitErrors();
        }

        if( FAILED(hr) ) goto Exit;

        // Verify that this is a Unicode property set

        propspecCodePage.ulKind = PRSPEC_PROPID;
        propspecCodePage.propid = PID_CODEPAGE;
        hr = ppropstg->ReadMultiple( 1, &propspecCodePage, &propvarCodePage );
        if( FAILED(hr) ) goto Exit;

        if( VT_I2 != propvarCodePage.vt
            ||
            CP_WINUNICODE != propvarCodePage.iVal )
        {
            propDbg(( DEB_ERROR, "Non-unicode codepage found in supposed property bag (0x%x)\n",
                      propvarCodePage.iVal ));
            hr = STG_E_INVALIDHEADER;
            goto Exit;
        }

        // Also verify that the property set is non-simple and case-sensitive

        hr = ppropstg->Stat( &statpropsetstg );
        if( FAILED(hr) ) goto Exit;

        if( !(PROPSETFLAG_CASE_SENSITIVE & statpropsetstg.grfFlags)
            ||
            !(PROPSETFLAG_NONSIMPLE & statpropsetstg.grfFlags) )
        {
            propDbg(( DEB_ERROR, "Supposed property bag isn't case sensitive or isn't non-simple (0x%x)\n",
                                 statpropsetstg.grfFlags ));
            hr = STG_E_INVALIDHEADER;
            goto Exit;
        }
                                        
        _ppropstg = ppropstg;
        ppropstg = NULL;
    }

    // Even if we already have an open IPropertyStorage, we may not have yet read the
    // Locale ID (this happens in the case where the CPropertyBagEx(IPropertyStorage*)
    // constructor is used).

    if( !_fLcidInitialized )
    {
        hr = GetLCID();
        if( FAILED(hr) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    DfpVerify( 0 == RELEASE_INTERFACE(ppropstg) );
    return(hr);

}   // CPropertyBagEx::OpenPropStg



//+----------------------------------------------------------------------------
//
//  Method: GetLCID
//
//  Get the LocalID from the property set represented by _ppropstg.
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::GetLCID()
{
    HRESULT hr = S_OK;
    PROPSPEC propspecLCID;
    PROPVARIANT propvarLCID;

    propITrace( "CPropertyBagEx::GetLCID" );

    propspecLCID.ulKind = PRSPEC_PROPID;
    propspecLCID.propid = PID_LOCALE;
    PropVariantInit( &propvarLCID );

    if( SUCCEEDED( hr = _ppropstg->ReadMultiple( 1, &propspecLCID, &propvarLCID ))
        &&
        VT_UI4 == propvarLCID.vt )
    {
        _lcid = propvarLCID.uiVal;
    }
    else if( S_FALSE == hr )
    {
        _lcid = GetUserDefaultLCID();
    }

    _fLcidInitialized = TRUE;

    PropVariantClear( &propvarLCID );
    return( hr );

}   // CPropertyBagEx::GetLCID()

//+----------------------------------------------------------------------------
//
//  Method: IUnknown methods
//
//  If we have a parent (_ppropsetstgParent), we forward all calls to there.
//  Otherwise, we implement all calls here.  Whether or not we have a parent
//  depends on which of the two constructors is called.  In NFF, NSS, and docfile,
//  we have a parent.  When creating a standalone property bag implementation
//  (in StgCreate/OpenStorageOnHandle), we have no such parent.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    // Do we have a parent?
    if( NULL != _ppropsetstgContainer )
    {
        // Yes, refer the call
        DfpAssert( 0 == _cRefs );
        return( _ppropsetstgContainer->QueryInterface( riid, ppvObject ));
    }
    else
    {
        // No, we have no parent.
        if( IID_IPropertyBagEx == riid
            ||
            IID_IUnknown == riid )
        {
            AddRef();
            *ppvObject = static_cast<IPropertyBagEx*>(this);
            return( S_OK );
        }

        else if( IID_IPropertyBag == riid )
        {
            AddRef();
            *ppvObject = static_cast<IPropertyBag*>(this);
            return( S_OK );
        }
    }

    return( E_NOINTERFACE );
}


ULONG STDMETHODCALLTYPE
CPropertyBagEx::AddRef( void)
{
    // Do we have a parent?
    if( NULL != _ppropsetstgContainer )
    {
        // Yes.  The parent does the ref-counting
        DfpAssert( 0 == _cRefs );
        return( _ppropsetstgContainer->AddRef() );
    }
    else
    {
        // No.  We don't have a parent, and we must do the ref-counting.
        LONG lRefs = InterlockedIncrement( &_cRefs );
        return( lRefs );
    }
}


ULONG STDMETHODCALLTYPE
CPropertyBagEx::Release( void)
{
    // Do we have a parent?
    if( NULL != _ppropsetstgContainer )
    {
        // Yes.  The container does the ref-counting
        DfpAssert( 0 == _cRefs );
        return( _ppropsetstgContainer->Release() );
    }
    else
    {
        // No.  We don't have a parent, and we must do the ref-counting.
        LONG lRefs = InterlockedDecrement( &_cRefs );
        if( 0 == lRefs )
        {
            // Only in this case (where we have no parent) do we release
            // the IBlockingLock
            RELEASE_INTERFACE( _pBlockingLock );

            delete this;
        }
        return( lRefs );
    }
}


//+----------------------------------------------------------------------------
//
//  Method: Read/Write (IPropertyBag)
//
//  These methods simply thunk to ReadMultiple/WriteMultiple.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::Read(
    /* [in] */ LPCOLESTR pszPropName,
    /* [out][in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ IErrorLog __RPC_FAR *pErrorLog)
{
    HRESULT hr=S_OK, hr2=S_OK;
    PROPVARIANT *ppropvar, propvarTmp;

    // We'll read the property into propvarTmp.  Initialize it to
    // *pVar, since it is an in/out parameter (pVar->VarType holds the
    // caller's desired type).

    ppropvar = reinterpret_cast<PROPVARIANT*>(pVar);
    propvarTmp = *ppropvar;

    // Call down to ReadMultiple to read this one property.

    hr = ReadMultiple(1, &pszPropName, &propvarTmp, pErrorLog );

    // If that worked, coerce the property into the type desired by the caller.
    // ReadMultiple already tries to do a coercion, but IPropertyBag::Read
    // supports different types than IPropertyBagEx::ReadMultiple(??).

    if( !FAILED( hr ) )
    {
        hr2 = ImplicitPropVariantToVariantChangeType( ppropvar, &propvarTmp, _lcid );
        PropVariantClear( &propvarTmp );
    }
    if( FAILED(hr2) )
        return hr2;
    else
        return hr;
}   // CPropertyBagEx::Read


HRESULT STDMETHODCALLTYPE
CPropertyBagEx::Write(
    /* [in] */ LPCOLESTR pszPropName,
    /* [in] */ VARIANT __RPC_FAR *pVar)
{
    if( !IsVariantType( pVar->vt ))
        return( STG_E_INVALIDPARAMETER );

    return( WriteMultiple(1, &pszPropName, reinterpret_cast<PROPVARIANT*>(pVar) ));
}


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::ReadMultiple (IPropertyBagEx)
//
//  This method calls down to IPropertyStorage::ReadMultiple.  It has the
//  additional behaviour of coercing the property types into those specified
//  by the caller.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::ReadMultiple( 
        /* [in] */ ULONG cprops,
        /* [size_is][in] */ LPCOLESTR const __RPC_FAR rgoszPropNames[  ],
        /* [size_is][out][in] */ PROPVARIANT __RPC_FAR rgpropvar[  ],
        /* [in] */ IErrorLog __RPC_FAR *pErrorLog)
{
    HRESULT hr = S_OK;
    ULONG i;
    PROPSPEC *rgpropspec = NULL;    // PERF: use TStackBuffer
    PROPVARIANT *rgpropvarRead = NULL;
    BOOL fAtLeastOnePropertyRead = FALSE;

    propXTrace( "CPropertyBagEx::ReadMultiple" );

    _pBlockingLock->Lock( INFINITE );

    //  ----------
    //  Validation
    //  ----------

    if (0 == cprops)
    {
        hr = S_OK;
        goto Exit;
    }

    if (S_OK != (hr = ValidateInRGLPOLESTR( cprops, rgoszPropNames )))
        goto Exit;
    if (S_OK != (hr = ValidateOutRGPROPVARIANT( cprops, rgpropvar )))
        goto Exit;

    propTraceParameters(( "%d, 0x%x, 0x%x, 0x%x", cprops, rgoszPropNames, rgpropvar, pErrorLog ));

    //  --------------
    //  Initialization
    //  --------------

    // Open the underlying property set if it exists.

    hr = OpenPropStg( FILE_OPEN_IF );
    if( STG_E_FILENOTFOUND == hr )
    {
        // The property storage for this bag doesn't even exist.  So we simulate
        // the reading non-extant properties by setting the vt's to emtpy and returning
        // s_false.

        for( i = 0; i < cprops; i++ )
            rgpropvar[i].vt = VT_EMPTY;

        hr = S_FALSE;
        goto Exit;
    }
    else if( FAILED(hr) )
        goto Exit;


    // The property set existed and is now open.

    // Alloc propspec & propvar arrays.  
    // PERF:  Make these stack-based for typical-sized reads.

    rgpropspec = reinterpret_cast<PROPSPEC*>
                 ( CoTaskMemAlloc( cprops * sizeof(PROPSPEC) ));
    if( NULL == rgpropspec )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    rgpropvarRead = reinterpret_cast<PROPVARIANT*>
                    ( CoTaskMemAlloc( cprops * sizeof(PROPVARIANT) ));
    if( NULL == rgpropvarRead )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Put the names into the propspecs.

    for( i = 0; i < cprops; i++ )
    {
        PropVariantInit( &rgpropvarRead[i] );
        rgpropspec[i].ulKind = PRSPEC_LPWSTR;
        rgpropspec[i].lpwstr = const_cast<LPOLESTR>(rgoszPropNames[i]);
    }

    //  ----------------------------
    //  Read & coerce the properties
    //  ----------------------------

    // Read the properties into the local PropVar array

    hr = _ppropstg->ReadMultiple(cprops, rgpropspec, rgpropvarRead );
    if( FAILED(hr) ) goto Exit;

    if( S_FALSE != hr )
        fAtLeastOnePropertyRead = TRUE;

    // Coerce the properties as necessary

    for( i = 0; i < cprops; i++ )
    {
        // If the caller requested a type (something other than VT_EMPTY), and the
        // requested type isn't the same as the read type, then a coercion is necessary.

        if( VT_EMPTY != rgpropvar[i].vt && rgpropvarRead[i].vt != rgpropvar[i].vt )
        {
            PROPVARIANT propvar;
            PropVariantInit( &propvar );

            // Does this property require conversion
            // (i.e. to a VT_UNKNOWN/DISPATCH)?
            if( PropertyRequiresConversion( rgpropvar[i].vt )
                &&
                ( VT_STORED_OBJECT == rgpropvarRead[i].vt
                  ||
                  VT_STREAMED_OBJECT == rgpropvarRead[i].vt
                )
              )
            {
                // Load the object from the stream/storage in rgpropvarRead
                // into propvar.

                propvar = rgpropvar[i];
                hr = LoadObject( &propvar, &rgpropvarRead[i] );
                if( FAILED(hr) )
                    goto Exit;
            }
            else
            {
                // Coerce the property in rgpropvarRead into propvar, according
                // to the caller-requested type (which is specified in rgpropvar).

                hr = PropVariantChangeType( &propvar, &rgpropvarRead[i],
                                              _lcid, 0, rgpropvar[i].vt );
                if( FAILED(hr) )
                {
                    propDbg(( DEB_ERROR, "CPropertyBagEx(0x%x), PropVariantChangeType"
                                         "(0x%x,0x%x,%d,%d,%d) returned %08x\n",
                                         this, &propvar, &rgpropvarRead[i], _lcid, 0, rgpropvar[i].vt, hr ));
                    goto Exit;
                }
            }

            // Get rid of the value original read, and keep the coerced value.
            PropVariantClear( &rgpropvarRead[i] );
            rgpropvarRead[i] = propvar;
        }
    }   // for( i = 0; i < cprops; i++ )

    // No errors from here to the end.
    // Copy the PropVars from the local array to the caller's

    for( i = 0; i < cprops; i++ )
        rgpropvar[i] = rgpropvarRead[i];

    //  ----
    //  Exit
    //  ----

    CoTaskMemFree( rgpropvarRead );
    rgpropvarRead = NULL;

    if( SUCCEEDED(hr) )
        hr = fAtLeastOnePropertyRead ? S_OK : S_FALSE;
            

Exit:

    // We needn't free the rgpropspec[*].lpwstr members, they point
    // into rgszPropName
    if( NULL != rgpropspec )
        CoTaskMemFree( rgpropspec );

    if( NULL != rgpropvarRead )
    {
        for( i = 0; i < cprops; i++ )
            PropVariantClear( &rgpropvarRead[i] );
        CoTaskMemFree( rgpropvarRead );
    }

    _pBlockingLock->Unlock();
    return( hr );

}   // CPropertyBagEx::ReadMultiple



//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::LoadObject
//
//  This method loads an IUnknown or IDispatch object from its persisted state
//  in a stream or storage (by QI-ing for IPersistStream or IPersistStorage,
//  respectively).
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::LoadObject( OUT PROPVARIANT *ppropvarOut, IN PROPVARIANT *ppropvarIn ) const
{
    HRESULT hr = S_OK;
    IUnknown *punk = NULL;
    IPersistStorage *pPersistStg = NULL;
    IPersistStream  *pPersistStm = NULL;

    propITrace( "CPropertyBagEx::LoadObject" );

    DfpAssert( VT_STREAMED_OBJECT == ppropvarIn->vt || VT_STORED_OBJECT == ppropvarIn->vt );
    DfpAssert( VT_UNKNOWN == ppropvarOut->vt || VT_DISPATCH == ppropvarOut->vt );

    punk = ppropvarOut->punkVal;
    DfpAssert( reinterpret_cast<void*>(&ppropvarOut->punkVal)
               ==
               reinterpret_cast<void*>(&ppropvarOut->pdispVal) );

    //  --------------------------
    //  Read in an IPersistStorage
    //  --------------------------

    if( VT_STORED_OBJECT == ppropvarIn->vt )
    {
        DfpAssert( NULL != ppropvarIn->pStorage );

        // Get an IUnknown if the caller didn't provide one.

        if( NULL == punk )
        {
            STATSTG statstg;

            hr = ppropvarIn->pStorage->Stat( &statstg, STATFLAG_NONAME );
            if( FAILED(hr) ) goto Exit;

            hr = CoCreateInstance( statstg.clsid, NULL, CLSCTX_ALL, IID_IUnknown,
                                   reinterpret_cast<void**>(&punk) );
            if( FAILED(hr) ) goto Exit;
        }

        // QI for IPersistStorage

        hr = punk->QueryInterface( IID_IPersistStorage, reinterpret_cast<void**>(&pPersistStg) );
        if( FAILED(hr) )
        {
            propDbg(( DEB_ERROR, "Caller didn't provide IPersistStorage in IProeprtyBagEx::ReadMultiple (%08x)", hr ));
            goto Exit;
        }
        
        // IPersist::Load the storage

        hr = pPersistStg->Load( ppropvarIn->pStorage );
        if( FAILED(hr) )
        {
            propDbg(( DEB_ERROR, "Failed IPersistStorage::Load in IPropretyBagEx::ReadMultiple (%08x)", hr ));
            goto Exit;
        }

    }   // if( VT_STORED_OBJECT == ppropvarIn->vt )


    //  -------------------------
    //  Read in an IPersistStream
    //  -------------------------

    else
    {
        DfpAssert( VT_STREAMED_OBJECT == ppropvarIn->vt );
        DfpAssert( NULL != ppropvarIn->pStream );

        CLSID clsid;
        ULONG cbRead;

        // Skip over the clsid

        hr = ppropvarIn->pStream->Read( &clsid, sizeof(clsid), &cbRead );
        if( FAILED(hr) ) goto Exit;
        if( sizeof(clsid) != cbRead )
        {
            hr = STG_E_INVALIDHEADER;
            propDbg(( DEB_ERROR, "Clsid missing in VT_STREAMED_OBJECT in IPropertyBagEx::ReadMultiple (%d bytes)",
                      cbRead ));
            goto Exit;
        }

        // Get an IUnknown if the caller didn't provide one.

        if( NULL == punk )
        {
            hr = CoCreateInstance( clsid, NULL, CLSCTX_ALL, IID_IUnknown,
                                   reinterpret_cast<void**>(&punk) );
            if( FAILED(hr) ) goto Exit;
        }

        // QI for the IPersistStream

        hr = punk->QueryInterface( IID_IPersistStream, reinterpret_cast<void**>(&pPersistStm) );
        if( FAILED(hr) )
        {
            propDbg(( DEB_ERROR, "Caller didn't provide IPersistStream in IPropertyBagEx::ReadMultiple (%08x)", hr ));
            goto Exit;
        }

        // Load the remainder of the stream

        IFDBG( ULONG cRefs = GetRefCount( ppropvarIn->pStream ));

        hr = pPersistStm->Load( ppropvarIn->pStream );
        if( FAILED(hr) )
        {
            propDbg(( DEB_ERROR, "Failed IPersistStream::Load in IPropertyBagEx::ReadMultiple (%08x)", hr ));
            goto Exit;
        }

        DfpAssert( GetRefCount( ppropvarIn->pStream ) == cRefs );

    }   // if( VT_STORED_OBJECT == ppropvarIn->vt ) ... else

    //  ----
    //  Exit
    //  ----

    ppropvarOut->punkVal = punk;
    punk = NULL;
    hr = S_OK;

Exit:

    RELEASE_INTERFACE( pPersistStg );
    RELEASE_INTERFACE( pPersistStm );
    RELEASE_INTERFACE( punk );

    return( hr );

}   // CPropertyBagEx::LoadObject



//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::WriteMultiple (IPropertyBagEx)
//
//  This method calls down to IPropertyStorage::WriteMultiple.  Additionally,
//  this method is atomic.  So if the WriteMultiple fails, the IPropertyStorage
//  is reverted and reopened.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::WriteMultiple(
        /* [in] */ ULONG cprops,
        /* [size_is][in] */ LPCOLESTR const __RPC_FAR rgoszPropNames[  ],
        /* [size_is][in] */ const PROPVARIANT __RPC_FAR rgpropvar[  ])
{
    HRESULT hr = S_OK;
    ULONG i;
    PROPSPEC *prgpropspec = NULL;
    BOOL fInterfaces = FALSE;

    _pBlockingLock->Lock( INFINITE );

    CStackPropVarArray rgpropvarCopy;
    propXTrace( "CPropertyBagEx::WriteMultiple" );

    hr = rgpropvarCopy.Init( cprops );
    if( FAILED(hr) ) goto Exit;


    //  ----------
    //  Validation
    //  ----------

    if (0 == cprops)
    {
        hr = S_OK;
        goto Exit;
    }

    if (S_OK != (hr = ValidateInRGLPOLESTR( cprops, rgoszPropNames )))
        goto Exit;
    if (S_OK != (hr = ValidateInRGPROPVARIANT( cprops, rgpropvar )))
        goto Exit;

    propTraceParameters(("%lu, 0x%x, 0x%x", cprops, rgoszPropNames, rgpropvar));

    //  --------------
    //  Initialization
    //  --------------

    // Open the property storage if it isn't already, creating if necessary.

    hr = OpenPropStg( FILE_OPEN );
    if( FAILED(hr) ) goto Exit;

    // PERF: Create a local array of propspecs for the WriteMultiple call

    prgpropspec = reinterpret_cast<PROPSPEC*>( CoTaskMemAlloc( cprops * sizeof(PROPSPEC) ));
    if( NULL == prgpropspec )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Set up the PROPSPEC and PROPVARIANT arrays to be written.

    for( i = 0; i < cprops; i++ )
    {
        // Point the propspecs at the caller-provided names

        prgpropspec[i].ulKind = PRSPEC_LPWSTR;
        prgpropspec[i].lpwstr = const_cast<LPOLESTR>(rgoszPropNames[i]);

        // Make a copy of the input PropVariant array, converting VT_UNKNOWN and
        // VT_DISPATCH into VT_EMPTY.  We'll handle these after the initial write.

        rgpropvarCopy[i] = rgpropvar[i];
        if( PropertyRequiresConversion( rgpropvarCopy[i].vt ))
        {
            if( NULL == rgpropvarCopy[i].punkVal )
            {
                hr = E_INVALIDARG;
                goto Exit;
            }

            // We'll handle this particular property after the initial WriteMultiple.
            fInterfaces = TRUE;
            PropVariantInit( &rgpropvarCopy[i] );
        }
    }

    //  --------------------
    //  Write the properties
    //  --------------------

    // Write all the properties, though the VT_UNKNOWN and VT_DISPATCH have been
    // switched to VT_EMPTY (their names will be written, but no value will be written
    // for them).

    hr = _ppropstg->WriteMultiple(cprops, prgpropspec, rgpropvarCopy, PID_FIRST_USABLE );
    if( FAILED(hr) ) goto Exit;

    // Now write the VT_UNKNOWN and VT_DISPATCH properties individually, converting
    // first to VT_STREAMED_OBJECT or VT_STORED_OBJECT.

    if( fInterfaces )
    {
        hr = WriteObjects( cprops, prgpropspec, rgpropvar );
        if( FAILED(hr) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    // We don't need to delete the lpwstr fields, they just point to the caller-provided
    // names.
    if( NULL != prgpropspec )
        CoTaskMemFree( prgpropspec );

    // We don't need to clear rgpropvarCopy; it wasn't a deep copy.

    _pBlockingLock->Unlock();
    return( hr );

}   // CPropertyBagEx::WriteMultiple



//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::WriteObjects
//
//  This method writes VT_UNKNOWN and VT_DISPATCH properties.  It scans the
//  input rgpropvar array for such properties.  For each that it finds, it QIs
//  for IPersistStorage or IPersistStream (in that order), creates a 
//  VT_STORED_OBJECT/VT_STREAMED_OBJECT property (respectively), and persists the object
//  to that property.
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::WriteObjects( IN ULONG cprops,
                              IN const PROPSPEC rgpropspec[],
                              IN const PROPVARIANT rgpropvar[] )
{
    HRESULT hr = S_OK;
    ULONG i;

    propITrace( "CPropertyBagEx::WriteObjects" );

    for( i = 0; i < cprops; i++ )
    {
        // Is this a type we need to handle?

        if( PropertyRequiresConversion( rgpropvar[i].vt ))
        {
            hr = WriteOneObject( &rgpropspec[i], &rgpropvar[i] );
            if( FAILED(hr) ) goto Exit;
        }
    }

    hr = S_OK;

Exit:

    return( hr );

}   // CPropertyBagEx::WriteObjects



//+----------------------------------------------------------------------------
//
//  Method:  WriteOneObject
//
//  This method takes an input propvar that holds an IUnknown or IDispatch,
//  and writes it out to the property set in a stored object 
//  (if the unknown/dispatch supports IPersistStorage) or a streamed object
//  (if it supports IPersistStream).
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::WriteOneObject( const IN PROPSPEC *ppropspec, const IN PROPVARIANT *ppropvar )
{
    HRESULT hr = S_OK;
    PROPVARIANT propvarNew;
    IPersistStorage *pPersistStg = NULL;
    IPersistStream *pPersistStm = NULL;
    IUnknown *punk = NULL;

    PropVariantInit( &propvarNew );

    DfpAssert( PropertyRequiresConversion( ppropvar->vt ));

    DfpAssert( reinterpret_cast<const void*const*>(&ppropvar->punkVal)
               ==
               reinterpret_cast<const void*const*>(&ppropvar->pdispVal)
               &&
               reinterpret_cast<const void*const*>(&ppropvar->pdispVal)
               ==
               reinterpret_cast<const void*const*>(&ppropvar->ppdispVal)
               &&
               reinterpret_cast<const void*const*>(&ppropvar->ppdispVal)
               ==
               reinterpret_cast<const void*const*>(&ppropvar->ppunkVal) );

    //  --------------------
    //  Look for an IPersist
    //  --------------------

    // Get the IUnknown pointer (good for both VT_UNKNOWN and VT_DISPATCH).

    if( VT_BYREF & ppropvar->vt )
        punk = *ppropvar->ppunkVal;
    else
        punk = ppropvar->punkVal;

    DfpAssert( NULL != punk );

    // QI for IPersistStorage, then IPersistStream.  If we find one or the other,
    // set up propvarNew in preparation for a write.  We give preference to IPersistStorage,
    // because if the punk supports both, we should give it the opportunity for the more
    // functional of the two persistence mechanisms.

    hr = punk->QueryInterface( IID_IPersistStorage, reinterpret_cast<void**>(&pPersistStg) );
    if( SUCCEEDED(hr) )
    {
        propvarNew.vt = VT_STORED_OBJECT;
    }
    else if( E_NOINTERFACE == hr )
    {
        hr = punk->QueryInterface( IID_IPersistStream, reinterpret_cast<void**>(&pPersistStm) );
        if( SUCCEEDED(hr) )
            propvarNew.vt = VT_STREAMED_OBJECT;
    }
    if( FAILED(hr) )
    {
        propDbg(( DEB_WARN, "Couldn't find an IPersist interface in IPropertyBagEx::WriteMultiple" ));
        goto Exit;
    }

    //  ----------------------------------
    //  Create the stream/storage property
    //  ----------------------------------

    // Write this empty VT_STREAMED/STORED_OBJECT (has a NULL pstm/pstg value).  This will cause the
    // property set to create a new stream/storage.

    hr = _ppropstg->WriteMultiple( 1, ppropspec, &propvarNew, PID_FIRST_USABLE );
    if( FAILED(hr) )
    {
        propDbg(( DEB_ERROR, "Couldn't write %d for interface in IPropertyBagEx", propvarNew.vt ));
        goto Exit;
    }

    // Get an interface pointer for that new stream/storage.

    hr = _ppropstg->ReadMultiple( 1, ppropspec, &propvarNew );
    if( FAILED(hr) || S_FALSE == hr )
    {
        propDbg(( DEB_ERROR, "Couldn't read stream/storage back for interface in IPropertyBagEx::WriteMultiple" ));
        if( !FAILED(hr) )
            hr = STG_E_WRITEFAULT;
        goto Exit;
    }

    //  --------------------
    //  Persist the property
    //  --------------------

    // IPersistStorage case

    if( NULL != pPersistStg )
    {
        CLSID clsid;

        DfpAssert( VT_STORED_OBJECT == propvarNew.vt );

        // Set the clsid

        hr = pPersistStg->GetClassID( &clsid );
        if( E_NOTIMPL == hr )
            clsid = CLSID_NULL;
        else if( FAILED(hr) )
            goto Exit;

        hr = propvarNew.pStorage->SetClass( clsid );
        if( FAILED(hr) ) goto Exit;

        // Persist to VT_STORED_OBJECT

        hr = pPersistStg->Save( propvarNew.pStorage, FALSE /* Not necessarily same as load */ );
        if( FAILED(hr) ) goto Exit;

        hr = pPersistStg->SaveCompleted( propvarNew.pStorage );
        if( FAILED(hr) ) goto Exit;
    }

    // IPersistStream case

    else
    {
        CLSID clsid;
        ULONG cbWritten;

        DfpAssert( VT_STREAMED_OBJECT == propvarNew.vt );
        DfpAssert( NULL != pPersistStm );

#if 1 == DBG
        // This stream should be at its start.
        {
            CULargeInteger culi;
            hr = propvarNew.pStream->Seek( CLargeInteger(0), STREAM_SEEK_CUR, &culi );
            if( FAILED(hr) ) goto Exit;

            DfpAssert( CULargeInteger(0) == culi );
        }
#endif // #if 1 == DBG


        // Write the clsid

        DfpAssert( NULL != pPersistStm );
        hr = pPersistStm->GetClassID( &clsid );
        if( E_NOTIMPL == hr )
            clsid = CLSID_NULL;
        else if( FAILED(hr) )
            goto Exit;

        hr = propvarNew.pStream->Write( &clsid, sizeof(clsid), &cbWritten );
        if( FAILED(hr) || sizeof(clsid) != cbWritten )
            goto Exit;

        // Persist to VT_STREAMED_OBJECT

        IFDBG( ULONG cRefs = GetRefCount( propvarNew.pStream ));

        hr = pPersistStm->Save( propvarNew.pStream, TRUE /* Clear dirty flag */ );
        if( FAILED(hr) ) goto Exit;

        DfpAssert( GetRefCount( propvarNew.pStream ) == cRefs );
    }


Exit:

    RELEASE_INTERFACE(pPersistStg);
    RELEASE_INTERFACE(pPersistStm);

    PropVariantClear( &propvarNew );

    return( hr );

}   // CPropertyBagEx::WriteOneObject


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::DeleteMultiple (IPropertyBagEx)
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::DeleteMultiple( /*[in]*/ ULONG cprops,
	                        /*[in]*/ LPCOLESTR const rgoszPropNames[],
                                /*[in]*/ DWORD dwReserved )
{
    HRESULT hr = S_OK;
    IEnumSTATPROPBAG *penum = NULL;
    STATPROPBAG statpropbag = { NULL };
    PROPSPEC *prgpropspec = NULL;
    ULONG i;

    //  --------------
    //  Initialization
    //  --------------

    propXTrace( "CPropertyBagEx::DeleteMultiple" );

    _pBlockingLock->Lock( INFINITE );

    // Validate the input

    if (S_OK != (hr = ValidateInRGLPOLESTR( cprops, rgoszPropNames )))
        goto Exit;

    if( 0 != dwReserved )
    {
        hr = STG_E_INVALIDPARAMETER;
        goto Exit;
    }

    propTraceParameters(( "%d, 0x%x", cprops, rgoszPropNames ));

    // If it's not already open, open the property storage now.  If it doesn't exist,
    // then our mission is accomplished; the properties don't exist.

    hr = OpenPropStg( FILE_OPEN_IF ); // Open only if it already exists
    if( STG_E_FILENOTFOUND == hr )
    {
        hr = S_OK;
        goto Exit;
    }
    else if( FAILED(hr) )
        goto Exit;

    // Create an array of PROPSPECs, and load with the caller-provided
    // names.

    prgpropspec = reinterpret_cast<PROPSPEC*>
                  ( CoTaskMemAlloc( cprops * sizeof(PROPSPEC) ));
    if( NULL == prgpropspec )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    for( i = 0; i < cprops; i++ )
    {
        prgpropspec[i].ulKind = PRSPEC_LPWSTR;
        prgpropspec[i].lpwstr = const_cast<LPOLESTR>(rgoszPropNames[i]);
    }

    //  ---------------------
    //  Delete the properties
    //  ---------------------

    hr = _ppropstg->DeleteMultiple( cprops, prgpropspec );
    if( FAILED(hr) ) goto Exit;


    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    CoTaskMemFree( prgpropspec );

    _pBlockingLock->Unlock();

    return( hr );

}   // CPropertyBagEx::DeleteMultiple



//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::Open (IPropertyBagEx)
//
//  This method reads a VT_VERSIONED_STREAM from the underlying property set,
//  and returns the IStream pointer in *ppUnk.  If the property doesn't already
//  exist, and guidPropertyType is not GUID_NULL, then an empty property is
//  created first.  An empty property can also be created over an existing
//  one by specifying OPENPROPERTY_OVERWRITE.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::Open(
        /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
        /* [in] */ LPCOLESTR pwszPropName,
        /* [in] */ GUID guidPropertyType,
        /* [in] */ DWORD dwFlags,
        /* [in] */ REFIID riid,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk)
{

    HRESULT hr = S_OK;

    PROPVARIANT propvar;
    IUnknown *pUnk = NULL;
    DBGBUF(buf1);
    DBGBUF(buf2);

    //  --------------
    //  Initialization
    //  --------------

    propXTrace( "CPropertyBagEx::Open" );

    PropVariantInit( &propvar );

    _pBlockingLock->Lock( INFINITE );

    // Validation

    GEN_VDATEPTRIN_LABEL( pUnkOuter, IUnknown*, E_INVALIDARG, Exit, hr );
    if (S_OK != (hr = ValidateInRGLPOLESTR( 1, &pwszPropName )))
        goto Exit;
    GEN_VDATEREADPTRIN_LABEL( &riid, IID*, E_INVALIDARG, Exit, hr );

    propTraceParameters(( "0x%x, %ws, %s, 0x%x, %s",
                          pUnkOuter, pwszPropName, DbgFmtId(guidPropertyType,buf1),dwFlags, DbgFmtId(riid,buf2) ));


    // Initialize out-parms
    *ppUnk = NULL;


    // We don't support aggregation
    if( NULL != pUnkOuter )
    {
        propDbg(( DEB_ERROR, "CPropertyBagEx(0x%x)::Open doesn't support pUnkOuter\n", this ));
        hr = E_NOTIMPL;
        goto Exit;
    }

    // Check for unsupported flags
    if( 0 != (~OPENPROPERTY_OVERWRITE & dwFlags) )
    {
        propDbg(( DEB_ERROR, "CPropertyBagEx(0x%x)::Open, invalid dwFlags (0x%x)\n", this, dwFlags ));
        hr = E_NOTIMPL;
        goto Exit;
    }

    // We don't support anything but IID_IStream
    if( IID_IStream != riid )
    {
        hr = E_NOTIMPL;
        goto Exit;
    }

    //  -----------------
    //  Read the property
    //  -----------------

    // Attempt to read the property
    hr = ReadMultiple( 1, &pwszPropName, &propvar, NULL );

    // If the property doesn't exist but we were given a valid guid, create a new one.
    if( S_FALSE == hr && GUID_NULL != guidPropertyType )
    {
        VERSIONEDSTREAM VersionedStream;
        PROPVARIANT propvarCreate;

        // Write a new property speicifying NULL for the stream

        VersionedStream.guidVersion = guidPropertyType;
        VersionedStream.pStream = NULL;
        propvarCreate.vt = VT_VERSIONED_STREAM;
        propvarCreate.pVersionedStream = &VersionedStream;

        hr = WriteMultiple( 1, &pwszPropName, &propvarCreate );
        if( FAILED(hr) ) goto Exit;

        // Read the property back, getting an IStream*
        hr = ReadMultiple( 1, &pwszPropName, &propvar, NULL );
    }
    if( FAILED(hr) ) goto Exit;

    // Is the type or guidPropertyType wrong?  (If the caller specified GUID_NULL,
    // then any guidVersion is OK.)

    if( VT_VERSIONED_STREAM != propvar.vt
        ||
        GUID_NULL != guidPropertyType
        &&
        guidPropertyType != propvar.pVersionedStream->guidVersion )
    {
        if( OPENPROPERTY_OVERWRITE & dwFlags )
        {
            // Delete the existing property
            hr = DeleteMultiple( 1, &pwszPropName, 0 );
            if( FAILED(hr) ) goto Exit;

            // Recursive call
            // PERF: Optimize this so that we don't have to re-do the parameter checking.
            hr = Open( pUnkOuter, pwszPropName, guidPropertyType, dwFlags & ~OPENPROPERTY_OVERWRITE, riid, ppUnk );
        
        }   // if( OPENPROPERTY_OVERWRITE & dwFlags )
        else
        {
            propDbg(( DEB_ERROR, "CPropertyBagEx(0x%x)::Open couldn't overwrite existing property - %ws, %d\n",
                                 this, pwszPropName, propvar.vt ));
            hr = STG_E_FILEALREADYEXISTS;
        }   // if( OPENPROPERTY_OVERWRITE & dwFlags ) ... else

        // Unconditional goto Exit; we either just called Open recursively to do the work,
        // or set an error.
        goto Exit;
    }

    // We have a good property, QI for the riid and we're done

    DfpAssert( IID_IStream == riid );

    hr = propvar.pVersionedStream->pStream->QueryInterface( IID_IUnknown, reinterpret_cast<void**>(&pUnk) );
    if( FAILED(hr) )
    {
        pUnk = NULL;
        goto Exit;
    }

    //  ----
    //  Exit
    //  ----

    *ppUnk = pUnk;
    pUnk = NULL;
    hr = S_OK;


Exit:

    if( NULL != pUnk )
        pUnk->Release();

    PropVariantClear( &propvar );

    _pBlockingLock->Unlock();
    return( hr );
}


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::Enum (IPropertyBagEx)
//
//  This method returns an enumerator of properties in a bag.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::Enum( 
        /* [in] */ LPCOLESTR poszPropNameMask,
        /* [in] */ DWORD dwFlags,
        /* [out] */ IEnumSTATPROPBAG __RPC_FAR *__RPC_FAR *ppenum)
{
    HRESULT hr = S_OK;
    CEnumSTATPROPBAG *penum = NULL;

    propXTrace( "CPropertyBagEx::Enum" );

    _pBlockingLock->Lock( INFINITE );

    // Validate inputs

    if (NULL != poszPropNameMask && S_OK != (hr = ValidateInRGLPOLESTR( 1, &poszPropNameMask )))
        goto Exit;
    GEN_VDATEPTROUT_LABEL( ppenum, IEnumSTATPROPBAG*, E_INVALIDARG, Exit, hr );

    // Flags aren't used yet.

    if( 0 != dwFlags )
    {
        propDbg(( DEB_ERROR, "CPropertyBagEx(0x%x)::Enum - invalid dwFlags (%08x)\n", this, dwFlags ));
        hr = E_INVALIDARG;
        goto Exit;
    }

    propTraceParameters(( "%ws, 0x%08x, 0x%x", poszPropNameMask, dwFlags, ppenum ));

    // Initialize output

    *ppenum = NULL;

    // Open the property storage, if it exists.  If it doesn't, 
    // we'll still carry on and create an enumerator, it just won't have
    // anything in it.

    hr = OpenPropStg( FILE_OPEN_IF );
    if( STG_E_FILENOTFOUND == hr )
        hr = S_OK;
    else if( FAILED(hr) )
        goto Exit;

    // Create an enumerator

    penum = new CEnumSTATPROPBAG( _pBlockingLock );
    if( NULL == penum )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // And initialize it

    hr = penum->Init( _ppropstg, poszPropNameMask, dwFlags );    // _ppropstg could be NULL
    if( FAILED(hr) ) goto Exit;

    //  ----
    //  Exit
    //  ----

    hr = S_OK;
    *ppenum = static_cast<IEnumSTATPROPBAG*>( penum );
    penum = NULL;

Exit:

    if( NULL != penum )
        penum->Release();

    _pBlockingLock->Unlock();

    return( hr );

}   // CPropertyBagEx::Enum


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::Commit
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::Commit( DWORD grfCommitFlags )
{
    HRESULT hr = S_OK;

    propITrace( "CPropertyBagEx::Commit" );
    propTraceParameters(( "%08x", grfCommitFlags ));

    // As an optimization, we only take the lock if we're really going to
    // do the commit.

    if( NULL != _ppropstg )
    {
        _pBlockingLock->Lock( INFINITE );

        // We have to re-check if _ppropstg is NULL, since it
        // could have changed while we were taking the lock.

        if( NULL != _ppropstg && IsWriteable() )
        {
            hr = _ppropstg->Commit( grfCommitFlags );
        }

        _pBlockingLock->Unlock();
    }

    return( hr );

}   // CPropertyBagEx::Commit


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::ShutDown
//
//  Release the _ppropstg and clean up.
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::ShutDown()
{
    HRESULT hr = S_OK;
    propITrace( "CPropertyBagEx::ShutDown" );

    if( NULL != _pBlockingLock )
        _pBlockingLock->Lock( INFINITE );

    // Release the property storage that holds the bag.  It is because
    // of this call that we need this separate ShutDown method; we can't
    // release this interface in the destructor, since it may be reverted
    // by that point.

    DfpVerify( 0 == RELEASE_INTERFACE(_ppropstg) );

    // We didn't AddRef these, so we don't need to release them.

    if( NULL != _ppropsetstgContainer )
        _ppropsetstgContainer = NULL;

    if( NULL != _pBlockingLock )
    {
        _pBlockingLock->Unlock();
        _pBlockingLock = NULL;
    }

    return( hr );

}   // CPropertyBagEx::ShutDown



//+----------------------------------------------------------------------------
//
//  Method: CSTATPROPBAGArray::Init
//
//+----------------------------------------------------------------------------

HRESULT
CSTATPROPBAGArray::Init( IPropertyStorage *ppropstg, const OLECHAR *poszPrefix, DWORD dwFlags )
{
    HRESULT hr = S_OK;

    propITrace( "CSTATPROPBAGArray::Init" );
    propTraceParameters(( "0x%x, %ws", ppropstg, poszPrefix ));

    _pBlockingLock->Lock( INFINITE );

    // Keep the IPropertyBagEx::Enum flags

    _dwFlags = dwFlags;

    // Copy the prefix string

    if( NULL == poszPrefix )
        // There isn't a prefix string
        _poszPrefix = NULL;
    else
    {
        // Dup the prefix string

        ULONG cbPrefix = (ocslen(poszPrefix)+1) * sizeof(OLECHAR);
        _poszPrefix = reinterpret_cast<OLECHAR*> ( CoTaskMemAlloc( cbPrefix ));
        if( NULL == _poszPrefix )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        //ocscpy( _poszPrefix, poszPrefix );
        CopyMemory( _poszPrefix, poszPrefix, cbPrefix );
    }

    // If we were given an IPropertyStorage, enum it.  Otherwise, we'll leave
    // _penum NULL and always return 0 for *pcFetched.

    if( NULL != ppropstg )
    {
        hr = ppropstg->Enum( &_penum );
        if( FAILED(hr) ) goto Exit;
    }

    hr = S_OK;

Exit:

    _pBlockingLock->Unlock();
    return( hr );

}   // CSTATPROPBAGArray::Init



//+----------------------------------------------------------------------------
//
//  Method: CSTATPROPBAGArray::AddRef/Release
//
//+----------------------------------------------------------------------------

ULONG
CSTATPROPBAGArray::AddRef()
{
    return( InterlockedIncrement( &_cReferences ));
}

ULONG
CSTATPROPBAGArray::Release()
{
    LONG lRet = InterlockedDecrement( &_cReferences );

    if( 0 == lRet )
        delete this;

    return( 0 > lRet ? 0 : lRet );
}



//+----------------------------------------------------------------------------
//
//  Method: CSTATPROPBAGArray::NextAt
//
//  This method gets the *pcFetched STATPROPBAG structures in the
//  enumeration starting from index iNext.  This is implemented using
//  the IEnumSTATPROPSTG enumerator in _penum.
//
//+----------------------------------------------------------------------------  


HRESULT
CSTATPROPBAGArray::NextAt( ULONG iNext, STATPROPBAG *prgstatpropbag, ULONG *pcFetched )
{
    HRESULT hr = S_OK;
    STATPROPSTG statpropstg = { NULL };
    ULONG iMatch = 0;
    ULONG iFetched = 0;

    propITrace( "CSTATPROPBAGArray::NextAt" );
    propTraceParameters(( "%d, 0x%x, 0x%x", iNext, prgstatpropbag, pcFetched ));

    _pBlockingLock->Lock( INFINITE );

    // If there's nothing to enumerate, then we're done

    if( NULL == _penum )
    {
        hr = S_FALSE;
        *pcFetched = 0;
        goto Exit;
    }

    // Reset the IEnumSTATPROPBAGTG index (doesn't reload, just resets the index).

    hr = _penum->Reset();
    if( FAILED(hr) ) goto Exit;

    // Walk the IEnumSTATPROPBAGTG enumerator, looking for matches.

    hr = _penum->Next( 1, &statpropstg, NULL );
    while( S_OK == hr && iFetched < *pcFetched )
    {
        // Does this property have a name (all properties in a bag must have
        // a name)?

        if( NULL != statpropstg.lpwstrName )
        {
            // Yes, we have a name.  Are we enumerating all properties (in which case
            // _poszPrefix is NULL), or does this property name match the prefix?

            if( NULL == _poszPrefix
                ||
                statpropstg.lpwstrName == ocsstr( statpropstg.lpwstrName, _poszPrefix )
                ||
                !ocscmp( statpropstg.lpwstrName, _poszPrefix ) )
            {
                // Yes, this property matches the prefix and is therefore part
                // of this enumeration.  But is this the index into the enumeration
                // that we're looking for?

                if( iNext == iMatch )
                {
                    // Yes, everything matches, and we have a property that should
                    // be returned.

                    // *Move* the name from statpropstg to the output array.

                    prgstatpropbag[ iFetched ].lpwstrName = statpropstg.lpwstrName;
                    statpropstg.lpwstrName = NULL;

                    prgstatpropbag[ iFetched ].vt = statpropstg.vt;

                    // GUID is not currently supported by the enumeration

                    prgstatpropbag[ iFetched ].guidPropertyType = GUID_NULL;

                    // Show that we're now looking for the i+1 index

                    iNext++;
                    iFetched++;
                }

                // Increment the number of property matches we've had.
                // (iMatch will increment until it equals iNext, after
                // which the two will always both increment and remain equal).

                iMatch++;

            }   // if( NULL == _poszPrefix ...
        }   // if( NULL != statpropstg.lpwstrName )

        CoTaskMemFree( statpropstg.lpwstrName );  // (May be NULL)
        statpropstg.lpwstrName = NULL;
        hr = _penum->Next( 1, &statpropstg, NULL );

    }   // while( S_OK == hr && iFetched < *pcFetched )

    // Did we get an error on a _penum->Next call?
    if( FAILED(hr) ) goto Exit;


    // If we reached this point, there was no error.  Determine if
    // OK or FALSE should be returned.

    if( iFetched == *pcFetched )
        hr = S_OK;
    else
        hr = S_FALSE;

    *pcFetched = iFetched;

    //  ----
    //  Exit
    //  ----

Exit:

    // Cleanup on error
    CoTaskMemFree( statpropstg.lpwstrName );

    _pBlockingLock->Unlock();
    return( hr );

}   // CSTATPROPBAGArray::NextAt




//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::CEnumSTATPROPBAG (copy constructor)
//
//+----------------------------------------------------------------------------

CEnumSTATPROPBAG::CEnumSTATPROPBAG( const CEnumSTATPROPBAG &Other )
{
    propDbg(( DEB_ITRACE, "CEnumSTATPROPBAG::CEnumSTATPROPBAG (copy constructor)" ));

    Other._pBlockingLock->Lock( INFINITE );

    new(this) CEnumSTATPROPBAG( Other._pBlockingLock );

    _iarray = Other._iarray;

    Other._parray->AddRef();
    _parray = Other._parray;

    Other._pBlockingLock->Unlock();
}

//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::~CEnumSTATPROPBAG
//
//+----------------------------------------------------------------------------

CEnumSTATPROPBAG::~CEnumSTATPROPBAG()
{
    propDbg(( DEB_ITRACE, "CEnumSTATPROPBAG::~CEnumSTATPROPBAG\n" ));

    _pBlockingLock->Release();
    if( NULL != _parray )
        _parray->Release();
}

//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::Init
//
//+----------------------------------------------------------------------------

HRESULT
CEnumSTATPROPBAG::Init( IPropertyStorage *ppropstg, LPCOLESTR poszPrefix, DWORD dwFlags )
{
    HRESULT hr = S_OK;

    propITrace( "CEnumSTATPROPBAG::Init" );
    propTraceParameters(( "0x%x, %ws", ppropstg, poszPrefix ));

    // Create a STATPROPBAG Array

    _parray = new CSTATPROPBAGArray( _pBlockingLock );
    if( NULL == _parray )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Load the array from the IPropertyStorage

    hr = _parray->Init( ppropstg, poszPrefix, dwFlags );
    if( FAILED(hr) ) goto Exit;

    hr = S_OK;

Exit:

    return( hr );
}	// CEnumSTATPROPBAG::Init


//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::QueryInterface/AddRef/Release
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEnumSTATPROPBAG::QueryInterface( REFIID riid, void **ppvObject )
{
    HRESULT hr = S_OK;

    // Validate the inputs

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    *ppvObject = NULL;

    // Get the interface

    if( IID_IEnumSTATPROPBAG == riid || IID_IUnknown == riid )
    {
        *ppvObject = static_cast<IEnumSTATPROPBAG*>(this);
        AddRef();
    }
    else
        hr = E_NOINTERFACE;

    return(hr);

}   // CEnumSTATPROPBAG::QueryInterface

ULONG STDMETHODCALLTYPE
CEnumSTATPROPBAG::AddRef()
{
    return( InterlockedIncrement( &_cRefs ));
}

ULONG STDMETHODCALLTYPE
CEnumSTATPROPBAG::Release()
{
    LONG lRet = InterlockedDecrement( &_cRefs );
    
    if( 0 == lRet )
        delete this;

    return( 0 > lRet ? 0 : lRet );
}


//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::Next
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEnumSTATPROPBAG::Next( ULONG celt, STATPROPBAG *rgelt, ULONG *pceltFetched )
{
    HRESULT hr = S_OK;
    ULONG celtFetched = celt;

    propXTrace( "CEnumSTATPROPBAG::Next" );

    // Validate the inputs

    if (NULL == pceltFetched)
    {
        if (celt != 1)
        {
            hr = STG_E_INVALIDPARAMETER;
            goto Exit;
        }
    }
    else
    {
        VDATEPTROUT( pceltFetched, ULONG );
        *pceltFetched = 0;
    }
    propTraceParameters(( "%d, 0x%x, 0x%x", celt, rgelt, pceltFetched ));

    _pBlockingLock->Lock( INFINITE );

    // Get the next set of stat structures

    hr = _parray->NextAt( _iarray, rgelt, &celtFetched );
    if( FAILED(hr) ) goto Exit;

    // Advance the index

    _iarray += celtFetched;
    
    // Return the count to the caller

    if( NULL != pceltFetched )
        *pceltFetched = celtFetched;

    hr = celtFetched == celt ? S_OK : S_FALSE;

Exit:

    _pBlockingLock->Unlock();
    return( hr );

}   // CEnumSTATPROPBAG::Next


//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::Reset
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEnumSTATPROPBAG::Reset( )
{
    HRESULT hr = S_OK;
    propXTrace( "CEnumSTATPROPBAG::Reset" );

    _pBlockingLock->Lock( INFINITE );
    _iarray = 0;
    _pBlockingLock->Unlock();

    return( hr );

}   // CEnumSTATPROPBAG::Reset



//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::Skip
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEnumSTATPROPBAG::Skip( ULONG celt )
{
    HRESULT hr = S_OK;
    STATPROPBAG statpropbag = { NULL };

    propXTrace( "CEnumSTATPROPBAG::Skip" );
    propTraceParameters( ("%d", celt ));

    _pBlockingLock->Lock( INFINITE );

    // Loop until we've skipped celt items (or run into the end)

    while( celt )
    {
        ULONG cFetched = 1;

        // Get the next item.
        hr = _parray->NextAt( _iarray, &statpropbag, &cFetched );

        // Free the name
        CoTaskMemFree( statpropbag.lpwstrName );
        statpropbag.lpwstrName = NULL;

        // Did the NextAt work?

        if( FAILED(hr) )
            // No, it failed
            goto Exit;
        else if( S_FALSE == hr )
            // It worked, but there's nothing left
            break;
        else
        {
            // We got an entry

            _iarray++;
            hr = S_OK;
            --celt;
        }
    }


Exit:

    CoTaskMemFree( statpropbag.lpwstrName );

    _pBlockingLock->Unlock();
    return( hr );

}   // CEnumSTATPROPBAG::Skip



//+----------------------------------------------------------------------------
//
//  Method: CEnumSTATPROPBAG::Clone
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEnumSTATPROPBAG::Clone( IEnumSTATPROPBAG **ppenum )
{
    HRESULT hr = S_OK;
    CEnumSTATPROPBAG *penum = NULL;

    propXTrace( "CEnumSTATPROPBAG::Clone" );

    // Validate the input

    VDATEPTROUT( ppenum, IEnumSTATPROPSTG* );
    *ppenum = NULL;
    propTraceParameters(( "0x%x", ppenum ));

    // Instantiated & initialize a new enumerator

    penum = new CEnumSTATPROPBAG( *this );
    if( NULL == penum )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Set the out parm

    *ppenum = static_cast<IEnumSTATPROPBAG*>(penum);
    penum = NULL;

Exit:

    if( NULL != penum )
        delete penum ;

    return( hr );

}   // CEnumSTATPROPBAG::Clone
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\hntfsstg.cxx ===
//+============================================================================
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:   hntfsstg.cxx
//
//  This file provides the NFF (NTFS Flat File) IStorage implementation.
//
//  History:
//      5/6/98  MikeHill
//              -   Use CoTaskMem rather than new/delete.
//              -   Split the Init method into two methods, one which is
//                  file name based and the other which is handle based.
//      5/18/98 MikeHill
//              -   Use the cleaned up CPropertySetStorage & CPropertyBagEx
//                  constructors.
//
//+============================================================================


#include <pch.cxx>
#include "expparam.hxx"


#define UNSUPPORTED_STGM_BITS  ( STGM_CONVERT    |      \
                                 STGM_TRANSACTED |      \
                                 STGM_PRIORITY   |      \
                                 STGM_SIMPLE     |      \
                                 STGM_DELETEONRELEASE )


WCHAR GetDriveLetter (WCHAR const *pwcsName);
BOOL IsDataStream( const PFILE_STREAM_INFORMATION pFileStreamInformation );


//-----------------------------------------------------------
//
// NFFOpen();
//
// Routine for the rest of Storage to use to open NFF files
// without knowing a lot of details.
//
//-----------------------------------------------------------

HRESULT
NFFOpen(const WCHAR *pwcsName,
        DWORD grfMode,
        DWORD dwFlags,
        BOOL fCreateAPI,
        REFIID riid,
        void **ppv)
{
    CNtfsStorage* pnffstg=NULL;
    IUnknown *punk=NULL;
    HRESULT sc=S_OK;

    nffDebug(( DEB_TRACE | DEB_INFO | DEB_OPENS,
               "NFFOpen(\"%ws\", %x, %x, &iid=%x, %x)\n",
              pwcsName, grfMode, fCreateAPI, &riid, ppv));

    // Parameter validation

    if( 0 != ( grfMode & UNSUPPORTED_STGM_BITS ) )
        nffErr( EH_Err, STG_E_INVALIDFLAG );

    // We don't support Write only storage (yet)

    if( STGM_WRITE == (grfMode & STGM_RDWR_MASK) )
        nffErr( EH_Err, STG_E_INVALIDFLAG );

    // Instantiate and initialize a CNtfsStorage for this file.

    nffMem( pnffstg = new CNtfsStorage( grfMode ));

    nffChk( pnffstg->InitFromName( pwcsName, fCreateAPI, dwFlags ) );

    nffChk( pnffstg->QueryInterface( riid, (void**)&punk ) );

    *ppv = punk;
    punk = NULL;

EH_Err:
    RELEASE_INTERFACE( pnffstg );
    RELEASE_INTERFACE( punk );

    // Compatibilty with Docfile:  Multiple opens with incompatible
    //  STGM_ modes returns LOCK vio not SHARE vio.   We use file SHARE'ing
    // Docfile used file LOCK'ing.
    
    if(STG_E_SHAREVIOLATION == sc)
        sc = STG_E_LOCKVIOLATION;

    nffDebug(( DEB_TRACE, "NFFOpen() sc=%x\n", sc ));
    return(sc);
}

//+----------------------------------------------------------------------------
//
//  Function:   NFFOpenOnHandle
//
//  Create or open an NFF IStorage (or QI-able interface) on a given
//  handle.
//
//+----------------------------------------------------------------------------

HRESULT
NFFOpenOnHandle( BOOL fCreateAPI,
                 DWORD grfMode,
                 DWORD stgfmt,
                 HANDLE* phStream,
                 REFIID riid,
                 void ** ppv)
{
    HRESULT sc=S_OK;
    CNtfsStorage *pnffstg=NULL;
    IUnknown *punk=NULL;

    nffDebug(( DEB_TRACE | DEB_INFO | DEB_OPENS,
               "NFFOpenOnHandle(%x, %x, %x, %x, &iid=%x, %x)\n",
               fCreateAPI, grfMode, stgfmt, *phStream, &riid, ppv));

    // Parameter validation

    if( 0 != ( grfMode & UNSUPPORTED_STGM_BITS ) )
        nffErr( EH_Err, STG_E_INVALIDFLAG );

    // We don't currently support create here.

    if( fCreateAPI )
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    // Instantiate and initialize a CNtfsStorage on this handle

    nffMem( pnffstg = new CNtfsStorage( grfMode ));

    nffChk( pnffstg->InitFromMainStreamHandle( phStream,
                                               NULL,
                                               fCreateAPI,
                                               NFFOPEN_NORMAL,
                                               stgfmt ) );

    nffAssert( INVALID_HANDLE_VALUE == *phStream );

    nffChk( pnffstg->QueryInterface( riid, (void**)&punk ) );

    *ppv = punk;
    punk = NULL;

EH_Err:
    RELEASE_INTERFACE(pnffstg);
    RELEASE_INTERFACE(punk);

    return( sc );

}   // OpenNFFOnHandle

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IUnknown::QueryInterface
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::QueryInterface(
    REFIID  riid,
    void ** ppvObject
    )
{
    nffXTrace( "CNtfsStorage::QueryInterface" );

    HRESULT sc = S_OK;

    // Parameter validation

    NFF_VALIDATE( QueryInterface( riid, ppvObject ) );

    // Check for the known interfaces

    if( IID_IStorage == riid )
    {
        nffDebug(( DEB_ERROR, "STGFMT_FILE IID_IStorage is not supported\n" ));
        return E_NOINTERFACE;
    }
    else if( IID_IPropertySetStorage == riid || IID_IUnknown == riid )
    {
        *ppvObject = static_cast<IPropertySetStorage*>(this);
        AddRef();
    }
    else if( IID_IBlockingLock == riid )
    {
        *ppvObject = static_cast<IBlockingLock*>(this);
        AddRef();
    }
    else if( IID_ITimeAndNoticeControl == riid )
    {
        *ppvObject = static_cast<ITimeAndNoticeControl*>(this);
        AddRef();
    }
    else if( IID_IPropertyBagEx == riid )
    {
        *ppvObject = static_cast<IPropertyBagEx*>(&_PropertyBagEx);
        AddRef();
    }
    else if( IID_IPropertyBag == riid )
    {
        *ppvObject = static_cast<IPropertyBag*>(&_PropertyBagEx);
        AddRef();
    }
#if DBG
    else if( IID_IStorageTest == riid )
    {
        *ppvObject = static_cast<IStorageTest*>(this);
        AddRef();
    }
#endif // #if DBG
    else
        return E_NOINTERFACE ;

    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IUnknown::AddRef
//
//+----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CNtfsStorage::AddRef(void)
{
    LONG lRet;

    lRet = InterlockedIncrement( &_cReferences );

    nffDebug(( DEB_REFCOUNT, "CNtfsStorage::AddRef(this==%x) == %d\n",
                                this, lRet));

    return( lRet );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IUnknown::Release
//
//+----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CNtfsStorage::Release(void)
{
    LONG lRet;

    lRet = InterlockedDecrement( &_cReferences );

    if( 0 == lRet )
    {
        delete this;
    }

    nffDebug((DEB_REFCOUNT, "CNtfsStorage::Release(this=%x) == %d\n",
                            this, lRet));

    return( lRet );

}


#ifdef OLE2ANSI
#error CNtfsStorage requires OLECHAR to be UNICODE
#endif

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::CreateStream
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::CreateStream(
        const OLECHAR* pwcsName,
        DWORD grfMode,
        DWORD res1,
        DWORD res2,
        IStream** ppstm)
{
    HRESULT sc=S_OK;
    CNtfsStream *pstm = NULL;
    CNtfsStream *pstmPrevious = NULL;

    //
    // Prop code passed streams names with DOCF_  UPDR_ prefix and are too long.
    //  MikeHill and BChapman agree that the docfile in a stream code should
    //  be moved into this object's (currenly unimplemented) CreateStorage.
    // So for the moment since this IStorage is not exposed, we will remove
    // the parameter validation.
    //
    // NFF_VALIDATE( CreateStream( pwcsName, grfMode, res1, res2, ppstm ) );

    Lock( INFINITE );

    // Ensure we're not in the reverted state

    nffChk( CheckReverted() );

    nffDebug(( DEB_INFO | DEB_OPENS | DEB_TRACE,
               "CreateStream(\"%ws\", %x)\n", pwcsName, grfMode));

    // We don't support convert

    if( STGM_CONVERT & grfMode )
        nffErr( EH_Err, STG_E_INVALIDFLAG );

    // Is this tream already opened?

    if( FindAlreadyOpenStream( pwcsName, &pstmPrevious ) )
    {
        // If the stream is already open then return Access Denied because
        // streams are always opened Exclusive.  But if we are CREATE'ing
        // then revert the old one and make a new one.

        if( 0 == (STGM_CREATE & grfMode) )
        {
            nffErr( EH_Err, STG_E_ACCESSDENIED );
        }
        else
        {
            pstmPrevious->ShutDown();
            pstmPrevious->Release();    // FindAOS() Addref'ed, so release here
            pstmPrevious = NULL;
        }
    }

    // The stream isn't already open, or we blew it away.
    // Instantiate a new one.

    nffChk( NewCNtfsStream( pwcsName, grfMode, TRUE, &pstm ));

    // ------------------
    // Set Out Parameters
    // ------------------

    *ppstm = static_cast<IStream*>(pstm);
    pstm = NULL;

EH_Err:

    if( NULL != pstm )
        pstm->Release();

    if( NULL != pstmPrevious )
        pstmPrevious->Release();

    Unlock();

    nffDebug(( DEB_TRACE, "CreateStream() sc=%x\n", sc ));

    return( sc );

}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::OpenStream
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::OpenStream(
        const OLECHAR* pwcsName,
        void* res1,
        DWORD grfMode,
        DWORD res2,
        IStream** ppstm)
{
    HRESULT sc=S_OK;
    CNtfsStream *pstm = NULL;

    //
    // Prop code passed streams names with DOCF_  UPDR_ prefix and are too long.
    //  MikeHill and BChapman agree that the docfile in a stream code should
    //  be moved into this object's (currenly unimplemented) OpenStorage.
    // So for the moment since this IStorage is not exposed, we will remove
    // the parameter validation.
    //
    // NFF_VALIDATE( OpenStream( pwcsName, res1, grfMode, res2, ppstm ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    nffDebug(( DEB_INFO | DEB_OPENS | DEB_TRACE,
               "OpenStream(\"%ws\", grf=0x%x);\n", pwcsName, grfMode ));

    // Is this stream already open?  If so => error.

    if( FindAlreadyOpenStream( pwcsName, &pstm ) )
        nffErr( EH_Err, STG_E_ACCESSDENIED );

    // Otherwise, open the stream.

    nffChk( NewCNtfsStream( pwcsName, grfMode, FALSE, &pstm ));

    *ppstm = static_cast<IStream*>(pstm);
    pstm = NULL;

EH_Err:

    if( NULL != pstm )
        pstm->Release();

    Unlock();

    nffDebug(( DEB_TRACE, "OpenStream() sc=%x\n", sc ));

    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::CreateStorage
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::CreateStorage(
        const OLECHAR* pwcsName,
        DWORD grfMode,
        DWORD reserved1,
        DWORD reserved2,
        IStorage** ppstg)
{
    nffXTrace( "CNtfsStorage::CreateStorage" );
    // Not supported
    return( E_NOTIMPL );
}   // CNtfsStorage::CreateStorage



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::OpenStorage
//
//+----------------------------------------------------------------------------

HRESULT CNtfsStorage::OpenStorage(
        const OLECHAR* pwcsName,
        IStorage* pstgPriority,
        DWORD grfMode,
        SNB snbExclude,
        DWORD reserved,
        IStorage** ppstg)
{
    nffXTrace( "CNtfsStorage::OpenStorage" );
    // Not supported
    return( E_NOTIMPL );
}   // CNtfsStorage::OpenStorage



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::CopyTo
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::CopyTo(
        DWORD ciidExclude,
        const IID* rgiidExclude,
        SNB snbExclude,
        IStorage* pstgDest)
{
    nffXTrace( "CNtfsStorage::CopyTo" );
    return E_NOTIMPL;
}
//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::MoveElementTo
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::MoveElementTo(
        const OLECHAR* pwcsName,
        IStorage* pstgDest,
        const OLECHAR* pwcsNewName,
        DWORD grfFlags)
{
    nffXTrace( "CNtfsStorage::MoveElementTo" );
    HRESULT sc=S_OK;

    NFF_VALIDATE( MoveElementTo( pwcsName, pstgDest, pwcsNewName, grfFlags ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // MoveElementTo not supported.  Use CopyTo and DestroyElement

EH_Err:
    Unlock();

    return( E_NOTIMPL );
}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::Commit
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::Commit( DWORD grfCommitFlags )
{
    nffXTrace( "CNtfsStorage::Commit" );
    CNtfsStream *pstm = NULL;
    HRESULT sc=S_OK;

    NFF_VALIDATE( Commit( grfCommitFlags ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // Commit the property bag (stored as a special stream).

    nffChk( _PropertyBagEx.Commit( grfCommitFlags ));

    // Loop through the open streams and commit (flush) them.

    if( NULL != _pstmOpenList )     // Skip the head sentinal;
        pstm = _pstmOpenList->_pnffstmNext;

    while(NULL != pstm)
    {
        sc = pstm->Commit ( grfCommitFlags );
        if( S_OK != sc )
            break;

        pstm = pstm->_pnffstmNext;
    }

EH_Err:
    Unlock();

    return( sc );
}



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::Revert
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::Revert( void )
{
    nffXTrace( "CNtfsStorage::Revert" );
    // We don't support transactioning, so we must be in direct mode.
    // In direct mode, return S_OK on Revert.
    return( S_OK );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::EnumElements
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::EnumElements(
        DWORD res1,
        void* res2,
        DWORD res3,
        IEnumSTATSTG** ppenum )
{
    nffXTrace( "CNtfsStorage::EnumElements" );
    CNtfsEnumSTATSTG *pNtfsEnumSTATSTG = NULL;
    HRESULT sc=S_OK;

    NFF_VALIDATE( EnumElements( res1, res2, res3, ppenum ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // Create the enumerator
    pNtfsEnumSTATSTG = new CNtfsEnumSTATSTG(
                                  static_cast<IBlockingLock*>(_pTreeMutex) );

    if( NULL == pNtfsEnumSTATSTG )
    {
        sc = E_OUTOFMEMORY;
        goto EH_Err;
    }

    // Initialize the enumerator

    nffChk( pNtfsEnumSTATSTG->Init( _hFileMainStream ));

    //  ----
    //  Exit
    //  ----

    *ppenum = static_cast<IEnumSTATSTG*>(pNtfsEnumSTATSTG);
    pNtfsEnumSTATSTG = NULL;
    sc = S_OK;

EH_Err:

    if( NULL != pNtfsEnumSTATSTG )
        delete pNtfsEnumSTATSTG;

    Unlock();
    return( sc );

}   // CNtfsStorage::EnumElements

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::DestroyElement
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::DestroyElement( const OLECHAR* pwcsName )
{
    nffXTrace( "CNtfsStorage::DestroyElement" );
    HRESULT sc=S_OK;

    NFF_VALIDATE( DestroyElement( pwcsName ) );

    Lock( INFINITE );

    nffChk( CheckReverted() );


    // We don't allow Destroying the CONTENT Stream.

    if( IsContentStream( pwcsName ) )
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );

    nffDebug((DEB_INFO, "CNtfsStorage::DestroyElement(\"%ws\", %x)\n",
                        pwcsName));

    // Try to delete the stream

    sc = DestroyStreamElement( pwcsName );
    if( STG_E_PATHNOTFOUND == sc || STG_E_FILENOTFOUND == sc )
    {
        // It didn't exist - delete it as a storage (a storage is
        // really a docfile, and the stream name has a "Docf_" prefix).
        // ?? Why is this storage logic here?  The storage logic is supposed
        // to be part of CNtfsStorageForPropSet, and not known here?

        sc = DestroyStreamElement( CDocfileStreamName(pwcsName) );
    }
    nffChk(sc);

    // If the stream is already open, revert it.

    CNtfsStream *pstm;
    if( FindAlreadyOpenStream( pwcsName, &pstm ) )  // revert open stream
    {
        pstm->ShutDown();
        pstm->Release();
    }

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::RenameElement
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::RenameElement(
    const OLECHAR* pwcsOldName,
    const OLECHAR* pwcsNewName)
{
    HRESULT sc=S_OK;
    CNtfsStream *pstm = NULL;
    nffXTrace( "CNtfsStorage::RenameElement" );

    //NFF_VALIDATE( RenameElement( pwcsOldName, pwcsNewName ) );

    Lock( INFINITE );
    nffChk( CheckReverted() );


    // We don't allow Renaming the CONTENT Stream.

    if( IsContentStream( pwcsOldName ) )
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );

    // Get a CNtfsStream for this stream (you have to open it,
    // with exclusive access, in order to rename it).

    nffChk( NewCNtfsStream( pwcsOldName,
                            STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                            FALSE,
                            &pstm ) );

    // Rename it

    nffChk( pstm->Rename( pwcsNewName, FALSE ));

    nffVerify( 0 == pstm->Release() );
    pstm = NULL;

EH_Err:

    if( NULL != pstm )
        nffVerify( 0 == pstm->Release() );

    Unlock();
    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::SetElementTimes
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::SetElementTimes(
        const OLECHAR* pwcsName,
        const FILETIME* pctime,
        const FILETIME* patime,
        const FILETIME* pmtime)
{
    nffXTrace( "CNtfsStorage::SetElementTimes" );
    HRESULT sc=S_OK;

    NFF_VALIDATE( SetElementTimes( pwcsName, pctime, patime, pmtime ) );

    if(NULL != pwcsName)
        return S_OK;

    Lock ( INFINITE );
    nffChk( CheckReverted() );

    nffDebug((DEB_INFO, "CNtfsStorage::SetElementTimes(\"%ws\")\n",
                        pwcsName));

    // If user mode code sets the last modified times on a handle,
    // then WriteFile()s no longer changes the last modified time

    sc = SetAllStreamsTimes(pctime, patime, pmtime);

EH_Err:
    Unlock();
    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::SetClass
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::SetClass(
        REFCLSID clsid)
{
    nffXTrace( "CNtfsStorage::SetClass" );
    CLSID clsidOld = _clsidStgClass;
    HRESULT sc = S_OK;

    NFF_VALIDATE( SetClass( clsid ) );

    Lock( INFINITE );
    nffChk( CheckReverted() );

    _clsidStgClass = clsid;
    nffChk( WriteControlStream() );

EH_Err:

    if (FAILED(sc))
        _clsidStgClass = clsidOld;

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::SetStateBits
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::SetStateBits(
        DWORD grfStateBits,
        DWORD grfMask)
{
    // Reserved for future use
    return E_NOTIMPL;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IStorage::Stat
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::Stat(
        STATSTG *pstatstg,
        DWORD grfStatFlag)
{
    nffXTrace( "CNtfsStorage::Stat" );
    HRESULT sc = S_OK;
    BY_HANDLE_FILE_INFORMATION ByHandleFileInformation;
    WCHAR* pwszPath=NULL;

    STATSTG statstg;

    NFF_VALIDATE( Stat( pstatstg, grfStatFlag ) );

    statstg.pwcsName = NULL;

    Lock( INFINITE );
    nffChk( CheckReverted() );

    nffDebug((DEB_INFO, "CNtfsStorage::Stat()\n"));

    // Does the caller want a name?
    if( (STATFLAG_NONAME & grfStatFlag) )
         pwszPath = NULL;
    else
        nffChk( GetFilePath( &pwszPath ) );

    // Get the type
    statstg.type = STGTY_STORAGE;

    // Get the size & times.

    if( !GetFileInformationByHandle( _hFileMainStream,
                                     &ByHandleFileInformation ))
    {
        nffErr( EH_Err, LAST_SCODE );
    }

    statstg.cbSize.LowPart = ByHandleFileInformation.nFileSizeLow;
    statstg.cbSize.HighPart = ByHandleFileInformation.nFileSizeHigh;

    statstg.mtime = ByHandleFileInformation.ftLastWriteTime;
    statstg.atime = ByHandleFileInformation.ftLastAccessTime;
    statstg.ctime = ByHandleFileInformation.ftCreationTime;

    statstg.grfLocksSupported = 0;    // no locks supported

    // Get the STGM modes
    statstg.grfMode = _grfMode & ~STGM_CREATE;


    // Get the clsid & state bits

    statstg.grfStateBits = _dwStgStateBits;
    statstg.clsid        = _clsidStgClass;


    sc = S_OK;

    statstg.pwcsName = pwszPath;
    pwszPath = NULL;

    *pstatstg = statstg;

EH_Err:

    if(NULL != pwszPath)
        CoTaskMemFree( pwszPath);

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IBlockingLock::Lock
//
//+----------------------------------------------------------------------------

inline HRESULT
CNtfsStorage::Lock( DWORD dwTimeout )
{
    // Don't trace at this level.  The noice is too great!
    // nffCDbgTrace dbg(DEB_ITRACE, "CNtfsStorage::Lock");
    nffAssert( INFINITE == dwTimeout );
    if( INFINITE != dwTimeout )
        return( E_NOTIMPL );

    // If there was an error during Initialize(), we may not have created the tree
    // mutex.

    if( NULL == _pTreeMutex )
        return( E_NOTIMPL );
    else
        return _pTreeMutex->Lock( dwTimeout );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    IBlockingLock::Unlock
//
//+----------------------------------------------------------------------------

inline HRESULT
CNtfsStorage::Unlock()
{
    // Don't trace at this level.  The noice is too great!
    // nffCDbgTrace dbg(DEB_ITRACE, "CNtfsStorage::Unlock");

    // If there was an error during Initialize(), we may not have created the tree
    // mutex.

    if( NULL == _pTreeMutex )
        return( E_NOTIMPL );
    else
        return _pTreeMutex->Unlock();
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    ITimeAndNoticeControl::SuppressChanges
//
//  This method puts the storage in a state such that the modify timestamp
//  is not updated, and
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::SuppressChanges(
        DWORD res1,
        DWORD res2)
{
    return E_NOTIMPL;
}


//+----------------------------------------------------------------------------
//  End of Interface Methods
//     -------------
//  Start of C++ Methods.
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Constructor
//
//+----------------------------------------------------------------------------

inline
CNtfsStorage::CNtfsStorage( DWORD grfMode )
        : _sig(NTFSSTORAGE_SIG),
          CPropertySetStorage( MAPPED_STREAM_QI ),
          _PropertyBagEx( grfMode )
{
    nffITrace("CNtfsStorage::CNtfsStorage");

    _grfMode = grfMode;

    _pstmOpenList = NULL;
    _hFileMainStream    = INVALID_HANDLE_VALUE;
    _hFileControlStream = INVALID_HANDLE_VALUE;

    _wcDriveLetter = 0;
    _dwState = 0;

    _hsmStatus = 0;
    _dwStgStateBits = 0;
    _clsidStgClass = CLSID_NULL;

    _pTreeMutex = NULL;
    _filetime.dwHighDateTime = 0;
    _filetime.dwLowDateTime  = 0;

    // Finish initialization the property set objects.

    _NtfsStorageForPropSetStg.Init( this ); // Not add-refed

    CPropertySetStorage::Init( static_cast<IStorage*>(&_NtfsStorageForPropSetStg),
                               static_cast<IBlockingLock*>(this),
                               FALSE ); // fControlLifetimes (=> don't addref)

    // These are also not add-refed
    _PropertyBagEx.Init( static_cast<IPropertySetStorage*>(this),
                         static_cast<IBlockingLock*>(this) );
};


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::IsNffAppropriate
//
//  Synopsis:   Looks for Control stream and Docfile Header given a filename
//
//  Arguments:  [pwszName] - Filename.
//
//  History:    22-July-98   BChapman   Created
//              10-Nov-98    BChapman   Added global routine so it can be
//                                  called by code that doesn't include
//                                  CNtfsStorage/CNtfsStream definitions.
//+----------------------------------------------------------------------------

HRESULT IsNffAppropriate( const LPCWSTR pwcsName )
{
    return CNtfsStorage::IsNffAppropriate( pwcsName );
}

HRESULT // static
CNtfsStorage::IsNffAppropriate( const LPCWSTR pwcsName )
{
    UNICODE_STRING usNtfsName;
    LPWSTR pFreeBuffer=NULL;
    HANDLE hFile=INVALID_HANDLE_VALUE;
    HRESULT sc=S_OK;

    if (NULL == pwcsName)
        nffErr  (EH_Err, STG_E_INVALIDNAME);

    if (!RtlDosPathNameToNtPathName_U(pwcsName, &usNtfsName, NULL, NULL))
        nffErr(EH_Err, STG_E_INVALIDNAME);

    // This buffer will need free'ing later
    pFreeBuffer = usNtfsName.Buffer;

    // When Checking file state always open the main stream ReadOnly share
    // everything.  We allow opening Directories.
    //
    nffChk( OpenNtFileHandle( usNtfsName,
                              NULL,     // No Parent File Handle
                              STGM_READ | STGM_SHARE_DENY_NONE,
                              NFFOPEN_NORMAL,
                              FALSE,            // Not a Create API
                              &hFile ) );

    nffChk( IsNffAppropriate( hFile, pwcsName ) );

EH_Err:
    if (NULL != pFreeBuffer)
        RtlFreeHeap(RtlProcessHeap(), 0, pFreeBuffer);

    if( INVALID_HANDLE_VALUE != hFile )
        NtClose( hFile );

    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::IsNffAppropriate
//
//  Synopsis:   Looks for Control stream and Docfile Header given a HFILE
//
//  Arguments:  [hFile] - readable File Handle to the main stream.
//
//  History:    22-July-98   BChapman   Created
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::IsNffAppropriate( HANDLE hFile,
                                const WCHAR* wcszPath )
{
    PFILE_STREAM_INFORMATION pfsiBuf = NULL;
    ULONG cbBuf;
    OVERLAPPED olpTemp;
    HANDLE ev=NULL;
    HRESULT sc=S_OK;

    olpTemp.hEvent = NULL;


    // Check that we are on NTFS by doing a stream enum.
    // This is also useful later when looking for a control stream.
    //   PERF we should cache the fsi (reload every create or delete)
    //
    sc = EnumNtStreams( hFile, &pfsiBuf, &cbBuf, TRUE );
    if( FAILED(sc) )
    {
        nffDebug((DEB_IWARN, "EnumNtStreams Failed. Not NTFS.\n" ));
        nffErr( EH_Err,  STG_E_INVALIDFUNCTION );
    }

    // If the control stream exists then the file is NFF.

    if( IsControlStreamExtant( pfsiBuf ) )
    {
        // This is a kludge test for nt4-pre-sp4 system over the RDR.
        // We don't support NFF on those systems (because they didn't
        // allow the '\005' property set name prefix charachter).

        nffChk( TestNt4StreamNameBug( pfsiBuf, wcszPath ) );

        goto EH_Err;    // return S_OK;
    }


    // Don't read HSM migrated Files.
    //  If the test fails in any way, assume it is not an HSM file.
    //
    if( S_OK == IsOfflineFile( hFile ) )
        nffErr( EH_Err, STG_E_INCOMPLETE );

    // Check that the file is not a Storage File.  Docfile and NSS don't
    // want this implementation making NTFS streams on their files.
    //
    // To do this we need to read the main stream.

    ZeroMemory( &olpTemp, sizeof(OVERLAPPED) );

    // Create the Event for the Overlapped structure.
    //
    ev = CreateEvent( NULL,     // Security Attributes.
                      TRUE,     // Manual Reset Flag.
                      FALSE,    // Inital State = Signaled, Flag.
                      NULL );   // Name

    if( NULL == ev)
        nffErr( EH_Err, LAST_SCODE );

    olpTemp.hEvent = ev;

    // See if this is an NSS

    nffChk( StgIsStorageFileHandle( hFile, &olpTemp ) );
    if( S_OK == sc )
        nffErr (EH_Err, STG_E_INVALIDFUNCTION);

    nffAssert(S_FALSE == sc);

    // Ensure this isn't NT4-pre-SP4, where we don't
    // support NFF (that was before '\005' became a legal
    // character in stream names).

    nffChk( TestNt4StreamNameBug( pfsiBuf, wcszPath ) );

    sc = S_OK;

EH_Err:
    if( NULL != pfsiBuf )
        delete [] (BYTE *)pfsiBuf;

    if( NULL != olpTemp.hEvent )
        CloseHandle( olpTemp.hEvent );

    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::TestNt4StreamNameBug
//
//  Synopsis:   Check if a stream with a \005 in the name can be opened.
//              This routine added an extra NTCreateFile to the NFF Open
//              path.  And limits the length of the filename component to
//              MAX_PATH - StrLen(PropSetName().  This routine should be
//              eliminated as soon as NT4 Sp3 is history.
//                The bug this looking for was fixed in nt4 sp4 and Nt5.
//
//  Returns:    S_OK if the system is working correctly
//              STG_E_INVALIDFUNCTION if a \005 stream cannot be opened
//
//  Arguments:  [pfsiBuf]  - Buffer of Enumerated Stream Names.
//              [wcszPath] - Full Pathname of file.
//
//  History:    12-Oct-98   BChapman   Created
//+----------------------------------------------------------------------------

FMTID FMTID_NT4Check = { /* ffc11011-5e3b-11d2-8a3e-00c04f8eedad */
    0xffc11011,
    0x5e3b,
    0x11d2,
    {0x8a, 0x3e, 0x00, 0xc0, 0x4f, 0x8e, 0xed, 0xad}
};

HRESULT
CNtfsStorage::TestNt4StreamNameBug(
        PFILE_STREAM_INFORMATION pfsiBuf,
        const WCHAR* pwcszPath )
{
    const WCHAR* pwcszNtStreamName=NULL;
    WCHAR* pwszPathBuf=NULL;
    int ccBufSize=0;
    HANDLE hFile;
    UNICODE_STRING usNtfsName;
    OBJECT_ATTRIBUTES object_attributes;
    IO_STATUS_BLOCK iostatusblock;
    ACCESS_MASK accessmask=0;
    ULONG ulAttrs=0;
    ULONG ulSharing=0;
    ULONG ulCreateDisp=0;
    ULONG ulCreateOpt = 0;
    NTSTATUS status;
    HRESULT sc=S_OK;

    //  If there is no pathname (and in some calling paths there isn't)
    // then we can't do the test.
    //
    if( NULL == pwcszPath )
        goto EH_Err;    // S_OK

    // last ditch optimization to prevent having to do
    // the NT4 pre-sp4 stream name bug tests.
    //
    if( AreAnyNtPropertyStreamsExtant( pfsiBuf ) )
        goto EH_Err;    // S_OK
    //
    // OK here is the deal....
    // Try to open READONLY a stream that doesn't exist with a \005 in
    // the name.  If the system supports such stream names then it will
    // return filenotfound, on NT4 before sp4 it will return INVALIDNAME.
    //
    {
        CPropSetName psn( FMTID_NT4Check );
        CNtfsStreamName nsn( psn.GetPropSetName() );
        pwcszNtStreamName = nsn;

        //
        // Use the NT API so we don't have to worry about the length
        // of the name.  We have to convert the name while it is less
        // than MAX_PATH.
        //
        if (!RtlDosPathNameToNtPathName_U(pwcszPath, &usNtfsName, NULL, NULL))
            nffErr(EH_Err, STG_E_INVALIDNAME);

        //
        // Build a buffer with the Path + Stream name.  Free the
        // allocated UNICODE_STRING name and point at the buffer.
        //
        ccBufSize = usNtfsName.Length/sizeof(WCHAR)+ (ULONG)wcslen(pwcszNtStreamName) + 1;
        __try
        {
            pwszPathBuf = (WCHAR*) alloca( ccBufSize*sizeof(WCHAR) );
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, usNtfsName.Buffer);
            nffErr(EH_Err, STG_E_INSUFFICIENTMEMORY);
        }

        StringCchCopy( pwszPathBuf, ccBufSize, usNtfsName.Buffer );
        StringCchCat( pwszPathBuf, ccBufSize, pwcszNtStreamName );

        RtlFreeHeap(RtlProcessHeap(), 0, usNtfsName.Buffer);
        usNtfsName.Buffer = pwszPathBuf;
        usNtfsName.Length = (USHORT) wcslen(pwszPathBuf)*sizeof(WCHAR);
        usNtfsName.MaximumLength = (USHORT)(ccBufSize*sizeof(WCHAR));

        InitializeObjectAttributes(&object_attributes,
                                   &usNtfsName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        nffChk( ModeToNtFlags( STGM_READ|STGM_SHARE_DENY_NONE, 0, FALSE,
                               &accessmask, &ulAttrs, &ulSharing,
                               &ulCreateDisp, &ulCreateOpt ) );

        status = NtCreateFile( &hFile, accessmask,
                               &object_attributes, &iostatusblock,
                               NULL,
                               ulAttrs,      ulSharing,
                               ulCreateDisp, ulCreateOpt,
                               NULL, 0);


        nffAssert( NULL == hFile && "NFF Property TestNt4StreamNameBug" );
        if( NULL != hFile )
            CloseHandle( hFile );

        // The system doesn't support \005.
        //
        if( STATUS_OBJECT_NAME_INVALID == status )
        {
            nffDebug(( DEB_OPENS, "Nt4File: file=(%x) \"%ws\"\n",
                                pwszPathBuf, pwszPathBuf ));
            nffErr( EH_Err, STG_E_INVALIDFUNCTION );
        }

        // NOT_FOUND is the expected status for good systems.
        //
        if( STATUS_OBJECT_NAME_NOT_FOUND != status )
        {
            nffDebug(( DEB_IWARN, "NT4Chk Create Stream status 0x%x\n", status ));
            nffErr(EH_Err, STG_E_INVALIDFUNCTION);
        }
    }

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::IsOfflineFile
//
//  Synopsis:   Check for FILE_ATTRIBUTE_OFFLINE in the file attributes.
//
//  Returns:    S_OK    if the file attributes have the bit set.
//              S_FALSE if the file attributes do not have the bit set.
//              E_*     if an error occured while accessing the attributes.
//
//  Arguments:  [hFile] - Attribute Readable file handle
//
//  History:    27-July-98   BChapman   Created
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::IsOfflineFile( HANDLE hFile )
{
    HRESULT         sc=S_OK;
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatblk;
    FILE_BASIC_INFORMATION fbi;

    status = NtQueryInformationFile( hFile,
                                     &iostatblk,
                                     (PVOID) &fbi,
                                     sizeof(FILE_BASIC_INFORMATION),
                                     FileBasicInformation );

    if( !NT_SUCCESS(status) )
    {
        nffDebug(( DEB_IERROR,
                   "Query FileAttributeTagInformation file=%x, failed stat=%x\n",
                   hFile, status ));
        nffErr( EH_Err, NtStatusToScode( status ) );
    }

    // If it does not have a reparse tag, it is not HighLatency
    //
    if( 0==( FILE_ATTRIBUTE_OFFLINE & fbi.FileAttributes) )
    {
        sc = S_FALSE;
        goto EH_Err;
    }

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::InitFromName
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::InitFromName(
        const WCHAR *pwcsName,
        BOOL fCreateAPI,
        DWORD dwOpenFlags )
{
    nffITrace( "CNtfsStorage::Init (name)" );

    HANDLE hFile = INVALID_HANDLE_VALUE;
    UNICODE_STRING usNtfsName;
    WCHAR* pFreeBuffer=NULL;
    DWORD dwTid;
    HRESULT sc=S_OK;
    DWORD fCreateOrNot=0;

    if (!RtlDosPathNameToNtPathName_U(pwcsName, &usNtfsName, NULL, NULL))
        nffErr(EH_Err, STG_E_INVALIDNAME);

    // This buffer will need free'ing later
    pFreeBuffer = usNtfsName.Buffer;


    // Regardless of _grfMode, always open the unnamed stream read-only share
    // everything.  We allow opening Directories.  We use this handle to
    // dup-open all the other streams.
    //
    if( fCreateAPI && (STGM_CREATE & _grfMode) )
        fCreateOrNot = STGM_CREATE;

    nffChk( OpenNtFileHandle( usNtfsName,
                              NULL,     // No Parent File Handle
                              STGM_READ | STGM_SHARE_DENY_NONE | fCreateOrNot,
                              dwOpenFlags,
                              fCreateAPI,
                              &hFile ) );

    // Cache the drive letter so that in Stat we can compose a
    // complete path name
    _wcDriveLetter = GetDriveLetter( pwcsName );

    nffChk( InitFromMainStreamHandle( &hFile,
                                      pwcsName,
                                      fCreateAPI,
                                      dwOpenFlags,
                                      STGFMT_ANY ) );

    // hFile now belongs to the object.
    nffAssert( INVALID_HANDLE_VALUE == hFile );


EH_Err:
    if (NULL != pFreeBuffer)
        RtlFreeHeap(RtlProcessHeap(), 0, pFreeBuffer);


    if( INVALID_HANDLE_VALUE != hFile )
        NtClose( hFile );

    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::InitFromMainStreamHandle
//
//  Synopsis:   Opens NFF file from a handle.
//
//  Arguments:  [hFileMainStream] - ReadOnly DenyNone file handle.
//              [fCreateAPI]      - Called from a Create API (vs. Open)
//              [fmtKnown]        - STGFMT_FILE if IsNffAppropriate has
//                                  already been called.  STGFMT_ANY otherwise
//
//  History:    05-Jun-98   BChapman   Created
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::InitFromMainStreamHandle(
        HANDLE* phFileMainStream,
        const WCHAR* wcszPath,
        BOOL fCreateAPI,
        DWORD dwOpenFlags,
        DWORD fmtKnown )
{
    nffITrace( "CNtfsStorage::InitFromMainStreamHandle(HANDLE)" );

    HRESULT sc = S_OK;

    CNtfsStream*   pstmHeadSentinal= NULL;
    CNFFTreeMutex* pTreeMutex      = NULL;


    // Check that this file should be opened by NFF.
    // Skip the check if the caller has already figured it out.
    //
    if( STGFMT_FILE != fmtKnown )
    {
        nffChk( IsNffAppropriate( *phFileMainStream, wcszPath ) );
        fmtKnown = STGFMT_FILE;
    }

    //
    // Load the Main Stream Handle here so member functions (below)
    // can use it.
    //
    _hFileMainStream = *phFileMainStream;
    *phFileMainStream = INVALID_HANDLE_VALUE;

    // If requested, suppress changes, starting with the main stream handle
    // we just accepted.  All subsequent stream opens/creates (including the
    // Control stream) will be marked similarly.
    //
    if( NFFOPEN_SUPPRESS_CHANGES & dwOpenFlags )
        nffChk( SuppressChanges(1, 0) );

    // Open the ControlPropertySet and place the SHARE MODE locks there
    //
    nffChk( OpenControlStream( fCreateAPI ) );

    // Create a Mutex to Serialize access to the NFF File
    //
    nffMem( pTreeMutex = new CNFFTreeMutex() );
    nffChk( pTreeMutex->Init() );


    // Create an Head Sentinal for the Open Stream List
    //
    nffMem( pstmHeadSentinal = new CNtfsStream( this, pTreeMutex ) );


    // Success!
    _dwState |= NFF_INIT_COMPLETED;

    _pTreeMutex = pTreeMutex;
    pTreeMutex = NULL;

    _pstmOpenList = pstmHeadSentinal;
    pstmHeadSentinal = NULL;


EH_Err:
    if( NULL != pTreeMutex )
        pTreeMutex->Release();

    if( NULL != pstmHeadSentinal )
        pstmHeadSentinal->Release();

    return( sc );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Destructor
//
//+----------------------------------------------------------------------------

inline
CNtfsStorage::~CNtfsStorage()
{
    nffITrace("CNtfsStorage::~CNtfsStorage");

    DWORD rc, hrThread=S_OK;
    HANDLE thread;

    nffDebug(( DEB_REFCOUNT, "~CNtfsStorage\n" ));

    ShutDownStorage();

    if( NULL != _pTreeMutex )
        _pTreeMutex->Release();

    nffAssert( NULL == _pstmOpenList );

    _sig = NTFSSTORAGE_SIGDEL;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::ShutDownStorage
//
//  Flush data, Close File handle and mark the objects as reverted.
//  This is called when the Oplock Breaks and when the Storage is released.
//  In neither case does the caller hold the tree mutex.  So we take it here.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::ShutDownStorage()
{
    nffITrace( "CNtfsStorage::ShutDownStorage" );
    HRESULT sc, scAccum=S_OK;
    CNtfsStream *pstm = NULL;
    CNtfsStream *pstmNext = NULL;
    ULONG cbBuf;

    Lock( INFINITE );

    if(NFF_FILE_CLOSED & _dwState)
        goto EH_Err;

    _dwState |= NFF_FILE_CLOSED;

    nffDebug(( DEB_INFO, "CNtfsStorage::Shutdown called\n" ));

    // Shut down the property bag (it is initialized in the
    // constructor, so we need to shut it down whether or not
    // we ever completed initialization).

    if( FAILED(sc = _PropertyBagEx.ShutDown() ))
        scAccum = sc;

    // Clean up the tree mutex and open stream list, neither of which
    // will exist unless we're fully initialized.

    if(NFF_INIT_COMPLETED & _dwState)
    {

        nffAssert( NULL != _pstmOpenList );

        // Skip the head sentinal;
        pstm = _pstmOpenList->_pnffstmNext;

        //
        // Shutdown all the streams.  If there is a problem, make note of it
        // but continue until all the streams are shutdown.
        //
        while(NULL != pstm)
        {
            // ShutDown will cut itself from the list, so pick up the
            // Next pointer before calling it.
            // Let the streams go loose (don't delete or Release them)
            // the app still holds the reference (the list never had a reference)
            //
            pstmNext = pstm->_pnffstmNext;

            if( FAILED( sc = pstm->ShutDown() ) )
                scAccum = sc;

            pstm = pstmNext;
        }

        // Delete the head sentinal because it is not a stream and the
        // app doesn't have a pointer to it.
        //
        nffAssert( NULL == _pstmOpenList->_pnffstmNext );
        _pstmOpenList->Release();
        _pstmOpenList = NULL;

    }

    // Close down all the handles

    nffDebug(( DEB_OPENS, "Closing Storage w/ _hFileMainStream=%x\n",
                        _hFileMainStream ));

    if( INVALID_HANDLE_VALUE != _hFileControlStream )
    {
        CloseHandle( _hFileControlStream );
        _hFileControlStream = INVALID_HANDLE_VALUE;
    }

    if( INVALID_HANDLE_VALUE != _hFileMainStream )
    {
        CloseHandle( _hFileMainStream );
        _hFileMainStream = INVALID_HANDLE_VALUE;
    }

    _dwState |= NFF_REVERTED;


EH_Err:

    Unlock();
    return scAccum;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::GetStreamHandle
//
//  This method gets the HANDLE for the named stream.
//  It understands grfModes and RelativeOpens of a main stream handle.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::GetStreamHandle(
        HANDLE *phStream,
        const WCHAR * pwcsName,
        DWORD grfMode,
        BOOL fCreateAPI)
{
    HANDLE hFileStream = INVALID_HANDLE_VALUE;
    HRESULT sc=S_OK;
    DWORD dwNffOpenFlags=0;
    CNtfsStreamName nsn( pwcsName );

    nffDebug(( DEB_ITRACE | DEB_INFO,
             "GetStreamHandle(\"%ws\", grf=0x%x, %s)\n",
             pwcsName, grfMode, fCreateAPI?"Create":"Open" ));

    Lock( INFINITE );

    if( IsContentStream( pwcsName ) )
    {
        // The content (main) stream always exists
        //
        if( fCreateAPI && !( STGM_CREATE & grfMode ) )
            nffErr( EH_Err, STG_E_FILEALREADYEXISTS );


        // only allow DenyNone mode.
        //
        grfMode &= ~STGM_SHARE_MASK;
        grfMode |= STGM_SHARE_DENY_NONE;    // Its is already open for read.

        dwNffOpenFlags |= NFFOPEN_CONTENTSTREAM;
    }
    else    // not the content stream
    {
        // Use the given access mode but
        // Use the container's Share mode.
        //
        grfMode &= ~STGM_SHARE_MASK;
        grfMode |= _grfMode & STGM_SHARE_MASK;
    }

    //dwNffOpenFlags |= NFFOPEN_ASYNC;

    sc = OpenNtStream( nsn,            // ":name:$DATA"
                       grfMode,
                       dwNffOpenFlags,
                       fCreateAPI,
                       &hFileStream );
#if DBG==1
    if( STG_E_FILENOTFOUND == sc )
    {
        nffDebug(( DEB_IWARN, "GetStreamHandle: stream '%ws' not found\n",
                              (const WCHAR*)nsn ));
        goto EH_Err;
    }
#endif DBG
    nffChk( sc );

    *phStream = hFileStream;
    hFileStream = INVALID_HANDLE_VALUE;

EH_Err:

#if DBG==1
    if( S_OK != sc )
    {
        nffDebug(( DEB_OPENS|DEB_INFO,
                   "Open on stream '%ws' Failed\n",
                   pwcsName ));
    }
#endif
    if( INVALID_HANDLE_VALUE != hFileStream )
        NtClose( hFileStream );

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::FindAlreadyOpenStream
//
// This routine finds the previously open stream by the given name.
//
//+----------------------------------------------------------------------------

BOOL
CNtfsStorage::FindAlreadyOpenStream(
        const WCHAR* pwcsName,
        CNtfsStream** ppstm)
{
    // Skip the head sentinal.
    CNtfsStream *pstm = _pstmOpenList->_pnffstmNext;

    while(NULL != pstm)
    {
        //if( 0 == _wcsicmp(pwcsName, pstm->GetName() ) )
        if( 0 == dfwcsnicmp( pwcsName, pstm->GetName(), -1 ))
        {
            *ppstm = pstm;
            pstm->AddRef();
            return TRUE;
        }
        pstm = pstm->_pnffstmNext;
    }
    return FALSE;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::NewCNtfsStream
//
// This method lumps together the three phases of creating a new stream
// object (Constructor, Filesystem Open, and Object Initialization).  And
// it handles the special case of opening the "already open" CONTENTS stream.
// This begs the question, why is there three phases.
// 1) We can't put to much in the constructor because of the inability to
//    return errors.
// 2) GetStreamHandle and InitCNtfsStream are broken apart because of the
//    the special needs in the Storage::Init routine.  It opens the
//    CONTENT stream directly and calls InitCNtfsStream to finish.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::NewCNtfsStream( const WCHAR *pwcsName,
                              DWORD grfMode,
                              BOOL fCreateAPI,
                              CNtfsStream **ppstm )
{
    HRESULT sc=S_OK;
    HANDLE hStream = INVALID_HANDLE_VALUE;
    CNtfsStream *pstm = NULL;

    Lock( INFINITE );

    nffMem( pstm = new CNtfsStream( this, (IBlockingLock*) _pTreeMutex ) );
    nffChk( GetStreamHandle( &hStream, pwcsName, grfMode, fCreateAPI ) );
    sc = InitCNtfsStream( pstm, hStream, grfMode, pwcsName );

    hStream = INVALID_HANDLE_VALUE; // hStream now belongs the the object.
    nffChk(sc);

    // If we're creating, truncate the stream just in case we opened one
    // that already existed.

    if( fCreateAPI )
        nffChk( pstm->SetSize( CULargeInteger(0) ));

// Load Out parameters and clear working state
    *ppstm = pstm;
    pstm = NULL;

EH_Err:

    nffDebug(( DEB_ITRACE | DEB_INFO,
             "NewCNtfsStream() sc=%x. hFile=0x%x\n",
             sc,
             FAILED(sc)?INVALID_HANDLE_VALUE:(*ppstm)->GetFileHandle() ));

    if( INVALID_HANDLE_VALUE != hStream )
        NtClose( hStream );

    if( NULL != pstm )
        pstm->Release();

    Unlock();
    return( sc );
}



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface ::DestroyStreamElement
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::DestroyStreamElement( const OLECHAR *pwcsName )
{
    nffXTrace( "CNtfsStorage::DestroyStreamElement" );

    HANDLE hFileStream = INVALID_HANDLE_VALUE;
    HRESULT sc=S_OK;

    Lock( INFINITE );
    nffChk( CheckReverted() );
    nffDebug(( DEB_INFO | DEB_WRITE,
               "CNtfsStorage::DestroyStreamElement('%ws')\n",
               pwcsName));

    // Open the handle with DELETE permissions.  Write includes Delete.
    //
    nffChk( OpenNtStream( CNtfsStreamName(pwcsName),         // ":name:$Data"
                          STGM_WRITE | STGM_SHARE_DENY_NONE, // grfMode
                          NFFOPEN_SYNC,
                          FALSE,                             // not CreateAPI
                          &hFileStream ) );

    nffChk( CNtfsStream::DeleteStream( &hFileStream ));

EH_Err:

    if( INVALID_HANDLE_VALUE != hFileStream )
    {
        NtClose( hFileStream );
    }

    Unlock();
    return( sc );

}   // CNtfsStorage::DestroyStreamElement


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface ::GetFilePath
//      Helper routine for Stat.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::GetFilePath( WCHAR** ppwszPath )
{
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG cbFileNameInfo = 2*(MAX_PATH+1)+sizeof(FILE_NAME_INFORMATION);
    PFILE_NAME_INFORMATION pFileNameInfo=NULL;
    WCHAR* pwsz=NULL;

    HRESULT sc = E_FAIL;
    NTSTATUS status;

    // Query the handle for the "volume-relative" path.  This isn't
    // actually volume-relative (e.g. on a UNC path), it's actually
    // the complete path without the leading "D:" or leading "\".

    pFileNameInfo = (PFILE_NAME_INFORMATION)CoTaskMemAlloc( cbFileNameInfo );
    nffMem( pFileNameInfo );

    // Get the file name
    status = NtQueryInformationFile( _hFileMainStream,
                                    &IoStatusBlock,
                                    pFileNameInfo,
                                    cbFileNameInfo,
                                    FileNameInformation );

    if( !NT_SUCCESS(status) )
    {
        if( STATUS_BUFFER_OVERFLOW == status )
            nffErr( EH_Err, CO_E_PATHTOOLONG);
        nffErr( EH_Err, NtStatusToScode( status ) );
    }

    if( 0 == pFileNameInfo->FileNameLength )
        nffErr( EH_Err, STG_E_INVALIDHEADER );


    // Allocate and copy this filename for the return.
    //

    int cbFileName;
    int cchPrefix;

    cbFileName = pFileNameInfo->FileNameLength + (sizeof(WCHAR) * 3);

    nffMem( pwsz = (WCHAR*) CoTaskMemAlloc( cbFileName ) );

    // Start with the Drive Letter or "\" for UNC paths
    if (IsCharAlphaW(_wcDriveLetter))
    {
        pwsz[0] = _wcDriveLetter;
        pwsz[1] = L':';
        pwsz[2] = L'\0';
        cchPrefix = 2;
    }
    else
    {
        nffAssert( L'\\' == _wcDriveLetter );
        pwsz[0] = L'\\';
        pwsz[1] = L'\0';
        cchPrefix = 1;
    }

    // Copy in the File Path we got from NT.  We have a length and it is
    // not necessarily NULL terminated.
    //
    CopyMemory(&pwsz[cchPrefix],
               &pFileNameInfo->FileName,
               pFileNameInfo->FileNameLength );

    // NULL terminiate the string.  Assuming we got the length allocation
    // right, then the NULL just goes at the end.
    //
    pwsz[ cchPrefix + pFileNameInfo->FileNameLength/sizeof(WCHAR) ] = L'\0';

    // Copy the Out Params And Clear the Temporaries.
    *ppwszPath = pwsz;
    pwsz = NULL;

EH_Err:
    if( NULL != pFileNameInfo )
        CoTaskMemFree( pFileNameInfo );

    if( NULL != pwsz )
        CoTaskMemFree( pwsz );

    return sc;
}



BOOL
CNtfsStorage::IsControlStreamExtant( PFILE_STREAM_INFORMATION pfsiBuf )
{
    return IsNtStreamExtant( pfsiBuf, CNtfsStreamName( GetControlStreamName() ));
}


BOOL
CNtfsStorage::AreAnyNtPropertyStreamsExtant( PFILE_STREAM_INFORMATION pfsiBuf )
{
    return FindStreamPrefixInFSI( pfsiBuf, L":\005" );
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::OpenControlStream
//
// This stream is not a property set at the moment.  Because we put one of
// these on every file and it normally doesn't actually contain _any_ data we
// feel that the overhead of 88 bytes for an empty PPSet was too great.
//
// An important role of the control property set is to the be first stream
// (after the main stream) to be opened.  The share mode of the container is
// is expressed by the share mode of the control property set stream.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::OpenControlStream( BOOL fCreateAPI )
{
    nffITrace( "CNtfsStorage::OpenControlPropertySet" );

    HRESULT sc = S_OK;
    HANDLE hFile=INVALID_HANDLE_VALUE;
    NFFCONTROLBITS nffControlBits;
    DWORD cbDidRead=0;
    DWORD grfModeOpen=0;

    CNtfsStreamName ntfsnameControlStream( GetControlStreamName() );

    //  We shouldn't be called more than once.
    // But we can handle it correctly here.
    //
    if( INVALID_HANDLE_VALUE != _hFileControlStream )
        goto EH_Err;

    //  Add STGM_CREATE flag in the open path (this is an internal only mode
    // that uses NT's OPEN_IF).
    // Don't add it in the Create path because that would mean OverWrite.
    // Don't add it in the ReadOnly case because it would create a stream.
    //
    grfModeOpen = _grfMode;
    if( !fCreateAPI && GrfModeIsWriteable( _grfMode ) )
        grfModeOpen |= STGM_CREATE;

    sc = OpenNtStream( ntfsnameControlStream,
                       grfModeOpen,
                       NFFOPEN_SYNC,
                       fCreateAPI,
                       &hFile );

    //
    // If we are a ReadOnly Open, then it is OK to not have a
    // control stream.
    //
    if( STG_E_FILENOTFOUND == sc )
    {
        if( !fCreateAPI && !GrfModeIsWriteable( _grfMode ) )
        {
            sc = S_OK;
            goto EH_Err;
        }
    }
    nffChk(sc);

    // Set buffer to Zero so short reads are OK.
    ZeroMemory(&nffControlBits, sizeof(NFFCONTROLBITS) );

    if( !ReadFile( hFile, &nffControlBits,
                    sizeof(nffControlBits), &cbDidRead, NULL) )
    {
        nffErr(EH_Err, LAST_SCODE);
    }

    // Currently we only support version 0 control streams.
    // Note: a zero length stream is a version zero stream.
    //
    if( 0 != nffControlBits.sig)
        nffErr(EH_Err, STG_E_INVALIDHEADER);

    _dwStgStateBits = nffControlBits.bits;
    _clsidStgClass  = nffControlBits.clsid;
    _hsmStatus      = nffControlBits.hsmStatus;

    _hFileControlStream = hFile;
    hFile = INVALID_HANDLE_VALUE;

EH_Err:
    if(INVALID_HANDLE_VALUE != hFile)
        NtClose(hFile);

    return( sc );

}   // CNtfsStorage::OpenControlPropertySet



//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::WriteControlStream
//
//+----------------------------------------------------------------------------
HRESULT
CNtfsStorage::WriteControlStream()
{
    NFFCONTROLBITS nffcb;
    LONG cbToWrite=0;
    ULONG cbDidWrite=0;
    HRESULT sc=S_OK;

    nffAssert( INVALID_HANDLE_VALUE != _hFileControlStream );

    nffcb.sig = 0;
    nffcb.hsmStatus = _hsmStatus;
    nffcb.bits = _dwStgStateBits;
    nffcb.clsid = _clsidStgClass;

    // Try to save some space in the file by not writing the CLSID
    // if it is all zeros.
    //
    if( IsEqualGUID(_clsidStgClass, CLSID_NULL) )
    {
        cbToWrite = FIELD_OFFSET(NFFCONTROLBITS, clsid);
        // Assert that clsid is the last thing in the struct.
        nffAssert( sizeof(NFFCONTROLBITS) == cbToWrite+sizeof(CLSID) );
    }
    else
        cbToWrite = sizeof(NFFCONTROLBITS);

    if( -1 == SetFilePointer( _hFileControlStream, 0, NULL, FILE_BEGIN ) )
        nffErr( EH_Err, LAST_SCODE );

    if( !WriteFile( _hFileControlStream,
                    &nffcb,
                    cbToWrite,
                    &cbDidWrite,
                    NULL) )
    {
        nffErr(EH_Err, LAST_SCODE);
    }

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::StreamExists
//      The right way to do this is with enumeration.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::StreamExists( const WCHAR *pwcsName )
{
    nffITrace( "CNtfsStorage::StreamExists" );

    HANDLE hFileStream = NULL;
    HRESULT sc = S_OK;

    if( IsContentStream( pwcsName ) )
    {
        // The Contents stream always exists
        sc = S_OK;
    }
    else
    {
        sc = OpenNtStream( CNtfsStreamName(pwcsName),
                           STGM_READ_ATTRIBUTE | STGM_SHARE_DENY_NONE,
                           NFFOPEN_NORMAL,
                           FALSE,        // Not a create API.
                           &hFileStream);
        if( S_OK == sc )
        {
            NtClose( hFileStream );
        }
        else
            sc = S_FALSE;
    }
    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::SetAllStreamsTimes
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::SetAllStreamsTimes(
        const FILETIME *pctime,
        const FILETIME *patime,
        const FILETIME *pmtime)
{
    HRESULT sc=S_OK;
    HRESULT scAccum=S_OK;
    CNtfsStream *pstm = NULL;

    nffDebug(( DEB_INFO | DEB_STATCTRL | DEB_ITRACE,
             "CNtfsStorage::SetAllStreamsTimes()\n" ));

    // Set the time on the main control stream.

    if( INVALID_HANDLE_VALUE != _hFileControlStream )
    {
        sc = CNtfsStream::SetFileHandleTime( _hFileControlStream,
                                             pctime, patime, pmtime );
        if( S_OK != sc )
            scAccum = sc;
    }

    // We don't set time stamps on _hFileMainStream and _hFileOplock
    // Because they are readonly.  (and _hFileOplock is not always open)

    // Now set the time on any CNtfsStream objects we have open.

    if( NULL != _pstmOpenList )     // Skip the head sentinal;
        pstm = _pstmOpenList->_pnffstmNext;

    while(NULL != pstm)
    {
        sc = pstm->SetStreamTime( pctime, patime, pmtime );
        if( S_OK != sc )
            scAccum = sc;

        pstm = pstm->_pnffstmNext;
    }

    return scAccum;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::InitCNtfsStream
//
//  Create and Init an CNtfsStream Object.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::InitCNtfsStream(
        CNtfsStream *pstm,
        HANDLE hStream,
        DWORD grfMode,
        const WCHAR * pwcsName )
{
    nffITrace("CNtfsStorage::InitCNtfsStream");
    HRESULT sc=S_OK;

    // Attach the File Stream to the Stream Object
    nffChk( pstm->Init( hStream, grfMode, pwcsName, _pstmOpenList ) );

    sc = S_OK;

EH_Err:

    return sc;
}


//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::ModeToNtFlags
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::ModeToNtFlags(DWORD grfMode,
                            DWORD dwFlags,
                            BOOL fCreateAPI,
                            ACCESS_MASK *pam,
                            ULONG *pulAttributes,
                            ULONG *pulSharing,
                            ULONG *pulCreateDisposition,
                            ULONG *pulCreateOptions)
{
    SCODE sc=S_OK;

    nffDebug((DEB_ITRACE, "In  ModeToNtFlags("
             "%lX, %d %d, %p, %p, %p, %p, %p)\n",
             grfMode, dwFlags, fCreateAPI, pam,
             pulAttributes,        pulSharing,
             pulCreateDisposition, pulCreateOptions));

    *pam = 0;
    *pulAttributes = 0;
    *pulSharing = 0;
    *pulCreateDisposition = 0;
    *pulCreateOptions = 0;

    switch(grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE | STGM_READ_ATTRIBUTE))
    {
    case STGM_READ:
        *pam = FILE_GENERIC_READ;
        break;

    case STGM_WRITE:
        *pam = FILE_GENERIC_WRITE;
        if( 0 == (NFFOPEN_CONTENTSTREAM & dwFlags) )
            *pam |= DELETE;
        break;

    case STGM_READWRITE:
        *pam = FILE_GENERIC_READ | FILE_GENERIC_WRITE;
        if( 0 == (NFFOPEN_CONTENTSTREAM & dwFlags) )
            *pam |= DELETE;

        break;

    case STGM_READ_ATTRIBUTE:
        *pam = FILE_READ_ATTRIBUTES;
        break;

    default:
        nffErr(EH_Err, STG_E_INVALIDFLAG);
        break;
    }
    *pam |= SYNCHRONIZE;


    switch(grfMode & (STGM_SHARE_DENY_NONE | STGM_SHARE_DENY_READ |
                      STGM_SHARE_DENY_WRITE | STGM_SHARE_EXCLUSIVE))
    {
    case STGM_SHARE_DENY_READ:
        *pulSharing = FILE_SHARE_WRITE | FILE_SHARE_DELETE;
        break;
    case STGM_SHARE_DENY_WRITE:
        *pulSharing = FILE_SHARE_READ;
        break;
    case STGM_SHARE_EXCLUSIVE:
        *pulSharing = 0;
        break;
    case STGM_SHARE_DENY_NONE:
    case 0:
        *pulSharing = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
        break;

    default:
        nffErr(EH_Err, STG_E_INVALIDFLAG);
        break;
    }

    switch(grfMode & (STGM_CREATE | STGM_FAILIFTHERE | STGM_CONVERT))
    {
    case STGM_CREATE:
        if (fCreateAPI)
            *pulCreateDisposition = FILE_OVERWRITE_IF;
        else
            *pulCreateDisposition = FILE_OPEN_IF;   // Illegal but used internaly
        break;
    case STGM_FAILIFTHERE:  // this is a 0 flag
        if (fCreateAPI)
            *pulCreateDisposition = FILE_CREATE;
        else
            *pulCreateDisposition = FILE_OPEN;
        break;

    case STGM_CONVERT:
        nffDebug(( DEB_ERROR, "STGM_CONVERT illegal flag to NFF" ));
        nffErr(EH_Err, STG_E_INVALIDFLAG);
        break;

    default:
        nffErr(EH_Err, STG_E_INVALIDFLAG);
        break;
    }

    //if( NFFOPEN_SYNC & dwFlags )
        *pulCreateOptions |= FILE_SYNCHRONOUS_IO_NONALERT;

    *pulAttributes = FILE_ATTRIBUTE_NORMAL;

    sc = S_OK;

    nffDebug((DEB_ITRACE, "Out ModeToNtFlags\n"));
 EH_Err:
    return sc;
}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::OpenNtStream
//      Used by NFF to open a named stream, relative to an exiting main
//      stream handle.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::OpenNtStream( const CNtfsStreamName& nsnName,
                            DWORD grfMode,
                            DWORD dwFlags,
                            BOOL fCreateAPI,
                            HANDLE* phFile )
{
    UNICODE_STRING usNtfsStreamName;

    RtlInitUnicodeString(&usNtfsStreamName, (const WCHAR*)nsnName);

    return OpenNtFileHandle( usNtfsStreamName,
                             _hFileMainStream,
                             grfMode,
                             dwFlags,
                             fCreateAPI,
                             phFile);
}

//+----------------------------------------------------------------------------
//
//  CNtfsStorage    Non-Interface::OpenNtFileHandle
//      Common sub-code for OpenNtFile and OpenNtStream
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsStorage::OpenNtFileHandle( const UNICODE_STRING& usNtfsStreamName,
                                HANDLE hParent,
                                DWORD grfMode,
                                DWORD dwFlags,
                                BOOL fCreateAPI,
                                HANDLE *phFile)
{
    OBJECT_ATTRIBUTES object_attributes;
    IO_STATUS_BLOCK iostatusblock;
    HANDLE hStream;
    ACCESS_MASK accessmask=0;
    ULONG ulAttrs=0;
    ULONG ulSharing=0;
    ULONG ulCreateDisp=0;
    ULONG ulCreateOpt = 0;


    SCODE sc = S_OK;
    NTSTATUS status = STATUS_SUCCESS;

    nffDebug(( DEB_ITRACE | DEB_OPENS,
               "OpenNtStream(%ws, %p, %lX, %d, %p)\n",
               usNtfsStreamName.Buffer,
               hParent, grfMode,
               fCreateAPI, phFile ));

    InitializeObjectAttributes(&object_attributes,
                               (PUNICODE_STRING) &usNtfsStreamName, // cast away const
                               OBJ_CASE_INSENSITIVE,
                               hParent,
                               NULL);

    nffChk( ModeToNtFlags( grfMode, dwFlags, fCreateAPI,
                           &accessmask, &ulAttrs, &ulSharing,
                           &ulCreateDisp, &ulCreateOpt ) );

    status = NtCreateFile( &hStream, accessmask,
                           &object_attributes, &iostatusblock,
                           NULL,
                           ulAttrs,      ulSharing,
                           ulCreateDisp, ulCreateOpt,
                           NULL, 0);

    if (NT_SUCCESS(status))
    {
        *phFile = hStream;
        sc = S_OK;
    }
    else
        sc = NtStatusToScode(status);

 EH_Err:
    nffDebug(( DEB_ITRACE | DEB_OPENS,
                  "OpenNtFileHandle returns hFile=%x sc=%x status=%x\n",
                  *phFile, sc, status));

    return sc;
}



//////////////////////////////////////////////////////////////////////////
//
//  CNFFTreeMutex
//
//////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  CNFFTreeMutex   IUnknown::QueryInterface
//
//+----------------------------------------------------------------------------

HRESULT
CNFFTreeMutex::QueryInterface(
    REFIID  riid,
    void ** ppvObject
    )
{
    //nffITrace( "CNFFTreeMutex::QueryInterface");
    HRESULT sc = S_OK;

    //  ----------
    //  Validation
    //  ----------

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    *ppvObject = NULL;

    //  -----
    //  Query
    //  -----

    if( IID_IUnknown == riid || IID_IBlockingLock == riid )
    {
        *ppvObject = static_cast<IBlockingLock*>(this);
        AddRef();
    }
    else
        sc = E_NOINTERFACE;


    return( sc );

}


//+----------------------------------------------------------------------------
//
//  CNFFTreeMutex   IUnknown::AddRef
//
//+----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CNFFTreeMutex::AddRef(void)
{
    LONG lRet;

    lRet = InterlockedIncrement( &_cRefs );

    nffDebug(( DEB_REFCOUNT, "CNFFTreeMutex::AddRef(this==%x) == %d\n",
                            this, lRet));

    return( lRet );

}


//+----------------------------------------------------------------------------
//
//  CNFFTreeMutex   IUnknown::Release
//
//+----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CNFFTreeMutex::Release(void)
{
    LONG lRet;

    lRet = InterlockedDecrement( &_cRefs );

    if( 0 == lRet )
        delete this;

    nffDebug((DEB_REFCOUNT, "CNFFTreeMutex::Release(this=%x) == %d\n",
                            this, lRet));

    return( lRet );

}


//+----------------------------------------------------------------------------
//
//  CNFFTreeMutex   IBlockingLock::Lock
//
//+----------------------------------------------------------------------------

inline HRESULT
CNFFTreeMutex::Lock( DWORD dwTimeout )
{

    // Don't trace at this level.  The noice is too great!
    // nffCDbgTrace dbg(DEB_ITRACE, "CNFFTreeMutex::Lock");

    nffAssert (_fInitialized == TRUE);
    nffAssert( INFINITE == dwTimeout );
    if( INFINITE != dwTimeout )
        return( E_NOTIMPL );

    EnterCriticalSection( &_cs );
    nffDebug(( DEB_ITRACE, "Tree Locked. cnt=%d\n", _cs.RecursionCount ));
    return( S_OK );
}


//+----------------------------------------------------------------------------
//
//  CNFFTreeMutex   IBlockingLock::Unlock
//
//+----------------------------------------------------------------------------

inline HRESULT
CNFFTreeMutex::Unlock()
{
    // Don't trace at this level.  The noice is too great!
    //nffCDbgTrace dbg(DEB_ITRACE, "CNFFTreeMutex::Unlock");
    nffAssert (_fInitialized == TRUE);
    LeaveCriticalSection( &_cs );
    nffDebug(( DEB_ITRACE, "Tree Unlocked. cnt=%d\n", _cs.RecursionCount ));
    return( S_OK );
}


#if DBG
LONG
CNFFTreeMutex::GetLockCount()
{
    return( _cs.LockCount + 1 );
}
#endif // #if DBG


//////////////////////////////////////////////////////////////////////////
//
//  CNtfsEnumSTATSTG
//
//////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::QueryInterface (IUnknown)
//
//+----------------------------------------------------------------------------


HRESULT
CNtfsEnumSTATSTG::QueryInterface(
    REFIID  riid,
    void ** ppvObject
    )
{
    nffXTrace( "CNtfsEnumSTATSTG::QueryInterface" );
    HRESULT sc = S_OK;

    //  ----------
    //  Validation
    //  ----------

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----
    //  Query
    //  -----

    if( IID_IUnknown == riid || IID_IEnumSTATSTG == riid )
    {
        *ppvObject = static_cast<IEnumSTATSTG*>(this);
        AddRef();
    }
    else
    {
        *ppvObject = NULL;
        sc = E_NOINTERFACE;
    }

    return( sc );
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::AddRef (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
CNtfsEnumSTATSTG::AddRef(void)
{
    LONG lRet;

    lRet = InterlockedIncrement( &_cRefs );

    nffDebug(( DEB_REFCOUNT, "CNtfsEnumSTATSTG::AddRef(this==%x) == %d\n",
                                this, lRet));

    return( lRet );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::Release (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
CNtfsEnumSTATSTG::Release(void)
{
    LONG lRet;

    lRet = InterlockedDecrement( &_cRefs );

    nffAssert( 0 <= lRet );

    if( 0 == lRet )
        delete this;

    nffDebug((DEB_REFCOUNT, "CNtfsEnumSTATSTG::Release(this=%x) == %d\n",
                            this, lRet));


    return( lRet );

}



//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::Next (IEnumSTATSTG)
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsEnumSTATSTG::Next(ULONG celt, STATSTG *prgstatstg, ULONG *pcFetched)
{
    nffXTrace( "CNtfsEnumSTATSTG::Next" );
    HRESULT sc = S_OK;


    NFF_VALIDATE( Next(celt, prgstatstg, pcFetched ) );

    if( NULL != pcFetched )
        *pcFetched = 0;

    // Compatibility requires we return S_OK when 0 elements are requested.
    if( 0 == celt )
        return S_OK;

    _pBlockingLock->Lock( INFINITE );

    sc = _pstatstgarray->NextAt( _istatNextToRead, prgstatstg, &celt );
    if( FAILED(sc) ) goto Exit;

    _istatNextToRead += celt;

    if( NULL != pcFetched )
        *pcFetched = celt;

Exit:

    _pBlockingLock->Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::Skip (IEnumSTATSTG)
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsEnumSTATSTG::Skip(ULONG celt)
{
    nffXTrace( "CNtfsEnumSTATSTG::Skip" );
    HRESULT sc = S_OK;


    NFF_VALIDATE( Skip( celt ) );

    _pBlockingLock->Lock( INFINITE );

    // Advance the index, but not past the end of the array
    if( _istatNextToRead + celt > _pstatstgarray->GetCount() )
    {
        _istatNextToRead = _pstatstgarray->GetCount();
        sc = S_FALSE;
    }
    else
        _istatNextToRead += celt;

    _pBlockingLock->Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::Reset (IEnumSTATSTG)
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsEnumSTATSTG::Reset()
{
    nffXTrace( "CNtfsEnumSTATSTG::Reset" );
    _pBlockingLock->Lock( INFINITE );
    _istatNextToRead = 0;
    _pBlockingLock->Unlock();
    return( S_OK );

}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::Clone (IEnumSTATSTG)
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsEnumSTATSTG::Clone(IEnumSTATSTG **ppenum)
{
    nffXTrace( "CNtfsEnumSTATSTG::Clone" );
    HRESULT sc = S_OK;

    NFF_VALIDATE( Clone( ppenum ) );

    _pBlockingLock->Lock( INFINITE );

    CNtfsEnumSTATSTG *pNtfsEnumSTATSTG = new CNtfsEnumSTATSTG(*this);
    if( NULL == pNtfsEnumSTATSTG )
    {
        sc = E_OUTOFMEMORY;
        goto Exit;
    }

    *ppenum = static_cast<IEnumSTATSTG*>(pNtfsEnumSTATSTG);
    pNtfsEnumSTATSTG = NULL;

Exit:

    _pBlockingLock->Unlock();

    if( NULL != pNtfsEnumSTATSTG )
        delete pNtfsEnumSTATSTG;

    return( sc );

}

//+----------------------------------------------------------------------------
//
//  Method:     CNtfsEnumSTATSTG::ReadFileStreamInfo (private)
//
//  This method reads the FileStreamInformation from the ContentStream.  It
//  puts this buffer into a member pointer, for use in Next, etc.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsSTATSTGArray::ReadFileStreamInfo( HANDLE hFile )
{
    nffITrace( "CNtfsStorage::ReadFileStreamInfo" );

    PFILE_STREAM_INFORMATION    pStreamInfo=NULL;
    PFILE_STREAM_INFORMATION    pFSI=NULL;
    ULONG    cbBuffer=0;
    ULONG    cStreams=0;
    HRESULT  sc=S_OK;

    sc = EnumNtStreams( hFile, &pStreamInfo, &cbBuffer, TRUE );
    if( FAILED(sc) )
        return sc;

    for(pFSI=pStreamInfo ; NULL != pFSI; pFSI=NextFSI( pFSI ) )
        cStreams++;

    _pFileStreamInformation = pStreamInfo;
    _cFileStreamInformation = cStreams;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsSTATSTGArray::Init (Internal method)
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsSTATSTGArray::Init( HANDLE hFile )
{
    nffITrace( "CNtfsSTATSTGArray::Init" );
    HRESULT hr = S_OK;

    DfpAssert( NULL != _pBlockingLock );
    _pBlockingLock->Lock( INFINITE );

    if( NULL != _pFileStreamInformation )
    {
        CoTaskMemFree( _pFileStreamInformation );
        _pFileStreamInformation = NULL;
        _cFileStreamInformation = 0;
    }

    // Snapshot the stream information in _pFileStreamInformation
    hr = ReadFileStreamInfo( hFile );
    if( FAILED(hr) ) goto Exit;

Exit:

    _pBlockingLock->Unlock();
    return( hr );

}

//+----------------------------------------------------------------------------
//
//  Method:     CNtfsSTATSTGArray::NextAt
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsSTATSTGArray::NextAt( ULONG iNext, STATSTG *prgstatstg, ULONG *pcFetched )
{
    nffITrace( "CNtfsSTATSTGArray::NextAt" );
    HRESULT sc=S_OK;
    ULONG cFetched=0;
    ULONG cVisibleDataStreams=0;
    PFILE_STREAM_INFORMATION pFSI=NULL;
    const WCHAR* pwName=NULL;
    ULONG cbAlloc=0, cchLength=0;

    _pBlockingLock->Lock( INFINITE );

    // If there is nothing to do skip out early.
    if( iNext >= _cFileStreamInformation )
    {
        sc = S_FALSE;
        *pcFetched = 0;
        goto EH_Err;
    }

    // Loop through the cached stream info in _pFileStreamInformation

    for( pFSI=_pFileStreamInformation; NULL != pFSI; pFSI = NextFSI(pFSI) )
    {
        if( cFetched >= *pcFetched )
            break;                  // We are done.

        // We only handle data streams
        //
        if( !IsDataStream( pFSI ) )
            continue;

        // We hide some of the streams (like the Control Stream)
        //
        if( IsHiddenStream( pFSI ) )
        {
            continue;
        }

        // We are counting up to the requested streams.
        //
        if( iNext > cVisibleDataStreams++)
            continue;

        // Now lets unmangle the name no memory is allocated yet we just
        // move the pointer past the first ':' and return a shortened length.
        // Must be a $DATA Stream.  Also invent "CONTENTS" if necessary.
        // pwName is not null terminated.
        //
        GetNtfsUnmangledNameInfo(pFSI, &pwName, &cchLength);

        // Yes, this is a data stream that we need to return.

        // Allocate a buffer for the stream name in the statstg.  If this is
        // the unnamed stream, then we'll return it to the caller with the
        // name "Contents".

        cbAlloc = (cchLength + 1) * sizeof(WCHAR);

        //  Allocate memory, copy and null terminate the string from the FSI.
        //
        nffMem( prgstatstg[cFetched].pwcsName = (WCHAR*) CoTaskMemAlloc( cbAlloc ) );
        memcpy( prgstatstg[cFetched].pwcsName, pwName, cchLength*sizeof(WCHAR) );
        prgstatstg[cFetched].pwcsName[ cchLength ] = L'\0';


        // But Wait !!!
        // If this stream is really a non-simple property set, it's actually
        // a docfile, so let's return it as a STGTY_STORAGE, without the
        // name munging.

        if( IsDocfileStream( prgstatstg[cFetched].pwcsName ))
        {
            StringCbCopy( prgstatstg[cFetched].pwcsName,
                          cbAlloc,
                          UnmangleDocfileStreamName( prgstatstg[cFetched].pwcsName ));
            prgstatstg[cFetched].type = STGTY_STORAGE;
        }
        else
            prgstatstg[cFetched].type = STGTY_STREAM;

        // Fill in the rest of the stream information.
        prgstatstg[cFetched].cbSize.QuadPart = static_cast<ULONGLONG>(pFSI->StreamSize.QuadPart);

        // streams don't support timestamps yet
        prgstatstg[cFetched].mtime = prgstatstg[cFetched].ctime = prgstatstg[cFetched].atime = CFILETIME(0);
        prgstatstg[cFetched].grfMode = 0;
        prgstatstg[cFetched].grfLocksSupported = 0; // no locks supported 
        prgstatstg[cFetched].grfStateBits = 0;
        prgstatstg[cFetched].clsid = CLSID_NULL;
        prgstatstg[cFetched].reserved = 0;

        // Advance the index of the next index the caller wants retrieved
        iNext++;

        // Advance the count of entries read
        cFetched++;

    }

    //  ----
    //  Exit
    //  ----

    if( cFetched == *pcFetched )
        sc = S_OK;
    else
        sc = S_FALSE;

    *pcFetched = cFetched;

EH_Err:

    _pBlockingLock->Unlock();
    return( sc );

}

//+----------------------------------------------------------------------------
//
//  Routine     GetDriveLetter
//      Return the drive letter from a path, or '\' for UNC paths.
//
//+----------------------------------------------------------------------------


WCHAR GetDriveLetter (WCHAR const *pwcsName)
{
    nffITrace( "GetDriveLetter" );

    if( pwcsName == NULL )
        return( L'\0' );

    if( pwcsName[0] != L'\0' )
    {
        if( 0 == dfwcsnicmp( pwcsName, L"\\\\?\\", 4 )
            &&
            pwcsName[4] != L'\0' )
        {
            if( pwcsName[5] == L':' )
                return( pwcsName[4] );

            else if( 0 == dfwcsnicmp( pwcsName, L"\\\\?\\UNC\\", -1 ))
                return( L'\\' );

        }

        if( pwcsName[1] == L':'
            ||
            pwcsName[0] == L'\\' && pwcsName[1] == L'\\' )
        {
            return( pwcsName[0] );
        }

    }

   // No drive letter in pathname, get current drive instead

   WCHAR wcsPath[MAX_PATH];
   NTSTATUS nts = RtlGetCurrentDirectory_U (MAX_PATH*sizeof(WCHAR),wcsPath);
   if (NT_SUCCESS(nts))
       return( wcsPath[0] );


    return( L'\0' );
};




#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStorage::UseNTFS4Streams( BOOL fUseNTFS4Streams )
{
    return( E_NOTIMPL );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStorage::GetFormatVersion(WORD *pw)
{
    return( E_NOTIMPL );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStorage::SimulateLowMemory( BOOL fSimulate )
{
    return( E_NOTIMPL );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStorage::GetLockCount()
{
    return( _pTreeMutex->GetLockCount() );
}
#endif // #if DBG

#if DBG
HRESULT STDMETHODCALLTYPE
CNtfsStorage::IsDirty()
{
    return( E_NOTIMPL );
}
#endif // #if DBG


//+---------------------------------------------------------------------------
//
//  Function:   EnumNtStreams
//
//  Synopsis:   Enumerate NT stream information
//
//  Arguments:  [h] -- Handle to rename
//              [ppfsi] -- buffer to hold stream information
//              [pulBufferSize] -- size of output buffer
//              [fGrow] -- FALSE for fixed size buffer
//
//  Returns:    Appropriate status code
//
//  Notes   :
//
//  History:    1-Apr-98   HenryLee Created
//
//----------------------------------------------------------------------------

HRESULT EnumNtStreams (HANDLE h,
                       FILE_STREAM_INFORMATION ** ppfsi,
                       ULONG *pulBufferSize,
                       BOOL fGrow)
{
    HRESULT sc = S_OK;
    NTSTATUS nts;
    IO_STATUS_BLOCK iosb;

    nffAssert (pulBufferSize != NULL);
    ULONG ulStreamInfoSize = 2048;
    FILE_STREAM_INFORMATION *pfsi;

    *ppfsi = NULL;
    *pulBufferSize = 0;

    do
    {
        nffMem (pfsi = (FILE_STREAM_INFORMATION*) new BYTE[ulStreamInfoSize]);

        nts = NtQueryInformationFile(h,
                        &iosb,
                        (VOID*) pfsi,
                        ulStreamInfoSize - sizeof (L'\0'),
                        FileStreamInformation
                        );

        if ( !NT_SUCCESS(nts) )
        {
            //  We failed the call.  Free up the previous buffer and set up
            //  for another pass with a buffer twice as large

            delete [] (BYTE *)pfsi;
            pfsi = NULL;
            ulStreamInfoSize *= 2;
        }
        if (fGrow == FALSE)
            break;

    } while (nts == STATUS_BUFFER_OVERFLOW || nts == STATUS_BUFFER_TOO_SMALL);

    if (NT_SUCCESS(nts))
    {
        if (iosb.Information == 0)  // no data returned
        {
            delete [] (BYTE *) pfsi;
            *ppfsi = NULL;
            *pulBufferSize = 0;
        }
        else
        {
            *ppfsi = pfsi;
            *pulBufferSize = iosb.Status;
        }
    }
    else
    {
        sc = NtStatusToScode(nts);
    }

EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindStreamInFSI
//
//  Synopsis:   Find a Stream name in a provided Enumeration Buffer
//
//  Arguments:  [ppfsi] -- buffer that holds the stream enumeration.
//              [pwszNtStreamName] -- Name to look for, in :*:$DATA form.
//
//  Returns:    Pointer to the found element, or NULL otherwise
//
//----------------------------------------------------------------------------

const FILE_STREAM_INFORMATION *
FindStreamInFSI( IN const FILE_STREAM_INFORMATION *pfsi,
                 IN const WCHAR *pwszNtStreamName  // In :*:$data format
                )
{
    ULONG cchLength = (ULONG)wcslen(pwszNtStreamName);

    for( ; NULL != pfsi; pfsi= NextFSI(pfsi) )
    {
        if( cchLength*sizeof(WCHAR) != pfsi->StreamNameLength )
            continue;

        if( 0 == dfwcsnicmp( pwszNtStreamName, pfsi->StreamName, cchLength ))
            break;
    }

    return( pfsi );

}

//+---------------------------------------------------------------------------
//
//  Function:   IsStreamPrefixInFSI
//
//  Synopsis:   Find a Stream with the given prefix in a provided
//              Enumeration Buffer
//
//  Arguments:  [ppfsi] -- buffer that holds the stream enumeration.
//              [pwszPrefix] -- Prefix to find.
//
//  Returns:    TRUE if it finds it, FALSE otherwise.
//
//----------------------------------------------------------------------------

BOOL
FindStreamPrefixInFSI( IN const FILE_STREAM_INFORMATION *pfsi,
                       IN const WCHAR *pwszPrefix
                     )
{
    ULONG cchLength = (ULONG)wcslen(pwszPrefix);

    for( ; NULL != pfsi; pfsi= NextFSI(pfsi) )
    {
        if( cchLength*sizeof(WCHAR) > pfsi->StreamNameLength )
            continue;

        if( 0 == dfwcsnicmp( pwszPrefix, pfsi->StreamName, cchLength ))
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\chgtype.cxx ===
/*
 *  Purpose:
 *      Conversion code for coercing propvariant types.
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation
 *
 *  References:
 *      VariantChangeTypeEx conversion routine in variant.cpp
 *
 *  [Date]      [email]     [Comment]
 *  04/10/98    Puhazv      Creation.
 *
 */

#include "pch.cxx"
#include "chgtype.hxx"


/*
 -  PropVariantChangeType
 -
 *  Purpose:
 *      Conversion code for coercing propvariant types.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant from which the type should be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion. See API documentation for more info.
 *      vartype     IN      The type to coerce to.
 */

HRESULT
PropVariantChangeType( PROPVARIANT *ppvtDest,
                       CONST PROPVARIANT *ppvtSrc,
                       LCID lcid,
                       USHORT wFlags,
                       VARTYPE  vt)
{
    HRESULT hr = NOERROR;

    // Check if dest & src pointers are NULL.
    if (!ppvtDest || !ppvtSrc)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check if the type to coerce to is same as the src type
    if (vt == ppvtSrc->vt)
    {
        // No coercion is required, we can just make a copy.
        hr = PropVariantCopy (ppvtDest, ppvtSrc);
        goto Exit;
    }
    
    // If both src and destination are variants just call VariantChangeTypeEx()
    if (FIsAVariantType(ppvtSrc->vt) && FIsAVariantType(vt))
    {
        hr = PrivVariantChangeTypeEx((VARIANT *)ppvtDest, (VARIANT *)ppvtSrc, lcid, wFlags, vt);
        goto Exit;
    }

    // The target can't be a byref, and the source can't be an array.
    if ((vt &  VT_BYREF) || (ppvtSrc->vt & VT_ARRAY))
    {
        hr = DISP_E_TYPEMISMATCH;
        goto Exit;
    }

    // Do the conversion (byref sources require special handling)

    if (ppvtSrc->vt & VT_BYREF)
    {
        PROPVARIANT pvT;

        // First, convert the BYREF to non-BYREF
        // (This doesn't alloc anything, pvT should not be cleared.)

        hr = HrConvertByRef(&pvT, ppvtSrc);
        if (hr != S_OK)
            goto Exit;

        // Then do the conversion

        hr = HrConvertPVTypes (ppvtDest, &pvT, lcid, wFlags, vt);
    }
    else
    {
        // Just do the conversion

        hr = HrConvertPVTypes (ppvtDest, ppvtSrc, lcid, wFlags, vt);
    }
    
Exit:
    return (hr);
}



/*
 -  HrConvertByRef
 -
 *  Purpose:
 *      Converts Byref propvariants to non-byref propvariants.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant from which the type should be changed.
 *
 *  Note:
 *      After calling this routine, the dest points to the same memory that
 *      is referenced by the source - the external buffers are not copied.
 *      Thus the dst should not be PropVariantClear-ed.
 */

HRESULT
HrConvertByRef (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc)
{
    HRESULT hr = NOERROR;

    ZeroMemory (ppvtDest, sizeof(PROPVARIANT));

    PROPASSERT ((ppvtSrc->vt) & VT_BYREF);

    switch (ppvtSrc->vt)
    {
        case VT_BYREF | VT_I1:
            ppvtDest->cVal = *(ppvtSrc->pcVal);
            break;
            
        case VT_BYREF | VT_UI1:
            ppvtDest->bVal = *(ppvtSrc->pbVal);
            break;
        
        case VT_BYREF | VT_I2:
            ppvtDest->iVal = *(ppvtSrc->piVal);
            break;
        
        case VT_BYREF | VT_UI2:     
            ppvtDest->uiVal = *(ppvtSrc->puiVal);
            break;
        
        case VT_BYREF | VT_I4:
            ppvtDest->lVal = *(ppvtSrc->plVal);
            break;
        
        case VT_BYREF | VT_UI4:
            ppvtDest->ulVal = *(ppvtSrc->pulVal);
            break;

// These types don't exist. 
//      case VT_BYREF | VT_I8:
//          ppvtDest->hVal = *(ppvtSrc->phVal);
//          break;
//      
//      case VT_BYREF | VT_UI8 :
//          ppvtDest->uhVal = *(ppvtSrc->puhVal);
//          break;
//
        case VT_BYREF | VT_R4 :
            ppvtDest->fltVal = *(ppvtSrc->pfltVal);
            break;
        
        case VT_BYREF | VT_R8 :
            ppvtDest->dblVal = *(ppvtSrc->pdblVal);
            break;
        
        case VT_BYREF | VT_BOOL:
            ppvtDest->boolVal = *(ppvtSrc->pboolVal);
            break;
        
        case VT_BYREF | VT_DECIMAL:
            ppvtDest->decVal = *(ppvtSrc->pdecVal);
            break;
        
        case VT_BYREF | VT_ERROR :
            ppvtDest->scode = *(ppvtSrc->pscode);
            break;

        case VT_BYREF | VT_CY:
            ppvtDest->cyVal = *(ppvtSrc->pcyVal);
            break;
        
        case VT_BYREF | VT_DATE:
            ppvtDest->date = *(ppvtSrc->pdate);
            break;
        
        case VT_BYREF | VT_BSTR:
            ppvtDest->bstrVal = *(ppvtSrc->pbstrVal);
            break;
        
        case VT_BYREF | VT_UNKNOWN:
            ppvtDest->punkVal = *(ppvtSrc->ppunkVal);
            break;
        
        case VT_BYREF | VT_DISPATCH:
            ppvtDest->pdispVal = *(ppvtSrc->ppdispVal);
            break;
        
        case VT_BYREF | VT_SAFEARRAY:
            ppvtDest->parray = *(ppvtSrc->pparray);
            break;

        /*

        VT_PROPVARIANT tag is not defined? Should I use someother tag?
        
        case VT_BYREF | VT_PROPVARIANT :
            *ppvtDest = *(ppvtSrc->ppropvar);
            break;
        */
        
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

    if (hr == NOERROR /* && ppvtSrc->vt != (VT_PROPVARIANT | VT_BYREF)*/)
    {
        ppvtDest->vt = (short) (ppvtSrc->vt & ~VT_BYREF);
    }

    return (hr);
}


/*
 -  HrConvertPVTypes
 -
 *  Purpose:
 *      Conversion code for coercing propvariant types.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant from which the type should be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion. See API documentation for more info.
 *      vartype     IN      The type to coerce to.
 */

HRESULT
HrConvertPVTypes( PROPVARIANT *ppvtDest,
                  CONST PROPVARIANT *ppvtSrc,
                  LCID lcid,
                  USHORT wFlags,
                  VARTYPE  vt)
{
    HRESULT hr = NOERROR;

    
    switch (ppvtSrc->vt)
    {
        case VT_EMPTY:
            hr = HrConvFromVTEMPTY(ppvtDest, vt);
            break;

        case VT_I2:
            hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
                                   ppvtSrc->iVal, TRUE);
            break;

        case VT_I4:
            hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid,  wFlags, vt, 
                                   ppvtSrc->lVal, TRUE);
            break;

        case VT_R4:
            hr = HrGetValFromDOUBLE(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
                                    ppvtSrc->fltVal);
            break;

        case VT_R8:
            hr = HrGetValFromDOUBLE(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
                                    ppvtSrc->dblVal);
            break;

        case VT_CY:
            hr = HrConvFromVTCY(ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        case VT_DATE:
            hr = HrConvFromVTDATE(ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        case VT_BSTR:
            hr = HrConvFromVTBSTR(ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        case VT_BOOL:
            hr = HrConvFromVTBOOL(ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        case VT_DECIMAL:
            hr = HrConvFromVTDECIMAL(ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        case VT_I1:
            hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
                                   ppvtSrc->cVal, TRUE);
            break;

        case VT_UI1:
            hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
                                   ppvtSrc->bVal, FALSE);
            break;

        case VT_UI2:
            hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
                                   ppvtSrc->uiVal, FALSE);
            break;

        case VT_UI4:
            hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
                                   ppvtSrc->ulVal, FALSE);
            break;

        case VT_INT:
            hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
                                   ppvtSrc->intVal, TRUE);
            break;

        case VT_UINT:
            hr  = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
                                    ppvtSrc->uintVal, FALSE);
            break;

        case VT_DISPATCH:
            hr = HrConvFromVTDISPATCH(ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        case VT_UNKNOWN:
            hr = HrGetValFromUNK(ppvtDest, ppvtSrc->punkVal, vt);
            break;

        case VT_I8:
            hr = HrConvFromVTI8(ppvtDest, ppvtSrc, vt);
            break;

        case VT_UI8:
            hr = HrConvFromVTUI8(ppvtDest, ppvtSrc, vt);
            break;

        case VT_LPSTR:
            hr = HrConvFromVTLPSTR(ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        case VT_LPWSTR:
            hr = HrConvFromVTLPWSTR(ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        case VT_FILETIME:
            hr = HrConvFromVTFILETIME(ppvtDest, ppvtSrc, vt);
            break;

        case VT_BLOB:
            hr = HrGetValFromBLOB(ppvtDest, ppvtSrc, vt);
            break;

        case VT_STREAM:
            hr = HrGetValFromUNK(ppvtDest, ppvtSrc->pStream, vt);
            break;

        case VT_STORAGE:
            hr = HrGetValFromUNK(ppvtDest, ppvtSrc->pStorage, vt);
            break;

        case VT_STREAMED_OBJECT:
            hr = HrGetValFromUNK(ppvtDest, ppvtSrc->pStream, vt);
            break;

        case VT_STORED_OBJECT:
            hr = HrGetValFromUNK(ppvtDest, ppvtSrc->pStorage, vt);
            break;

        case VT_BLOB_OBJECT:
            hr = HrGetValFromBLOB(ppvtDest, ppvtSrc, vt);
            break;

        case VT_CF:
            hr = HrConvFromVTCF(ppvtDest, ppvtSrc, vt);
            break;

        case VT_CLSID:
            hr = HrConvFromVTCLSID(ppvtDest, ppvtSrc, vt);
            break;

        case VT_VERSIONED_STREAM:
            hr = HrConvFromVTVERSIONEDSTREAM (ppvtDest, ppvtSrc, vt);
            break;
            
        case VT_NULL:
        case VT_RECORD:
        case VT_ERROR:
        case VT_VARIANT:
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

    if (hr == NOERROR)
        ppvtDest->vt = vt;

    return hr;
}


/*
 -  FIsAVariantType
 -
 *  Purpose:
 *      Returns TRUE if the given variant type can be coerced using
 *      VariantChangeTypeEx.
 *
 *  Parameters:
 *      vt  IN      The vartype that needs to checked.
 */
 
BOOL
FIsAVariantType (VARTYPE  vt)
{
    // Remove BYREF.
    switch(vt & ~(VT_BYREF | VT_ARRAY))
    {
        case VT_NULL:
        case VT_EMPTY:
        case VT_I2:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_BSTR:
        case VT_BOOL:
        case VT_DECIMAL:
        case VT_I1:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_INT:
        case VT_UINT:
        case VT_DISPATCH:
        case VT_UNKNOWN:
        case VT_RECORD:
        case VT_ERROR:
        case VT_VARIANT:
            return (TRUE);
    }
    return (FALSE);
}

/*
 -  HrConvFromVTEMPTY
 -
 *  Purpose:
 *      Converts a propvariant of type VT_EMPTY.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      vt          IN      The type to coerce to.
 */

HRESULT 
HrConvFromVTEMPTY (PROPVARIANT *ppvtDest, VARTYPE vt)
{ 
    HRESULT hr = NOERROR;
    CHAR    *pszT;
    WCHAR   *pwszT;
    UUID    *puuidT;

    switch(vt)
    {
        case VT_I8:
        case VT_UI8:
        case VT_FILETIME:
        case VT_BLOB:
            ppvtDest->hVal.QuadPart = 0;
            break;
        
        case VT_LPSTR:
            // Alloc and Copy a NULL String
            pszT = (CHAR *)CoTaskMemAlloc(sizeof(CHAR));
            if (pszT)
            {
                pszT[0] = '\0';
                ppvtDest->pszVal = pszT;
            }
            else
                hr = E_OUTOFMEMORY;
            break;

        case VT_LPWSTR:
            // Alloc and Copy a NULL String
            pwszT = (WCHAR *)CoTaskMemAlloc(sizeof(WCHAR));
            if (pwszT)
            {
                pwszT[0] = L'\0';
                ppvtDest->pwszVal = pwszT;
            }
            else
                hr = E_OUTOFMEMORY;
            break;

        case VT_CLSID:
            // Alloc and Copy a NULL GUID
            puuidT = (CLSID *)CoTaskMemAlloc(sizeof(CLSID));
            if (puuidT)
            {
                CopyMemory (puuidT, &CLSID_NULL, sizeof(CLSID));
                ppvtDest->puuid = puuidT;
            }
            else
                hr = E_OUTOFMEMORY;
            break;

        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }
    return hr;
}


/*
 -  HrGetValFromDWORD
 -
 *  Purpose:
 *      Converts a DWORD to the requested PV type
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion. 
 *      vt          IN      The type to coerce to.
 *      dwVal       IN      Value to be converted
 *      fSigned     IN      Is the DWORD value signed?
 */

HRESULT
HrGetValFromDWORD (PROPVARIANT *ppvtDest,
                   CONST PROPVARIANT *ppvtSrc,
                   LCID lcid,
                   USHORT wFlags,
                   VARTYPE vt,
                   DWORD dwVal,
                   BOOL fSigned)
{
    HRESULT hr = NOERROR;

    PROPASSERT (FIsAVariantType(ppvtSrc->vt));
    
    switch(vt)
    {
        case VT_I8:
            if (fSigned)
                ppvtDest->hVal.QuadPart = (LONG)dwVal;
            else
                ppvtDest->hVal.QuadPart = dwVal;
            break;
            
        case VT_UI8:
            if (fSigned  && ((LONG)dwVal) < 0)
            {
                hr = DISP_E_OVERFLOW;
                break;
            }
            ppvtDest->uhVal.QuadPart = dwVal;
            break;
            
        case VT_LPSTR:
        case VT_LPWSTR:
            // Convert the Src Propvariant to a BSTR using VariantChangeTypeEx() 
            // and then convert the resultant BSTR to LPSTR/LPWSTR
            hr = HrGetValFromBSTR(ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;
            
        case VT_FILETIME:
            if (fSigned  && ((LONG)dwVal) < 0)
            {
                hr = DISP_E_OVERFLOW;
                break;
            }
            ppvtDest->filetime.dwLowDateTime = dwVal;
            ppvtDest->filetime.dwHighDateTime = 0;
            break;
            
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }
    return hr;
}


/*
 -  HrGetValFromDOUBLE
 -
 *  Purpose:
 *      Converts a DOUBLE to the requested PV type
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvari  ant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion.
 *      vt          IN      The type to coerce to.
 *      dbl         IN      Value to be converted
 */

HRESULT 
HrGetValFromDOUBLE (PROPVARIANT *ppvtDest,
                    CONST PROPVARIANT *ppvtSrc, 
                    LCID lcid,
                    USHORT wFlags,
                    VARTYPE vt,
                    DOUBLE dbl)
{ 
    HRESULT hr = NOERROR;

    PROPASSERT(FIsAVariantType(ppvtSrc->vt));

    switch(vt)
    {
        case VT_I8:
            hr = HrGetLIFromDouble(dbl, &(ppvtDest->hVal.QuadPart));
            break;

        case VT_UI8:
            hr = HrGetULIFromDouble (dbl, &(ppvtDest->uhVal.QuadPart));
            break;
            
        case VT_LPSTR:
        case VT_LPWSTR:
            // Convert the Src Propvariant to a BSTR using VariantChangeTypeEx() 
            // and then convert the resultant BSTR to LPSTR/LPWSTR
            hr = HrGetValFromBSTR (ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        case VT_FILETIME:
            hr = HrGetULIFromDouble (dbl, &(ppvtDest->uhVal.QuadPart));
            break;
              
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }
    return hr;
}


/*
 -  HrConvFromVTCY
 -
 *  Purpose:
 *      Converts a propvariant of type VT_CY.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion.
 *      vt          IN      The type to coerce to.
 */

HRESULT 
HrConvFromVTCY (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, 
                    LCID lcid, USHORT wFlags, VARTYPE vt)
{
    HRESULT hr = NOERROR;

    switch(vt)
    {
        case VT_I8:
            hr = HrGetLIFromDouble((double(ppvtSrc->cyVal.int64)/double(g_cCurrencyMultiplier)), 
                                   &(ppvtDest->hVal.QuadPart));
            break;

        case VT_FILETIME:           
        case VT_UI8:
            hr = HrGetULIFromDouble((double(ppvtSrc->cyVal.int64)/double(g_cCurrencyMultiplier)), 
                &(ppvtDest->uhVal.QuadPart));
            break;

        case VT_LPSTR:
        case VT_LPWSTR:
            // Convert the Src Propvariant to a BSTR using VariantChangeTypeEx() 
            // and then convert the resultant BSTR to LPSTR/LPWSTR
            hr = HrGetValFromBSTR (ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }
    return hr;
}


/*
 -  HrConvFromVTDATE
 -
 *  Purpose:
 *      Converts a propvariant of type VT_DATE.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion.
 *      vt          IN      The type to coerce to.
 */

HRESULT 
HrConvFromVTDATE (PROPVARIANT *ppvtDest,
                  CONST PROPVARIANT *ppvtSrc, 
                  LCID lcid,
                  USHORT wFlags, 
                  VARTYPE vt)
{ 
    HRESULT hr = NOERROR;
    switch(vt)
    {
        case VT_I8:
            hr = HrGetLIFromDouble (ppvtSrc->date, &(ppvtDest->hVal.QuadPart));
            break;

        case VT_UI8:
            hr = HrGetULIFromDouble (ppvtSrc->date, &(ppvtDest->uhVal.QuadPart));
            break;
            
        case VT_LPSTR:
        case VT_LPWSTR:
            // Convert the Src Propvariant to a BSTR using VariantChangeTypeEx() 
            // and then convert the resultant BSTR to LPSTR/LPWSTR
            hr = HrGetValFromBSTR (ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;
            
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

    return hr;
}


/*
 -  HrConvFromVTBSTR
 -
 *  Purpose:
 *      Converts a propvariant of type VT_BSTR
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion.
 *      vt          IN      The type to coerce to.
 */

HRESULT 
HrConvFromVTBSTR (PROPVARIANT *ppvtDest,
                  CONST PROPVARIANT *ppvtSrc, 
                  LCID lcid, 
                  USHORT wFlags, 
                  VARTYPE vt)
{ 
    HRESULT hr = NOERROR;
    switch(vt)
    {
        case VT_LPSTR:
            hr = HrBStrToAStr(ppvtSrc->bstrVal, &(ppvtDest->pszVal));
            break;
            
        case VT_LPWSTR:
            hr = HrBStrToWStr(ppvtSrc->bstrVal, &(ppvtDest->pwszVal));
            break;

        case VT_I8:
            hr = HrStrToULI(ppvtSrc, lcid, wFlags, TRUE, &(ppvtDest->uhVal.QuadPart));
            break;
            
        case VT_UI8:
        case VT_FILETIME:
            hr = HrStrToULI(ppvtSrc, lcid, wFlags, FALSE, &(ppvtDest->uhVal.QuadPart));
            break;

        case VT_CLSID:
            hr = HrStrToCLSID(ppvtDest, ppvtSrc);
            break;

        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }
    
    return hr;
}


/*
 -  HrConvFromVTBOOL
 -
 *  Purpose:
 *      Converts a propvariant of type VT_BOOL
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion. 
 *      vt          IN      The type to coerce to.
 */

HRESULT
HrConvFromVTBOOL (PROPVARIANT *ppvtDest,
                  CONST PROPVARIANT *ppvtSrc,
                  LCID lcid, 
                  USHORT wFlags, 
                  VARTYPE vt)
{
    HRESULT hr = NOERROR;
    BOOL    fVal= ppvtSrc->boolVal;
    
    PROPASSERT (FIsAVariantType(ppvtSrc->vt));
    
    switch(vt)
    {
        case VT_I8:
            ppvtDest->hVal.QuadPart = fVal ? VARIANT_TRUE : VARIANT_FALSE;
            break;
        
        case VT_UI8:
        case VT_FILETIME:
            ppvtDest->uhVal.QuadPart = fVal ? VARIANT_TRUE : VARIANT_FALSE;
            break;
                        
        case VT_LPSTR:
        case VT_LPWSTR:
            // Convert the Src Propvariant to a BSTR using VariantChangeTypeEx() 
            // and then convert the resultant BSTR to LPSTR/LPWSTR
            hr = HrGetValFromBSTR(ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;
            
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }
    
    return hr;
}


/*
 -  HrConvFromVTDECIMAL
 -
 *  Purpose:
 *      Converts a propvariant of type VT_DECIMAL.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion.
 *      vt          IN      The type to coerce to.
 */

HRESULT 
HrConvFromVTDECIMAL (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, 
                    LCID lcid, USHORT wFlags, VARTYPE vt)
{ 
    HRESULT hr = NOERROR;

    switch(vt)
    {
        case VT_LPSTR:
        case VT_LPWSTR:
            // Get the Src Propvariant to a BSTR using VariantChangeTypeEx() 
            // and then convert BSTR to LPSTR/LPWSTR
            hr = HrGetValFromBSTR (ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;

        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

    return hr;
}


/*
 -  HrConvFromVTDISPATCH
 -
 *  Purpose:
 *      Converts a propvariant of type VT_DISPATCH.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion.
 *      vt          IN      The type to coerce to.
 */

HRESULT
HrConvFromVTDISPATCH (PROPVARIANT *ppvtDest,
                      CONST PROPVARIANT *ppvtSrc, 
                      LCID lcid, 
                      USHORT wFlags, 
                      VARTYPE vt)
{
    VARIANT     varT;
    HRESULT     hr = NOERROR;

    switch (vt)
    {
        case VT_I8:
        case VT_UI8:
        case VT_FILETIME:
            // Extract an I4 value from the DISPATCH pointer and convert it to 
            // I64/UI64 integer
            if (wFlags & VARIANT_NOVALUEPROP)
            {
                hr = DISP_E_TYPEMISMATCH;
                break;
            }
            
            ZeroMemory(&varT, sizeof(VARIANT));
            hr = PrivVariantChangeTypeEx ((VARIANT *)&varT, (VARIANT *)ppvtSrc, lcid, wFlags, VT_I4);
            if (hr != S_OK)
                break;

            hr = HrGetValFromDWORD (ppvtDest, ppvtSrc, lcid, wFlags, vt, 
                                    varT.lVal,
                                    (vt == VT_I8) // fSigned
                                    );
            break;
            
        case VT_LPSTR:
        case VT_LPWSTR:
            hr = HrGetValFromBSTR (ppvtDest, ppvtSrc, lcid, wFlags, vt);
            break;
            
        case VT_STREAM:
        case VT_STREAMED_OBJECT:
        case VT_STORAGE:
        case VT_STORED_OBJECT:
        case VT_DISPATCH:
        case VT_UNKNOWN:
            hr = HrGetValFromUNK (ppvtDest, ppvtSrc->pdispVal, vt);
            break;
            
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

    return (hr);
}


/*
 -  HrGetValFromUNK
 -
 *  Purpose:
 *      Converts a IUNKNOWN ptr to the specified type
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      punk        IN      IUnknown pointer to be coerced
 *      vt          IN      The type to coerce to.
 */

HRESULT
HrGetValFromUNK (PROPVARIANT *ppvtDest, IUnknown *punk, VARTYPE vt)
{
    CONST IID   *piid = NULL;
    VOID        **ppvResult = NULL, *pvT = NULL;
    HRESULT     hr = NOERROR;

    if (!punk)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    switch (vt)
    {
        case VT_STREAM:
        case VT_STREAMED_OBJECT:
            piid = &IID_IStream; 
            ppvResult = (void **)&(ppvtDest->pStream);
            break;
            
        case VT_STORAGE:
        case VT_STORED_OBJECT:
            piid = &IID_IStorage;
            ppvResult = (void **)&(ppvtDest->pStorage);
            break;
            
        case VT_DISPATCH:
            piid = &IID_IDispatch;
            ppvResult = (void **)&(ppvtDest->pdispVal);
            break;
            
        case VT_UNKNOWN:
            piid = &IID_IUnknown;
            ppvResult = (void **)&(ppvtDest->punkVal);
            break;
            
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }
    if (hr != S_OK)
        goto Exit;

    hr = punk->QueryInterface(*piid, &pvT);
    if (hr != S_OK)
        goto Exit;

    *ppvResult = pvT;

Exit:
    return (hr);
}


/*
 -  HrGetValFromBSTR
 -
 *  Purpose:
 *      Converts a BSTR to the given type.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion.
 *      vt          IN      The type to coerce to.
 */

HRESULT
HrGetValFromBSTR (PROPVARIANT *ppvtDest,
                  CONST PROPVARIANT *ppvtSrc, 
                  LCID lcid, 
                  USHORT wFlags, 
                  VARTYPE vt)
{
    HRESULT     hr = NOERROR;
    PROPVARIANT pvtT;
    
    PROPASSERT(vt == VT_LPSTR || vt == VT_LPWSTR || vt == VT_BSTR);
    PROPASSERT(FIsAVariantType(ppvtSrc->vt));
    
    // Convert the src propvariant to a BSTR

    ZeroMemory (&pvtT, sizeof(PROPVARIANT));
    hr = PrivVariantChangeTypeEx( (VARIANT *)&pvtT,
                                  (VARIANT *)ppvtSrc, 
                                  lcid, 
                                  wFlags, 
                                  VT_BSTR);
    if (FAILED(hr) || !pvtT.bstrVal)
        goto Exit;

    if (vt == VT_BSTR)
    {
        ppvtDest->bstrVal = pvtT.bstrVal;
        pvtT.bstrVal = NULL;
    }
    else if (vt == VT_LPWSTR)
    {
        hr = HrBStrToWStr(pvtT.bstrVal, &(ppvtDest->pwszVal));
    }
    else
    {
        hr = HrBStrToAStr(pvtT.bstrVal, &(ppvtDest->pszVal));
    }


Exit:
    if (pvtT.bstrVal)
        PrivSysFreeString(pvtT.bstrVal);
    return (hr);
}


/*
 -  HrGetLIFromDouble
 -
 *  Purpose:
 *      Converts a double to large integer.
 *
 *  Parameters:
 *      dbl     IN  Double to be coerced.
 *      pll OUT Pointer to the resultanat LLInteger.
 */
 
HRESULT
HrGetLIFromDouble (DOUBLE dbl, LONGLONG *pll)
{
    HRESULT     hr = NOERROR;
    LONGLONG    ll, llRound;
    BOOL        fExactHalf;
    
    if (dbl > (_I64_MAX + 0.5)  || dbl < (_I64_MIN - 0.5))
    {
        hr = DISP_E_OVERFLOW;
        goto Exit;
    }

    ll = (LONGLONG) dbl;

    if (dbl < 0)
    {
        llRound = (LONGLONG)(dbl - 0.5);
        fExactHalf = ((ll - dbl) == 0.5);
    }
    else
    {
        llRound = (LONGLONG)(dbl + 0.5);
        fExactHalf = ((dbl - ll) == 0.5);
    }

    if (!fExactHalf || (ll & 0x1))
    {
        if ((dbl < 0 && llRound > ll) || (dbl > 0 && llRound < ll))
        {
            hr = DISP_E_OVERFLOW;
            goto Exit;
        }
        *pll = llRound;
    }
    else
    {
        *pll = ll;
    }
    
Exit:
    return (hr);
}


/*
 -  HrGetULIFromDouble
 -
 *  Purpose:
 *      Converts a double to unsigned large integer.
 *
 *  Parameters:
 *      dbl     IN  Double to be coerced.
 *      pull    OUT Pointer to the resultanat ULLInteger.
 */
 
HRESULT
HrGetULIFromDouble (DOUBLE dbl, ULONGLONG *pull)
{
    HRESULT     hr = NOERROR;
    ULONGLONG   ull, ullRound;
    BOOL        fExactHalf;
    
    if (dbl >= (_UI64_MAX + 0.5) || dbl < - 0.5)
    {
        hr = DISP_E_OVERFLOW;
        goto Exit;
    }

    if (dbl < 0)
    {
        // Should be between 0 and -0.5
        *pull = 0;
        goto Exit;
    }
    
    ull  = (ULONGLONG)dbl;
    ullRound = (ULONGLONG)(dbl + 0.5);

    if (ull > _I64_MAX)
    {
        hr = DISP_E_OVERFLOW; //Compiler limitation
        goto Exit;
    }
    
    fExactHalf = ((dbl - (LONGLONG)ull) == 0.5);

    if (!fExactHalf || (ull & 0x1))
    {
        if (ullRound < ull)
        {
            hr = DISP_E_OVERFLOW;
            goto Exit;
        }
        *pull = ullRound;
    }
    else
    {
        *pull = ull;
    }
    
Exit:
    return (hr);
}


/*
 -  HrConvFromVTI8
 -
 *  Purpose:
 *      Converts a propvariant of type VT_I8.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      vartype     IN      The type to coerce to.
 */
 
HRESULT
HrConvFromVTI8(PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{

    LONGLONG    llSrc = ppvtSrc->hVal.QuadPart;
    LONGLONG    llSrcCurrency;
    HRESULT     hr = NOERROR;
    
    switch (vt)
    {
        case VT_I2:
            if (llSrc > _I16_MAX || llSrc < _I16_MIN)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->iVal = (__int16) llSrc;
            break;
            
        case VT_I4:
            if (llSrc > _I32_MAX || llSrc < _I32_MIN)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->lVal = (__int32) llSrc;
            break;

        case VT_R4:
            ppvtDest->fltVal = (float) llSrc;
            break;
            
        case VT_R8:
            ppvtDest->dblVal = (double) llSrc;
            break;

        case VT_CY:
            llSrcCurrency = llSrc * g_cCurrencyMultiplier;
            if ((llSrc > 0 && llSrcCurrency < llSrc) ||
                (llSrc < 0 && llSrcCurrency > llSrc))
                hr = DISP_E_OVERFLOW;
            else
                ppvtDest->cyVal.int64 = llSrcCurrency;
            break;

        case VT_BSTR:
        case VT_LPSTR:
        case VT_LPWSTR:
            hr = HrULIToStr (ppvtDest, ppvtSrc, vt);
            break;
            
        case VT_BOOL:
            ppvtDest->boolVal = llSrc ? VARIANT_TRUE : VARIANT_FALSE;
            break;
        
        case VT_I1:
            if (llSrc > _I8_MAX || llSrc < _I8_MIN)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->cVal = (__int8)llSrc;
            break;

        case VT_UI1:
            if (llSrc > _UI8_MAX || llSrc < 0)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->bVal = (BYTE)llSrc;
            break;

        case VT_UI2:
            if (llSrc > _UI16_MAX || llSrc < 0)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->uiVal = (USHORT) llSrc;
            break;

        case VT_INT:
            if (llSrc > INT_MAX || llSrc < INT_MIN)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->intVal = (INT)llSrc;
            break;

        case VT_UINT:
            if (llSrc > UINT_MAX || llSrc < 0)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->uintVal = (UINT)llSrc;
            break;

        case VT_UI4:
            if (llSrc > _UI32_MAX || llSrc < 0)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->ulVal = (ULONG) llSrc;
            break;

        case VT_UI8:
        case VT_FILETIME:
            if (llSrc < 0)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->uhVal.QuadPart = llSrc;
            break;

        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

    return (hr);
}


/*
 -  HrConvFromVTUI8
 -
 *  Purpose:
 *      Converts a propvariant of type VT_UI8.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      vt          IN      The type to coerce to.
 */

HRESULT
HrConvFromVTUI8(PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{

    ULONGLONG   ullSrc = ppvtSrc->uhVal.QuadPart;
    ULONGLONG   ullSrcCurrency;
    HRESULT     hr = NOERROR;
    
    switch (vt)
    {
        case VT_I2:
            if (ullSrc > _I16_MAX)
                hr = DISP_E_OVERFLOW;
            else        
                ppvtDest->iVal = (__int16) ullSrc;
            break;
            
        case VT_I4:
            if (ullSrc > _I32_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->lVal = (__int32)ullSrc;
            break;

        case VT_R4:
            if (ullSrc > _I64_MAX)
                hr = DISP_E_OVERFLOW; //Compiler limitation
            else
                ppvtDest->fltVal = (float)(LONGLONG) ullSrc;
            break;
            
        case VT_R8:
            if (ullSrc > _I64_MAX)
                hr = DISP_E_OVERFLOW; //Compiler limitation
            else
                ppvtDest->dblVal = (double)(LONGLONG) ullSrc;
            break;

        case VT_CY:
            ullSrcCurrency = ullSrc * g_cCurrencyMultiplier;
            if (ullSrcCurrency < ullSrc || ullSrcCurrency > _I64_MAX)
                hr = DISP_E_OVERFLOW;
            else
                ppvtDest->cyVal.int64 = ullSrcCurrency;
            break;

        case VT_BSTR:
        case VT_LPSTR:
        case VT_LPWSTR:
            hr = HrULIToStr (ppvtDest, ppvtSrc, vt);
            break;
            
        case VT_BOOL:
            ppvtDest->boolVal = ullSrc ? VARIANT_TRUE : VARIANT_FALSE;
            break;
        
        case VT_I1:
            if (ullSrc > _I8_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->cVal = (__int8)ullSrc;
            break;

        case VT_UI1:
            if (ullSrc > _UI8_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->bVal = (UCHAR)ullSrc;
            break;

        case VT_UI2:
            if (ullSrc > _UI16_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->uiVal = (USHORT) ullSrc;
            break;

        case VT_INT:
            if (ullSrc > INT_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->intVal = (INT)ullSrc;
            break;

        case VT_UINT:
            if (ullSrc > UINT_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->uintVal = (UINT)ullSrc;
            break;

        case VT_UI4:
            if (ullSrc > _UI32_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->ulVal = (ULONG)ullSrc;
            break;

        case VT_I8:
            if (ullSrc > _I64_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->hVal = ppvtSrc->hVal;
            break;
            
        case VT_FILETIME:
            ppvtDest->uhVal = ppvtSrc->uhVal;
            break;

        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

    return (hr);
}


/*
 -  HrConvFromVTLPSTR
 -
 *  Purpose:
 *      Converts a propvariant of type VT_LPSTR.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion. See API documentation for more info.
 *      vt          IN      The type to coerce to.
 */

HRESULT
HrConvFromVTLPSTR (PROPVARIANT *ppvtDest,
                   CONST PROPVARIANT *ppvtSrc, 
                   LCID lcid,
                   USHORT wFlags, 
                   VARTYPE vt)
{
    HRESULT hr = NOERROR;
    BSTR    bstrT = NULL;
    VARIANT var;
    
    switch (vt)
    {
        case VT_NULL:
        case VT_EMPTY:
        case VT_I2:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_BSTR:
        case VT_BOOL:
        case VT_DECIMAL:
        case VT_I1:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_INT:
        case VT_UINT:
        case VT_UNKNOWN:
        case VT_RECORD:
        case VT_DISPATCH:
        case VT_ERROR:
        case VT_VARIANT:
            // Convert LPSTR to BSTR and call VariantChangeTypeEx()
            hr = HrAStrToBStr (ppvtSrc->pszVal, &bstrT);
            if (hr != S_OK)
                goto Exit;

            var.vt = VT_BSTR;
            var.bstrVal = bstrT;
            hr = PrivVariantChangeTypeEx((VARIANT *)ppvtDest, &var, lcid, wFlags, vt);
            break;
            
        case VT_I8:
            hr = HrStrToULI(ppvtSrc, lcid, wFlags, TRUE, (ULONGLONG *)&(ppvtDest->hVal.QuadPart));
            break;
            
        case VT_UI8:
        case VT_FILETIME:
            hr = HrStrToULI(ppvtSrc, lcid, wFlags, FALSE, &(ppvtDest->uhVal.QuadPart));
            break;
            
        case VT_LPWSTR:
            hr = HrAStrToWStr(ppvtSrc->pszVal, &(ppvtDest->pwszVal));
            break;

        case VT_CLSID:
            hr = HrStrToCLSID (ppvtDest, ppvtSrc);
            break;
            
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

Exit:
    if (bstrT)
        PrivSysFreeString (bstrT);
    return (hr);
}



/*
 -  HrConvFromVTLPWSTR
 -
 *  Purpose:
 *      Converts a propvariant of type VT_LPWSTR.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion. See API documentation for more info.
 *      vt          IN      The type to coerce to.
 */

HRESULT
HrConvFromVTLPWSTR (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, LCID lcid, USHORT wFlags, VARTYPE vt)
{
    VARIANT var; 
    BSTR    bstrT = NULL;
    WCHAR   *pwszVal = NULL;
    HRESULT hr = NOERROR;

    PrivVariantInit( &var );
    
    switch (vt)
    {
        case VT_NULL:
        case VT_EMPTY:
        case VT_I2:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_BSTR:
        case VT_BOOL:
        case VT_DECIMAL:
        case VT_I1:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_INT:
        case VT_UINT:
        case VT_UNKNOWN:
        case VT_RECORD:
        case VT_DISPATCH:
        case VT_ERROR:
        case VT_VARIANT:
            // Convert LPWSTR to BSTR and call VariantChangeTypeEx()
            hr = HrWStrToBStr (ppvtSrc->pwszVal, &bstrT);
            if (hr != S_OK)
                goto Exit;

            var.vt = VT_BSTR;
            var.bstrVal = bstrT;
            hr = PrivVariantChangeTypeEx ((VARIANT *)ppvtDest, &var, lcid, wFlags, vt);

            break;
            
        case VT_I8:
            hr = HrStrToULI (ppvtSrc, lcid, wFlags, TRUE, (ULONGLONG *) &(ppvtDest->hVal.QuadPart));
            break;
            
        case VT_UI8:
        case VT_FILETIME:
            hr = HrStrToULI (ppvtSrc, lcid, wFlags, FALSE, &(ppvtDest->uhVal.QuadPart));
            break;
            
        case VT_LPSTR:
            hr = HrWStrToAStr (ppvtSrc->pwszVal, &(ppvtDest->pszVal));
            break;
    
        case VT_CLSID:
            hr = HrStrToCLSID (ppvtDest, ppvtSrc);
            break;

        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }
Exit:
    PrivVariantClear( &var );
    return (hr);
}



/*
 -  HrConvFromVTFILETIME
 -
 *  Purpose:
 *      Converts a propvariant of type VT_FILETIME.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      vt          IN      The type to coerce to.
 */

HRESULT
HrConvFromVTFILETIME(PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{

    // get the filetime value as 64bit unsigned.
    ULONGLONG   ullSrc = ((ULARGE_INTEGER *)&(ppvtSrc->filetime))->QuadPart;
    HRESULT     hr = NOERROR;
    
    switch (vt)
    {
        case VT_I2:
            if (ullSrc > _I16_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->iVal = (__int16) ullSrc;
            break;
            
        case VT_I4:
            if (ullSrc > _I32_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->lVal = (__int32)ullSrc;
            break;

        case VT_R4:
            if (ullSrc > _I64_MAX)
                hr = DISP_E_OVERFLOW; //Compiler limitation
            else
                ppvtDest->fltVal = (float)(LONGLONG) ullSrc;
            break;

        case VT_R8:
            if (ullSrc > _I64_MAX)
                hr = DISP_E_OVERFLOW; //Compiler limitation
            else
                ppvtDest->dblVal = (double)(LONGLONG) ullSrc;
            break;

        case VT_CY:
            if (ullSrc > _I64_MAX || (ullSrc * g_cCurrencyMultiplier) > _I64_MAX)
                hr = DISP_E_OVERFLOW;
            else
                ppvtDest->cyVal.int64 = ullSrc * g_cCurrencyMultiplier;
            break;

        case VT_BOOL:
            ppvtDest->boolVal = ullSrc ? VARIANT_TRUE : VARIANT_FALSE;
            break;
        
        case VT_I1:
            if (ullSrc > _I8_MAX)
                hr = DISP_E_OVERFLOW;
            else
                ppvtDest->iVal = (__int8)ullSrc;
            break;

        case VT_UI1:
            if (ullSrc > _UI8_MAX)
                hr = DISP_E_OVERFLOW;
            else
                ppvtDest->bVal = (UCHAR)ullSrc;
            break;

        case VT_UI2:
            if (ullSrc > _UI16_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->uiVal = (USHORT) ullSrc;
            break;

        case VT_INT:
            if (ullSrc > INT_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->intVal = (INT)ullSrc;
            break;

        case VT_UINT:
            if (ullSrc > UINT_MAX)
                hr = DISP_E_OVERFLOW;
            else
                ppvtDest->uintVal = (UINT)ullSrc;
            break;

        case VT_UI4:
            if (ullSrc > _I32_MAX)
                hr = DISP_E_OVERFLOW;
            else            
                ppvtDest->ulVal = (ULONG)ullSrc;
            break;

        case VT_I8:
            if (ullSrc > _I64_MAX)
                hr = DISP_E_OVERFLOW;
            else
                ppvtDest->hVal.QuadPart = (LONGLONG)ullSrc;
            break;
            
        case VT_UI8:
            ppvtDest->uhVal.QuadPart = ullSrc;
            break;

        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }
    return (hr);
}


/*
 -  HrGetValFromBLOB
 -
 *  Purpose:
 *      Converts a propvariant of type VT_BLOB.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion. See API documentation for more info.
 *      vt          IN      The type to coerce to.
 */

HRESULT
HrGetValFromBLOB(PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{
    HRESULT hr = NOERROR;
    BLOB    blobT;
    
    switch (vt)
    {
        case VT_BLOB:
        case VT_BLOB_OBJECT:
            // Check if the size is zero.
            if (ppvtSrc->blob.cbSize == 0)
            {
                PROPASSERT (ppvtSrc->blob.pBlobData == NULL);
                ppvtDest->blob.pBlobData = NULL;
                ppvtDest->blob.cbSize = 0;
                goto Exit;
            }

            // Allocate BLOB and copy data.
            blobT.cbSize = (ppvtSrc->blob).cbSize;
            blobT.pBlobData = (BYTE *) CoTaskMemAlloc((ppvtSrc->blob).cbSize);
            if (blobT.pBlobData == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            CopyMemory (blobT.pBlobData, (ppvtSrc->blob).pBlobData, (ppvtSrc->blob).cbSize);
            ppvtDest->blob = blobT;
            break;
            
        case VT_UI1 | VT_ARRAY:
            hr = PBToSafeArray ((ppvtSrc->blob).cbSize, (ppvtSrc->blob).pBlobData, &(ppvtDest->parray));
            break;
            
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

Exit:
    return (hr);
}


/*
 -  HrConvFromVTCF
 -
 *  Purpose:
 *      Converts a propvariant of type VT_CF.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant to be coerced.
 *      vt          IN      The type to coerce to.
 */
 
HRESULT
HrConvFromVTCF(PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{
    HRESULT     hr = NOERROR;
    CLIPDATA    *pclip = NULL;
    
    switch (vt)
    {
        case VT_ARRAY | VT_UI1:
            // Convert Clipdata to unsigned one byte array.
            hr = CFToSafeArray (ppvtSrc->pclipdata, &(ppvtDest->parray));
            break;
            
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

    if (pclip)
        CoTaskMemFree(pclip);
    return (hr);
}


/*
 -  HrConvFromVTCLSID
 -
 *  Purpose:
 *      Converts a propvariant of type VT_CLSID.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant from which the type should be coerced.
 *      vt          IN      The type to coerce to.
 */

HRESULT
HrConvFromVTCLSID (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{
    HRESULT hr = NOERROR;
    
    switch (vt)
    {
        case VT_BSTR:
        case VT_LPSTR:
        case VT_LPWSTR:
            hr = HrCLSIDToStr (ppvtDest, ppvtSrc, vt);
            break;
            
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }
    return (hr);
}


/*
 -  HrConvFromVTVERSIONEDSTREAM
 -
 *  Purpose:
 *      Converts a propvariant of type VT_VERSIONEDSTREAM.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant from which the type should be coerced.
 *      vt          IN      The type to coerce to.
 */
HRESULT
HrConvFromVTVERSIONEDSTREAM (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{
    HRESULT             hr = NOERROR;
    PROPVARIANT         rgpvar[2];
    PROPVARIANT         pvtT;
    SAFEARRAYBOUND      sabound;
    SAFEARRAY           *psaT;

    memset( rgpvar, 0, sizeof(rgpvar) );

    switch (vt)
    {
            
        case VT_ARRAY | VT_VARIANT:

            // Convert the CLSID to string
            pvtT.vt = VT_CLSID;
            pvtT.puuid = &(ppvtSrc->pVersionedStream->guidVersion);
            hr = HrCLSIDToStr(&rgpvar[0], &pvtT, VT_BSTR);
            if (hr != S_OK)
                goto Exit;
            PROPASSERT (rgpvar[0].bstrVal);
            
            // Get IStream as IUnknown
            hr = HrGetValFromUNK (&rgpvar[1], ppvtSrc->pVersionedStream->pStream,
                        VT_UNKNOWN);
            if (hr != S_OK)
                goto Exit;
            PROPASSERT (rgpvar[1].punkVal);

            // Build the safearray

            sabound.lLbound = 0;
            sabound.cElements = 2;

            psaT = PrivSafeArrayCreate(VT_VARIANT, 1, &sabound );
            if(psaT == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            // Copy the propvariants to the safe array.
            PROPASSERT(psaT->pvData);
            CopyMemory(psaT->pvData, rgpvar, 2 * sizeof(PROPVARIANT));
            ppvtDest->parray = psaT;
            psaT = NULL;

            // Null out all temp params
            rgpvar[0].bstrVal = NULL;
            rgpvar[1].punkVal = NULL;
            break;
                
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

Exit:
    if (rgpvar[0].bstrVal)
        PrivSysFreeString(rgpvar[0].bstrVal);
    if (rgpvar[1].punkVal)
        (rgpvar[1].punkVal)->Release();
        
    return (hr);
}


/*
 -  HrConvFromVTVECTOR
 -
 *  Purpose:
 *      Converts a propvariant of type VT_VECTOR.
 *
 *  Parameters:
 *      ppvtDest    OUT     Resultant Propvariant with the new type
 *      ppvtSrc     IN      Source propvariant from which the type should be coerced.
 *      vt          IN      The type to coerce to.
 */
 
HRESULT
HrConvFromVTVECTOR (PROPVARIANT *, CONST PROPVARIANT *, VARTYPE)
{
    // Brian Chapman has implemented this conversion.
    return (NOERROR);
}

/*
 -  HrStrToClsid
 -
 *  Purpose:
 *      Converts a string to GUID
 *
 *  Parameters:
 *      ppvtDest    OUT Dest Propvariant with the CLSID.
 *      ppvtSrc     IN  Propvariant with the string to be converted.
 */
 
HRESULT
HrStrToCLSID (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc)
{
    WCHAR   *pwszT = NULL;
    BOOL    fAllocated = FALSE;
    CLSID   clsid, *puuidT = NULL;
    HRESULT hr = NOERROR;
    

    // This routine converts only strings to CLSID.
    PROPASSERT (ppvtSrc->vt == VT_LPSTR  || 
                ppvtSrc->vt == VT_LPWSTR || 
                ppvtSrc->vt == VT_BSTR);

    // Convert the src type to a WSTR
    switch(ppvtSrc->vt)
    {
        case VT_LPSTR:
            hr = HrAStrToWStr(ppvtSrc->pszVal, &pwszT);
            if (hr != S_OK)
                goto Exit;
            fAllocated = TRUE;
            break;
            
        case VT_LPWSTR:
            pwszT = ppvtSrc->pwszVal;
            break;
            
        case VT_BSTR:
            pwszT = ppvtSrc->bstrVal;
            break;
    }

    // We should have a NON-NULL wide char string here.
    if (!pwszT)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Convert WSTR to CLSID    
    hr  = CLSIDFromString(pwszT, &clsid);
    if (hr != S_OK) 
        goto Exit;

    // Allocate memory and copy the GUID.
    puuidT = (CLSID *)CoTaskMemAlloc (sizeof(CLSID));
    if (!puuidT)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    CopyMemory(puuidT, &clsid, sizeof (CLSID));
    ppvtDest->puuid = puuidT;
    puuidT = NULL;

Exit:
    if (fAllocated)
        CoTaskMemFree(pwszT);
    return (hr);
}


/*
 -  HrClsidToStr
 -
 *  Purpose:
 *      Converts a GUID to a string
 *
 *  Parameters:
 *      ppvtDest    OUT Dest Propvariant with the CLSID.
 *      ppvtSrc     IN  Propvariant with the string to be converted.
 *      vt          IN  Type to coerce to.
 */
 
HRESULT
HrCLSIDToStr (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{

    HRESULT hr = NOERROR;
    WCHAR   *pwszT = NULL;
    
    PROPASSERT (vt == VT_LPSTR || vt == VT_LPWSTR || vt == VT_BSTR);

    // Convert CLSID to WSTR
    hr  = StringFromCLSID (*(ppvtSrc->puuid), &pwszT);
    if (hr != S_OK) 
        goto Exit;

    switch(vt)
    {
        case VT_LPSTR:
            hr = HrWStrToAStr(pwszT, &(ppvtDest->pszVal));
            if (hr != S_OK)
                goto Exit;
            break;
            
        case VT_LPWSTR:
            ppvtDest->pwszVal = pwszT;
            pwszT = NULL;
            break;
            
        case VT_BSTR:
            hr = HrWStrToBStr(pwszT, &(ppvtDest->bstrVal));
            if (hr != S_OK)
                goto Exit;
            break;
    }

Exit:
    if (pwszT)
        CoTaskMemFree(pwszT);
    return (hr);
}



/*
 -  HrStrToULI
 -
 *  Purpose:
 *      Converts a string to ULI
 *
 *  Parameters:
 *      ppvtDest    OUT Dest Propvariant with the CLSID.
 *      lcid        IN      Locale Id
 *      wFlags      IN      Flags to control coercion. See API documentation for more info.
 *      fSigned     IN      Is the output LL signed?
 *      puli        OUT     Pointer to ULI to receive the resultant value
 *
 */
 
HRESULT
HrStrToULI (CONST PROPVARIANT *ppvtSrc, LCID lcid, USHORT wFlags, 
            BOOL fSigned, ULONGLONG *puli)
{

    HRESULT     hr = NOERROR;
    BSTR        bstrT = NULL;
    VARIANT     varSrcT = {0}, varDestT = {0};
    BOOL        fAllocated = FALSE;

    switch (ppvtSrc->vt)
    {
        case VT_LPSTR:
            hr = HrAStrToBStr(ppvtSrc->pszVal, &bstrT);
            if (hr != S_OK)
                goto Exit;
            PROPASSERT (bstrT);
            fAllocated = TRUE;
            break;
                
        case VT_LPWSTR:
            hr = HrWStrToBStr(ppvtSrc->pwszVal, &bstrT);
            if (hr != S_OK)
                goto Exit;
            PROPASSERT (bstrT);
            fAllocated = TRUE;
            break;

        case VT_BSTR:
            bstrT = ppvtSrc->bstrVal;
            fAllocated = FALSE;
            break;

        default:
            PROPASSERT(0);
            break;
    }

    varSrcT.vt = VT_BSTR;
    varSrcT.bstrVal = bstrT;
    hr = PrivVariantChangeTypeEx (&varDestT, &varSrcT, lcid, wFlags, VT_R8);
    if (FAILED(hr))
        goto Exit;

    if (fSigned)
    {
        hr = HrGetLIFromDouble(varDestT.dblVal, (LONGLONG *)puli);
    }
    else
    {
        hr = HrGetULIFromDouble(varDestT.dblVal, puli);
    }
    
    
Exit:
    if (fAllocated)
    {
        PrivSysFreeString(bstrT);
    }
    return (hr);
}


/*
 -  HrULIToStr
 -
 *  Purpose:
 *      Converts an ULI to a STR (Ascii/BSTR/WSTR)
 *
 *  Parameters:
 *      ppvtDest    IN  Propvariant to receive the coerced type.
 *      ppvtSrc     IN  Propvariant to be coerced.
 *      vt          IN  The type to be coerced to.
 */
 
HRESULT
HrULIToStr (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{
    HRESULT     hr = NOERROR;
    CHAR        sz[256], *pszT;
    WCHAR       wsz[256], *pwszT;
    BSTR        bstrT;
    BOOL        fNegative = FALSE;
    ULONGLONG   ull;
    DWORD       dw;

    if (ppvtSrc->vt == VT_I8)
    {
        fNegative = ppvtSrc->hVal.QuadPart < 0;
        ull = ppvtSrc->hVal.QuadPart;
    }
    else
    {
        PROPASSERT (ppvtSrc->vt == VT_UI8 || ppvtSrc->vt == VT_FILETIME);
        ull = ppvtSrc->uhVal.QuadPart;
    }

    switch (vt)
    {
        case VT_LPSTR:
            dw = DwULIToAStr(ull, sz, fNegative);
            pszT = (CHAR *) CoTaskMemAlloc (dw * sizeof (CHAR));
            if (!pszT)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            CopyMemory (pszT, sz, dw * sizeof (CHAR));
            ppvtDest->pszVal = pszT;
            pszT = NULL;
            break;
            
        case VT_LPWSTR:
            dw = DwULIToWStr (ull, wsz, fNegative); 
            pwszT = (WCHAR *) CoTaskMemAlloc (dw * sizeof (WCHAR));
            if (!pwszT)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            CopyMemory (pwszT, wsz, dw * sizeof (WCHAR));
            ppvtDest->pwszVal = pwszT;
            pwszT = NULL;
            break;
            
        case VT_BSTR:
            dw = DwULIToWStr(ull, wsz, fNegative);  
            bstrT = PrivSysAllocString (wsz);
            if (!bstrT)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            ppvtDest->bstrVal = bstrT;
            break;
    }
    
Exit:
    return (hr);
}


/*
 -  DwULIToAStr
 -
 *  Purpose:
 *      Converts an ULI to an Ascii STR
 *
 *  Parameters:
 *      ullVal      IN  ULONGLONG value to be converted
 *      pszBuf      OUT Output buffer - Should have been allocated before.
 *      fNegative   IN  Is the number negative
 */
 
DWORD
DwULIToAStr (ULONGLONG ullVal, CHAR *pszBuf, BOOL fNegative)
{
    CHAR    *pch, *pchFirstDigit, chT;
    BYTE    bDigit;
    DWORD   cchWritten;

    pch = pszBuf;
    
    // If the value is negative, put a '-' sign.

    if (fNegative)
    {
        PROPASSERT(((LONGLONG)ullVal) < 0);
        *pch++ = '-';
        ullVal = -(LONGLONG)ullVal;
    }
    pchFirstDigit = pch;
    
    // Write the digits to pszBuf in reverse order
    // (lowest order digit first)
    do
    {
        bDigit = (BYTE)(ullVal % 10);
        ullVal /= 10;
        *pch++ = (CHAR) (bDigit + '0');
    }
    while (ullVal > 0);

    // Terminate the string

    *pch = 0;
    cchWritten = (DWORD)(pch - pszBuf + 1);
    
    // Swap the order of the digits (so that the high order
    // digit is first, low order digit is last).

    pch--;
    do 
    {
        chT = *pch; *pch = *pchFirstDigit; *pchFirstDigit = chT;
        --pch; ++pchFirstDigit;    
    } 
    while (pchFirstDigit < pch); 

    return (cchWritten);
}


/*
 -  DwULIToWStr
 -
 *  Purpose:
 *      Converts an ULI to a WSTR
 *
 *  Parameters:
 *      ullVal      IN  ULONGLONG value to be converted
 *      pwszBuf     OUT Output buffer - Should have been allocated before.
 *      fNegative   IN  Is the number negative
 */
 
DWORD
DwULIToWStr (ULONGLONG ullVal, WCHAR *pwszBuf, BOOL fNegative)
{
    WCHAR   *pwch, *pwchFirstDigit, wchT;
    BYTE    bDigit;
    DWORD   cchWritten;

    pwch = pwszBuf;

    // If the number is negative, add a '-' char to the out string.

    if (fNegative)
    {
        PROPASSERT(((LONGLONG)ullVal) < 0);
        *pwch++ = L'-';
        ullVal = -(LONGLONG)ullVal;
    }

    // Write the digits to pwszBuf in reverse order
    // (lowest order digit first)

    pwchFirstDigit = pwch;
    do
    {
        bDigit = (BYTE)(ullVal % 10);
        ullVal /= 10;
        *pwch++ = (WCHAR)(bDigit + L'0');
    }
    while (ullVal > 0);

    // Terminate the string

    *pwch = 0;
    cchWritten = (DWORD)(pwch - pwszBuf + 1);
    
    // Swap the order of the digits (so that the high order
    // digit is first, low order digit is last).

    pwch--;
    do 
    {
        wchT = *pwch; *pwch = *pwchFirstDigit; *pwchFirstDigit = wchT;
        --pwch; ++pwchFirstDigit;    
    } 
    while (pwchFirstDigit < pwch); 

    return (cchWritten);
}


/*
 -  HrWStrToAstr
 -
 *  Purpose:
 *      Converts a WSTR to an Ascii String
 *
 *  Parameters:
 *      pwsz        IN  WSTR to be converted.
 *      ppsz        OUT resultant Ascii Str.
 */

HRESULT
HrWStrToAStr(CONST WCHAR *pwsz, CHAR **ppsz)
{
    HRESULT hr = NOERROR;
    CHAR    *pszT = NULL;
    DWORD   cchLen;

    PROPASSERT (pwsz && ppsz);

    // Findout the length of the String.
    cchLen = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);
    if (cchLen == 0)
        goto Win32Error;

    // Allocate memory
    pszT = (CHAR *) CoTaskMemAlloc(cchLen * sizeof (CHAR));
    if (!pszT)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Convert it
    if (!WideCharToMultiByte(CP_ACP, 0, pwsz, -1, pszT, cchLen, NULL, NULL))
        goto Win32Error;
        
    *ppsz = pszT;
    pszT = NULL;

Exit:
    if (pszT)
        CoTaskMemFree(pszT);
    return (hr);
    
Win32Error:
    hr = MAKE_HRESULT (SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
    goto Exit;
}


/*
 -  HrWStrToBStr
 -
 *  Purpose:
 *      Converts a WSTR to BSTR
 *
 *  Parameters:
 *      pwsz    IN  Input WSTR.
 *      pbstr   OUT Output BSTR.
 */
 
HRESULT
HrWStrToBStr(CONST WCHAR *pwsz, BSTR *pbstr)
{
    BSTR bstrT;
    
    bstrT = PrivSysAllocString(pwsz);
    if (bstrT)
    {
        *pbstr = bstrT;
        return (NOERROR);
    }
    else
        return E_OUTOFMEMORY;
}


/*
 -  HrAStrToWStr
 -
 *  Purpose:
 *      Converts a Ascii STR to Wide String
 *
 *  Parameters:
 *      psz     IN  Input Ascii string.
 *      ppwsz   OUT Output WSTR.
 */
 
HRESULT
HrAStrToWStr (CONST CHAR *psz, WCHAR **ppwsz)
{
    WCHAR   *pwszT = NULL;
    DWORD   cchLen;
    HRESULT hr = NOERROR;
    
    PROPASSERT (psz && ppwsz);
    
    cchLen = MultiByteToWideChar (CP_ACP, 0, psz, -1, NULL, 0);
    if (cchLen == 0)
        goto Win32Error;
    
    pwszT = (WCHAR *)CoTaskMemAlloc(cchLen * sizeof (WCHAR));
    if (!pwszT)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    if (!MultiByteToWideChar(CP_ACP, 0, psz, -1, pwszT, cchLen))
        goto Win32Error;
        
    *ppwsz = pwszT;
    pwszT = NULL;

Exit:
    if (pwszT)
        CoTaskMemFree(pwszT);
    return (hr);
    
Win32Error:
    hr = MAKE_HRESULT (SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
    goto Exit;
}


/*
 -  HrAStrToBStr
 -
 *  Purpose:
 *      Converts a Ascii STR to a BSTR
 *
 *  Parameters:
 *      psz     IN  Ascii Str to be converted
 *      ppbstr  OUT Resultant BSTR.
 */
 
HRESULT
HrAStrToBStr (CONST CHAR *psz, BSTR *ppbstr)
{
    HRESULT hr = NOERROR;
    WCHAR   *pwszT = NULL;
    
    hr = HrAStrToWStr(psz, &pwszT);
    if (hr != S_OK)
        goto Exit;

    hr = HrWStrToBStr(pwszT, ppbstr);
    if (hr != S_OK)
        goto Exit;
        
Exit:
    if (pwszT)
        CoTaskMemFree (pwszT);
    return (hr);
}


/*
 -  HrBStrToAStr
 -
 *  Purpose:
 *      Converts a BSTR to ascii STR
 *
 *  Parameters:
 *      pbstr   IN  BSTR to be converted
 *      ppsz    OUT Resultant ASCII str.
 */

HRESULT
HrBStrToAStr(CONST BSTR pbstr, CHAR **ppsz)
{

    PROPASSERT (pbstr && ppsz);
    return (HrWStrToAStr((WCHAR *)pbstr, ppsz));
}


/*
 -  HrBStrToWStr
 -
 *  Purpose:
 *      Converts a BSTR to a WSTR
 *
 *  Parameters:
 *      pbstr   IN  BSTR to be converted
 *      ppwsz   OUT Resultant wide char str.
 */

HRESULT
HrBStrToWStr(CONST BSTR pbstr, WCHAR **ppwsz)
{
    HRESULT hr = NOERROR;
    DWORD   cchLen;
    WCHAR   *pwszT = NULL;
    
    PROPASSERT (pbstr && ppwsz);
    
    cchLen = PrivSysStringLen (pbstr) + 1;
    pwszT = (WCHAR *) CoTaskMemAlloc(cchLen * sizeof (WCHAR));
    if (!pwszT)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
        // cchLen includes the string terminator
    CopyMemory (pwszT, pbstr, cchLen * sizeof (WCHAR));
    *ppwsz = pwszT;
    
Exit:
    return (hr);
}


/*
 -  PBToSafeArray
 -
 *  Purpose:
 *      Converts a BYTE array to a safe array
 *
 *  Parameters:
 *      cb      IN      # bytes in the PB array
 *      pbData  IN      Bin array to be converted
 *      ppsa    OUT     Safe array output.
 */

HRESULT
PBToSafeArray (DWORD cb, CONST BYTE *pbData, SAFEARRAY **ppsa)
{
    HRESULT hr = NOERROR;
    SAFEARRAYBOUND sabound;
    SAFEARRAY   *psaT;
    
    PROPASSERT (ppsa);
    
    sabound.lLbound = 0;
    sabound.cElements = cb;

    // Create SafeArray
    psaT = PrivSafeArrayCreate(VT_UI1, 1, &sabound );
    if(psaT == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if(psaT->pvData) // may be NULL if 0-length array.
      CopyMemory(psaT->pvData, pbData, cb );

    *ppsa = psaT;
    
  Exit:
    return (hr);
}


/*
 -  CFToSafeArray
 -
 *  Purpose:
 *      Converts a CLIPDATA to a safe array
 *
 *  Parameters:
 *      pclipdata   IN      CLIPDATA to be converted.
 *      ppsa        OUT     Safe array output.
 */

HRESULT
CFToSafeArray (CONST CLIPDATA *pclipdata, SAFEARRAY **ppsa)
{
    HRESULT         hr = NOERROR;
    SAFEARRAYBOUND  sabound;
    SAFEARRAY       *psaT;
    DWORD               cbClipFmtSize;
    
    PROPASSERT (ppsa);
    
    sabound.lLbound = 0;
    sabound.cElements = pclipdata->cbSize; // Size includes size of ulClipFmt

    // Create SafeArray
    psaT = PrivSafeArrayCreate(VT_UI1, 1, &sabound );
    if(psaT == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if(psaT->pvData) 
    {
        // may be NULL if 0-length array.

        cbClipFmtSize = sizeof(pclipdata->ulClipFmt);

        // Copy the length of the clipdata.
        CopyMemory(psaT->pvData, &(pclipdata->ulClipFmt), cbClipFmtSize);
        
        // Copy the data itself.
        if (pclipdata->cbSize > cbClipFmtSize)
        {
            PROPASSERT (pclipdata->pClipData);
            CopyMemory( ((BYTE*)(psaT->pvData)) + cbClipFmtSize,
                        pclipdata->pClipData, 
                        pclipdata->cbSize - cbClipFmtSize);
        }
    }

    *ppsa = psaT;
  Exit:
    return (hr);
}

    //
    //  These are the Property Variant types that need to be
    //  dumbed down to the VARIANT types.
    //
struct {
    VARTYPE vtSrc, vtDest;
} const ImplicitCoercionLookup[] = {
    // Src             Dest  
    {VT_I8,              VT_I4},
    {VT_UI8,             VT_UI4},
    {VT_LPSTR,           VT_BSTR},
    {VT_LPWSTR,          VT_BSTR},
    {VT_FILETIME,        VT_DATE},
    {VT_BLOB,            VT_ARRAY|VT_UI1},
    {VT_STREAM,          VT_UNKNOWN},
    {VT_STREAMED_OBJECT, VT_UNKNOWN},
    {VT_STORAGE,         VT_UNKNOWN},
    {VT_STORED_OBJECT,   VT_UNKNOWN},
    {VT_BLOB_OBJECT,     VT_ARRAY|VT_UI1},
    {VT_CF,              VT_ARRAY|VT_UI1},
    {VT_CLSID,           VT_BSTR},
};

HRESULT
ImplicitPropVariantToVariantChangeType(
        PROPVARIANT *pDest,     // Omit the hungarian to make
        const PROPVARIANT *pSrc,      // the code look cleaner.
        LCID lcid )
{
    HRESULT hr=S_OK;
    VARTYPE vtCoerce;
    VARTYPE vtType;
    int i;

    //
    // Safe arrays are only built from old VARIANT types.
    // They are easy so get them out of the way.
    //
    if( VT_ARRAY & pSrc->vt )
    {
        return PropVariantCopy( pDest, pSrc );
    }

    // Figure out what type we're coercing from and to.  If we don't
    // find the source type in the ImplicitCoercionLookup
    // array, then we'll just copy as is (leave vtCoerce
    // to VT_EMPTY).

    vtType = (VARTYPE) (pSrc->vt & VT_TYPEMASK);
    vtCoerce = VT_EMPTY;

    for( i = 0; i < ELEMENTS(ImplicitCoercionLookup); i++ )
    {
        if( ImplicitCoercionLookup[i].vtSrc == vtType )
        {
            vtCoerce = ImplicitCoercionLookup[i].vtDest;
            break;
        }
    }

    // Try to coerce vectors to a safearray

    if(VT_VECTOR & pSrc->vt)
    {
        if( VT_EMPTY == vtCoerce )
            vtCoerce = (VARTYPE) (pSrc->vt & VT_TYPEMASK);

        return HrPropVarVECTORToSAFEARRAY( pDest, pSrc, lcid, vtCoerce);
    }

    // It's not a vector

    // If the caller didn't specify a desired type, keep it as is.
    if( VT_EMPTY == vtCoerce )
        hr = PropVariantCopy( pDest, pSrc );    // Optimization (don't do the copy).

    // Otherwise, call out to change the type.
    else
        hr = PropVariantChangeType( pDest, pSrc, lcid, 0, vtCoerce );

    return hr;
}

//+----------------------------------------------------------------------------
//
//  HrPropVarVECTORToSAFEARRAY
//
//  Convert a PropVariant vector to a one dimensional SafeArray.
//
//+----------------------------------------------------------------------------

HRESULT
HrPropVarVECTORToSAFEARRAY(
        PROPVARIANT *pDest,
        const PROPVARIANT *pSrc,
        LCID lcid,
        VARTYPE vtCoerce )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAY   *psaT=NULL;
    SAFEARRAYBOUND sabound;
    PROPVARIANT propvarT1, propvarT2;

    PropVariantInit( &propvarT1 );
    PropVariantInit( &propvarT2 );
    
    PROPASSERT (VT_VECTOR & pSrc->vt);
    
    VARTYPE vt;

    vt = (VARTYPE) (pSrc->vt & VT_TYPEMASK);

    // Create the SafeArray

    sabound.lLbound = 0;
    sabound.cElements = pSrc->cac.cElems;

    psaT = PrivSafeArrayCreate(vtCoerce, 1, &sabound );
    if(psaT == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // Convert single typed Vectors
    //  Pull each element from the Vector,
    //  Change it's type, per requested.
    //  Put it into the Array.

    if(VT_VARIANT != vt)
    {
        for( i = 0; i < pSrc->cac.cElems; i++ )
        {
            // Get the propvariant out of the source vector
            // PERF:  Don't make a copy of the propvar

            hr = LoadPropVariantFromVectorElem( &propvarT1, pSrc, i );
            if( FAILED(hr) )
                goto Error;

            // Coerce that propvar into the caller-desired type
            // PERF: Performance
            //  If the pSrc->vt == vtCoerce, then we can skip the ChangeType
            //  and the following clean.  And go directly to "Put" of T1.

            hr = PropVariantChangeType( &propvarT2, &propvarT1, lcid, 0, vtCoerce );
            PropVariantClear( &propvarT1 );

            if( FAILED(hr) )
                goto Error;

            // Put the coerced propvar into the safearray

            hr = PutPropVariantDataIntoSafeArray( psaT, &propvarT2, i);
            PropVariantClear( &propvarT2 );
            if( FAILED(hr) )
                goto Error;
        }
    }   // if(VT_VARIANT != vt)

    // Convert Vectors of Variants
    //  Do Implicit Coercion of each Variant into an new Variant
    //  Put the new Variant into the Array.

    else        
    {
        for( i = 0; i < pSrc->cac.cElems; i++ )
        {
            // Get the propvar into a safearray-compatible type

            hr = ImplicitPropVariantToVariantChangeType( &propvarT2,
                                                         &pSrc->capropvar.pElems[i],
                                                         lcid );
            if( FAILED(hr) )
                goto Error;

            // Put that coerced propvar into the safearray.

            hr = PrivSafeArrayPutElement( psaT, (long*)&i, (void*)&propvarT2 );
            PropVariantClear( &propvarT2 );
            if( FAILED(hr) )
                goto Error;
        }
    }   // if(VT_VARIANT != vt) ... else

    pDest->vt = (VARTYPE) (VT_ARRAY | vtCoerce);
    pDest->parray = psaT;
    psaT = NULL;

Error:

    if(NULL != psaT)
        PrivSafeArrayDestroy( psaT );

    return hr;
}


//-----------------------------------------------------------------
// Dup routines
//-----------------------------------------------------------------

LPSTR
PropDupStr( const LPSTR lpstr )
{
    int cch;

    if( NULL == lpstr )
        return NULL;
    else
    {
        cch = lstrlenA( lpstr ) + 1;
        return (LPSTR)AllocAndCopy( cch*sizeof(CHAR), lpstr );
    }
}
    
LPWSTR
PropDupWStr( const LPWSTR lpwstr )
{
    int cch;

    if( NULL == lpwstr )
        return NULL;
    else
    {
        cch = lstrlenW( lpwstr ) + 1;
        return (LPWSTR)AllocAndCopy( cch*sizeof(WCHAR), lpwstr );
    }
}

LPCLSID
PropDupCLSID( const LPCLSID pclsid )
{
    return (LPCLSID)AllocAndCopy( sizeof(CLSID), pclsid);
}

CLIPDATA*
PropDupClipData( const CLIPDATA* pclipdata )
{
    CLIPDATA* pcdNew=NULL;
    CLIPDATA* pclipdataNew=NULL;
    PVOID pvMem=NULL;

    pcdNew = new CLIPDATA;
    pvMem = AllocAndCopy( CBPCLIPDATA( *pclipdata ), pclipdata->pClipData);

    if( NULL == pvMem || NULL == pcdNew )
        goto Error;

    pcdNew->cbSize    = pclipdata->cbSize;
    pcdNew->ulClipFmt = pclipdata->ulClipFmt;
    pcdNew->pClipData = (BYTE*)pvMem;
    pclipdataNew = pcdNew;
    pcdNew = NULL;
    pvMem = NULL;

Error:
    if( NULL != pcdNew )
        delete pcdNew;
    if( NULL != pvMem )
        delete pvMem;

    return pclipdataNew;
}

//------------------------------------------------------------------------
//
//  LoadPropVariantFromVectorElem()
//
//  This routine will load a provided PropVariant from an element of a
//  provided SafeArray at the provided index.
//  All the PropVariant Vector types are supported.
//  
//------------------------------------------------------------------------

HRESULT
LoadPropVariantFromVectorElem(
        PROPVARIANT *pDest,
        const PROPVARIANT *pSrc,
        int idx)
{
    VARTYPE vt;
    HRESULT hr=S_OK;

    vt = (VARTYPE) (pSrc->vt & VT_TYPEMASK);

    // Copy the value from pSrc to pDest (we'll
    // copy the VT afterwards).

    switch( vt )
    {
    case VT_I1:
        pDest->cVal = pSrc->cac.pElems[idx];
        break;

    case VT_UI1:
        pDest->bVal = pSrc->caub.pElems[idx];
        break;

    case VT_I2:
        pDest->iVal = pSrc->cai.pElems[idx];
        break;

    case VT_UI2:
        pDest->uiVal = pSrc->caui.pElems[idx];
        break;

    case VT_I4:
        pDest->lVal = pSrc->cal.pElems[idx];
        break;

    case VT_UI4:
        pDest->ulVal = pSrc->caul.pElems[idx];
        break;

    case VT_R4:
        pDest->fltVal = pSrc->caflt.pElems[idx];
        break;

    case VT_R8:
        pDest->dblVal = pSrc->cadbl.pElems[idx];
        break;

    case VT_CY:
        pDest->cyVal = pSrc->cacy.pElems[idx];
        break;

    case VT_DATE:
        pDest->date = pSrc->cadate.pElems[idx];
        break;

    case VT_BSTR:
        if( NULL == pSrc->cabstr.pElems[idx] )
            pDest->bstrVal = NULL;
        else
        {
            pDest->bstrVal = PrivSysAllocString( pSrc->cabstr.pElems[idx] );
            if( NULL == pDest->bstrVal)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
        }
        break;

    case VT_BOOL:
        pDest->boolVal = pSrc->cabool.pElems[idx];
        break;

    case VT_ERROR:
        pDest->scode = pSrc->cascode.pElems[idx];
        break;

    case VT_I8:
        pDest->hVal = pSrc->cah.pElems[idx];
        break;

    case VT_UI8:
        pDest->uhVal = pSrc->cauh.pElems[idx];
        break;
    
        // String Copy
    case VT_LPSTR:
        if( NULL == pSrc->calpstr.pElems[idx] )
            pDest->pszVal = NULL;
        else
        {
            pDest->pszVal = PropDupStr( pSrc->calpstr.pElems[idx] );
            if( NULL == pDest->pszVal)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
        }
        break;

        // Wide String Copy
    case VT_LPWSTR:
        if( NULL == pSrc->calpwstr.pElems[idx] )
            pDest->pwszVal = NULL;
        else
        {
            pDest->pwszVal = PropDupWStr( pSrc->calpwstr.pElems[idx] );
            if( NULL == pDest->pwszVal)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
        }
        break;
    
    case VT_FILETIME:
        pDest->filetime = pSrc->cafiletime.pElems[idx];
        break;

        //
        // The Variant takes a pointer to a CLIPDATA but the
        // vector is an array of CLIPDATA structs.
        //
    case VT_CF:
        pDest->pclipdata = PropDupClipData(&pSrc->caclipdata.pElems[idx]);
        if( NULL == pDest->pclipdata)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        break;

        //
        // The Variant takes a pointer to a CLSID but the
        // vector is an array of CLSID structs.
        //
    case VT_CLSID:
        pDest->puuid = PropDupCLSID(&pSrc->cauuid.pElems[idx]);
        if( NULL == pDest->puuid)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        break;

    default:
        return DISP_E_TYPEMISMATCH;
    }

    // Now update the VT

    pDest->vt = vt;

Error:
    return hr;
}       


//------------------------------------------------------------------------
//
//  PutPropVariantDataIntoSafeArray
//
//  This will take the data part of a propvariant and "Put" it into the
//  a SafeArray at the provided index.
//
//  Only the intersection of PROPVARIANT vector types with old VARIANT types
//  are supported.
//
//------------------------------------------------------------------------

// PERF:  Reimplement this without using the PropVariantCopy

HRESULT
PutPropVariantDataIntoSafeArray(
        SAFEARRAY *psa,
        const PROPVARIANT *pSrc,
        int idx)
{
    VARTYPE vt;
    HRESULT hr=S_OK;
    PROPVARIANT propvarT;
    const void *pv=NULL;

    vt = (VARTYPE) (pSrc->vt & VT_TYPEMASK);

    PROPASSERT(vt == pSrc->vt);

    // Make a temporary copy of the source propvar

    PropVariantInit( &propvarT );
    hr = PropVariantCopy( &propvarT, pSrc );
    if( FAILED( hr ) ) goto Exit;

    // Set pv to point to the type-appropriate location in the propvarT
    // of the data.

    switch( vt )
    {
    case VT_I1:
        pv = &propvarT.cVal;
        break;

    case VT_UI1:
        pv = &propvarT.bVal;
        break;

    case VT_I2:
        pv = &propvarT.iVal;
        break;

    case VT_UI2:
        pv = &propvarT.uiVal;
        break;

    case VT_I4:
        pv = &propvarT.lVal;
        break;

    case VT_UI4:
        pv = &propvarT.ulVal;
        break;

    case VT_R4:
        pv = &propvarT.fltVal;
        break;

    case VT_R8:
        pv = &propvarT.dblVal;
        break;

    case VT_CY:
        pv = &propvarT.cyVal;
        break;

    case VT_DATE:
        pv = &propvarT.date;
        break;

    case VT_BSTR:
        pv = propvarT.bstrVal;  // Pointer Copy
        break;

    case VT_BOOL:
        pv = &propvarT.boolVal;
        break;

    case VT_ERROR:
        pv = &propvarT.scode;
        break;

    case VT_I8:
        pv = &propvarT.hVal;
        break;

    case VT_UI8:
        pv = &propvarT.uhVal;
        break;
    
    case VT_CF:
        pv = &propvarT.pclipdata;
        break;

    default:
        hr = DISP_E_TYPEMISMATCH;
        goto Exit;
    }

    // *Copy* the data into the SafeArray

    hr = PrivSafeArrayPutElement( psa, (long*)&idx, const_cast<void*>(pv) );
    if( FAILED(hr) ) goto Exit;

Exit:

    PropVariantClear( &propvarT );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\ntprop.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993
//
// File:        ntprop.cxx
//
// Contents:    OLE Appendix B property set support.
//
// History:     28-Nov-94   vich        created
//              15-Jul-96   MikeHill    - PropSetNames: WCHAR=>OLECHAR, byte-swapping.
//                                      - Added special-cases for PictureIt! propsets.
//              06-May-98   MikeHill    - In PropertySetNameToGuid, disallow
//                                        a string-ized well-known GUID.
//
//---------------------------------------------------------------------------

#include <pch.cxx>
#include <olechar.h>


#define CCH_MAP         (1 << CBIT_CHARMASK)            // 32
#define CHARMASK        (CCH_MAP - 1)                   // 0x1f

// we use static array instead of string literals because some systems
// have 4 bytes string literals, and would not produce the correct result
// for REF's 2 byte Unicode convention
// 
OLECHAR aocMap[CCH_MAP + 1] = {'a','b','c','d','e','f','g',
                               'h','i','j','k','l','m','n',
                               'o','p','q','r','s','t','u',
                               'v','w','x','y','z',
                               '0','1','2','3','4','5','\0'};

#define CALPHACHARS  (1 + (OLECHAR)'z' - (OLECHAR)'a')

GUID guidSummary =
    { 0xf29f85e0,
      0x4ff9, 0x1068,
      { 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 } };

OLECHAR oszSummary[] = {'S','u','m','m','a','r','y',
                        'I','n','f','o','r','m','a','t','i','o','n','\0'};

GUID guidDocumentSummary =
    { 0xd5cdd502,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

OLECHAR oszDocumentSummary[] = {'D','o','c','u','m','e','n','t',
                                'S','u','m','m','a','r','y',
                                'I','n','f','o','r','m','a','t','i','o','n',
                                '\0'};

// Note that user defined properties are placed in section 2 with the below
// GUID as the FMTID -- alas, we did not expect Office95 to actually use it.

GUID guidDocumentSummarySection2 =
    { 0xd5cdd505,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

// *Global Info*

OLECHAR oszGlobalInfo[] = {'G','l','o','b','a','l',' ','I','n','f','o','\0'};

GUID guidGlobalInfo =
    { 0x56616F00,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Contents*

OLECHAR oszImageContents[] = {'I','m','a','g','e',' ',
                              'C','o','n','t','e','n','t','s','\0'};

GUID guidImageContents =
    { 0x56616400,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Info*

OLECHAR oszImageInfo[] = {'I','m','a','g','e',' ','I','n','f','o','\0'};

GUID guidImageInfo =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };


__inline OLECHAR
MapChar(IN ULONG i)
{
    return((OLECHAR) aocMap[i & CHARMASK]);
}


//+--------------------------------------------------------------------------
// Function:    PrGuidToPropertySetName
//
// Synopsis:    Map property set GUID to null-terminated UNICODE name string.
//
//              The awcname parameter is assumed to be a buffer with room for
//              CWC_PROPSETSZ (28) UNICODE characters.  The first character
//              is always WC_PROPSET0 (0x05), as specified by the OLE Appendix
//              B documentation.  The colon character normally used as an NT
//              stream name separator is not written to the caller's buffer.
//
//              No error is possible.
//
// Arguments:   IN GUID *pguid        -- pointer to GUID to convert
//              OUT OLECHAR aocname[] -- output string buffer
//
// Returns:     count of non-NULL characters in the output string buffer
//---------------------------------------------------------------------------

WINOLEAPI_(ULONG)
PrGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[])
{
    ULONG cbitRemain = CBIT_BYTE;
    OLECHAR *poc = aocname;

    BYTE *pb;
    BYTE *pbEnd;    

    *poc++ = OC_PROPSET0;

    //  -----------------------
    //  Check for special-cases
    //  -----------------------

    // Note: CCH_PROPSET includes the OC_PROPSET0, and sizeof(osz...)
    // includes the trailing '\0', so sizeof(osz...) is ok because the
    // OC_PROPSET0 character compensates for the trailing NULL character.

    // Is this the SummaryInformation propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszSummary)/sizeof(OLECHAR));

    if (*pguid == guidSummary)
    {
        RtlCopyMemory(poc, oszSummary, sizeof(oszSummary));
        return(sizeof(oszSummary)/sizeof(OLECHAR));
    }

    // Is this The DocumentSummaryInformation or User-Defined propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszDocumentSummary)/sizeof(OLECHAR));

    if (*pguid == guidDocumentSummary || *pguid == guidDocumentSummarySection2)
    {
        RtlCopyMemory(poc, oszDocumentSummary, sizeof(oszDocumentSummary));
        return(sizeof(oszDocumentSummary)/sizeof(OLECHAR));
    }

    // Is this the Global Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszGlobalInfo)/sizeof(OLECHAR));
    if (*pguid == guidGlobalInfo)
    {
        RtlCopyMemory(poc, oszGlobalInfo, sizeof(oszGlobalInfo));
        return(sizeof(oszGlobalInfo)/sizeof(OLECHAR));
    }

    // Is this the Image Contents propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageContents)/sizeof(OLECHAR));
    if (*pguid == guidImageContents)
    {
        RtlCopyMemory(poc, oszImageContents, sizeof(oszImageContents));
        return(sizeof(oszImageContents)/sizeof(OLECHAR));
    }

    // Is this the Image Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageInfo)/sizeof(OLECHAR));
    if (*pguid == guidImageInfo)
    {
        RtlCopyMemory(poc, oszImageInfo, sizeof(oszImageInfo));
        return(sizeof(oszImageInfo)/sizeof(OLECHAR));
    }


    //  ------------------------------
    //  Calculate the string-ized GUID
    //  ------------------------------

    // If this is a big-endian system, we need to convert
    // the GUID to little-endian for the conversion.

#if BIGENDIAN
    GUID guidByteSwapped = *pguid;
    PropByteSwap( &guidByteSwapped );
    pguid = &guidByteSwapped;
#endif

    // Point to the beginning and ending of the GUID
    pb = (BYTE*) pguid;
    pbEnd = pb + sizeof(*pguid);

    // Walk 'pb' through each byte of the GUID.

    while (pb < pbEnd)
    {
        // Get the value of the current byte, shifting down to
        // get at the bits which we haven't looked at yet.

        ULONG i = *pb >> (CBIT_BYTE - cbitRemain);

        // Does the currenty byte of the GUID have at least 5 bits
        // that we haven't looked at yet?

        if (cbitRemain >= CBIT_CHARMASK)
        {
            // Yes, we have enough bits.  Map 5 of them to a character.
            *poc = MapChar(i);

            // If this is a byte boundary, uppercase the letter
            // (Don't know why, maybe to help debug?)

            if (cbitRemain == CBIT_BYTE && *poc >= (OLECHAR)'a' 
                && *poc <= ((OLECHAR)'z'))
            {
                *poc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a') );
            }

            // Advance the output pointer
            poc++;

            // Decrement the count of interesting bits in this byte.
            cbitRemain -= CBIT_CHARMASK;

            // If we just used up the last bit in this byte, move on
            // to the next byte.

            if (cbitRemain == 0)
            {
                pb++;
                cbitRemain = CBIT_BYTE;
            }
        }   // if (cbitRemain >= CBIT_CHARMASK)

        // Otherwise, we need to advance pb to the next byte.

        else
        {
            // Advance pb to the next byte.
            if (++pb < pbEnd)
            {
                // We haven't gone off the end of the GUID, so 
                // add bits from the new byte to i (add them above
                // the interesting bits from the previous byte
                // which are already in i).

                i |= *pb << cbitRemain;
            }

            // Put the next character into the output string.
            // Note that on the last byte, we'll have less than
            // 5 bits in i (but the bits above cbitRemain will
            // be zero).

            *poc++ = MapChar(i);

            // Add 3 to the count of remaining interesting bits
            // in this new byte.  E.g. if we brought over 1 bit
            // from the previous byte, then we used 4 bits from
            // this new byte, and we have 1+3=4 bits left in this
            // byte.

            cbitRemain += CBIT_BYTE - CBIT_CHARMASK;
        }
    }   // while (pb < pbEnd)

    // Terminate the string and return its cch.

    *poc = OLESTR( '\0' );
    return(CCH_PROPSET);

}


//+--------------------------------------------------------------------------
// Function:    PrPropertySetNameToGuid
//
// Synopsis:    Map non null-terminated UNICODE string to a property set GUID.
//
//              If the name is not properly formed as per
//              PrGuidToPropertySetName(), STATUS_INVALID_PARAMETER is
//              returned.  The pguid parameter is assumed to point to a buffer
//              with room for a GUID structure.
//
// Arguments:   IN ULONG cocname     -- count of OLECHARs in string to convert
//              IN OLECHAR aocname[] -- input string to convert
//              OUT GUID *pguid      -- pointer to buffer for converted GUID
//
// Returns:     NTSTATUS
//---------------------------------------------------------------------------

NTSTATUS
PrPropertySetNameToGuid(
    IN ULONG cocname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    GUID guidReturn = GUID_NULL;

    OLECHAR const *poc = aocname;

    if (poc[0] == OC_PROPSET0)
    {
        //  -----------------------
        //  Check for Special-Cases 
        //  -----------------------

        // Note: cocname includes the OC_PROPSET0, and sizeof(osz...)
        // includes the trailing OLESTR('\0'), but the comparison excludes both
        // the leading OC_PROPSET0 and the trailing '\0'.

        // Is this SummaryInformation?
        if (cocname == sizeof(oszSummary)/sizeof(OLECHAR) &&
            // MAC: Create a dfsocsnicmp or convert strings to WCHARs
            //ocsnicmp(&poc[1], oszSummary, cocname - 1) == 0)
            dfwcsnicmp(&poc[1], oszSummary, cocname - 1) == 0)

        {
            *pguid = guidSummary;
            return(STATUS_SUCCESS);
        }

        // Is this DocumentSummaryInformation?
        if (cocname == sizeof(oszDocumentSummary)/sizeof(OLECHAR) &&
            //ocsnicmp(&poc[1], oszDocumentSummary, cocname - 1) == 0)
            dfwcsnicmp(&poc[1], oszDocumentSummary, cocname - 1) == 0)
        {
            *pguid = guidDocumentSummary;
            return(STATUS_SUCCESS);
        }

        // Is this Global Info?
        if (cocname == sizeof(oszGlobalInfo)/sizeof(OLECHAR) &&
            //ocsnicmp(&poc[1], oszGlobalInfo, cocname - 1) == 0)
            dfwcsnicmp(&poc[1], oszGlobalInfo, cocname - 1) == 0)
        {
            *pguid = guidGlobalInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Info?
        if (cocname == sizeof(oszImageInfo)/sizeof(OLECHAR) &&
            //ocsnicmp(&poc[1], oszImageInfo, cocname - 1) == 0)
            dfwcsnicmp(&poc[1], oszImageInfo, cocname - 1) == 0)
        {
            *pguid = guidImageInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Contents?
        if (cocname == sizeof(oszImageContents)/sizeof(OLECHAR) &&
            //ocsnicmp(&poc[1], oszImageContents, cocname - 1) == 0)
            dfwcsnicmp(&poc[1], oszImageContents, cocname - 1) == 0)
        {
            *pguid = guidImageContents;
            return(STATUS_SUCCESS);
        }

        //  ------------------
        //  Calculate the GUID
        //  ------------------

        // None of the special-cases hit, so we must calculate
        // the GUID from the name.

        if (cocname == CCH_PROPSET)
        {
            ULONG cbit;
            BYTE *pb = (BYTE *) &guidReturn - 1;

            RtlZeroMemory(&guidReturn, sizeof(guidReturn));

            // Loop through the output GUID, 5 bits at a time.

            for (cbit = 0; cbit < CBIT_GUID; cbit += CBIT_CHARMASK)
            {
                ULONG cbitStored;
                OLECHAR oc;

                // Calculate the number of bits in the current byte
                // that have already been used.

                ULONG cbitUsed = cbit % CBIT_BYTE;

                // If there are no bits remaining in this byte, move on to
                // the next byte.

                if (cbitUsed == 0)
                {
                    pb++;
                }

                // Get the next character in the input string.
                // Assume it's an upper case character for now, then correct if
                // that doesn't work.  (If it's lower case, 
                // oc will be a very large number if it's a wchar,
                // a negative number if it's a char.)

                oc = *++poc - (OLECHAR)'A';

                if (oc > CALPHACHARS || oc < 0)
                {
                    // oops, try lower case

                    oc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a'));

                    if (oc > CALPHACHARS || oc < 0)
                    {
                        // must be a digit
                        oc += ((OLECHAR)'a') - ((OLECHAR)'0') + CALPHACHARS;
                        if (oc > CHARMASK)
                        {
                            goto Exit;                  // invalid character
                        }
                    }
                }

                // Put at least some of the bits of this character into the
                // current byte.

                *pb |= (BYTE) (oc << cbitUsed);

                // How many of the bits of oc actually just went into *pb?

                cbitStored = min(CBIT_BYTE - cbitUsed, CBIT_CHARMASK);

                // If the translated bits wouldn't all fit in the current byte,
                // put then into the next byte (advancing pb).

                if( cbitStored < CBIT_CHARMASK )
                {
                    // Get the bits that didn't go into *pb in to the
                    // low-order bits of oc.

                    oc >>= CBIT_BYTE - cbitUsed;

                    // Have we already filled the ouput GUID?

                    if (cbit + cbitStored == CBIT_GUID)
                    {
                        // Yes.  There should be nothing left in cb.
                        if (oc != 0)
                        {
                            goto Exit;                  // extra bits (error)
                        }
                        break;
                    }

                    // Otherwise, advance pb to the next byte in the output GUID

                    pb++;

                    // Put the leftover bits of this character (that didn't fit
                    // into the last byte) into this new byte.

                    *pb |= (BYTE) oc;
                }
            }   // for (cbit = 0; cbit < CBIT_GUID; cbit += CBIT_CHARMASK)

            Status = STATUS_SUCCESS;

            // If byte-swapping is necessary, do so now on the calculated
            // GUID.

            PropByteSwap( &guidReturn );

        }   // if (cocname == CCH_PROPSET)
    }   // if (poc[0] == OC_PROPSET0)

    // Ensure that the calculated GUID isn't one of the special ones.  If it is,
    // then this is an error.  We don't want to convert something to a GUID
    // that we can't convert back.

    if( guidSummary         == guidReturn
        ||
        guidDocumentSummary == guidReturn
        ||
        guidGlobalInfo      == guidReturn
        ||
        guidImageInfo       == guidReturn
        ||
        guidImageContents   == guidReturn
        )
    {
        return( STATUS_INVALID_PARAMETER );
    }


    //  ----
    //  Exit
    //  ----

    Status = STATUS_SUCCESS;    // Normalize results
    *pguid = guidReturn;

Exit:

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\ntpropb.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1994
//
// File:        ntpropb.cxx
//
// Contents:    Nt property set implementation based on OLE Appendix B.
//
// History:     
//  5-Dec-94   vich       created
//  09-May-96  MikeHill   Use the 'boolVal' member of PropVariant,
//                        rather than the member named 'bool'
//                       (which is a reserved keyword).
//  22-May-96  MikeHill   - Get the OSVersion during a CreatePropSet.
//                        - Let CPropSetStm allocate prop name buffers.
//  07-Jun-96  MikeHill   - Correct ClipData.cbSize to include
//                          sizeof(ulClipFmt).
//                        - Removed unnecessary Flushes.
//                        - Take the psstm lock on RtlClosePropSet.
//  12-Jun-96  MikeHill   - Fix locking in RtlClosePropertySet.
//                        - VT_I1 support (under ifdefs)
//  25-Jul-96  MikeHill   - Removed Win32 SEH.
//                        - BSTRs & prop names:  WCHAR => OLECHAR.
//                        - Added RtlOnMappedStreamEvent
//                        - Enabled for use in "iprop.dll".
//  03-Mar-98  MikeHill   - Chagned "Pr" routines to "Stg".
//  06-May-98  MikeHill   - Removed UnicodeCallouts.
//                        - Use CoTaskMem rather than new/delete.
//                        - Added support for VT_VECTOR|VT_I1
//  18-May-98  MikeHill   - Fixed typos.
//  11-June-98 MikeHIll   - Removed some old Cairo code.
//                        - Dbg output.
//                        - Add a pCodePage to PrSetProperties.
//
//---------------------------------------------------------------------------

#include <pch.cxx>
#include "propvar.h"
#include <olechar.h>
#include <stgprop.h>

#define Dbg     DEBTRACE_NTPROP
#define DbgS(s) (NT_SUCCESS(s)? Dbg : DEBTRACE_ERROR)


#if DBG
ULONG DebugLevel = DEBTRACE_ERROR;
//ULONG DebugLevel = DEBTRACE_ERROR | DEBTRACE_CREATESTREAM;
//ULONG DebugLevel = DEBTRACE_ERROR | MAXULONG;
ULONG DebugIndent;
ULONG cAlloc;
ULONG cFree;
#endif

#if defined(WINNT) && !defined(IPROPERTY_DLL)

GUID guidStorage = PSGUID_STORAGE;


#endif // #if defined(WINNT) && !defined(IPROPERTY_DLL)


//+---------------------------------------------------------------------------
// Function:    UnLock, private
//
// Synopsis:    Unlock a PropertySetStream, and return the
//              more severe of two NTSTATUSs; the result of
//              the Unlock, or the one passed in by the caller.
//
// Arguments:   [ppsstm]        -- The CPropertySetStream to unlock
//              [Status]        -- NTSTATUS
//
// Returns:     NTSTATUS
//---------------------------------------------------------------------------

inline NTSTATUS
Unlock( CPropertySetStream *ppsstm, NTSTATUS Status )
{
    NTSTATUS StatusT = ppsstm->Unlock();

    // Note that the statement below preserves
    // success codes in the original Status unless
    // there was an error in the Unlock.

    if( NT_SUCCESS(Status) && !NT_SUCCESS(StatusT) )
        Status = StatusT;

    return( Status );
}

//+---------------------------------------------------------------------------
// Function:    PrCreatePropertySet, public
//
// Synopsis:    Allocate and initialize a property set context
//
// Arguments:   [ms]            -- Nt Mapped Stream
//              [Flags]         -- *one* of READ/WRITE/CREATE/CREATEIF/DELETE
//              [pguid]         -- property set guid (create only)
//              [pclsid]        -- CLASSID of propset code (create only)
//              [ma]            -- caller's memory allocator
//		[LocaleId]	-- Locale Id (create only)
//              [pOSVersion]    -- pointer to the OS Version header field
//              [pCodePage]     -- pointer to new/returned CodePage of propset
//              [pgrfBehavior]  -- pointer to PROPSET_BEHAVIOR_* flags
//              [pnp]           -- pointer to returned property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrCreatePropertySet(
    IN NTMAPPEDSTREAM ms,           // Nt Mapped Stream
    IN USHORT Flags,                // *one* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid,  // property set guid (create only)
    OPTIONAL IN GUID const *pclsid, // CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	    // caller's memory allocator
    IN ULONG LocaleId,		    // Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion, // OS Version from the propset header
    IN OUT USHORT *pCodePage,       // IN: CodePage of property set (create only)
                                    // OUT: CodePage of property set (always)
    IN OUT DWORD *pgrfBehavior,     // IN: Behavior of property set (create only)
                                    // OUT:  Behavior of property set (always)
    OUT NTPROP *pnp)                // pointer to return prop set context
{
    NTSTATUS Status;
    IMappedStream *pmstm = (IMappedStream *) ms;
    CPropertySetStream *ppsstm = NULL;
    BOOLEAN fLocked = FALSE;
    BOOLEAN fOpened = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrCreatePropertySet" );
    propTraceParameters(( "ms=%p, f=0x%x, codepage=0x%x)", ms, Flags, *pCodePage ));

    *pnp = NULL;
    Status = STATUS_INVALID_PARAMETER;

    if( pOSVersion != NULL )
        *pOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;

    // Validate the input flags

    if (Flags & ~(CREATEPROP_MODEMASK | CREATEPROP_NONSIMPLE))
    {
        propDbg(( DEB_ERROR, "PrCreatePropertySet(ms=%x, Flags=%x) ==> bad flags!\n",
                  ms, Flags));
        goto Exit;
    }

    PROPASSERT( (0 == *pgrfBehavior) || (CREATEPROP_CREATE & Flags) );
    PROPASSERT( !(*pgrfBehavior & ~PROPSET_BEHAVIOR_CASE_SENSITIVE) );

    switch (Flags & CREATEPROP_MODEMASK)
    {
        case CREATEPROP_DELETE:
        case CREATEPROP_CREATE:
        case CREATEPROP_CREATEIF:
        case CREATEPROP_WRITE:

            if (!pmstm->IsWriteable())
            {
                Status = STATUS_ACCESS_DENIED;
                goto Exit;
            }
            // FALLTHROUGH

        case CREATEPROP_READ:
        case CREATEPROP_UNKNOWN:
    	    if (ma == NULL)
    	    {
                goto Exit;
    	    }
            break;

        default:
            propDbg(( DEB_ERROR, "PrCreatePropertySet(ms=%x, Flags=%x) ==> invalid mode!\n",
                      ms, Flags));
            goto Exit;
    }

    Status = pmstm->Lock((Flags & CREATEPROP_MODEMASK) != CREATEPROP_READ);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm = new CPropertySetStream( Flags, pmstm, (PMemoryAllocator *) ma);
    if (ppsstm == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }
    else
    {
        ppsstm->Open(pguid, pclsid, LocaleId,
                     pOSVersion, *pCodePage, *pgrfBehavior, &Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

    }

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    // If we were successfull with everything, set the
    // out-parameters.

    if( NT_SUCCESS(Status) )
    {
        // pOSVersion has already been set.
        *pCodePage = ppsstm->GetCodePage();
        *pgrfBehavior = ppsstm->GetBehavior();
        *pnp = (NTPROP) ppsstm;
    }

    // Otherwise, if we created a CPropertySetStream object, but
    // the overall operation failed, we must close/delete
    // the object.  Note that we must do this after
    // the above unlock, since ppsstm will be gone after
    // this call.

    else if( NULL != ppsstm )
    {
        PrClosePropertySet((NTPROP) ppsstm);
    }

    if( STATUS_PROPSET_NOT_FOUND == Status )
        propSuppressExitErrors();

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    PrClosePropertySet, public
//
// Synopsis:    Delete a property set context
//
// Arguments:   [np]      -- property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrClosePropertySet(
    IN NTPROP np)               // property set context
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrClosePropertySet" );
    propTraceParameters(( "np=%p", np ));

    // Lock the mapped stream, because this close
    // may trigger a Write.

    Status = ppsstm->Lock(TRUE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    // Note that we haven't ReOpen-ed the mapped stream.  This
    // isn't required for the CPropertySetStream::Close method.
    ppsstm->Close(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    if( STG_E_REVERTED == Status )
        propSuppressExitErrors();

    delete ppsstm;

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    PrOnMappedStreamEvent, public
//
// Synopsis:    Handle a MappedStream event.  Every such
//              event requires a byte-swap of the property set
//              headers.
//
// Arguments:   [np]      -- property set context
//              [pbuf]    -- property set buffer
//              [cbstm]   -- size of mapped stream (or CBSTM_UNKNOWN)
//
// NOTE:        It is assumed that the caller has already taken
//              the CPropertySetStream::Lock.
//
// Returns:     Status code
//---------------------------------------------------------------------------
#ifdef BIGENDIAN

NTSTATUS
PrOnMappedStreamEvent(
    IN VOID * np,               // property set context (an NTPROP)
    IN VOID *pbuf,              // property set buffer
    IN ULONG cbstm )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrOnMappedStreamEvent" );
    propTraceParameters(( "np=%p, pbuf=%p, cbstm=%lu", np, pbuf, cbstm ));

    // Byte-swap the property set headers.
    ppsstm->ByteSwapHeaders((PROPERTYSETHEADER*) pbuf, cbstm, &Status );
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    return(Status);

}   // PrOnMappedStreamEvent()

#endif

//+---------------------------------------------------------------------------
// Function:    PrFlushPropertySet, public
//
// Synopsis:    Flush property set changes to disk
//
// Arguments:   [np]      -- property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrFlushPropertySet(
    IN NTPROP np)               // property set context
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrFlushPropertySet" );
    propTraceParameters(( "np=%p", np ));

    Status = ppsstm->Lock(TRUE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    if (ppsstm->IsModified())
    {
        ppsstm->ReOpen(&Status);           // Reload header/size info
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Validate(&Status);  // (Debug only)
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Flush(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Validate(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;
    }

Exit:

    if( fLocked )
        Status = Unlock( ppsstm, Status );

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    MapNameToPropId, private
//
// Synopsis:    Find an available propid and map it to the passed name
//
// Arguments:   [ppsstm]        -- property set stream
//              [CodePage]      -- property set codepage
//              [aprs]          -- array of property specifiers
//              [cprop]         -- count of property specifiers
//              [iprop]         -- index of propspec with name to map
//              [pidStart]      -- first PROPID to start mapping attempts
//              [pstatus]       -- NTSTATUS code
//
// Returns:     PROPID mapped to passed name
//
// Note:        Find the first unused propid starting at pidStart.
//---------------------------------------------------------------------------

PROPID
MapNameToPropId(
    IN CPropertySetStream *ppsstm,    // property set stream
    IN USHORT CodePage,
    IN PROPSPEC const aprs[],         // array of property specifiers
    IN ULONG cprop,
    IN ULONG iprop,
    IN PROPID pidStart,
    OUT NTSTATUS *pstatus)
{
    PROPID pid = PID_ILLEGAL;
    const OLECHAR *poszName = NULL;
    OLECHAR *poszNameFromDictionary = NULL;
    ULONG cbName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(aprs[iprop].ulKind == PRSPEC_LPWSTR);
    poszName = aprs[iprop].lpwstr;
    PROPASSERT(IsOLECHARString( poszName, MAXULONG ));

    IFDBG( HRESULT &hr = *pstatus );
    propITraceStatic( "MapNameToPropId" );
    propTraceParameters(( "ppsstm=%p, CodePage=%d, aprs=%p, cprop=%d, iprop=%d, pidStart=%d",
                           ppsstm,    CodePage,    aprs,    cprop,    iprop,    pidStart ));

    // Starting with the caller-provided PID, search sequentially
    // until we find a PID we can use.

    for (pid = pidStart; ; pid++)
    {
        ULONG i;

        // The caller must specify a starting propid of 2 or larger, and we
        // must not increment into the reserved propids.

        if (pid == PID_DICTIONARY ||
            pid == PID_CODEPAGE ||
            pid <  PID_FIRST_USABLE)
        {
            *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        // Do not assign any propids that explitly appear in the array of
        // propspecs involved in this PrSetProperties call, nor any propids
        // that are associated with any names in the propspec array.

        for (i = 0; i < cprop; i++)
        {
            if (i != iprop)             // skip the entry we are mapping
            {
                // Is the current PID in the PropSpec[]?

                if (aprs[i].ulKind == PRSPEC_PROPID &&
                    aprs[i].propid == pid)
                {
                    goto nextpid;       // skip colliding pid
                }

                // Is the current PID already used in the property set?

                if (aprs[i].ulKind == PRSPEC_LPWSTR &&
                    ppsstm->QueryPropid(aprs[i].lpwstr, pstatus) == pid)
                {
                    goto nextpid;       // skip colliding pid
                }
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
            }
        }   // for (i = 0; i < cprop; i++)

        // Do not assign any propids that currently map to any name.
        // Note that the property name we are mapping does not appear in the
        // dictionary -- the caller checked for this case already.

        if( ppsstm->QueryPropertyNames( 1, &pid, &poszNameFromDictionary, pstatus ))
        {
            CoTaskMemFree( poszNameFromDictionary );
            poszNameFromDictionary = NULL;
        }
        else
        {
            // The property name could not be found in the dictionary.

            ULONG cbT;
	    SERIALIZEDPROPERTYVALUE const *pprop;

            PROPASSERT( NULL == poszNameFromDictionary );

            // Was the name not found due to an error in QueryPropertyNames?
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            // Do not assign any propids that currently have a property value.

            pprop = ppsstm->GetValue(pid, &cbT, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            if (pprop == NULL)
            {
                // There was no property value corresponding to this PID.

                DebugTrace(0, Dbg, (
		    "MapNameToPropId(Set Entry: pid=%x, name=L'%ws')\n",
                    pid,
                    poszName));

                // Add the caller-provided name to the dictionary, using
                // the PID that we now know is nowhere in use.

                ppsstm->SetPropertyNames(1, &pid, &poszName, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                ppsstm->Validate(pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                break;

            }   // if (pprop == NULL)
        }   // if( ppsstm->QueryPropertyNames( 1, &pid, &poszNameFromDictionary, pstatus ))

nextpid:
        ;
    }   // for (pid = pidStart; ; pid++)

Exit:

    if( NULL != poszNameFromDictionary )
        CoTaskMemFree( poszNameFromDictionary );

    return(pid);
}


//+---------------------------------------------------------------------------
// Function:    ConvertVariantToPropInfo, private
//
// Synopsis:    Convert variant property values to PROPERTY_INFORMATION values
//
// Arguments:   [ppsstm]        -- property set stream
//              [cprop]         -- property count
//              [pidNameFirst]  -- first PROPID for new named properties
//              [aprs]          -- array of property specifiers
//              [apid]          -- buffer for array of propids
//              [avar]          -- array of PROPVARIANTs
//              [apinfo]        -- output array of property info
//              [pcIndirect]    -- output count of indirect properties
//
// Returns:     None
//
// Note:        If pcIndirect is NULL,
//---------------------------------------------------------------------------

VOID
ConvertVariantToPropInfo(
    IN CPropertySetStream *ppsstm,    // property set stream
    IN ULONG cprop,                   // property count
    IN PROPID pidNameFirst,           // first PROPID for new named properties
    IN PROPSPEC const aprs[],         // array of property specifiers
    OPTIONAL OUT PROPID apid[],       // buffer for array of propids
    OPTIONAL IN PROPVARIANT const avar[],// array of properties+values
    OUT PROPERTY_INFORMATION *apinfo, // output array of property info
    OUT ULONG *pcIndirect,            // output count of indirect properties
    OUT NTSTATUS *pstatus )
{
    *pstatus = STATUS_SUCCESS;

    USHORT CodePage = ppsstm->GetCodePage();
    PROPID pidStart = pidNameFirst;
    ULONG iprop;

    IFDBG( HRESULT &hr = *pstatus );
    propITraceStatic( "ConvertVariantToPropInfo" );
    propTraceParameters(( "ppsstm=%p, cprop=%d, pidNameFirst=%d, aprs=%p, apid=%p, avar=%p, apinfo=%p, pcIndirect=%p",
                           ppsstm,    cprop,    pidNameFirst,    aprs,    apid,    avar,    apinfo,    pcIndirect ));

    if (pcIndirect != NULL)
    {
        *pcIndirect = 0;
    }

    // Loop through each of the input propvariants and put it's info
    // in the apinfo array.

    for (iprop = 0; iprop < cprop; iprop++)
    {
        PROPID pid;
        ULONG cbprop;

        // Get the PROPID into 'pid' (harder if this is a name)
        // If a property is being written with a new name, we'll
        // add it to the dictionary here.

        switch(aprs[iprop].ulKind)
        {
            // For names, we have to work with the dictionary.

            case PRSPEC_LPWSTR:
            {
                PROPASSERT(IsOLECHARString(aprs[iprop].lpwstr, MAXULONG));

                // Is this property already in the dictionary?

                pid = ppsstm->QueryPropid(aprs[iprop].lpwstr, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                // If it's not in the dictionary, add it.

                if (pid == PID_ILLEGAL && avar != NULL)
                {
                    pid = MapNameToPropId(
                                    ppsstm,
                                    CodePage,
                                    aprs,
                                    cprop,
                                    iprop,
                                    pidStart,
                                    pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    pidStart = pid + 1;
                }
                break;
            }

            // Otherwise, the caller has already explicitely given us the PID.

            case PRSPEC_PROPID:
                pid = aprs[iprop].propid;
                break;

            default:
                PROPASSERT(!"Bad ulKind");
                *pstatus = STATUS_INVALID_PARAMETER;
                goto Exit;

                break;

        }   // switch(aprs[iprop].ulKind)

        // Store the PROPID in the apid array.

        if (apid != NULL)
        {
            apid[iprop] = pid;
        }

        // Calculate the size of the serialized property (cbprop).
        // StgConvertVariantToProperty returns NULL on overflow and
        // Raises on bad data.

        cbprop = 0;             // Assume property deletion
        if (pid != PID_ILLEGAL && avar != NULL)
        {
            StgConvertVariantToPropertyNoEH(
                            &avar[iprop],
                            CodePage,
                            NULL,   // Don't actualy convert. We just want to calc cbprop.
                            &cbprop,
                            pid,
                            FALSE, FALSE,   // Not a vector or array recursive call
                            pcIndirect,
                            NULL,   // Don't check for min format version required yet
                            pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            PROPASSERT(cbprop == DwordAlign(cbprop));
        }

        // Store the size & PROPID into the PROPINFO array.

        apinfo[iprop].cbprop = cbprop;
        apinfo[iprop].pid = pid;

    }   // for (iprop = 0; iprop < cprop; iprop++)

    //  ----
    //  Exit
    //  ----

Exit:

    if( STATUS_NOT_SUPPORTED == *pstatus )
        propSuppressExitErrors();

    return;
}


//+---------------------------------------------------------------------------
// Function:    BuildIndirectIndexArray, private
//
// Synopsis:    Set property values for a property set
//
// Arguments:   [cprop]         -- count of properties in avar
//              [cAlloc]        -- max count of indirect properties
//              [cIndirect]     -- count of indirect properties in avar
//              [avar]          -- array of PROPVARIANTs
//              [ppip]          -- ptr to ptr to Indirect property structures
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
BuildIndirectIndexArray(
    IN ULONG cprop,             // count of properties in avar
    IN ULONG cAlloc,            // max count of indirect properties
    IN ULONG cIndirect,         // count of indirect properties in avar
    IN PROPVARIANT const avar[],// array of properties+values
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                          // MAXULONG terminated array of Indirect
                                          // properties w/indexes into aprs & avar
    OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITraceStatic( "BuildIndirectIndexArray" );
    propTraceParameters(( "cprop=%d, cAlloc=%d, cIndirect=%d, avar=%p",
                           cprop,    cAlloc,    cIndirect,    avar ));

    PROPASSERT(cIndirect > 0);
    PROPASSERT(cAlloc >= cIndirect);
    PROPASSERT(cprop >= cAlloc);

    if (ppip != NULL)
    {
        INDIRECTPROPERTY *pip;
        ULONG iprop;

        // Get a pointer to an INDIRECTPROPERTY array.  If there
        // is only one entry, then the caller has provided us the buffer.
        // Otherwise, we need to allocate it.

        if (cprop == 1)
        {
            pip = (INDIRECTPROPERTY *) ppip;
        }
        else
        {
            // Allocate the indrect property array

            pip = (INDIRECTPROPERTY *) CoTaskMemAlloc( (cAlloc+1) * sizeof(INDIRECTPROPERTY) );
            if (pip == NULL)
            {
                *pstatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
            }
            *ppip = pip;
        }

        // Loop through the properties, and for each that is indirect,
        // put it's index into the INDIRECTPROPERTY array.

        for (iprop = 0; iprop < cprop; iprop++)
        {
            if (IsIndirectVarType(avar[iprop].vt))
            {
                PROPASSERT(cprop == 1 || (ULONG) (pip - *ppip) < cIndirect);

                pip->Index = iprop;
                pip->poszName = NULL;

                pip++;
            }
        }

        // For the case where we allocated an array, we allocated an extra entry
        // so that we could put a terminator at the end of the array.

        if (cprop > 1)
        {
            pip->Index = MAXULONG;
            PROPASSERT((ULONG) (pip - *ppip) == cIndirect);
        }

    }   // if (ppip != NULL)

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+---------------------------------------------------------------------------
// Function:    PrSetProperties, public
//
// Synopsis:    Set property values for a property set
//
// Arguments:   [np]            -- property set context
//              [cprop]         -- property count
//              [pidNameFirst]  -- first PROPID for new named properties
//              [aprs]          -- array of property specifiers
//              [apid]          -- buffer for array of propids
//                              -- values to write in place of indirect properties
//              [ppip]          -- ptr to ptr to Indirect property structures
//              [avar]          -- array of PROPVARIANTs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OUT USHORT *pCodePage,
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN PROPVARIANT const avar[]) // array of properties+values
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;

    PROPERTY_INFORMATION apinfoStack[6];
    PROPERTY_INFORMATION *apinfo = apinfoStack;
    ULONG cIndirect = 0;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrSetProperties" );
    propTraceParameters(( "np=%p, cprop=%d, pidNameFirst=%d, aprs=%p, CodePage=%d, apid=%p, ppip=%p, avar=%p",
                           np,    cprop,    pidNameFirst,    aprs,    *pCodePage,  apid,    ppip,    avar ));


    // Initialize the INDIRECTPROPERTY structure.

    if (ppip != NULL)
    {
        *ppip = NULL;

        // If cprop is 1, ppip is actually pip (one level
        // of indirection).

        if (cprop == 1)
        {
            // Default the index.
            ((INDIRECTPROPERTY *) ppip)->Index = MAXULONG;
        }
    }

    // Lock the property set.

    Status = ppsstm->Lock(TRUE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    // Is the stack-based apinfo big enough?

    if (cprop > sizeof(apinfoStack)/sizeof(apinfoStack[0]))
    {
        // No - we need to allocate an apinfo.

        apinfo = reinterpret_cast<PROPERTY_INFORMATION*>
                 ( CoTaskMemAlloc( sizeof(PROPERTY_INFORMATION) * cprop ));

        if( NULL == apinfo )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    }

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    // Describe the request into the apinfo array.  This also writes the names
    // to the dictionary.

    ConvertVariantToPropInfo(
                    ppsstm,
                    cprop,
                    pidNameFirst,
                    aprs,
                    apid,
                    avar,
                    apinfo,
                    ppip == NULL? NULL : &cIndirect,
                    &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    // Write the value.  If there are indirect properties, ppip will hold
    // the stream/storage names.

    ppsstm->SetValue(cprop, ppip, avar, apinfo, pCodePage, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    // If we allocated a temporary apinfo buffer, free it.
    if (apinfo != apinfoStack)
    {
        CoTaskMemFree( apinfo );
    }

    // Clean up the PIP array on error.

    if (!NT_SUCCESS(Status))
    {
        if (ppip != NULL)
        {
            if (cprop == 1)
            {
                ((INDIRECTPROPERTY *) ppip)->Index = MAXULONG;
            }
            else if (*ppip != NULL)
            {
                CoTaskMemFree( *ppip );
                *ppip = NULL;
            }
        }
    }

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    if( STATUS_NOT_SUPPORTED == Status )
        propSuppressExitErrors();

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    PrQueryProperties, public
//
// Synopsis:    Query property values from a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [aprs]           -- array of property specifiers
//              [apid]           -- buffer for array of propids
//              [ppip]           -- ptr to ptr to Indirect property structures
//              [avar]           -- array of PROPVARIANTs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound)     // count of property values retrieved
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    SERIALIZEDPROPERTYVALUE const *pprop = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cIndirect = 0;
    ULONG iprop;
    BOOL fLocked = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrQueryProperties" );
    propTraceParameters(( "np=%p, cprop=%d, aprs=%p, apid=%p, ppip=%p)",
                           np,    cprop,    aprs,    apid,    ppip ));

    // Initialize the variant array enough to allow it to be cleaned up
    // by the caller (even on partial failure).

    *pcpropFound = 0;
    if (ppip != NULL)
    {
        *ppip = NULL;
        if (cprop == 1)
        {
            ((INDIRECTPROPERTY *) ppip)->Index = MAXULONG;
        }
    }

    // Zero-ing out the caller-provided PropVariants, essentially
    // sets them all to VT_EMPTY.  It also zeros out the data portion,
    // which prevents cleanup problems in error paths.

    RtlZeroMemory(avar, cprop * sizeof(avar[0]));


    Status = ppsstm->Lock(FALSE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    // Loop through and get all the property values.

    for (iprop = 0; iprop < cprop; iprop++)
    {
        PROPID pid;
        ULONG cbprop;

        // Get the PROPID to query

        switch(aprs[iprop].ulKind)
        {
            // Query the PROPID from the caller-provided name.

            case PRSPEC_LPWSTR:
                pid = ppsstm->QueryPropid(aprs[iprop].lpwstr, &Status);
                if( !NT_SUCCESS(Status) ) goto Exit;
                break;

            // The caller already gave us the PROPID

            case PRSPEC_PROPID:
                pid = aprs[iprop].propid;
                break;

            default:
                PROPASSERT(!"Bad ulKind");
                Status = STATUS_INVALID_PARAMETER;
                goto Exit;

        }

        // Get a pointer to the value in the serialized stream
        // (into pprop).  If this succeeds, pprop will point
        // to the value, and we will know that the value fits within
        // the section (so e.g. there's no corrupt length fields).

        pprop = ppsstm->GetValue(pid, &cbprop, &Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        if (pprop != NULL)
        {
            // We got the property value.

            BOOL fIndirect;

            // De-serialize the property value from pprop to 
            // a PROPVARIANT (into an entry in the avar array).

            (*pcpropFound)++;
            fIndirect = StgConvertPropertyToVariantNoEH(
                                pprop,
                                cbprop,
				ppsstm->GetCodePage(),
                                &avar[iprop],
                                ppsstm->GetAllocator(),
                                &Status);
            if( !NT_SUCCESS(Status) ) goto Exit;

            PROPASSERT( ( !(VT_ARRAY & avar[iprop].vt)
                          &&
                          !(VT_BYREF & avar[iprop].vt)
                          &&
                          VT_DECIMAL != avar[iprop].vt
                          &&
                          VT_I1 != avar[iprop].vt
                          &&
                          VT_INT != avar[iprop].vt
                          &&
                          VT_UINT != avar[iprop].vt
                        )
                        ||
                        PROPSET_WFORMAT_EXPANDED_VTS <= ppsstm->GetFormatVersion()
                      );

            // Keep a count of the number of indirect (aka non-simple) properties.

            if( fIndirect )
            {
                cIndirect++;
            }

        }   // if (pprop != NULL)

        // Pass the actual PROPID back to the caller.

        if (apid != NULL)
        {
            apid[iprop] = pid;
        }

    }   // for (iprop = 0; iprop < cprop; iprop++)

    // If the caller wants to know about indirect streams and
    // storages (and if there were any), allocate memory for a
    // MAXULONG terminated array of indexes to the indirect
    // variant structures, and fill it in.

    if (cIndirect != 0)
    {
        BuildIndirectIndexArray(
                    cprop,
                    cIndirect,
                    cIndirect,
                    avar,
                    ppip,
                    &Status);
        if( !NT_SUCCESS(Status) ) goto Exit;
    }

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(Status) )
    {
        if (ppip != NULL)
        {
            if (cprop == 1)
            {
                ((INDIRECTPROPERTY *) ppip)->Index = MAXULONG;
            }
            else if (*ppip != NULL)
            {
                CoTaskMemFree( *ppip );
                *ppip = NULL;
            }
        }

        CleanupVariants(avar, cprop, ppsstm->GetAllocator());
    }

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    if( STATUS_NOT_SUPPORTED == Status )
        propSuppressExitErrors();

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    PrEnumerateProperties, public
//
// Synopsis:    Enumerate properties in a property set
//
// Arguments:   [np]             -- property set context
//              [cskip]          -- count of properties to skip
//              [pcprop]         -- pointer to property count
//              [Flags]          -- flags: No Names (propids only), etc.
//              [asps]           -- array of STATPROPSTGs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN ULONG *pkey,             // count of properties to skip
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                 // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]) // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    SERIALIZEDPROPERTYVALUE const *pprop = NULL;
    PROPSPEC *pprs;
    STATPROPSTG *psps;
    PROPID *ppidBase = NULL;
    ULONG i;
    ULONG cpropin;
    BOOL fLocked = FALSE;

    PROPID apidStack[20];
    PROPID *ppid;
    ULONG cprop;
    PMemoryAllocator *pma = ppsstm->GetAllocator();

    // PERF: It'd be good to rewrite this name code so that it uses
    // a default-sized stack buffer where possible, which will be most of
    // the time.

    OLECHAR *poszName = NULL;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrEnumerateProperties" );
    propTraceParameters(( "np=%p, Flags=0x%x, key=0x%x, cprop=%d, aprs=%p, asps=%p)\n",
                           np,    Flags,      *pkey,    *pcprop,  aprs,    asps));

    cpropin = *pcprop;

    // Eliminate confusion for easy cleanup

    if (aprs != NULL)
    {
        // Set all the PropSpecs to PROPID (which require
        // no cleanup).

        for (i = 0; i < cpropin; i++)
        {
            aprs[i].ulKind = PRSPEC_PROPID;
        }
    }

    // Zero all pointers in the array for easy cleanup

    if (asps != NULL)
    {
        RtlZeroMemory(asps, cpropin * sizeof(asps[0]));
    }

    Status = ppsstm->Lock(FALSE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;


    ppidBase = NULL;

    cprop = ppsstm->ReOpen(&Status);   // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    if (cprop > cpropin)
    {
	cprop = cpropin;
    }

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    // Point ppid to an array of PROPIDs (either on stack for perf, or in heap
    // if too big).

    ppid = NULL;
    if (aprs != NULL || asps != NULL)
    {
	ppid = apidStack;

	if (cprop > sizeof(apidStack)/sizeof(apidStack[0]))
	{
            // Too big for the stack, alloc it out of heap.

            ppidBase = reinterpret_cast<PROPID*>( CoTaskMemAlloc( cprop * sizeof(PROPID) ));
	    if (ppidBase == NULL)
	    {
		Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
	    }

	    ppid = ppidBase;
	}
    }

    // Enumerate the PROPIDs and put them into the PROPID array we
    // just set up (ppid)

    ppsstm->EnumeratePropids(pkey, &cprop, ppid, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    *pcprop = cprop;

    // Load the STATPROPSTG array (asps) and PROPSPEC array (aprs)

    if (ppid != NULL)
    {
	psps = asps;
	pprs = aprs;

	while (cprop-- > 0)
	{
	    ULONG cbprop;
	    BOOLEAN fHasName;
	
	    PROPASSERT(*ppid != PID_DICTIONARY && *ppid != PID_CODEPAGE);
	    fHasName = FALSE;

            // Unless the caller doesn't want names, get this property's name.

	    if ((Flags & ENUMPROP_NONAMES) == 0)
	    {
                fHasName = ppsstm->QueryPropertyNames( 1, ppid, &poszName, &Status );
                if( !NT_SUCCESS(Status) ) goto Exit;
	    }

            // If we're filling in the PROPSPEC array, load the
            // name or PROPID now.

	    if (pprs != NULL)
	    {
		PROPASSERT(pprs->ulKind == PRSPEC_PROPID);
		if (fHasName)
		{
		    pprs->lpwstr = ppsstm->DuplicatePropertyName( poszName, &Status );
                    if( !NT_SUCCESS(Status) ) goto Exit;
		    PROPASSERT(pprs->lpwstr != NULL);

		    // Make this assignment *after* memory allocation
		    // succeeds so we free only valid pointers in below
		    // cleanup code.

		    pprs->ulKind = PRSPEC_LPWSTR;
		}
		else
		{
		    pprs->propid = *ppid;
		}
		pprs++;

	    }   // if (pprs != NULL)

            // If we're passing back the STATPROPSTGs, fill it in for
            // this property.

	    if (psps != NULL)
	    {
		pprop = ppsstm->GetValue(*ppid, &cbprop, &Status);
                if( !NT_SUCCESS(Status) ) goto Exit;

		PROPASSERT(psps->lpwstrName == NULL);
		if (fHasName)
		{
		    psps->lpwstrName = ppsstm->DuplicatePropertyName( poszName, &Status);
                    if( !NT_SUCCESS(Status) ) goto Exit;
                    PROPASSERT(psps->lpwstrName != NULL);
		}

                psps->propid = *ppid;
		psps->vt = (VARTYPE) PropByteSwap( pprop->dwType );

		psps++;

	    }   // if (psps != NULL)
	
            ppid++;
            CoTaskMemFree( poszName ); poszName = NULL;

	}   // while (cprop-- > 0)
    }   // if (ppid != NULL)

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    if( NULL != poszName )
        CoTaskMemFree( poszName );

    CoTaskMemFree( ppidBase );

    if (!NT_SUCCESS(Status))
    {
        PMemoryAllocator *pma2 = ppsstm->GetAllocator();

        if (aprs != NULL)
        {
            for (i = 0; i < cpropin; i++)
            {
                if (aprs[i].ulKind == PRSPEC_LPWSTR)
                {
                    pma2->Free(aprs[i].lpwstr);
                    aprs[i].ulKind = PRSPEC_PROPID;
                }
            }
        }

        if (asps != NULL)
        {
            for (i = 0; i < cpropin; i++)
            {
                if (asps[i].lpwstrName != NULL)
                {
                    pma2->Free(asps[i].lpwstrName);
                    asps[i].lpwstrName = NULL;
                }
            }
        }
    }   // if (!NT_SUCCESS(Status))

#if DBG
    if (NT_SUCCESS(Status))
    {
	if (aprs != NULL)
	{
	    for (i = 0; i < cpropin; i++)
	    {
		if (aprs[i].ulKind == PRSPEC_LPWSTR)
		{
		    PROPASSERT(aprs[i].lpwstr != NULL);
		    PROPASSERT(ocslen(aprs[i].lpwstr) > 0);
		}
	    }
	}
	if (asps != NULL)
	{
	    for (i = 0; i < cpropin; i++)
	    {
		if (asps[i].lpwstrName != NULL)
		{
		    PROPASSERT(ocslen(asps[i].lpwstrName) > 0);
		}
	    }
	}
    }
#endif // DBG

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    PrQueryPropertyNames, public
//
// Synopsis:    Read property names for PROPIDs in a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [apid]           -- array of PROPIDs
//              [aposz]          -- array of pointers to WCHAR strings
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[])       // OUT pointers to allocated strings
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusQuery = STATUS_SUCCESS;
    BOOL fLocked = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrQueryPropertyNames" );
    propTraceParameters(( "np=%p, cprop=%d, apid=%p, aposz=%p)",
                           np,    cprop,    apid,    aposz ));

    RtlZeroMemory(aposz, cprop * sizeof(aposz[0]));

    Status = ppsstm->Lock(FALSE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    // We'll save the Status from the following call.  If there
    // are no other errors, we'll return it to the caller (it
    // might contain a useful success code).

    ppsstm->QueryPropertyNames(cprop, apid, aposz, &StatusQuery);
    if( !NT_SUCCESS(StatusQuery) )
    {
        Status = StatusQuery;
        goto Exit;
    }

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    if( NT_SUCCESS(Status) )
        Status = StatusQuery;

    return(Status);

}   // PrQueryPropertyNames()


//+---------------------------------------------------------------------------
// Function:    PrSetPropertyNames, public
//
// Synopsis:    Write property names for PROPIDs in a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [apid]           -- array of PROPIDs
//              [aposz]          -- array of pointers to OLECHAR strings
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[]) // pointers to property names
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrSetPropertyNames" );
    propTraceParameters(( "np=%p, cprop=%d, apid=%p, aposz=%p",
                           np,    cprop,    apid,    aposz ));

    Status = ppsstm->Lock(TRUE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->SetPropertyNames(cprop, apid, aposz, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    return(Status);

}   // PrSetPropertyNames()


//+---------------------------------------------------------------------------
// Function:    PrSetPropertySetClassId, public
//
// Synopsis:    Set the property set's ClassId
//
// Arguments:   [np]    -- property set context
//              [pspss] -- pointer to STATPROPSETSTG
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid)      // new CLASSID of propset code
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrSetPropertySetClassId" );
    propTraceParameters(( "np=%p, pclsid=%p", np, pclsid ));

    Status = ppsstm->Lock(TRUE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->SetClassId(pclsid, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    return(Status);

}   // PrSetPropertySetClassId()


//+---------------------------------------------------------------------------
// Function:    PrQueryPropertySet, public
//
// Synopsis:    Query the passed property set
//
// Arguments:   [np]    -- property set context
//              [pspss] -- pointer to STATPROPSETSTG
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS
PrQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss)  // buffer for property set stat information
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fLocked = FALSE;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    IFDBG( HRESULT &hr = Status );
    propITraceStatic( "PrQueryPropertySet" );
    propTraceParameters(( "np=%p, pspss=%p", np, pspss ));

    RtlZeroMemory(pspss, sizeof(*pspss));

    Status = ppsstm->Lock(FALSE);
    if( !NT_SUCCESS(Status) ) goto Exit;
    fLocked = TRUE;

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->QueryPropertySet(pspss, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if (fLocked)
        Status = Unlock( ppsstm, Status );

    return(Status);

}   // PrQueryPropertySet()


inline BOOLEAN
_Compare_VT_BOOL(VARIANT_BOOL bool1, VARIANT_BOOL bool2)
{
    // Allow any non-zero value to match any non-zero value

    return((bool1 == FALSE) == (bool2 == FALSE));
}


BOOLEAN
_Compare_VT_CF(CLIPDATA *pclipdata1, CLIPDATA *pclipdata2)
{
    BOOLEAN fSame;

    if (pclipdata1 != NULL && pclipdata2 != NULL)
    {
        fSame = ( pclipdata1->cbSize == pclipdata2->cbSize
                  &&
                  pclipdata1->ulClipFmt == pclipdata2->ulClipFmt );

        if (fSame)
        {
            if (pclipdata1->pClipData != NULL && pclipdata2->pClipData != NULL)
            {
                fSame = memcmp(
                            pclipdata1->pClipData,
                            pclipdata2->pClipData,
                            CBPCLIPDATA(*pclipdata1)
                              ) == 0;
            }
            else
            {
                // They're the same if both are NULL, or if
                // they have a zero length (if they have a zero
                // length, either one may or may not be NULL, but they're
                // still considered the same).
                // Note that CBPCLIPDATA(*pclipdata1)==CBPCLIPDATA(*pclipdata2).

                fSame = pclipdata1->pClipData == pclipdata2->pClipData
                        ||
                        CBPCLIPDATA(*pclipdata1) == 0;
            }
        }
    }
    else
    {
        fSame = pclipdata1 == pclipdata2;
    }
    return(fSame);
}


//+---------------------------------------------------------------------------
// Function:    PrCompareVariants, public
//
// Synopsis:    Compare two passed PROPVARIANTs -- case sensitive for strings
//
// Arguments:   [CodePage]      -- CodePage
//              [pvar1]         -- pointer to PROPVARIANT
//              [pvar2]         -- pointer to PROPVARIANT
//
// Returns:     TRUE if identical, else FALSE
//---------------------------------------------------------------------------

#ifdef _MAC
EXTERN_C    // The Mac linker doesn't seem to be able to export with C++ decorations
#endif

BOOLEAN
PrCompareVariants(
    USHORT CodePage,
    PROPVARIANT const *pvar1,
    PROPVARIANT const *pvar2)
{
    if (pvar1->vt != pvar2->vt)
    {
        return(FALSE);
    }

    BOOLEAN fSame;
    ULONG i;

    switch (pvar1->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        fSame = TRUE;
        break;

    case VT_I1:
    case VT_UI1:
        fSame = pvar1->bVal == pvar2->bVal;
        break;

    case VT_I2:
    case VT_UI2:
        fSame = pvar1->iVal == pvar2->iVal;
        break;

    case VT_BOOL:
        fSame = _Compare_VT_BOOL(pvar1->boolVal, pvar2->boolVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        fSame = pvar1->lVal == pvar2->lVal;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        fSame = pvar1->hVal.HighPart == pvar2->hVal.HighPart
                &&
                pvar1->hVal.LowPart  == pvar2->hVal.LowPart;
        break;

    case VT_CLSID:
        fSame = memcmp(pvar1->puuid, pvar2->puuid, sizeof(CLSID)) == 0;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        fSame = ( pvar1->blob.cbSize == pvar2->blob.cbSize );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->blob.pBlobData,
                        pvar2->blob.pBlobData,
                        pvar1->blob.cbSize) == 0;
        }
        break;

    case VT_CF:
        fSame = _Compare_VT_CF(pvar1->pclipdata, pvar2->pclipdata);
        break;

    case VT_BSTR:
        if (pvar1->bstrVal != NULL && pvar2->bstrVal != NULL)
        {
            fSame = ( BSTRLEN(pvar1->bstrVal) == BSTRLEN(pvar2->bstrVal) );
            if (fSame)
            {
                fSame = memcmp(
                            pvar1->bstrVal,
                            pvar2->bstrVal,
                            BSTRLEN(pvar1->bstrVal)) == 0;
            }
        }
        else
        {
            fSame = pvar1->bstrVal == pvar2->bstrVal;
        }
        break;

    case VT_LPSTR:
        if (pvar1->pszVal != NULL && pvar2->pszVal != NULL)
        {
            fSame = strcmp(pvar1->pszVal, pvar2->pszVal) == 0;
        }
        else
        {
            fSame = pvar1->pszVal == pvar2->pszVal;
        }
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_LPWSTR:
        if (pvar1->pwszVal != NULL && pvar2->pwszVal != NULL)
        {
            fSame = Prop_wcscmp(pvar1->pwszVal, pvar2->pwszVal) == 0;
        }
        else
        {
            fSame = pvar1->pwszVal == pvar2->pwszVal;
        }
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        fSame = ( pvar1->caub.cElems == pvar2->caub.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->caub.pElems,
                        pvar2->caub.pElems,
                        pvar1->caub.cElems * sizeof(pvar1->caub.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
        fSame = ( pvar1->cai.cElems == pvar2->cai.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cai.pElems,
                        pvar2->cai.pElems,
                        pvar1->cai.cElems * sizeof(pvar1->cai.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_BOOL:
        fSame = ( pvar1->cabool.cElems == pvar2->cabool.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->cabool.cElems; i++)
            {
                fSame = _Compare_VT_BOOL(
                                pvar1->cabool.pElems[i],
                                pvar2->cabool.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        fSame = ( pvar1->cal.cElems == pvar2->cal.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cal.pElems,
                        pvar2->cal.pElems,
                        pvar1->cal.cElems * sizeof(pvar1->cal.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        fSame = ( pvar1->cah.cElems == pvar2->cah.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cah.pElems,
                        pvar2->cah.pElems,
                        pvar1->cah.cElems *
                            sizeof(pvar1->cah.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CLSID:
        fSame = ( pvar1->cauuid.cElems == pvar2->cauuid.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cauuid.pElems,
                        pvar2->cauuid.pElems,
                        pvar1->cauuid.cElems *
                            sizeof(pvar1->cauuid.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CF:
        fSame = ( pvar1->caclipdata.cElems == pvar2->caclipdata.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->caclipdata.cElems; i++)
            {
                fSame = _Compare_VT_CF(
                                &pvar1->caclipdata.pElems[i],
                                &pvar2->caclipdata.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_BSTR:
        fSame = ( pvar1->cabstr.cElems == pvar2->cabstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->cabstr.cElems; i++)
            {
                if (pvar1->cabstr.pElems[i] != NULL &&
                    pvar2->cabstr.pElems[i] != NULL)
                {
                    fSame = ( BSTRLEN(pvar1->cabstr.pElems[i])
                              ==
                              BSTRLEN(pvar2->cabstr.pElems[i]) );
                    if (fSame)
                    {
                        fSame = memcmp(
                                    pvar1->cabstr.pElems[i],
                                    pvar2->cabstr.pElems[i],
                                    BSTRLEN(pvar1->cabstr.pElems[i])) == 0;
                    }
                }
                else
                {
                    fSame = pvar1->cabstr.pElems[i] == pvar2->cabstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        fSame = ( pvar1->calpstr.cElems == pvar2->calpstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->calpstr.cElems; i++)
            {
                if (pvar1->calpstr.pElems[i] != NULL &&
                    pvar2->calpstr.pElems[i] != NULL)
                {
                    fSame = strcmp(
                                pvar1->calpstr.pElems[i],
                                pvar2->calpstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpstr.pElems[i] ==
                            pvar2->calpstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        fSame = ( pvar1->calpwstr.cElems == pvar2->calpwstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->calpwstr.cElems; i++)
            {
                if (pvar1->calpwstr.pElems[i] != NULL &&
                    pvar2->calpwstr.pElems[i] != NULL)
                {
                    fSame = Prop_wcscmp(
                                pvar1->calpwstr.pElems[i],
                                pvar2->calpwstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpwstr.pElems[i] ==
                            pvar2->calpwstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        fSame = ( pvar1->capropvar.cElems == pvar2->capropvar.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->capropvar.cElems; i++)
            {
                fSame = PrCompareVariants(
                                CodePage,
                                &pvar1->capropvar.pElems[i],
                                &pvar2->capropvar.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT Comparison");
        fSame = FALSE;
        break;

    }
    return(fSame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\nffmstm.cxx ===
//+============================================================================
//
//  File:   nffmstm.cxx
//
//  This file provides the NFF (NTFS Flat File) IMappedStream implementation.
//
//  History:
//      5/6/98  MikeHill
//              -   Misc dbg cleanup.
//
//+============================================================================

#include <pch.cxx>



CNFFMappedStream::~CNFFMappedStream()
{
    HRESULT hr = S_OK;

    // If the update stream has the latest data, rename it over the original
    // stream.  Ordinarily this replace call will create a new update stream.
    // But since we're going away, tell it not to bother.
    // Errors are ignored here because there's no way to return them.
    // If the caller wishes to avoid this, they should call Flush first.

    if( NULL != _pstmUpdate )
    {
        ReplaceOriginalWithUpdate( DONT_CREATE_NEW_UPDATE_STREAM );
        DfpVerify( 0 == RELEASE_INTERFACE(_pstmUpdate) );
    }


    // Just to be safe, free the mapping buffer (it should have
    // already been freed).

    DfpAssert( NULL == _pbMappedStream );
    CoTaskMemFree( _pbMappedStream );

    // If we've got the global reserved buffer locked,
    // free it now.

    if (_fLowMem)
        g_ReservedMemory.UnlockMemory();

}




HRESULT
CNFFMappedStream::QueryInterface( REFIID riid, void**ppvObject )
{
    return( _pnffstm->QueryInterface( riid, ppvObject ));
}

ULONG
CNFFMappedStream::AddRef()
{
    return( _pnffstm->AddRef() );
}

ULONG
CNFFMappedStream::Release()
{
    return( _pnffstm->Release() );
}



//+----------------------------------------------------------------------------
//
//  Method:     CNFFMappedStream::Open (IMappedStream)
//
//+----------------------------------------------------------------------------


VOID
CNFFMappedStream::Open( IN VOID  *powner, OUT LONG *phr )
{
    nffITrace( "CNFFMappedStream::Open" );
    VOID *pv = NULL;
    HRESULT sc=S_OK;

    BOOL fUsingLatestStream = FALSE;

    DfpAssert(!_fLowMem);

    _pnffstm->Lock( INFINITE );

    nffChk( _pnffstm->CheckReverted() );

    // If the previous open crashed during a flush, roll forward to the
    // updated copy.  If we're only open for read access, then this will
    // just set _fUpdateStreamHasLatest so that we'll know to process
    // reads from that stream.

    nffChk( RollForwardIfNecessary() );

    BeginUsingLatestStream();
    fUsingLatestStream = TRUE;

    // If given a pointer to the owner of this mapped stream,
    // save it.  This could be NULL (i.e., when called from
    // ReOpen).

    if( NULL != powner  )
        _pMappedStreamOwner = powner;

    // If we haven't already read the stream, read it now.

    if( NULL == _pbMappedStream )
    {
        BY_HANDLE_FILE_INFORMATION fileinfo;

        DfpAssert( INVALID_HANDLE_VALUE != _pnffstm->GetFileHandle() );
        DfpAssert( 0 == _cbMappedStream );
        DfpAssert( 0 == _cbMappedStreamActual);

        // Get and validate the size of the file

        if( !GetFileInformationByHandle( _pnffstm->GetFileHandle(), &fileinfo ))
        {
            nffErr( EH_Err, LAST_SCODE );
        }
        else if( 0 != fileinfo.nFileSizeHigh
                 || CBMAXPROPSETSTREAM < fileinfo.nFileSizeLow )
        {
            nffErr( EH_Err, STG_E_INVALIDHEADER );
        }

        _cbMappedStream = _cbMappedStreamActual = fileinfo.nFileSizeLow;

        // Allocate a buffer to hold the Stream.  If there isn't sufficient
        // memory in the system, lock and get the reserved buffer.  In the
        // end, 'pv' points to the appropriate buffer.

#if DBG
        pv = _fSimulateLowMem ? NULL : CoTaskMemAlloc( _cbMappedStreamActual );
#else
        pv = CoTaskMemAlloc( _cbMappedStreamActual );
#endif

        if( NULL == pv )
        {
            // could block until previous property call completes
            pv = g_ReservedMemory.LockMemory();

            if( NULL == pv )
                nffErr( EH_Err, E_OUTOFMEMORY );

            _fLowMem = TRUE;
        }
        _pbMappedStream = (BYTE*) pv;

        // Read in the file.

        if( 0 != _cbMappedStreamActual )
        {
            ULARGE_INTEGER ulOffset;
            ulOffset.QuadPart = 0;

            if( FAILED(_pnffstm->SyncReadAtFile( ulOffset, _pbMappedStream,
                                                 _cbMappedStreamActual, &_cbMappedStream)))
            {
                nffErr( EH_Err, LAST_SCODE );
            }


            // Ensure that we got all the bytes we requested.

            if( _cbMappedStream != _cbMappedStreamActual )
            {
                propDbg((DEBTRACE_ERROR,
                         "CMappedStreamOnHFile(%08X)::Open bytes-read (%lu) doesn't match bytes-requested (%lu)\n",
                         this, _cbMappedStream, _cbMappedStreamActual ));
                nffErr( EH_Err, STG_E_INVALIDHEADER );
            }
        }


#if BIGENDIAN==1
        // Notify our owner that we've read in new data.

        if( _pMappedStreamOwner != NULL && 0 != _cbMappedStream )
        {
            nffChk( PrOnMappedStreamEvent( _pMappedStreamOwner, _pbMappedStream, _cbMappedStream ) );
        }
#endif

    }   // if( NULL == _pbMappedStream )

    //  ----
    //  Exit
    //  ----

EH_Err:

    if( fUsingLatestStream )
        EndUsingLatestStream();

    // If there was an error, free any memory we have.

    if( FAILED(sc) )
    {
        propDbg((DEB_ERROR, "IMappedStream::CNtfsStream(%08X)::Open exception returns %08X\n", this, *phr));

        if (_fLowMem)
            g_ReservedMemory.UnlockMemory();
        else
            CoTaskMemFree(pv);

        _pbMappedStream = NULL;
        _cbMappedStream = _cbMappedStreamActual = 0;
        _fLowMem = FALSE;
    }

    _pnffstm->Unlock();
    *phr = sc;
    return;

}


//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Flush (IMappedStream)
//
//--------------------------------------------------------------------

VOID CNFFMappedStream::Flush(OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::Flush" );
    HRESULT sc=S_OK;
    BOOL fUsingLatestStream = FALSE;

    _pnffstm->Lock( INFINITE );;

    BeginUsingLatestStream();
    fUsingLatestStream = TRUE;

    nffChk( _pnffstm->CheckReverted() );

    if( !IsWriteable() )
        nffErr( EH_Err, STG_E_ACCESSDENIED );


    // If the IMappedStream is being used, write it out to the
    // underlying file.

    if( NULL != _pbMappedStream )
        nffChk( WriteMappedStream() );

    // Commit the Stream.
    if( !FlushFileBuffers( _pnffstm->GetFileHandle() ))
        nffErr( EH_Err, LAST_SCODE );

    EndUsingLatestStream();
    fUsingLatestStream = FALSE;

    nffChk( ReplaceOriginalWithUpdate( CREATE_NEW_UPDATE_STREAM ));

    sc = S_OK;

EH_Err:

    if( fUsingLatestStream )
        EndUsingLatestStream();

    _pnffstm->Unlock();
    *phr = sc;
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     IMappedStream::Close
//
//  Synopsis:   Close the mapped stream by writing out
//              the mapping buffer and then freeing it.
//              Errors are ignored, so if the caller wants an
//              opportunity to recover from an error, they should
//              call Flush before calling Close.
//
//  Arguments:  [LONG*] phr
//                  An HRESULT error code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID CNFFMappedStream::Close(OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::Close" );
    HRESULT sc=S_OK;

    _pnffstm->Lock( INFINITE );

    // So watch out for multiple closes.
    sc = _pnffstm->CheckReverted();

    // If we are already closed then return immediatly (but don't error)
    if( STG_E_REVERTED == sc )
    {
        sc = S_OK;
        goto EH_Err;
    }

    // Report any real errors.
    if( FAILED( sc ) )
        nffErr( EH_Err, sc );

    // Write the changes.  We don't need to Commit them,
    // they will be implicitely committed when the
    // Stream is Released.

    sc = WriteMappedStream();

    // Even if we fail the write, we must free the memory.
    // (PrClosePropertySet deletes everything whether or not
    // there was an error here, so we must free the memory.
    // There's no danger of this happenning due to out-of-
    // disk-space conditions, because the propset code
    // pre-allocates).

    CoTaskMemFree( _pbMappedStream );
    _pbMappedStream = NULL;

    // Re-zero the member data.
    InitMappedStreamMembers();

    sc = S_OK;

EH_Err:

    _pnffstm->Unlock();
    *phr = sc;
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::ReOpen (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::ReOpen(IN OUT VOID **ppv, OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::ReOpen" );
    HRESULT sc=S_OK;

    *ppv = NULL;

    _pnffstm->Lock( INFINITE );;

    nffChk( _pnffstm->CheckReverted() );

    this->Open(NULL, &sc);
    nffChk(sc);

    *ppv = _pbMappedStream;

EH_Err:
    _pnffstm->Unlock();
    *phr = sc;
    return;

}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Quiesce (IMappedStream)
//
//--------------------------------------------------------------------

VOID CNFFMappedStream::Quiesce(VOID)
{
    nffITrace( "CNFFMappedStream::Quiesce" );
    // Not necessary for this implemented
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Map (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::Map(IN BOOLEAN fCreate, OUT VOID **ppv)
{
    nffITrace( "CNFFMappedStream::Map" );
    HRESULT sc;

    _pnffstm->Lock( INFINITE );;

    nffChk( _pnffstm->CheckReverted() );

    DfpAssert(_pbMappedStream != NULL);
    *ppv = _pbMappedStream;

EH_Err:
    _pnffstm->Unlock();
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Unmap (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::Unmap(BOOLEAN fFlush, VOID **ppv)
{
    nffITrace( "CNFFMappedStream::Unmap" );

    *ppv = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::WriteMappedStream (internal support for IMappedStream)
//
//  Returns:    S_OK if successful, S_FALSE if there was nothing to write.
//
//--------------------------------------------------------------------
#define STACK_BYTES 16

HRESULT
CNFFMappedStream::WriteMappedStream()
{
    nffITrace( "CNFFMappedStream::WriteMappedStream" );
    HRESULT sc = S_OK;
    ULONG cbWritten;
    BOOL fOwnerSignaled = FALSE;
    BOOL fUsingUpdateStream = FALSE;

    // We can return right away if there's nothing to write.
    // (_pbMappedStream may be NULL in the error path of our
    // caller).

    if (!IsModified() || NULL == _pbMappedStream )
    {
        propDbg((DEB_TRACE, "IMappedStream::CNtfsStream(%08X)::Flush returns with not-dirty\n", this));
        return S_FALSE;
    }

    // Put the update stream's handle into _pnffstm, so that we write out to it.

    BeginUsingUpdateStream();
    fUsingUpdateStream = TRUE;

    DfpAssert( INVALID_HANDLE_VALUE != _pnffstm->GetFileHandle() );

#if BIGENDIAN==1
    // Notify our owner that we're about to perform a Write.
    nffChk( PrOnMappedStreamEvent( _powner, _pbMappedStream, _cbMappedStream ) );
    fOwnerSignaled = TRUE;
#endif

    // Write out the mapping buffer (to the update stream).

    ULARGE_INTEGER ulOffset;
    ulOffset.QuadPart = 0;

    nffChk( _pnffstm->SyncWriteAtFile( ulOffset, _pbMappedStream,
                                       _cbMappedStream, &cbWritten ));

    if( cbWritten != _cbMappedStream )
    {
        propDbg((DEB_ERROR,
                 "CMappedStreamOnHFile(%08X)::Write bytes-written (%lu) doesn't match bytes-requested (%lu)\n",
                 this, cbWritten, _cbMappedStream ));
        sc = STG_E_INVALIDHEADER;
        goto EH_Err;
    }

    // If the buffer is shrinking, this is a good time to shrink the file.

    if (_cbMappedStream < _cbMappedStreamActual)
    {
        nffChk( _pnffstm->SetSize( static_cast<CULargeInteger>(_cbMappedStream) ) );
        _cbMappedStreamActual = _cbMappedStream;
    }

    if( _fStreamRenameSupported )
    {
        // We wrote the data to the update stream.  So flag that it now
        // has the latest data.

        _fUpdateStreamHasLatest = TRUE;
        DfpAssert( NULL != _pstmUpdate && INVALID_HANDLE_VALUE != _pstmUpdate->GetFileHandle() );
    }

    //  ----
    //  Exit
    //  ----

EH_Err:

#if BIGENDIAN==1
    // Notify our owner that we're done with the Write.  We do this
    // whether or not there was an error, because _pbMappedStream is
    // not modified, and therefore intact even in the error path.

    if( fOwnerSignaled )
    {
        DfpVerify( PrOnMappedStreamEvent( _powner,
                                    _pbMappedStream, _cbMappedStream ) );
    }
#endif

    if( fUsingUpdateStream )
        EndUsingUpdateStream();

    if (sc == S_OK || sc == STG_E_REVERTED)
    {
        _fMappedStreamDirty = FALSE;
    }

    propDbg(( DbgFlag(sc,DEB_ITRACE), "CNtfsStream(%08X)::Write %s returns hr=%08X\n",
              this, sc != S_OK ? "exception" : "", sc));

    return sc;

}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::GetSize (IMappedStream)
//
//--------------------------------------------------------------------

ULONG CNFFMappedStream::GetSize(OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::GetSize" );
    HRESULT sc=S_OK;

    _pnffstm->Lock( INFINITE );;

    nffChk( _pnffstm->CheckReverted() );

    // If necessary, open the Stream.

    if( NULL == _pbMappedStream )
    {
        this->Open(NULL, &sc);
    }

    if( SUCCEEDED(sc) )
    {
        DfpAssert( NULL != _pbMappedStream );
    }

    // Return the size of the mapped stream.  If there was an
    // Open error, it will be zero, and *phr will be set.

EH_Err:
    _pnffstm->Unlock();
    *phr = sc;

    return _cbMappedStream;
}


//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::InitMappedStreamMembers
//
//--------------------------------------------------------------------

void
CNFFMappedStream::InitMappedStreamMembers()
{
    nffITrace( "CNFFMappedStream::InitMappedStreamMembers" );

    _pbMappedStream = NULL;
    _cbMappedStream = 0;
    _cbMappedStreamActual = 0;
    _pMappedStreamOwner = NULL;
    _fLowMem = FALSE;
    _fMappedStreamDirty = FALSE;

    _fCheckedForRollForward = FALSE;
    _fStreamRenameSupported = FALSE;

    _cUpdateStreamInUse = _cLatestStreamInUse = 0;
}


//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::SetSize (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::SetSize(IN ULONG cb,
                     IN BOOLEAN fPersistent,
                     IN OUT VOID **ppv, OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::SetSize" );
    BYTE  *pv;

    HRESULT &sc = *phr;
    BOOL fUsingUpdateStream = FALSE, fUsingLatestStream = FALSE;

    DfpAssert(cb != 0);

    sc = S_OK;

    _pnffstm->Lock( INFINITE );;

    nffChk( _pnffstm->CheckReverted() );

    if( CBMAXPROPSETSTREAM < cb )
        nffErr( EH_Err, STG_E_MEDIUMFULL );

    if( fPersistent )
    {
        nffChk( CreateUpdateStreamIfNecessary() );
        BeginUsingUpdateStream();
        fUsingUpdateStream = TRUE;
    }
    else
    {
        BeginUsingLatestStream();
        fUsingLatestStream = TRUE;
    }

    // if we are growing the data, we should grow the file

    if( fPersistent && cb > _cbMappedStreamActual )
    {
        nffChk( _pnffstm->SetFileSize( CULargeInteger(cb) ) );
        _cbMappedStreamActual = cb;
    }

    // We only get here if we either (1) didn't want to grow the
    // underlying stream, or (2) we successfully grew the underlying stream.

    // Re-size the buffer to the size specified in cb.

    if( _fLowMem )
    {
        // If we want to grow the buffer In low-memory conditions,
        // no realloc is necessary, because
        // _pbMappedStream is already large enough for the largest
        // property set.

        if( NULL != ppv )
            *ppv = _pbMappedStream;
    }
    else if ( cb != _cbMappedStream )
    {

        // We must re-alloc the buffer.

#if DBG
        pv = _fSimulateLowMem ? NULL : (PBYTE) CoTaskMemRealloc( _pbMappedStream, cb );
#else
        pv = (PBYTE)CoTaskMemRealloc( _pbMappedStream, cb );
#endif

        if ((pv == NULL) )
        {
            // allocation failed: we need to try using a backup mechanism for
            // more memory.
            // copy the data to the global reserved chunk... we will wait until
            // someone else has released it.  it will be released on the way out
            // of the property code.

            pv = g_ReservedMemory.LockMemory();

            if( NULL == pv )
                nffErr( EH_Err, E_OUTOFMEMORY );

            _fLowMem = TRUE;

            if( NULL != _pbMappedStream )
            {
                memcpy( pv, _pbMappedStream, _cbMappedStream );
            }
            CoTaskMemFree( _pbMappedStream );
        }

        _pbMappedStream = pv;

        if( NULL != ppv )
            *ppv = pv;
    }
    _cbMappedStream = cb;

    //  ----
    //  Exit
    //  ----

EH_Err:

    if( fUsingUpdateStream )
    {
        DfpAssert( !fUsingLatestStream );
        EndUsingUpdateStream();
    }
    else if( fUsingLatestStream )
    {
        EndUsingLatestStream();
    }

    _pnffstm->Unlock();

    if( FAILED(*phr) )
    {
        propDbg((DbgFlag(*phr,DEB_ITRACE), "IMappedStream::CNtfsStream(%08X)::SetSize %s returns hr=%08X\n",
                this, *phr != S_OK ? "exception" : "", *phr));
    }

}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Lock (IMappedStream)
//
//--------------------------------------------------------------------

NTSTATUS
CNFFMappedStream::Lock(IN BOOLEAN fExclusive)
{
    // Don't trace at this level.  The noice is too great!
    //nffXTrace( "CNFFMappedStream::Lock");

    UNREFERENCED_PARM(fExclusive);
    _pnffstm->Lock( INFINITE );
    return(STATUS_SUCCESS);

}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::Unlock (IMappedStream)
//
//--------------------------------------------------------------------

// Should we unlock even if there's an error?
NTSTATUS
CNFFMappedStream::Unlock(VOID)
{
    // Don't trace at this level.  The noise is too great!
    //nffXTrace( "CNFFMappedStream::Unlock");
    // if at the end of the properties set/get call we have the low
    // memory region locked, we flush to disk.
    HRESULT sc = S_OK;

    if (_fLowMem)
    {
        Flush(&sc);

        g_ReservedMemory.UnlockMemory();
        _pbMappedStream = NULL;
        _cbMappedStream = _cbMappedStreamActual = 0;
        _fLowMem = FALSE;
        propDbg((DEB_PROP_INFO, "CMappedStreamOnHFile(%08X):Unlock low-mem returns NTSTATUS=%08X\n",
            this, sc));
    }

    _pnffstm->Unlock();

    return(sc);

}

//+-------------------------------------------------------------------
//
//  Member:     Unused methods by this IMappedStream implementation:
//              QuerySecurity, IsWritable, GetHandle, QueryTimeStamps,
//              and QueryModifyTime.
//
//--------------------------------------------------------------------

BOOLEAN
CNFFMappedStream::QuerySecurity(OUT ULONG *pul) const
{
    nffITrace( "CNFFMappedStream::QuerySecurity" );
    return(FALSE);
}

BOOLEAN
CNFFMappedStream::IsWriteable() const
{
    nffITrace( "CNFFMappedStream::IsWriteable" );
    return( (BOOLEAN) _pnffstm->IsWriteable() );
}

HANDLE
CNFFMappedStream::GetHandle(VOID) const
{
    nffITrace( "CNFFMappedStream::GetHandle" );
    return(INVALID_HANDLE_VALUE);
}

VOID
CNFFMappedStream::QueryTimeStamps(OUT STATPROPSETSTG *pspss, BOOLEAN fNonSimple) const
{
    nffITrace( "CNFFMappedStream::QueryTimeStamps" );
}

BOOLEAN
CNFFMappedStream::QueryModifyTime(OUT LONGLONG *pll) const
{
    nffITrace( "CNFFMappedStream::QueryModifyTime" );
    return(FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CNFFMappedStream::SetModified/IsModified (IMappedStream)
//
//--------------------------------------------------------------------

VOID
CNFFMappedStream::SetModified(OUT LONG *phr)
{
    nffITrace( "CNFFMappedStream::SetModified" );
    HRESULT &sc = *phr;

    _pnffstm->Lock( INFINITE );;

    nffChk( _pnffstm->CheckReverted() );

    nffChk( CreateUpdateStreamIfNecessary() );

    _fMappedStreamDirty = TRUE;
    sc = S_OK;

EH_Err:

    _pnffstm->Unlock();
}

BOOLEAN
CNFFMappedStream::IsModified(VOID) const
{
    nffITrace( "CNFFMappedStream::IsModified" );
    return _fMappedStreamDirty;
}

//+-------------------------------------------------------------------
//
//  Member:     ImappedStream::IsNtMappedStream/SetChangePending
//
//  Synopsis:   Debug routines.
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN
CNFFMappedStream::IsNtMappedStream(VOID) const
{
    nffITrace( "CNFFMappedStream::IsNtMappedStream" );
    return(TRUE);
}
#endif


#if DBGPROP
BOOLEAN
CNFFMappedStream::SetChangePending(BOOLEAN f)
{
    nffITrace( "CNFFMappedStream::SetChangePending" );
    return(f);
}
#endif


//
//  CNFFMappedStream::BeginUsingLatestStream/EndUsingLatestStream
//
//  These routines are similar to Begin/EndUsing*Update*Stream,
//  except that they honor the _fUpdateStreamHasLatest flag.
//  Thus, if the original stream has the latest data, then this
//  routine will do nothing.
//

void
CNFFMappedStream::BeginUsingLatestStream()
{
    if( _fUpdateStreamHasLatest )
    {
        if( 0 == _cLatestStreamInUse++ )
            BeginUsingUpdateStream();
    }
}

void
CNFFMappedStream::EndUsingLatestStream()
{
    if( 0 != _cLatestStreamInUse )
    {
        EndUsingUpdateStream();
        _cLatestStreamInUse--;
    }

    DfpAssert( static_cast<USHORT>(-1) != _cLatestStreamInUse );
}



//
//  CNFFMappedStream::BeginUsingUpdateStream
//
//  This is called when the update stream is to be used.  It
//  does nothing, though, if we don't have an update stream
//  (e.g. if the file system doesn't support stream renames).
//  We increment the _cUpdateStreamInUse count, so that we can determine in
//  EndUsingUpdateStream when to swap the handles back.

void
CNFFMappedStream::BeginUsingUpdateStream()
{
    if( NULL != _pstmUpdate
        &&
        INVALID_HANDLE_VALUE != _pstmUpdate->GetFileHandle()
        &&
        0 == _cUpdateStreamInUse++ )
    {
        HANDLE hTemp = _pnffstm->_hFile;
        _pnffstm->_hFile = _pstmUpdate->_hFile;
        _pstmUpdate->_hFile = hTemp;
    }

}

//
//  CNFFMappedStream::EndUsingUpdateStream
//
//  Decrement the _cUpdateStreamInUse count.  And, if that puts
//  the count down to zero, swap the handles back.
//

void
CNFFMappedStream::EndUsingUpdateStream()
{
    if( 0 != _cUpdateStreamInUse
        &&
        0 == --_cUpdateStreamInUse )
    {
        DfpAssert( NULL != _pstmUpdate && INVALID_HANDLE_VALUE != _pstmUpdate->GetFileHandle() );

        HANDLE hTemp = _pnffstm->_hFile;
        _pnffstm->_hFile = _pstmUpdate->_hFile;
        _pstmUpdate->_hFile = hTemp;
    }
    DfpAssert( static_cast<USHORT>(-1) != _cUpdateStreamInUse );
}


inline HRESULT
CNFFMappedStream::CreateUpdateStreamIfNecessary()
{
    if( _fStreamRenameSupported
        &&
        ( NULL == _pstmUpdate
          ||
          INVALID_HANDLE_VALUE == _pstmUpdate->GetFileHandle()
        )
      )
    {
        return( OpenUpdateStream( TRUE ));
    }
    else
        return( S_OK );
}


//+----------------------------------------------------------------------------
//
//  Method: CNFFMAppedStream::RollForwardIfNecessary (non-interface method)
//
//  In the open path, we look to see if there's a leftover update stream for
//  a previous open of the stream, which must have crashed during a write.
//  If we're opening for write, we fix the problem.  Otherwise, we
//  just remember that we'll have to read out of the update stream.
//
//  See the CNtfsStreamForPropStg class declaration for a description of
//  this transactioning.
//
//+----------------------------------------------------------------------------

HRESULT
CNFFMappedStream::RollForwardIfNecessary()
{
    HRESULT hr = S_OK;
    BY_HANDLE_FILE_INFORMATION ByHandleFileInformation;

    // If we've already checked for this, then we needn't check again.
    if( _fCheckedForRollForward )
        goto Exit;

    // We also needn't do anything if we're creating, since that overwrites
    // any existing data anyway.

    if( !(STGM_CREATE & _pnffstm->_grfMode) )
    {
        // Get the size of the current stream.

        if( !GetFileInformationByHandle( _pnffstm->_hFile, &ByHandleFileInformation ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Exit;
        }

        // If the size is zero, then there might be an update
        // stream with the real data.

        if( 0 == ByHandleFileInformation.nFileSizeLow
            &&
            0 == ByHandleFileInformation.nFileSizeHigh )
        {
            // See if there's an update stream
            hr = OpenUpdateStream( FALSE );
            if( SUCCEEDED(hr) )
            {
                // We have a zero-length main stream and an update stream,
                // so there must have been a crash in ReplaceOriginalWithUpdate,
                // after the truncation but before the NtSetInformationFile
                // (FileRenameInformation).

                // If this is a writable stream, rename the update stream
                // over the zero-length one.  Otherwise, we'll just read from
                // the update stream.

                _fUpdateStreamHasLatest = TRUE;

                if( IsWriteable() )
                {
                    hr = ReplaceOriginalWithUpdate( DONT_CREATE_NEW_UPDATE_STREAM );
                    if( FAILED(hr) ) goto Exit;
                }
            }
            else if( STG_E_FILENOTFOUND == hr )
                // Ignore the case where there's no update stream.  This happens
                // when the stream is created without STGM_CREATE set.
                hr = S_OK;
            else
                goto Exit;
        }
    }   // if( !(STGM_CREATE & _grfMode) )

    // We don't need to check for this again.
   _fCheckedForRollForward = TRUE;

Exit:

   return( hr );

}   // CNtfsStreamForPropStg::RollForwardIfNecessary


//+----------------------------------------------------------------------------
//
//  Method: CNtfsStreamForPropStg::ReplaceOriginalWithUpdate (internal method)
//
//  This method renames the update stream over the original stream, then
//  creates a new update stream (with no data but properly sized).  If, however,
//  the update stream doesn't have the latest data anyway, then this routine
//  noops.
//
//  See the CNtfsStreamForPropStg class declaration for a description of
//  this transactioning.
//
//+----------------------------------------------------------------------------

HRESULT
CNFFMappedStream::ReplaceOriginalWithUpdate( enumCREATE_NEW_UPDATE_STREAM CreateNewUpdateStream )
{
    HRESULT hr = S_OK;
    NTSTATUS status;

    FILE_END_OF_FILE_INFORMATION file_end_of_file_information;
    IO_STATUS_BLOCK io_status_block;

    // If the original stream already has the latest data, then
    // there's nothing to do.

    if( !_fUpdateStreamHasLatest )
        goto Exit;

    DfpAssert( NULL != _pstmUpdate );
    DfpAssert( 0 == _cUpdateStreamInUse );

    // We must write the update data all the way to disk.

    hr = _pstmUpdate->Flush();
    if( FAILED(hr) ) goto Exit;

    // Truncate the original stream so that it can be overwritten.
    // After this atomic operation, the update stream is considered
    // *the* stream (which is why we had to flush it above).

    file_end_of_file_information.EndOfFile = CLargeInteger(0);

    status = NtSetInformationFile( _pnffstm->_hFile, &io_status_block,
                                   &file_end_of_file_information,
                                   sizeof(file_end_of_file_information),
                                   FileEndOfFileInformation );
    if( !NT_SUCCESS(status) )
    {
        hr = NtStatusToScode(status);
        goto Exit;
    }

    NtClose( _pnffstm->_hFile );
    _pnffstm->_hFile = INVALID_HANDLE_VALUE;

    // Rename the updated stream over the original (now empty) stream.
    // This is guaranteed by NTFS to be atomic.

    hr = _pstmUpdate->Rename( _pnffstm->_pwcsName, TRUE );
    if( FAILED(hr) )
    {
        // Go into the reverted state and return the error.
        // The state is still in the update stream, and we'll
        // use it on the next open.
        // Bug 566706: Actually, this doesn't make sense to
        // return an error to the caller; we've already truncated
        // the original stream, so this transaction is committed, and
        // we shouldn't make them think otherwise.

        NtClose( _pstmUpdate->_hFile );
        _pstmUpdate->_hFile = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    // Make the updated stream the master

    _pnffstm->_hFile = _pstmUpdate->_hFile;
    _pstmUpdate->_hFile = INVALID_HANDLE_VALUE;
    _fUpdateStreamHasLatest = FALSE;

    // Optionally create a new update stream.

    if( CREATE_NEW_UPDATE_STREAM == CreateNewUpdateStream )
    {
        // return an error if we cannot create the update stream
        hr = OpenUpdateStream( TRUE );
        if( FAILED(hr) ) goto Exit;
    }
    else
        DfpAssert( DONT_CREATE_NEW_UPDATE_STREAM == CreateNewUpdateStream );


Exit:

    return( hr );

}   // CNFFMappedStream::ReplaceOriginalWithUpdate()



//+----------------------------------------------------------------------------
//
//  Method: CNFFMappedStream::OpenUpdateStream
//
//  This method opens the update stream, to which stream updates are written.
//  This is necessary to provide a minimal level of transactioning.
//
//  See the CNtfsStreamForPropStg class declaration for a description of
//  this transactioning.
//
//+----------------------------------------------------------------------------

HRESULT
CNFFMappedStream::OpenUpdateStream( BOOL fCreate )
{
    HRESULT hr = S_OK;
    HANDLE hStream = INVALID_HANDLE_VALUE;
    CNtfsUpdateStreamName UpdateStreamName = _pnffstm->_pwcsName;

    // Open the NTFS stream

    hr = _pnffstm->_pnffstg->GetStreamHandle( &hStream,
                                             UpdateStreamName,
                                             _pnffstm->_grfMode | (fCreate ? STGM_CREATE : 0),
                                             fCreate );
    if( FAILED(hr) ) goto Exit;

    // If necessary, instantiate a CNtfsUpdateStreamForPropStg

    if( NULL == _pstmUpdate )
    {
        _pstmUpdate = new CNtfsUpdateStreamForPropStg( _pnffstm->_pnffstg, _pnffstm->_pBlockingLock );
        if( NULL == _pstmUpdate )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    // Put the NTFS stream handle into the CNtfsUpdateStreamForPropStg

    hr = _pnffstm->_pnffstg->InitCNtfsStream( _pstmUpdate, hStream,
                                              _pnffstm->_grfMode | (fCreate ? STGM_CREATE : 0),
                                              UpdateStreamName );

    hStream = INVALID_HANDLE_VALUE; // ownership of the handle has changed

    if( FAILED(hr) ) goto Exit;

    // If we're creating the update stream, size it to match the size
    // of the original stream.

    if( fCreate )
    {
        ULONG ulSize = GetSize(&hr);
        if( FAILED(hr) ) goto Exit;

        hr = _pstmUpdate->SetSize( CULargeInteger(ulSize) );
        if( FAILED(hr) ) goto Exit;

    }


Exit:

    if( INVALID_HANDLE_VALUE != hStream )
        NtClose( hStream );

    if( FAILED(hr) )
    {
        // If we were attempting a create but failed, then ensure the
        // update stream is gone.

        if( NULL != _pstmUpdate && fCreate )
            _pstmUpdate->Delete();

        DfpVerify( 0 == RELEASE_INTERFACE(_pstmUpdate) );
    }

    return( hr );

}   // CNFFMappedStream::OpenUpdateStream()



//+----------------------------------------------------------------------------
//
//  Method: CNFFMappedStream::Init (called by from CNtfsStream::Init)
//
//  This method initializes the CNtfsStream, and checks the file system to
//  determine if we can support the update stream (for robustness).  The
//  necessary file system support is stream renaming, which we use to provide
//  a minimal level of transactioning.
//
//  See the CNtfsStreamForPropStg class declaration for a description of
//  this transactioning.
//
//+----------------------------------------------------------------------------

HRESULT
CNFFMappedStream::Init( HANDLE hFile )
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;

    FILE_FS_ATTRIBUTE_INFORMATION file_fs_attribute_information;
    IO_STATUS_BLOCK io_status_block;

    // Check to see if we'll be able to support stream renaming.

    if( NULL != _pnffstm->_pnffstg )
    {
        // We can at least see an IStorage for the file, so stream renaming
        // could potentially work, but we also need to query the file system
        // attributes to see if it actually supports it.

        status = NtQueryVolumeInformationFile( hFile, &io_status_block,
                                               &file_fs_attribute_information,
                                               sizeof(file_fs_attribute_information),
                                               FileFsAttributeInformation );

        // We should always get a buffer-overflow error here, because we don't
        // provide enough buffer for the file system name, but that's OK because
        // we don't need it (status_buffer_overflow is just a warning, so the rest
        // of the data is good).

        if( !NT_SUCCESS(status) && STATUS_BUFFER_OVERFLOW != status)
        {
            hr = NtStatusToScode(status);
            goto Exit;
        }

        // There's no attribute bit which says "supports stream rename".  The best
        // we can do is look for another NTFS5 feature and make an inferrence.

        if( FILE_SUPPORTS_OBJECT_IDS & file_fs_attribute_information.FileSystemAttributes )
            _fStreamRenameSupported = TRUE;
    }

Exit:

    return( hr );

}   // CNFFMappedStream::Init()




HRESULT
CNFFMappedStream::ShutDown()
{   // mikehill step
    HRESULT hr = S_OK;

    _pnffstm->Lock( INFINITE );

    // Close the mapped stream
    Close( &hr );
    if( FAILED(hr) && STG_E_REVERTED != hr )
        propDbg(( DEB_ERROR, "CNFFMappedStream(0x%x)::ShutDown failed call to CNtfsStream::Close (%08x)\n",
                             this, hr ));

    // Overwrite the original stream with the update (if necessary),
    // but don't bother to create a new update stream afterwards.

    if( NULL != _pstmUpdate )
    {
        hr = ReplaceOriginalWithUpdate( DONT_CREATE_NEW_UPDATE_STREAM );
        if( FAILED(hr) )
            propDbg(( DEB_ERROR, "CNFFMappedStream(0x%x)::ShutDown failed call to ReplaceOriginalWithUpdate (%08x)\n",
                             this, hr ));
    }

    // Release the update stream.
    if( NULL != _pstmUpdate )
        DfpVerify( 0 == RELEASE_INTERFACE(_pstmUpdate) );

    propDbg(( DbgFlag(hr,DEB_ITRACE), "CNFFMappedStream(0x%x)::ShutDown() returns %08x\n", this, hr ));

    _pnffstm->Unlock();
    return( hr );

}   // CNFFMappedStream::ShutDown


void
CNFFMappedStream::Read( void *pv, ULONG ulOffset, ULONG *pcbCopy )
{
    if( ulOffset > _cbMappedStream )
        *pcbCopy = 0;
    else if( *pcbCopy > _cbMappedStream - ulOffset )
        *pcbCopy = _cbMappedStream - ulOffset;

    memcpy( pv, &_pbMappedStream[ ulOffset ], *pcbCopy );

    *pcbCopy = 0;
    return;
}


void
CNFFMappedStream::Write( const void *pv, ULONG ulOffset, ULONG *pcbCopy )
{
    if( ulOffset > _cbMappedStream )
        *pcbCopy = 0;
    else if( *pcbCopy + ulOffset > _cbMappedStream )
        *pcbCopy = _cbMappedStream - ulOffset;

    memcpy( &_pbMappedStream[ulOffset], pv, *pcbCopy );

    *pcbCopy = 0;
    return;
}



//+----------------------------------------------------------------------------
//
//  Method:     IStorageTest::UseNTFS4Streams (DBG only)
//
//  This method can be used to disable the stream-renaming necessary for
//  robust property sets.  This emulates an NTFS4 volume.
//
//+----------------------------------------------------------------------------

#if DBG
HRESULT STDMETHODCALLTYPE
CNFFMappedStream::UseNTFS4Streams( BOOL fUseNTFS4Streams )
{
    HRESULT hr = S_OK;

    if( _fUpdateStreamHasLatest )
    {
        hr = STG_E_INVALIDPARAMETER;
        propDbg(( DEB_ERROR, "CNtfsStreamForPropStg(0x%x)::UseNTFS4Streams(%s)"
                             "was called while an update stream was already in use\n",
                             this, fUseNTFS4Streams ? "True" : "False" ));
    }
    else if( fUseNTFS4Streams )
    {
        DfpVerify( 0 == RELEASE_INTERFACE(_pstmUpdate) );
        _fStreamRenameSupported = FALSE;
    }
    else
    {
        // Shutting NTFS4streams off isn't implemented
        hr = E_NOTIMPL;
    }

    return( hr );

}   // CNFFMAppedStream::UseNTFS4Streams
#endif // #if DBG

#if DBG
HRESULT
CNFFMappedStream::GetFormatVersion( WORD *pw )
{
    return( E_NOTIMPL );
}
#endif // #if DBG

#if DBG
HRESULT
CNFFMappedStream::SimulateLowMemory( BOOL fSimulate )
{
    _fSimulateLowMem = fSimulate;
    return( S_OK );
}
#endif // #if DBG

#if DBG
LONG
CNFFMappedStream::GetLockCount()
{
    return( _pnffstm->GetLockCount() );
}
#endif // #if DBG

#if DBG
HRESULT
CNFFMappedStream::IsDirty()
{
    return( _fMappedStreamDirty ? S_OK : S_FALSE );
}
#endif // #if DBG



//+----------------------------------------------------------------------------
//
//  Method: CNtfsUpdateStreamForPropStg::ShutDown (overrides CNtfsStream)
//
//  Override so that we can remove this stream from the linked-list, but
//  not do a flush.  See the CNtfsStreamForPropStg class declaration for
//  more information on this class.
//
//+----------------------------------------------------------------------------

HRESULT
CNtfsUpdateStreamForPropStg::ShutDown()
{
    RemoveSelfFromList();
    return( S_OK );
}   // CNtfsUpdateStreamForPropStg::ShutDown
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pch.cxx
//
//  Contents:   Precompiled header includes.
//
//--------------------------------------------------------------------------

#include <new.h>

extern "C"
{
# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windef.h>
}

#include <ddeml.h>
#include <objbase.h>
#include <malloc.h>

#include <stgint.h>

#include <valid.h>

#include <debnot.h>

// Safe strings
#include <strsafe.h>

#ifdef IPROPERTY_DLL

    VOID PropAssertFailed(
        IN PVOID FailedAssertion,
        IN PVOID FileName,
        IN ULONG LineNumber,
        IN PCHAR Message OPTIONAL
        );

    #define Win4AssertEx( file, line, message ) PropAssertFailed( FALSE, __FILE__, __LINE__, message )

#endif // #ifdef IPROPERTY_DLL

#include <otrack.hxx>
#include <funcs.hxx>
#include <safedecl.hxx>


#include <propset.h>    // for PROPID_CODEPAGE

extern "C"
{
#include <propapi.h>
}

#include <propstm.hxx>  // Declaration for IMappedStream i/f that
                        // is used to let the ntdll implementation of
                        // OLE properties access the underlying stream data.

#include <olechar.h>    // Wrappers. E.g.: ocscpy, ocscat.

#include "prophdr.hxx"


#ifndef IPROPERTY_DLL
# include <msf.hxx>
# include <publicdf.hxx>
# include <pbstream.hxx>
# include <expdf.hxx>
# include <expst.hxx>
#endif

#include <privoa.h>     // Private OleAut32 wrappers
#include <psetstg.hxx>  // CPropertySetStorage which implements
                        // IPropertySetStorage for docfile and ofs

#include <utils.hxx>

#include <propstg.hxx>
#include <cli.hxx>
#include <SSMapStm.hxx>
#include <propdbg.hxx>

#include <propmac.hxx>

#include <reserved.hxx>
#include <objidl.h>
#include <stgprops.hxx>

#include <windows.h>
#include <dfmsp.hxx>    // LONGSIG,VDATEPTROUT


#include <error.hxx>
#include <names.hxx>
#include <hntfsstm.hxx>
#include <hntfsstg.hxx>
#include "bag.hxx"

#include <docfilep.hxx>

#ifndef STG_E_PROPSETMISMATCHED
#define STG_E_PROPSETMISMATCHED 0x800300F0
#endif

#include <cfiletim.hxx>
#include <ole.hxx>  // olAssert
#include <df32.hxx> // LAST_SCODE


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\names.cxx ===
#include <pch.cxx>

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:	names.cxx
//
//+---------------------------------------------------------------------------


///////////////////////// CONTENTS STREAM ////////////////////////////////////

const WCHAR g_wszContentsStreamName[]   = L"CONTENTS";

//+----------------------------------------------------------------------------
//
//  Routine    IsContentStream
//      Calls String Compare with "CONTENTS".
//
//+----------------------------------------------------------------------------

BOOL IsContentStream( const WCHAR* pwszName )
{
    return ( 0 == dfwcsnicmp( pwszName, g_wszContentsStreamName, -1 ) );
}

//+----------------------------------------------------------------------------
//
//  Routine    GetContentStreamName
//      returns the string "CONTENTS".
//
//+----------------------------------------------------------------------------

const WCHAR* GetContentStreamName()
{
    return g_wszContentsStreamName;
}

///////////////////////// NTFS $Data Name Mangling ///////////////////////////

//+----------------------------------------------------------------------------
//
//  CNtfsStreamName    "constructor"
//      converts "name" into ":name:$DATA"
//
//+----------------------------------------------------------------------------
const WCHAR g_wszNtfsDollarDataSuffix[] = L":$DATA";

CNtfsStreamName::CNtfsStreamName( const WCHAR *pwsz)
{
    nffAssert( NULL != pwsz);

    if( IsContentStream( pwsz ) )
        pwsz = L"";

    _count = wcslen( pwsz ) + CCH_NTFS_DOLLAR_DATA + 1;
    nffAssert( NTFS_MAX_ATTR_NAME_LEN >= _count );

    StringCbCopy( _wsz, sizeof(_wsz), L":" );
    StringCbCat( _wsz, sizeof(_wsz), pwsz );
    StringCbCat( _wsz, sizeof(_wsz), g_wszNtfsDollarDataSuffix );
    nffAssert( Count() == wcslen(_wsz) );
}

//+----------------------------------------------------------------------------
//
//  Routine     IsDataStream
//      Does the name have a ":$Data" On the end.
//
//+----------------------------------------------------------------------------

BOOL IsDataStream( const PFILE_STREAM_INFORMATION pFSInfo )
{
    BOOL ret;

    LONG ccnt = pFSInfo->StreamNameLength/sizeof(WCHAR) - CCH_NTFS_DOLLAR_DATA;

    ret = pFSInfo->StreamNameLength >= CCH_NTFS_DOLLAR_DATA*sizeof(WCHAR)
            &&  !dfwcsnicmp( &pFSInfo->StreamName[ ccnt ],
                            g_wszNtfsDollarDataSuffix,
                            CCH_NTFS_DOLLAR_DATA );
    return ret;        
}

//+----------------------------------------------------------------------------
//
//  Routine     GetNtfsUnmangledNameInfo
//      Take an FILE_STREAM_INFORMATION record and compute the unmangled name.
//      No memory allocation, just return pointers into the existing data.
//      The given FILE_STREAM_INFORMATION record must be a $DATA record.
//      Also invent "CONTENTS" if necessary.
//
//+----------------------------------------------------------------------------

void
GetNtfsUnmangledNameInfo(const PFILE_STREAM_INFORMATION pFSI,
                         const WCHAR** ppwcs,
                         ULONG* pcch)
{
    // The stream names in pFSI are "mangled"; they have the ":" prefix
    // and ":$DATA" suffix.  Get the size and address of the beginning of
    // the unmangled name, which is what we'll return to the caller.

    LONG cbName = pFSI->StreamNameLength
                  - sizeof(WCHAR)                       // leading colon
                  - sizeof(WCHAR)*CCH_NTFS_DOLLAR_DATA; // ":$DATA"

    nffAssert( IsDataStream(pFSI ) );
    nffAssert(cbName >=0 && cbName <= NTFS_MAX_ATTR_NAME_LEN);

    if(0 == cbName )
    {
        *ppwcs = GetContentStreamName();
        *pcch = (ULONG)wcslen(*ppwcs);     // *ppwcs is NULL terminated in this case
    }
    else
    {
        *ppwcs = &pFSI->StreamName[1];
        *pcch = cbName/sizeof(WCHAR);   // *ppwcs is not NULL terminated!
    }
}

///////////////////////// NFF CONTROL STREAM  ////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Routine    IsControlStream
//
//+----------------------------------------------------------------------------
const WCHAR g_wszNFFControlStreamName[] = L"{4c8cc155-6c1e-11d1-8e41-00c04fb9386d}";

BOOL IsControlStream( const WCHAR* pwszName )
{
    return ( 0 == dfwcsnicmp( pwszName, g_wszNFFControlStreamName, -1 ) );
}

//+----------------------------------------------------------------------------
//
//  Routine    GetControlStreamName
//
//+----------------------------------------------------------------------------

const WCHAR* GetControlStreamName()
{
    return g_wszNFFControlStreamName;
}



//+----------------------------------------------------------------------------
//
//  Routine    IsSpecifiedStream
//
//+----------------------------------------------------------------------------

BOOL IsSpecifiedStream(const FILE_STREAM_INFORMATION *pFSI,
                       const WCHAR *pwszStream  // Without the :*:$data adornments
                       )
{
    DWORD cch = (ULONG)wcslen(pwszStream);

    // The cch plus the ::$data decorations should match the stream length

    if( cch + CCH_NTFS_DOLLAR_DATA + 1 
        !=
        pFSI->StreamNameLength / sizeof(WCHAR) )
    {
        return FALSE;
    }

    return ( 0 == dfwcsnicmp( &( pFSI->StreamName[1] ),
                             pwszStream,
                             cch ) );
}


//+----------------------------------------------------------------------------
//
//  Routine    HasVisibleNamedStreams
//
//  Returns TRUE if there is a stream other than the contents
//  and control streams.
//
//+----------------------------------------------------------------------------

BOOL HasVisibleNamedStreams( const FILE_STREAM_INFORMATION *pfsi )
{
    for( ; NULL != pfsi; pfsi = NextFSI(pfsi) )
    {
        if( !IsHiddenStream(pfsi) && !IsContentsStream(pfsi) )
            return( TRUE );
    }

    return( FALSE );
}




///////////////////////// Docfile Stream Name Mangling ///////////////////////

//+----------------------------------------------------------------------------
//
//  CDocfileStreamName    "constructor"
//      converts "name" into "Docf_name"
//
//+----------------------------------------------------------------------------

const WCHAR g_wszDocfileStreamPrefix[] = L"Docf_";

CDocfileStreamName::CDocfileStreamName( const WCHAR *pwsz)
{
    StringCbCopy( _wszName, sizeof(_wszName), g_wszDocfileStreamPrefix );
    StringCbCat( _wszName, sizeof(_wszName), pwsz );
}


//+----------------------------------------------------------------------------
//
//  Routine     IsDocfileStream
//      Does the name have a "Docf_" On the front.
//
//+----------------------------------------------------------------------------

BOOL IsDocfileStream( const WCHAR *pwsz )
{
    return( 0 == wcsncmp( pwsz, g_wszDocfileStreamPrefix,
                                CCH_DOCFILESTREAMPREFIX ) );
}


const WCHAR *
UnmangleDocfileStreamName( const WCHAR *pwszName )
{
    nffAssert( IsDocfileStream( pwszName ));
    return( &pwszName[ CCH_DOCFILESTREAMPREFIX ] );
}


///////////////////////// Update Stream Name Mangling ///////////////////////

//+----------------------------------------------------------------------------
//
//  CDocfileStreamName    "constructor"
//      converts "name" into "Updt_name"
//
//+----------------------------------------------------------------------------
const WCHAR g_wszNtfsUpdateStreamPrefix[] = L"Updt_";

CNtfsUpdateStreamName::CNtfsUpdateStreamName( const WCHAR *pwsz)
{
    StringCbCopy( _wszName, sizeof(_wszName), g_wszNtfsUpdateStreamPrefix );
    StringCbCat( _wszName, sizeof(_wszName), pwsz );
}

//+----------------------------------------------------------------------------
//
//  CNtfsUpdateStreamName statics
//
//+----------------------------------------------------------------------------

BOOL
IsUpdateStream( const WCHAR *pwsz )
{
    return( 0 == wcsncmp( pwsz, g_wszNtfsUpdateStreamPrefix,
                          sizeof(g_wszNtfsUpdateStreamPrefix)/sizeof(WCHAR) ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\propapi.cxx ===
//+==================================================================
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:   PropAPI.cxx
//
//          This file provides the Property Set API routines.
//
//  APIs:   StgCreatePropSetStg (creates an IPropertySetStorage)
//          StgCreatePropStg (creates an IPropertyStorage)
//          StgOpenPropStg (opens an IPropertyStorage)
//          StgCreateStorageOnHandle (private, not a public API)
//          StgOpenStorageOnHandle (private, not a public API)
//
//  History:
//
//      3/10/98  MikeHill   - Added StgCreate/OpenStorageOnHandle
//      5/6/98   MikeHill   - Rewrite StgCreate/OpenStorageOnHandle.
//      5/18/98     MikeHill
//                  -   Use new CPropertySetStorage constructor.
//
//+==================================================================

#include <pch.cxx>

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

//+------------------------------------------------------------------
//
//  Function:   QueryForIStream
//
//  Synopsis:   This routine queries an IUnknown for
//              an IStream interface.  This is isolated into
//              a separate routine because some workaround code
//              is required on the Mac.
//
//  Inputs:     [IUnknown*] pUnk
//                  The interface to be queried.
//              [IStream**] ppStm
//                  Location to return the result.
//
//  Returns:    [HRESULT]
//
//  Notes:      On older Mac implementations (<=2.08, <=~1996)
//              the memory-based IStream implementation
//              (created by CreateStreamOnHGlobal) had a bug
//              in QueryInterface:  when you QI for an
//              IStream or IUnknown, an addref is done, but an
//              HR of E_NOINTERFACE is returned.
//
//              Below, we look for this condition:  if we get an
//              E_NOINTERFACE on the Mac, we check to see if it's
//              an OLE mem-based IStream.  If it is, we simply cast
//              IUnknown as an IStream.  We validate it as an OLE
//              the mem-based IStream by creating one of our own, and
//              comparing the QueryInterface addresses.
//
//              This is some ugly code, but at least it is isolated,
//              only runs on the older Macs, and ensures that we
//              work on all platforms.
//
//+------------------------------------------------------------------


inline HRESULT QueryForIStream( IUnknown * pUnk, IStream** ppStm )
{
    HRESULT hr;

    // Attempt to get the interface
    hr = pUnk->QueryInterface( IID_IStream, (void**) ppStm );

#ifdef _MAC

    // On the Mac, if we get a no-interface error, see if it is really
    // a buggy mem-based IStream implementation.

    if( E_NOINTERFACE == hr )
    {
        IStream *pstmMem = NULL;

        // Create our own mem-based IStream.

        hr = CreateStreamOnHGlobal( NULL, TRUE, &pstmMem );
        if( FAILED(hr) ) goto Exit;

        // If the mem-based Stream's QI implementation has the same
        // address as the Unknown's QI implementation, then the Unknown
        // must be an OLE mem-based stream.

        if( pUnk->QueryInterface == pstmMem->QueryInterface )
        {
            // We can just cast the IUnknown* as an IStream* and
            // we're done (the original QI, despite returning an
            // error, has already done an AddRef).

            hr = S_OK;
            *ppStm = (IStream*) pUnk;
        }
        else
        {
            // This is a real no-interface error, so let's return it.
            hr = E_NOINTERFACE;
        }

        pstmMem->Release();
    }

    //  ----
    //  Exit
    //  ----

Exit:

#endif  // #ifdef _MAC

    return( hr );

}   // QueryForIStream()



//+------------------------------------------------------------------
//
//  Function:   StgCreatePropStg
//
//  Synopsis:   Given an IStorage or IStream, create an
//              IPropertyStorage.  This is similar to the
//              IPropertySetStorage::Create method.  Existing
//              contents of the Storage/Stream are removed.
//
//  Inputs:     [IUnknown*] pUnk
//                  An IStorage* for non-simple propsets,
//                  an IStream* for simple.  grfFlags is
//                  used to disambiguate.
//              [REFFMTID] fmtid
//                  The ID of the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_* enumeration.
//              [IPropertySetStorage**] ppPropStg
//                  The result.
//
//  Returns:    [HRESULT]
//
//  Notes:      The caller is responsible for maintaining
//              thread-safety between the original
//              IStorage/IStream and this IPropertyStorage.
//
//+------------------------------------------------------------------

STDAPI StgCreatePropStg( IUnknown *pUnk,
                         REFFMTID fmtid,
                         const CLSID *pclsid,
                         DWORD grfFlags,
                         DWORD dwReserved,
                         IPropertyStorage **ppPropStg)
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    IStream *pstm = NULL;
    IStorage *pstg = NULL;
    CPropertyStorage *pPropStg = NULL;

    //  ----------
    //  Validation
    //  ----------

    propXTraceStatic( "StgCreatePropStg" );

    GEN_VDATEIFACE_LABEL( pUnk, E_INVALIDARG, Exit, hr );
    GEN_VDATEREADPTRIN_LABEL(&fmtid, FMTID, E_INVALIDARG, Exit, hr );
    GEN_VDATEPTRIN_LABEL(pclsid, CLSID, E_INVALIDARG, Exit, hr );
    // grfFlags is validated by CPropertyStorage
    GEN_VDATEPTROUT_LABEL( ppPropStg, IPropertyStorage*, E_INVALIDARG, Exit, hr );

    *ppPropStg = NULL;

    propTraceParameters(( "pUnk=%p, fmtid=%s, clsid=%s, grfFlags=%s, dwReserved=0x%x, ppPropStg=%p",
                           pUnk, static_cast<const char*>(CStringize(fmtid)),
                           static_cast<const char*>(CStringize(*pclsid)),
                           static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                           dwReserved, ppPropStg ));

    //  -----------------------
    //  Non-Simple Property Set
    //  -----------------------

    if( grfFlags & PROPSETFLAG_NONSIMPLE )
    {
        // Get the IStorage*
        hr = pUnk->QueryInterface( IID_IStorage, (void**) &pstg );
        if( FAILED(hr) ) goto Exit;

        // Create the IPropertyStorage implementation
        pPropStg = new CPropertyStorage( MAPPED_STREAM_CREATE );
        if( NULL== pPropStg )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Initialize the IPropertyStorage
        hr = pPropStg->Create( pstg, fmtid, pclsid, grfFlags,
                               0 ); // We don't know the grfMode
        if( FAILED(hr) ) goto Exit;

    }   // if( grfFlags & PROPSETFLAG_NONSIMPLE )

    //  -------------------
    //  Simple Property Set
    //  -------------------

    else
    {
        // Get the IStream*
        hr = QueryForIStream( pUnk, &pstm );
        if( FAILED(hr) ) goto Exit;

        // Create an IPropertyStorage implementation.
        pPropStg = new CPropertyStorage( MAPPED_STREAM_CREATE );
        if( NULL == pPropStg )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Initialize the IPropertyStorage (which
        // is responsible for sizing and seeking the
        // stream).

        hr = pPropStg->Create( pstm, fmtid, pclsid, grfFlags,
                               0 ); // We don't know the grfMode
        if( FAILED(hr) ) goto Exit;

    }   // if( grfFlags & PROPSETFLAG_NONSIMPLE ) ... else

    //  ----
    //  Exit
    //  ----

    *ppPropStg = static_cast<IPropertyStorage*>(pPropStg);
    pPropStg = NULL;

Exit:

    // If we created pPropStg, and there was an error, delete it.

    #if DBG
    if( FAILED(hr) )
    {
        propDbg((DEB_ERROR, "StgCreatePropStg returns %08X\n", hr ));
    }
    #endif

    if( NULL != pPropStg )
        delete pPropStg;

    if( NULL != pstm )
        pstm->Release();
    if( NULL != pstg )
        pstg->Release();

    return( hr );

}   // StgCreatePropStg()



//+------------------------------------------------------------------
//
//  Function:   StgOpenPropStg
//
//  Synopsis:   Given an IStorage or IStream which hold a
//              serialized property set, create an
//              IPropertyStorage.  This is similar to the
//              IPropertySetStorage::Open method.
//
//  Inputs:     [IUnknown*] pUnk
//                  An IStorage* for non-simple propsets,
//                  an IStream* for simple.  grfFlags is
//                  used to disambiguate.
//              [REFFMTID] fmtid
//                  The ID of the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_* enumeration.
//              [IPropertySetStorage**] ppPropStg
//                  The result.
//
//  Returns:    [HRESULT]
//
//  Notes:      The caller is responsible for maintaining
//              thread-safety between the original
//              IStorage/IStream and this IPropertyStorage.
//
//+------------------------------------------------------------------

STDAPI StgOpenPropStg( IUnknown* pUnk,
                       REFFMTID fmtid,
                       DWORD grfFlags,
                       DWORD dwReserved,
                       IPropertyStorage **ppPropStg)
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    IStream *pstm = NULL;
    IStorage *pstg = NULL;
    CPropertyStorage *pPropStg = NULL;

    //  ----------
    //  Validation
    //  ----------

    propXTraceStatic( "StgOpenPropStg" );

    GEN_VDATEIFACE_LABEL( pUnk, E_INVALIDARG, Exit, hr );
    GEN_VDATEREADPTRIN_LABEL(&fmtid, FMTID, E_INVALIDARG, Exit, hr);
    // grfFlags is validated by CPropertyStorage
    GEN_VDATEPTROUT_LABEL( ppPropStg, IPropertyStorage*, E_INVALIDARG, Exit, hr );

    propTraceParameters(( "pUnk=%p, fmtid=%s, grfFlags=%s, dwReserved=0x%x, ppPropStg=%p",
                           pUnk, static_cast<const char*>(CStringize(fmtid)),
                           static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                           dwReserved, ppPropStg ));


    //  -----------------------
    //  Non-Simple Property Set
    //  -----------------------

    *ppPropStg = NULL;

    if( grfFlags & PROPSETFLAG_NONSIMPLE )
    {
        // Get the IStorage*
        hr = pUnk->QueryInterface( IID_IStorage, (void**) &pstg );
        if( FAILED(hr) ) goto Exit;

        // Create an IPropertyStorage* implementation.
        pPropStg = new CPropertyStorage( MAPPED_STREAM_CREATE );
        if( NULL == pPropStg )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Initialize the IPropertyStorage by reading
        // the serialized property set.

        hr = pPropStg->Open( pstg, fmtid, grfFlags,
                             0 ); // We don't know the grfMode
        if( FAILED(hr) ) goto Exit;

    }   // if( grfFlags & PROPSETFLAG_NONSIMPLE )

    //  -------------------
    //  Simple Property Set
    //  -------------------

    else
    {
        // Get the IStream*
        hr = QueryForIStream( pUnk, &pstm );
        if( FAILED(hr) ) goto Exit;

        // Create an IPropertyStorage* implementation.
        pPropStg = new CPropertyStorage(MAPPED_STREAM_CREATE );
        if( NULL == pPropStg )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    
        // Initialize the IPropertyStorage by reading
        // the serialized property set (the CPropertyStorage
        // is responsible for seeking to the stream start).

        hr = pPropStg->Open( pstm, fmtid, grfFlags,
                             0,          // We don't know the grfMode
                             FALSE );    // Not deleting
        if( FAILED(hr) ) goto Exit;

    }   // if( grfFlags & PROPSETFLAG_NONSIMPLE ) ... else

    //  ----
    //  Exit
    //  ----

    *ppPropStg = static_cast<IPropertyStorage*>(pPropStg);
    pPropStg = NULL;

Exit:

    #if DBG
    if( FAILED(hr) )
    {
        propDbg((DEB_ERROR, "StgOpenPropStg returns %08X\n", hr ));
    }
    #endif

    if( NULL != pPropStg )
        delete pPropStg;

    if( NULL != pstm )
        pstm->Release();
    if( NULL != pstg )
        pstg->Release();

    return( hr );

}   // StgOpenPropStg()



//+------------------------------------------------------------------
//
//  Function:   StgCreatePropSetStg
//
//  Synopsis:   Given an IStorage, create an IPropertySetStorage.
//              This is similar to QI-ing a DocFile IStorage for
//              the IPropertySetStorage interface.
//
//  Inputs:     [IStorage*] pStorage
//                  Will be held by the propsetstg and used
//                  for create/open.
//              [IPropertySetStorage**] ppPropSetStg
//                  Receives the result.
//
//  Returns:    [HRESULT]
//
//  Notes:      The caller is responsible for maintaining
//              thread-safety between the original
//              IStorage and this IPropertySetStorage.
//
//+------------------------------------------------------------------

STDAPI
StgCreatePropSetStg( IStorage *pStorage,
                     DWORD dwReserved,
                     IPropertySetStorage **ppPropSetStg)
{
    HRESULT hr = S_OK;
    CPropertySetStorage *pPropSetStg = NULL;

    // Validation

    propXTraceStatic( "StgCreatePropSetStg" );

    GEN_VDATEIFACE_LABEL( pStorage, E_INVALIDARG, Exit, hr );
    GEN_VDATEPTROUT_LABEL( ppPropSetStg, IPropertySetStorage*, E_INVALIDARG, Exit, hr );

    propTraceParameters(( "pStorage=%p, dwReserved=0x%x, ppPropSetStg=%p",
                           pStorage,    dwReserved,      ppPropSetStg ));

    // Create the IPropertySetStorage implementation.

    pPropSetStg = new CPropertySetStorage( MAPPED_STREAM_CREATE );
    if( NULL == pPropSetStg )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Pass the caller-provided storage into the CPropertySetStorage
    pPropSetStg->Init( pStorage, /*IBlockingLock*/ NULL,
                       TRUE ); // fControlLifetime (=> addref)

    //  ----
    //  Exit
    //  ----

    hr = S_OK;
    *ppPropSetStg = static_cast<IPropertySetStorage*>(pPropSetStg);
    pPropSetStg = NULL;

Exit:

    RELEASE_INTERFACE(pPropSetStg);

    if( FAILED(hr) )
        propDbg((DEB_ERROR, "StgCreatePropSetStg() returns %08X\n", hr ));

    return( hr );

}   // StgCreatePropSetStg()


//+----------------------------------------------------------------------------
//
//  Function:   FmtIdToPropStgName
//
//  Synopsis:   This function maps a property set's FMTID to the name of
//              the Stream or Storage which contains it.  This name
//              is 27 characters (including the terminator).
//
//  Inputs:     [const FMTID*] pfmtid (in)
//                  The FMTID of the property set.
//              [LPOLESTR] oszName (out)
//                  The name of the Property Set's Stream/Storage
//
//  Returns:    [HRESULT] S_OK or E_INVALIDARG
//
//+----------------------------------------------------------------------------

STDAPI
FmtIdToPropStgName( const FMTID *pfmtid, LPOLESTR oszName )
{

    HRESULT hr = S_OK;

    // Validate Inputs

    propXTraceStatic( "FmtIdToPropStgName" );

    GEN_VDATEREADPTRIN_LABEL(pfmtid, FMTID, E_INVALIDARG, Exit, hr);
    VDATESIZEPTROUT_LABEL(oszName,
                          sizeof(OLECHAR) * (CCH_MAX_PROPSTG_NAME+1),
                          Exit, hr);

    propTraceParameters(( "fmtid=%s, oszName=%p",
                           static_cast<const char*>(CStringize(*pfmtid)), oszName ));

    // Make the Conversion

    PrGuidToPropertySetName( pfmtid, oszName );

    // Exit

Exit:

    if( FAILED(hr) )
    {
        propDbg((DEB_ERROR, "FmtIdToPropStgName returns %08X\n", hr ));
    }

    return( hr );

}   // FmtIdToPropStgName()



//+----------------------------------------------------------------------------
//
//  Function:   PropStgNameToFmtId
//
//  Synopsis:   This function maps a property set's Stream/Storage name
//              to its FMTID.
//
//  Inputs:     [const LPOLESTR] oszName (in)
//                  The name of the Property Set's Stream/Storage
//              [FMTID*] pfmtid (out)
//                  The FMTID of the property set.
//
//
//  Returns:    [HRESULT] S_OK or E_INVALIDARG
//
//+----------------------------------------------------------------------------

STDAPI
PropStgNameToFmtId( const LPOLESTR oszName, FMTID *pfmtid )
{

    HRESULT hr = S_OK;

    // Validate Inputs

    propXTraceStatic( "PropStgNameToFmtId" );

    GEN_VDATEPTROUT_LABEL(pfmtid, FMTID, E_INVALIDARG, Exit, hr);

    propTraceParameters(( "oszName=%p, *pfmtid=%s", oszName,
                           static_cast<const char*>(CStringize(*pfmtid)) ));

#ifdef OLE2ANSI
    if( FAILED(hr = ValidateNameA(oszName, CCH_MAX_PROPSTG_NAME )))
        goto Exit;
#else
    if( FAILED(hr = ValidateNameW(oszName, CCH_MAX_PROPSTG_NAME )))
        goto Exit;
#endif


    // Make the Conversion, passing in the name and its character-length
    // (not including the null-terminator).

    PrPropertySetNameToGuid( ocslen(oszName), oszName, pfmtid );

    // Exit

Exit:

    propDbg(( DbgFlag(hr,DEB_TRACE), "PropStgNameToFmtId returns %08x", hr ));

    return( hr );

}   // PropStgNameToFmtId()



//+----------------------------------------------------------------------------
//
//  Function:   CreateOrOpenDocfileOnHandle
//
//  Create or open a Docfile IStorage (or QI-able interface) on a given
//  handle.
//
//+----------------------------------------------------------------------------

CreateOrOpenDocfileOnHandle( IN BOOL fCreate,
                             IN DWORD grfMode,
                             IN HANDLE *phStream,
                             IN  REFIID riid,
                             OUT void ** ppObjectOpen)
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    CNtfsStream *pnffstm = NULL;
    CNFFTreeMutex *pmutex = NULL;
    IStorage *pstg = NULL;

    propITraceStatic( "CreateOrOpenDocfileOnHandle" );

    //  --------------------
    //  Create an ILockBytes
    //  --------------------

    // Instantiate a mutex

    pmutex = new CNFFTreeMutex();
    if( NULL == pmutex )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pmutex->Init();
    if ( FAILED(hr) ) goto Exit;

    // Use the mutex to instantiate an NFF stream object

    pnffstm = new CNtfsStream( NULL, pmutex );
    if( NULL == pnffstm )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Put the stream handle and grfMode into the NFF stream object.
    // We now have our ILockBytes implementation for the given handle.

    hr = pnffstm->Init( *phStream, grfMode, NULL, NULL );
    if( FAILED(hr) ) goto Exit;
    *phStream = INVALID_HANDLE_VALUE;

    //  ----------------
    //  Open the Storage
    //  ----------------

    if( fCreate )
    {
        hr = StgCreateDocfileOnILockBytes( pnffstm, grfMode, 0, &pstg );
    }
    else
    {
        hr = StgOpenStorageOnILockBytes( pnffstm, NULL, grfMode, NULL, 0, &pstg );

        // STG_E_INVALIDHEADER in some paths of the above call gets converted into
        // STG_E_FILEALREADYEXISTS, which doesn't make a whole lot of sense from
        // from our point of view (we already knew it existed, we wanted to open it).  So,
        // translate it back.
        if( STG_E_FILEALREADYEXISTS == hr )
            hr = STG_E_INVALIDHEADER;
    }
    if( FAILED(hr) ) goto Exit;

    // QI for the caller-requested IID

    hr = pstg->QueryInterface( riid, ppObjectOpen );
    if( FAILED(hr) ) goto Exit;


    hr = S_OK;

Exit:

    RELEASE_INTERFACE(pnffstm);
    RELEASE_INTERFACE(pstg);
    RELEASE_INTERFACE(pmutex);

    return( hr );

}


//+----------------------------------------------------------------------------
//
//  CreateOrOpenStorageOnHandle
//  StgCreateStorageOnHandle
//  StgOpenStorageOnHandle
//
//  Given a handle, create or open a storage.
//  The caller-provided handle is duplicated.
//  
//+----------------------------------------------------------------------------

CreateOrOpenStorageOnHandle( IN BOOL fCreate,
                             IN DWORD grfMode,
                             IN DWORD stgfmt,
                             IN HANDLE hStream,
                             IN  REFIID riid,
                             OUT void ** ppObjectOpen)
{
    HRESULT hr = S_OK;
    HANDLE hStreamInternal = INVALID_HANDLE_VALUE;
    NTSTATUS status = STATUS_SUCCESS;
    BOOL fIsStorageFile = FALSE;
    OVERLAPPED olpTemp;


    propXTraceStatic( "CreateOrOpenStorageOnHandle" );

    ZeroMemory( &olpTemp, sizeof(OVERLAPPED) );

    propTraceParameters(( "fCreate=%s, grfMode=%s, stgfmt=0x%x, hStream=%p, riid=%s, ppObjectOpen=%p",
                          fCreate?"TRUE":"FALSE",
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))),
                          stgfmt, hStream,
                          static_cast<const char*>(CStringize(riid)), ppObjectOpen ));

    hr = VerifyPerms (grfMode, TRUE);
    if (FAILED(hr))
        return hr;

    // Make a copy of the handle so that the caller can still call
    // CloseHandle.

    if( !DuplicateHandle( GetCurrentProcess(), hStream,
                          GetCurrentProcess(), &hStreamInternal,
                          0,  // dwDesiredAccess, ignored because of DUPLICATE_SAME_ACCESS below
                          FALSE, // bInheritHandle
                          DUPLICATE_SAME_ACCESS ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hStreamInternal = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    // Set up an overlapped structure in preparation to call
    // StgIsStorageFileHandle

    olpTemp.hEvent = CreateEvent( NULL,     // Security Attributes.
                                  TRUE,     // Manual Reset Flag.
                                  FALSE,    // Inital State = Signaled, Flag.
                                  NULL );   // Name

    if( NULL == olpTemp.hEvent )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Does this handle represent a docfile?

    hr = StgIsStorageFileHandle( hStreamInternal, &olpTemp );
    if( HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION) == hr )
    {
        // This is the error we get when the handle is to a directory.
        // See if that's really the case, and if so assume that this isn't
        // a docfile.

        // Do not move this in StgIsStorageFileHandle for compatibility

        BY_HANDLE_FILE_INFORMATION ByHandleFileInformation;

        if( GetFileInformationByHandle( hStreamInternal, &ByHandleFileInformation ))
        {
            if( FILE_ATTRIBUTE_DIRECTORY & ByHandleFileInformation.dwFileAttributes )
                hr = S_FALSE;
        }
    }
    if( FAILED(hr) ) goto Exit;

    if( S_OK == hr )
        fIsStorageFile = TRUE;
    else
        DfpAssert( S_FALSE == hr );

    // Is this the create of a docfile/storage, or the open of an
    // existing docfile?

    if( fCreate && ( STGFMT_DOCFILE == stgfmt || STGFMT_STORAGE == stgfmt )
        ||
        !fCreate && fIsStorageFile )
    {
        // In the open path, the caller must request
        // either any, docfile, or storage.

        if( !fCreate
            &&
            STGFMT_ANY != stgfmt
            &&
            STGFMT_DOCFILE != stgfmt
            &&
            STGFMT_STORAGE != stgfmt )
        {
            hr = STG_E_INVALIDPARAMETER;
            goto Exit;
        }

        // Create/Open the docfile.  hStreamInternal may be changed
        // to INVALID_HANDLE_VALUE.

        hr = CreateOrOpenDocfileOnHandle( fCreate, grfMode, &hStreamInternal,
                                          riid, ppObjectOpen );
        if( FAILED(hr) ) goto Exit;
    }

    // Otherwise, this should be the create/open of an NFF

    else if( fCreate && STGFMT_FILE == stgfmt
             ||
             !fCreate && !fIsStorageFile )
    {
        // In the open path, the caller must request either any or file.

        if( !fCreate && STGFMT_ANY != stgfmt && STGFMT_FILE != stgfmt )
        {
            hr = STG_E_INVALIDPARAMETER;
            goto Exit;
        }

        // Instantiate the NFF IStorage.

        hr = NFFOpenOnHandle( fCreate, grfMode, STGFMT_FILE,
                              &hStreamInternal, riid, ppObjectOpen );

        if( FAILED(hr) ) goto Exit;
    }
    else
    {
        hr = STG_E_INVALIDPARAMETER;
        goto Exit;
    }

    hr = S_OK;

Exit:

    if( INVALID_HANDLE_VALUE != hStreamInternal )
        CloseHandle( hStreamInternal );

    if( NULL != olpTemp.hEvent )
        CloseHandle( olpTemp.hEvent );

    if( STG_E_INVALIDFUNCTION == hr // This happens e.g. when we try to get NFF propsets on FAT
        ||                          // This happens when we try to read a FAT directory file
        HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == hr )
    {
        propSuppressExitErrors();
    }

    return( hr );

}   // CreateOrOpenStorageOnHandle


STDAPI
StgCreateStorageOnHandle( IN HANDLE hStream,
                          IN DWORD grfMode,
                          IN DWORD stgfmt,
                          IN void *reserved1,
                          IN void *reserved2,
                          IN REFIID riid,
                          OUT void **ppObjectOpen )
{
    return( CreateOrOpenStorageOnHandle( TRUE, grfMode, stgfmt, hStream, riid, ppObjectOpen ));
}

STDAPI
StgOpenStorageOnHandle( IN HANDLE hStream,
                        IN DWORD grfMode,
                        IN void *reserved1,
                        IN void *reserved2,
                        IN REFIID riid,
                        OUT void **ppObjectOpen )
{
    return( CreateOrOpenStorageOnHandle( FALSE, grfMode, STGFMT_ANY, hStream, riid, ppObjectOpen ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\propvar.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993
//
// File:        propvar.cxx
//
// Contents:    PROPVARIANT manipulation code
//
// History:     15-Aug-95       vich  created
//              22-Feb-96   MikeHill  Moved DwordRemain to "propmac.hxx".
//              09-May-96   MikeHill  Use the 'boolVal' member of PropVariant
//                                    rather than the member named 'bool'.
//              22-May-96   MikeHill  Use the caller-provided codepage for
//                                    string conversions, not the system default.
//              06-Jun-96   MikeHill  Modify CLIPDATA.cbData to include sizeof
//                                    ulClipFmt.
//              12-Jun-96   MikeHill  - Use new BSTR alloc/free routines.
//                                    - Added VT_I1 support (under ifdefs)
//                                    - Bug for VT_CF|VT_VECTOR in RtlConvPropToVar
//              25-Jul-96   MikeHill  - Removed Win32 SEH.
//                                    - BSTRs:  WCHAR=>OLECHAR
//                                    - Added big-endian support.
//              10-Mar-98   MikeHill  - Added support for Variant types except
//                                      for VT_RECORD.
//              06-May-98   MikeHill  - Removed usage of UnicodeCallouts.
//                                    - Wrap SafeArray/BSTR calls for delayed-linking.
//                                    - Enforce VT in VT_ARRAYs.
//                                    - Added support for VT_VARIANT|VT_BYREF.
//                                    - Added support for VT_ARRAY|VT_BYREF.
//                                    - Added support for VT_VECTOR|VT_I1.
//                                    - Use CoTaskMem rather than new/delete.
//              11-June-98  MikeHill  - Validate elements of arrays & vectors.
//
//---------------------------------------------------------------------------

#include <pch.cxx>

#include <stdio.h>

#ifndef _MAC
#include <ddeml.h>      // for CP_WINUNICODE
#endif

#include "propvar.h"

#ifndef newk
#define newk(Tag, pCounter)     new
#endif

#if DBGPROP

BOOLEAN
IsUnicodeString(WCHAR const *pwszname, ULONG cb)
{
    return( TRUE );
}


BOOLEAN
IsAnsiString(CHAR const *pszname, ULONG cb)
{
    return( TRUE );
}
#endif




//+---------------------------------------------------------------------------
// Function:    PrpConvertToUnicode, private
//
// Synopsis:    Convert a MultiByte string to a Unicode string
//
// Arguments:   [pch]        -- pointer to MultiByte string
//              [cb]         -- byte length of MultiByte string
//              [CodePage]   -- property set codepage
//              [ppwc]       -- pointer to returned pointer to Unicode string
//              [pcb]        -- returned byte length of Unicode string
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
PrpConvertToUnicode(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    WCHAR *pwszName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pch != NULL);
    PROPASSERT(ppwc != NULL);
    PROPASSERT(pcb != NULL);

    *ppwc = NULL;
    *pcb = 0;

    ULONG cwcName;

    pwszName = NULL;
    cwcName = 0;
    while (TRUE)
    {
        cwcName = MultiByteToWideChar(
                                    CodePage,
                                    0,                  // dwFlags
                                    pch,
                                    cb,
                                    pwszName,
                                    cwcName);
        if (cwcName == 0)
        {
            CoTaskMemFree( pwszName );
            *ppwc = NULL;

            // If there was an error, assume that it was a code-page
            // incompatibility problem.
            StatusError(pstatus, "PrpConvertToUnicode: MultiByteToWideChar error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
        }
        if (pwszName != NULL)
        {
            DebugTrace(0, DEBTRACE_PROPERTY, (
                "PrpConvertToUnicode: pch='%s'[%x] pwc='%ws'[%x->%x]\n",
                pch,
                cb,
                pwszName,
                *pcb,
                cwcName * sizeof(WCHAR)));
            break;
        }
        *pcb = cwcName * sizeof(WCHAR);
        *ppwc = pwszName = (WCHAR *) CoTaskMemAlloc( *pcb );
        if (pwszName == NULL)
        {
            StatusNoMemory(pstatus, "PrpConvertToUnicode: no memory");
            goto Exit;
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+---------------------------------------------------------------------------
// Function:    PrpConvertToMultiByte, private
//
// Synopsis:    Convert a Unicode string to a MultiByte string
//
// Arguments:   [pwc]        -- pointer to Unicode string
//              [cb]         -- byte length of Unicode string
//              [CodePage]   -- property set codepage
//              [ppch]       -- pointer to returned pointer to MultiByte string
//              [pcb]        -- returned byte length of MultiByte string
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
PrpConvertToMultiByte(
    IN WCHAR const *pwc,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT CHAR **ppch,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    ULONG cbName;
    CHAR *pszName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pwc != NULL);
    PROPASSERT(ppch != NULL);
    PROPASSERT(pcb != NULL);

    *ppch = NULL;
    *pcb = 0;

    // Ensure that cb is valid

    if( 0 != (cb % 2) )
    {
        StatusError(pstatus, "PrpConvertToMultiByte:  Odd Unicode string cb",
                    STATUS_INTERNAL_DB_CORRUPTION);
        goto Exit;
    }

    pszName = NULL;
    cbName = 0;
    while (TRUE)
    {
        cbName = WideCharToMultiByte(
                                    CodePage,
                                    0,                  // dwFlags
                                    pwc,
                                    cb/sizeof(WCHAR),
                                    pszName,
                                    cbName,
                                    NULL,               // lpDefaultChar
                                    NULL);              // lpUsedDefaultChar
        if (cbName == 0)
        {
            CoTaskMemFree( pszName );
            *ppch = NULL;

            // If there was an error, assume that it was a code-page
            // incompatibility problem.
            StatusError(pstatus, "PrpConvertToMultiByte: WideCharToMultiByte error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
        }
        if (pszName != NULL)
        {
            DebugTrace(0, DEBTRACE_PROPERTY, (
                "PrpConvertToMultiByte: pwc='%ws'[%x] pch='%s'[%x->%x]\n",
                pwc,
                cb,
                pszName,
                *pcb,
                cbName));
            break;
        }
        *pcb = cbName;
        *ppch = pszName = reinterpret_cast<CHAR*>( CoTaskMemAlloc( cbName ));
        if (pszName == NULL)
        {
            StatusNoMemory(pstatus, "PrpConvertToMultiByte: no memory");
            goto Exit;
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+---------------------------------------------------------------------------
//
// Function:    SerializeSafeArrayBounds, private
//
// Synopsis:    Write the rgsabounds field of a SAFEARRAY to pbdst (if non-NULL).
//              Calculate and return the size of the serialized bounds,
//              and the total number of elements in the array.
//
//---------------------------------------------------------------------------

NTSTATUS
SerializeSafeArrayBounds( const SAFEARRAY *psa, BYTE *pbdst, ULONG *pcbBounds, ULONG *pcElems )
{
    NTSTATUS status = STATUS_SUCCESS;

    ULONG ulIndex = 0;
    ULONG cDims = PrivSafeArrayGetDim( const_cast<SAFEARRAY*>(psa) );
    PROPASSERT( 0 < cDims );

    *pcbBounds = 0;
    *pcElems = 1;

    // Loop through each dimension and get its range

    for( ulIndex = 1; ulIndex <= cDims; ulIndex++ )
    {
        LONG lLowerBound = 0, lUpperBound = 0;

        // Get the lower & upper bounds

        if( SUCCEEDED( status = PrivSafeArrayGetLBound( const_cast<SAFEARRAY*>(psa), ulIndex, &lLowerBound )))
        {
            status = PrivSafeArrayGetUBound( const_cast<SAFEARRAY*>(psa), ulIndex, &lUpperBound );
        }
        if( FAILED(status) )
        {
            goto Exit;
        }
        else if( lUpperBound < lLowerBound )
        {
            status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        // Update the total element count
        *pcElems *= (lUpperBound - lLowerBound + 1 );

        // If we're really serializing, write the current set of bounds
        if( NULL != pbdst )
        {
            // Write the length of this dimension
            *(ULONG *) pbdst = (lUpperBound - lLowerBound + 1);
            pbdst += sizeof(ULONG);

            // Then the lower bound
            *(LONG *) pbdst = lLowerBound;
            pbdst += sizeof(LONG);
        }
    }

    // Calculate the size of the rgsabound array.
    *pcbBounds = sizeof(SAFEARRAYBOUND) * cDims;

Exit:

    return( status );
}


ULONG
CalcSafeArrayElements( ULONG cDims, const SAFEARRAYBOUND *rgsaBounds )
{
    ULONG cElems = 1; // Multiplicitive identity

    for( ULONG i = 0; i < cDims; i++ )
        cElems *= rgsaBounds[ i ].cElements;

    return( cElems );
}



//+---------------------------------------------------------------------------
// Function:    StgConvertVariantToProperty, private
//
// Synopsis:    Convert a PROPVARIANT to a SERIALIZEDPROPERTYVALUE
//
// Arguments:   [pvar]       -- pointer to PROPVARIANT
//              [CodePage]   -- property set codepage
//              [pprop]      -- pointer to SERIALIZEDPROPERTYVALUE
//              [pcb]        -- pointer to remaining stream length,
//                              updated to actual property size on return
//              [pid]        -- propid (used if indirect)
//              [fVariantVectorOrArray] -- TRUE if recursing on VT_VECTOR | VT_VARIANT
//              [pcIndirect] -- pointer to indirect property count
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     NULL if buffer too small, else input [pprop] argument
//---------------------------------------------------------------------------


// Define a macro which sets a variable named 'cbByteSwap', but
// only on big-endian builds.  This value is not needed on little-
// endian builds (because byte-swapping is not necessary).

#ifdef BIGENDIAN
#define CBBYTESWAP(cb) cbByteSwap = cb
#elif LITTLEENDIAN
#define CBBYTESWAP(cb)
#else
#error Either BIGENDIAN or LITTLEENDIAN must be set.
#endif


// First, define a wrapper for this function which returns errors
// using NT Exception Handling, rather than returning an NTSTATUS.

#if defined(WINNT)

EXTERN_C SERIALIZEDPROPERTYVALUE * __stdcall
StgConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVector,
    OPTIONAL OUT ULONG *pcIndirect)
{
    SERIALIZEDPROPERTYVALUE *ppropRet;
    NTSTATUS status;

    ppropRet = StgConvertVariantToPropertyNoEH(
                                    pvar, CodePage, pprop,
                                    pcb, pid, fVector,
                                    FALSE,  // fArray
                                    pcIndirect, NULL, &status );

    if (!NT_SUCCESS( status ))
        RtlRaiseStatus( status );

    return (ppropRet );

}

#endif // #if defined(WINNT)


// Enough for "prop%lu" + L'\0'
//#define CCH_MAX_INDIRECT_NAME (4 + 10 + 1)


// Now define the body of the function, returning errors with an
// NTSTATUS value instead of raising.

SERIALIZEDPROPERTYVALUE *
StgConvertVariantToPropertyNoEH(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVector,  // Used for recursive calls
    IN BOOLEAN fArray,    // Used for recursive calls
    OPTIONAL OUT ULONG *pcIndirect,
    IN OUT OPTIONAL WORD *pwMinFormatRequired,
    OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    //  ------
    //  Locals
    //  ------
    CHAR *pchConvert = NULL;

    ULONG count = 0;
    BYTE *pbdst;
    ULONG cbch = 0;
    ULONG cbchdiv = 0;
    ULONG cb = 0;
    ULONG ulIndex = 0;  // Used as a misc loop control variable

    // Size of byte-swapping units (e.g. 2 to swap a WORD).
    INT   cbByteSwap = 0;

    ULONG const *pcount = NULL;
    VOID const *pv = NULL;
    LONG *pclipfmt = NULL;
    BOOLEAN fCheckNullSource;
    BOOLEAN fIllegalType = FALSE;
    const VOID * const *ppv = NULL;
    OLECHAR aocName[ PROPGENPROPERTYNAME_SIZEOF ]; //CCH_MAX_INDIRECT_NAME ];
    BOOLEAN fByRef;

    const SAFEARRAY *parray = NULL;
    const VOID *parraydata = NULL;
    ULONG fSafeArrayLocked = FALSE;
    ULONG cSafeArrayDims = 0;

    IFDBG( HRESULT &hr = *pstatus; )
    propITraceStatic( "StgConvertVariantToPropertyNoEH" );
    propTraceParameters(( "pprop=%p, CodePage=%d, pvar=%p, pma=%p" ));


    // Initialize a local wMinFormatRequired - this is the minimum serialization
    // format version required for the data in this property set (e.g., if you
    // don't use any of the new NT5 support, you can stay a version 0 property set,
    // otherwise you go to version 1).

    WORD wMinFormatRequired = (NULL == pwMinFormatRequired)
                                  ? (WORD) PROPSET_WFORMAT_ORIGINAL
                                  : (WORD) *pwMinFormatRequired;

    // If this is a byref, then up the min format required.

    if( VT_BYREF & pvar->vt )
        wMinFormatRequired = (WORD) max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );

    // We dereference byrefs.  If this is a byref Variant, we can shortcut this
    // by simply changing pvar.

    while( (VT_BYREF | VT_VARIANT) == pvar->vt )
    {
        if( NULL == pvar->pvarVal )
        {
            *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        pvar = pvar->pvarVal;
    }

    // Now that we've settled on the pvar we're going to convert,
    // Jot down some info on it.

    fCheckNullSource = (BOOLEAN) ((pvar->vt & VT_VECTOR) != 0);
    fByRef = 0 != (pvar->vt & VT_BYREF);

    // If this is an array, then validate the VT in the SafeArray itself matches
    // pvar->vt.

    if( VT_ARRAY & pvar->vt )
    {
        VARTYPE vtSafeArray = VT_EMPTY;

        // It's invalid to have both the array and vector bits set (would it be
        // an array of vectors or a vector of arrays?).
        if( VT_VECTOR & pvar->vt )
        {
            StatusInvalidParameter( pstatus, "Both VT_VECTOR and VT_ARRAY set" );
            goto Exit;
        }

        // Arrays require an uplevel property set format
        wMinFormatRequired = (WORD) max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );

        // Get the Type bit from the SafeArray

        if( VT_BYREF & pvar->vt )
        {
            if( NULL != pvar->pparray && NULL != *pvar->pparray )
            {
                *pstatus = PrivSafeArrayGetVartype( *pvar->pparray, &vtSafeArray );
                if( FAILED(*pstatus) )
                    goto Exit;
            }
        }
        else if( NULL != pvar->parray )
        {
            *pstatus = PrivSafeArrayGetVartype( pvar->parray, &vtSafeArray );
            if( FAILED(*pstatus) )
                goto Exit;
        }

        if( !NT_SUCCESS(*pstatus) )
            goto Exit;

        // Ensure the VT read from the property set matches that in the PropVariant.
        // It is illegal for these to be different.

        if( ( vtSafeArray & VT_TYPEMASK )
            !=
            ( pvar->vt    & VT_TYPEMASK ) )
        {
            *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

    }   // if( VT_ARRAY & pvar->vt )


    //  -------------------------------------------------------
    //  Analyze the PropVariant, and store information about it
    //  in fIllegalType, cb, pv, pcount, count, pclipfmt,
    //  fCheckNullSource, cbch, chchdiv, and ppv.
    //  -------------------------------------------------------


    switch( pvar->vt )
    {
    case VT_EMPTY:
    case VT_NULL:
        fIllegalType = fVector || fArray;
        break;

    case VT_I1 | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_I1:
        AssertByteField(cVal);        // VT_I1
        wMinFormatRequired = (WORD) max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );
        
        cb = sizeof(pvar->bVal);
        pv = fByRef ? pvar->pcVal : &pvar->cVal;
        break;

    
    case VT_UI1 | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_UI1:
        AssertByteField(bVal);          // VT_UI1
        AssertStringField(pbVal);

        cb = sizeof(pvar->bVal);
        pv = fByRef ? pvar->pbVal : &pvar->bVal;
        break;


    case VT_I2 | VT_BYREF:
    case VT_UI2 | VT_BYREF:
    case VT_BOOL | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:

        AssertShortField(iVal);         // VT_I2
        AssertStringField(piVal);
        AssertShortField(uiVal);        // VT_UI2
        AssertStringField(puiVal);
        AssertShortField(boolVal);      // VT_BOOL

        cb = sizeof(pvar->iVal);
        pv = fByRef ? pvar->piVal : &pvar->iVal;

        // If swapping, swap as a WORD
        CBBYTESWAP(cb);
        break;

    case VT_INT | VT_BYREF:
    case VT_UINT | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_INT:
    case VT_UINT:
        fIllegalType |= fVector;
        // Fall through

    case VT_I4 | VT_BYREF:
    case VT_UI4 | VT_BYREF:
    case VT_R4 | VT_BYREF:
    case VT_ERROR | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:

        AssertLongField(lVal);          // VT_I4
        AssertStringField(plVal);
        AssertLongField(intVal);      // VT_INT
        AssertStringField(pintVal);
        AssertLongField(ulVal);         // VT_UI4
        AssertLongField(uintVal);     // VT_UINT
        AssertStringField(puintVal);
        AssertStringField(pulVal);
        AssertLongField(fltVal);        // VT_R4
        AssertStringField(pfltVal);
        AssertLongField(scode);         // VT_ERROR
        AssertStringField(pscode);

        if( VT_INT == (pvar->vt&VT_TYPEMASK) || VT_UINT == (pvar->vt&VT_TYPEMASK) )
            wMinFormatRequired = (WORD) max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );

        cb = sizeof(pvar->lVal);
        pv = fByRef ? pvar->plVal : &pvar->lVal;

        // If swapping, swap as a DWORD
        CBBYTESWAP(cb);
        break;

    case VT_FILETIME:
        fIllegalType = fArray;

    /*
    case VT_I8 | VT_BYREF:
    case VT_UI8 | VT_BYREF:
        fIllegalType = fVector || fArray;
    */

    case VT_I8:
    case VT_UI8:
        AssertLongLongField(hVal);      // VT_I8
        AssertLongLongField(uhVal);     // VT_UI8
        AssertLongLongField(filetime);  // VT_FILETIME

        cb = sizeof(pvar->hVal);
        pv = &pvar->hVal;

        // If swapping, swap each DWORD independently.
        CBBYTESWAP(sizeof(DWORD));
        break;

    case VT_R8 | VT_BYREF:
    case VT_CY | VT_BYREF:
    case VT_DATE | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_R8:
    case VT_CY:
    case VT_DATE:

        AssertLongLongField(dblVal);    // VT_R8
        AssertStringField(pdblVal);
        AssertLongLongField(cyVal);     // VT_CY
        AssertStringField(pcyVal);
        AssertLongLongField(date);      // VT_DATE
        AssertStringField(pdate);

        cb = sizeof(pvar->dblVal);
        pv = fByRef ? pvar->pdblVal : &pvar->dblVal;

        // If swapping, swap as a LONGLONG (64 bits).
        CBBYTESWAP(cb);
        break;

    case VT_CLSID:
        AssertStringField(puuid);       // VT_CLSID

        fIllegalType = fArray;
        cb = sizeof(GUID);
        pv = pvar->puuid;
        fCheckNullSource = TRUE;

        // If swapping, special handling is required.
        CBBYTESWAP( CBBYTESWAP_UID );
        break;

    case VT_DECIMAL | VT_BYREF:
        fIllegalType = fVector || fArray;
    case VT_DECIMAL:
        fIllegalType |= fVector;
        wMinFormatRequired = (WORD) max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );

        cb = sizeof(DECIMAL);
        pv = fByRef ? pvar->pdecVal : &pvar->decVal;
        break;

    case VT_CF:

        fIllegalType = fArray;

        // Validate the PropVariant
        if (pvar->pclipdata == NULL
            ||
            pvar->pclipdata->cbSize < sizeof(pvar->pclipdata->ulClipFmt) )
        {
            StatusInvalidParameter(pstatus, "StgConvertVariantToProperty: pclipdata NULL");
            goto Exit;
        }

        // How many bytes should we copy?
        cb = CBPCLIPDATA( *(pvar->pclipdata) );

        // Identify the value for this property's count field.
        // (which includes sizeof(ulClipFmt))
        count = pvar->pclipdata->cbSize;
        pcount = &count;

        // Identify the clipdata's format & data
        pclipfmt = &pvar->pclipdata->ulClipFmt;
        pv = pvar->pclipdata->pClipData;

        fCheckNullSource = TRUE;

        // Note that no byte-swapping of 'pv' is necessary.
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        fIllegalType = fVector || fArray;
        pcount = &pvar->blob.cbSize;
        cb = *pcount;
        pv = pvar->blob.pBlobData;
        fCheckNullSource = TRUE;

        // Note that no byte-swapping of 'pv' is necessary.
        break;

    case VT_VERSIONED_STREAM:

        wMinFormatRequired = (WORD) max( wMinFormatRequired, PROPSET_WFORMAT_VERSTREAM );
        // Fall through

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:

        fIllegalType = fVector || fArray;
        if( fIllegalType ) break;

        // Does the caller support indirect properties?
        if (pcIndirect != NULL)
        {
            // Yes.
            (*pcIndirect)++;

            // For indirect properties, we don't write the value
            // in 'pvar', we write a substitute value.  That value is by
            // convention (IPropertyStorage knows to use PROPGENPROPERTYNAME),
            // so we don't have to pass the name back to the caller.

            PROPGENPROPERTYNAME_CB(aocName, sizeof(aocName), pid);
            pv = aocName;

        }

        // Otherwise, the caller doesn't support indirect properties,
        // so we'll take the value from pwszVal
        else
        {
            PROPASSERT(
                pvar->pwszVal == NULL ||
                IsUnicodeString(pvar->pwszVal, MAXULONG));
            pv = pvar->pwszVal;
        }

        count = 1;      // default to forcing an error on NULL pointer

        // Jump to the LPSTR/BSTR handling code, but skip the ansi check
        goto noansicheck;

        break;

    case VT_BSTR | VT_BYREF:
        fIllegalType = fVector || fArray;
        count = 0;
        pv = *pvar->pbstrVal;
        goto noansicheck;

    case VT_LPSTR:
        fIllegalType = fArray;
        PROPASSERT(
            pvar->pszVal == NULL ||
            IsAnsiString(pvar->pszVal, MAXULONG));
        // FALLTHROUGH

    case VT_BSTR:
        count = 0;      // allow NULL pointer
        pv = pvar->pszVal;
noansicheck:
        AssertStringField(pwszVal);             // VT_STREAM, VT_STREAMED_OBJECT
        AssertStringField(pwszVal);             // VT_STORAGE, VT_STORED_OBJECT
        AssertStringField(bstrVal);             // VT_BSTR
        AssertStringField(pbstrVal);
        AssertStringField(pszVal);              // VT_LPSTR
        AssertStringField(pVersionedStream);    // VT_VERSIONED_STREAM

        if( fIllegalType ) break;

        // We have the string for an LPSTR, BSTR, or indirect
        // property pointed to by 'pv'.  Now we'll perform any
        // Ansi/Unicode conversions and byte-swapping that's
        // necessary (putting the result in 'pv').

        if (pv == NULL)
        {
            fCheckNullSource = TRUE;
        }

        else if (pvar->vt == VT_LPSTR)
        {
            count = (ULONG)strlen((char *) pv) + 1;

            // If the propset is Unicode, convert the LPSTR to Unicode.

            if (CodePage == CP_WINUNICODE)
            {
                // Convert to Unicode.

                PROPASSERT(IsAnsiString((CHAR const *) pv, count));
                PrpConvertToUnicode(
                                (CHAR const *) pv,
                                count,
                                CP_ACP,  // Variants are in the system codepage
                                (WCHAR **) &pchConvert,
                                &count,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                // 'pv' always has the ready-to-serialize string.
                pv = pchConvert;

                // This unicode string may require byte-swapping.
                CBBYTESWAP( sizeof(WCHAR) );
            }
        }   // else if (pvar->vt == VT_LPSTR)

        else
        {
            // If this is a BSTR, increment the count to include
            // the string terminator.
            if( (~VT_BYREF & pvar->vt) == VT_BSTR )
            {
               count = BSTRLEN(pv); // (This looks at the count field, not wcslen)

                // Verify that the input BSTR is terminated.
                if( S_OK != StringCbLengthW((const OLECHAR*)pv, count+sizeof(OLECHAR), NULL ))
                {
                    StatusInvalidParameter(pstatus,
                        "StgConvertVariantToProperty: bad BSTR null char");
                    goto Exit;
                }

                // Increment the count to include the terminator.
                count += sizeof(OLECHAR);
            }
            else
            {
                count = ((ULONG)Prop_ocslen((OLECHAR *) pv) + 1) * sizeof(OLECHAR);
                PROPASSERT(IsOLECHARString((OLECHAR const *) pv, count));
            }

            // This string is either an indirect property name,
            // or a BSTR, both of which could be Ansi or Unicode.

            if (CodePage != CP_WINUNICODE   // Ansi property set
                &&
                OLECHAR_IS_UNICODE          // The PropVariant is in Unicode
               )
            {
                // A Unicode to Ansi conversion is required.

                PROPASSERT( IsUnicodeString( (WCHAR*)pv, count ));

                PrpConvertToMultiByte(
                                (WCHAR const *) pv,
                                count,
                                CodePage,
                                &pchConvert,
                                &count,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
                pv = pchConvert;
            }

            else
            if (CodePage == CP_WINUNICODE   // Unicode property set,
                &&
                !OLECHAR_IS_UNICODE         // The PropVariant is in Ansi
               )
            {
                // An Ansi to Unicode conversion is required.

                PROPASSERT(IsAnsiString((CHAR const *) pv, count));
                PROPASSERT(sizeof(OLECHAR) == sizeof(CHAR));

                PrpConvertToUnicode(
                                (CHAR const *) pv,
                                count,
                                CP_ACP, // In-mem BSTR is in system CP
                                (WCHAR **) &pchConvert,
                                &count,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                // 'pv' always holds the ready-to-serialize value.
                pv = pchConvert;

                // This unicode string may require swapping.
                CBBYTESWAP( sizeof(WCHAR) );
            }

            else
            if (CodePage == CP_WINUNICODE)
            {
                // No conversion is required (i.e., both 'pv' and the 
                // property set are Unicode).  But we must remember
                // to perform a byte-swap (if byte-swapping is necessary).

                CBBYTESWAP( sizeof(WCHAR) );
            }
        }   // if (pv == NULL) ... else if ... else

        // Validate 'pv'.
#ifdef LITTLEENDIAN
        PROPASSERT( NULL == pv
                    ||
                    CodePage == CP_WINUNICODE && IsUnicodeString((WCHAR*)pv, count)
                    ||
                    CodePage != CP_WINUNICODE && IsAnsiString((CHAR*)pv, count) );
#endif

        cb = count;
        pcount = &count;
        break;

    case VT_LPWSTR:
        AssertStringField(pwszVal);             // VT_LPWSTR
        PROPASSERT(
            pvar->pwszVal == NULL ||
            IsUnicodeString(pvar->pwszVal, MAXULONG));

        fIllegalType = fArray;
        pv = pvar->pwszVal;
        if (pv == NULL)
        {
            count = 0;
            fCheckNullSource = TRUE;
        }
        else
        {
            // Calculate the [length] field.
            count = (ULONG)Prop_wcslen(pvar->pwszVal) + 1;

            // If byte-swapping will be necessary to get to the serialized
            // format, we'll do so in units of WCHARs.

            CBBYTESWAP( sizeof(WCHAR) );
        }

        cb = count * sizeof(WCHAR);
        pcount = &count;
        break;

    /*
    case VT_RECORD:

        pv = pvar->pvRecord;
        pRecInfo = pvar->pRecInfo;

        if( NULL == pv )
        {
            count = 0;
            fCheckNullSource = TRUE;
        }
        else if( NULL == pRecInfo )
        {
            StatusInvalidParameter( pstatus, "Missing IRecordInfo*" );
            goto Exit;
        }

        cb = 0;

        break;
    */

    // Vector properties:

    case VT_VECTOR | VT_I1:
        AssertByteVector(cac);          // VT_I1
        fIllegalType = fArray;
        wMinFormatRequired = (WORD) max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );
        // Fall through

    case VT_VECTOR | VT_UI1:
        AssertByteVector(caub);         // VT_UI1
        fIllegalType = fArray;
        pcount = &pvar->caub.cElems;
        cb = *pcount * sizeof(pvar->caub.pElems[0]);
        pv = pvar->caub.pElems;
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        AssertShortVector(cai);         // VT_I2
        AssertShortVector(caui);        // VT_UI2
        AssertShortVector(cabool);      // VT_BOOL

        fIllegalType = fArray;
        pcount = &pvar->cai.cElems;
        cb = *pcount * sizeof(pvar->cai.pElems[0]);
        pv = pvar->cai.pElems;

        // If swapping, swap as WORDs
        CBBYTESWAP(sizeof(pvar->cai.pElems[0]));
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        AssertLongVector(cal);          // VT_I4
        AssertLongVector(caul);         // VT_UI4
        AssertLongVector(caflt);        // VT_R4
        AssertLongVector(cascode);      // VT_ERROR

        fIllegalType = fArray;
        pcount = &pvar->cal.cElems;
        cb = *pcount * sizeof(pvar->cal.pElems[0]);
        pv = pvar->cal.pElems;

        // If swapping, swap as DWORDs
        CBBYTESWAP(sizeof(pvar->cal.pElems[0]));
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_FILETIME:
        AssertLongLongVector(cah);      // VT_I8
        AssertLongLongVector(cauh);     // VT_UI8
        AssertLongLongVector(cafiletime);// VT_FILETIME

        fIllegalType = fArray;
        pcount = &pvar->cah.cElems;
        cb = *pcount * sizeof(pvar->cah.pElems[0]);
        pv = pvar->cah.pElems;

        // If swapping, swap as DWORDs
        CBBYTESWAP(sizeof(DWORD));
        break;

    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
        AssertLongLongVector(cadbl);    // VT_R8
        AssertLongLongVector(cacy);     // VT_CY
        AssertLongLongVector(cadate);   // VT_DATE

        fIllegalType = fArray;
        pcount = &pvar->cah.cElems;
        cb = *pcount * sizeof(pvar->cadbl.pElems[0]);
        pv = pvar->cadbl.pElems;

        // If swapping, swap as LONGLONGs (8 bytes)
        CBBYTESWAP(sizeof(pvar->cadbl.pElems[0]));
        break;

    case VT_VECTOR | VT_CLSID:
        AssertVarVector(cauuid, sizeof(GUID));

        fIllegalType = fArray;
        pcount = &pvar->cauuid.cElems;
        cb = *pcount * sizeof(pvar->cauuid.pElems[0]);
        pv = pvar->cauuid.pElems;

        // If swapping, special handling is required.
        CBBYTESWAP( CBBYTESWAP_UID );
        break;

    case VT_VECTOR | VT_CF:
        fIllegalType = fArray;
        cbch = sizeof(CLIPDATA);
        cbchdiv = sizeof(BYTE);
        goto stringvector;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
        fIllegalType = fArray;
        cbchdiv = cbch = sizeof(BYTE);
        goto stringvector;

    case VT_VECTOR | VT_LPWSTR:
        fIllegalType = fArray;
        cbchdiv = cbch = sizeof(WCHAR);
        goto stringvector;

    case VT_VECTOR | VT_VARIANT:
        fIllegalType = fArray;
        cbch = MAXULONG;
stringvector:
        AssertVarVector(caclipdata, sizeof(CLIPDATA));  // VT_CF
        AssertStringVector(cabstr);                     // VT_BSTR
        AssertStringVector(calpstr);                    // VT_LPSTR
        AssertStringVector(calpwstr);                   // VT_LPWSTR
        AssertVarVector(capropvar, sizeof(PROPVARIANT));// VT_VARIANT

        pcount = &pvar->calpstr.cElems;
        ppv = (VOID **) pvar->calpstr.pElems;
        break;


    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_BSTR | VT_BYREF:
        fIllegalType = fVector || fArray;
        cbchdiv = cbch = sizeof(BYTE);
        cb = 1;
        // Fall through
        
    case VT_ARRAY | VT_VARIANT:
    case VT_ARRAY | VT_VARIANT | VT_BYREF:
        fIllegalType = fVector || fArray;
        if( 0 == cbch )
            cbch = MAXULONG;

        pcount = &count;

    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_I1 | VT_BYREF:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_UI1 | VT_BYREF:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_I2 | VT_BYREF:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI2 | VT_BYREF:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_BOOL | VT_BYREF:
    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_I4 | VT_BYREF:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_UI4 | VT_BYREF:
    /*
    case VT_ARRAY | VT_I8:
    case VT_ARRAY | VT_I8 | VT_BYREF:
    case VT_ARRAY | VT_UI8:
    case VT_ARRAY | VT_UI8 | VT_BYREF:
    */
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_INT | VT_BYREF:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_UINT | VT_BYREF:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R4 | VT_BYREF:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_ERROR | VT_BYREF:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_DECIMAL | VT_BYREF:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_R8 | VT_BYREF:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_CY | VT_BYREF:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_DATE | VT_BYREF:

        fIllegalType = fVector || fArray;
        if( fIllegalType ) break;

        wMinFormatRequired = (WORD) max( wMinFormatRequired, PROPSET_WFORMAT_EXPANDED_VTS );

        parray = (VT_BYREF & pvar->vt) ? *pvar->pparray : pvar->parray;

        if( NULL == parray )
            cb = 0;
        else
        {
            // Get a pointer to the raw data
            *pstatus = PrivSafeArrayAccessData( const_cast<SAFEARRAY*>(parray), const_cast<void**>(&parraydata) );
            if( FAILED(*pstatus) ) goto Exit;
            fSafeArrayLocked = TRUE;

            pv = parraydata;
            ppv = static_cast<const void* const*>(pv);

            // Determine the dimension count and element size
            cSafeArrayDims = PrivSafeArrayGetDim( const_cast<SAFEARRAY*>(parray) );
            cb = PrivSafeArrayGetElemsize( const_cast<SAFEARRAY*>(parray) );
            PROPASSERT( 0 != cb );

            if( 0 == cSafeArrayDims )
            {
                StatusInvalidParameter( pstatus, "Zero-length safearray dimension" );
                goto Exit;
            }

            // Determine the number of elements, and the total size of parraydata
            count = CalcSafeArrayElements( cSafeArrayDims, parray->rgsabound );
            cb *= count;
        }

        break;

    default:
        propDbg(( DEB_IWARN, "StgConvertVariantToProperty: unsupported vt=%d\n", pvar->vt));
        *pstatus = STATUS_NOT_SUPPORTED;
        goto Exit;

    }   // switch (pvar->vt)

    //  ---------------------------------------------------------
    //  Serialize the property into the property set (pprop->rgb)
    //  ---------------------------------------------------------

    // At this point we've analyzed the PropVariant, and stored
    // information about it in various local variables.  Now we
    // can use this information to serialize the propvar.

    // Early exit if this is an illegal type.

    if (fIllegalType)
    {
        propDbg(( DEB_ERROR, "vt=%d\n", pvar->vt ));
        StatusInvalidParameter(pstatus, "StgConvertVariantToProperty: Illegal VarType");
        goto Exit;
    }

    // Set pbdst to point into the serialization buffer, or to 
    // NULL if there is no such buffer.

    if (pprop == NULL)
    {
        pbdst = NULL;
    }
    else
    {
        pbdst = pprop->rgb;
    }

    // Is this an Array/Vector of Strings/Variants/CFs?
    if (cbch != 0)
    {
        // Yes.

        PROPASSERT(pcount != NULL);
        PROPASSERT(*pcount == 0 || ppv != NULL);
        PROPASSERT(0 == cbByteSwap);

        // Start calculating the serialized size.  Include the sizes
        // of the VT.

        cb = sizeof(ULONG);
        
        // Is this an Array or Vector of Variants?
        if( cbch != MAXULONG )
        {
            // No.  Include each element's length field.
            cb += *pcount * sizeof(ULONG);
        }

        // For vectors, write the element count
        if( VT_VECTOR & pvar->vt )
        {
            cb += sizeof(ULONG);

            // Do we have room to write it?
            if( *pcb < cb )
            {
                // No.  But we'll continue to calculate the cb
                pprop = NULL;
            }
            else if( pprop != NULL )
            {
                *(ULONG *) pbdst = PropByteSwap(*pcount);
                pbdst += sizeof(ULONG);
            }
        }   // if( VT_VECTOR & pvar->vt )

        // For arrays, write the dimension count, features, and element size
        else if( NULL != parray )
        {
            PROPASSERT( VT_ARRAY & pvar->vt );
            ULONG cbBounds = 0, cElems = 0;

            // Allow for the VarType & dimension count
            cb += sizeof(DWORD);
            cb += sizeof(UINT);    
            PROPASSERT( sizeof(DWORD) >= sizeof(VARTYPE) );

            // Allow for the rgsaBounds
            *pstatus = SerializeSafeArrayBounds( parray, NULL, &cbBounds, &cElems );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            cb += cbBounds;

            // Do we have room to write this?
            if( *pcb < cb )
            {
                // No, but continue to calc cb
                pprop = NULL;
            }
            else if( NULL != pprop )
            {
                // Yes, we have room.  Write the safearray header data.
                PROPASSERT( sizeof(UINT) == sizeof(ULONG) );

                // Write the SafeArray's internal vartype.  We'll write the real pvar->vt
                // at the bottom of this routine.

                *(DWORD *)  pbdst = 0;
                *(VARTYPE *)pbdst = PropByteSwap( static_cast<VARTYPE>(pvar->vt & VT_TYPEMASK) );
                pbdst += sizeof(DWORD);

                // Write the dimension count
                *(UINT *)pbdst = PropByteSwap(cSafeArrayDims);
                pbdst += sizeof(UINT);

                // Write the bounds
                *pstatus = SerializeSafeArrayBounds( parray, pbdst, &cbBounds, &cElems );
                pbdst += cbBounds;
            }
        }   // if( VT_VECTOR & pvar->vt ) ... else if

        // Walk through the vector/array and write the elements.

        for( ulIndex = *pcount; ulIndex > 0; ulIndex-- )
        {
            ULONG cbcopy = 0;
            const PROPVARIANT *ppropvarT;

            // Switch on the size of the element.
            switch (cbch)
            {
                //
                // VT_VARIANT, VT_VECTOR
                //
                case MAXULONG:
                    cbcopy = MAXULONG;

                    // Perform a recursive serialization
                    StgConvertVariantToPropertyNoEH(
                                (PROPVARIANT *) ppv,
                                CodePage,
                                NULL,
                                &cbcopy,
                                PID_ILLEGAL,
                                (VT_VECTOR & pvar->vt) ? TRUE : FALSE,
                                (VT_ARRAY  & pvar->vt) ? TRUE : FALSE,
                                NULL,
                                &wMinFormatRequired,
                                pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    break;


                //
                //  VT_CF
                //
                case sizeof(CLIPDATA):

                    // We copy cbSize-sizeof(ulClipFmt) bytes.

                    if( ((CLIPDATA *) ppv)->cbSize < sizeof(ULONG) )
                    {
                        StatusInvalidParameter(pstatus, "StgConvertVariantToProperty: short cbSize on VT_CF");
                        goto Exit;
                    }
                    else
                    {
                        cbcopy = CBPCLIPDATA( *(CLIPDATA*) ppv );
                    }

                    // But increment cb to to include sizeof(ulClipFmt)
                    cb += sizeof(ULONG);
                    break;

                //
                //  VT_LPWSTR
                //
                case sizeof(WCHAR):
                    if (*ppv != NULL)
                    {
                        PROPASSERT(IsUnicodeString((WCHAR const *) *ppv, MAXULONG));
                        cbcopy = ((ULONG)Prop_wcslen((WCHAR *) *ppv) + 1) * sizeof(WCHAR);
                        pv = *ppv;

                        // If byte-swapping is necessary, swap in units of WCHARs
                        CBBYTESWAP( sizeof(WCHAR) );

                    }
                    break;

                //
                //  VT_LPSTR/VT_BSTR
                //
                default:

                    PROPASSERT(cbch == sizeof(BYTE));
                    PROPASSERT(pchConvert == NULL);

                    if (*ppv != NULL)
                    {
                        pv = *ppv;

                        // Is this a BSTR?
                        if( VT_BSTR == (VT_TYPEMASK & pvar->vt) )
                        {
                            // Initialize the # bytes to copy.
                            cbcopy = BSTRLEN(pv);

                            // Verify that the BSTR is terminated.
                            if( S_OK != StringCbLengthW((const OLECHAR*)pv, cbcopy+sizeof(OLECHAR), NULL ))
                            {
                                StatusInvalidParameter(pstatus,
                                    "StgConvertVariantToProperty: bad BSTR array null char");
                                goto Exit;
                            }

                            // Also copy the string terminator.
                            cbcopy += sizeof(OLECHAR);

                            // If the propset and the BSTR are in mismatched
                            // codepages (one's Unicode, the other's Ansi),
                            // correct the BSTR now.  In any case, the correct
                            // string is in 'pv'.

                            if (CodePage != CP_WINUNICODE   // Ansi property set
                                &&
                                OLECHAR_IS_UNICODE)         // Unicode BSTR
                            {
                                PROPASSERT(IsUnicodeString((WCHAR*)pv, cbcopy));

                                PrpConvertToMultiByte(
                                                (WCHAR const *) pv,
                                                cbcopy,
                                                CodePage,
                                                &pchConvert,
                                                &cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                pv = pchConvert;
                            }

                            else
                            if (CodePage == CP_WINUNICODE   // Unicode property set
                                &&
                                !OLECHAR_IS_UNICODE)        // Ansi BSTRs
                            {
                                PROPASSERT(IsAnsiString((CHAR const *) pv, cbcopy));

                                PrpConvertToUnicode(
                                                (CHAR const *) pv,
                                                cbcopy,
                                                CP_ACP, // In-mem BSTR is in system CP
                                                (WCHAR **) &pchConvert,
                                                &cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                // The Unicode string must have the proper byte order
                                CBBYTESWAP( sizeof(WCHAR) );

                                pv = pchConvert;

                            }

                            else
                            if (CodePage == CP_WINUNICODE )
                            {
                                // Both the BSTR and the property set are Unicode.
                                // No conversion is required, but byte-swapping
                                // is (if byte-swapping is enabled).

                                CBBYTESWAP( sizeof(WCHAR) );
                            }

                        }   // if( VT_BSTR == (VT_TYPEMASK & pvar->vt) )

                        // Otherwise it's an LPSTR
                        else
                        {
                            PROPASSERT(IsAnsiString((char const *) pv, MAXULONG));
                            PROPASSERT(pvar->vt == (VT_VECTOR | VT_LPSTR));
                            cbcopy = (ULONG)strlen((char *) pv) + 1; // + trailing null

                            if (CodePage == CP_WINUNICODE)
                            {
                                PROPASSERT(IsAnsiString(
                                                (CHAR const *) pv,
                                                cbcopy));
                                PrpConvertToUnicode(
                                                (CHAR const *) pv,
                                                cbcopy,
                                                CP_ACP,
                                                (WCHAR **) &pchConvert,
                                                &cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                // If byte-swapping, we'll do so with the WCHARs
                                CBBYTESWAP( sizeof(WCHAR) );

                                pv = pchConvert;
                            }   
                        }   // if (pvar->vt == (VT_VECTOR | VT_BSTR)) ... else
                    }   // if (*ppv != NULL)

                    // In the end, pv should be in the codepage of
                    // the property set.

#ifdef LITTLEENDIAN
                    PROPASSERT( NULL == pv
                                ||
                                CodePage == CP_WINUNICODE && IsUnicodeString((WCHAR*)pv, cbcopy)
                                ||
                                CodePage != CP_WINUNICODE && IsAnsiString((CHAR*)pv, cbcopy));
#endif

                    break;

            }   // switch (cbch)
            
            // Add the size of this vector element to the property total
            cb += DwordAlign(cbcopy);

            // Will there be enough room for this vector element?

            if (*pcb < cb)
            {
                // No - we'll continue (thus calculating the total size
                // necessary), but we won't write to the caller's buffer.
                pprop = NULL;
            }

            // Is this a vector or array of Variants?

            if (cbch == MAXULONG)
            {
                // Yes.  Convert this variant.
                if (pprop != NULL)
                {
                    StgConvertVariantToPropertyNoEH(
                                (PROPVARIANT *) ppv,
                                CodePage,
                                (SERIALIZEDPROPERTYVALUE *) pbdst,
                                &cbcopy,
                                PID_ILLEGAL,
                                (VT_VECTOR & pvar->vt) ? TRUE : FALSE,
                                (VT_ARRAY  & pvar->vt) ? TRUE : FALSE,
                                NULL,
                                &wMinFormatRequired,
                                pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    pbdst += cbcopy;
                }
                ppv = (VOID **) Add2Ptr(ppv, sizeof(PROPVARIANT));
            }   // if (cbch == MAXULONG)

            else
            {
                // This is a vector/array of strings or clipformats

                PROPASSERT(
                    cbch == sizeof(BYTE) ||
                    cbch == sizeof(WCHAR) ||
                    cbch == sizeof(CLIPDATA));

                PROPASSERT(cbchdiv == sizeof(BYTE) || cbchdiv == sizeof(WCHAR));

                // Are we writing the serialized property?
                if (pprop != NULL)
                {
                    ULONG cbVectOrArrayElement;

                    // Calculate the length of the vector/array element.
                    cbVectOrArrayElement = (ULONG) cbcopy/cbchdiv;

                    // Is this a ClipData?
                    if( cbch == sizeof(CLIPDATA) )
                    {
                        // Adjust the length to include sizeof(ulClipFmt)
                        cbVectOrArrayElement += sizeof(ULONG);

                        // Write the vector element length.
                        *(ULONG *) pbdst = PropByteSwap( cbVectOrArrayElement );

                        // Advance pbdst & write the clipboard format.
                        pbdst += sizeof(ULONG);
                        *(ULONG *) pbdst = PropByteSwap( ((CLIPDATA *) ppv)->ulClipFmt );
                    }
                    else
                    {
                        // Write the vector element length.
                        *(ULONG *) pbdst = PropByteSwap( cbVectOrArrayElement );
                    }

                    // Advance pbdst & write the property data.
                    pbdst += sizeof(ULONG);
                    RtlCopyMemory(
                                pbdst,
                                cbch == sizeof(CLIPDATA)?
                                  ((CLIPDATA *) ppv)->pClipData :
                                  pv,
                                cbcopy);

                    // Zero out the pad bytes.
                    RtlZeroMemory(pbdst + cbcopy, DwordRemain(cbcopy));

                    // If byte-swapping is necessary, do so now.
                    PBSBuffer( pbdst, DwordAlign(cbcopy), cbByteSwap );

                    // Advance pbdst to the next property.
                    pbdst += DwordAlign(cbcopy);

                }   // if (pprop != NULL)

                // Advance ppv to point into the PropVariant at the
                // next element in the array.

                if (cbch == sizeof(CLIPDATA))
                {
                    ppv = (VOID **) Add2Ptr(ppv, sizeof(CLIPDATA));
                }
                else
                {
                    ppv++;
                    CoTaskMemFree( pchConvert );
                    pchConvert = NULL;
                }
            }   // if (cbch == MAXULONG) ... else
        }   // for (cElems = *pcount; cElems > 0; cElems--)
    }   // if (cbch != 0)    // VECTOR/ARRAY of STRING/VARIANT/CF properties

    else
    {
        // This isn't an array or a vector, or the elements of the array/vector
        // aren't Strings, Variants, or CFs.

        ULONG cbCopy = cb;

        // Adjust cb (the total serialized buffer size) for
        // pre-data.

        if( pvar->vt != VT_EMPTY )
        {   // Allow for the VT
            cb += sizeof(ULONG);
        }
        if( pcount != NULL )
        {   // Allow for the count field
            cb += sizeof(ULONG);
        }
        if( pclipfmt != NULL )
        {   // Allow for the ulClipFmt field.
            cb += sizeof(ULONG);
        }
        if( pvar->vt == VT_VERSIONED_STREAM )
        {
            // Allow for the version guid
            cb += sizeof(pvar->pVersionedStream->guidVersion);
        }
        if( VT_ARRAY & pvar->vt )
        {
            // Allow for SafeArray header info
            cb += sizeof(DWORD);   // VT
            cb += sizeof(UINT);    // Dimension count
            PROPASSERT( sizeof(DWORD) >= sizeof(VARTYPE) );

            // Allow for the SafeArray bounds vector

            ULONG cbBounds = 0, cElems = 0;
            *pstatus = SerializeSafeArrayBounds( parray, NULL, &cbBounds, &cElems );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            cb += cbBounds;
        }

        /*
        if( VT_RECORD == (VT_TYPEMASK & pvar->vt) )
        {
            // Allow for the recinfo guids.
            cb += sizeof(GUID);     // Type library ID
            cb += sizeof(WORD);    // Major version
            cb += sizeof(WORD);    // Minor version
            cb += sizeof(LCID);     // Type library Locale ID
            cb += sizeof(GUID);     // Type info ID

            PROPASSERT( sizeof(WORD) == sizeof(USHORT) );   // Size of major/minor versions
            PROPASSERT( NULL == pcount );
        }
        */

        // Is there room in the caller's buffer?
        if( *pcb < cb )
        {   // No - calculate cb but don't write anything.
            pprop = NULL;
        }

        // 'pv' should point to the source data.  If it does, then
        // we'll copy it into the property set.  If it doesn't but
        // it should, then we'll report an error.

        if (pv != NULL || fCheckNullSource)
        {
            ULONG cbZero = DwordRemain(cbCopy);

            // Do we have a destination (propset) buffer?

            if (pprop != NULL)
            {
                // Copy the GUID for a VT_VERSIONED_STREAM
                if( pvar->vt == VT_VERSIONED_STREAM )
                {
                    if( NULL != pvar->pVersionedStream )
                        *reinterpret_cast<GUID*>(pbdst) = pvar->pVersionedStream->guidVersion;
                    else
                        *reinterpret_cast<GUID*>(pbdst) = GUID_NULL;

                    PropByteSwap( reinterpret_cast<GUID*>(pbdst) );
                    pbdst += sizeof(pvar->pVersionedStream->guidVersion);
                }

                // Does this property have a count field?
                if( pcount != NULL )
                {
                    // Write the count & advance pbdst
                    *(ULONG *) pbdst = PropByteSwap( *pcount );
                    pbdst += sizeof(ULONG);
                }

                // Copy the clipfmt for a VT_CF
                if( pclipfmt != NULL )
                {
                    PROPASSERT(pvar->vt == VT_CF);

                    // Write the ClipFormat & advance pbdst
                    *(ULONG *) pbdst = PropByteSwap( (DWORD) *pclipfmt );
                    pbdst += sizeof(ULONG);
                }

                // Write the array info
                if( (VT_ARRAY & pvar->vt) && NULL != parray )
                {
                    ULONG cbBounds = 0, cElems = 0;

                    PROPASSERT( NULL == pcount && NULL == pclipfmt );
                    PROPASSERT( NULL != parray );
                    PROPASSERT( 0 != cSafeArrayDims );
                    PROPASSERT( VT_ARRAY & pvar->vt );
                    PROPASSERT( sizeof(UINT) == sizeof(ULONG) );

                    *(DWORD *)  pbdst = 0;
                    *(VARTYPE *)pbdst = PropByteSwap( static_cast<VARTYPE>(pvar->vt & VT_TYPEMASK) );
                    pbdst += sizeof(DWORD);

                    *(UINT *)pbdst = PropByteSwap(cSafeArrayDims);
                    pbdst += sizeof(UINT);

                    *pstatus = SerializeSafeArrayBounds( parray, pbdst, &cbBounds, &cElems );
                    pbdst += cbBounds;

                }
            }   // if (pprop != NULL)

            // Are we missing the source data?
            if (pv == NULL)
            {
                // The Source pointer is NULL.  If cbCopy != 0, the passed
                // VARIANT is not properly formed.

                if (cbCopy != 0)
                {
                    StatusInvalidParameter(pstatus, "StgConvertVariantToProperty: bad NULL");
                    goto Exit;
                }
            }
            else if (pprop != NULL)
            {
                // We have a non-NULL source & destination.
                // First, copy the bytes from the former to the latter.

                RtlCopyMemory(pbdst, pv, cbCopy);

                // Then, if necessary, swap the bytes in the property
                // set (leaving the PropVariant bytes untouched).

                PBSBuffer( (VOID*) pbdst, cbCopy, cbByteSwap );

                // If this is a decimal, zero-out the reserved word at the front
                // (typically, this is actually the VarType, because of the
                // way in which a decimal is stored in a Variant).

                if( VT_DECIMAL == (~VT_BYREF & pvar->vt) )
                    *(WORD *) pbdst = 0;

            }

            // Did we write the serialization?
            if (pprop != NULL)
            {
                // Zero the padding bytes.
                RtlZeroMemory(pbdst + cbCopy, cbZero);

                // Canonicalize VARIANT_BOOLs.  We do this here because
                // we don't want to muck with the caller's buffer directly.

                if ((pvar->vt & ~VT_VECTOR) == VT_BOOL)
                {
                    VARIANT_BOOL *pvb = (VARIANT_BOOL *) pbdst;
                    VARIANT_BOOL *pvbEnd = &pvb[cbCopy/sizeof(*pvb)];

                    while (pvb < pvbEnd)
                    {
                        if (*pvb
                            &&
                            PropByteSwap(*pvb) != VARIANT_TRUE)
                        {
                            DebugTrace(0, DEBTRACE_ERROR, (
                                "Patching VARIANT_TRUE value: %hx --> %hx\n",
                                *pvb,
                                VARIANT_TRUE));

                            *pvb = PropByteSwap( (VARIANT_BOOL) VARIANT_TRUE );
                        }
                        pvb++;
                    }
                }
            }   // if (pprop != NULL)
        }
    }   // if (cbch != 0) ... else    // non - STRING/VARIANT/CF VECTOR property

    // Set the VT in the serialized buffer now that all size
    // checks completed.

    if (pprop != NULL && pvar->vt != VT_EMPTY)
    {
        // When byte-swapping the VT, treat it as a DWORD
        // (it's a WORD in the PropVariant, but a DWORD when
        // serialized).

        pprop->dwType = PropByteSwap( static_cast<DWORD>(~VT_BYREF & pvar->vt) );
    }

    // Update the caller's copy of the total size.
    *pcb = DwordAlign(cb);

Exit:

    if( fSafeArrayLocked )
    {
        PROPASSERT( NULL != parraydata );
        PROPASSERT( NULL != parray );

        PrivSafeArrayUnaccessData( const_cast<SAFEARRAY*>(parray) );
        parraydata = NULL;
    }

    /*
    if( NULL != pTypeInfo )
        pTypeInfo->Release();
    if( NULL != pTypeLib )
        pTypeLib->Release();
    */

    if( NULL != pwMinFormatRequired )
        *pwMinFormatRequired = wMinFormatRequired;

    CoTaskMemFree( pchConvert );
    return(pprop);

}


//+---------------------------------------------------------------------------
// Function:    StgConvertPropertyToVariant, private
//
// Synopsis:    Convert a SERIALIZEDPROPERTYVALUE to a PROPVARIANT
//
// Arguments:   [pprop]         -- pointer to SERIALIZEDPROPERTYVALUE
//              [PointerDelta]  -- adjustment to pointers to get user addresses
//              [fConvertNullStrings] -- map NULL strings to empty strings
//              [CodePage]      -- property set codepage
//              [pvar]          -- pointer to PROPVARIANT
//              [pma]           -- caller's memory allocation routine
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     TRUE if property is an indirect property type
//
// NOTE:        This routine assumes that pprop points to a semi-valid
//              serialized property value.  That is, pprop points to 
//              a property value, and its buffer is long enough to hold
//              the buffer.  This is ensured by calling PropertyLength first.
//              PropertyLength doesn't, however, ensure that individual fields
//              are correct, only that the length prefix is valid.  E.g.
//              it doesn't check the individual fields of a VT_CF, it doesn't
//              verify that strings are terminated, etc.
//
//---------------------------------------------------------------------------

#ifdef KERNEL
#define ADJUSTPOINTER(ptr, delta, type) (ptr) = (type) Add2Ptr((ptr), (delta))
#else
#define ADJUSTPOINTER(ptr, delta, type)
#endif

// First, define a wrapper for this function which returns errors
// using NT Exception Handling, rather than returning an NTSTATUS.
// This is done for backwards compatibility with old CI implementations.

#if defined(WINNT)

EXTERN_C BOOLEAN __stdcall
StgConvertPropertyToVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma)
{
    BOOLEAN boolRet;
    NTSTATUS status;

    boolRet = StgConvertPropertyToVariantNoEH(
                        pprop, -1, CodePage, pvar,
                        pma, &status );

    if (!NT_SUCCESS( status ))
        RtlRaiseStatus( status );

    return (boolRet);

}

#endif // #if defined(WINNT)


// Now define the body of the function, returning errors with an
// NTSTATUS value instead of raising.

BOOLEAN
StgConvertPropertyToVariantNoEH(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN ULONG cbprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma,
    OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    //  ------
    //  Locals
    //  ------

    BOOLEAN fIndirect = FALSE;

    // Buffers which must be freed before exiting.
    CHAR *pchConvert = NULL, *pchByteSwap = NULL;

    VOID **ppv = NULL;
    VOID *pv = NULL;
    const VOID *pvCountedString = NULL;

    VOID *pvSafeArrayData = NULL;
    SAFEARRAY *psa = NULL;
    BOOL fSafeArrayLocked = FALSE;

    ULONG cbskip = sizeof(ULONG);

    ULONG cb = 0;

    // Size of byte-swapping units (must be signed).
    INT cbByteSwap = 0;

    BOOLEAN fPostAllocInit = FALSE;
    BOOLEAN fNullLegal = (BOOLEAN) ( (PropByteSwap(pprop->dwType) & VT_VECTOR) != 0 );

    IFDBG( HRESULT &hr = *pstatus; )
    propITraceStatic( "StgConvertPropertyToVariantNoEH" );
    propTraceParameters(( "pprop=%p, CodePage=%d, pvar=%p, pma=%p" ));

    //  ---------------------------------------------------------
    //  Based on the VT, calculate ppv, pv, cbskip,
    //  cb, fPostAllocInit, cbCheck, fNullLegal
    //  ---------------------------------------------------------

    // Set the VT in the PropVariant.  Note that in 'pprop' it's a
    // DWORD, but it's a WORD in 'pvar'.

    pvar->vt = (VARTYPE) PropByteSwap(pprop->dwType);

    if( VT_BYREF & pvar->vt )
    {
        // ByRef's are always indirected on their way to the property set.
        // Thus we should never see a VT_BYREF in serialized form.

        StatusError( pstatus, "StgConvertPropertyToVariant found VT_BYREF", 
                     STATUS_INTERNAL_DB_CORRUPTION );
        goto Exit;
    }

    //
    // Switch on the type and set cb, pv, etc.  The information stored in these
    // is subsequently used to do most of the work.  In many cases, we can just do 
    // a copy at the end of the switch, we copy cb bytes from pprop->rgb into the buffer
    // pointed to by pv (which points into the output propvariant).  If an allocation
    // must be done, ppv points to the location in the propvariant that should hold
    // the buffer, so we allocate at buffer at *ppv, then copy cb bytes into it.
    //

    switch( pvar->vt )
    {
        case VT_EMPTY:
        case VT_NULL:
            break;

        case VT_I1:
            //AssertByteField(cVal);          // VT_I1
            cb = sizeof(pvar->cVal);
            pv = &pvar->cVal;
            break;

        case VT_UI1:
            AssertByteField(bVal);          // VT_UI1
            cb = sizeof(pvar->bVal);
            pv = &pvar->bVal;
            break;

        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
            AssertShortField(iVal);         // VT_I2
            AssertShortField(uiVal);        // VT_UI2
            AssertShortField(boolVal);      // VT_BOOL
            cb = sizeof(pvar->iVal);
            pv = &pvar->iVal;

            // If swapping, swap as a WORD
            CBBYTESWAP(cb);
            break;

        case VT_I4:
        case VT_INT:
        case VT_UI4:
        case VT_UINT:
        case VT_R4:
        case VT_ERROR:
            AssertLongField(lVal);          // VT_I4
            //AssertLongField(intVal)       // VT_INT
            AssertLongField(ulVal);         // VT_UI4
            //AssertLongField(uintVal);     // VT_UINT
            AssertLongField(fltVal);        // VT_R4
            AssertLongField(scode);         // VT_ERROR

            cb = sizeof(pvar->lVal);
            pv = &pvar->lVal;

            // If swapping, swap as a DWORD
            CBBYTESWAP(cb);
            break;

        case VT_I8:
        case VT_UI8:
        case VT_FILETIME:
            AssertLongLongField(hVal);          // VT_I8
            AssertLongLongField(uhVal);         // VT_UI8
            AssertLongLongField(filetime);      // VT_FILETIME
            cb = sizeof(pvar->hVal);
            pv = &pvar->hVal;

            // If swapping, swap as a pair of DWORDs
            CBBYTESWAP(sizeof(DWORD));
            break;

        case VT_R8:
        case VT_CY:
        case VT_DATE:
            AssertLongLongField(dblVal);        // VT_R8
            AssertLongLongField(cyVal);         // VT_CY
            AssertLongLongField(date);          // VT_DATE

            cb = sizeof(pvar->dblVal);
            pv = &pvar->dblVal;

            // If swapping, swap as a LONGLONG
            CBBYTESWAP(cb);
            break;

        case VT_CLSID:
            AssertStringField(puuid);           // VT_CLSID

            cb = sizeof(GUID);
            ppv = (VOID **) &pvar->puuid;
            cbskip = 0;

            // If swapping, special handling is required
            CBBYTESWAP( CBBYTESWAP_UID );
            break;

        case VT_DECIMAL:
            //AssertVarField(decVal, sizeof(DECIMAL));  // VT_DECIMAL
            cb = sizeof(DECIMAL);
            pv = (VOID *) &pvar->decVal;

            #ifdef BIGENDIAN
            #error Big-Endian support required
            // Define CBBYTESWAP_DECIMAL, and add support for it below
            //CBBYTESWAP( CBBYTESWAP_DECIMAL );
            #endif
            break;


        case VT_CF:

            // Allocate a CLIPDATA buffer.  Init-zero it so that we can
            // do a safe cleanup should an early-exist be necessary.

            pvar->pclipdata = (CLIPDATA *) pma->Allocate(sizeof(CLIPDATA));
            if (pvar->pclipdata == NULL)
            {
                StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory for CF");
                goto Exit;
            }
            RtlZeroMemory( pvar->pclipdata, sizeof(CLIPDATA) );

            // Set the size (includes sizeof(ulClipFmt))
            pvar->pclipdata->cbSize = PropByteSwap( ((CLIPDATA *) pprop->rgb)->cbSize );
            if( pvar->pclipdata->cbSize < sizeof(pvar->pclipdata->ulClipFmt) )
            {
                StatusError(pstatus, "StgConvertPropertyToVariant:  Invalid VT_CF cbSize",
                            STATUS_INTERNAL_DB_CORRUPTION);
                goto Exit;
            }

            // Set the # bytes-to-copy.  We can't use the CBPCLIPDATA macro
            // here because it assumes that the CLIPDATA parameter is correctly
            // byte-swapped.
            cb = PropByteSwap( *(DWORD*) pprop->rgb ) - sizeof(pvar->pclipdata->ulClipFmt);

            // Set the ClipFormat itself.
            pvar->pclipdata->ulClipFmt = PropByteSwap( ((CLIPDATA *) pprop->rgb)->ulClipFmt );

            // Prepare for the alloc & copy.  Put the buffer pointer
            // in pClipData, & skip the ulClipFmt in the copy.
            ppv = (VOID **) &pvar->pclipdata->pClipData;
            cbskip += sizeof(ULONG);

            // It's legal for cb to be 0.
            fNullLegal = TRUE;

            // Adjust to the user-mode pointer (Kernel only)
            ADJUSTPOINTER(pvar->pclipdata, PointerDelta, CLIPDATA *);

            break;

        case VT_BLOB:
        case VT_BLOB_OBJECT:

            cb = pvar->blob.cbSize = PropByteSwap( *(ULONG *) pprop->rgb );
            ppv = (VOID **) &pvar->blob.pBlobData;
            fNullLegal = TRUE;
            break;

        case VT_VERSIONED_STREAM:

            // Allocate the first buffer (which will point to the stream)

            pvar->pVersionedStream = reinterpret_cast<LPVERSIONEDSTREAM>( pma->Allocate( sizeof(*pvar->pVersionedStream) ));
            if (pvar->pVersionedStream == NULL)
            {
                StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory for VersionedStream");
                goto Exit;
            }
            RtlZeroMemory( pvar->pVersionedStream, sizeof(*pvar->pVersionedStream) );

            // Read the GUID (the PropertyLength function has already
            // validated that the buffer is big enough to read the GUID
            // and counted string.

            pvar->pVersionedStream->guidVersion = *reinterpret_cast<const GUID*>( pprop->rgb );
            PropByteSwap( &pvar->pVersionedStream->guidVersion );

            // A buffer will be allocated and the stream name put into *ppv.
            ppv = reinterpret_cast<void**>( &pvar->pVersionedStream->pStream );

            // Point to the beginning of the string
            pvCountedString = Add2Ptr( pprop->rgb, sizeof(GUID) );

            // When copying the string, we will skip the guid
            cbskip += sizeof(GUID);


            // Fall through

        case VT_STREAM:
        case VT_STREAMED_OBJECT:
        case VT_STORAGE:
        case VT_STORED_OBJECT:
            fIndirect = TRUE;
            goto lpstr;

        case VT_BSTR:
        case VT_LPSTR:
lpstr:
            AssertStringField(pszVal);          // VT_STREAM, VT_STREAMED_OBJECT
            AssertStringField(pszVal);          // VT_STORAGE, VT_STORED_OBJECT
            AssertStringField(bstrVal);         // VT_BSTR
            AssertStringField(pszVal);          // VT_LPSTR

            // The string to be converted is loaded into pvCountedString
            if( NULL == pvCountedString )
                pvCountedString = reinterpret_cast<const void*>(pprop->rgb);

            // [length field] bytes should be allocated
            cb = PropByteSwap( *(ULONG *) pvCountedString );

            // When a buffer is allocated, its pointer will go
            // in *ppv.
            if( NULL == ppv )
                ppv = (VOID **) &pvar->pszVal;

            // Is this a non-empty string?

            if (cb != 0)
            {
                // Yes, non-empty.  If the serialized string is Unicode, ensure
                // that the cb is even

                if( CodePage == CP_WINUNICODE
                    &&
                    0 != (cb % 2) )
                {
                    StatusError(pstatus, "StgConvertPropertyToVariant:  Odd Unicode string cb",
                                STATUS_INTERNAL_DB_CORRUPTION);
                    goto Exit;
                }

                // Also ensure that the string is terminated

                if( CodePage == CP_WINUNICODE )
                {
                    WCHAR *pwsz = (WCHAR *) Add2ConstPtr(pvCountedString, sizeof(ULONG));
                    //if( L'\0' != pwsz[ cb/sizeof(WCHAR) - 1 ] )
                    if( S_OK != StringCbLengthW(pwsz, cb, NULL ))
                    {
                        StatusError(pstatus, "StgConvertPropertyToVariant:  Unterminated string",
                                    STATUS_INTERNAL_DB_CORRUPTION );
                        goto Exit;
                    }
                }
                else
                {
                    CHAR *psz = (CHAR *) Add2ConstPtr(pvCountedString, sizeof(ULONG));
                    //if( '\0' != psz[ cb - 1 ] )
                    if( S_OK != StringCbLengthA(psz, cb, NULL ))
                    {
                        StatusError(pstatus, "StgConvertPropertyToVariant:  Unterminated string",
                                    STATUS_INTERNAL_DB_CORRUPTION );
                        goto Exit;
                    }
                }

                // Is the serialized value one that should be
                // an Ansi string in the PropVariant (if so it might require conversion)?

                if (pvar->vt == VT_LPSTR        // It's an LPSTR (always Ansi), or
                    ||
                    !OLECHAR_IS_UNICODE )       //    PropVariant strings are Ansi (Mac)
                {
                    // If the propset is Unicode, we must do a
                    // conversion to Ansi.

                    if (CodePage == CP_WINUNICODE)
                    {
                        WCHAR *pwsz = (WCHAR *) Add2ConstPtr(pvCountedString, sizeof(ULONG));

                        // If necessary, swap the WCHARs.  'pwsz' will point to
                        // the correct (system-endian) string either way.  If an
                        // alloc is necessary, 'pchByteSwap' will point to the new
                        // buffer.

                        PBSInPlaceAlloc( &pwsz, (WCHAR**) &pchByteSwap, pstatus );
                        if( !NT_SUCCESS( *pstatus )) goto Exit;
                        PROPASSERT(IsUnicodeString( pwsz, cb));

                        // Convert the properly-byte-ordered string in 'pwsz'
                        // into MBCS, putting the result in pchConvert.
                        // This routine will validate that cb is even.

                        PrpConvertToMultiByte(
                                    pwsz,
                                    cb,
                                    CP_ACP,  // Use the system default codepage
                                    &pchConvert,
                                    &cb,
                                    pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    }
                }   // if (pvar->vt == VT_LPSTR) ...

                // Otherwise, even though this string may be
                // Ansi in the Property Set, it must be Unicode
                // in the PropVariant.

                else
                {
                    // If necessary, convert to Unicode

                    if (CodePage != CP_WINUNICODE)
                    {
                        PROPASSERT(
                            IsAnsiString(
                                    (CHAR const *)
                                        Add2ConstPtr(pvCountedString, sizeof(ULONG)),
                                    cb));

                        PrpConvertToUnicode(
                                    (CHAR const *)
                                        Add2ConstPtr(pvCountedString, sizeof(ULONG)),
                                    cb,
                                    CodePage,
                                    (WCHAR **) &pchConvert,
                                    &cb,
                                    pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    }   // if (CodePage != CP_WINUNICODE)
                    else
                    {
                        // The value is Unicode both the property set
                        // and the PropVariant.  If byte-swapping is
                        // necessary, we'll do so in units of WCHARs.

                        CBBYTESWAP( sizeof(WCHAR) );
                    }

                }   // if (pvar->vt == VT_LPSTR) ... else

            }   // if (cb != 0)

            fNullLegal = TRUE;
            break;

        case VT_LPWSTR:

            fNullLegal = TRUE;
            AssertStringField(pwszVal);         // VT_LPWSTR

            // Show where buffer needs to be allocated.

            ppv = (VOID **) &pvar->pwszVal;

            // Calculate the length of the Unicode string.  Put the total number
            // of bytes for this property in cbCheck.

            cb = PropByteSwap( *(ULONG *) pprop->rgb ) * sizeof(WCHAR);

            // Ensure the string is null-terminated.

            if( 0 != cb )
            {
                WCHAR *pwsz = (WCHAR *) Add2ConstPtr(pprop->rgb, sizeof(ULONG));
                //if( L'\0' != pwsz[ cb/sizeof(WCHAR) - 1 ] )
                if( S_OK != StringCbLengthW(pwsz, cb, NULL ))
                {
                    StatusError(pstatus, "StgConvertPropertyToVariant:  Unterminated string",
                                STATUS_INTERNAL_DB_CORRUPTION );
                    goto Exit;
                }
            }

            // If byte-swapping will be necessary, do so for the WCHARs
            CBBYTESWAP( sizeof(WCHAR) );

            break;

        //
        // VT_VECTOR types are handled by a recursive call.
        //

        case VT_VECTOR | VT_I1:
            //AssertByteVector(cac);              // VT_I1

        case VT_VECTOR | VT_UI1:
            AssertByteVector(caub);             // VT_UI1
            pvar->caub.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
            cb = pvar->caub.cElems * sizeof(pvar->caub.pElems[0]);
            ppv = (VOID **) &pvar->caub.pElems;

            break;

        case VT_VECTOR | VT_I2:
        case VT_VECTOR | VT_UI2:
        case VT_VECTOR | VT_BOOL:
            AssertShortVector(cai);             // VT_I2
            AssertShortVector(caui);            // VT_UI2
            AssertShortVector(cabool);          // VT_BOOL

            pvar->cai.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
            cb = pvar->cai.cElems * sizeof(pvar->cai.pElems[0]);
            ppv = (VOID **) &pvar->cai.pElems;

            // If swapping, swap as a WORD
            CBBYTESWAP(sizeof(pvar->cai.pElems[0]));
            break;

        case VT_VECTOR | VT_I4:
        case VT_VECTOR | VT_UI4:
        case VT_VECTOR | VT_R4:
        case VT_VECTOR | VT_ERROR:
            AssertLongVector(cal);              // VT_I4
            AssertLongVector(caul);             // VT_UI4
            AssertLongVector(caflt);            // VT_R4
            AssertLongVector(cascode);          // VT_ERROR

            pvar->cal.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
            cb = pvar->cal.cElems * sizeof(pvar->cal.pElems[0]);
            ppv = (VOID **) &pvar->cal.pElems;

            // If byte swapping, swap as DWORDs
            CBBYTESWAP(sizeof(pvar->cal.pElems[0]));
            break;

        case VT_VECTOR | VT_I8:
        case VT_VECTOR | VT_UI8:
        case VT_VECTOR | VT_FILETIME:
            AssertLongLongVector(cah);          // VT_I8
            AssertLongLongVector(cauh);         // VT_UI8
            AssertLongLongVector(cafiletime);   // VT_FILETIME

            pvar->cah.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
            cb = pvar->cah.cElems * sizeof(pvar->cah.pElems[0]);
            ppv = (VOID **) &pvar->cah.pElems;

            // If byte swapping, swap as DWORDs
            CBBYTESWAP(sizeof(DWORD));
            break;

        case VT_VECTOR | VT_R8:
        case VT_VECTOR | VT_CY:
        case VT_VECTOR | VT_DATE:
            AssertLongLongVector(cadbl);        // VT_R8
            AssertLongLongVector(cacy);         // VT_CY
            AssertLongLongVector(cadate);       // VT_DATE

            pvar->cadbl.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
            cb = pvar->cadbl.cElems * sizeof(pvar->cadbl.pElems[0]);
            ppv = (VOID **) &pvar->cadbl.pElems;

            // If byte swapping, swap as LONGLONGs
            CBBYTESWAP(sizeof(pvar->cadbl.pElems[0]));
            break;


        case VT_VECTOR | VT_CLSID:
            AssertVarVector(cauuid, sizeof(GUID));
            pvar->cauuid.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
            cb = pvar->cauuid.cElems * sizeof(pvar->cauuid.pElems[0]);
            ppv = (VOID **) &pvar->cauuid.pElems;

            // If byte swapping, special handling is required.
            CBBYTESWAP( CBBYTESWAP_UID );
            break;

        case VT_VECTOR | VT_CF:

            // Set the count of clipdatas
            pvar->caclipdata.cElems = PropByteSwap( *(ULONG *) pprop->rgb );

            // How much should we allocate for caclipdata.pElems, & where
            // should that buffer pointer go?
            cb = pvar->caclipdata.cElems * sizeof(pvar->caclipdata.pElems[0]);
            ppv = (VOID **) &pvar->caclipdata.pElems;

            // We need to do work after pElems is allocated.
            fPostAllocInit = TRUE;
            break;

        case VT_VECTOR | VT_BSTR:
        case VT_VECTOR | VT_LPSTR:
            AssertStringVector(cabstr);     // VT_BSTR
            AssertStringVector(calpstr);    // VT_LPSTR

            // Put the element count in the PropVar
            pvar->calpstr.cElems = PropByteSwap( *(ULONG *) pprop->rgb );

            // An array of cElems pointers should be alloced
            cb = pvar->calpstr.cElems * sizeof(CHAR*);

            // Show where the array of pointers should go.
            ppv = (VOID **) &pvar->calpstr.pElems;

            // Additional allocs will be necessary after the vector
            // is alloced.
            fPostAllocInit = TRUE;

            break;

        case VT_VECTOR | VT_LPWSTR:

            AssertStringVector(calpwstr);       // VT_LPWSTR
            pvar->calpwstr.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
            cb = pvar->calpwstr.cElems * sizeof(WCHAR *);
            ppv = (VOID **) &pvar->calpwstr.pElems;
            fPostAllocInit = TRUE;
            break;

        case VT_VECTOR | VT_VARIANT:

            AssertVariantVector(capropvar);     // VT_VARIANT
            pvar->capropvar.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
            cb = pvar->capropvar.cElems * sizeof(PROPVARIANT);
            ppv = (VOID **) &pvar->capropvar.pElems;
            fPostAllocInit = TRUE;
            break;

        //
        // VT_ARRAY (SafeArray) types are handled by a recursive call
        //

        case VT_ARRAY | VT_BSTR:
            cbskip = 0;
            cb = sizeof(BSTR); // (BSTR is really a pointer)
            ppv = (VOID**) &pvar->parray;
            fPostAllocInit = TRUE;
            break;
        
        case VT_ARRAY | VT_VARIANT:
            cbskip = 0;
            cb = sizeof(PROPVARIANT);
            ppv = (VOID**) &pvar->parray;
            fPostAllocInit = TRUE;
            break;

        case VT_ARRAY | VT_I1:
        case VT_ARRAY | VT_UI1:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(BYTE);
            break;

        case VT_ARRAY | VT_I2:
        case VT_ARRAY | VT_UI2:
        case VT_ARRAY | VT_BOOL:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(USHORT);
            break;

        case VT_ARRAY | VT_I4:
        case VT_ARRAY | VT_UI4:
        case VT_ARRAY | VT_INT:
        case VT_ARRAY | VT_UINT:
        case VT_ARRAY | VT_R4:
        case VT_ARRAY | VT_ERROR:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(ULONG);
            break;

        case VT_ARRAY | VT_DECIMAL:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(DECIMAL);
            break;

        /*
        case VT_ARRAY | VT_I8:
        case VT_ARRAY | VT_UI8:
        */
        case VT_ARRAY | VT_DATE:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(ULONGLONG);

            // If byte swapping, swap as DWORDs
            CBBYTESWAP(DWORD);

            break;

        case VT_ARRAY | VT_R8:
        case VT_ARRAY | VT_CY:
            cbskip = 0;
            ppv = (VOID**) &pvar->parray;
            cb = sizeof(CY);

            // If byte swapping, swap as LONGLONGs
            CBBYTESWAP(cb);

            break;

        default:
            propDbg(( DEB_IWARN, "StgConvertPropertyToVariant: unsupported vt=%d\n", pvar->vt ));
            *pstatus = STATUS_NOT_SUPPORTED;
            goto Exit;

    }   // switch (pvar->vt)

    //  ------------------------------------------------------
    //  We've now analyzed the serialized property, learned
    //  about it, and loaded part or all of the PropVariant.
    //  Now we can load any remaining parts.
    //  ------------------------------------------------------

    // Is this a simple, unaligned scalar?

    if (pv != NULL)
    {
        // Yes.  All we need to do is copy some bytes.

        PROPASSERT(pchConvert == NULL);
        PROPASSERT( cb < sizeof(PROPVARIANT)-sizeof(VARTYPE)
                    ||
                    VT_DECIMAL == pprop->dwType );

        // Copy from the pprop into the PropVariant

        RtlCopyMemory(pv, pprop->rgb, cb);

        // We also might need to byte-swap them (but only in the PropVar).
        PBSBuffer( pv, cb, cbByteSwap );

        // Decimal requires special handling, since it overlaps the VT field.
        if( VT_DECIMAL == PropByteSwap(pprop->dwType) )
            pvar->vt = VT_DECIMAL;

    } // if (pv != NULL)

    // Otherwise, we need to allocate memory, to which the
    // PropVariant will point.

    else if (ppv != NULL)
    {
        *ppv = NULL;

        // If cb is zero, then there's nothing to allocate anyway.

        if( cb == 0 )
        {
            // Make sure it's legal for this type to be NULL.

            if (!fNullLegal)
            {
                StatusInvalidParameter(pstatus, "StgConvertPropertyToVariant: bad NULL");
                goto Exit;
            }
        }

        else
        {
            // We need to allocate something.

            SAFEARRAYBOUND *rgsaBounds = NULL;
            ULONG cElems = 0, cbBounds = 0;

            PROPASSERT(cb != 0);

            // Allocate the necessary buffer (which we figured out in the
            // switch above).  For vector properties,  this will just be the
            // pElems buffer at this point.  For singleton BSTR properties, we'll skip
            // this allocate altogether; they're allocated by oleaut with SysStringAlloc.
            // For array properties, we'll allocate the safearray and the buffer that
            // it will reference.

            if( VT_ARRAY & pvar->vt )
            {
                // This is a SafeArray.  We need to use oleaut to allocate the SafeArray
                // structure.

                VARTYPE vtInternal; // The VT as determined by the SafeArray
                UINT cDims = 0;

                // Read the SafeArray's internal VT
                // (PropertyLength guarantees us that we can read the VT,
                // cDims, and bounds).

                vtInternal = *(VARTYPE*) &pprop->rgb[cbskip];
                cbskip += sizeof(ULONG);

                // Read the dimension count
                cDims = *(ULONG*) &pprop->rgb[cbskip];
                cbskip += sizeof(DWORD);

                // Point to the SAFEARRAYBOUND array
                rgsaBounds = (SAFEARRAYBOUND*) &pprop->rgb[cbskip];

                // We now have everything we need to create a new safe array

                psa = PrivSafeArrayCreateEx( vtInternal, cDims, rgsaBounds, NULL );
                if( NULL == psa )
                {
                    propDbg(( DEB_ERROR, "Failed SafeArrayCreateEx, vt=0x%x, cDims=%d\n",
                              vtInternal, cDims ));
                    *pstatus = STATUS_NO_MEMORY;
                    goto Exit;
                }
                cbskip += cDims * sizeof(SAFEARRAYBOUND);

                // Calculate the number of elements in the safearray.

                PROPASSERT( cb == psa->cbElements );
                *pstatus = SerializeSafeArrayBounds( psa, NULL, &cbBounds, &cElems );
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                // In the big switch above, cb was set to the single element size.
                // Now update it to be the total element size.

                cb *= cElems;

                // Put this SafeArray into pvar->parray
                *ppv = psa;

                // Get the newly-created psa->pvData
                *pstatus = PrivSafeArrayAccessData( psa, &pvSafeArrayData );
                if( FAILED(*pstatus) ) goto Exit;
                fSafeArrayLocked = TRUE;

                // Point ppv to it - we'll copy the data from the serialized
                // format to here.

                ppv = &pvSafeArrayData;
                PROPASSERT( NULL != ppv && psa != *ppv );

            } // if( VT_ARRAY & pvar->vt )

            else if( VT_BSTR != pvar->vt  )
            {
                // Array was handled in the if above, BSTRs are handled below
                // (simultaneous with the copy), so this else if block is for
                // everything else - i.e. simple allocs.

                *ppv = pma->Allocate(max(1, cb));
                if (*ppv == NULL)
                {
                    StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory");
                    goto Exit;
                }
            }   // if( VT_ARRAY & pvar->vt ) ... else if( VT_BSTR != pvar->vt  )


            // We've got memory allocated now.
            // Can we load the PropVariant with a simple copy?

            if( !fPostAllocInit )
            {
                // Yes - all we need is a memcopy (and an implicit alloc for BSTRs).

                if (VT_BSTR == pvar->vt)
                {
                    // We do the copy with the OleAutomation routine
                    // (which does an allocation too).
                    //
                    // If byte-swapping is necessary, the switch block
                    // already took care of it, leaving the buffer in
                    // 'pchConvert'.
                    // 
                    // We already validated that the string is properly terminated.

                    // Now do the alloc/copy

                    PROPASSERT( NULL == *ppv );
                    *ppv = PrivSysAllocString( ( pchConvert != NULL )
                                                ? (OLECHAR *) pchConvert
                                                : (OLECHAR *) (pprop->rgb + cbskip) );
                    if (*ppv == NULL)
                    {
                        StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory");
                        goto Exit;
                    }
                }   // if (VT_BSTR == pvar->vt)

                else
                {
                    // Copy the property into the PropVariant.

                    RtlCopyMemory(
                            *ppv,
                            pchConvert != NULL?
                                (BYTE const *) pchConvert : pprop->rgb + cbskip,
                            cb);

                }

                // If necessary, byte-swap the property (only in the PropVar).
                PBSBuffer( *ppv, cb, cbByteSwap );

            }   // if (!fPostAllocInit)

            else
            {
                // We must do more than just a simple copy.
                // (Thus this is a vector/array of strings, variants, or CFs).

                // Pointer to the correct location in pprop->rgb
                BYTE const *pbsrc;

                // Point pbsrc to the actual data (i.e. beyond the counts).  For
                // vectors, put the element count in cElems.

                if( VT_VECTOR & pvar->vt )
                {
                    // Get the element count
                    cElems = pvar->calpstr.cElems;

                    // Initialize the source pointer to point just beyond
                    // the element count.

                    pbsrc = pprop->rgb + sizeof(ULONG);
                }
                else
                {   
                    PROPASSERT( VT_ARRAY & pvar->vt );
                    PROPASSERT( 0 != cElems );

                    // Initialize the source pointer to point just beyond the VT, cDims, and bounds
                    pbsrc = pprop->rgb + cbBounds + sizeof(DWORD) + sizeof(UINT);
                }

                // Zero all pointers in the pElems array for easy caller cleanup
                // (cb is the size of the array of pointers)

                ppv = (VOID **) *ppv;
                RtlZeroMemory(ppv, cb);

                // Handle Variants, ClipFormats, & Strings separately.

                if( (VT_VECTOR | VT_VARIANT) == pvar->vt
                    ||
                    (VT_ARRAY  | VT_VARIANT) == pvar->vt )
                {
                    // This is an array or vector of variants

                    PROPVARIANT *pvarT = (PROPVARIANT *) ppv;
                    PROPASSERT(!fIndirect);

                    // Loop through the variants.

                    while (cElems-- > 0)
                    {
                        ULONG cbelement;

                        // Get this variant into pvarT (which is really part of
                        // the pvar->capropvar->pElems).

                        fIndirect = StgConvertPropertyToVariantNoEH(
                                        (SERIALIZEDPROPERTYVALUE const *) pbsrc,
                                        cbprop - (ULONG)((UINT_PTR)pbsrc - (UINT_PTR)pprop),
                                        CodePage,
                                        pvarT,
                                        pma,
                                        pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                        PROPASSERT(!fIndirect);

                        // Calculate this size of this serialized element.

                        cbelement = PropertyLengthNoEH(
                                        (SERIALIZEDPROPERTYVALUE const *) pbsrc,
                                        cbprop - (ULONG)((UINT_PTR)pbsrc - (UINT_PTR)pprop),
                                        CPSS_VARIANTVECTOR,
                                        pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // Advance pbsrc by that size, and advance pvarT to the
                        // next element in pvar->capropvar->pElems.

                        pbsrc += cbelement;
                        pvarT++;
                    }
                }   // if (pvar->vt == (VT_VECTOR | VT_VARIANT) ... )

                else if (pvar->vt == (VT_VECTOR | VT_CF))
                {
                    // Handle vectors of clipformats.

                    // Set pcd to &pElems[0]
                    CLIPDATA *pcd = (CLIPDATA *) ppv;

                    // Loop through pElems
                    while (cElems-- > 0)
                    {
                        // What is the size of the clipdata (including sizeof(ulClipFmt))?
                        pcd->cbSize = PropByteSwap( ((CLIPDATA *) pbsrc)->cbSize );
                        if( pcd->cbSize < sizeof(pcd->ulClipFmt) )
                        {
                            StatusError(pstatus, "StgConvertPropertyToVariant:  Invalid VT_CF cbSize",
                                        STATUS_INTERNAL_DB_CORRUPTION);
                            goto Exit;
                        }

                        // How many bytes should we copy to pClipData?
                        cb = CBPCLIPDATA( *pcd );

                        // Set the ClipFormat & advance pbsrc to the clipdata.
                        pcd->ulClipFmt = PropByteSwap( ((CLIPDATA *) pbsrc)->ulClipFmt );

                        pbsrc += 2 * sizeof(ULONG);

                        // Copy the ClipData into the PropVariant

                        pcd->pClipData = NULL;
                        if (cb > 0)
                        {
                            // Get a buffer for the clip data.
                            pcd->pClipData = (BYTE *) pma->Allocate(cb);
                            if (pcd->pClipData == NULL)
                            {
                                StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory for CF[]");
                                goto Exit;
                            }

                            // Copy the clipdata into pElems[i].pClipData

                            RtlCopyMemory(pcd->pClipData, pbsrc, cb);
                            ADJUSTPOINTER(pcd->pClipData, PointerDelta, BYTE *);

                        }   // if (cb > 0)

                        // Move pcd to &pElems[i+1], and advance the buffer pointer.
                        pcd++;
                        pbsrc += DwordAlign(cb);

                    }   // while (cElems-- > 0)
                }   // else if (pvar->vt == (VT_VECTOR | VT_CF))

                else
                {
                    // This is a vector or array of some kind of string.

                    // Assume that characters are CHARs
                    ULONG cbch = sizeof(char);

                    if( pvar->vt == (VT_VECTOR | VT_LPWSTR) )
                    {
                        // Characters are actually WCHARs
                        cbch = sizeof(WCHAR);

                        // If byte-swapping is enabled, LPWSTRs must have
                        // their WCHARs swapped.
                        CBBYTESWAP( sizeof(WCHAR) );
                    }

                    // Loop through the array

                    while (cElems-- > 0)
                    {
                        ULONG cbcopy;

                        // Read the cb from the front of the property, and advance
                        // pbsrc beyond that length field.

                        cbcopy = cb = PropByteSwap( *((ULONG *) pbsrc) ) * cbch;
                        pbsrc += sizeof(ULONG);
                        pv = (VOID *) pbsrc;

                        PROPASSERT(*ppv == NULL);
                        PROPASSERT(pchConvert == NULL);

                        // Do we have actual data to work with?
                        if( cb != 0 )
                        {
                            // Validate that the string is null terminated

                            if( CP_WINUNICODE == CodePage
                                  //&& L'\0' != ((WCHAR*)pv)[ (cb-1) / sizeof(WCHAR) ]
                                  && S_OK != StringCbLengthW((WCHAR*)pv, cb, NULL )
                                ||
                                CP_WINUNICODE != CodePage
                                  //&& '\0' != ((CHAR*)pv)[ cb-1 ]
                                  && S_OK != StringCbLengthA((CHAR*)pv, cb, NULL )
                              )
                            {
                                StatusError(pstatus, "String element missing null termination",
                                            STATUS_INTERNAL_DB_CORRUPTION );
                                goto Exit;
                            }

                            // Special BSTR pre-processing ... it might be
                            // necessary to do a unicode/ansi conversion.

                            if( (VT_VECTOR | VT_BSTR) == pvar->vt
                                ||
                                (VT_ARRAY  | VT_BSTR) == pvar->vt )
                            {
                                // If the propset & in-memory BSTRs are of
                                // different Unicode-ness, convert now.

                                if (CodePage != CP_WINUNICODE   // Ansi PropSet
                                    &&
                                    OLECHAR_IS_UNICODE )        // Unicode BSTRs
                                {

                                    PROPASSERT(IsAnsiString((CHAR*) pv, cb));
                                    PrpConvertToUnicode(
                                                (CHAR const *) pv,
                                                cb,
                                                CodePage,
                                                (WCHAR **) &pchConvert,
                                                &cbcopy,
                                                pstatus);
                                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
                                    pv = pchConvert;
                                }

                                else
                                if (CodePage == CP_WINUNICODE   // Unicode PropSet
                                    &&
                                    !OLECHAR_IS_UNICODE )       // Ansi BSTRs
                                {
                                    // If byte-swapping is necessary, the string from
                                    // the propset must be swapped before it can be
                                    // converted to MBCS.  If such a conversion
                                    // is necessary, a new buffer is alloced and 
                                    // put in pchByteSwap.  Either way, 'pv' points
                                    // to the correct string.

                                    PBSInPlaceAlloc( (WCHAR**) &pv,
                                                        (WCHAR**) &pchByteSwap,
                                                        pstatus );
                                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
                                    PROPASSERT(IsUnicodeString((WCHAR*)pv, cb));

                                    // Convert the Unicode string from the property
                                    // set to Ansi.

                                    PrpConvertToMultiByte(
                                                (WCHAR const *) pv,
                                                cb,
                                                CP_ACP,  // Use the system default codepage
                                                &pchConvert,
                                                &cbcopy,
                                                pstatus);
                                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                    // 'pv' always has the correct string.
                                    pv = pchConvert;
                                }
                                else
                                if (CodePage == CP_WINUNICODE)
                                {
                                    // Both the BSTR is unicode in the property set,
                                    // and must remain unicode in the PropVariant.
                                    // But byte-swapping may still be necessary.

                                    CBBYTESWAP( sizeof(WCHAR) );
                                }
                                                        

#ifdef LITTLEENDIAN
                                PROPASSERT( IsOLECHARString((BSTR)pv, cbcopy ));
#endif
                            }   // if( (VT_VECTOR | VT_BSTR) == pvar->vt ...

                            // Special LPSTR pre-processing ... again, we might
                            // need to do a unicode/ansi conversion.

                            else if (pvar->vt == (VT_VECTOR | VT_LPSTR))
                            {
                                // LPSTRs are always Ansi.  If the string
                                // is Unicode in the propset, convert now.

                                if (CodePage == CP_WINUNICODE)
                                {
                                    // If byte-swapping is necessary, the string from
                                    // the propset must be swapped before it can be
                                    // converted to MBCS.  If such a conversion
                                    // is necessary, a new buffer is alloced and 
                                    // put in pchByteSwap.  Either way, 'pv' points
                                    // to the correct string.

                                    PBSInPlaceAlloc( (WCHAR**) &pv, (WCHAR**) &pchByteSwap,
                                                    pstatus );
                                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
                                    PROPASSERT(IsUnicodeString((WCHAR*)pv, cb));

                                    // Convert to Ansi.
                                    PrpConvertToMultiByte(
                                                (WCHAR const *) pv,
                                                cb,
                                                CP_ACP,     // Use the system default codepage
                                                &pchConvert,
                                                &cbcopy,
                                                pstatus);
                                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                    pv = pchConvert;
                                }

                                PROPASSERT( IsAnsiString( (CHAR const *)pv, cbcopy ));
                            }   // else if (pvar->vt == (VT_VECTOR | VT_LPSTR))

                            // Allocate memory in the PropVariant and copy
                            // the string.

                            if( (VT_BSTR | VT_VECTOR) == pvar->vt
                                ||
                                (VT_BSTR | VT_ARRAY)  == pvar->vt )
                            {

                                // For BSTRs, the allocate/copy is performed
                                // by SysStringAlloc.  We've already verified
                                // that the string pointed to by pv is properly
                                // terminated.

                                *ppv = PrivSysAllocString( (BSTR) pv );
                                if (*ppv == NULL)
                                {
                                    StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory for BSTR element");
                                    goto Exit;
                                }

                                // The BSTR length should be the property length
                                // minus the NULL.
                                PROPASSERT( BSTRLEN(*ppv) == cbcopy - sizeof(OLECHAR) );

                            }   // if( VT_BSTR == pvar->vt )

                            else
                            {
                                // For everything that's not a BSTR,
                                // Allocate a buffer in the PropVariant

                                *ppv = pma->Allocate(max(1, cbcopy));
                                if (*ppv == NULL)
                                {
                                    StatusKBufferOverflow(pstatus, "StgConvertPropertyToVariant: no memory for string element");
                                    goto Exit;
                                }

                                // And then copy from the propset buffer to the PropVariant
                                RtlCopyMemory(*ppv, pv, cbcopy);

                            }   // if( VT_BSTR == pvar->vt ) ... else

                            // If necessary, byte-swap in the PropVariant to get
                            // the proper byte-ordering.
                            PBSBuffer( *ppv, cbcopy, cbByteSwap );

                            // Adjust the PropVar element ptr to user-space (kernel only)
                            ADJUSTPOINTER(*ppv, PointerDelta, VOID *);

                            // Move, within the propset buffer, to the
                            // next element in the vector.

                            pbsrc += DwordAlign(cb);

                            // Delete the temporary buffers

                            CoTaskMemFree( pchByteSwap );
                            pchByteSwap = NULL;

                            CoTaskMemFree( pchConvert );
                            pchConvert = NULL;

                        }   // if (cb != 0)

                        // Move, within the PropVariant, to the next
                        // element in the vector.
                        ppv++;

                    }   // while (cElems-- > 0)
                }   // else if (pvar->vt == (VT_VECTOR | VT_CF)) ... else

            }   // if (!fPostAllocInit) ... else

            ADJUSTPOINTER(*ppvK, PointerDelta, VOID *);

        }   // if (cb == 0) ... else
    }   // if (pv != NULL) ... else if (ppv != NULL)

Exit:

    if( fSafeArrayLocked )
    {
        PROPASSERT( NULL != pvSafeArrayData );
        PrivSafeArrayUnaccessData( psa );
    }

    CoTaskMemFree( pchByteSwap );
    CoTaskMemFree( pchConvert );

    return(fIndirect);
}




//+---------------------------------------------------------------------------
// Function:    CleanupVariants, private
//
// Synopsis:    Free all memory used by an array of PROPVARIANT
//
// Arguments:   [pvar]          -- pointer to PROPVARIANT
//              [cprop]         -- property count
//              [pma]           -- caller's memory free routine
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CleanupVariants(
    IN PROPVARIANT *pvar,
    IN ULONG cprop,
    IN PMemoryAllocator *pma)
{
    // We can get null if we're called recursively (for a vector),
    // and the vector property never got fully set up (i.e. the
    // second buffer never got allocated).

    if( NULL == pvar )
        return;

    while (cprop-- > 0)
    {
        VOID *pv = NULL;
        VOID **ppv = NULL;
        ULONG cElems = 0;

        switch (pvar->vt)
        {
        case VT_CF:
            pv = pvar->pclipdata;
            if (pv != NULL && pvar->pclipdata->pClipData)
            {
                pma->Free(pvar->pclipdata->pClipData);
            }
            break;

        case VT_VERSIONED_STREAM:
            pv = pvar->pVersionedStream;
            if( NULL != pv && NULL != pvar->pVersionedStream->pStream )
            {
                pma->Free(pvar->pVersionedStream->pStream);
            }
            break;

        case VT_BLOB:
        case VT_BLOB_OBJECT:
            pv = pvar->blob.pBlobData;
            break;

        case VT_BSTR:
        case VT_CLSID:
        case VT_STREAM:
        case VT_STREAMED_OBJECT:
        case VT_STORAGE:
        case VT_STORED_OBJECT:
        case VT_LPSTR:
        case VT_LPWSTR:
            AssertStringField(puuid);           // VT_CLSID
            AssertStringField(pszVal);          // VT_STREAM, VT_STREAMED_OBJECT
            AssertStringField(pszVal);          // VT_STORAGE, VT_STORED_OBJECT
            AssertStringField(bstrVal);         // VT_BSTR
            AssertStringField(pszVal);          // VT_LPSTR
            AssertStringField(pwszVal);         // VT_LPWSTR
            pv = pvar->pszVal;
            break;

        // Vector properties:

        case VT_VECTOR | VT_I1:
        case VT_VECTOR | VT_UI1:
        case VT_VECTOR | VT_I2:
        case VT_VECTOR | VT_UI2:
        case VT_VECTOR | VT_BOOL:
        case VT_VECTOR | VT_I4:
        case VT_VECTOR | VT_UI4:
        case VT_VECTOR | VT_R4:
        case VT_VECTOR | VT_ERROR:
        case VT_VECTOR | VT_I8:
        case VT_VECTOR | VT_UI8:
        case VT_VECTOR | VT_R8:
        case VT_VECTOR | VT_CY:
        case VT_VECTOR | VT_DATE:
        case VT_VECTOR | VT_FILETIME:
        case VT_VECTOR | VT_CLSID:
            AssertByteVector(cac);                      // VT_I1
            AssertByteVector(caub);                     // VT_UI1
            AssertShortVector(cai);                     // VT_I2
            AssertShortVector(caui);                    // VT_UI2
            AssertShortVector(cabool);                  // VT_BOOL
            AssertLongVector(cal);                      // VT_I4
            AssertLongVector(caul);                     // VT_UI4
            AssertLongVector(caflt);                    // VT_R4
            AssertLongVector(cascode);                  // VT_ERROR
            AssertLongLongVector(cah);                  // VT_I8
            AssertLongLongVector(cauh);                 // VT_UI8
            AssertLongLongVector(cadbl);                // VT_R8
            AssertLongLongVector(cacy);                 // VT_CY
            AssertLongLongVector(cadate);               // VT_DATE
            AssertLongLongVector(cafiletime);           // VT_FILETIME
            AssertVarVector(cauuid, sizeof(GUID));      // VT_CLSID
            pv = pvar->cai.pElems;
            break;

        case VT_VECTOR | VT_CF:
            {
                CLIPDATA *pcd;

                cElems = pvar->caclipdata.cElems;
                pv = pcd = pvar->caclipdata.pElems;
                while (cElems-- > 0)
                {
                    if (pcd->pClipData != NULL)
                    {
                        pma->Free(pcd->pClipData);
                    }
                    pcd++;
                }
            }
            break;

        case VT_VECTOR | VT_BSTR:
        case VT_VECTOR | VT_LPSTR:
        case VT_VECTOR | VT_LPWSTR:
            AssertStringVector(cabstr);                 // VT_BSTR
            AssertStringVector(calpstr);                // VT_LPSTR
            AssertStringVector(calpwstr);               // VT_LPWSTR
            cElems = pvar->calpstr.cElems;
            ppv = (VOID **) pvar->calpstr.pElems;
            break;

        case VT_VECTOR | VT_VARIANT:
            CleanupVariants(
                    pvar->capropvar.pElems,
                    pvar->capropvar.cElems,
                    pma);
            pv = pvar->capropvar.pElems;
            break;

        }   // switch (pvar->vt)

        if (ppv != NULL)                        // STRING VECTOR property
        {
            // Save the vector of pointers
            pv = (VOID *) ppv;

            // Free the vector elements
            while (cElems-- > 0)
            {
                if (*ppv != NULL)
                {
                    if( (VT_BSTR | VT_VECTOR) == pvar->vt )
                    {
                        PrivSysFreeString( (BSTR) *ppv );
                    }
                    else
                    {
                        pma->Free((BYTE *) *ppv);
                    }
                }
                ppv++;
            }

            // Free the vector of pointers.
            pma->Free(pv);
            pv = NULL;

        }   // if (ppv != NULL)

        if (pv != NULL)
        {
            if( VT_BSTR == pvar->vt )
            {
                PrivSysFreeString( (BSTR) pv );
            }
            else
            {
                pma->Free((BYTE *) pv);
            }
        }

        pvar->vt = VT_EMPTY;

        // Move on to the next PropVar in the vector.
        pvar++;

    }   // while (cprop-- > 0)
}


//+--------------------------------------------------------------------------
// Function:    PropertyLength
//
// Synopsis:    compute the length of a property including the variant type
//
// Arguments:   [pprop]         -- property value
//              [cbbuf]         -- max length of accessible memory at pprop
//              [flags]         -- CPropertySetStream flags
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     length of property
//---------------------------------------------------------------------------


// First, define a wrapper for this function which returns errors
// using NT Exception Handling, rather than returning an NTSTATUS.

#if defined(WINNT) && !defined(IPROPERTY_DLL)

ULONG
PropertyLength(
    SERIALIZEDPROPERTYVALUE const *pprop,
    ULONG cbbuf,
    BYTE flags)
{
    NTSTATUS status;
    ULONG ulRet;
    
    ulRet = PropertyLengthNoEH( pprop, cbbuf, flags, &status );
    
    if (!NT_SUCCESS( status ))
        RtlRaiseStatus( status );

    return( ulRet );
}

#endif // #if defined(WINNT) && !defined(IPROPERTY_DLL)


// Now define the body of the function, returning errors with an
// NTSTATUS value instead of raising.

ULONG
PropertyLengthNoEH(
    SERIALIZEDPROPERTYVALUE const *pprop,
    ULONG cbbuf,
    BYTE flags,
    OUT NTSTATUS *pstatus)
{
    ULONG const *pl = (ULONG const *) pprop->rgb;
    ULONG cElems = 1;
    ULONG cSafeArrayDimensions = 1;
    ULONG cbremain = cbbuf;
    ULONG cb = 0, cbch;
    BOOLEAN fIllegalType = FALSE;
    const SAFEARRAYBOUND *rgsaBounds = NULL;
    ULONG vt;

    *pstatus = STATUS_SUCCESS;

    // Can we read the VT?
    if (cbremain < CB_SERIALIZEDPROPERTYVALUE)
    {
        StatusOverflow(pstatus, "PropertyLength: dwType");
        goto Exit;
    }

    // Get the VT
    vt = PropByteSwap( pprop->dwType );
    cbremain -= CB_SERIALIZEDPROPERTYVALUE;
    PROPASSERT( sizeof(pprop->dwType) == CB_SERIALIZEDPROPERTYVALUE );

    // If this is a vector or array, get the element count

    if( VT_VECTOR & vt )
    {
        // It's a vector.

        // Can we read the element count?
        if (cbremain < sizeof(ULONG))
        {
            StatusOverflow(pstatus, "PropertyLength: cElems");
            goto Exit;
        }

        // Get the element count
        cElems = PropByteSwap( *pl++ );
        cbremain -= sizeof(ULONG);
    }
    else if( VT_ARRAY & vt )
    {
        // It's an array

        ULONG cbBounds = 0;

        // Can we read the element VT and dimension count?
        // (This VT is for the members of the array, as opposed
        // to the VT_ARRAY in pprop->dwType).

        if( sizeof(DWORD) + sizeof(UINT) > cbremain )
        {
            StatusOverflow(pstatus, "PropertyLength:  vt/cDims" );
            goto Exit;
        }

        // Read the SafeArray's VT (so we'll now ignore pprop->dwType)
        vt = VT_ARRAY | PropByteSwap( *pl++ );
        PROPASSERT( sizeof(DWORD) == sizeof(*pl) );

        // Read the dimension count
        cSafeArrayDimensions = PropByteSwap( *pl++ );
        PROPASSERT( sizeof(DWORD) == sizeof(*pl) );

        // Update the remaining count to be the bytes after the vt/count
        cbremain -= sizeof(DWORD) + sizeof(UINT);

        // Can we read the bounds?
        cbBounds = sizeof(SAFEARRAYBOUND) * cSafeArrayDimensions;
        if( cbBounds > cbremain )
        {
            StatusOverflow(pstatus, "PropertyLength:  safearray bounds" );
            goto Exit;
        }

        // Get the bounds (point to them directly in the pprop)

        cbremain -= cbBounds;
        rgsaBounds = reinterpret_cast<const SAFEARRAYBOUND *>(pl);
        pl = static_cast<const ULONG*>(Add2ConstPtr( pl, cbBounds ));

        // Finally, calc the element count
        cElems = CalcSafeArrayElements( cSafeArrayDimensions, rgsaBounds );
    }

    // Is this a vector/array of variants?  If so, we need to make recursive
    // calls to size the elements.

    if( (VT_VECTOR | VT_VARIANT) == vt
        ||
        (VT_ARRAY  | VT_VARIANT) == vt )
    {
        while (cElems-- > 0)
        {
            cb = PropertyLengthNoEH(
                        (SERIALIZEDPROPERTYVALUE const *) pl,
                        cbremain,
                        flags | CPSS_VARIANTVECTOR,
                        pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            pl = (ULONG const *) Add2ConstPtr(pl, cb);
            cbremain -= cb;
        }
    }

    // Otherwise (it's not a vector/array), we have to look at each
    // type individually.

    else
    {
        // Assume that characters are Unicode
        // (we'll update this if it's not true).

        cbch = sizeof(WCHAR);

        // Switch over the raw type (i.e., mask out vt_vector, vt_array, etc.)
        // We won't see VT_VARIANT here because we handled it in the if above.
        // If we're in a recursive call, CPSS_VARIANTVECTOR will be true, and
        // consequently certain types will be illegal (such as VT_NULL - you can't
        // have this type in a vector|variant).  Mostly, this switch updates
        // pl to point just beyond the data - the total size in the end will be
        // the delta between this and pprop.  Note that we don't actually try
        // to dereference pl, because it may be pointing off the end of the buffer
        // (i.e., we don't check cbremain during the switch).

        switch( VT_TYPEMASK & vt )
        {
        case VT_EMPTY:
        case VT_NULL:
            fIllegalType = (flags & CPSS_VARIANTVECTOR) != 0;
            break;

        case VT_I1:
        case VT_UI1:
            pl = (ULONG const *) Add2ConstPtr(pl, DwordAlign(cElems * sizeof(BYTE)));
            break;

        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
            pl = (ULONG const *) Add2ConstPtr(pl, DwordAlign(cElems * sizeof(USHORT)));
            break;

        case VT_I4:
        case VT_INT:
        case VT_UI4:
        case VT_UINT:
        case VT_R4:
        case VT_ERROR:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(ULONG));
            break;

        case VT_I8:
        case VT_UI8:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(LONGLONG));
            break;

        case VT_CLSID:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(GUID));
            break;

        case VT_DECIMAL:
            pl = (ULONG const *) Add2ConstPtr( pl, cElems * sizeof(DECIMAL) );
            break;


        case VT_VERSIONED_STREAM:

            // Ensure we can read the GUID & string length
            if( cbremain <  sizeof(GUID) + sizeof(ULONG) )
            {
                StatusOverflow(pstatus, "PropertyLength: VersionedStream" );
                goto Exit;
            }

            // Point to the string's length
            pl = reinterpret_cast<const ULONG*>( Add2ConstPtr( pl, sizeof(GUID) ));

            // Point past the end of the property
            pl = reinterpret_cast<const ULONG*>( Add2ConstPtr( pl, sizeof(ULONG) + DwordAlign(PropByteSwap(*pl)) ));

            break;


        case VT_BLOB:
        case VT_BLOB_OBJECT:
            // FALLTHROUGH

        case VT_STREAM:
        case VT_STREAMED_OBJECT:
        case VT_STORAGE:
        case VT_STORED_OBJECT:

            // These are stored as strings (which are the name of a
            // stream/storage).

            if (flags & CPSS_VARIANTVECTOR)
            {
                fIllegalType = TRUE;
                break;
            }
            // FALLTHROUGH

        case VT_CF:
        case VT_BSTR:
        case VT_LPSTR:

            // This have byte counts, not character counts
            cbch = sizeof(BYTE);
            // FALLTHROUGH

        case VT_LPWSTR:

            // Handle all the length-prefixed types

            while (cElems-- > 0)
            {
                if (cbremain < sizeof(ULONG) ||
                    cbremain < (cb = sizeof(ULONG) + DwordAlign(PropByteSwap(*pl) * cbch)))
                {
                    StatusOverflow(pstatus, "PropertyLength: String/BLOB/CF/Indirect");
                    goto Exit;
                }

#ifdef LITTLEENDIAN
		PROPASSERT(
		    (PropByteSwap(pprop->dwType) & VT_TYPEMASK) != VT_LPWSTR
                     ||
		     IsUnicodeString( (WCHAR const *) &pl[1],
				       PropByteSwap(*pl) * sizeof(WCHAR)));
#endif

                pl = (ULONG const *) Add2ConstPtr(pl, cb);
                cbremain -= cb;
            }
            break;

        default:

            fIllegalType = TRUE;
            break;

        }   // switch( VT_TYPEMASK & vt )
    }

    // Did we get an illegal type (e.g. a VT_STREAM within a CPSS_VARIANTVECTOR)?

    if (fIllegalType)
    {
        propDbg(( DEB_IWARN, "PropertyLength: Unsupported VarType (0x%x)\n", vt ));
        *pstatus = STATUS_NOT_SUPPORTED;
        goto Exit;
    }

    // Calculate the final cb and verify it.

    cb = (ULONG) ((BYTE *) pl - (BYTE *) pprop);

    if (cbbuf < cb)
    {
        StatusOverflow(pstatus, "PropertyLength: cb");
        goto Exit;
    }

    // Make sure PropertyLength works when limited to an exact size buffer.
    PROPASSERT(cb == cbbuf || PropertyLengthNoEH(pprop, cb, flags, pstatus) == cb);

    //  ----
    //  Exit
    //  ----

Exit:

    // Normalize the error return value.
    if( !NT_SUCCESS(*pstatus) )
        cb = 0;

    return(cb);

}   // PropertyLengthNoEH()


//+--------------------------------------------------------------------------
// Function:    StgPropertyLengthAsVariant
//
// Synopsis:    compute the size of external memory required to store the
//              property as a PROPVARIANT
//
// Arguments:   [pprop]         -- property value
//              [cbprop]        -- computed length of pprop in propset stream
//              [CodePage]      -- property set codepage
//              [flags]         -- CPropertySetStream flags
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     length of property
//---------------------------------------------------------------------------

#if defined(WINNT)

// First, define a wrapper which raises NT Exceptions for compatibility
// with older callers who expect it.

EXTERN_C ULONG __stdcall
StgPropertyLengthAsVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN ULONG cbprop,
    IN USHORT CodePage,
    IN BYTE flags)
{
    NTSTATUS status;
    ULONG ulRet;
    
    ulRet = StgPropertyLengthAsVariantNoEH( pprop, cbprop, CodePage, flags, &status );
    
    if (!NT_SUCCESS( status ))
        RtlRaiseStatus( status );

    return( ulRet );
}

// Now define the body of the function, returning errors with an
// NTSTATUS value instead of raising.

ULONG
StgPropertyLengthAsVariantNoEH(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN ULONG cbprop,
    IN USHORT CodePage,
    IN BYTE flags,
    OUT NTSTATUS *pstatus)
{
    ULONG cElems = 0;
    ULONG cbvar = 0;
    const ULONG *pl = reinterpret_cast<const ULONG*>(pprop->rgb);

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(cbprop == PropertyLengthNoEH(pprop, cbprop, flags, pstatus));
    if( VT_VECTOR & PropByteSwap(pprop->dwType) )
    {
        if( VT_ARRAY & PropByteSwap(pprop->dwType) )
        {
            StatusInvalidParameter( pstatus, "Both Array and Vector bits set" );
            goto Exit;
        }
        cElems = *(ULONG *) pprop->rgb;
        pl++;
        cbprop -= sizeof(ULONG);        // Discount the element count
    }
    else if( VT_ARRAY & PropByteSwap(pprop->dwType) )
    {
        const SAFEARRAYBOUND *rgsaBounds = NULL;
        ULONG cDims = 0;
        VARTYPE vtInternal;

        if( VT_VECTOR & PropByteSwap(pprop->dwType) )
        {
            StatusInvalidParameter( pstatus, "Both Array and Vector bits set" );
            goto Exit;
        }

        vtInternal = static_cast<VARTYPE>(*pl++);
        cDims = *pl++;  PROPASSERT( sizeof(UINT) == sizeof(LONG) );
        rgsaBounds = reinterpret_cast<const SAFEARRAYBOUND*>(pl);
        pl = static_cast<const ULONG*>( Add2ConstPtr( pl, cDims * sizeof(SAFEARRAYBOUND) ));
        
        cElems = CalcSafeArrayElements( cDims, rgsaBounds );

        // Adjust cbprop to take into account that we have to create a SafeArray
        cbprop = cbprop
                 - sizeof(DWORD)            // vtInternal
                 - sizeof(UINT)             // cDims
                 + sizeof(SAFEARRAY)        // The SafeArray that will be alloced
                 + sizeof(GUID)             // hidden extra data alloc-ed with a safearray
                 - sizeof(SAFEARRAYBOUND);  // Discount SAFEARRAY.rgsabound[1]
    }


    switch( PropByteSwap(pprop->dwType) )
    {
        // We don't need to check for VT_BYREF, becuase serialized property sets
        // never contain them.

        //default:
        //case VT_EMPTY:
        //case VT_NULL:
        //case VT_I1:
        //case VT_UI1:
        //case VT_I2:
        //case VT_UI2:
        //case VT_BOOL:
        //case VT_INT:
        //case VT_UINT:
        //case VT_I4:
        //case VT_UI4:
        //case VT_R4:
        //case VT_ERROR:
        //case VT_I8:
        //case VT_UI8:
        //case VT_R8:
        //case VT_CY:
        //case VT_DATE:
        //case VT_FILETIME:
        //case VT_DECIMAL:
            //cbvar = 0;
            //break;

        case VT_CLSID:
            cbvar = cbprop - sizeof(ULONG);     // don't include VARTYPE
            break;

        // VT_CF: Round CLIPDATA up to Quad boundary, then drop VARTYPE+size+
        // clipfmt, which get tossed or unmarshalled into CLIPDATA.  Round
        // byte-granular data size to a Quad boundary when returning result.

        case VT_CF:
            cbvar = QuadAlign(sizeof(CLIPDATA)) + cbprop - 3 * sizeof(ULONG);
            break;

        case VT_BLOB:
        case VT_BLOB_OBJECT:
            cbvar = cbprop - 2 * sizeof(ULONG); // don't include VARTYPE & size
            break;

        case VT_VERSIONED_STREAM:
        case VT_STREAM:
        case VT_STREAMED_OBJECT:
        case VT_STORAGE:
        case VT_STORED_OBJECT:

            cbvar = cbprop - 2 * sizeof(ULONG); // don't include VARTYPE & size
            if (CodePage != CP_WINUNICODE)
            {
                cbvar *= sizeof(WCHAR); // worst case Unicode conversion
            }

            break;

        case VT_BSTR:

            // Don't include the size of the VT field, but leave
            // the size of the length field accounted for.
            cbvar = cbprop - sizeof(ULONG);

            // Worst-case Ansi->Unicode conversion:
            cbvar *= sizeof(OLECHAR);

            break;

        case VT_LPSTR:  // Assume Ansi conversion saves no space
        case VT_LPWSTR:
            cbvar = cbprop - 2 * sizeof(ULONG);
            break;

        case VT_ARRAY | VT_I1:
        case VT_ARRAY | VT_UI1:
        case VT_ARRAY | VT_I2:
        case VT_ARRAY | VT_UI2:
        case VT_ARRAY | VT_BOOL:
        case VT_ARRAY | VT_I4:
        case VT_ARRAY | VT_UI4:
        case VT_ARRAY | VT_INT:
        case VT_ARRAY | VT_UINT:
        case VT_ARRAY | VT_R4:
        case VT_ARRAY | VT_ERROR:
        case VT_ARRAY | VT_DECIMAL:
        //case VT_ARRAY | VT_I8:
        //case VT_ARRAY | VT_UI8:
        case VT_ARRAY | VT_R8:
        case VT_ARRAY | VT_CY:
        case VT_ARRAY | VT_DATE:

            // don't include VARTYPE field
            cbvar = cbprop - sizeof(ULONG);
            break;

        // Vector properties:

        case VT_VECTOR | VT_I1:
        case VT_VECTOR | VT_UI1:
        case VT_VECTOR | VT_I2:
        case VT_VECTOR | VT_UI2:
        case VT_VECTOR | VT_BOOL:
        case VT_VECTOR | VT_I4:
        case VT_VECTOR | VT_UI4:
        case VT_VECTOR | VT_R4:
        case VT_VECTOR | VT_ERROR:
        case VT_VECTOR | VT_I8:
        case VT_VECTOR | VT_UI8:
        case VT_VECTOR | VT_R8:
        case VT_VECTOR | VT_CY:
        case VT_VECTOR | VT_DATE:
        case VT_VECTOR | VT_FILETIME:
        case VT_VECTOR | VT_CLSID:
            AssertByteVector(cac);              // VT_I1
            AssertByteVector(caub);             // VT_UI1
            AssertShortVector(cai);             // VT_I2
            AssertShortVector(caui);            // VT_UI2
            AssertShortVector(cabool);          // VT_BOOL
            AssertLongVector(cal);              // VT_I4
            AssertLongVector(caul);             // VT_UI4
            AssertLongVector(caflt);            // VT_R4
            AssertLongVector(cascode);          // VT_ERROR
            AssertLongLongVector(cah);          // VT_I8
            AssertLongLongVector(cauh);         // VT_UI8
            AssertLongLongVector(cadbl);        // VT_R8
            AssertLongLongVector(cacy);         // VT_CY
            AssertLongLongVector(cadate);       // VT_DATE
            AssertLongLongVector(cafiletime);   // VT_FILETIME
            AssertVarVector(cauuid, sizeof(GUID));

            // don't include VARTYPE and count fields
            cbvar = cbprop - 2 * sizeof(ULONG);
            break;

        case VT_VECTOR | VT_CF:         // add room for each pointer
            AssertVarVector(caclipdata, sizeof(CLIPDATA));      // VT_CF

            // don't include VARTYPE and count fields
            cbvar = cbprop - 2 * sizeof(ULONG);

            // add room for each CLIPDATA data pointer and enough to Quad align
            // every clipdata data element and 1 ULONG to Quad align the
            // CLIPDATA array
            cbvar += cElems * (sizeof(BYTE *) + sizeof(ULONG)) + sizeof(ULONG);
            break;

        case VT_VECTOR | VT_BSTR:       // add room for each BSTRLEN
        case VT_ARRAY  | VT_BSTR:
            AssertStringVector(cabstr);                         // VT_BSTR
            //Assert

            // don't include VARTYPE field
            cbvar = cbprop - sizeof(ULONG);

            // For vectors, don't include the count field
            if( VT_VECTOR & PropByteSwap(pprop->dwType) )
                cbvar -= sizeof(ULONG);
            
            if (CodePage != CP_WINUNICODE)
            {
                cbvar *= sizeof(OLECHAR);   // worst case Unicode conversion
            }

            // add room for each BSTRLEN value and enough to Quad align
            // every BSTR and 1 ULONG to Quad align the array of BSTR pointers.

            cbvar += cElems * (sizeof(ULONG) + sizeof(ULONG)) + sizeof(ULONG);
            break;

        case VT_VECTOR | VT_LPSTR: // Assume Ansi conversion saves no space
        case VT_VECTOR | VT_LPWSTR:
            AssertStringVector(calpstr);                        // VT_LPSTR
            AssertStringVector(calpwstr);                       // VT_LPWSTR

            // don't include VARTYPE and count fields
            cbvar = cbprop - 2 * sizeof(ULONG);

            // add enough room to Quadalign the array of string pointers.

            cbvar += cElems * sizeof(ULONG) + sizeof(ULONG);
            break;

        case VT_VECTOR | VT_VARIANT:
        case VT_ARRAY  | VT_VARIANT:
        {
            ULONG cbremain = cbprop - sizeof(ULONG);    // Discount the VT

            cbvar = cElems * sizeof(PROPVARIANT);

            while (cElems-- > 0)
            {
                ULONG cbpropElem;
                ULONG cbvarElem;
                
                cbpropElem = PropertyLengthNoEH(
                                    (SERIALIZEDPROPERTYVALUE *) pl,
                                    cbremain,
                                    flags | CPSS_VARIANTVECTOR,
                                    pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                cbvarElem = StgPropertyLengthAsVariantNoEH(
                                    (SERIALIZEDPROPERTYVALUE *) pl,
                                    cbpropElem,
                                    CodePage,
                                    flags | CPSS_VARIANTVECTOR,
                                    pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                pl = (ULONG const *) Add2ConstPtr(pl, cbpropElem);
                cbremain -= cbpropElem;
                cbvar += cbvarElem;
            }
            break;
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // Normalize the error return value.
    if( !NT_SUCCESS(*pstatus) )
        cbvar = 0;

    return(QuadAlign(cbvar));

}   // StgPropertyLengthAsVariantNoEH

#endif // #if defined(WINNT)



//+--------------------------------------------------------------------------
// Function:    PBSCopy
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine copies the source to the destination, 
//              byte-swapping as it copies.
//
// Arguments:   [VOID*] pvDest
//                  Pointer to the target (swapped) buffer.
//                  This must be pre-allocated by the caller.
//              [VOID*] pvSource
//                  Pointer to the original buffer.
//              [ULONG] cbSize
//                  Size in bytes of the buffer.
//              [ULONG] cbByteSwap
//                  Size of byte-swapping units.
//
// Returns:     None.
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSCopy( OUT VOID *pvDest,
              IN VOID const *pvSource,
              IN ULONG cbCopy,
              IN LONG cbByteSwap )
{
    PROPASSERT( (cbCopy & 1) == 0 );
    PROPASSERT( pvDest != NULL && pvSource != NULL );

    memcpy( pvDest, pvSource, cbCopy );
    PBSBuffer( pvDest, cbCopy, cbByteSwap );
}

#endif  // BIGENDIAN


//+--------------------------------------------------------------------------
// Function:    PBSAllocAndCopy
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine allocs a buffer, and swaps the bytes from
//              the source buffer into the destination.
//
// Arguments:   [VOID**] ppvDest (out)
//                  On success will point to the swapped buffer.
//              [VOID*] pvSource (in)
//                  Pointer to the original buffer.
//              [ULONG] cbSize (in)
//                  Size in bytes of the buffer.
//              [LONG] cbByteSwap (in)
//                  Size of byte-swapping units.
//              [NTSTATUS*] pstatus (out)
//                  NTSTATUS code.
//
// Returns:     None.
//
// Note:        The caller is responsible for freeing *ppvDest
//              (using ::delete).
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSAllocAndCopy( OUT VOID **ppvDest,
                      IN VOID const *pvSource,
                      ULONG cbSize,
                      LONG cbByteSwap,
                      OUT NTSTATUS *pstatus)
{
    //  -----
    //  Begin
    //  -----

    *pstatus = STATUS_SUCCESS;
    PROPASSERT( ppvDest != NULL && pvSource != NULL );

    // Allocate a buffer.
    *ppvDest = CoTaskMemAlloc( cbSize );
    if( NULL == *ppvDest )
    {
        *pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Swap/copy the bytes.
    PBSCopy( *ppvDest, pvSource, cbSize, cbByteSwap );

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // PBSAllocAndCopy

#endif // BIGENDIAN

//+--------------------------------------------------------------------------
// Function:    PBSInPlaceAlloc
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine takes a WCHAR array, allocates a new buffer,
//              and swaps the original array into the new buffer.
//              
//
// Arguments:   [WCHAR**] ppwszResult
//                  IN: *ppwszResult points to string to be swapped.
//                  OUT: *ppwszResult points to the swapped string.
//              [WCHAR**] ppwszBuffer
//                  *ppwszBuffer points to the buffer which was allocated
//                  for the swapped bytes (should be the same as *ppwszResult).
//                  *ppwszBuffer must be NULL on input, and must be freed
//                  by the caller (using ::delete).
//              [NTSTATUS*] pstatus
//                  NTSTATUS code.
//
// Returns:     None.
//
// On input, *ppwszResult contains the original string.
// An equivalently sized buffer is allocated in *ppwszBuffer,
// and *ppwszResult is byte-swapped into it.  *ppwszResult
// is then set to the new *ppwszBuffer.
//
// It doesn't appear to useful to have both buffer parameters,
// but it makes it easier on the caller in certain circumstances;
// *ppwszResult always points to the correct string, whether the
// build is BIGENDIAN (alloc & swap takes place) or the build
// is LITTLEENDIAN (nothing happes, so *ppwszResult continues
// to point to the proper string).  The LITTLEENDIAN version of
// this function is implemented as an inline routine.
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSInPlaceAlloc( IN OUT WCHAR** ppwszResult,
                      OUT WCHAR** ppwszBuffer,
                      OUT NTSTATUS *pstatus )
{
    //  ------
    //  Locals
    //  ------

    WCHAR *pwszNewBuffer;

    // Pointers which will walk through the input buffers.
    WCHAR *pwszOriginal, *pwszSwapped;

    //  -----
    //  Begin
    //  -----

    *pstatus = STATUS_SUCCESS;

    // Allocate a new buffer.
    pwszNewBuffer = CoTaskMemAlloc( sizeof(WCHAR)*( Prop_wcslen(*ppwszResult) + 1 ));
    if( NULL == pwszNewBuffer )
    {
        *pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Swap the WCHARs into the new buffer.

    pwszOriginal = *ppwszResult;
    pwszSwapped = pwszNewBuffer;

    do
    {
        *pwszSwapped = PropByteSwap(*pwszOriginal++);
    }   while( *pwszSwapped++ != L'\0' );

    // If the caller wants a special pointer to the new buffer,
    // set it now.

    if( NULL != ppwszBuffer )
    {
        PROPASSERT( NULL== *ppwszBuffer );
        *ppwszBuffer = pwszNewBuffer;
    }

    // Also point *ppwszResult to the new buffer.
    *ppwszResult = pwszNewBuffer;


    //  ----
    //  Exit
    //  ----

Exit:
    return;
}   // PropByteSwap( WCHAR**, WCHAR**, NTSTATUS*)

#endif // BIGENDIAN


//+--------------------------------------------------------------------------
// Function:    PBSBuffer
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine takes a buffer and byte-swaps it.  The caller
//              specifies the size of the buffer, and the granularity of
//              the byte-swapping.
//
// Arguments:   [VOID*] pv
//                  Pointer to the buffer to be swapped.
//              [ULONG] cbSize
//                  Size in bytes of the buffer.
//              [ULONG] cbByteSwap
//                  Size of byte-swapping units.
//
// Returns:     None.
//
// For example, an array of 4 WORDs could be swapped with:
//
//      PBSBuffer( (VOID*) aw, 8, sizeof(WORD) );
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSBuffer( IN OUT VOID *pv,
                IN ULONG cbSize,
                IN ULONG cbByteSwap )
{
    ULONG ulIndex;

    // What kind of swapping should be do?

    switch( cbByteSwap )
    {
        // No swapping required

        case 0:
        case( sizeof(BYTE) ):

            // Nothing to do.
            break;

        // Swap WORDs

        case( sizeof(WORD) ):
            
            for( ulIndex = 0; ulIndex < cbSize/sizeof(WORD); ulIndex++ )
                ByteSwap( &((WORD*)pv)[ulIndex] );
            break;

        // Swap DWORDs

        case( sizeof(DWORD) ):

            for( ulIndex = 0; ulIndex < cbSize/sizeof(DWORD); ulIndex++ )
                ByteSwap( &((DWORD*)pv)[ulIndex] );
            break;

        // Swap LONGLONGs

        case( sizeof(LONGLONG) ):

            for( ulIndex = 0; ulIndex < cbSize/sizeof(LONGLONG); ulIndex++ )
                ByteSwap( &((LONGLONG*)pv)[ulIndex] );
            break;

        // Swap GUIDs

        case CBBYTESWAP_UID:

            for( ulIndex = 0; ulIndex < cbSize/sizeof(GUID); ulIndex++ )
                ByteSwap( &((GUID*)pv)[ulIndex] );
            break;

        // Error

        default:
            PROPASSERT( !"Invalid generic byte-swap size" );
    }
}   // PropByteSwap( VOID*, ULONG, ULONG )

#endif // BIGENDIAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\psetstg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       psetstg.cxx
//
//  Contents:   Implementation of common class for OFS and DocFile
//              IPropertySetStorage
//
//  Classes:    CPropertySetStorage
//              CEnumSTATPROPSETSTG
//
//  History:    1-Mar-95   BillMo      Created.
//             09-May-96   MikeHill    Don't delete a CPropertyStorage object,
//                                     it deletes itself in the Release.
//             22-May-96   MikeHill    Set STATPROPSETSTG.dwOSVersion.
//             06-Jun-96   MikeHill    Added input validation.
//             15-Jul-96   MikeHill    - Handle STATSTG as OLECHAR (not WCHAR).
//                                     - Added CDocFilePropertySetStorage imp.
//             07-Feb-97   Danl        - Removed CDocFilePropertySetStorage.
//                                     - Moved _Create, _Open, & _Delete
//                                       into Create, Open & Delete
//             10-Mar-98   MikeHill    Pass grfMode into CPropertyStorage
//                                     create/open methods.
//             06-May-98   MikeHill    Use CoTaskMem rather than new/delete.
//     5/18/98  MikeHill
//              -   Cleaned up constructor by moving parameters to a
//                  new Init method.
//     6/11/98  MikeHill
//              -   Dbg outs.
//              -   Don't use out-parm as temp-parm in Create, Open.
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#include <prophdr.hxx>

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

//
// debugging support
//

#if DBG
CHAR *
DbgFmtId(REFFMTID rfmtid, CHAR *pszBuf)
{
    PropSprintfA(pszBuf, CB_DBGBUF,
        "rfmtid=%08X-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X",
        rfmtid.Data1,
        rfmtid.Data2,
        rfmtid.Data3,
        rfmtid.Data4[0],
        rfmtid.Data4[1],
        rfmtid.Data4[2],
        rfmtid.Data4[3],
        rfmtid.Data4[4],
        rfmtid.Data4[5],
        rfmtid.Data4[6],
        rfmtid.Data4[7]);

    return(pszBuf);
}

CHAR *
DbgMode(DWORD grfMode, CHAR *psz)
{
    *psz = 0;

    if (grfMode & STGM_TRANSACTED)
        StringCbCatA(psz, CB_DBGBUF, "STGM_TRANSACTED | ");
    else
        StringCbCatA(psz, CB_DBGBUF, "STGM_DIRECT | ");

    if (grfMode & STGM_SIMPLE)
        StringCbCatA(psz, CB_DBGBUF, "STGM_SIMPLE | ");

    switch (grfMode & 3)
    {
    case STGM_READ:
        StringCbCatA(psz, CB_DBGBUF, "STGM_READ |");
        break;
    case STGM_WRITE:
        StringCbCatA(psz, CB_DBGBUF, "STGM_WRITE |");
        break;
    case STGM_READWRITE:
        StringCbCatA(psz, CB_DBGBUF, "STGM_READWRITE |");
        break;
    default:
        StringCbCatA(psz, CB_DBGBUF, "BAD grfMode |");
        break;
    }

    switch (grfMode & 0x70)
    {
    case STGM_SHARE_DENY_NONE:
        StringCbCatA(psz, CB_DBGBUF, "STGM_SHARE_DENY_NONE |");
        break;
    case STGM_SHARE_DENY_READ:
        StringCbCatA(psz, CB_DBGBUF, "STGM_SHARE_DENY_READ |");
        break;
    case STGM_SHARE_DENY_WRITE:
        StringCbCatA(psz, CB_DBGBUF, "STGM_SHARE_DENY_WRITE |");
        break;
    case STGM_SHARE_EXCLUSIVE:
        StringCbCatA(psz, CB_DBGBUF, "STGM_SHARE_EXCLUSIVE |");
        break;
    default:
        StringCbCatA(psz, CB_DBGBUF, "BAD grfMode | ");
        break;
    }


    if (grfMode & STGM_PRIORITY)
        StringCbCatA(psz, CB_DBGBUF, "STGM_PRIORITY | ");

    if (grfMode & STGM_DELETEONRELEASE)
        StringCbCatA(psz, CB_DBGBUF, "STGM_DELETEONRELEASE | ");

    if (grfMode & STGM_NOSCRATCH)
        StringCbCatA(psz, CB_DBGBUF, "STGM_NOSCRATCH | ");

    if (grfMode & STGM_CREATE)
        StringCbCatA(psz, CB_DBGBUF, "STGM_CREATE | ");

    if (grfMode & STGM_CONVERT)
        StringCbCatA(psz, CB_DBGBUF, "STGM_CONVERT | ");

    if (grfMode & STGM_FAILIFTHERE)
        StringCbCatA(psz, CB_DBGBUF, "STGM_FAILIFTHERE | ");

    return(psz);
}

CHAR *
DbgFlags(DWORD grfFlags, CHAR *psz)
{
    StringCbCopyA(psz, CB_DBGBUF, "grfFlags=");

    if (grfFlags & PROPSETFLAG_NONSIMPLE)
        StringCbCatA(psz, CB_DBGBUF, "PROPSETFLAG_NONSIMPLE |");
    else
        StringCbCatA(psz, CB_DBGBUF, "PROPSETFLAG_SIMPLE |");

    if (grfFlags & PROPSETFLAG_ANSI)
        StringCbCatA(psz, CB_DBGBUF, "PROPSETFLAG_ANSI |");
    else
        StringCbCatA(psz, CB_DBGBUF, "PROPSETFLAG_WIDECHAR |");

    return(psz);
}
#endif

//+----------------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Init
//
//  Synopsis:   This method is used to provide the IStorage in which 
//              property sets (IPropertyStorage's) will be created/opened.
//
//  Arguments:  [IStorage*]
//                  The containing storage.
//              [IBlockingLock*]
//                  The locking mechanism this CPropertySetStorage should
//                  use.  May be NULL.
//              [BOOL] (fControlLifetimes)
//                  If true, we must addref the IStorage.  E.g. in the docfile
//                  implementation, CPropertySetStorage is a base class
//                  for CExposedStorage, and this flag is set false.
//
//+----------------------------------------------------------------------------

void
CPropertySetStorage::Init( IStorage *pstg,
                           IBlockingLock *pBlockingLock,
                           BOOL fControlLifetimes )
{
    DfpAssert( NULL == _pstg && NULL == _pBlockingLock );

    _pstg = pstg;
    _pBlockingLock = pBlockingLock;

    if( fControlLifetimes )
    {
        _fContainingStgIsRefed = TRUE;

        pstg->AddRef();
        if( NULL != pBlockingLock )
            pBlockingLock->AddRef();
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Create
//
//  Synopsis:   Create a property set for outermost client of
//              IPropertSetStorage.
//
//  Arguments:  Passed through to CPropertyStorage ctor.
//
//  Returns:    S_OK or failure code.
//
//  Notes:      Create a new CPropertyStorage object which will
//              implement IPropertyStorage.  The _pprivstg parameter
//              passed into CPropertyStorage::CPropertyStorage is
//              used to create (via QI) a matching type of mapped
//              stream (for OFS or DocFile properties.)
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Create( REFFMTID                rfmtid,
                                     const CLSID *           pclsid,
                                     DWORD                   grfFlags,
                                     DWORD                   grfMode,
                                     IPropertyStorage **     ppprstg)
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    IStream *pstmPropSet = NULL;
    IStorage *pstgPropSet = NULL;
    CPropertyStorage *pcPropStg = NULL;
    BOOL fCreated = FALSE;
    INT nPass = 0;
    BOOL fLocked = FALSE;
    CPropSetName psn;

    DBGBUF(buf1);
    DBGBUF(buf2);
    DBGBUF(buf3);

    propXTrace( "CPropertySetStorage::Create" );

    //  ----------
    //  Validation
    //  ----------

    if (S_OK != (hr = Validate()))
        goto Exit;

    Lock();
    fLocked = TRUE;

    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, Exit, hr);
    GEN_VDATEPTRIN_LABEL(pclsid, CLSID, E_INVALIDARG, Exit, hr);
    GEN_VDATEPTROUT_LABEL( ppprstg, IPropertyStorage*, E_INVALIDARG, Exit, hr);

    propTraceParameters(( "%s, %s, %s",
                          static_cast<const char*>(CStringize(rfmtid)),
                          static_cast<const char*>(CStringize( SGrfFlags(grfFlags))),
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))) ));

    // We don't support PROPSETFLAG_UNBUFFERED from the IPropertySetStorage
    // interface.  This may only be used in the StgOpenPropStg
    // and StgCreatePropStg APIs.  This was done because we can't support
    // the flag on IPropertySetStorage::Open, so it would be inconsistent
    // to support it on the Create method.

    if( grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        hr = STG_E_INVALIDFLAG;
        goto Exit;
    }

    hr = CheckFlagsOnCreateOrOpen(TRUE,grfMode);
    if (hr != S_OK)
    {
        goto Exit;
    }

    psn = CPropSetName(rfmtid);
    *ppprstg = NULL;

    //  --------------------------------
    //  Create a child Stream or Storage
    //  --------------------------------

    // We'll make one or two passes (two if we the stream/storage
    // already exists and we have to delete it).

    while( nPass <= 1 )
    {
        if( PROPSETFLAG_NONSIMPLE & grfFlags )
        {
            // The Child should be a Storage

            hr = _pstg->CreateStorage( psn.GetPropSetName(),
                                       grfMode,
                                       0L, 0L,
                                       &pstgPropSet );

            if( SUCCEEDED(hr) )
            {
                fCreated = TRUE;

                if( NULL != pclsid )
                {
                    // We should also set the CLSID of the Storage.
                    hr = pstgPropSet->SetClass(*pclsid);
                    if( FAILED(hr) && E_NOTIMPL != hr ) goto Exit;
                    hr = S_OK;
                }
            }

        }   // if( PROPSETFLAG_NONSIMPLE & grfFlags )

        else
        {
            // The Child should be a Stream

            if( IsEqualGUID( rfmtid, FMTID_UserDefinedProperties ))
            {
                hr = CreateUserDefinedStream( _pstg, psn, grfMode, &fCreated, &pstmPropSet );
            }
            else
            {
                hr = _pstg->CreateStream(psn.GetPropSetName(),
                                         grfMode & ~STGM_TRANSACTED,
                                         0, 0, &pstmPropSet);
                if( hr == S_OK )
                    fCreated = TRUE;
            }

        }

        // If the create failed because the element already existed,
        // and if STGM_CREATE was set, then let's delete the existing
        // element and try again.

        if( hr == STG_E_FILEALREADYEXISTS
            &&
            grfMode & STGM_CREATE
            &&
            0 == nPass )
        {
            hr = _pstg->DestroyElement( psn.GetPropSetName() );
            if( FAILED(hr) )
                goto Exit;

            nPass++;
        }

        // If we failed for any other reason, then it's fatal.

        else if( FAILED(hr) )
            goto Exit;

        // Otherwise (we succeeded), we can move on.

        else
            break;

    }   // while( nPass <= 1 )


    //  ---------------------------
    //  Create the Property Storage
    //  ---------------------------

    // Create a CPropertyStorage

    pcPropStg = new CPropertyStorage( _MSOpts );
    if( NULL == pcPropStg )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Initialize the property set.

    if( PROPSETFLAG_NONSIMPLE & grfFlags )
        // We need a non-simple IPropertyStorage
        hr = pcPropStg->Create( pstgPropSet, rfmtid, pclsid, grfFlags, grfMode);

    else
        // We need a simple IPropertyStorage
        hr = pcPropStg->Create(  pstmPropSet, rfmtid, pclsid, grfFlags, grfMode );

    if( FAILED(hr) ) goto Exit;


    //  ----
    //  Exit
    //  ----

    *ppprstg = static_cast<IPropertyStorage*>(pcPropStg);
    pcPropStg = NULL;
    hr = S_OK;

Exit:

    // On failure ...
    if( FAILED(hr) )
    {
        // If an entry was created, attempt to delete it.
        if( fCreated )
            _pstg->DestroyElement( psn.GetPropSetName() );

    }

    if( NULL != pcPropStg )
        delete pcPropStg;

    if( NULL != pstmPropSet )
        pstmPropSet->Release();

    if( NULL != pstgPropSet )
        pstgPropSet->Release();


    if( fLocked )
        Unlock();

    if( STG_E_FILEALREADYEXISTS == hr )
        propSuppressExitErrors();

    return( hr );
}




//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Open
//
//  Synopsis:   Open a property set for outermost client.
//
//  Arguments:  passed through to CPropertyStorage ctor.
//
//  Returns:    S_OK or error.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Open(   REFFMTID                rfmtid,
                                     DWORD                   grfMode,
                                     IPropertyStorage **     ppprstg)
{
    HRESULT hr;

    IUnknown *punkPropSet = NULL;
    BOOL fSimple = TRUE;
    BOOL fLocked = FALSE;
    CPropertyStorage *pcPropStg = NULL;
    CPropSetName psn;

    DBGBUF(buf1);
    DBGBUF(buf2);

    propXTrace( "CPropertySetStorage::Open" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto Exit;

    Lock();
    fLocked = TRUE;

    // Validate inputs
    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, Exit, hr);
    GEN_VDATEPTROUT_LABEL( ppprstg, IPropertyStorage*, E_INVALIDARG, Exit, hr);


    propTraceParameters(( "%s, %s, %p",
                          DbgFmtId(rfmtid, buf1), DbgMode(grfMode, buf2), ppprstg ));

    psn = CPropSetName(rfmtid);
    *ppprstg = NULL;

    //  --------------------------------
    //  Open the child Stream or Storage
    //  --------------------------------

    hr = _pstg->OpenStream( psn.GetPropSetName(),
                            0L,
                            grfMode & ~STGM_TRANSACTED,
                            0L,
                            (IStream**) &punkPropSet );

    if( STG_E_FILENOTFOUND == hr )
    {
        fSimple = FALSE;
        hr = _pstg->OpenStorage( psn.GetPropSetName(),
                                 NULL,
                                 grfMode,
                                 NULL,
                                 0L,
                                 (IStorage**) &punkPropSet );
    }

    if( FAILED(hr) ) goto Exit;


    //  -------------------------
    //  Open the Property Storage
    //  -------------------------

    // Create an empty CPropertyStorage object.
    pcPropStg = new CPropertyStorage( _MSOpts );
    if( NULL == pcPropStg )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Open the property set and load it into the CPropertyStorage
    // object.  We pas the default grfFlags, letting the Open method
    // infer its correct value from the property set.

    if( !fSimple )
    {
        hr = pcPropStg->Open(static_cast<IStorage*>(punkPropSet),   // Addref-ed
                             rfmtid,
                             PROPSETFLAG_DEFAULT, // Flags are inferred
                             grfMode );
    }
    else
    {
        hr = pcPropStg->Open( static_cast<IStream*>(punkPropSet),   // Addref-ed
                              rfmtid,
                              PROPSETFLAG_DEFAULT, // Flags are inferred
                              grfMode,
                              FALSE );    // Don't delete this property set

    }
    if( FAILED(hr) ) goto Exit;


    //  ----
    //  Exit
    //  ----

    *ppprstg = static_cast<IPropertyStorage*>(pcPropStg);
    pcPropStg = NULL;
    hr = S_OK;

Exit:

    if( NULL != pcPropStg )
        delete pcPropStg;

    if( NULL != punkPropSet )
        punkPropSet->Release();

    if( fLocked )
        Unlock();

    if( STG_E_FILENOTFOUND == hr )
        propSuppressExitErrors();

    return(hr);
}



//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Delete
//
//  Synopsis:   Delete the specified property set.
//
//  Arguments:  [rfmtid] -- format id of property set to delete.
//
//  Returns:    S_OK if successful, error otherwise.
//
//  Notes:      Get the matching name and try the element deletion.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Delete( REFFMTID  rfmtid)
{
    HRESULT hr = S_OK;
    IStream *pstm = NULL;
    BOOL fLocked = FALSE;
    CPropSetName psn;
    DBGBUF(buf);

    propXTrace( "CPropertySetStorage::Delete" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto Exit;

    Lock();
    fLocked = TRUE;

    // Validate the input
    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, Exit, hr);

    propTraceParameters(( "%s", DbgFmtId(rfmtid, buf) ));
    psn = CPropSetName(rfmtid);

    //  --------------------------
    //  Delete the PropertyStorage
    //  --------------------------

    // Check for the special-case

    if( IsEqualIID( rfmtid, FMTID_UserDefinedProperties ))
    {
        // This property set is actually the second section of the Document
        // Summary Information property set.  We must delete this
        // section, but we can't delete the Stream because it
        // still contains the first section.

        CPropertyStorage* pprstg;

        // Open the Stream.
        hr = _pstg->OpenStream( psn.GetPropSetName(),
                                NULL,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                0L,
                                &pstm );
        if( FAILED(hr) ) goto Exit;

        // Create a CPropertyStorage
        pprstg = new CPropertyStorage( _MSOpts );
        if( NULL == pprstg )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Use the CPropertyStorage to delete the section.
        hr = pprstg->Open( pstm,
                           rfmtid,
                           PROPSETFLAG_DEFAULT,
                           STGM_READWRITE | STGM_SHARE_EXCLUSIVE,      
                           TRUE ); // Delete this section

        pprstg->Release();  // Deletes *pprstg
        pprstg = NULL;

        if( FAILED(hr) ) goto Exit;

    }   // if( IsEqualIID( rfmtid, FMTID_DocSummaryInformation2 ))

    else
    {
        // This is not a special case, so we can just delete
        // the Stream.  Note that if the rfmtid represents the first
        // section of the DocumentSummaryInformation set, we might be
        // deleting the second section here as well.  That is a documented
        // side-effect.

        hr = _pstg->DestroyElement(psn.GetPropSetName());
        if( FAILED(hr) ) goto Exit;

    }   // if( IsEqualIID( rfmtid, FMTID_UserDefinedProperties )) ... else


    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    if( NULL != pstm )
        pstm->Release();

    if( fLocked )
        Unlock();

    if( STG_E_FILENOTFOUND == hr )
        propSuppressExitErrors();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Enum
//
//  Synopsis:   Create an enumerator over the property set
//
//  Arguments:  [ppenum] -- where to return the pointer to the
//                          enumerator.
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      [ppenum] is NULL on error.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Enum(   IEnumSTATPROPSETSTG **  ppenum)
{

    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertySetStorage::Enum" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto Exit;

    Lock();
    fLocked = TRUE;

    // Validate the input
    GEN_VDATEPTROUT_LABEL( ppenum, IEnumSTATPROPSETSTG*, E_INVALIDARG, Exit, hr);
    *ppenum = NULL;

    propTraceParameters(( "%p", ppenum ));

    //  --------------------
    //  Create the enuerator
    //  --------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = new CEnumSTATPROPSETSTG(_pstg, &hr);

    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSETSTG*) *ppenum;
        *ppenum = NULL;
    }


    //  ----
    //  Exit
    //  ----

Exit:

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG
//
//  Synopsis:   Constructor which is used to implement
//              IPropertySetStorage::Enum
//
//  Arguments:  [pstg] -- the storage of the container to enumerate.
//              [phr] -- place to return HRESULT, S_OK or error.
//
//  Notes:      We use an STATSTG enumerator over the actual storage
//              to get the information about the property sets.
//
//--------------------------------------------------------------------


CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG(IStorage *pstg, HRESULT *phr)
{
    HRESULT & hr = *phr;

    _ulSig = ENUMSTATPROPSETSTG_SIG;
    _cRefs = 1;

    hr = pstg->EnumElements(FALSE, NULL, 0, &_penumSTATSTG);
    if (FAILED(hr))
        _penumSTATSTG = NULL;

    _cstatTotalInArray = 0;
    _istatNextToRead = 0;

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG
//
//  Synopsis:   Copy constructor which is used to implement
//              IEnumSTATPROPSETSTG::Clone.
//
//  Arguments:  [Other] -- The CEnumSTATPROPSETSTG to clone.
//              [phr] -- place to return HRESULT, S_OK or error.
//
//--------------------------------------------------------------------

CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG(   CEnumSTATPROPSETSTG &Other,
                                            HRESULT *phr)
{
    HRESULT & hr = *phr;

    _ulSig = ENUMSTATPROPSETSTG_SIG;
    _cRefs = 1;

    _cstatTotalInArray = 0;
    _istatNextToRead = Other._istatNextToRead;

    hr = Other._penumSTATSTG->Clone(&_penumSTATSTG);
    if (hr == S_OK)
    {
        // Copy the data in the buffer
        memcpy(_statarray, Other._statarray, sizeof(_statarray));
        _cstatTotalInArray = Other._cstatTotalInArray;

        // Copy the strings in the buffer
        for (ULONG i=0; i<_cstatTotalInArray; i++)
        {
            ULONG cbName = sizeof(OLECHAR)*( ocslen(Other._statarray[i].pwcsName) + 1 );
            _statarray[i].pwcsName = reinterpret_cast<OLECHAR*>
                                     ( CoTaskMemAlloc( cbName ));
            if (_statarray[i].pwcsName == NULL)
            {
                _cstatTotalInArray = i;
                hr = STG_E_INSUFFICIENTMEMORY;
                break;
            }
            else
            {
                StringCbCopy(_statarray[i].pwcsName,
                             cbName,
                             Other._statarray[i].pwcsName );
            }
        }
    }
    // note: destructor will cleanup the the strings or enumerator left behind
    //       in the error case
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::~CEnumSTATPROPSETSTG
//
//  Synopsis:   Delete the enumerator.
//
//  Notes:      Just releases the contained IEnumSTATSTG
//
//--------------------------------------------------------------------

CEnumSTATPROPSETSTG::~CEnumSTATPROPSETSTG()
{
    _ulSig = ENUMSTATPROPSETSTG_SIGDEL;

    if (_penumSTATSTG != NULL)
        _penumSTATSTG->Release();

    CleanupStatArray();

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown
//
//  Arguments:  The usual thing.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IEnumSTATPROPSETSTG))
    {
        *ppvObject = (IEnumSTATPROPSETSTG *)this;
        CEnumSTATPROPSETSTG::AddRef();
    }
    else
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = (IUnknown *)this;
        CEnumSTATPROPSETSTG::AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return(hr);

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::AddRef
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSETSTG::AddRef(void)
{
    if (S_OK != Validate())
        return(0);

    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Release
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSETSTG::Release(void)
{
    LONG lRet;

    if (S_OK != Validate())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Next
//
//  Synopsis:   Implement IEnumSTATPROPSETSTG for ofs and docfile.
//
//  Arguments:  [celt] -- Count of elements to attempt to retrieve.
//              [rgelt] -- Where to put the results.  Must be valid for at least
//                         celt * sizeof(STATPROPSETSTG) bytes in length.
//              [pceltFetched] -- Count of elements returned is put here if
//                  the pointer is non-null.  If celt > 1, pceltFetched must
//                  be valid non-NULL.  If pcelt is non-NULL, it must be valid.
//                  if pcelt is NULL, celt must be 1.
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      We use a stack buffer to get more stuff per call to
//              underlying storage IEnumSTATSTG::Next.  We then copy
//              data from the STATSTG's to STATPROPSETSTG's.
//
//              An outer loop enumerates into statarray and then an
//              inner loop copies each batch into the [rgelt] buffer.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Next(ULONG                   celt,
                                  STATPROPSETSTG *        rgelt,
                                  ULONG *                 pceltFetched)
{
    HRESULT hr;
    ULONG celtCallerTotal;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate inputs

    if (NULL == pceltFetched)
    {
        if (1 != celt)
            return(STG_E_INVALIDPARAMETER);
    }
    else
    {
        VDATEPTROUT( pceltFetched, ULONG );
        *pceltFetched = 0;
    }

    if (0 == celt)
        return(hr);

    if( !IsValidPtrOut(rgelt, celt * sizeof(rgelt[0])) )
        return( E_INVALIDARG );


    //  -----------------------
    //  Perform the enumeration
    //  -----------------------

    celtCallerTotal = 0;

    //
    // we do this loop until we have what the caller wanted or error, or
    // no more.
    //
    do
    {
        //
        // If our internal buffer is empty, we (re)load it
        //
        if (_istatNextToRead == _cstatTotalInArray)
        {
            if (_cstatTotalInArray != 0)
                CleanupStatArray();

            hr = _penumSTATSTG->Next(sizeof(_statarray)/sizeof(_statarray[0]),
                    _statarray,
                    &_cstatTotalInArray);
        }

        // S_OK or S_FALSE indicate that we got something
        if (SUCCEEDED(hr))
        {
            //
            // we loop reading out of this buffer until either we have
            // all that the caller asked for, or we have exhausted the
            // buffer.
            //
            for (; celtCallerTotal < celt &&
                   _istatNextToRead < _cstatTotalInArray ;
                   _istatNextToRead++)
            {
                OLECHAR *pocsName = _statarray[_istatNextToRead].pwcsName;
                BOOL fDone = FALSE;

                DfpAssert(pocsName != NULL);

                if (pocsName[0] == OC_PROPSET0)
                {
                    // SPEC: if no matching fmtid then return GUID_NULL

                    // *** get fmtid *** //

                    if (!NT_SUCCESS(PrPropertySetNameToGuid(
                                    ocslen(pocsName), pocsName, &rgelt->fmtid)))
                    {
                        ZeroMemory(&rgelt->fmtid, sizeof(rgelt->fmtid));
                    }

                    // *** get clsid *** //
                    // *** get grfFlags *** //
                    // SPEC: don't support returning PROPSETFLAG_ANSI

                    if (_statarray[_istatNextToRead].type == STGTY_STORAGE)
                    {
                        rgelt->clsid = _statarray[_istatNextToRead].clsid;
                        rgelt->grfFlags = PROPSETFLAG_NONSIMPLE;
                    }
                    else
                    {
                        // SPEC: don't get the clsid for !PROPSET_NONSIMPLE
                        ZeroMemory(&rgelt->clsid, sizeof(rgelt->clsid));
                        rgelt->grfFlags = 0;
                    }

                    // *** get mtime *** //
                    rgelt->mtime = _statarray[_istatNextToRead].mtime;

                    // *** get ctime *** //
                    rgelt->ctime = _statarray[_istatNextToRead].ctime;

                    // *** get atime *** //
                    rgelt->atime = _statarray[_istatNextToRead].atime;

                    // *** default the OS Version *** //
                    rgelt->dwOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;

                    rgelt ++;
                    celtCallerTotal ++;
                }
            }   // for (; celtCallerTotal < celt && ...
        }   // if (SUCCEEDED(hr))
    
    } while (celtCallerTotal < celt && hr == S_OK);

    if (SUCCEEDED(hr))
    {
        hr = celt == celtCallerTotal ? S_OK : S_FALSE;
        DfpAssert(hr == S_OK || celtCallerTotal < celt);

        if (pceltFetched != NULL)
            *pceltFetched = celtCallerTotal;
    }
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Skip
//
//  Synopsis:   Skip the requested number of elements.
//
//  Arguments:  [celt] -- number to skip.
//
//  Returns:    S_OK if all skipped, S_FALSE if less than requested
//              number skipped, error otherwise.
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Skip(ULONG celt)
{
    HRESULT hr;
    STATPROPSETSTG stat;
    ULONG celtCallerTotal = 0;

    if (S_OK != (hr = Validate()))
        return(hr);

    do
    {
        hr = Next(1, &stat, NULL);
    } while ( hr == S_OK && ++celtCallerTotal < celt );

    if (SUCCEEDED(hr))
        hr = celt == celtCallerTotal ? S_OK : S_FALSE;

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CleanupStatArray
//
//  Synopsis:   Free any strings in the array.
//
//--------------------------------------------------------------------

VOID CEnumSTATPROPSETSTG::CleanupStatArray()
{
    for (ULONG i=0; i<_cstatTotalInArray; i++)
    {
        CoTaskMemFree( _statarray[i].pwcsName );
        _statarray[i].pwcsName = NULL;
    }
    _istatNextToRead = 0;
    _cstatTotalInArray = 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Reset
//
//  Synopsis:   Reset the enumerator.
//
//  Notes:      Merely resetting the underlying enumerator should be
//              adequate,
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Reset()
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    hr = _penumSTATSTG->Reset();
    if (hr == S_OK)
    {
        CleanupStatArray();
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Clone
//
//  Synopsis:   Copy the enumeration state of this enumerator.
//
//  Arguments:  [ppenum] -- where to put the pointer to the clone
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      We end up just calling IEnumSTATSTG::Clone in the
//              CEnumSTATPROPSETSTG constructor.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Clone(IEnumSTATPROPSETSTG **     ppenum)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate inputs

    VDATEPTROUT( ppenum, IEnumSTATPROPSETSTG* );

    //  --------------------
    //  Clone the enumerator
    //  --------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = new CEnumSTATPROPSETSTG(*this, &hr);
    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSETSTG*) *ppenum;
        *ppenum = NULL;
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::
//              QueryInterface, AddRef, and Release
//
//  Synopsis:   IUnknown members.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr = S_OK;

    //  ----------
    //  Validation
    //  ----------

    if (S_OK != (hr = Validate()))
        return(hr);

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----
    //  Query
    //  -----

    if( IID_IPropertySetStorage == riid
        ||
        IID_IUnknown == riid )
    {
        *ppvObject = this;
        this->AddRef();
    }
    else
    {
        *ppvObject = NULL;
        hr = E_NOINTERFACE;
    }

    return( hr );
}

ULONG   CPropertySetStorage::AddRef(void)
{
    LONG lRet;

    // We don't call Validate here, because AddRef/Release should
    // always work.

    lRet = InterlockedIncrement( &_cReferences );
    return( lRet );
}

ULONG   CPropertySetStorage::Release(void)
{
    LONG lRet;

    // We don't call Validate here, because AddRef/Release should
    // always work.

    lRet = InterlockedDecrement( &_cReferences );

    if( 0 == lRet )
        delete this;
    else if( 0 > lRet )
        lRet = 0;

    return( lRet );
}

//+----------------------------------------------------------------------------
//
//  Function:   Lock & Unlock
//
//  Synopsis:   This methods take and release the CPropertySetStorage's
//              critical section.
//
//  Inputs:     None
//
//  Returns:    Nothing
//
//+----------------------------------------------------------------------------

VOID
CPropertySetStorage::Lock()
{
#ifndef _MAC

    if (NULL == _pBlockingLock)
    {
        DfpAssert (_fInitCriticalSection);
        EnterCriticalSection( &_CriticalSection );
    }
    else
    {
        _pBlockingLock->Lock(INFINITE);
    }

#endif
}

VOID
CPropertySetStorage::Unlock()
{
#ifndef _MAC

    if (NULL == _pBlockingLock)
    {
        DfpAssert (_fInitCriticalSection);
        LeaveCriticalSection( &_CriticalSection );
    }
    else
    {
        _pBlockingLock->Unlock();
    }


#endif
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::CreateUserDefinedStream
//
//  Synopsis:   Open the "DocumentSummaryInformation" stream in order
//              to create the UserDefined section of that property set.
//              Create the stream only if it doesn't already exist.
//
//  Arguments:  [pstg]     -- container storage
//              [psn]      -- the property set name
//              [grfMode]  -- mode of the property set
//              [fCreated] -- TRUE if Stream is created, FALSE if opened.
//              [ppStream] -- On return, the Stream for the property set
//
//  Notes:      This special case is necessary because this DocSumInfo
//              property set is the only one in which we support more
//              than one section.  For this property set, if the caller
//              Creates the second section, we must not *Create* the Stream,
//              because that would lose the first Section.  So, we must open it.
//
//              This routine is only called when creating the second
//              Section.  The first Section is created normally (note
//              that if the client creates the first section, the second
//              section is lost).
//
//              Also note that it may not be possible to open the Stream,
//              since it may already be opened.  This is significant
//              because it may not be obvious to the caller.  I.e.,
//              to a client of IPropertyStorage, the 2 sections are
//              distinct property sets, and you would think that you could
//              open them for simultaneous write.
//
//--------------------------------------------------------------------

HRESULT
CPropertySetStorage::CreateUserDefinedStream( IStorage *      pstg,
                         CPropSetName &  psn,
                         DWORD           grfMode,
                         BOOL *          pfCreated,
                         IStream **      ppStream )
{

    HRESULT hr;
    DWORD   grfOpenMode;

    // Calculate the STGM flags to use for the Open.  Create & Convert
    // don't have meaning for the Open, and Transacted isn't supported
    // by IPropertyStorage on the simple stream.

    grfOpenMode = grfMode & ~(STGM_CREATE | STGM_CONVERT | STGM_TRANSACTED);

    *pfCreated = FALSE;

    // Try an Open

    hr = pstg->OpenStream( psn.GetPropSetName(), NULL,
                           grfOpenMode,
                           0L, ppStream );

    // If the file wasn't there, try a create.

    if(( hr == STG_E_FILENOTFOUND ) || ( hr == STG_E_INVALIDFUNCTION))
    {
        hr = pstg->CreateStream(psn.GetPropSetName(), grfMode, 0, 0, ppStream);

        if( SUCCEEDED( hr ))
        {
            *pfCreated = TRUE;
        }
    }

    return( hr );

} // CPropertySetStorage::CreateUserDefinedStream
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\propstg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       propstg.cxx
//
//  Contents:   Class that directly implements IPropertyStorage
//
//  Classes:    CCoTaskAllocator
//              CPropertyStorage
//
//  Notes:      For methods that state 'if successful returns S_OK,
//              otherwise error code', the possible error codes include:
//
//                  STG_E_INVALIDHANDLE
//                  STG_E_INSUFFICIENTMEMORY
//                  STG_E_MEDIUMFULL
//                  STG_E_REVERTED
//                  STG_E_INVALIDPARAMETER
//                  STG_E_INVALIDFLAG
//
//  History:    1-Mar-95   BillMo      Created.
//             22-Feb-96   MikeHill    Use VT_EMPTY instead of VT_ILLEGAL.
//             14-Mar-96   MikeHill    Set _fUserDefinedProperties in open constructor.
//             09-May-96   MikeHill    Don't return an error when someone calls
//                                     IPropertyStorage::Revert on a direct-mode propset.
//             22-May-96   MikeHill    Use the new _dwOSVersion.
//             06-Jun-96   MikeHill    Validate inputs.
//             31-Jul-96   MikeHill    - Treat prop names as OLECHARs, not WCHARs
//                                     - Added CDocFilePropertyStorage
//                                     - Modified for Mac support.
//             07-Feb-97   Danl        - Removed CDocFilePropertyStorage.
//             10-Mar-98   MikeHill    - Only stat for the grfMode on create/open
//                                       if it wasn't provided by the caller.
//                                     - Dbg outputs.
//      5/6/98  MikeHill
//              -   Use CoTaskMem rather than new/delete.
//              -   Removed calls for defunct UnicodeCallouts.
//              -   Added dbgouts.
//              -   Changed GetCPropertySetStream to GetFormatVersion (DBG only).
//     5/18/98  MikeHill
//              -   Fixed typos.
//     6/11/98  MikeHill
//              -   Allow the codepage to change during WriteMultiple.
//     8/18/98  MikeHill
//              -   If the given _grfMode is zero, then probe the stream
//                  to see if it's actually writeable.
//              -   InitializePropertyStream now determines the CREATEPROP_
//                  flags internally.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#include <tstr.h>

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

#ifndef _MAC    // No InfoLevel debug functionality on Mac.
DECLARE_INFOLEVEL(prop)
#endif

#if DBG

extern "C" const IID
IID_IStorageTest = { /* 40621cf8-a17f-11d1-b28d-00c04fb9386d */
    0x40621cf8,
    0xa17f,
    0x11d1,
    {0xb2, 0x8d, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
  };
#endif // #if DBG

// The IMappedStream is implemented by all the IStream implementations,
// and provides a mapping for CPropertySetStream.

extern "C" const IID
IID_IMappedStream = { /* 7d747d7f-a49e-11d1-b28e-00c04fb9386d */
    0x7d747d7f,
    0xa49e,
    0x11d1,
    {0xb2, 0x8e, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
  };

//+-------------------------------------------------------------------
//
//  Member:     CCoTaskAllocator::Allocate, Free.
//
//  Synopsis:   A PMemoryAllocator used by the Pr*
//              property set routines.  This is required
//              so that those routines can work in any
//              heap.
//
//--------------------------------------------------------------------


void *
CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return( CoTaskMemAlloc(cbSize) );
}

void
CCoTaskAllocator::Free(void *pv)
{
    CoTaskMemFree( pv );
}


const OLECHAR g_oszPropertyContentsStreamName[] = OLESTR( "CONTENTS" );

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Initialize
//
//  Synopsis:   Initialize members to known values.
//
//--------------------------------------------------------------------

void CPropertyStorage::Initialize()
{
    _fExplicitelyProbedForWriteAccess = FALSE;
    _fUserDefinedProperties = FALSE;
    _ulSig = PROPERTYSTORAGE_SIG;
    _cRefs = 1;
    _pstgPropSet = NULL;
    _pstmPropSet = NULL;
    _dwOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;
    _np = NULL;
    _ms = NULL;
    _usCodePage = CP_WINUNICODE;
    _grfFlags = 0;
    _grfMode = 0;

#if DBG
    _cLocks = 0;
#endif

}


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::InitializePropertyStream.
//
//  Synopsis:   Initialize the storage-type specific members.
//
//  Arguments:  [pguid] -- FMTID, in for create only.
//              [pclsid] -- Class id, in for create only.
//              [CreateOpenDelete] -- has one of the following
//                  values: CREATE_PROPSTREAM, OPEN_PROPSTREAM, or
//                  DELETE_PROPSTREAM.
//
//  Returns:    HRESULT
//
//  Requires:
//              _pstmPropSet -- The IStream of the main property set stream.
//
//  Modifies:
//              _ms         (IMappedStream *)
//
//                          (assumed NULL on entry) will be NULL or valid on exit
//
//              _np         (NTPROP)         aka CPropertySetStream
//
//                          (assumed NULL on entry) will be NULL or valid on exit
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::InitializePropertyStream(
    const GUID *pguid,
    GUID const *pclsid,
    EInitializePropertyStream CreateOpenDelete )
{
    HRESULT hr = S_OK;
    DWORD grfBehavior = 0;
    USHORT createprop = 0;  // Flags parameter to PrCreatePropertySet

    propITrace( "CPropertyStorage::InitializePropertyStream" );
    AssertLocked();


    // Set the CREATEPROP_ flags in createprop

    if( CREATE_PROPSTREAM == CreateOpenDelete )
        createprop = CREATEPROP_CREATE;
    else if( DELETE_PROPSTREAM == CreateOpenDelete )
        createprop = CREATEPROP_DELETE;
    else
    {
        DfpAssert( OPEN_PROPSTREAM == CreateOpenDelete );

        // If _grfMode is zero, it's either uninitialized or STGM_READ|STGM_SHARE_DENYNONE.
        // We'll consider it unknown for now, and probe the stream later to see if it's
        // writeable.

        if( 0 == _grfMode )
            createprop = CREATEPROP_UNKNOWN;
        else
            createprop = IsWriteable() ? CREATEPROP_WRITE : CREATEPROP_READ;
    }

    if( IsNonSimple() )
        createprop |= CREATEPROP_NONSIMPLE;


    // In the create path, set the behavior flag that will be passed to
    // PrCreatePropertySet.  In the open path, this will be returned
    // from that function instead.

    if( PROPSETFLAG_CASE_SENSITIVE & _grfFlags
        &&
        CREATEPROP_CREATE & createprop )
    {
        grfBehavior = PROPSET_BEHAVIOR_CASE_SENSITIVE;
    }


    // Get an appropriate IMappedStream

    hr = CreateMappedStream();
    if( FAILED(hr) ) goto Exit;

    // Create the CPropertySetStream

    NTSTATUS Status;

    DfpAssert( NULL == _np );

    Status = PrCreatePropertySet(
                        (NTMAPPEDSTREAM)_ms,
                        createprop,
                        pguid,
                        pclsid,
                        (NTMEMORYALLOCATOR) &_cCoTaskAllocator,
                        GetUserDefaultLCID(),
                        &_dwOSVersion,
                        &_usCodePage,
                        &grfBehavior,
                        &_np);

    if (!NT_SUCCESS(Status))
    {
        propDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::InitializePropertyStream"
            " - PrCreatePropertySet Status=%08X\n", this, Status));
        hr = DfpNtStatusToHResult(Status);
        goto Exit;
    }

    // If this was a create, the input _grfFlags should match the Behavior
    DfpAssert( (PROPSETFLAG_CASE_SENSITIVE & _grfFlags) && (PROPSET_BEHAVIOR_CASE_SENSITIVE & grfBehavior)
               ||
               !(PROPSETFLAG_CASE_SENSITIVE & _grfFlags) && !(PROPSET_BEHAVIOR_CASE_SENSITIVE & grfBehavior)
               ||
               !(CREATEPROP_CREATE & createprop) );

    // Also if this was a create, the input _grfFlags should match the codepage
    DfpAssert( (PROPSETFLAG_ANSI & _grfFlags) && CP_WINUNICODE != _usCodePage
               ||
               !(PROPSETFLAG_ANSI & _grfFlags) && CP_WINUNICODE == _usCodePage
               ||
               !(CREATEPROP_CREATE & createprop) );

    // If this is an open, we need to update _grfFlags with the actual values,
    // so that we can return them in a Stat.

    if( CP_WINUNICODE != _usCodePage )
        _grfFlags |= PROPSETFLAG_ANSI;

    if( PROPSET_BEHAVIOR_CASE_SENSITIVE & grfBehavior )
        _grfFlags |= PROPSETFLAG_CASE_SENSITIVE;

Exit:

    if( STG_E_FILENOTFOUND == hr )
        propSuppressExitErrors();

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::~CPropertyStorage
//
//  Synopsis:   Free up object resources.
//
//  Notes:      Cleans up even from partial construction.
//
//--------------------------------------------------------------------

CPropertyStorage::~CPropertyStorage()
{
    HRESULT hr = S_OK;

    propITrace( "CPropertyStorage::~CPropertyStorage" );

#if DBG
    // We don't need to take the lock in a destructor, but
    // we're about to call private methods that assert that
    // the lock is held.  So, just to avoid the asserts
    // (and so we don't have to remove them), set the lock
    // count.
    _cLocks++;
#endif

    _ulSig = PROPERTYSTORAGE_SIGDEL; // prevent someone else deleting it

    // Close the property set.  This causes the latest mapped stream data to be
    // written to the underlying stream.  Errors are ignored, though, so 
    // clients should call Commit before calling the final release, in order
    // to get an opportunity to recover from flush errors.

    if (_np != NULL)
    {
        PrClosePropertySet(_np);
    }

    // Free the mapped stream.

    DeleteMappedStream();

    // Free the Stream and/or Storage with the serialized data.
    // If it was opened in direct mode, then the data written
    // during PrClosePropertySet will be implicitely commited.
    // If it was opened in transacted mode, then data written
    // in PrClosePropertySet will be reverted and lost (of course,
    // to avoid this, the client would have called IPropertyStorage::Commit).

    RELEASE_INTERFACE( _pstmPropSet );

    if( _pstgPropSet != NULL )
    {
        // If we're not opened in transacted mode, call Commit.
        // This was added to handle NFF (NTFS property sets), in which case
        // we open a direct IStorage, but it actually gives us a transacted
        // storage, for the purpose of robustness.
        // We tell IsWriteable not to probe the stream if it's unsure
        // about the _grfMode; return FALSE in that case.

        if( IsWriteable(DO_NOT_PROBE) && !(STGM_TRANSACTED & _grfMode) )
            _pstgPropSet->Commit( STGC_DEFAULT );

        RELEASE_INTERFACE( _pstgPropSet );
    }

    if (_fInitCriticalSection)
        DeleteCriticalSection( &_CriticalSection );
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown members
//
//  Notes:      IPropertyStorage supports IPropertyStorage and IUnknown
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = ValidateRef()))
        return(hr);

    // Validate the inputs

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----------------
    //  Perform the Query
    //  -----------------

    *ppvObject = NULL;

    if( IID_IPropertyStorage == riid || IID_IUnknown == riid )
    {
        *ppvObject = static_cast<IPropertyStorage*>(this);
        CPropertyStorage::AddRef();
    }

#if DBG
    else if( IID_IStorageTest == riid )
    {
        *ppvObject = static_cast<IStorageTest*>(this);
        CPropertyStorage::AddRef();
    }
#endif // #if DBG

    else
    {
        hr = E_NOINTERFACE;
    }

    return(hr);
}

ULONG   CPropertyStorage::AddRef(void)
{
    if (S_OK != ValidateRef())
        return(0);

    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

ULONG   CPropertyStorage::Release(void)
{
    LONG lRet;

    if (S_OK != ValidateRef())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;    // this will do a flush if dirty
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::CleanupOpenedObjects
//
//  Synopsis:   Cleans up the objects that have been opened
//              during the ReadMultiple.  Sets all entries to
//              VT_ILLEGAL so that the later free doesn't try to
//              treat the pointers as interface pointers.
//
//  Arguments:  [avar] -- The user's array of PROPVARIANTs
//
//              [pip] -- The array of INDIRECTPROPERTY structures
//                            for non-simple properties.
//
//              [cpspec] -- if 1 then no MAX_ULONG end of list marker.
//
//              [iFailIndex] -- An index into [pip] which
//                               indicates the non-simple property
//                               which failed to open, and represents
//                               the index at which the avar's begin
//                               to be strings rather than IStream's et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CPropertyStorage::CleanupOpenedObjects(
    PROPVARIANT avar[],
    INDIRECTPROPERTY *pip,
    ULONG cpspec,
    ULONG iFailIndex)
{
    HRESULT hr = S_OK;
    ULONG iStgProp;
    ULONG iiScan;

    propITrace( "CPropertyStorage::CleanupOpenedObjects" );
    AssertLocked();

    // Loop through the propvar array (avar) and release
    // the streams/storages that have been opened, and free
    // the strings for the indirects that have not yet been
    // opened.

    for (iiScan = 0;
        (iStgProp = pip[iiScan].Index) != MAX_ULONG;
        iiScan++)
    {
        PROPVARIANT *pPropVar = avar + iStgProp;

        // Are we before the failure point( thus stream/storage
        // properties have actually been opened)?

        if (iiScan < iFailIndex)
        {
            switch (pPropVar->vt)
            {
            case VT_STREAM:
            case VT_STREAMED_OBJECT:
                pPropVar->pStream->Release();
                break;
            case VT_STORAGE:
            case VT_STORED_OBJECT:
                pPropVar->pStorage->Release();
                break;
            }
        }
        else
        {
            CoTaskMemFree( pPropVar->pStream );
        }

        // Rather than return VT_EMPTY, which looks like a valid
        // property, return VT_ILLEGAL.

        pPropVar->vt = VT_ILLEGAL;
        pPropVar->pStream = NULL; // mark pStorage and pStream as nul

        // If cpspec is 1, then pip is not really an array, and
        // we have to explicitely break out (there isn't an array
        // terminator).

        if (cpspec == 1)
        {
            break;
        }
    }   // for (iiScan = 0; ...
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::ReadMultiple
//
//  Synopsis:   Read properties from the property set.
//
//  Arguments:  [cpspec] -- Count of PROPSPECs in [rgpspec]
//              [rgpspec] -- Array of PROPSPECs
//              [rgpropvar] -- Array of PROPVARIANTs to be filled in
//                             with callee allocated data.
//
//  Returns:    S_FALSE if none found
//              S_OK if >=1 found
//              FAILED(hr) otherwise.
//
//  Notes:      SPEC: Returning the same IStream* for the same
//              VT queried multiple times.
//
//              PrQueryProperties has been specified to return
//              useful data: the count of properties found (controls
//              return code) and an array of indexes of non-simple
//              PROPSPECs (useful for simply opening the storages and
//              streams.)  This extra returned data means we don't
//              have to walk the [rgpropvar] in the success cases.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::ReadMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[],
                PROPVARIANT             rgpropvar[])
{
    NTSTATUS Status;
    HRESULT hr;
    INDIRECTPROPERTY * pip = NULL; //array for non-simple
    INDIRECTPROPERTY ip = { 0, NULL };
    ULONG   cpropFound;
    BOOL    fLocked = FALSE;

    propXTrace( "CPropertyStorage::ReadMultiple" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate inputs

    if (0 == cpspec)
    {
        hr = S_FALSE;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    if (S_OK != (hr = ValidateOutRGPROPVARIANT( cpspec, rgpropvar )))
        goto errRet;

    propTraceParameters(( "cpspec=%d, rgpspec=%08X, rgpropvar=%08X",
                           cpspec, rgpspec, rgpropvar ));

    //  -------------------
    //  Read the Properties
    //  -------------------

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsReadable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    // Call CPropertySetStream

    Status = PrQueryProperties(
                    _np,
                    cpspec,
                    rgpspec,
                    NULL,   // don't want PROPID's
                    cpspec == 1 ? (INDIRECTPROPERTY**)&ip : &pip,
                    rgpropvar,
                    &cpropFound);

    // If that query worked, we have to post-process non-simple (aka "indirect")
    // properties.

    if (NT_SUCCESS(Status))
    {
        // Yes, it succeeded.  Did it actually find anything?

        if (cpropFound != 0)
        {
            // Yes, we got at least one property back.

            // For the special-case of reading one property, point pip
            // to ip (otherwise, the PrQueryProperties call allocated
            // pip as appropriate).

            if (cpspec == 1)
            {
                // Is there an indirect?
                if (ip.Index != MAX_ULONG)
                {
                    // Yes - point to it.
                    pip = &ip;
                }
                else
                {
                    // No, no indirect.
                    pip = NULL;
                }
            }

            // Do we have any indirects to deal with?

            if (pip != NULL)
            {

                // Yes, we have one or more of VT_STREAM, VT_STREAMED_OBJECT,
                // VT_STORAGE, VT_STORED_OBJECT, VT_VERSIONED_STREAM

                ULONG iiScan;
                ULONG iStgProp;

                // Loop through the pip array returned from PrQueryProperties

                for (iiScan = 0;
                     hr == S_OK && (iStgProp = pip[iiScan].Index) != MAX_ULONG;
                     iiScan++ )
                {
                    PROPVARIANT *pPropVar = rgpropvar + iStgProp;
                    OLECHAR **pposzStreamOrStorageName = NULL;

                    // Make sure we're a non-simple property set and the 
                    // stream/storage name isn't empty.

                    if (IsNonSimple() && pPropVar->pwszVal[0] != L'\0')
                    {
                        // Everything looks valid.

                        VOID *pStreamOrStorage = NULL;

                        // Open the stream or storage

                        switch (pPropVar->vt)
                        {
                            case VT_VERSIONED_STREAM:

                                pposzStreamOrStorageName
                                    = reinterpret_cast<OLECHAR**>( &(pPropVar->pVersionedStream->pStream) );
                                // Fall through

                            case VT_STREAM:
                            case VT_STREAMED_OBJECT:

                                if( NULL == pposzStreamOrStorageName )
                                {
                                    pposzStreamOrStorageName
                                        = reinterpret_cast<OLECHAR**>( &(pPropVar->pStream) );
                                }

                                // Open the stream.
                                // Mask out the STGM_TRANSACTED bit because we don't
                                // support transactioning on streams (of course, you can
                                // always open the whole property set transacted).

                                hr = _pstgPropSet->OpenStream(*pposzStreamOrStorageName,
                                        NULL,
                                        GetChildOpenMode() & ~STGM_TRANSACTED,
                                        0,
                                        (IStream**)&pStreamOrStorage);
                                break;

                            case VT_STORAGE:
                            case VT_STORED_OBJECT:

                                if( NULL == pposzStreamOrStorageName )
                                {
                                    pposzStreamOrStorageName
                                        = reinterpret_cast<OLECHAR**>( &(pPropVar->pStorage) );
                                }

                                hr = _pstgPropSet->OpenStorage(*pposzStreamOrStorageName,
                                        NULL,
                                        GetChildOpenMode(),
                                        NULL,
                                        0,
                                        (IStorage**)&pStreamOrStorage);
                                break;

                            default:

                                DfpAssert( !OLESTR("Invalid non-simple property type") );
                                hr = HRESULT_FROM_WIN32( ERROR_INTERNAL_ERROR );

                        }   // switch (pPropVar->vt)

                        // Did we open the stream/storage?

                        if (hr == S_OK)
                        {
                            // Yes, it's open.

                            // The pStream/pStorage entry currently points to a string
                            // (the name of the stream/storage).  Delete that string buffer
                            // and put in the real stream/storage interface pointer.

                            CoTaskMemFree( *pposzStreamOrStorageName );
                            *pposzStreamOrStorageName = reinterpret_cast<OLECHAR*>( pStreamOrStorage );

                        }
                        else if (hr != STG_E_FILENOTFOUND)
                        {
                            // The one that fails is passed in as
                            // iiScan and is still a string.
                            CleanupOpenedObjects(rgpropvar, pip, cpspec, iiScan);
                        }
                    }   // if (IsNonSimple() && pPropVar->pwszVal[0] != L'\0')
                    else
                    {
                        hr = STG_E_FILENOTFOUND;
                    }

                    // Special handling for the case where the stream/storage
                    // didn't exist.

                    if (hr == STG_E_FILENOTFOUND)
                    {
                        // If the stream/storage is not found, or this is
                        // a simple stream with VT_STORAGE etc, then treat
                        // like the property is not found.

                        if( VT_VERSIONED_STREAM == pPropVar->vt )
                        {
                            pPropVar->pVersionedStream->pStream->Release();
                            CoTaskMemFree( pPropVar->pVersionedStream );
                        }
                        else
                        {
                            CoTaskMemFree( pPropVar->pszVal );
                        }

                        PropVariantInit( pPropVar );
                        --cpropFound;
                        hr = S_OK;
                    }

                    // Special handling for the single property case.  In this
                    // case pip isn't really an array, so there's no array
                    // terminator.

                    if (cpspec == 1)
                        break;

                }   // for (iiScan = 0;

                // If pip is really an array (not a pointer to ip), then
                // free it now.

                if (cpspec != 1 && pip != NULL)
                    CoTaskMemFree( pip );

            }   // if (pip != NULL)

            if (hr != S_OK)
            {
                // We succeeded in getting the basic property types but
                // the non-simple stuff failed, so we zap out the whole lot
                // and return a complete failure

                FreePropVariantArray(cpspec, rgpropvar);
            }
        }

        // Return a special success code if we didn't find anything.

        if (hr == S_OK && cpropFound == 0)
        {
            hr = S_FALSE;
        }
    }   // if (NT_SUCCESS(Status))

    else
    {
        hr = DfpNtStatusToHResult(Status);
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    if( HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) == hr )
        propSuppressExitErrors();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::_WriteMultiple, private
//
//  Synopsis:   Write the properties to the property set.  Allows
//              a NULL rgpropvar pointer for deletion case.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//
//              [rgpspec] -- pointer to array of PROPSPECs
//
//              [rgpropvar] -- pointer to array of PROPVARIANTs with
//                           the values to write.
//
//              [propidNameFirst] -- id below which not to assign
//                           ids for named properties.
//
//
//  Returns:    S_OK,   -- all requested data was written.
//              S_FALSE -- all simple properties written, but non-simple
//                         types (VT_STREAM etc) were ignored.
//              Errors  --
//
//  Modifies:
//
//  Derivation:
//
//  Notes:      PrSetProperties has been carefully specified to return
//              useful information so that we can deal with the case
//              where a non-simple type (VT_STREAM etc) is overwritten
//              by a simple type.
//
//              This routine assumes the object has been validated
//              and is writeable.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::_WriteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[],
                const PROPVARIANT       rgpropvar[],
                PROPID                  propidNameFirst)
{
    HRESULT             hr;
    NTSTATUS            Status;
    CStackPropIdArray   rgPROPID;

    INDIRECTPROPERTY *  pip = NULL;
    INDIRECTPROPERTY    ip = { 0, NULL };

    if (S_OK != (hr = rgPROPID.Init(cpspec)))
        return(hr);

    propITrace( "CPropertyStorage::_WriteMultiple" );
    AssertLocked();

    Status = PrSetProperties(_np,   // property set context
                cpspec,             // property count
                propidNameFirst,    // first propid for new named props
                rgpspec,            // array of property specifiers
                &_usCodePage,       // updated CodePage
                rgPROPID,           // buffer for array of propids
                                    // the stream/storage names for indirect properties
                1 == cpspec ? (INDIRECTPROPERTY**)&ip : &pip,
                rgpropvar);

    if (NT_SUCCESS(Status))
    {
        // The code page may have been modified. Update grfFlags to
        // reflect the current value.

        if( CP_WINUNICODE == _usCodePage )
            _grfFlags &= ~PROPSETFLAG_ANSI;
        else
            _grfFlags |= PROPSETFLAG_ANSI;

        // For the special case where pip is really &ip, point it
        // to that INDIRECTPROPERTY array

        if (cpspec == 1)
        {
            if (ip.Index != MAX_ULONG)
                pip = &ip;
            else
                pip = NULL;
        }

        // If we have indirect properties, write them out now.

        if ( pip != NULL)
        {
            ULONG iiScan;   // in this scope because we always use
            ULONG iStgProp; // these variables in the free memory loop below.

            if (IsSimple())
            {
                //
                // VT_STREAM was requested to be written and this
                // is a "SIMPLE" property set.
                //
                hr = STG_E_PROPSETMISMATCHED;
            }
            else
            {
                //
                // Two cases now:
                // 1.  Wrote a simple over a non-simple -- must delete the
                //     old non-simple.
                // 2.  Wrote a non-simple -- must actually copy data into it.
                //

                // Loop through the INDIRECTPROPERTY array.

                for (iiScan = 0;
                     hr == S_OK &&
                     (iStgProp = pip[iiScan].Index) != MAX_ULONG;
                     iiScan++ )
                {

                    OLECHAR oszStdPropName[ PROPGENPROPERTYNAME_SIZEOF ];
                    const OLECHAR *poszPropName;
                    const PROPVARIANT *pPropVar = rgpropvar + iStgProp;
                    IStream *pstmFrom = NULL;

                    poszPropName = static_cast<LPOLESTR>(pip[iiScan].poszName);

                    // If PrSetProperties didn't return us the indirect name,
                    // generate it now (does this ever happen?)

                    if( NULL == poszPropName )
                    {
                        DfpAssert((LONG) iStgProp >= 0 && iStgProp < cpspec);
                        PROPGENPROPERTYNAME_CB( oszStdPropName,
                                                PROPGENPROPERTYNAME_SIZEOF,
                                                rgPROPID[iStgProp] );
                        poszPropName = oszStdPropName;
                    }

                    DfpAssert( NULL != poszPropName );

                    // Switch on the input property type.

                    switch (rgpropvar == NULL ? VT_ILLEGAL : pPropVar->vt)
                    {
                        case VT_VERSIONED_STREAM:
                        case VT_STREAM:
                        case VT_STREAMED_OBJECT:
                            {
                                // We're writing some kind of stream

                                IStream *pstm;
                                int i=0;

                                if( VT_VERSIONED_STREAM == pPropVar->vt )
                                    pstmFrom = pPropVar->pVersionedStream->pStream;
                                else
                                    pstmFrom = pPropVar->pStream;

                                while (i<=1)
                                {
                                    // Create the stream

                                    hr = _pstgPropSet->CreateStream(poszPropName,
                                                                    GetChildCreateMode() & ~STGM_TRANSACTED,
                                                                    0, 0, &pstm);

                                    if (hr == S_OK)
                                    {   
                                        // The create worked.  If the property being 
                                        // written was non-NULL (NULL is OK), copy it
                                        // to the new stream.

                                        if( NULL != pstmFrom )
                                        {
                                            ULARGE_INTEGER uli;
                                            memset(&uli, -1, sizeof(uli));
                                            hr = pstmFrom->CopyTo(pstm, uli, NULL, NULL);
                                        }

                                        // Release the stream we just created.

                                        pstm->Release();
                                        break;
                                    }

                                    // We might be able to handle file-exists, but
                                    // anything else is an error.

                                    else if (hr != STG_E_FILEALREADYEXISTS)
                                    {
                                        break;
                                    }

                                    // If this is the first pass and we got a file-exists,
                                    // delete it and try the create again.  (Why is this
                                    // necessary, since the create above used STGM_CREATE?)

                                    else if (i == 0)
                                    {
                                        _pstgPropSet->DestroyElement(poszPropName);
                                    }

                                    i++;
                                }   // while (i<=1)
                            }   // Stream-type cases

                            break;

                        case VT_STORAGE:
                        case VT_STORED_OBJECT:
                            {
                                // We're writing some kind of storage

                                IStorage *pstg;
                                int i=0;

                                while (i<=1)
                                {
                                    // Create the sub-storage

                                    hr = _pstgPropSet->CreateStorage(poszPropName,
                                            GetChildCreateMode(),
                                            0,
                                            0,
                                            &pstg);

                                    if (hr == S_OK)
                                    {
                                        // The create worked.
                                        // If the input storage was non-NULL (though
                                        // NULL is OK), copy the input to the new one.

                                        if (pPropVar->pStorage != NULL)
                                        {
                                            hr = pPropVar->pStorage->CopyTo(0, NULL,
                                                    NULL, pstg);
                                        }

                                        // Release the newly-created storage

                                        pstg->Release();
                                        break;
                                    }

                                    // We might be able to handle file-exists, but
                                    // anything else is fatal.

                                    else if (hr != STG_E_FILEALREADYEXISTS)
                                    {
                                        break;
                                    }

                                    // If we got file-exists, try deleting it and
                                    // trying the create again.  (I don't understand
                                    // why this is necessary, given that we used
                                    // STGM_CREATE on the create above.)

                                    else if (i == 0)
                                    {
                                        _pstgPropSet->DestroyElement(poszPropName);
                                    }
                                    i++;
                                }
                            }   // Storage-type properties

                            break;

                        default:

                            //
                            // Any other VT_ type is simple and therefore
                            // was a non-simple overwritten by a simple.
                            //

                            hr = _pstgPropSet->DestroyElement( poszPropName );
                            break;
                    }

                    // Special-case handling for a single write (since 
                    // pip doesn't really point to an array).

                    if (cpspec == 1)
                        break;

                }   // for (iiScan = 0; ...
            }   // if (IsSimple())

            // In both the success and failure cases we do this cleanup.

            for (iiScan = 0; pip[iiScan].Index != MAX_ULONG; iiScan++ )
            {
                if (pip[iiScan].poszName != NULL)
                    CoTaskMemFree( pip[iiScan].poszName );

                if (cpspec == 1)
                    break;
            }

            // If pip is an allocated array, free it.

            if (cpspec != 1 && pip != NULL)
                CoTaskMemFree( pip );

        }   // if ( pip != NULL)

        else
        {
            //
            // No VT_STREAM etc was requested to be written.
            // and no simple property overwrote a non-simple one.
        }
    }   // if (NT_SUCCESS(Status))

    else
    {
        hr = DfpNtStatusToHResult(Status);
    }

    if( HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) == hr )
        propSuppressExitErrors();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::WriteMultiple
//
//  Synopsis:   Write properties.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//              [rgpspec] -- pointer to array of PROPSPECs
//              [rgpropvar] -- pointer to array of PROPVARIANTs with
//                           the values to write.
//              [propidNameFirst] -- id below which not to assign
//                           ids for named properties.
//
//  Returns:    S_OK,   -- all requested data was written.
//              S_FALSE -- all simple properties written, but non-simple
//                         types (VT_STREAM etc) were ignored.
//              Errors  --
//
//  Notes:      Checks that rgpropvar is not NULL, then calls
//              _WriteMultiple.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::WriteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[],
                const PROPVARIANT       rgpropvar[],
                PROPID                  propidNameFirst)
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::WriteMultiple" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    if (0 == cpspec)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    if (S_OK != (hr = ValidateInRGPROPVARIANT( cpspec, rgpropvar )))
        goto errRet;

    propTraceParameters(( "cpspec=%d, rgpspec=%08X, rgpropvar=%08X, propidNameFirst=%d",
                          cpspec, rgpspec, rgpropvar, propidNameFirst ));

    // Ensure we understand all the VarTypes in the input array.

    hr = ValidateVTs( cpspec, rgpropvar );
    if( FAILED(hr) ) goto errRet;

    //  --------------------
    //  Write the Properties
    //  --------------------

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    // Try to write the properties

    hr = _WriteMultiple(cpspec, rgpspec, rgpropvar, propidNameFirst);

    // If we ran out of memory, try writing them one at a time.
    // (?? I'm really not sure that this will help, but billmo probably
    // put it in here to handle some boundary case where we do an alloc
    // porpotional to the number of input properties.)

    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;

        for (ULONG i=0; hr == S_OK && i < cpspec; i++)
        {
            hr = _WriteMultiple(1, rgpspec+i, rgpropvar+i, propidNameFirst);
            if( FAILED(hr) ) goto errRet;
        }
    }
    if( FAILED(hr) ) goto errRet;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
            goto errRet;
        }
    }

    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    if( HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) == hr )
        propSuppressExitErrors();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::DeleteMultiple
//
//  Synopsis:   Delete properties.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//              [rgpspec] -- pointer to array of PROPSPECs
//
//  Returns:    S_OK,   -- all requested data was deleted.
//              S_FALSE -- all simple properties written, but non-simple
//                         types (VT_STREAM etc) were ignored.
//              Errors  --
//
//  Notes:      Checks that rgpropvar is not NULL, then calls
//              _WriteMultiple.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::DeleteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[])
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::DeleteMultiple" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    if (0 == cpspec)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    propTraceParameters(( "cpspec=%d, rgpspec=%08X", cpspec, rgpspec ));

    //  ---------------------
    //  Delete the Properties
    //  ---------------------

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    // The way you delete properties is by calling write
    // with no values.

    hr = _WriteMultiple(cpspec, rgpspec, NULL, 2);

    // If that fails due to low mem, try again, one property at
    // a time.

    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;

        for (ULONG i=0; hr == S_OK && i < cpspec; i++)
        {
            hr = _WriteMultiple(1, rgpspec+i, NULL, 2);
            if( FAILED(hr) ) goto errRet;
        }
    }
    if( FAILED(hr) ) goto errRet;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
            goto errRet;
        }
    }

    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::ReadPropertyNames
//
//  Synopsis:   Attempt to read names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK -- success, one or more names returned
//              S_FALSE -- success, no names returned
//              STG_E_INVALIDHEADER -- no propid->name mapping property
//              other errors -- STG_E_INSUFFICIENTMEMORY etc
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::ReadPropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                LPOLESTR                rglpwstrName[])
{
    HRESULT hr;
    NTSTATUS Status;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::ReadPropertyNames" );

    //  --------
    //  Validate
    //  --------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    if (0 == cpropid)
    {
        // Nothing failed, but we didn't find anything either.
        hr = S_FALSE;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    if (S_OK != (hr = ValidateOutRGLPOLESTR( cpropid, rglpwstrName )))
        goto errRet;

    propTraceParameters(( "cpropid=%d, rgpropid=%08X, rglpwstrName=%08X",
                           cpropid, rgpropid, rglpwstrName ));

    //  --------------
    //  Read the Names
    //  --------------

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsReadable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    // Query the property names out of the proeprty set.

    Status = PrQueryPropertyNames(_np, cpropid, rgpropid, rglpwstrName);
    if (Status == STATUS_NOT_FOUND)
        hr = STG_E_INVALIDHEADER;
    else if (Status == STATUS_BUFFER_ALL_ZEROS)
        hr = S_FALSE;  // None of the properties were found
    else if (!NT_SUCCESS(Status))
        hr = DfpNtStatusToHResult(Status);


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::_WritePropertyNames
//
//  Synopsis:   Internal function used by WritePropertyNames and
//              DeletePropertyNames.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK if successful, otherwise error code.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::_WritePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                const LPOLESTR          rglpwstrName[])
{
    NTSTATUS Status;
    AssertLocked();

    Status = PrSetPropertyNames(_np, cpropid, rgpropid, (OLECHAR const * const *) rglpwstrName);
    return NT_SUCCESS(Status) ? S_OK : DfpNtStatusToHResult(Status);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::WritePropertyNames
//
//  Synopsis:   Attempt to write names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK -- success, otherwise error code.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::WritePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                const LPOLESTR          rglpwstrName[])
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::WritePropertyNames" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate inputs

    if (0 == cpropid)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    if (S_OK != (hr = ValidateInRGLPOLESTR( cpropid, rglpwstrName )))
        goto errRet;

    propTraceParameters(( "cpropid=%d, rgpropid=%08X, rglpwstrName=%08X",
                          cpropid, rgpropid, rglpwstrName ));

    //  ---------------
    //  Write the Names
    //  ---------------

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    hr = _WritePropertyNames(cpropid, rgpropid, rglpwstrName);

    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;

        for (ULONG i=0; hr == S_OK && i < cpropid; i++)
        {
            hr = _WritePropertyNames(1, rgpropid+i, rglpwstrName+i);
            if( FAILED(hr) ) goto errRet;
        }
    }
    if( FAILED(hr) ) goto errRet;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::DeletePropertyNames
//
//  Synopsis:   Attempt to delete names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//
//  Returns:    S_OK -- success, otherwise error.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::DeletePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[])
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::DeletePropertyNames" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    if( 0 == cpropid )
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    propTraceParameters(( "cpropid=%d, rgpropid=%08X)", cpropid, rgpropid ));

    //  ----------------
    //  Delete the Names
    //  ----------------

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    // Delete names by "writing" a NULL name.

    hr = _WritePropertyNames(cpropid, rgpropid, NULL);
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;

        for (ULONG i=0; hr == S_OK && i < cpropid; i++)
        {
            hr = _WritePropertyNames(1, rgpropid+i, NULL);
            if( FAILED(hr) ) goto errRet;
        }
    }
    if( FAILED(hr) ) goto errRet;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Commit
//
//  Synopsis:   Flush and/or commit the property set
//
//  Arguments:  [grfCommittFlags] -- Commit flags.
//
//  Returns:    S_OK -- success, otherwise error.
//
//  Notes:      For both simple and non-simple, this flushes the
//              memory image to disk subsystem.  In addition,
//              for non-simple transacted-mode property sets, this
//              performs a commit on the property set.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Commit(DWORD grfCommitFlags)
{
    HRESULT  hr;
    NTSTATUS Status;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::Commit" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    if (S_OK != (hr = VerifyCommitFlags(grfCommitFlags)))
        goto errRet;

    propTraceParameters(( "grfCommitFlags=%08X", grfCommitFlags ));

    //  --------------------------
    //  Commit the PropertyStorage
    //  --------------------------

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    Status = PrFlushPropertySet(_np);
    if (!NT_SUCCESS(Status))
    {
        hr = DfpNtStatusToHResult(Status);
    }

    if (IsNonSimple())
    {
        if (hr == S_OK)
            hr = _pstgPropSet->Commit(grfCommitFlags);
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Revert
//
//  Synopsis:   For non-simple property sets, revert it.
//
//  Returns:    S_OK if successful.  STG_E_UNIMPLEMENTEDFUNCTION for
//              simple property sets.
//
//  Notes:      For non-simple property sets, call the underlying
//              storage's Revert and re-open the 'contents' stream.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Revert()
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::Revert" );

    if (S_OK != (hr = Validate()))
        goto errRet;

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    // We can only do something if we're in a transacted storage 
    // (i.e. we're non-simple and transacted).

    if (IsNonSimple())
    {
        // Try to revert our storage.

        hr = _pstgPropSet->Revert();
        if (hr == S_OK)
        {
            // That worked.  Actually, if we weren't opened transacted mode
            // in the first place (_pstgPropSet isn't transacted), then that
            // call was just ignored.  But we'll go ahead as if it worked.
            // This should be changed (bug 569182); otherwise you can get some
            // unpredictable behavior when the mapped stream tries to
            // flush itself belof in PrClosePropertySet.  If that fails,
            // then the content of your property set is different after this
            // Revert call completes.

            // Close the propert set.  The mapped stream will attempt
            // to flush itself, but it will just get a reverted error, which
            // we ignore.

            PrClosePropertySet(_np);
            _np = NULL;

            // Release the contents stream (the main property set stream)

            _pstmPropSet->Release();
            _pstmPropSet = NULL;

            // Release _ms

            DeleteMappedStream();

            // If one of these fails then this object becomes invalid (zombie)
            // Mask out the STGM_TRANSACTED bit because we don't support it.

            hr = _pstgPropSet->OpenStream(g_oszPropertyContentsStreamName, NULL,
                                          GetChildOpenMode() & ~STGM_TRANSACTED,
                                          0, &_pstmPropSet);
            if (hr == S_OK)
            {
                // Initialize the property set.  If this property set is the 2nd section
                // of the DocumentSummaryInformation property set (used by Office),
                // then we must specify the FMTID.

                hr = InitializePropertyStream(
                        _fUserDefinedProperties ? &FMTID_UserDefinedProperties : NULL,
                        NULL,       // pguid
                        OPEN_PROPSTREAM );
            }

            // If it didn't work, go into the zombie state.

            if (hr != S_OK)
            {
                _ulSig = PROPERTYSTORAGE_SIGZOMBIE;
            }
        }

    }

    else
    {
        // Docfile returns S_OK when you try to revert a direct-mode
        // object.
        hr = S_OK;
    }


errRet:

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Enum
//
//  Synopsis:   Create an enumerator over the property set.
//
//  Arguments:  [ppenum] -- where to return the IEnumSTATPROPSTG *
//
//  Returns:    S_OK or error.
//
//  Notes:      The constructor of CEnumSTATPROPSTG creates a
//              CStatArray which reads the entire property set and
//              which can be shared when IEnumSTATPROPSTG::Clone is
//              used.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Enum(IEnumSTATPROPSTG ** ppenum)
{
    HRESULT hr;
    BOOL fLocked = FALSE;
    IStatArray *psa = NULL;
    IEnumSTATPROPSTG *penum = NULL;

    propXTrace( "CPropertyStorage::Enum" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate the inputs

    VDATEPTROUT( ppenum, IEnumSTATPROPSTG* );
    *ppenum = NULL;

    propTraceParameters(( "ppenum=%p", ppenum ));

    hr = Lock();
    if( FAILED(hr) ) goto Exit;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto Exit;
    }

    if( !IsReadable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto Exit;
    }

    //  ----------------------
    //  Create the Enumeration
    //  ----------------------

    // Create an array for the STATPROPSTG structures.
    // This allows the data to be shared between multiple
    // instances of the same enumeration.

    psa = (IStatArray*) new CStatArray( _np, &hr );
    if( NULL == psa )
        hr = STG_E_INSUFFICIENTMEMORY;
    if( FAILED(hr) ) goto Exit;

    // Create the enumerator.

    penum = new CEnumSTATPROPSTG( psa );
    if( NULL == penum )
    {
        hr = STG_E_INSUFFICIENTMEMORY;
        goto Exit;
    }

    *ppenum = penum;
    penum = NULL;

    //  ----
    //  Exit
    //  ----

Exit:

    RELEASE_INTERFACE( penum );
    RELEASE_INTERFACE( psa );

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::SetTimes
//
//  Synopsis:   Set the given times on the underlying storage
//
//  Arguments:  [pctime] -- creation time
//              [patime[ -- access time
//              [pmtime] -- modify time
//
//  Returns:    S_OK or error.
//
//  Notes:
//              (non-simple only)  Only the times supported by the
//              underlying docfile implementation are
//              supported.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::SetTimes(
                FILETIME const *        pctime,
                FILETIME const *        patime,
                FILETIME const *        pmtime)
{
    HRESULT hr;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::SetTimes" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    VDATEPTRIN_LABEL( pctime, FILETIME, errRet, hr );
    VDATEPTRIN_LABEL( patime, FILETIME, errRet, hr );
    VDATEPTRIN_LABEL( pmtime, FILETIME, errRet, hr );

    propTraceParameters(( "pctime=%08x:%08x, patime=%08x:%08x, pmtime=%08x:%08x",
                          pctime->dwHighDateTime, pctime->dwLowDateTime,
                          patime->dwHighDateTime, patime->dwLowDateTime,
                          pmtime->dwHighDateTime, pmtime->dwLowDateTime ));

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    //  -------------
    //  Set the Times
    //  -------------

    if (IsNonSimple())
    {
        hr = _pstgPropSet->SetElementTimes(
                NULL,
                pctime,
                patime,
                pmtime);
        if( FAILED(hr) ) goto errRet;
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::SetClass
//
//  Synopsis:   Sets the class of the property set.
//
//  Arguments:  [clsid] -- class id to set.
//
//  Returns:    S_OK or error.
//
//  Notes:      If non-simple, the underlying storage has SetClass
//              called.  Both simple and non-simple will have
//              clsid set into the property set stream.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::SetClass(REFCLSID clsid)
{
    HRESULT hr;
    NTSTATUS Status;
    BOOL fLocked = FALSE;
    DBGBUF(buf);

    propXTrace( "CPropertyStorage::SetClass" );

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the inputs

    GEN_VDATEREADPTRIN_LABEL(&clsid, CLSID, E_INVALIDARG, errRet, hr);

    propTraceParameters(( "clsid=%s", DbgFmtId(clsid, buf) ));

    //  -------------
    //  Set the CLSID
    //  -------------

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsWriteable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    // Set it in the property set header

    Status = PrSetPropertySetClassId(_np, &clsid);
    if (NT_SUCCESS(Status))
    {
        // And if this is an IStorage, set it there as well.
        if (IsNonSimple())
        {
            hr = _pstgPropSet->SetClass(clsid);
        }
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }
    if( FAILED(hr) ) goto errRet;

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Stat
//
//  Synopsis:   Get STATPROPSETSTG about the property set.
//
//  Arguments:  [p] -- STATPROPSETSTG *
//
//  Returns:    S_OK if successful, error otherwise.  On failure,
//              *p is all zeros.
//
//  Notes:      See spec.  Gets times from underlying storage or stream
//              using IStorage or IStream ::Stat.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Stat(STATPROPSETSTG * pstatpropsetstg)
{
    HRESULT hr;
    NTSTATUS Status;
    BOOL fLocked = FALSE;

    propXTrace( "CPropertyStorage::Stat" )

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate inputs

    VDATEPTROUT_LABEL(pstatpropsetstg, STATPROPSETSTG, errRet, hr);

    propTraceParameters(( "STATPROPSETSTG *p = %08X", pstatpropsetstg ));

    //  ------------
    //  Get the Stat
    //  ------------

    hr = Lock();
    if( FAILED(hr) ) goto errRet;
    fLocked = TRUE;

    if( IsReverted() )
    {
        hr = STG_E_REVERTED;
        goto errRet;
    }

    if( !IsReadable() )
    {
        hr = STG_E_ACCESSDENIED;
        goto errRet;
    }

    ZeroMemory(pstatpropsetstg, sizeof(*pstatpropsetstg));

    // Get what info we can from the property set itself
    // (mtime, ansi flag, clsid, fmtid)

    Status = PrQueryPropertySet(_np, pstatpropsetstg);
    if (NT_SUCCESS(Status))
    {
        // Get the rest of the info for the STATPROPSETSTG, which
        // comes from the underlying stream/storage.

        STATSTG statstg;

        hr = S_OK;

        if( NULL != _pstgPropSet || NULL != _pstmPropSet )
        {
            if (IsNonSimple())
            {
                hr = _pstgPropSet->Stat(&statstg, STATFLAG_NONAME);
            }
            else
            {
                hr = _pstmPropSet->Stat(&statstg, STATFLAG_NONAME);
            }

            if (hr == S_OK)
            {
                pstatpropsetstg->mtime = statstg.mtime;
                pstatpropsetstg->ctime = statstg.ctime;
                pstatpropsetstg->atime = statstg.atime;
                pstatpropsetstg->grfFlags = _grfFlags;
                pstatpropsetstg->dwOSVersion = _dwOSVersion;
            }
        }
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }

    if (FAILED(hr))
    {
        ZeroMemory(pstatpropsetstg, sizeof(*pstatpropsetstg));
    }


    //  ----
    //  Exit
    //  ----

errRet:

    if( fLocked )
        Unlock();

    return(hr);
}



//+-------------------------------------------------------------------
//
//  Member:     CStatArray::CStatArray
//
//--------------------------------------------------------------------

CStatArray::CStatArray(NTPROP np, HRESULT *phr)
{
    NTSTATUS Status;
    ULONG ulKeyZero;
    ULONG cpropAllocated;

    _cpropActual = 0;
    _cRefs = 1;
    _psps = NULL;

    do
    {
        //  when *pkey == 0, *pcprop == MAXULONG, aprs == NULL and asps == NULL on input,
        // *pcprop will be the total count of properties in the enumeration set.  OLE needs to
        // allocate memory and enumerate out of the cached PROPID+propname list.

        ulKeyZero = 0;
        _cpropActual = MAX_ULONG;

        CoTaskMemFree( _psps );
        _psps = NULL;

        Status = PrEnumerateProperties(
                np,
                ENUMPROP_NONAMES,
                &ulKeyZero,
                &_cpropActual,
                NULL,   // aprs
                NULL);

        if (!NT_SUCCESS(Status))
            break;

        cpropAllocated = _cpropActual + 1;

        _psps = reinterpret_cast<STATPROPSTG*>
                ( CoTaskMemAlloc( sizeof(STATPROPSTG) * cpropAllocated ) );
        if (_psps == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ulKeyZero = 0;
        Status = PrEnumerateProperties(
                np,
                0,
                &ulKeyZero,
                &cpropAllocated,
                NULL,   // aprs
                _psps);

    } while (NT_SUCCESS(Status) && cpropAllocated != _cpropActual);

    *phr = NT_SUCCESS(Status) ? S_OK : DfpNtStatusToHResult(Status);
}

//+-------------------------------------------------------------------
//
//  Member:     CStatArray::~CStatArray
//
//  Synopsis:   Deallocated the object's data.
//
//--------------------------------------------------------------------

CStatArray::~CStatArray()
{
    if( NULL != _psps )
    {
        STATPROPSTG *psps = _psps;

        while( _cpropActual )
        {
            CoTaskMemFree( psps->lpwstrName );
            _cpropActual--;
            psps++;
        }

        CoTaskMemFree( _psps );
    }
}


//+----------------------------------------------------------------------------
//
//	Member:		CStatArray::  QueryInterface/AddRef/Release
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CStatArray::QueryInterface( REFIID riid, void **ppvObject)
{
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CStatArray::AddRef(void)
{
    LONG lRet;

    lRet = InterlockedIncrement(&_cRefs);
    return(lRet);
}

STDMETHODIMP_(ULONG) CStatArray::Release(void)
{
    LONG lRet;

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}


//+-------------------------------------------------------------------
//
//  Member:     CStatArray::NextAt
//
//  Synopsis:   Read from the internal STATPROPSTG array.
//
//  Effects:    The cursor is passed in, and this function acts
//              as a IEnumXX::Next would behave if the current cursor
//              was [ipropNext].
//
//  Arguments:  [ipropNext] -- index of cursor to use
//              [pspsDest] -- if NULL, emulate read's effect on cursor.
//                            if non-NULL, return data with cursor effect.
//              [pceltFetched] -- buffer for count fetched
//
//  Returns:    STATUS_SUCCESS if successful, otherwise
//              STATUS_INSUFFICIENT_RESOURCES.
//
//  Notes:
//
//--------------------------------------------------------------------

NTSTATUS
CStatArray::NextAt(ULONG ipropNext, STATPROPSTG *pspsDest, ULONG *pceltFetched)
{
    ULONG   ipropLastPlus1;

    //
    // Copy the requested number of elements from the cache
    // (including strings, the allocation of which may fail.)
    //

    ipropLastPlus1 = ipropNext + *pceltFetched;
    if (ipropLastPlus1 > _cpropActual)
    {
        ipropLastPlus1 = _cpropActual;
    }

    *pceltFetched = ipropLastPlus1 - ipropNext;

    if (pspsDest != NULL)
        return CopySTATPROPSTG(*pceltFetched, pspsDest, _psps + ipropNext);
    else
        return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::CEnumSTATPROPSTG
//
//  Synopsis:   Constructor which is used by IEnumSTATPROPSTG::Clone.
//
//  Arguments:  [other] -- the CEnumSTATPROPSTG to copy
//              [phr] -- the error code.
//
//  Notes:      Since the CStatArray actually contains the object this
//              just adds to the ref count.
//
//--------------------------------------------------------------------

CEnumSTATPROPSTG::CEnumSTATPROPSTG(const CEnumSTATPROPSTG & other )
{
    _ulSig = ENUMSTATPROPSTG_SIG;
    _cRefs = 1;

    _psa = other._psa;
    _psa->AddRef();

    _ipropNext = other._ipropNext;

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::~CEnumSTATPROPSTG
//
//  Synopsis:   Deallocated storage.
//
//  Arguments:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------

CEnumSTATPROPSTG::~CEnumSTATPROPSTG()
{
    _ulSig = ENUMSTATPROPSTG_SIGDEL;    // prevent another thread doing it - kinda

    RELEASE_INTERFACE( _psa );
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::QueryInterface
//
//  Synopsis:   Respond to IEnumSTATPROPSTG and IUnknown.
//
//  Returns:    S_OK  or E_NOINTERFACE
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    *ppvObject = NULL;

    if (S_OK != (hr = Validate()))
        return(hr);

    if (IsEqualIID(riid, IID_IEnumSTATPROPSTG))
    {
        *ppvObject = (IEnumSTATPROPSTG *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = (IUnknown *)this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::AddRef
//
//  Synopsis:   Add 1 to ref count.
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSTG::AddRef(void)
{
	long cRefs;

    if (S_OK != Validate())
        return(0);

    cRefs = InterlockedIncrement(&_cRefs);
    return(cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Release
//
//  Synopsis:   Subtract 1 from ref count and delete if 0.
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSTG::Release(void)
{
    LONG lRet;

    if (S_OK != Validate())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Function:   CopySTATPROPSTG
//
//  Synopsis:   Copy out the range of elements from [pspsSrc] to
//              [pspsDest].
//
//  Arguments:  [celt] -- count of elements to copy
//              [pspsDest] -- where to copy to, always filled with
//                          zeros before anything else (helps cleanup
//                          case.)
//
//              [pspsSrc] -- where to copy from
//
//  Returns:    STATUS_SUCCESS if ok, otherwise
//              STATUS_INSUFFICIENT_RESOURCES in which case there
//              may be pointers that need deallocating.  Use
//              CleanupSTATPROPSTG to do that.
//
//--------------------------------------------------------------------

NTSTATUS
CopySTATPROPSTG(ULONG celt,
            STATPROPSTG * pspsDest,
            const STATPROPSTG * pspsSrc)
{
    memset(pspsDest, 0, sizeof(*pspsDest) * celt);

    while (celt)
    {
        *pspsDest = *pspsSrc;

        if (pspsSrc->lpwstrName != NULL)
        {
            ULONG cbName = sizeof(OLECHAR)*( 1 + ocslen(pspsSrc->lpwstrName) );
            pspsDest->lpwstrName = reinterpret_cast<OLECHAR*>
                                   ( CoTaskMemAlloc( cbName ));
            if (pspsDest->lpwstrName != NULL)
            {
                StringCbCopy( pspsDest->lpwstrName, cbName, pspsSrc->lpwstrName );
            }
            else
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        celt--;
        pspsDest++;
        pspsSrc++;
    }

    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Next
//
//  Synopsis:   Get the next [celt] STATPROPSTGs from the enumerator.
//
//  Arguments:  [celt] -- count requested.
//              [rgelt] -- where to return them
//              [pceltFetched] -- buffer for returned-count.
//                  if pceltFetched==NULL && celt != 1 -> STG_E_INVALIDPARAMETER
//                  if pceltFetched!=NULL && celt == 0 -> S_OK
//
//  Returns:    S_OK if successful, otherwise error.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Next(
             ULONG                   celt,
             STATPROPSTG *           rgelt,
             ULONG *                 pceltFetched)
{
    HRESULT hr;
    NTSTATUS Status;
    ULONG   celtFetched = celt;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate the inputs

    if (NULL == pceltFetched)
    {
        if (celt != 1)
            return(STG_E_INVALIDPARAMETER);
    }
    else
    {
        VDATEPTROUT( pceltFetched, ULONG );
        *pceltFetched = 0;
    }

    if( 0 == celt )
        return( S_OK );

    if( !IsValidPtrOut(rgelt, celt * sizeof(rgelt[0])) )
        return( E_INVALIDARG );


    //  -----------------------
    //  Perform the enumeration
    //  -----------------------

    if (celt == 0)
        return(hr);

    Status = _psa->NextAt(_ipropNext, rgelt, &celtFetched);

    if (NT_SUCCESS(Status))
    {
        _ipropNext += celtFetched;

        if (pceltFetched != NULL)
            *pceltFetched = celtFetched;

        hr = celtFetched == celt ? S_OK : S_FALSE;
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }

    return(hr);

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Skip
//
//  Synopsis:   Skip the next [celt] elements in the enumeration.
//
//  Arguments:  [celt] -- number of elts to skip
//
//  Returns:    S_OK if skipped [celt] elements
//              S_FALSE if skipped < [celt] elements
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Skip(ULONG celt)
{
    HRESULT hr;
    ULONG celtFetched = celt;

    if (S_OK != (hr = Validate()))
        return(hr);

    _psa->NextAt(_ipropNext, NULL, &celtFetched);

    _ipropNext += celtFetched;

    return celtFetched == celt ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Reset
//
//  Synopsis:   Set cursor to beginnging of enumeration.
//
//  Returns:    S_OK otherwise STG_E_INVALIDHANDLE.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Reset()
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    _ipropNext = 0;

    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Clone
//
//  Synopsis:   Creates an IEnumSTATPROPSTG with same cursor
//              as this.
//
//  Arguments:  S_OK or error.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Clone(IEnumSTATPROPSTG ** ppenum)
{
    HRESULT hr = S_OK;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate the input

    VDATEPTROUT( ppenum, IEnumSTATPROPSTG* );
    *ppenum = NULL;

    //  --------------------
    //  Clone the enumerator
    //  --------------------

    *ppenum = new CEnumSTATPROPSTG( *this );

    if( NULL == *ppenum )
        hr = STG_E_INSUFFICIENTMEMORY;

    return(hr);
}




//+----------------------------------------------------------------------------
//
//  Function:   Lock & Unlock
//
//  Synopsis:   This methods take and release the CPropertyStorage's
//              critical section.
//
//  Inputs:     none
//
//  Returns:    Nothing
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyStorage::Lock(void)
{
    HRESULT hr = S_OK;

#ifndef _MAC

    if( _fInitCriticalSection )
    {
        EnterCriticalSection( &_CriticalSection );

        #if DBG
            _cLocks++;
        #endif
    }
    else
        hr = E_OUTOFMEMORY;

#endif

    return hr;

}

HRESULT
CPropertyStorage::Unlock()
{
    HRESULT hr = S_OK;

#if DBG
    --_cLocks;
    DfpAssert( 0 <= _cLocks );
#endif

#ifndef _MAC

    if( _fInitCriticalSection )
        LeaveCriticalSection( &_CriticalSection );
    else
        hr = E_OUTOFMEMORY;
#endif

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   CPropertyStorage::ProbeStreamToDetermineIfWriteable
//
//  Synopsis:   Probes the IStream which holds the property set to see if it
//              can be written.  Ordinarily we know whether or not a stream
//              is writeable either because we were given the grfMode or
//              because we Stat-ed it out of the stream.  But this code
//              was added for the case where IStream::Stat returns zero
//              for the grfMode but it's actually writeable (this happens
//              with CreateStreamOnHGlobal).  So a grfMode of zero is a hint
//              that the IStream may not support that value in the Stat.
//
//              This method should be called lazily the first time a modify
//              operation is called on the property set, because it will
//              cause an update to the last-modify time of the stream.
//
//  Inputs:     none
//
//  Returns:    TRUE if the stream is writeable.  Also sets
//              _fExplicitelyProbedForWriteAccess so that we don't call this
//              twice.
//
//+----------------------------------------------------------------------------

BOOL
CPropertyStorage::ProbeStreamToDetermineIfWriteable()
{
    HRESULT hr = S_OK;
    BOOL fWriteable = FALSE;
    BYTE FirstByte;
    LARGE_INTEGER liZero = {0};
    ULONG cbRead = 0;

    propITrace( "CPropertyStorage::ProbeStreamToDetermineIfWriteable" );
    AssertLocked();
    DfpAssert( !_fExplicitelyProbedForWriteAccess );

    // This routine is only called once

    _fExplicitelyProbedForWriteAccess = TRUE;

    // Read then write a byte

    hr = _pstmPropSet->Seek( liZero, STREAM_SEEK_SET, NULL );
    if( FAILED(hr) ) goto Exit;

    hr = _pstmPropSet->Read( &FirstByte, 1, &cbRead );
    if( SUCCEEDED(hr) && 1 != cbRead )
        hr = STG_E_INVALIDHEADER;
    if( FAILED(hr) ) goto Exit;

    hr = _pstmPropSet->Seek( liZero, STREAM_SEEK_SET, NULL );
    if( FAILED(hr) ) goto Exit;

    hr = _pstmPropSet->Write( &FirstByte, 1, NULL );
    if( FAILED(hr) ) goto Exit;

    // If the write worked, then this stream is really STGM_READWRITE

    fWriteable = TRUE;
    _grfMode |= STGM_READWRITE;

Exit:

    propDbg((DEB_ITRACE, "Property Set %p %s writeable (hr=%08x)\n",
            this, fWriteable?"is":"isn't", hr ));

    return( fWriteable );

}


//+-----------------------------------------------------------------------
//
//  Member:     InitializeOnCreateOrOpen
//
//  Synopsis:   This routine is called during the creation or opening
//              of a Property Storage, and initializes everything
//              it can without being concerned about whether this
//              is a simple or non-simple property set.
//
//  Inputs:     [DWORD] grfFlags (in)
//                  From the PROPSETFLAG_* enumeration.
//              [DWORD] grfMode (in)
//                  From the STGM_* enumeration.
//              [REFFMTID] rfmtid (in)
//                  The ID of the property set.
//              [BOOL] fCreate (in)
//                  Distinguishes Create from Open.
//
//  Returns:    [HRESULT]
//
//  Effects:    _grfFlags, _grfMode, _fUserDefinedProperties,
//              and g_ReservedMemory.
//
//+-----------------------------------------------------------------------


HRESULT
CPropertyStorage::InitializeOnCreateOrOpen(
                                      DWORD grfFlags,
                                      DWORD grfMode,
                                      REFFMTID rfmtid,
                                      BOOL fCreate )
{
    HRESULT hr = S_OK;

    propITrace( "CPropertyStorage::InitializeOnCreateOrOpen" );
    AssertLocked();

    // If the caller didn't give us a grfMode, stat for it.

    if( 0 == grfMode )
    {
        STATSTG statstg;    
        DfpAssert( NULL != _pstgPropSet || NULL != _pstmPropSet );

        if( NULL != _pstgPropSet )
            hr = _pstgPropSet->Stat( &statstg, STATFLAG_NONAME );
        else
            hr = _pstmPropSet->Stat( &statstg, STATFLAG_NONAME );

        if( FAILED(hr) ) goto Exit;
        grfMode = statstg.grfMode;
    }

    // Validate that grfFlags is within the enumeration.
    if (grfFlags & ~(PROPSETFLAG_ANSI | PROPSETFLAG_NONSIMPLE | PROPSETFLAG_UNBUFFERED | PROPSETFLAG_CASE_SENSITIVE))
    {
        hr = STG_E_INVALIDFLAG;
        goto Exit;
    }

    hr = CheckFlagsOnCreateOrOpen( fCreate, grfMode );
    if (hr != S_OK)
    {
        goto Exit;
    }

    // Store the grfFlags & grfMode.
    _grfFlags = grfFlags;

    _grfMode = grfMode;

    // Is this the special-case second-section property set?
    _fUserDefinedProperties = ( rfmtid == FMTID_UserDefinedProperties ) ? TRUE : FALSE;

    // If creating an Ansi property set, default the code page.

    if (fCreate
        &&
        (_grfFlags & PROPSETFLAG_ANSI) )
    {
        _usCodePage = static_cast<USHORT>(GetACP());
    }

    // Initialize the global reserved memory (to prevent problems
    // in low-memory conditions).

    if (S_OK != (hr = g_ReservedMemory.Init()))
        goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    return( hr );


}   // CPropertyStorage::InitializeOnCreateOrOpen()



//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Create( IStream * ...
//
//  Synopsis:   This method creates an IPropertyStorage on a
//              given *Stream*.  It is therefore a simple property
//              set.  The given Stream is addref-ed.
//
//  Arguments:  [IStream*] pstm
//                  The Stream which will hold the serialized property set.
//              [REFFMTID] rfmtid
//                  The ID of the property set.
//              [const CLSID*]
//                  The COM object which can interpret the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_* enumeration.
//              [DWORD] grfMode
//                  From the STGM_* enumeration.  If 0, we use Stat.
//              [HRESULT*]
//                  The return code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::Create(
                IStream       *pstm,
                REFFMTID      rfmtid,
                const CLSID   *pclsid,
                DWORD         grfFlags,
                DWORD         grfMode
                )
{
    HRESULT hr = S_OK;
    BOOL fCreated = FALSE;
    BOOL    fLocked = FALSE;

    propITrace( "CPropertyStorage::Create(IStream*)" );
    propTraceParameters(( "pstm=%p, rfmtid=%s, grfFlags=%s, grfMode=%s, fDelete=%s",
                          pstm,
                          static_cast<const char*>(CStringize(rfmtid)),
                          static_cast<const char*>(CStringize(*pclsid)),
                          static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))) ));

    // Save and addref the Stream.

    _pstmPropSet = pstm;
    _pstmPropSet->AddRef();

    hr = Lock();
    if( FAILED(hr) ) goto Exit;
    fLocked = TRUE;

    // Initialize this object

    DfpAssert( !(PROPSETFLAG_NONSIMPLE & grfFlags ));
    hr = InitializeOnCreateOrOpen( grfFlags, grfMode, rfmtid,
                                   TRUE ); // => Create
    if( FAILED(hr) ) goto Exit;

    DfpAssert( !IsNonSimple() );

    // Initialize the Stream (this causes a CPropertySetStream to be created
    // and stored in '_np').

    hr = InitializePropertyStream( &rfmtid, pclsid, CREATE_PROPSTREAM );
    if( FAILED(hr) ) goto Exit;

    // If buffering is not desired, flush the initial property storage
    // to the underlying Stream.

    if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // On error, remove our reference to the Stream.
    if( FAILED(hr) )
    {
        _pstmPropSet->Release();
        _pstmPropSet = NULL;

        propDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::Create(IStream*)"
            " hr=%08X\n", this, hr));
    }

    if( fLocked )
        Unlock();

    return( hr );

}   // CPropertyStorage::Create( IStream *, ...


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Create( IStorage *, ...
//
//  Synopsis:   This method creates an IPropertyStorage on a
//              given *Storage*.  It is therefore a non-simple property
//              set.  The Storage is addref-ed.
//
//  Arguments:  [IStorage*] pstm
//                  The Storage which will hold the serialized property set.
//              [REFFMTID] rfmtid
//                  The ID of the property set.
//              [const CLSID*]
//                  The COM object which can interpret the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_* enumeration.
//              [HRESULT*]
//                  The return code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::Create(
                IStorage      *pstg,
                REFFMTID      rfmtid,
                const CLSID   *pclsid,
                DWORD         grfFlags,
                DWORD         grfMode
                )
{
    HRESULT hr = S_OK;
    BOOL fCreated = FALSE;
    BOOL    fLocked = FALSE;
    STATSTG statstg = { NULL };

    propITrace( "CPropertyStorage::Create(IStorage*)" );
    propTraceParameters(( "pstg=%p, rfmtid=%s, grfFlags=%s, grfMode=%s, fDelete=%s",
                          pstg,
                          static_cast<const char*>(CStringize(rfmtid)),
                          static_cast<const char*>(CStringize(*pclsid)),
                          static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))) ));

    // Save the given Storage.

    _pstgPropSet = pstg;
    _pstgPropSet->AddRef();

    hr = Lock();
    if( FAILED(hr) ) goto Exit;
    fLocked = TRUE;

    // Initialize this object.

    DfpAssert( grfFlags & PROPSETFLAG_NONSIMPLE );
    hr = InitializeOnCreateOrOpen( grfFlags, grfMode, rfmtid,
                                   TRUE ); // => Create
    if( FAILED(hr) ) goto Exit;

    DfpAssert( IsNonSimple() );

    // Create the "CONTENTS" stream.  Mask out the STGM_TRANSACTED
    // bit because we don't support it.

    hr = _pstgPropSet->CreateStream(g_oszPropertyContentsStreamName,
                                    GetChildCreateMode() & ~STGM_TRANSACTED,
                                    0, 0, &_pstmPropSet);
    if (FAILED(hr)) goto Exit;
    fCreated = TRUE;

    // Initialize the CONTENTS Stream.

    hr = InitializePropertyStream( &rfmtid, pclsid, CREATE_PROPSTREAM );
    if( FAILED(hr) ) goto Exit;

    // In the transacted case, ensure that the contents
    // stream is actually published right away.
    // The logic is this ... if you have a storage and create a transacted
    // child storage, that child storage is complete and intact to the parent.
    // If you then revert the child, or make no changes to it, the parent still
    // has a valid (albeit empty) storage.  Now, say you do the same thing, but
    // the transacted child is a property set.  As it stands at this point in this
    // method, the parent can only see an empty storage.  For it to see a valid
    // (empty) property set child, it must see the Contents stream, along with its default
    // data (header, codepage, etc.).  In order to make this happen, we must
    // commit (not just flush) this storage that holds a property set.
    //
    // There's one more complication.  Even if this is a direct mode property 
    // set, the _pstgPropSet may be transacted nonetheless, for the purpose of
    // robustness (this happens in NFF).  So, we need to commit not if
    // _grfMode is transacted, but if _pstgPropSet says that it's transacted.

    hr = _pstgPropSet->Stat( &statstg, STATFLAG_NONAME );
    if( FAILED(hr) ) goto Exit;

    if( STGM_TRANSACTED & statstg.grfMode )
    {
        hr = Commit(STGC_DEFAULT);
        if( FAILED(hr) ) goto Exit;

    }

    // If buffering is not desired, flush the property storage
    // to the underlying Stream.

    else if( _grfFlags & PROPSETFLAG_UNBUFFERED )
    {
        NTSTATUS Status = PrFlushPropertySet(_np);
        if (!NT_SUCCESS(Status))
        {
            hr = DfpNtStatusToHResult(Status);
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // On error, remove our reference to the Storage.

    if( FAILED(hr) )
    {
        _pstgPropSet->Release();
        _pstgPropSet = NULL;

        // Also, delete the "CONTENTS" stream.
        if( fCreated )
            pstg->DestroyElement( g_oszPropertyContentsStreamName );

        propDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::Create(IStorage*)"
            " hr=%08X\n", this, hr));
    }

    if( fLocked )
        Unlock();

    return( hr );

}   // CPropertyStorage::Create( IStorage *, ...


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Open( IStream * ...
//
//  Synopsis:   This method opens an IPropertyStorage on a
//              given *Stream*.  It is therefore a simple property
//              set.  The Stream is addref-ed.
//
//  Arguments:  [IStream*] pstm
//                  The Stream which will hold the serialized property set.
//              [REFFMTID] rfmtid
//                  The ID of the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_ enumeration.  Only the
//                  _UNBUFFERED flag is relevant _ANSI and
//                  _NONSIMPLE are inferred from the property set.
//              [BOOL] fDelete
//                  If TRUE, the property set is actually to be deleted,
//                  rather than opened (this is used for the special-case
//                  "UserDefined" property set).
//              [HRESULT*]
//                  The return code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::Open(
                IStream *pstm,
                REFFMTID  rfmtid,
                DWORD     grfFlags,
                DWORD     grfMode,
                BOOL      fDelete
                )
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    propITrace( "CPropertyStorage::Open(IStream*)" );
    propTraceParameters(( "pstm=%p, rfmtid=%s, grfFlags=%s, grfMode=%s, fDelete=%s",
                          pstm,
                          static_cast<const char*>(CStringize(rfmtid)),
                          static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))),
                          fDelete ? "True":"False" ));

    // Keep a copy of the Stream.

    _pstmPropSet = pstm;
    _pstmPropSet->AddRef();

    hr = Lock();
    if( FAILED(hr) ) goto Exit;
    fLocked = TRUE;

    // Initialize this object.

    hr = InitializeOnCreateOrOpen( grfFlags,
                                   grfMode,
                                   rfmtid,
                                   FALSE ); // => Open
    if( FAILED(hr) ) goto Exit;

    // Only simple sections may be deleted (really, only the
    // second section of the DocumentSummaryInformation property
    // set may be deleted in this way).

    DfpAssert( !fDelete || !IsNonSimple() );

    // Initialize the property set Stream.

    if (hr == S_OK)
    {
        // sets up _usCodePage
        hr = InitializePropertyStream(
                &rfmtid,
                NULL,
                fDelete ? DELETE_PROPSTREAM : OPEN_PROPSTREAM );

    }
    if( FAILED(hr) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    // On error, remove our reference to the Stream.

    if( FAILED(hr) )
    {
        _pstmPropSet->Release();
        _pstmPropSet = NULL;

        propDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::Open(IStream*)"
            " hr=%08X\n", this, hr));
    }

    if( fLocked )
        Unlock();

    return( hr );

}   // CPropertyStorage::Open( IStream *, ...


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Open( IStorage * ...
//
//  Synopsis:   This method opens an IPropertyStorage on a
//              given *Storage*.  It is therefore a non-simple property
//              set.  The Storage is addref-ed.
//
//  Arguments:  [IStorage*] pstg
//                  The Storage which will hold the serialized property set.
//              [REFFMTID] rfmtid
//                  The ID of the property set.
//              [DWORD] grfFlags
//                  From the PROPSETFLAG_ enumeration.  Only the
//                  _UNBUFFERED flag is relevant _ANSI and
//                  _NONSIMPLE are inferred from the property set.
//              [HRESULT*]
//                  The return code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::Open(
                IStorage *pstg,
                REFFMTID  rfmtid,
                DWORD     grfFlags,
                DWORD     grfMode
                )
{
    HRESULT hr = S_OK;
    CPropSetName psn(rfmtid);
    USHORT createprop = 0L;
    BOOL    fLocked = FALSE;

    propITrace( "CPropertyStorage::Open(IStorage*)" );
    propTraceParameters(( "pstg=%p, rfmtid=%s, grfFlags=%s, grfMode=%s",
                          pstg,
                          static_cast<const char*>(CStringize(rfmtid)),
                          static_cast<const char*>(CStringize(SGrfFlags(grfFlags))),
                          static_cast<const char*>(CStringize(SGrfMode(grfMode))) ));


    // Keep a copy of the Storage

    _pstgPropSet = pstg;
    _pstgPropSet->AddRef();

    hr = Lock();
    if( FAILED(hr) ) goto Exit;
    fLocked = TRUE;

    // Initialize this object.

    hr = InitializeOnCreateOrOpen( grfFlags,
                                   grfMode,
                                   rfmtid,
                                   FALSE ); // => Open
    if( FAILED(hr) ) goto Exit;

    _grfFlags |= PROPSETFLAG_NONSIMPLE;

    // Open the CONTENTS stream.  Mask out the STGM_TRANSACTED bit
    // because it causes an error on Mac OLE2.

    hr = _pstgPropSet->OpenStream( g_oszPropertyContentsStreamName,
                                   0,
                                   GetChildOpenMode() & ~STGM_TRANSACTED,
                                   0,
                                   &_pstmPropSet );
    if( FAILED(hr) ) goto Exit;


    // Load the property set Stream.

    if (hr == S_OK)
    {
        // sets up _usCodePage
        hr = InitializePropertyStream(
                &rfmtid,
                NULL,
                OPEN_PROPSTREAM );

    }
    if( FAILED(hr) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    // On error, remove our reference to the Storage.

    if( FAILED(hr) )
    {
        _pstgPropSet->Release();
        _pstgPropSet = NULL;

        if( NULL != _pstmPropSet )
        {
            _pstmPropSet->Release();
            _pstmPropSet = NULL;
        }

        propDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::Open(IStorage*)"
            " hr=%08X\n", this, hr));
    }

    if( fLocked )
        Unlock();

    return( hr );

}   // CPropertyStorage::Open( IStorage *, ...


//+----------------------------------------------------------------
//
//  Member:     CPropertyStorage::CreateMappedStream
//
//  Synopsis:   Create a IMappedStream object on an IStream.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      This method calls QI through the PropSet Stream to see if
//              a mapped stream exists.  If it doesn't then this
//              method creates a IMappedStream which maps
//              an IStream.
//
//+----------------------------------------------------------------

HRESULT
CPropertyStorage::CreateMappedStream()
{
    HRESULT hr;

    DfpAssert( NULL != _pstmPropSet );
    DfpAssert( NULL == _ms );
    AssertLocked();
    propITrace( "CPropertyStorage::CreateMappedStream" );

    // QI the property set's IStream, if asked to do so, for an IMappedstream.

    if( MAPPED_STREAM_QI == _fMSOpts )
    {
        hr = _pstmPropSet->QueryInterface(IID_IMappedStream,(void**)&_ms);
        if (SUCCEEDED(hr))
        {
            // We got a mapped stream, so we're done.
            propDbg(( DEB_INFO, "Using QI-ed IMappedStream\n" ));
            goto Exit;
        }
    }

    // Either we couldn't get a mapped stream from the IStream, or
    // we were told not to ask for one.  In either case, we'll
    // create our own.

    hr = S_OK;

    _ms = (IMappedStream *) new CSSMappedStream( _pstmPropSet );
    if( NULL == _ms )
        hr = E_OUTOFMEMORY;
    else
        propDbg(( DEB_INFO, "Using CSSMappedStream\n" ));

Exit:
    return( hr );
}

VOID
CPropertyStorage::DeleteMappedStream()
{
    AssertLocked();

    if (NULL != _ms) {
        _ms->Release();
    }
    _ms = NULL;
}



#if DBG

HRESULT
CPropertyStorage::UseNTFS4Streams( BOOL fUseNTFS4Streams )
{
    IStorageTest *pPropStgTest = NULL;
    HRESULT hr = S_OK;

    if( NULL != _pstmPropSet )
        hr = _pstmPropSet->QueryInterface( IID_IStorageTest,
                                           reinterpret_cast<void**>(&pPropStgTest) );
    else if( NULL != _pstgPropSet )
        hr = _pstgPropSet->QueryInterface( IID_IStorageTest,
                                           reinterpret_cast<void**>(&pPropStgTest) );
    else
        hr = STG_E_NOMOREFILES;
    if( FAILED(hr) ) goto Exit;

    hr = pPropStgTest->UseNTFS4Streams( fUseNTFS4Streams );
    if( FAILED(hr) ) goto Exit;

Exit:

    if( NULL != pPropStgTest )
        pPropStgTest->Release();

    return( hr );

}   // CPropertyStorage::UseNTFS4Streams()
#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CPropertyStorage::GetFormatVersion (IStorageTest) **DBG**
//
//  Get the property set's wFormatVersion field.
//
//+----------------------------------------------------------------------------

#if DBG
HRESULT
CPropertyStorage::GetFormatVersion(WORD *pw)
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    CPropertySetStream *pPropertySetStream = (CPropertySetStream*) _np;

    status = pPropertySetStream->Lock( TRUE );
    if( !NT_SUCCESS(status) ) goto Exit;

    pPropertySetStream->ReOpen( &status );
    if( !NT_SUCCESS(status) ) goto Exit;

    *pw = pPropertySetStream->GetFormatVersion();
    status = STATUS_SUCCESS;

Exit:

    if( !NT_SUCCESS(status) )
        hr = DfpNtStatusToHResult(status);

    pPropertySetStream->Unlock();
    return( hr );
}
#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CPropertyStorage::SimulateLowMemory (IStorageTest) **DBG**
//
//  Forcable turn on the low-memory support in the IMappedStream implementation.
//
//+----------------------------------------------------------------------------

#if DBG
HRESULT
CPropertyStorage::SimulateLowMemory( BOOL fSimulate )
{
    IStorageTest *pPropStgTest = NULL;
    HRESULT hr = S_OK;

    if( NULL != _pstmPropSet )
        hr = _pstmPropSet->QueryInterface( IID_IStorageTest,
                                           reinterpret_cast<void**>(&pPropStgTest) );
    else if( NULL != _pstgPropSet )
        hr = _pstgPropSet->QueryInterface( IID_IStorageTest,
                                           reinterpret_cast<void**>(&pPropStgTest) );
    else
        hr = STG_E_NOMOREFILES;
    if( FAILED(hr) ) goto Exit;

    hr = pPropStgTest->SimulateLowMemory( fSimulate );
    if( FAILED(hr) ) goto Exit;

Exit:

    if( NULL != pPropStgTest )
        pPropStgTest->Release();

    return( hr );
}
#endif  // #if DBG


#if DBG
HRESULT
CPropertyStorage::GetLockCount()
{
    return( E_NOTIMPL );
}
#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CPropertyStorage::IsDirty (IStorageTest) **DBG**
//
//  Determine if the IMappedStream is dirty.
//
//+----------------------------------------------------------------------------

#if DBG
HRESULT
CPropertyStorage::IsDirty()
{
    HRESULT hr = S_OK;
    IStorageTest *ptest = NULL;

    if( NULL == _ms )
    {
        hr = S_FALSE;
        goto Exit;
    }

    hr = _ms->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&ptest) );
    if( FAILED(hr) ) goto Exit;

    hr = ptest->IsDirty();

Exit:

    RELEASE_INTERFACE(ptest);
    return( hr );

}
#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CPropertyStorage::ValidateVTs
//
//  Validate the VTs in an array of PropVariants.  If we see a type we don't
//  understand, return error_not_supported.
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyStorage::ValidateVTs( ULONG cprops, const PROPVARIANT rgpropvar[] )
{
    HRESULT hr = S_OK;
    propITrace( "CPropertyStorage::ValidateVTs" );
    propTraceParameters(( "cprops=%d, rgpropvar=%p", cprops, rgpropvar ));

    for( ULONG i = 0; i < cprops; i++ )
    {
        if( !IsSupportedVarType( rgpropvar[i].vt ) )
        {
            propDbg(( DEB_IWARN, "Unsupported VarType in ValidateVTs: 0x%x\n", rgpropvar[i].vt ));
            hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            propSuppressExitErrors();
            goto Exit;
        }
    }

Exit:

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\reserved.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       reserved.cxx
//
//  Contents:   Class that implements reserved memory for properties.
//              This implementation is in the form of two derivations
//              of the CReservedMemory class.
//
//  Classes:    CWin32ReservedMemory
//              CWin31ReservedMemory
//
//  History:    1-Mar-95   BillMo      Created.
//              29-Aug-96  MikeHill    Split CReservedMemory into CWin31 & CWin32
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#include "reserved.hxx"

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

// Instantiate the appropriate object.

#ifdef _MAC
    CWin31ReservedMemory g_ReservedMemory;
#else
    CWin32ReservedMemory g_ReservedMemory;
#endif


//+----------------------------------------------------------------------------
//
//  Method:     CWin32ReservedMemory::_Init
//
//  Synopsis:   Prepare as much as possible during initialization, in order
//              to be able to provide memory in LockMemory.
//
//  Inputs:     None.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------


#ifndef _MAC

HRESULT
CWin32ReservedMemory::_Init(VOID)
{
    HRESULT hr = E_FAIL;
    SID_IDENTIFIER_AUTHORITY Sa = SECURITY_CREATOR_SID_AUTHORITY;
    ULONG cInits;

    // Ensure this method is called once and only once.  This
    // is necessary since this class is implemented as a global
    // variable.

    cInits = InterlockedIncrement( &_cInits );
    if( 1 < cInits )
    {
        // We've already been initialized (probably simultaneously
        // in another thread).  NOTE: This leaves one small race where
        // this thread really needs to use the reserved memory before
        // the other thread has finished initializing it.  If that window
        // is hit, it won't cause a corruption, but will cause an out-of-mem
        // error to occur.

        InterlockedDecrement( &_cInits );
        hr = S_OK;
        goto Exit;
    }


    // Create a creator/owner SID.  We'll give the creator/owner
    // full access to the temp file.

    if( !AllocateAndInitializeSid( &Sa,                           // Top-level authority
                                   1,
                                   SECURITY_CREATOR_OWNER_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &_pCreatorOwner ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        _pCreatorOwner = NULL;
        goto Exit;
    }

    // Create a DACL that just gives the Creator/Owner full access.

    if (!InitializeAcl( &_DaclBuffer.acl, sizeof(_DaclBuffer), ACL_REVISION))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    if (!AddAccessAllowedAce( &_DaclBuffer.acl,
                              ACL_REVISION,
                              STANDARD_RIGHTS_ALL | GENERIC_ALL,
                              _pCreatorOwner
                              ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Set up the security descriptor with that DACL in it.

    InitializeSecurityDescriptor( &_sd, SECURITY_DESCRIPTOR_REVISION );
    if( !SetSecurityDescriptorDacl( &_sd, TRUE, &_DaclBuffer.acl, FALSE ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Put the security descriptor into the security attributes.

    memset( &_secattr, 0, sizeof(_secattr) );
    _secattr.nLength = sizeof(SECURITY_ATTRIBUTES);
    _secattr.lpSecurityDescriptor = &_sd;
    _secattr.bInheritHandle = FALSE;

    // Initialize the critical section.

    __try
    {
        InitializeCriticalSection( &_critsec );
        _fInitialized = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32( GetExceptionCode() );
        goto Exit;
    }

    hr = S_OK;

Exit:

    return hr;

}

#endif  // #ifndef _MAC


//+----------------------------------------------------------------------------
//
//  Method:     CWin32ReservedMemory::~CWin32ReservedMemory
//
//  Inputs:     N/A
//
//  Returns:    N/A
//
//+----------------------------------------------------------------------------

#ifndef _MAC

CWin32ReservedMemory::~CWin32ReservedMemory()
{
    if( _fInitialized )
        DeleteCriticalSection( &_critsec );

    if( NULL != _pCreatorOwner )
        FreeSid( _pCreatorOwner );

    FreeResources();

}



//+----------------------------------------------------------------------------
//
//  Method:     CWin32ReservedMemory::FreeResources
//
//  Inputs:     N/A
//
//  Returns:    Void
//
//  Synopsis:   Free the view, the mapping, and the file.
//
//+----------------------------------------------------------------------------

void
CWin32ReservedMemory::FreeResources()
{
    if( NULL != _pb )
    {
        UnmapViewOfFile( _pb );
        _pb = NULL;
    }

    if( NULL != _hMapping )
    {
        CloseHandle( _hMapping );
        _hMapping = NULL;
    }

    if( INVALID_HANDLE_VALUE != _hFile )
    {
        CloseHandle( _hFile );
        _hFile = INVALID_HANDLE_VALUE;
    }

}

#endif  // #ifndef _MAC


//+----------------------------------------------------------------------------
//
//  Method:     CWin32ReservedMemory::LockMemory
//
//  Synopsis:   Use a temporary file to get enough memory to hold the
//              largest possible property set and return a pointer to
//              that mapping.
//
//  Inputs:     None.
//
//  Returns:    Lock() returns a pointer to the locked memory.
//
//+----------------------------------------------------------------------------

#ifndef _MAC


BYTE * CWin32ReservedMemory::LockMemory(VOID)
{

    WCHAR wszTempFileName[ MAX_PATH + 64 ];
    ULONG cchPath = 0;

    // If for some reason initialization failed, there's nothing we can do,
    // we'll return NULL.

    if( !_fInitialized )
        goto Exit;
    
    // Lock down this class until the caller has completed.
    // This isn't really necessary, since this class could be
    // a member variable instead of a global, but that is too
    // much of a change for NT5.

    EnterCriticalSection( &_critsec );

    // Get the temp directory.

    cchPath = GetTempPath( MAX_PATH + 1, wszTempFileName );
    if( 0 == cchPath || cchPath > MAX_PATH + 1 )
        goto Exit;

    // Create a temporary file.  We can't use GetTempFileName, because it creates
    // the file, and consequently the DACL we pass in on CreateFile gets ignored.

    SYSTEMTIME st;
    FILETIME ft;
    GetSystemTime( &st );
    SystemTimeToFileTime( &st, &ft );

    StringCbPrintf( &wszTempFileName[cchPath],
                    sizeof(wszTempFileName),
                    L"OLEPROPSTG_%08x%08x.tmp",
                    ft.dwHighDateTime, 
                    ft.dwLowDateTime );

    _hFile = CreateFile( wszTempFileName,
                         GENERIC_WRITE|GENERIC_READ|DELETE,
                         0,
                         &_secattr,
                         CREATE_NEW,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                         INVALID_HANDLE_VALUE );
    if( INVALID_HANDLE_VALUE == _hFile )
        goto Exit;
    

    // Map the temporary file.

    _hMapping = CreateFileMappingA(_hFile,               // handle of file to map
                                   NULL,                 // optional security attributes
                                   PAGE_READWRITE,       // protection for mapping object
                                   0,                    // high-order 32 bits of object size
                                   CBMAXPROPSETSTREAM,   // low-order 32 bits of object size
                                   NULL);                // name of file-mapping object
    if( NULL == _hMapping )
        goto Exit;

    // Map a view.

    _pb = (BYTE*)MapViewOfFile(_hMapping,   // file-mapping object to map into address space
                       FILE_MAP_WRITE,      // read/write access mode
                       0,   // high-order 32 bits of file offset
                       0,   // low-order 32 bits of file offset
                       0);  // number of bytes to map
    if( NULL == _pb )
        goto Exit;

Exit:

    // If there was an error, free everything.

    if( NULL == _pb && _fInitialized )
    {
        FreeResources();
        LeaveCriticalSection( &_critsec );
    }

    return _pb;

}


//+----------------------------------------------------------------------------
//
//  Method:     CWin32ReservedMemory
//
//  Synopsis:   Free the temp file and its mapping, and leave the critical
//              section.
//
//+----------------------------------------------------------------------------

VOID CWin32ReservedMemory::UnlockMemory(VOID)
{

    if( _fInitialized )
    {
        FreeResources();
        LeaveCriticalSection( &_critsec );
    }

}

#endif  // #ifndef _MAC


//+----------------------------------------------------------------------------
//
//  Method:     CWin31ReservedMemory::LockMemory/UnlockMemory
//
//  Synopsis:   This derivation of the CReservedMemory does not provide
//              a locking mechanism, so no locking is performed.  The Lock
//              method simply returns the shared memory buffer.
//
//  Inputs:     None.
//
//  Returns:    Nothing
//
//+----------------------------------------------------------------------------


#ifdef _MAC

BYTE * CWin31ReservedMemory::LockMemory(VOID)
{

    DfpAssert( !_fLocked );
    #if DBG==1
        _fLocked = TRUE;
    #endif

    return (BYTE*) g_pbPropSetReserved;

}


VOID CWin31ReservedMemory::UnlockMemory(VOID)
{

    // No locking required on the Mac.

    DfpAssert( _fLocked );
    #if DBG==1
        _fLocked = FALSE;
    #endif

}

#endif // #ifdef _MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\propstm.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993
//
// File:        propstm.cxx
//
// Contents:    property set value extraction code
//
// History:     15-Jul-94       brianb  created
//              12-Aug-94       SethuR  Included Assertions for # of sections
//                                      split PropertySet class into
//                                      CPropertySetStream & CPropertySetStorage
//                                      Included Update methods on the property
//                                      stream.
//              22-Feb-96      MikeHill DWORD-align the dictionary entries,
//                                      & use char-counts for dict entries.
//              29-Feb-96      MikeHill Moved _DictionaryEntryLength and _NextDictionaryEntry
//                                      inlines here from propstm.hxx.
//              09-May-96      MikeHill - Keep the dictionary in the UserDef propset
//                                        immediately after the last entry in the PID/Offset
//                                        array (for Office95 compatibility).
//                                      - Create an empty dictionary in the UD propset
//                                        when it is created.  If we wait till later,
//                                        we can't make the dictionary the first property,
//                                        which is required by Office95.
//                                      - Provide compatibility with Publisher95 (which doesn't
//                                        DWORD-align the section/stream size).
//                                      - Provide compatibility with PowerPoint 4.0 (which
//                                        over-pads some properties, and under-pads others).
//                                      - Don't try to unpack the DocParts and HeadingPair
//                                        DocSumInfo properties in Ansi property sets.
//              22-May-96      MikeHill - Return the OSVersion on an Open.
//                                      - Use the PropSet's code page, not the system's.
//              11-Jun-96      MikeHill - Initialize all members in the constructor.
//              25-Jul-96      MikeHill - Removed usage of Win32 SEH.
//                                      - BSTRs & prop names: WCHAR => OLECHAR.
//                                      - Added big-endian support.
//                                      - Determine the OSVer at run-time.
//                                      - Fix for Excel 5.0a compatibility.
//              26-Nov-96      MikeHill Handle invalid oSection values.
//              10-Mar-98      MikeHill - Change "Pr" functions to "Stg".
//                                      - Added asserts for new VTs.
//              06-May-98      MikeHill - Use CoTaskMem rather than new(k)/delete
//                                      - Removed usage of UnicodeCallouts.
//              18-May-98      MikeHIll - Fixed typos.
//              11-June-98     MikeHill - Dbg output.
//                                      - Allow codepage & lcid to be changed
//                                        if property set is empty.
//                                      - Validate pid_behavior in property set.
//                                      - Silently ignore PID_ILLEGAL in SetPropertyNames.
//              18-Aug-98      MikeHill - Make reserved range 0x80000000 to 0x8c000000
//                                        read-only unless the property is understood.
//
// Notes:
//
// The OLE 2.0 Appendix B property set specifies multiple sections in the
// property stream specification.  Multiple sections were intended to allow
// the schema associated with the property set to evolve over a period of time,
// but there is no reason that new PROPIDs cannot serve the same purpose.  The
// current implementation of the property stream is limited to one section,
// except for the Office DocumentSummaryInformation property set's specific use
// of a second section.  Other property sets with multiple sections can only be
// accessed in read-only mode, and then only for the first property section.
//
// The current implementation of property set stream is built around a class
// called CPropertySetStream.  The various details of the OLE property spec is
// confined to this class.  Since the property set streams need to be parsed
// in the kernel mode (OFS driver) as well as the user mode, this class
// encapsulates a stream implementation (IMappedStream).  This is different
// from other stream implementations in that the fundamental mechanism provided
// for acessing the contents is Map/Unmap rather than Read/Write.  There are
// two user mode implementations of this IMappedStream interface, one for
// docfile streams, and another for native streams.  There is one
// implementation in kernel mode for the OFS driver.  For more details,
// refer to propstm.hxx.
//---------------------------------------------------------------------------

#include <pch.cxx>

#include <olechar.h>

#if DBGPROP
#include <stdio.h>      // for sprintf/strcpy
#endif
#include "propvar.h"


#define Dbg     DEBTRACE_PROPERTY

#define szX     "x"     // allows radix change for offsets & sizes
//#define szX   "d"     // allows radix change for offsets & sizes

#ifndef newk
#define newk(Tag, pCounter)     new
#endif

#ifndef IsDwordAligned
#define IsDwordAligned(p)       (( (p) & (sizeof(ULONG) - 1)) == 0)
#endif

#ifndef DwordRemain
#define DwordRemain(cb) \
        ((sizeof(ULONG) - ((cb) % sizeof(ULONG))) % sizeof(ULONG))
#endif


// Information for the the OS Version field of the
// property set header.

#if defined(WINNT) && !defined(IPROPERTY_DLL)
#   define PROPSETVER_CURRENT MAKEPSVER(OSKIND_WIN32, WINVER >> 8, WINVER & 0xff)
#endif

#define PROPSETVER_WIN310  MAKEPSVER(OSKIND_WINDOWS, 3, 10)
#define PROPSETVER_WIN333  MAKEPSVER(OSKIND_WIN32, 3, 0x33)



extern GUID guidSummary;
extern GUID guidDocumentSummary;
extern GUID guidDocumentSummarySection2;

#define CP_DEFAULT_NONUNICODE   1252 // ANSI Latin1 (US, Western Europe)
#define CP_CREATEDEFAULT(state)	GetACP()
#define LCID_CREATEDEFAULT GetUserDefaultLCID()

#if DBGPROP
#define StatusCorruption(pstatus, szReason)             \
            _StatusCorruption(szReason " ", pstatus)
#else
#define StatusCorruption(pstatus, szReason)             \
            _StatusCorruption(pstatus)
#endif


VOID PrpConvertToUnicode(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus);
VOID PrpConvertToMultiByte(
    IN WCHAR const *pwc,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT CHAR **ppch,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus);



//
// Re-direct PrEqual[Unicode]String routines
//
// These macros redirect two NTDLL routines which don't exist in
// the IProperty DLL.  They are redirected to CRT calls.
//
// Note:  These redirections assume that the Length and
// MaximumLength fields, on both String structures, are the
// same (e.g. s1.len == s1.maxlen == s2.len == s2.maxlen).
//

#ifdef IPROPERTY_DLL

#error Need to replace the icmp routines with CharUpper-based code for correct locale ID

    #define RtlEqualString(String1,String2,fCaseInSensitive)    \
        fCaseInSensitive                                        \
            ? ( !_strnicmp( (String1)->Buffer,                  \
                            (String2)->Buffer,                  \
                            (String1)->MaximumLength) )         \
            : ( !strncmp(   (String1)->Buffer,                  \
                            (String2)->Buffer,                  \
                            (String1)->MaximumLength) )

    #define RtlEqualUnicodeString(String1,String2,fCaseInSensitive)         \
        fCaseInSensitive                                                    \
            ? ( !_wcsnicmp( (String1)->Buffer,                              \
                            (String2)->Buffer,                              \
                            (String1)->MaximumLength / sizeof(WCHAR) ))     \
            : ( !wcsncmp(   (String1)->Buffer,                              \
                            (String2)->Buffer,                              \
                            (String1)->MaximumLength / sizeof(WCHAR) ))

#endif  // #ifdef IPROPERTY_DLL


#if DBGPROP

#define CB_VALUEDISPLAY 8       // Number of bytes to display
#define CB_VALUESTRING  (CB_VALUEDISPLAY * 3 + 3)       // "xx xx xx xx...\0"

char *
ValueToString(SERIALIZEDPROPERTYVALUE const *pprop, ULONG cbprop, char rgBuf[], ULONG cbBuf)
{
    //char *p = buf;
    ULONG iBuf = 0;
    BYTE const *pb = pprop->rgb;
    BOOLEAN fOverflow = FALSE;
    static char szDots[] = "...";

    if (cbprop >= FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb))
    {
        cbprop -= FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb);
        if (cbprop > CB_VALUEDISPLAY)
        {
            cbprop = CB_VALUEDISPLAY;
            fOverflow = TRUE;
        }
        while (cbprop-- > 0)
        {
            if (0 != iBuf)
            {
                rgBuf[ iBuf++ ] = ' ';
            }
            PropSprintfA( &rgBuf[iBuf], cbBuf-iBuf, "%02.2x", *pb++ );
            iBuf = (ULONG)strlen(rgBuf);
        }
    }
    rgBuf[iBuf] = '\0';
    PROPASSERT(iBuf + sizeof(szDots) <= CB_VALUESTRING);
    if (fOverflow)
    {
        StringCbCopyA( &rgBuf[iBuf], cbBuf-iBuf, szDots );
    }
    return( &rgBuf[iBuf] );
}


#define CB_VARIANT_TO_STRING 35

char *
VariantToString(PROPVARIANT const &var, ULONG cbprop, char rgBuf[], ULONG cbBuf )
{
    ULONG iBuf = 0;

    PROPASSERT( cbprop >= CB_VARIANT_TO_STRING );


    // Add the VT to the output buffer.

    PropSprintfA( &rgBuf[iBuf], cbBuf-iBuf, "vt=%04.4x", var.vt );
    iBuf = (ULONG)strlen(rgBuf);
    PropSprintfA( &rgBuf[iBuf], cbBuf-iBuf, ", val=(%08.8x, %08.8x)", var.uhVal.LowPart, var.uhVal.HighPart );
    iBuf = (ULONG)strlen(rgBuf);

    rgBuf[iBuf] =  '\0';
    PROPASSERT( iBuf == CB_VARIANT_TO_STRING);
    return( &rgBuf[iBuf] );
}

#endif // #if DBGPROP


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DictionaryEntryLength
//
// Synopsis:    Calculate the length of an entry in the
//              dictionary.  This is non-trivial because
//              it is codepage-dependent.
//
// Note:        We must not attempt to access the name itself,
//              as this routine can be called before those bytes
//              have been validated.
//
// Arguments:   [pent] -- pointer to a dictionary entry.
//
// Returns:     The entry's length.
//+--------------------------------------------------------------------------


inline ULONG
CPropertySetStream::_DictionaryEntryLength(
    IN ENTRY UNALIGNED const * pent
    ) const
{
    ULONG ulSize ;

    // If this is a Unicode property set, it should be DWORD-aligned.
    PROPASSERT( _CodePage != CP_WINUNICODE
                ||
                IsDwordAligned( (ULONG_PTR)pent ));

    // The size consists of the length of the
    // PROPID and character count ...

    ulSize = CB_DICTIONARY_ENTRY;

    // Plus the length of the string ...

    ulSize += PropByteSwap( pent->cch )
              *
              (_CodePage == CP_WINUNICODE ? sizeof( WCHAR ) : sizeof( CHAR ));

    // Plus, possibly, padding to make the entry DWORD-aligned
    // (for Unicode property sets).

    if( _CodePage == CP_WINUNICODE )
    {
        ulSize = DwordAlign( ulSize );
    }

    return( ulSize );

}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_NextDictionaryEntry
//
// Synopsis:    Given a pointer to an entry in the dictionary,
//              create a pointer to the next entry.
//
// Arguments:   [pent] -- pointer to a dictionary entry.
//
// Returns:     Pointer to the next entry.  If the input
//              points to the last entry in the dictionary,
//              then return a pointer to just beyond the
//              end of the dictionary.
//+--------------------------------------------------------------------------


inline ENTRY UNALIGNED *
CPropertySetStream::_NextDictionaryEntry(
    IN ENTRY UNALIGNED const * pent
    ) const
{

    return (ENTRY UNALIGNED *)
           Add2Ptr( pent, _DictionaryEntryLength( pent ));

}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_StatusCorruption
//
// Synopsis:    possibly PROPASSERT and return data corrupt error
//
// Arguments:   [szReason]              -- string explanation (DBGPROP only)
//              [pstatus]               -- NTSTATUS code.
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_StatusCorruption(
#if DBGPROP
    char *szReason,
#endif
    OUT NTSTATUS *pstatus
    ) const
{
#if DBGPROP

    propDbg(( DEB_ERROR,
                "_StatusCorruption(%s, psstm=%lx, mapstm=%lx, flags=%x)\n",
                szReason, this, _pmstm, _Flags));
#endif

    *pstatus = STATUS_INTERNAL_DB_CORRUPTION;
    return;
}


//+--------------------------------------------------------------------------
// Function:    _PropMoveMemory
//
// Synopsis:    call DebugTrace and RtlMoveMemory
//
// Arguments:   [pszReason]             -- string explanation (Debug only)
//              [pvSection]             -- base of section (Debug only)
//              [pvDst]                 -- destination
//              [pvSrc]                 -- source
//              [cbMove]                -- byte count to move
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
#define PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove) \
        _PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove)
#else
#define PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove) \
        _PropMoveMemory(pvDst, pvSrc, cbMove)
#endif

inline VOID
_PropMoveMemory(
#if DBGPROP
    char *pszReason,
    VOID *pvSection,
#endif
    VOID *pvDst,
    VOID const UNALIGNED *pvSrc,
    ULONG cbMove)
{
    propDbg(( DEB_ITRACE,
              "%s: Moving Dst=%lx(%l" szX ") Src=%lx(%l" szX ") Size=%l" szX "\n",
              pszReason, pvDst,
              (BYTE *) pvDst - (BYTE *) pvSection,
              pvSrc,
              (BYTE *) pvSrc - (BYTE *) pvSection,
              cbMove));

    RtlMoveMemory(pvDst, pvSrc, cbMove);
}


inline BOOLEAN
IsReadOnlyPropertySet(BYTE flags, BYTE state)
{
    return(
	(flags & CREATEPROP_MODEMASK) == CREATEPROP_READ ||
	(state & CPSS_USERDEFINEDDELETED) ||
	(state & (CPSS_MULTIPLESECTIONS | CPSS_DOCUMENTSUMMARYINFO)) ==
	    CPSS_MULTIPLESECTIONS);
}


inline BOOLEAN
IsLocalizationPropid(PROPID pid)
{
    return(
        PID_CODEPAGE == pid
        ||
        PID_LOCALE == pid
     );
}


inline BOOLEAN
IsReadOnlyPropid(PROPID pid)
{
    return(
        pid == PID_DICTIONARY ||
        pid == PID_MODIFY_TIME ||
        pid == PID_SECURITY ||
        pid == PID_BEHAVIOR ||
        IsLocalizationPropid(pid) ||
        ( PID_MIN_READONLY <= pid
          &&
          PID_MAX_READONLY >= pid
        )
      );
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::CStreamChunkList
//
// Synopsis:    constructor
//
// Arguments:   [cChunks]               -- count of chunks that will be needed
//
// Returns:     None
//+--------------------------------------------------------------------------

CStreamChunkList::CStreamChunkList(
    ULONG cChunks,
    CStreamChunk *ascnk) :
    _cMaxChunks(cChunks),
    _cChunks(0),
    _ascnk(ascnk),
    _fDelete(FALSE)
{
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::Delete
//
// Synopsis:    destructor
//
// Arguments:   None
//
// Returns:     None
//+--------------------------------------------------------------------------

inline
VOID
CStreamChunkList::Delete(VOID)
{
    if (_fDelete)
    {
        CoTaskMemFree( _ascnk );
    }
#if DBGPROP
    _cMaxChunks = _cChunks = 0;
    _ascnk = NULL;
    _fDelete = FALSE;
#endif
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::GetChunk
//
// Synopsis:    retrieves a chunk given the index
//
// Arguments:   [i]          -- index of the chunk to retrieve
//
// Returns:     specified chunk pointer
//+--------------------------------------------------------------------------

inline
CStreamChunk const *
CStreamChunkList::GetChunk(ULONG i) const
{
    PROPASSERT(i < _cChunks);
    PROPASSERT(i < _cMaxChunks);
    PROPASSERT(_ascnk != NULL);

    return(&_ascnk[i]);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::Count
//
// Synopsis:    returns the count of chunks
//
// Arguments:   None
//
// Returns:    the number of chunks.
//+--------------------------------------------------------------------------

inline ULONG
CStreamChunkList::Count(VOID) const
{
    return(_cChunks);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::GetFreeChunk
//
// Synopsis:    gets a unused chunk descriptor
//
// Arguments:   [pstatus]   -- NTSTATUS code
//
// Returns:     a ptr to a stream chunk descriptor.
//              This will be NULL if there was an
//              error.
//+--------------------------------------------------------------------------

CStreamChunk *
CStreamChunkList::GetFreeChunk(OUT NTSTATUS *pstatus)
{
    CStreamChunk *pscnk = NULL;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_cChunks < _cMaxChunks);
    if (_ascnk == NULL)
    {
        PROPASSERT(_cChunks == 0);

        _ascnk = (CStreamChunk*) CoTaskMemAlloc( sizeof(CStreamChunk) * _cMaxChunks );
        if (_ascnk == NULL)
        {
            StatusNoMemory(pstatus, "GetFreeChunk");
            goto Exit;
        }
        _fDelete = TRUE;
    }

    pscnk = &_ascnk[_cChunks++];

    //  ----
    //  Exit
    //  ----

Exit:

    return( pscnk );
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::AssertCbChangeTotal
//
// Synopsis:    make sure the computed cbChangeTotal is correct for the chunk
//
// Arguments:   None
//
// Returns:     Nothing
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CStreamChunkList::AssertCbChangeTotal(
    CStreamChunk const *pscnk,
    ULONG cbChangeTotal) const
{
    ULONG cb = 0;
    ULONG i;

    for (i = 0; i < Count(); i++)
    {
        CStreamChunk const *pscnkT = GetChunk(i);

        cb += pscnkT->cbChange;
        if (pscnk == pscnkT)
        {
            PROPASSERT(cb == cbChangeTotal);
            return;
        }
    }
    PROPASSERT(i < Count());
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnChunkCompare
//
// Synopsis:    qsort helper to compare chunks in the chunk list.
//
// Arguments:   [pscnk1]        -- pointer to chunk1
//              [pscnk2]        -- pointer to chunk2
//
// Returns:     difference
//+--------------------------------------------------------------------------

int __cdecl
fnChunkCompare(VOID const *pscnk1, VOID const *pscnk2)
{
    return(((CStreamChunk const *) pscnk1)->oOld -
           ((CStreamChunk const *) pscnk2)->oOld);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::SortByStartAddress
//
// Synopsis:    sort all the chunks that are being modified in a stream in the
//              ascending order.
//
// Arguments:   None
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CStreamChunkList::SortByStartAddress(VOID)
{
    DebugTrace(0, Dbg, ("Sorting %l" szX " Chunks @%lx\n", _cChunks, _ascnk));

    qsort(_ascnk, _cChunks, sizeof(_ascnk[0]), &fnChunkCompare);

#if DBGPROP
    LONG cbChangeTotal;
    ULONG i;

    cbChangeTotal = 0;
    for (i = 0; i < _cChunks; i++)
    {
        cbChangeTotal += _ascnk[i].cbChange;

        DebugTrace(0, Dbg, (
            "Chunk[%l" szX "] oOld=%l" szX " cbChange=%s%l" szX
                " cbChangeTotal=%s%l" szX "\n",
            i,
            _ascnk[i].oOld,
            _ascnk[i].cbChange < 0? "-" : "",
            _ascnk[i].cbChange < 0? -_ascnk[i].cbChange : _ascnk[i].cbChange,
            cbChangeTotal < 0? "-" : "",
            cbChangeTotal < 0? -cbChangeTotal : cbChangeTotal));
    }
#endif
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetFormatidOffset
//
// Synopsis:    Get a pointer to the (first) section header
//
// Arguments:   None
//
// Returns:     pointer to section header
//+--------------------------------------------------------------------------

inline FORMATIDOFFSET *
CPropertySetStream::_GetFormatidOffset(ULONG iSection) const
{
    return(&((FORMATIDOFFSET *) Add2Ptr(_pph, sizeof(*_pph)))[iSection]);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetSectionHeader
//
// Synopsis:    Get a pointer to the (first) section header
//
// Arguments:   None
//
// Returns:     pointer to section header
//+--------------------------------------------------------------------------

inline PROPERTYSECTIONHEADER *
CPropertySetStream::_GetSectionHeader(VOID) const
{
    return((PROPERTYSECTIONHEADER *) Add2Ptr(_pph, _oSection));
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetSectionHeader
//
// Synopsis:    Get a pointer to the specified section header
//
// Arguments:   [iSection]      -- section number (zero-relative)
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     pointer to specified section header
//+--------------------------------------------------------------------------

PROPERTYSECTIONHEADER *
CPropertySetStream::_GetSectionHeader(ULONG iSection, OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;
    PROPERTYSECTIONHEADER *psh = NULL;

    ULONG oSection = 0;                 // Assume no header
    ULONG cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Don't assume *any* class variables (except _pph) are loaded yet!

    PROPASSERT(iSection < _pph->reserved );

    // Get the section offset, after verifying that we can read all
    // of the FmtID/Offset table.

    if (cbstm >= CB_PROPERTYSETHEADER + (iSection + 1) * CB_FORMATIDOFFSET)
        oSection = _GetFormatidOffset(iSection)->dwOffset;
    else
        StatusCorruption (pstatus, "GetSectionHeader(i):  stream size too short to read section offset");

    // Create a pointer to the section header, after verifying that we can
    // read all of the section header.  We don't verify that we can actually
    // read the whole section (using cbSection), the caller must be responsible
    // for this.

    // We have to check oSection first, then oSection+cb_psh, because oSection
    // could be a negative number (such as 0xffffffff), so adding it to cb_psh
    // could make it look valid.

    if (cbstm >= oSection
        &&
        cbstm >= oSection + CB_PROPERTYSECTIONHEADER)
    {
        psh = (PROPERTYSECTIONHEADER *) Add2Ptr(_pph, oSection);
    }
    else
        StatusCorruption (pstatus, "GetSectionHeader(i):  stream size too short to read section header");

    // Finally, ensure that the section is 32 bit aligned.  We handle several
    // compatibility problems in the _Fix* routines, but not a misaligned
    // section header.

    if( !IsDwordAligned( (ULONG_PTR) psh ))
        StatusCorruption( pstatus, "GetSectionHeader(i):  section header is misaligned" );


    //  ----
    //  Exit
    //  ----

Exit:

    return(psh);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_SearchForCodePage, private
//
// Synopsis:    Searches a section of a property set for the code page,
//              LCID, and Behavior properties.
//
//              This routine searches for these special properties by iterating
//              through the PID/Offset array in search of
//              PID_CODEPAGE, PID_BEHAVIOR, and PID_LOCALE.  The difference between calling
//              this routine, and calling GetValue(PID_CODEPAGE),
//              is that this routine does not assume that the
//              property set is formatted correctly; it only assumes
//              that the PID/Offset array is correct.
//
//              Note that this routine is like a specialized _LoadProperty(),
//              the important difference is that this routine must use
//              unaligned pointers, since it cannot assume that the
//              property set is aligned properly.
//
// Pre-Conditions:
//              The PID/Offset array is correct.
//              &&
//              _oSection & _cSection are set correctly.
//
// Post-Conditions:
//              If PID_CODEPAGE/PID_BEHAVIOR exist, they are put
//                  into _CodePage/_grfBehavior.
//              If either doesn't exist, the corresponding member
//                  variable is left unchanged.
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Notes:       We do *not* assume that the property set's
//              cbSection field is valid (this was added to handle a
//              special-case compatibility problem).
//
// Returns:     None.
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_SearchForCodePage( OUT NTSTATUS *pstatus )
{

    PROPERTYSECTIONHEADER UNALIGNED *psh;
    PROPERTYIDOFFSET UNALIGNED      *ppo;
    PROPERTYIDOFFSET UNALIGNED      *ppoMax;

    BOOL fCodePageFound = FALSE;
    BOOL fBehaviorFound = FALSE;
    BOOL fLocaleFound = FALSE;
    ULONG cbstm;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::_SearchForCodePage" );

    *pstatus = STATUS_SUCCESS;

    // Verify the pre-conditions.

    PROPASSERT( _oSection != 0 );
    PROPASSERT( _cSection != 0 );

    // It's invalid to call any function on a deleted
    // DocSumInfo user-defined (section section) section.

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "GetValue: deleted");
        goto Exit;
    }

    // Get the section's header.

    psh = _GetSectionHeader();

    // Ensure that we can at least read the section header and
    // PID/Offset table.

    cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (cbstm < _oSection
        ||
        cbstm < _oSection + CB_PROPERTYSECTIONHEADER
        ||
        cbstm < _oSection + CB_PROPERTYSECTIONHEADER
                + psh->cProperties * CB_PROPERTYIDOFFSET
       )
    {
        StatusCorruption(pstatus, "_SearchForCodePage: stream too short to read section header");
        goto Exit;
    }

    // Calculate the first & last PID/Offset pointers.
    // We can't use _LoadPropertyOffsetPointers, because it assumes
    // alignment.

    ppo = psh->rgprop;
    ppoMax = psh->rgprop + psh->cProperties;

    // Search the PID/Offset array for PID_CODEPAGE & PID_BEHAVIOR

    for ( ; ppo < ppoMax; ppo++)
    {
        if( PID_CODEPAGE == ppo->propid
            || PID_BEHAVIOR == ppo->propid
            || PID_LOCALE == ppo->propid )
        {
            SERIALIZEDPROPERTYVALUE UNALIGNED *pprop;

            // Get the real address of serialized property.

            pprop = (SERIALIZEDPROPERTYVALUE *)
                    _MapOffsetToAddress( ppo->dwOffset );

            // Check for corruption.  Both properties are <= DWORD in size

            if ( cbstm < (_oSection + ppo->dwOffset + CB_SERIALIZEDPROPERTYVALUE + sizeof(DWORD)) )
            {
                StatusCorruption(pstatus, "_SearchForCodePage");
                goto Exit;
            }

            if( PID_CODEPAGE == ppo->propid )
            {
                if( VT_I2 != PropByteSwap(pprop->dwType) )
                {
                    StatusCorruption(pstatus, "_SearchForCodePage");
                    goto Exit;
                }

                fCodePageFound = TRUE;
                _CodePage = PropByteSwap( *reinterpret_cast<UNALIGNED SHORT *>(&pprop->rgb) );
            }
            else if( PID_BEHAVIOR == ppo->propid )
            {
                if( VT_UI4 != PropByteSwap(pprop->dwType) )
                {
                    StatusCorruption(pstatus, "_SearchForCodePage");
                    goto Exit;
                }

                fBehaviorFound = TRUE;
                _grfBehavior = PropByteSwap( *reinterpret_cast<UNALIGNED DWORD *>(&pprop->rgb) );
            }
            else if( PID_LOCALE == ppo->propid )
            {
                if( VT_UI4 != PropByteSwap(pprop->dwType) )
                {
                    StatusCorruption( pstatus, "_SearchForCodePage");
                    goto Exit;
                }

                fLocaleFound = TRUE;
                _Locale = PropByteSwap( *reinterpret_cast<UNALIGNED DWORD *>(&pprop->rgb) );
            }

            if( fCodePageFound && fBehaviorFound && fLocaleFound )
                break;

        }   // if( PID_CODEPAGE == ppo->propid || PID_BEHAVIOR == ppo->propid )
    }   // for ( ; ppo < ppoMax; ppo++)

    //  ----
    //  Exit
    //  ----

Exit:

    propDbg(( DEB_ITRACE, "CodePage=0x%x, Behavior=0x%x",
              _CodePage, _grfBehavior ));

    return;

}   // CPropertySetStream::_SearchForCodePage()


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapOffsetToAddress, private
//
// Synopsis:    maps an offset to an address
//
// Arguments:   [Offset]        -- the offset in the section
//
// Returns:     ptr to the offset mapped
//+--------------------------------------------------------------------------

inline VOID *
CPropertySetStream::_MapOffsetToAddress(ULONG Offset) const
{
    PROPASSERT(_cSection != 0);

    return(Add2Ptr(_GetSectionHeader(), Offset));
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAddressToOffset, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [pvAddr]        -- the address in the section
//
// Returns:     section-relative offset for passed pointer
//+--------------------------------------------------------------------------

inline ULONG
CPropertySetStream::_MapAddressToOffset(VOID const *pvAddr) const
{
    PROPASSERT(_cSection != 0);

    // Get a ptr to the section header.
    VOID const *pvSectionHeader = _GetSectionHeader();

    PROPASSERT((BYTE const *) pvAddr >= (BYTE const *) pvSectionHeader);
    return (ULONG)((BYTE const *) pvAddr - (BYTE const *) pvSectionHeader);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAbsOffsetToAddress, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [oAbsolute]      -- the absolute offset
//
// Returns:     a ptr to the offset mapped
//+--------------------------------------------------------------------------

inline VOID *
CPropertySetStream::_MapAbsOffsetToAddress(ULONG oAbsolute) const
{
    return(Add2Ptr(_pph, oAbsolute));
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAddressToAbsOffset, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [pvAddr]        -- the address
//
// Returns:     the absolute offset
//+--------------------------------------------------------------------------

inline ULONG
CPropertySetStream::_MapAddressToAbsOffset(VOID const *pvAddr) const
{
    PROPASSERT((BYTE const *) pvAddr >= (BYTE *) _pph);
    return (ULONG) ((BYTE const *) pvAddr - (BYTE *) _pph);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::CPropertySetStream
//
// Synopsis:    constructor for property set class
//
// Arguments:UK [Flags] -- NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
//            K [pscb]          -- SCB for property stream
//            K [pirpc]         -- pointer to Irp Context
//            K [State]         -- CPSS_PROPHEADER
//           U  [pmstm]         -- mapped stream implementation
//           U  [pma]           -- caller's memory allocator
//
// Returns:     None
//---------------------------------------------------------------------------

CPropertySetStream::CPropertySetStream(
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    IN IMappedStream *pmstm,    // mapped stream impelementation
    IN PMemoryAllocator *pma    // caller's memory allocator
    ) :
        _Flags((BYTE) Flags),
        _State(0),
        _pmstm(pmstm),
        _pma(pma),
        _pph(NULL)
{
    // GetACP returns a UINT, but the property set only holds a USHORT.
    PROPASSERT( USHRT_MAX >= CP_CREATEDEFAULT(_State) );

    _CodePage = (USHORT)CP_CREATEDEFAULT(_State); // Default if not present
    _Locale =  LCID_CREATEDEFAULT;                // Default if not present

    PROPASSERT(_Flags == Flags);                // Should fit in a byte

    _oSection = 0;
    _cSection = 0;
    _cbTail   = 0;
    _grfBehavior = 0;

}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Close
//
// Synopsis:    shutdown property set prior to calling destructor
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     None
//
// Notes:       This method does *not* require that _pph be valid,
//              since it makes no use of it.  If it were required, then
//              we would have to call ReOpen, which would be a waste
//              since we're closing down anyway.
//
//---------------------------------------------------------------------------

VOID
CPropertySetStream::Close(OUT NTSTATUS *pstatus)
{
    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::Close" );

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(
        (_Flags & CREATEPROP_MODEMASK) != CREATEPROP_READ ||
        !IsModified());

    _MSTM(Close)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Open
//
// Synopsis:    Open property set image
//
// Arguments:   None
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::Open(
    IN GUID const *pfmtid,	    // property set fmtid
    OPTIONAL IN GUID const *pclsid, // CLASSID of propset code (create only)
    IN ULONG LocaleId,		    // Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion, // OS Version from header
    IN USHORT CodePage,             // CodePage of property set (create only)
    IN DWORD grfBehavior,   // PROPSET_BEHAVIOR_*
    OUT NTSTATUS *pstatus
    )
{
    *pstatus = STATUS_SUCCESS;
    LOADSTATE LoadState;
    PROPASSERT(!_IsMapped());

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::Open" );
    propTraceParameters(( "pfmtid=%p, pclsid=%p, LocaleId=%d, pOSVersion=%p, CodePage=%d, grfBehavior=0x%x",
                           pfmtid,    pclsid,    LocaleId,    pOSVersion,    CodePage,    grfBehavior ));

    if( pOSVersion != NULL )
        *pOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;

    // Open the underlying stream which holds the property set.
    // We give it a callback pointer so that it can call
    // PrOnMappedStreamEvent.

    _MSTM(Open)(this, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Load the header, including fixing the in-memory image of
    // poorly-formatted property sets.

    LoadState = _LoadHeader(pfmtid, _Flags & CREATEPROP_MODEMASK, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (LoadState != LOADSTATE_DONE)
    {
	switch (_Flags & CREATEPROP_MODEMASK)
	{
	    case CREATEPROP_READ:
	    case CREATEPROP_WRITE:
    		if (LoadState == LOADSTATE_FAIL)
		{
		    StatusCorruption(pstatus, "Open: _LoadHeader");
                    goto Exit;
		}
		PROPASSERT(
		    LoadState == LOADSTATE_BADFMTID ||
		    LoadState == LOADSTATE_USERDEFINEDNOTFOUND);
#if DBG
                if( LOADSTATE_BADFMTID == LoadState )
                   DebugTrace(0, DEBTRACE_WARN,
		              ("_LoadHeader: LoadState=%x\n", LoadState));
#endif

                *pstatus = STATUS_PROPSET_NOT_FOUND;
		goto Exit;
	}

        _Create(
            pfmtid,
            pclsid,
	    LocaleId,
            CodePage,
	    LoadState,
            grfBehavior,
            pstatus
            );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

    }   // if (LoadState != LOADSTATE_DONE)

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if (_HasPropHeader() &&
        (_pph->dwOSVer == PROPSETVER_WIN310 ||
         _pph->dwOSVer == PROPSETVER_WIN333))
    {
        propDbg(( DEB_ERROR, "Open(%s) downlevel: %x",
                  (_Flags & CREATEPROP_MODEMASK) == CREATEPROP_READ? "Read" : "Write",
                  _Flags ));
        _State |= CPSS_DOWNLEVEL;
    }

    if ((_Flags & CREATEPROP_MODEMASK) != CREATEPROP_READ)
    {
        if (_State & CPSS_PACKEDPROPERTIES)
        {
            StatusAccessDenied(pstatus, "Open: writing Unaligned propset");
            goto Exit;
        }
        if ((_State & (CPSS_MULTIPLESECTIONS | CPSS_DOCUMENTSUMMARYINFO)) ==
	    CPSS_MULTIPLESECTIONS)
        {
            StatusAccessDenied(pstatus, "Open: writing unknown multiple section propset");
            goto Exit;
        }
    }

    // Return the OS Version to the caller.

    if( pOSVersion != NULL )
        *pOSVersion = _pph->dwOSVer;

    //  ----
    //  Exit
    //  ----

Exit:

    if( STATUS_PROPSET_NOT_FOUND == *pstatus )
        propSuppressExitErrors();

    return;
}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::ReOpen
//
// Synopsis:    ReOpen property set image
//
// Arguments:   [pstatus]       -- Pointer to NSTATUS code.
//
// Returns:     Number of properties.
//---------------------------------------------------------------------------

ULONG
CPropertySetStream::ReOpen(OUT NTSTATUS *pstatus)
{
    LOADSTATE LoadState;
    PROPERTYSECTIONHEADER const *psh;
    ULONG cProperties = 0;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::ReOpen" );

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());

    _MSTM(ReOpen)((VOID **) &_pph, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	goto Exit;
    }

    LoadState = _LoadHeader(NULL,
                            CREATEPROP_READ,  // all we need is !create
                            pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (LoadState != LOADSTATE_DONE)
    {
	propDbg(( DEB_ERROR, "ReOpen: LoadState=%lx\n",
                  LoadState));
        StatusCorruption(pstatus, "ReOpen: _LoadHeader");
        goto Exit;
    }

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    psh = _GetSectionHeader();
    PROPASSERT(psh != NULL);

    cProperties = psh->cProperties;

    //  ----
    //  Exit
    //  ----

Exit:

    return( cProperties );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_InitSection
//
// Synopsis:    Initialize a section header and the default properties.
//
// Arguments:   [pfo]		-- pointer to section info
//		[LocaleId]	-- Locale Id
//              [fCreateDictionary]
//                              -- TRUE => create empty dictionary
//
// Returns:     None
//---------------------------------------------------------------------------

        // Serialized Code-Page size
#define CB_CODEPAGE         (CB_SERIALIZEDPROPERTYVALUE + DwordAlign(sizeof(USHORT)))

        // Serialized Locale ID (LCID) size.
#define CB_LOCALE	    (CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG))

        // PID_BEHAVIOR property (VT_UI4)
#define CB_BEHAVIOR        (CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG))

        // Minimum section size (minimum has Code Page & LCID)
#define CB_MINSECTIONSIZE   (CB_PROPERTYSECTIONHEADER   \
                             + 2 * CB_PROPERTYIDOFFSET  \
                             + CB_CODEPAGE              \
                             + CB_LOCALE)

        // Minimum serialized dictionary size (a dict with no entries).
#define CB_EMPTYDICTSIZE    (sizeof(DWORD)) // Entry count

        // Minimum User-Defined section size (in DocumentSummaryInformation proset).
        // (Must include an empty dictionary & a PID/Offset for it.)
#define CB_MINUSERDEFSECTIONSIZE                    \
                            (CB_MINSECTIONSIZE      \
                             +                      \
                             CB_PROPERTYIDOFFSET    \
                             +                      \
                             CB_EMPTYDICTSIZE)

VOID
CPropertySetStream::_InitSection(
    IN FORMATIDOFFSET *pfo,
    IN ULONG LocaleId,
    IN BOOL  fCreateDictionary  // Create an empty dictionary?
    )
{
    PROPERTYSECTIONHEADER *psh;

    ULONG ulPropIndex;     // Index into the PID/Offset array.
    DWORD dwPropValOffset; // The offset to where the next prop val will be written.
                           // Pointer to a serialized property value.
    SERIALIZEDPROPERTYVALUE *pprop;

    IFDBG( HRESULT hr = S_OK );
    propITrace( "CPropertySetStream::_InitSection" );

    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

    // Set the property count and section size in the section header.
    // This must account for the Code Page and Locale ID properties, and
    // might need to account for an empty dictionary property and/or
    // a behavior property.  dwPropValOffset identifies the location of the
    // next property value to be written.

    psh->cProperties = 2;   // Always write codepage & local
//    dwPropValOffset  = CB_PROPERTYSECTIONHEADER + 2 * CB_PROPERTYIDOFFSET;

    // Don't add in CB_PROPERTYIDOFFSET yet
    psh->cbSection   = CB_PROPERTYSECTIONHEADER + CB_CODEPAGE + CB_LOCALE;

    // Finish calculating cProperties
    if( fCreateDictionary )
    {
        psh->cProperties++; // Write an empty dictionary too
        psh->cbSection += CB_EMPTYDICTSIZE;
    }

    if( 0 != _grfBehavior )
    {
        psh->cProperties++; // Write a behavior property too
        psh->cbSection += CB_BEHAVIOR;
    }

    // Based on cProperties, finish calculating cbSection
    psh->cbSection += psh->cProperties * CB_PROPERTYIDOFFSET;

    ulPropIndex = 0;

    // If requested by the caller, create a dictionary property, but
    // leave the dictionary empty.  We always create this first.  It shouldn't
    // matter where it's located, but Office95 requires it to be first
    // and it doesn't do any harm to put it there.

    dwPropValOffset = CB_PROPERTYSECTIONHEADER + psh->cProperties * CB_PROPERTYIDOFFSET;

    if( fCreateDictionary )
    {
        // Fill in the PID/Offset table.

        psh->rgprop[ ulPropIndex ].propid = PID_DICTIONARY;
        psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

        // Fill in the property value.

        pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr( psh, dwPropValOffset );
        pprop->dwType = 0L; // For the dictonary, this is actually the entry count.

        // Advance the table & value indices.

        ulPropIndex++;
        dwPropValOffset += CB_EMPTYDICTSIZE;

    }   // if( fCreateDictionary )

    // Also if requested by the caller, create a behavior property.

    if( 0 != _grfBehavior )
    {
        // Fill in the PID/Offset table

        psh->rgprop[ ulPropIndex ].propid = PID_BEHAVIOR;
        psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

        // Fill in the property value

        pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr( psh, dwPropValOffset );
        pprop->dwType = PropByteSwap( (DWORD) VT_UI4 );
        *reinterpret_cast<ULONG*>(pprop->rgb) = PropByteSwap( _grfBehavior );

        // Advance the table & value indices

        ulPropIndex++;
        dwPropValOffset += CB_BEHAVIOR;

    }   // if( 0 != _grfBehavior )


    // Write the code page.  We write a zero first to initialize
    // the padding bytes.

    psh->rgprop[ ulPropIndex ].propid = PID_CODEPAGE;
    psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

    pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr( psh, dwPropValOffset );
    pprop->dwType = PropByteSwap((DWORD) VT_I2);
    *(DWORD *) pprop->rgb = 0;   // Zero out extra two bytes.
    *(WORD  *) pprop->rgb = PropByteSwap( _CodePage );

    ulPropIndex++;
    dwPropValOffset += CB_CODEPAGE;


    // Write the Locale ID.

    psh->rgprop[ ulPropIndex ].propid = PID_LOCALE;
    psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

    pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr(psh, dwPropValOffset );
    pprop->dwType = PropByteSwap( (DWORD) VT_UI4 );
    *(DWORD *) pprop->rgb = PropByteSwap( (DWORD) LocaleId );

    // ulPropIndex++;
    // dwPropValOffset += CB_LOCALE;

}   // CPropertySetStream::_InitSection




//+---------------------------------------------------------------------------
// Member:      _MultiByteToWideChar, private
//
// Synopsis:    Convert a MultiByte string to a Unicode string,
//              using the _pma memory allocator if necessary.
//
// Arguments:   [pch]        -- pointer to MultiByte string
//              [cb]         -- byte length of MultiByte string
//                              (-1 if null terminated)
//              [CodePage]   -- Codepage of input string.
//              [ppwc]       -- pointer to pointer to converted string
//                              (if *ppwc is NULL, it will be alloced,
//                              if non-NULL, *ppwc must be *pcb bytes long).
//              [pcb]        -- IN:  byte length of *ppwc
//                              OUT: byte length of Unicode string.
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------
VOID
CPropertySetStream::_MultiByteToWideChar(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    // Did we allocate *ppwc?
    BOOL fAlloc = FALSE;

    //  --------------
    //  Initialization
    //  --------------

//    IFDBG( HRESULT &hr = *pstatus );
//    propITrace( "CPropertySetStream::_MultiByteToWideChar" );

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pch != NULL);
    PROPASSERT(ppwc != NULL);
    PROPASSERT(pcb != NULL);
    PROPASSERT(IsAnsiString(pch, ((ULONG)-1 == cb ) ? MAXULONG : cb));
    PROPASSERT(NULL != *ppwc || 0 == *pcb);

//    propTraceParameters(( "pch=%s, cb=%d, CodePage=%d, ppwc=%p, pcb=%p",
//                          pch,     cb,    CodePage,    ppwc,    pcb ));

    //  ------------------
    //  Convert the String
    //  ------------------

    // We will pass through this loop once (if the caller provided a buffer
    // or twice (otherwise).

    while (TRUE)
    {
        // Attempt to convert the string.

	*pcb = MultiByteToWideChar(
				    CodePage,   // Source codepage
				    0,          // Flags
				    pch,        // Source string
				    cb,         // Source string length
				    *ppwc,      // Target string
				    *pcb / sizeof(WCHAR) );      // Size of target string buffer

        // The converted length should never be zero.
	if (0 == *pcb)
	{
            // If we alloced a buffer, free it now.
            if( fAlloc )
            {
	        _pma->Free( *ppwc );
                *ppwc = NULL;
            }

            // If there was an error, assume that it was a code-page
            // incompatibility problem.

            StatusError(pstatus, "_MultiByteToWideChar error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}

        // There was no error.  If we provided a non-NULL buffer,
        // then the conversion was performed and we're done.

	*pcb *= sizeof(WCHAR);  // cch => cb
	if (*ppwc != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"_MultiByteToWideChar: pch='%s'[%x] pwc='%ws'[%x->%x]\n",
		pch,
		cb,
		*ppwc,
		*pcb,
		*pcb * sizeof(WCHAR)));
	    break;
	}

        // We haven't actually the string yet.  Now that
        // we know the length, we can allocate a buffer and try the
        // conversion for real.

	*ppwc = (WCHAR *) _pma->Allocate( *pcb );
	if (NULL == *ppwc)
	{
	    StatusNoMemory(pstatus, "_MultiByteToWideChar: no memory");
            goto Exit;
	}
        fAlloc = TRUE;

    }   // while(TRUE)

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_MultiByteToWideChar

//+---------------------------------------------------------------------------
// Member:      _WideCharToMultiByte, private
//
// Synopsis:    Convert a Unicode string to a MultiByte string,
//              using the _pma memory allocator if necessary.
//
// Arguments:   [pwc]        -- pointer to Unicode string
//              [cch]        -- character length of Unicode string
//                              (-1 if null terminated)
//              [CodePage]   -- codepage of target string
//              [ppch]       -- pointer to pointer to converted string
//                              (if *ppch is NULL, it will be alloced,
//                              if non-NULL, *ppch must be *pcb bytes long).
//              [pcb]        -- IN:  byte length of *ppch
//                              OUT: byte length of MultiByte string
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_WideCharToMultiByte(
    IN WCHAR const *pwc,
    IN ULONG cch,
    IN USHORT CodePage,
    OUT CHAR **ppch,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    // Did we allocate *ppch?
    BOOL fAlloc = FALSE;

    //  --------------
    //  Initialization
    //  --------------

    IFDBG( HRESULT &hr = *pstatus );
//    propITrace( "CPropertySetStream::_WiteCharToMultiByte" );

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pwc != NULL);
    PROPASSERT(ppch != NULL);
    PROPASSERT(pcb != NULL);
    PROPASSERT(IsUnicodeString(pwc, ((ULONG)-1 == cch ) ? MAXULONG : cch*sizeof(WCHAR)));
    PROPASSERT(NULL != *ppch || 0 == *pcb);

//    propTraceParameters(( "pwc=%ws, cch=%d, CodePage=%d, ppch=%p, pcb=%p",
//                           pwc,      cch,    CodePage,    ppch,    pcb ));

    //  ------------------
    //  Convert the String
    //  ------------------

    // We will pass through this loop once (if the caller provided a buffer
    // or twice (otherwise).

    while (TRUE)
    {
        // Attempt the conversion.
	*pcb = WideCharToMultiByte(
				    CodePage,       // Codepage to convert to
				    0,              // Flags
				    pwc,            // Source string
				    cch,            // Size of source string
				    *ppch,          // Target string
				    *pcb,           // Size of target string buffer
				    NULL,           // lpDefaultChar
				    NULL);          // lpUsedDefaultChar

        // A converted length of zero indicates an error.
	if (0 == *pcb)
	{
            // If we allocated a buffer in this routine, free it.
            if( fAlloc )
            {
	        _pma->Free( *ppch );
                *ppch = NULL;
            }

            // If there was an error, assume that it was a code-page
            // incompatibility problem.

            StatusError(pstatus, "_WideCharToMultiByte: WideCharToMultiByte error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}

        // If we have a non-zero length, and we provided a buffer,
        // then we're done (successfully).

	if (*ppch != NULL)
	{
            propDbg(( DEB_ITRACE, "_WideCharToMultiByte: pwc='%ws'[%x] pch='%s'[%x->%x]\n",
		                   pwc, cch, *ppch, *pcb, *pcb));
	    break;
	}

        // There were no errors, but we need to allocate a buffer
        // to do the actual conversion.

	*ppch = (CHAR*) _pma->Allocate( *pcb );
	if (*ppch == NULL)
	{
	    StatusNoMemory(pstatus, "_WideCharToMultiByte: no memory");
            goto Exit;
	}
        fAlloc = TRUE;

    }   // while (TRUE)


    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_WideCharToMultiByte


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::ByteSwapHeaders
//
// Synopsis:    Byte-swap the headers of a property set header
//              (both the propset header and any section headers).
//
// Arguments:   [PROPERTYSETHEADER*] pph
//                  Pointer to the beginning of the property set.
//              [ULONG] cbstm
//                  Total size of the property stream.
//              [NTSTATUS*] pstatus
//                  Pointer to NTSTATUS code.
//
// Pre-Conditions:
//              There are no more than two sections.
//
//              Note that this routine does not assume anything
//              about the current state of the CPropertySetStream
//              (it accesses no member variables).
//
// Post-Conditions:
//              If the property set headers are valid, the
//              propset and section headers are byte-swapped.
//              Note that if the property set is invalid, this
//              routine may only partially swap it.  Therefore,
//              the caller must ensure in this case that no
//              attempt is made to use the property set.
//
// Returns:     None.  *pstatus will only be non-successful
//              if the Stream was too small for the property set
//              (i.e, the property set is corrupt).  If the caller
//              knows this not to be the case, then it can assume
//              that this routine will return STATUS_SUCCESS.
//
//---------------------------------------------------------------------------

VOID
CPropertySetStream::ByteSwapHeaders( IN PROPERTYSETHEADER *pph,
                                     IN DWORD cbstm,
                                     OUT NTSTATUS *pstatus )
{
#if LITTLEENDIAN

    *pstatus = STATUS_SUCCESS;
    return;

#else

    //  ------
    //  Locals
    //  ------

    ULONG cSections;
    ULONG ulIndex, ulSectionIndex;

    // pfoPropSet points into pph, pfoReal is a local copy
    // in the system's endian-ness.
    FORMATIDOFFSET *pfoPropSet, pfoReal[2];

    // Pointers into pph.
    PROPERTYSECTIONHEADER *psh = NULL;
    PROPERTYIDOFFSET *po = NULL;

    // Are we converting *to* the system's endian-ness?
    BOOL fToSystemEndian;

    //  ----------
    //  Initialize
    //  ----------

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::ByteSwapHeaders" );
    propTraceParameters( "pph=%p, cbstm=%d", pph, cbstm );

    *pstatus = STATUS_SUCCESS;
    PROPASSERT( NULL != pph );
    PROPASSERT(PROPSET_BYTEORDER == pph->wByteOrder
               ||
               PROPSET_BYTEORDER == ByteSwap( pph->wByteOrder )
              );


    //  ----------------------------
    //  Swap the Property Set header
    //  ----------------------------

    // Validate the stream length.
    if( sizeof(*pph) > cbstm )
    {
        StatusCorruption(pstatus, "CPropertySetStream::ByteSwapHeaders: PropertySet header size");
        goto Exit;
    }

    // Swap the fields in place.
    PropByteSwap( &pph->wByteOrder );
    PropByteSwap( &pph->wFormat );
    PropByteSwap( &pph->dwOSVer );
    PropByteSwap( &pph->clsid );
    PropByteSwap( &pph->reserved );

    // Are we converting to little-endian?
    if( PROPSET_BYTEORDER == pph->wByteOrder)
        fToSystemEndian = TRUE;
    else
    {
        fToSystemEndian = FALSE;
        PROPASSERT( PROPSET_BYTEORDER == PropByteSwap(pph->wByteOrder) );
    }

    // Get the correctly-endianed section count and validate.

    cSections = fToSystemEndian ? pph->reserved
                                : PropByteSwap( pph->reserved );

    if( cSections > 2 )
    {
        StatusCorruption(pstatus, "CPropertySetStream::ByteSwapHeaders: PropertySet header size");
        goto Exit;
    }

    //  -------------------------
    //  Swap the per-section data
    //  -------------------------

    pfoPropSet = (FORMATIDOFFSET*) ((BYTE*) pph + sizeof(*pph));

    for( ulSectionIndex = 0; ulSectionIndex < cSections; ulSectionIndex++ )
    {
        ULONG cbSection, cProperties;

        //  ------------------------------
        //  Swap the FormatID/Offset entry
        //  ------------------------------

        // Is the Stream long enough for the array?
        if( cbstm < (ULONG) &pfoPropSet[ulSectionIndex]
                    + sizeof(*pfoPropSet)
                    - (ULONG) pph )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::_ByteSwapHeaders: FormatID/Offset size");
            goto Exit;
        }

        // Get a local copy of this FMTID/Offset array entry
        // If it is propset-endian format, swap to make usable.

        pfoReal[ ulSectionIndex ].fmtid    = pfoPropSet[ulSectionIndex].fmtid;
        pfoReal[ ulSectionIndex ].dwOffset = pfoPropSet[ulSectionIndex].dwOffset;

        if( fToSystemEndian )
        {
            PropByteSwap( &pfoReal[ulSectionIndex].fmtid );
            PropByteSwap( &pfoReal[ulSectionIndex].dwOffset );
        }

        // Swap this FMTID/Offset entry in place.
        PropByteSwap( &pfoPropSet[ulSectionIndex].fmtid );
        PropByteSwap( &pfoPropSet[ulSectionIndex].dwOffset );


        //  -----------------------
        //  Swap the section header
        //  -----------------------

        // Locate the section header and the first entry in the
        // PID/Offset table.

        psh = (PROPERTYSECTIONHEADER*)
              ( (BYTE*) pph + pfoReal[ ulSectionIndex ].dwOffset );

        po = (PROPERTYIDOFFSET*)
             ( (BYTE*) psh + sizeof(psh->cbSection) + sizeof(psh->cProperties) );

        // Validate that we can see up to the PID/Offset table.
        if( cbstm < (ULONG) ((BYTE*) po - (BYTE*) pph) )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::ByteSwapHeaders: Section header size");
            goto Exit;
        }

        // Get local copies of the section & property counts.
        // Again we may need to swap them from propset-endian format
        // in order to make them usable.

        cbSection = psh->cbSection;
        cProperties = psh->cProperties;

        if( fToSystemEndian)
        {
            PropByteSwap( &cbSection );
            PropByteSwap( &cProperties );
        }

        // Swap the two fields at the top of the section header.

        PropByteSwap( &psh->cbSection );
        PropByteSwap( &psh->cProperties );

        //  -------------------------
        //  Swap the PID/Offset table
        //  -------------------------

        // Validate that we can see the whole table.
        if( cbstm < (BYTE*) po - (BYTE*) pph + cProperties * sizeof(*po) )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::ByteSwapHeaders: Section header size");
            goto Exit;
        }

        // Swap each of the array entries.
        for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
        {
            PropByteSwap( &po[ulIndex].propid );
            PropByteSwap( &po[ulIndex].dwOffset );
        }

    }   // for( ulSectionIndex = 0; ulSectionIndex < cSections, ulIndex++ )

    //  ----
    //  Exit
    //  ----

Exit:

    return;

#endif // #if LITTLEENDIAN ... #else

}   // CPropertySetStream::ByteSwapHeaders


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CreateUserDefinedSection
//
// Synopsis:    Create second property section
//
// Arguments:   [LoadState]	-- _LoadHeader returned state
//		[LocaleId]	-- Locale Id
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     TRUE if LoadState handled successfully.  If TRUE,
//              *pstatus will be STATUS_SUCCESS.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_CreateUserDefinedSection(
    IN LOADSTATE LoadState,
    IN ULONG LocaleId,
    OUT NTSTATUS *pstatus)
{
    BOOLEAN fSuccess = FALSE;
    FORMATIDOFFSET *pfo;
    ULONG cbstmNew;
    PROPERTYSECTIONHEADER *psh;

    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::_CreateUserDefinedSection" );
    propTraceParameters(( "LoadState=%d, LocaleId=0x%x", LoadState, LocaleId ));

    PROPASSERT(_State & CPSS_USERDEFINEDPROPERTIES);
    switch (_Flags & CREATEPROP_MODEMASK)
    {
    case CREATEPROP_CREATEIF:
    case CREATEPROP_CREATE:
	if (LoadState == LOADSTATE_USERDEFINEDNOTFOUND)
	{
	    ULONG cbmove;

	    PROPASSERT(_cSection == 1);
	    pfo = _GetFormatidOffset(0);
	    PROPASSERT(pfo->fmtid == guidDocumentSummary);
	    PROPASSERT(IsDwordAligned(pfo->dwOffset));

            // Get a pointer to the first section header, using the
            // FmtID/Offset array.

	    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

            // Determine if we need to move the first section back in order
            // to make room for this new entry in the FmtID/Offset array.

	    cbmove = 0;
	    if (pfo->dwOffset < CB_PROPERTYSETHEADER + 2 * CB_FORMATIDOFFSET)
	    {
		cbmove = CB_PROPERTYSETHEADER + 2*CB_FORMATIDOFFSET - pfo->dwOffset;
	    }

            // How big should the Stream be (why are we doing this if cbmove is zero)?

	    cbstmNew = pfo->dwOffset            // The offset of the first section
                            +
			    cbmove              // Room for new FormatID/Offset array entry
                            +                   // Size of first section
			    DwordAlign(psh->cbSection)
                            +                   // Size of User-Defined section.
			    CB_MINUSERDEFSECTIONSIZE;

            // Set the stream size

	    _MSTM(SetSize)(cbstmNew, TRUE, (VOID **) &_pph, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // reload all pointers into mapped image:

	    pfo = _GetFormatidOffset(0);
	    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

	    if (cbmove != 0)
	    {
		// Move section back to make room for new FORMATIDOFFSET entry

		PropMoveMemory(
			"_AddSection",
			psh,
			Add2Ptr(psh, cbmove),
			psh,
			psh->cbSection);

		pfo->dwOffset += cbmove;
		PROPASSERT(IsDwordAligned(pfo->dwOffset));
	    }

	    psh->cbSection = DwordAlign(psh->cbSection);

            PROPASSERT(_oSection == 0);
	    PROPASSERT(_cSection == 1);
	    PROPASSERT(_pph->reserved == 1);

	    _cSection++;
	    _pph->reserved++;

	    _oSection = pfo->dwOffset + psh->cbSection;
	    pfo = _GetFormatidOffset(1);
	    pfo->fmtid = guidDocumentSummarySection2;
	    pfo->dwOffset = _oSection;
	    _InitSection(pfo,
                         LocaleId,
                         TRUE ); // Create an empty dictionary.

	    fSuccess = TRUE;
	}
	break;

    case CREATEPROP_DELETE:
	PROPASSERT(
	    LoadState == LOADSTATE_USERDEFINEDDELETE ||
	    LoadState == LOADSTATE_USERDEFINEDNOTFOUND);
	if (LoadState == LOADSTATE_USERDEFINEDDELETE)
	{
	    PROPASSERT(_cSection == 2);
	    PROPASSERT(_pph->reserved == 2);
	    pfo = _GetFormatidOffset(1);
	    RtlZeroMemory(pfo, sizeof(*pfo));

	    _cSection--;
	    _pph->reserved--;
	    pfo = _GetFormatidOffset(0);
	    PROPASSERT(pfo->fmtid == guidDocumentSummary);
	    PROPASSERT(IsDwordAligned(pfo->dwOffset));
	    psh = (PROPERTYSECTIONHEADER *)
			_MapAbsOffsetToAddress(pfo->dwOffset);
	    psh->cbSection = DwordAlign(psh->cbSection);
	    cbstmNew = pfo->dwOffset + psh->cbSection;

	    _MSTM(SetSize)(cbstmNew, TRUE, (VOID **) &_pph, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	}
	_State |= CPSS_USERDEFINEDDELETED;

	fSuccess = TRUE;
        break;

    default:
	PROPASSERT(!"_Flags: bad open mode");
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return( fSuccess );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_Create
//
// Synopsis:    Create property set image
//
// Arguments:   [pfmtid]        -- format id
//              [pclsid]        -- class id
//		[LocaleId]	-- Locale Id
//              [CodePage]      -- CodePage
//		[LoadState]	-- _LoadHeader returned state
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_Create(
    IN GUID const *pfmtid,
    OPTIONAL IN GUID const *pclsid,
    IN ULONG LocaleId,		    // Locale Id (create only)
    IN USHORT CodePage,
    IN LOADSTATE LoadState,
    IN DWORD grfBehavior,
    OUT NTSTATUS *pstatus
    )
{
    ULONG cb;
    FORMATIDOFFSET *pfo;
    ULONG cSectionT;

    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::_Create" );
    propTraceParameters(( "pfmtid=%p, pclsid=%p, LocaleId=%d, CodePage=%d, LoadState=%d, grfBehavior=0x%x",
                           pfmtid,    pclsid,    LocaleId,    CodePage,    LoadState,    grfBehavior ));

    _SetModified(pstatus);
    if( !NT_SUCCESS(*pstatus) )
    {
        TraceStatus( "_Create: Couldn't SetModified" );
        goto Exit;
    }

    // Set the size of the stream to correspond to the header for the
    // property set as well as the section.

    _CodePage = CodePage;
    _grfBehavior = grfBehavior;

    cSectionT = 1;

    // Are we creating the UserDefined property set
    // (the second section of the DocumentSummaryInformation
    // property set)?

    if (_State & CPSS_USERDEFINEDPROPERTIES)
    {
        // Create the UD propset, and set the cSection.
        // If this routine returns TRUE, it means that
        // the first section already existed, and we're done.
        // Otherwise, we must continue and create the first section.

	if (_CreateUserDefinedSection(LoadState, LocaleId, pstatus))
	{
            // If we get here, we know that *pstatus is Success.
            PROPASSERT( NT_SUCCESS(*pstatus) );

	    if (pclsid != NULL)
	    {
		_pph->clsid = *pclsid;
	    }
	    goto Exit;
	}
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

	cSectionT = 2;
    }

    // Calculate the exact size of the Stream (we know exactly
    // what it will be because we only initialize the set(s) with
    // fixed size data).

    PROPASSERT( 1 <= cSectionT && cSectionT <= 2 );
    cb = CB_PROPERTYSETHEADER       // The size of the propset header.
         +                          // The size of the FmtID/Offset array
         cSectionT * CB_FORMATIDOFFSET
         +
         CB_MINSECTIONSIZE          // The size of the first section
         +                          // Maybe the size of the User-Defined section
         ( cSectionT <= 1 ? 0 : CB_MINUSERDEFSECTIONSIZE );

    if( 0 != _grfBehavior )
        cb += CB_PROPERTYIDOFFSET + CB_BEHAVIOR;


    propDbg(( DEB_ITRACE, "SetSize(%x) init\n", cb ));

    // Set the size of the stream
    _MSTM(SetSize)(cb, TRUE, (VOID **) &_pph, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // And get a mapping of the Stream.
    _MSTM(Map)(TRUE, (VOID **) &_pph);
    RtlZeroMemory(_pph, cb);            // Zeros classid, fmtid(s), etc

    // Initialize the OS Version in the header.
    // Getting the current OS version depends on the OS.

#if defined(_MAC)

    {
        // Get the Mac System Version (e.g., 7.53).  If we get an API error,
        // we won't treat it as fatal, we'll just set the version to 0.

        OSErr oserr;
        SysEnvRec theWorld;
        oserr = SysEnvirons( curSysEnvVers, &theWorld );
        PROPASSERT( noErr == oserr );

        if( noErr == oserr )
        {
            _pph->dwOSVer = MAKEPSVER( OSKIND_MACINTOSH,
                                       HIBYTE(theWorld.systemVersion),  // Major
                                       LOBYTE(theWorld.systemVersion) );// Minor
        }
        else
        {
            _pph->dwOSVer = MAKEPSVER( OSKIND_MACINTOSH, 0, 0 );
        }

    }

#elif defined(IPROPERTY_DLL) || !defined(WINNT)

    {
        // Get the Windows version.
        DWORD dwWinVersion = GetVersion();

        // Use it to set the OSVersion
        _pph->dwOSVer = MAKEPSVER( OSKIND_WIN32,
                                   LOBYTE(LOWORD( dwWinVersion )),      // Major
                                   HIBYTE(LOWORD( dwWinVersion )) );    // Minor
    }

#else   // #if defined(_MAC) ... #elif defined(IPROPERTY_DLL)

    // Since we're part of the system, we can hard-code the OSVersion,
    // and save the expense of an API call.

    _pph->dwOSVer = PROPSETVER_CURRENT;

#endif  // #if defined(_MAC) ... #elif ... #else

    // Initialize the rest of the header.

    _pph->wByteOrder = 0xfffe;
    //_pph->wFormat = 0;                // RtlZeroMemory does this
    PROPASSERT(_pph->wFormat == 0);

    // The behavior property is only supported in version-1 property sets.
    if( 0 != _grfBehavior )
        _pph->wFormat = PROPSET_WFORMAT_BEHAVIOR;

    if (pclsid != NULL)
    {
	_pph->clsid = *pclsid;
    }
    _pph->reserved = cSectionT;

    // Initialize the format id offset for the section(s).

    pfo = _GetFormatidOffset(0);
    pfo->dwOffset = CB_PROPERTYSETHEADER + cSectionT * CB_FORMATIDOFFSET;

    // Are we creating the second section of the DocSumInfo property set?

    if (cSectionT == 2)
    {
        // We need to initialize any empty first section.

	pfo->fmtid = guidDocumentSummary;

	_InitSection(pfo,
                     LocaleId,
                     FALSE); // Don't create an empty dictionary.

        // Advance the FmtID/Offset table pointer to the second entry,
        // and set it's offset to just beyond the first section.

	pfo = _GetFormatidOffset(1);
	pfo->dwOffset = CB_PROPERTYSETHEADER +
			cSectionT * CB_FORMATIDOFFSET +
			CB_MINSECTIONSIZE;
    }

    // Initialize the requested property set.

    PROPASSERT(pfmtid != NULL);
    pfo->fmtid = *pfmtid;
    _InitSection(pfo,
                 LocaleId,
                           // TRUE => Create an empty dictionary
                 pfo->fmtid == guidDocumentSummarySection2 );

    _cSection = cSectionT;
    _oSection = pfo->dwOffset;


    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_Create


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadHeader
//
// Synopsis:    verify header of a property set and read the code page
//
// Arguments:   [pfmtid]        -- format id
//		[Mode]		-- open mode
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     LOADSTATE
//---------------------------------------------------------------------------

LOADSTATE
CPropertySetStream::_LoadHeader(
    OPTIONAL IN GUID const *pfmtid,
    IN BYTE Mode,
    OUT NTSTATUS *pstatus)
{
    LOADSTATE loadstate = LOADSTATE_FAIL;
    ULONG cbstm, cbMin;
    PROPERTYSECTIONHEADER *psh;
    FORMATIDOFFSET const *pfo;
    BOOLEAN fSummaryInformation = FALSE;
#if DBGPROP
    BOOLEAN fFirst = _pph == NULL;
#endif

    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::_LoadHeader" );
    propTraceParameters(( "pfmtid=%s, Mode=%d",
                          (NULL == pfmtid)?"<null>":static_cast<const char*>(CStringize(*pfmtid)),
                          Mode ));

    PROPASSERT((_State & CPSS_USERDEFINEDDELETED) == 0);

    // If this is one of the DocSumInfo property sets,
    // we need to set some _State bits.  If this is an
    // Open, rather than a Create, pfmtid may be NULL.
    // In that case, we'll set these bits after the open
    // (since we can then get the fmtid from the header).

    if( pfmtid != NULL && *pfmtid == guidDocumentSummary )
    {
        _State |= CPSS_DOCUMENTSUMMARYINFO;
    }

    if (pfmtid != NULL && *pfmtid == guidDocumentSummarySection2)
    {
	_State |= CPSS_USERDEFINEDPROPERTIES;
    }
    else
    {
        // If this isn't the UD property set, the Mode
        // better not be "Delete" (all other property sets
        // are deleted simply be deleting the underlying
        // stream).

	if (Mode == CREATEPROP_DELETE)
	{
	    propDbg(( DEB_ITRACE, "_LoadHeader: CREATEPROP_DELETE\n" ));
	    StatusInvalidParameter(pstatus, "_LoadHeader: CREATEPROP_DELETE");
            goto Exit;
	}
	if (Mode == CREATEPROP_CREATE)
	{
	    goto Exit;  // We're going to overwrite it anyway
	}
    }

    // Get the size of the underlying stream.

    cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Map the serialized property set to a pointer.

    _MSTM(Map)(FALSE, (VOID **) &_pph);

    // Fix a Visio problem where the User-Defined property set isn't
    // aligned properly.

    _FixUnalignedUDPropSet( &cbstm, pstatus );
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Compute the minimum size of this property set, as specified
    // by the property set header and the section headers.  This call
    // will fail if any part of these headers is beyond the end of the
    // the stream (as determined from cbstm).
    // It will *not* fail if a section's cbSection indicates that the
    // section goes beyond the end of the stream (in order to maintain
    // compatibility with other propset imps, such as Publisher).  We'll
    // handle that later in the _Fix* routines called below.

    cbMin = _ComputeMinimumSize(cbstm, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // The following assert should be valid, but it isn't for some
    // older property sets which we fix in the _Fix* routines, which
    // are called below.
    //PROPASSERT(cbMin <= cbstm);

    propDbg(( DEB_ITRACE, "ComputeMinimumSize: cbMin=%l" szX " cbstm=%l" szX " cbUnused=%l" szX "\n",
                          cbMin, cbstm, cbstm - cbMin ));

    _oSection = 0;
    _cSection = 1;
    _cbTail = 0;
#ifdef KERNEL
    _CodePage = CP_WINUNICODE;
#endif

    if (_HasPropHeader())   // I.e. if not in kernel mode
    {
	// The first expression must be TRUE before we can dereference _pph
	// for the second expression.

        if (cbstm < CB_PROPERTYSETHEADER + CB_FORMATIDOFFSET ||
	    cbstm < CB_PROPERTYSETHEADER + _pph->reserved * CB_FORMATIDOFFSET ||
            _pph->wByteOrder != 0xfffe ||
            _pph->wFormat > 1 ||
            _pph->reserved < 1)
        {
            _cSection = 0;		// Mark property set invalid
            propDbg(( DEB_ERROR, "_LoadHeader: %s\n",
                cbstm == 0? "Empty Stream" :
		    cbstm < CB_PROPERTYSETHEADER + CB_FORMATIDOFFSET?
			"Stream too small for header" :
		    _pph->wByteOrder != 0xfffe? "Bad wByteOrder field" :
		    _pph->wFormat > 1 ? "Bad wFormat field" :
		    _pph->reserved < 1? "Bad reserved field" :
                    "Bad dwOSVer field" ));
            goto Exit;
        }

        // Now that we've loaded the property set, check again
        // to see if this is a SumInfo or DocSumInfo set.

        pfo = _GetFormatidOffset(0);
	if (pfo->fmtid == guidDocumentSummary)
	{
	    _State |= CPSS_DOCUMENTSUMMARYINFO;
	}
        else if (pfo->fmtid == guidSummary)
        {
            fSummaryInformation = TRUE;
        }

        // If what we're after is the property set in the
        // second section, verify that it's there.

        if (_State & CPSS_USERDEFINEDPROPERTIES)
	{
            // Ensure that this is the second section of
            // the DocSumInfo property set; that's the only
            // two-section property set we support.

	    if ((_State & CPSS_DOCUMENTSUMMARYINFO) == 0)
	    {
		propDbg(( DEB_ERROR, "Not DocumentSummaryInfo 1st FMTID\n" ));
		goto Exit;
	    }

            // Verify that this property set has two sections, and that
            // the second section is the UD propset.
            // Note that this gets pfo pointing to the correct entry in the
            // FMTID/Offset array.

	    if (_pph->reserved < 2 ||
		(pfo = _GetFormatidOffset(1))->fmtid != guidDocumentSummarySection2)
	    {
		DebugTrace(
			0,
			_pph->reserved < 2? Dbg : DEBTRACE_ERROR,
			("Bad/missing 2nd section FMTID\n"));
		loadstate = LOADSTATE_USERDEFINEDNOTFOUND;
                goto Exit;
	    }
	}
	else if (pfmtid != NULL)
        {
            // This isn't the UserDefined property set, so it
            // should be the first section, so it should match
            // the caller-requested format ID.

            if (*pfmtid != pfo->fmtid)
            {
                // The propset's FmtID doesn't match, but maybe that's
                // because it's a MacWord6 SumInfo property set, in which
                // the FmtID isn't byte-swapped.  Otherwise, it's a problem.

                if( OSKIND_MACINTOSH == PROPSETHDR_OSVER_KIND(_pph->dwOSVer)
                    &&
                    guidSummary == *pfmtid
                    &&
                    IsEqualFMTIDByteSwap( *pfmtid, pfo->fmtid )
                  )
                {
                    fSummaryInformation = TRUE;
                }
                else
	        {
                    _cSection = 0;
	            DebugTrace(0, DEBTRACE_ERROR, ("Bad FMTID\n"));
                    loadstate = LOADSTATE_BADFMTID;
                    goto Exit;
	        }
            }   // if (*pfmtid != pfo->fmtid)
        }   // else if (pfmtid != NULL)

        _oSection = pfo->dwOffset;
        _cSection = _pph->reserved; // Could be first or second section, depending on pfo

    }   // if (_HasPropHeader())

    psh = _GetSectionHeader();

    // Scan the property set for code page and behavior properties.
    // Sets _CodePage and _grfBehavior.

    _SearchForCodePage( pstatus );
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Validate that the Behavior property only has bits we understand.

    if( 0 != _grfBehavior && _pph->wFormat < PROPSET_WFORMAT_BEHAVIOR )
    {
        propDbg(( DEB_ITRACE, "_LoadHeader: invalid format for behavior (%d,%x)\n",
                               _pph->wFormat, _grfBehavior ));
        goto Exit;
    }
    else if( ~PROPSET_BEHAVIOR_CASE_SENSITIVE & _grfBehavior )
    {
        propDbg(( DEB_ITRACE, "_LoadHeader: unsupported behavior (%x)\n", _grfBehavior ));
        goto Exit;
    }

    PROPASSERT( 0 == _grfBehavior || _pph->wFormat > 0 );

    // If we have multiple sections, record the tail length
    // (the size of the property set beyond this section).

    if (_cSection > 1)
    {
	_State |= CPSS_MULTIPLESECTIONS;
	_cbTail = cbMin - (_oSection + psh->cbSection);
	propDbg(( DEB_ITRACE, "_LoadHeader: cbTail=%x\n", _cbTail));
    }


    // Fix all header-related problems in the in-memory representation.
    // The only header-related problems we fix are with SummaryInformation
    // property sets.

    if (fSummaryInformation)
    {
	_FixSummaryInformation(&cbstm, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // The stream may have been re-mapped, invalidating our section header pointer
        psh = _GetSectionHeader();
    }


    // Now that, to the best of our ability, the headers are good,
    // let's validate them against the actual stream size.

    if (cbstm < _oSection ||
        cbstm < _oSection + CB_PROPERTYSECTIONHEADER ||
        psh->cbSection < CB_PROPERTYSECTIONHEADER +
            psh->cProperties * CB_PROPERTYIDOFFSET ||
        cbstm < _oSection + CB_PROPERTYSECTIONHEADER +
            psh->cProperties * CB_PROPERTYIDOFFSET ||
        cbstm < _oSection + psh->cbSection)
    {
        _cSection = 0;
        propDbg(( DEB_ITRACE, "_LoadHeader: too small for section\n"));
        goto Exit;
    }

    if( 1 < _cSection )
    {
        PROPERTYSECTIONHEADER *psh1;
        ULONG oSection1 = 0;

        oSection1 = _GetFormatidOffset(1)->dwOffset;

        psh1 = _GetSectionHeader( 1, pstatus ); // Validates that it can read up to the header
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (cbstm < oSection1 ||
            cbstm < oSection1 + CB_PROPERTYSECTIONHEADER ||
            psh1->cbSection < CB_PROPERTYSECTIONHEADER +
                psh1->cProperties * CB_PROPERTYIDOFFSET ||
            cbstm < oSection1 + CB_PROPERTYSECTIONHEADER +
                psh1->cProperties * CB_PROPERTYIDOFFSET ||
            cbstm < oSection1 + psh1->cbSection)
        {
            _cSection = 0;
            propDbg(( DEB_ITRACE, "_LoadHeader: too small for section\n"));
            goto Exit;
        }
    }

    // Now we know the headers are OK, so let's see if there are any
    // problems in the properties themselves that we know how
    // to fix.

    if (fSummaryInformation || (_State & CPSS_DOCUMENTSUMMARYINFO))
    {
        psh = NULL; // May get re-mapped by _FixPackedPropertySet
	_FixPackedPropertySet( pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    if (Mode == CREATEPROP_DELETE)
    {
	loadstate = LOADSTATE_USERDEFINEDDELETE;
        goto Exit;
    }


    //  ----
    //  Exit
    //  ----

    loadstate = LOADSTATE_DONE;

Exit:

    return( loadstate );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixSummaryInformation
//
// Synopsis:    Fix up the memory image of a SummaryInformation propset,
//              except for packing or padding problems (which are fixed
//              in _FixPackedPropertySet).
//
//              We don't assume anything about the validity of the content
//              of the section here, as this routine is called
//              before _LoadHeader completes (we do assume, though, that
//              the property set header is valid).
//
// Arguments:   [pcbstm]    - The size of the mapped stream.  This may
//                            be updated by this routine.
//              [pstatus]   - Pointer to NTSTATUS code.
//
// Returns:     None
//
//---------------------------------------------------------------------------


VOID
CPropertySetStream::_FixSummaryInformation(IN OUT ULONG *pcbstm,
                                           OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER *psh;
    PROPERTYIDOFFSET *ppo, *ppoMax;

    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::_FixSummaryInformation" );
    propTraceParameters(( "pcbstm=%p(%d)", pcbstm, *pcbstm ));

    // If this property set has multiple sections, then it's not one
    // of the ones we know how to fix in this routine.

    if (1 != _cSection) goto Exit;

    // Load pointers to the section header and the PID/Offset array.
    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) || NULL == psh ) goto Exit;

    // Ensure that the section header fits within the stream

    if( (UINT_PTR) ppoMax - (UINT_PTR) ppo > *pcbstm )
    {
        // It's a corrupt property set, but we'll let the normal
        // corruption detection code catch it.  For now, this isn't
        // what we're looking for, so just move on.

        goto Exit;
    }

    //  Look for the MS Publisher problem.  Pub only writes
    //  a Thumbnail, but it sets the section size too short (by 4 bytes).
    //  Pub95 has the additional problem that it doesn't DWORD-align the
    //  section and stream size.  We fix both of these problems below.

    if (*pcbstm == _oSection + psh->cbSection + sizeof(ULONG))
    {
        // Look for the thumbnail property.

	for ( ; ppo < ppoMax; ppo++)
	{
	    if (ppo->propid == PIDSI_THUMBNAIL)
	    {
		SERIALIZEDPROPERTYVALUE const *pprop;

                // If this property isn't properly aligned, then ignore it.

		if (ppo->dwOffset & (sizeof(DWORD) - 1))
		{
		    break;
		}

                // Get a pointer to the property.

		pprop = (SERIALIZEDPROPERTYVALUE *)
			    _MapOffsetToAddress(ppo->dwOffset);

                // Ensure this property, plus the part of the value we're going to read,
                // is within the stream
                if( ppo->dwOffset
                        + CB_SERIALIZEDPROPERTYVALUE    // The VT
                        + 2 * sizeof(ULONG)             // We need to check the first 8 bytes
                    > *pcbstm )
                {
                    // This isn't what we're looking for
                    break;
                }

                // Look specifically for the Publisher's Thumbnail property.
                // If this is a Publisher set, the lengths won't add
                // up correctly.  For the lengths to add up correctly,
                // the offset of the property, plus
                // the length of the thumbnail, plus the size of the VT
                // DWORD and the size of the length DWORD should be the
                // size of the Section.  But In the case of Publisher,
                // the section length is 4 bytes short.

		if (PropByteSwap(pprop->dwType) == VT_CF                // It's in a clipboard format
                    &&                                                  // For Windows
		    *(ULONG *) &pprop->rgb[sizeof(ULONG)] == PropByteSwap((ULONG)MAXULONG)
                    &&
		    ppo->dwOffset +                                     // And the lengths don't add up
			PropByteSwap( *(ULONG *) pprop->rgb ) +
			(3 - 2) * sizeof(ULONG) == psh->cbSection)
		{
                    // We've found the Publisher problem.

                    // For Pub95 files, we must dword-align the section
                    // and stream size.  We don't change the size of the underlying
                    // stream, however, just the mapping.  This is because if the caller
                    // doesn't make any explicit changes, we don't want the mapped Stream
                    // to be modified.  We do this step before fixing the section-size
                    // problem, so if it should fail we haven't touched anything.

                    if( !IsDwordAligned( *pcbstm ))
                    {
                        // Increase the size of the buffer, and reload the
                        // psh pointer.

                        *pcbstm += DwordRemain(*pcbstm);
    	                _MSTM(SetSize)(*pcbstm,             // The new size
                                       FALSE,               // Don't update the underlying stream
                                       (VOID **) &_pph,     // The new mapping
                                       pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // Align the section size.

                        psh->cbSection += DwordRemain(psh->cbSection);
                    }
                    else
                    {
                        // We don't need to adjust the size of the stream, but we
                        // do need to write to it (below to correct the section size).
                        // Until we call SetSize once, we don't know if the mapped stream
                        // is writable, so we'll call SetSize here to ensure that it is
                        // writable.

    	                _MSTM(SetSize)(*pcbstm,             // Reset the same size
                                       FALSE,               // Don't update the underlying stream
                                       (VOID **) &_pph,     // The new mapping
                                       pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    }

                    // Now correct the section size.

		    propDbg(( DEB_ITRACE,
			      "_FixSummaryInformation: Patch section size: %x->%x\n",
			      psh->cbSection, psh->cbSection + sizeof(ULONG)  ));

                    psh->cbSection += sizeof(ULONG);

		}   // if (pprop->dwType == VT_CF ...

		break;

	    }   // if (ppo->propid == PID_THUMBNAIL)
	}   // for ( ; ppo < ppoMax; ppo++)
    }   // if (cbstm == _oSection + psh->cbSection + sizeof(ULONG))

    // Look for the Excel 5.0a problem.
    // Excel 5.0a set the cbSection field to be 4 bytes too
    // high (fixed in 5.0b).  This code handles the more general case where the
    // cbSection is too long for the stream.  In such cases, if
    // all the properties actually fit within the stream, the
    // cbSection field is corrected.

    if (*pcbstm < _oSection + psh->cbSection)
    {
        // We'll fix this problem by adjusting the cbSection
        // value.  We have to be careful, though,
        // that the entire section fits within this new cbSection
        // value.  For efficiency, we'll just find the property
        // which is at the highest offset, and verify that it's
        // within the new section size.

        // Get what we think is the actual section length.
        ULONG cbSectionActual = *pcbstm - _oSection;

        ULONG dwHighestOffset = 0;
        ULONG cbProperty;

        // Find the property with the highest offset.

	for ( ; ppo < ppoMax; ppo++)
        {
            if( ppo->dwOffset > dwHighestOffset )
                dwHighestOffset = ppo->dwOffset;
        }

        // How long is this property?  Note that the following routine is
        // careful not to attempt to read beyond the end of the stream.

        cbProperty = PropertyLengthNoEH(
                                     // Pointer to property
                        (SERIALIZEDPROPERTYVALUE *)
		            _MapOffsetToAddress(dwHighestOffset),
                                     // Bytes between above ptr & end of stream
                        *pcbstm - _oSection - dwHighestOffset,
                        0,           // Flags
                        pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Does this property fit within the section?  If so, then fix this
        // property set.

        if( dwHighestOffset + DwordAlign(cbProperty) <= cbSectionActual )
        {
            // Until we call SetSize once, we don't know if the mapped stream
            // is writable, so we'll call SetSize here to ensure that it is.

    	    _MSTM(SetSize)(*pcbstm,             // Reset the same size
                           FALSE,               // Don't update the underlying stream
                           (VOID **) &_pph,     // The new mapping
                           pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            // Fix the section size
            psh->cbSection = dwHighestOffset + DwordAlign(cbProperty);
        }
        else
        {
            StatusCorruption(pstatus, "SumInfo cbSection is too long for the Stream.");
        }

    }   // if (*pcbstm < _oSection + psh->cbSection)


    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_FixSummaryInformation()


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixPackedPropertySet
//
// Synopsis:    Align the memory image of a propset.
//
// Algorithm:   We need to move the properties within the
//              property set so that they are properly aligned,
//              and we need to adjust the PID/Offset array accordingly.
//              This is complicated by the fact that we may have to
//              grow some propertes (which are not properly padded
//              for alignement) and at the same time we may have to
//              shrink some properties (which are over-padded).
//
//              To handle these two constraints, and to
//              avoid growing the underlying stream any more
//              than necessary, we process the property set in
//              two phases.  In the Compaction phase, we shrink
//              properties which are over-padded.  In the Expansion
//              phase, we grow properties which are under-padded.
//              For example, say we have a property set with 3
//              properties, all of which should be 4 bytes.  But
//              say they are currently 2, 4, and 6 bytes.  Thus
//              we must grow the first property, hold the second
//              constant, and shrink the third property.  In this
//              example, after the Compaction phase, the 3 properties
//              will be 2, 4, and 4 bytes.  After the Expansion phase,
//              the properties will be 4, 4, and 4 bytes.
//
//              To do all of this, we make a copy of the PID/Offset
//              array (apoT) and sort it.  We then proceed to make
//              two arrays of just offsets (no PIDs) - aopropShrink
//              and aopropFinal.  aopropShrink holds the offset for
//              each property after the Compaction phase.  aopropFinal
//              holds the offset for each property after the
//              Expansion phase.  (Note that each of these phases
//              could be skipped if they aren't necessary.)
//
//              Finally, we perform the Compaction and Expansion,
//              using aopropShrink and aopropFinal, respectively,
//              as our guide.
//
//              Note: this routine assumes that the property set
//              and section headers are valid (this is verified
//              already by the caller, _LoadHeader).
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     None
//---------------------------------------------------------------------------

int __cdecl fnOffsetCompare(VOID const *ppo1, VOID const *ppo2);

// DocumentSummaryInformation special case properties (w/packed vector elements)
#define PID_HEADINGPAIR 0x0000000c // heading pair (VT_VECTOR | VT_VARIANT):
					// {VT_LPSTR, VT_I4} pairs
#define PID_DOCPARTS	0x0000000d // docparts (VT_VECTOR | VT_LPSTR)
//#define PID_HLINKS	0x00000015 // hlinks vector

VOID
CPropertySetStream::_FixPackedPropertySet(OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    BOOLEAN fPacked = FALSE;
    BOOLEAN fDocSummaryInfo = FALSE;

    IFDBG( BOOLEAN fExpandDocSummaryInfo = FALSE );
    IFDBG( HRESULT &hr = *pstatus );

    PROPERTYSECTIONHEADER *psh = NULL;
    PROPERTYIDOFFSET *ppoT, *ppoTMax;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;

    PROPERTYIDOFFSET *apoT = NULL;

    ULONG *aopropShrink = NULL;
    ULONG *aopropFinal = NULL;
    ULONG cbprop;
    ULONG cCompact, cExpand;
    ULONG *poprop = NULL;

#if i386 == 0
    SERIALIZEDPROPERTYVALUE *ppropbuf = NULL;
    ULONG cbpropbuf = 0;
#endif

    ULONG cbtotal = 0;

    //  -----
    //  Begin
    //  -----

    propITrace( "CPropertySetStream::_FixPackedPropertySet" );
    *pstatus = STATUS_SUCCESS;

    // Determine if this is the first section of the DocSumInfo
    // property set.
    if ((_State & (CPSS_USERDEFINEDPROPERTIES | CPSS_DOCUMENTSUMMARYINFO)) ==
	 CPSS_DOCUMENTSUMMARYINFO)
    {
	fDocSummaryInfo = TRUE;
    }

    // Get pointers into this section's header.
    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // We know it's packed if the section-length isn't aligned.
    fPacked = !IsDwordAligned(psh->cbSection);

    // If we don't already know it's packed, check each of the properties in
    // the PID/Offset array to see if one is not properly aligned, if so we'll
    // assume that it's packed.  Also, if this is an Ansi DocSumInfo property set,
    // (first section), we'll assume that the HeadingPair and DocParts properties
    // are packed (vectors).

    if (!fPacked && psh != NULL)
    {
	for (ppo = ppoBase; ppo < ppoMax; ppo++)
	{
	    if ( !IsDwordAligned(ppo->dwOffset)
                 ||
		 ( fDocSummaryInfo
                   &&
                   _CodePage != CP_WINUNICODE
                   &&
		   ( ppo->propid == PID_HEADINGPAIR
                     ||
		     ppo->propid == PID_DOCPARTS
                   )
                 )
               )
	    {
		fPacked = TRUE;
		break;
	    }
	}
    }

    //  ----------------------------------------------------
    //  Fix the properties if they are packed or if there is
    //  unnecessary padding.
    //  ----------------------------------------------------

    // If we know there's a problem, set a _State flag
    // now.  If we can fix the problem below, we'll clear it.
    // Otherwise, the rest of the Class will know that there's
    // an unresolved problem.

    if (fPacked)
    {
	propDbg(( DEB_ITRACE, "_FixPackedPropertySet: packed properties\n" ));
        _State |= CPSS_PACKEDPROPERTIES;
    }


    //  ---------------------------------------------------------
    //  Create apoT (a sorted array of PID/Offsets), aopropShrink
    //  (the offsets for the Compaction phase) and aopropFinal
    //  (the offsets for the Expansion phase).
    //  ---------------------------------------------------------

    // Create a buffer for a temporary PID/Offset array.

    apoT = reinterpret_cast<PROPERTYIDOFFSET*>
           ( CoTaskMemAlloc( CB_PROPERTYIDOFFSET * (psh->cProperties + 1) ));
    if (apoT == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Copy the PID/offset pairs from the property set to the
    // temporary PID/Offset array.

    RtlCopyMemory(
	    apoT,
	    psh->rgprop,
	    psh->cProperties * CB_PROPERTYIDOFFSET);

    // Mark the end of the temporary array.

    ppoTMax = apoT + psh->cProperties;
    ppoTMax->propid = PID_ILLEGAL;
    ppoTMax->dwOffset = psh->cbSection;

    // Sort the PID/Offset array by offset and check for overlapping values:

    qsort(apoT, psh->cProperties, sizeof(apoT[0]), &fnOffsetCompare);

    // Create two arrays which will hold property offsets.
    // aopropShrink holds the offsets for the Compaction phase where
    // we shrink the property set.  aopropFinal holds the offsets
    // of the final property set, which will be achieved in the
    // Expansion phase.

    aopropShrink = reinterpret_cast<ULONG*>
                   ( CoTaskMemAlloc( sizeof(ULONG) *(psh->cProperties + 1) ));
    if (aopropShrink == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    aopropFinal = reinterpret_cast<ULONG*>
                  ( CoTaskMemAlloc( sizeof(ULONG)*(psh->cProperties + 1) ));
    if (aopropFinal == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

#if i386 == 0
    // On non-x86 machines, we can't directly access unaligned
    // properties.  So, allocate enough (aligned) memory to hold
    // the largest unaligned property.  We'll copy properties here
    // when we need to access them.

    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
    {
	if (!IsDwordAligned(ppoT->dwOffset))
	{
	    cbprop = DwordAlign(ppoT[1].dwOffset - ppoT->dwOffset);
	    if (cbpropbuf < cbprop)
	    {
		cbpropbuf = cbprop;
	    }
	}
    }

    if (cbpropbuf != 0)
    {
	ppropbuf = (SERIALIZEDPROPERTYVALUE *) CoTaskMemAlloc( cbpropbuf );
	if (ppropbuf == NULL)
	{
	    *pstatus = STATUS_NO_MEMORY;
            goto Exit;
	}
    }
#endif  // i386==0


    //  ----------------------------------------------
    //  Iterate through the properties, filling in the
    //  entries of aopropShrink and aopropFinal.
    //  ----------------------------------------------

    // We'll also count the number of compacts and expands
    // necessary.

    aopropShrink[0] = aopropFinal[0] = apoT[0].dwOffset;
    PROPASSERT(IsDwordAligned(aopropShrink[0]));
    cExpand = 0;
    cCompact = 0;

    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
    {
	SERIALIZEDPROPERTYVALUE *pprop;
	BOOLEAN fDocSumLengthComputed = FALSE;
        ULONG cbpropOriginal;

        // Validate the property's offset

        if( ppoT->dwOffset >= psh->cbSection )
        {
            StatusCorruption(pstatus, "Property's offset is too long for the section.");
            goto Exit;
        }

        // How much space does the property take up in the current
        // property set?

	cbpropOriginal = cbprop = ppoT[1].dwOffset - ppoT->dwOffset;
	pprop = (SERIALIZEDPROPERTYVALUE *)
		    _MapOffsetToAddress(ppoT->dwOffset);

#if i386 == 0
        // If necessary, put this property into an aligned buffer.

	if (!IsDwordAligned(ppoT->dwOffset))
	{
	    propDbg(( DEB_ITRACE, "_FixPackedPropertySet: unaligned pid=%x off=%x\n",
		                   ppoT->propid, ppoT->dwOffset ));
	    PROPASSERT(DwordAlign(cbprop) <= cbpropbuf);

	    RtlCopyMemory((VOID *) ppropbuf, pprop, cbprop);
	    pprop = ppropbuf;
	}
#endif
        // Calculate the actual length of this property, including
        // the necessary padding.  This might be bigger than the
        // property's current length (if the propset wasn't properly
        // padded), and it might be smaller than the property's current
        // length (if the propset was over-padded).

	if (ppoT->propid == PID_DICTIONARY)
	{
            // Get the size of the dictionary.

	    cbprop = DwordAlign(_DictionaryLength(
				    (DICTIONARY const *) pprop,
				    cbprop,
                                    pstatus));
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
	}
	else
	{
	    ULONG cbpropT = cbprop;

            // Ansi DocSumInfo property sets have two vector properties
            // which are packed.  If this is one of those properties,
            // we won't fix it yet, but we'll compute the size required
            // when the elements are un-packed.

	    if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
	    {
		if (ppoT->propid == PID_HEADINGPAIR)
		{
		    fDocSumLengthComputed = _FixHeadingPairVector(
					    PATCHOP_COMPUTESIZE,
					    pprop,
					    &cbpropT);
		}
		else
		if (ppoT->propid == PID_DOCPARTS)
		{
		    fDocSumLengthComputed = _FixDocPartsVector(
					    PATCHOP_COMPUTESIZE,
					    pprop,
					    &cbpropT);
		}
	    }

            // If we computed a length above, use it, otherwise calculate
            // the length using the standard rules (we've already checked
            // for the special cases).

	    if (fDocSumLengthComputed)
	    {
		cbprop = cbpropT;
#if DBGPROP
		fExpandDocSummaryInfo = TRUE;
#endif
	    }
	    else
	    {
		cbprop = PropertyLengthNoEH(pprop, DwordAlign(cbprop), 0, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    }

	}   // if (ppoT->propid == PID_DICTIONARY) ... else

	PROPASSERT(IsDwordAligned(cbprop));

        // Now that we know the actual cbprop, use it to update the
        // *next* entry in the two arrays of correct offsets.
        //
        // We want aopropFinal to hold the final, correct offsets,
        // so we'll use cbprop to calculate this array.
        // But for aopropShrink, we only want it to differ from
        // the original array (apoT) when a property is shrinking,
        // so we'll use min(cbNew,cbOld) for this array.

        poprop = &aopropShrink[ ppoT - apoT ]; // 1st do aopropShrink
        poprop[1] = poprop[0] + min(cbprop, cbpropOriginal);

        poprop = &aopropFinal[ ppoT - apoT ];  // 2nd do aopropFinal
        poprop[1] = poprop[0] + cbprop;

	propDbg(( DEB_ITRACE, "_FixPackedPropertySet: pid=%x off=%x->%x\n",
	          ppoT->propid, ppoT->dwOffset, poprop[0],
	          poprop[0] < ppoT->dwOffset? " (compact)" : poprop[0] > ppoT->dwOffset? " (expand)" : "" ));


        // Is this compaction or an expansion?
        // If we computed the doc-sum length, we count it as
        // an expansion, even if the total property size didn't change,
        // because we need the expand the elements within the vector.

	if (cbprop < cbpropOriginal)
	{
	    cCompact++;
	}
	else
	if (cbprop > cbpropOriginal || fDocSumLengthComputed)
	{
	    cExpand++;
	}
    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++)


    //  -------------------------------
    //  Compact/Expand the Property Set
    //  -------------------------------

    // We've now generated the complete aopropShrink and aopropFinal
    // offset arrays.  Now, if necessary, let's expand and/or compact
    // the property set to match these offsets.

    if (cExpand || cCompact)
    {
	ULONG cbstm;
	LONG cbdelta;

	cbstm = _oSection + psh->cbSection + _cbTail;
	cbdelta = aopropFinal[psh->cProperties] - psh->cbSection;

        // We may not have a writable mapped stream.  Do a SetSize on it
        // to ensure that we do.

	_MSTM(SetSize)(
		cbstm,
                FALSE,   // Not persistent
		(VOID **) &_pph,
                pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Always reload after obtaining a new _pph.
	psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;


        propDbg(( DEB_ITRACE, "_FixPackedPropertySet: cbstm=%x cbdelta=%x cexpand=%x ccompact=%x\n",
	                                              cbstm,   cbdelta,   cExpand,   cCompact ));

        //  -----------------------------
        //  Grow the Stream if necessary.
        //  -----------------------------

        // If we need to grow the stream, do it now.  If we need to shrink the stream,
        // we'll do it later, after the compaction & expansion phases.

        if (cbdelta > 0)
	{
            propDbg(( DEB_ITRACE, "SetSize(%x) _FixPackedPropertySet grow %x bytes\n",
		                   cbstm + cbdelta, cbdelta ));

            // On the set-size, say that this is a non-persistent
            // change, so that the underlying Stream isn't modified.
            // At this point, we don't know if this change should remain
            // permanent (if the caller closes without making any changes
            // the file should remain un-changed).

	    _MSTM(SetSize)(
		    cbstm + cbdelta,
                    FALSE,   // Not persistent
		    (VOID **) &_pph,
                    pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // reload all pointers into mapped image:

	    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // If there's another section after this one, move it back
	    // to the end of the stream now, which will create room for
            // our expansion.

	    if (_cbTail != 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"_FixPackedPropertySet(_cbTail:grow)",
			psh,
			Add2Ptr(pvSrc, cbdelta),
			pvSrc,
			_cbTail);
	    }
	}   // if (cbdelta > 0)

        // This previous step (growing the Stream), was the last one which can
        // fail.  We're about to modify the actual property set (we've been
        // working only with temporary buffers so far).  So we're always guaranteed
        // a good property set, or the original set, we'll never end up with a
        // half-updated set.


        //  ----------------
        //  Compaction Phase
        //  ----------------

        // Compact the property set if necessary.  I.e., adjust
        // the property set buffer so that it matches aopropShrink.

        if (cCompact > 0)
	{
	    // Start at the beginning and move each property forward.

	    poprop = aopropShrink;
	    for (ppoT = apoT; ppoT < ppoTMax; ppoT++, poprop++)
	    {
		if (*poprop != ppoT->dwOffset)
		{
		    PROPASSERT(*poprop < ppoT->dwOffset);
		    PROPASSERT(poprop[1] > *poprop);

		    // We're compacting; the property should not grow!

		    PROPASSERT(
			poprop[1] - *poprop <=
			ppoT[1].dwOffset - ppoT->dwOffset);

		    PropMoveMemory(
			    "_FixPackedPropertySet(compact)",
			    psh,
			    Add2Ptr(psh, *poprop),
			    Add2Ptr(psh, ppoT->dwOffset),
			    poprop[1] - *poprop);
		}
	    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++, poprop++)
	}   // if (cCompact > 0)


        //  ---------------
        //  Expansion phase
        //  ---------------

        // Recall that, whether or not we just did a compaction, aopropShrink
        // holds the property set offsets as they currently exist in the
        // property set.

        if (cExpand > 0)
        {
	    // Start at the end and move each property back.
            // The 'poprop' gives us the final correct offset
            // of the current property.

            LONG lOffsetIndex;
	    poprop = &aopropFinal[psh->cProperties - 1];

            // Start at the second-to-last entry in the arrays of offsets
            // (the last entry is an artificially added one to mark the end of the
            // property set).

	    for (lOffsetIndex = (LONG)(ppoTMax - apoT - 1), ppoT = ppoTMax - 1;
                 lOffsetIndex >=0;
                 lOffsetIndex--, poprop--, ppoT--)
	    {
                // Get a pointer to the final location of this
                // property.

		SERIALIZEDPROPERTYVALUE *pprop;
		pprop = (SERIALIZEDPROPERTYVALUE *)
			    Add2Ptr(psh, *poprop);

		if (*poprop != aopropShrink[ lOffsetIndex ])
		{
		    ULONG cbCopy, cbOld;
			
		    PROPASSERT(*poprop > aopropShrink[ lOffsetIndex ]);
		    PROPASSERT(poprop[1] > *poprop);
                    PROPASSERT(aopropShrink[ lOffsetIndex+1 ] > aopropShrink[ lOffsetIndex ]);

                    // How many bytes should we copy?  The minimum size of the property
                    // calculated using the old and new offsets.

		    cbCopy = poprop[1] - poprop[0];
		    cbOld = aopropShrink[ lOffsetIndex+1 ]
                            - aopropShrink[ lOffsetIndex+0 ];

		    if (cbCopy > cbOld)
		    {
			cbCopy = cbOld;
		    }

                    // Copy the property from its old location
                    // (psh+aopropShrink[lOffsetIndex]) to its new location
                    // (pprop == psh+*poprop).

                    propDbg(( DEB_ITRACE,
                              "_FixPackedPropertySet:move pid=%x off=%x->%x "
                              "cb=%x->%x cbCopy=%x z=%x @%x\n",
                              ppoT->propid, ppoT->dwOffset, *poprop,
                              cbOld, poprop[1] - *poprop, cbCopy, DwordRemain(cbCopy), _MapAddressToOffset(Add2Ptr(pprop, cbCopy))));

		    PropMoveMemory(
			    "_FixPackedPropertySet(expand)",
			    psh,
			    pprop,
			    Add2Ptr(psh, aopropShrink[ lOffsetIndex ]),
			    cbCopy);
		    RtlZeroMemory(
			    Add2Ptr(pprop, cbCopy),
			    DwordRemain(cbCopy));

		}   // if (*poprop != ppoT->dwOffset)

                // If this is an older DocSumInfo property set,
                // and this property is one of the vector values,
                // we must expand the vector elements now that we've
                // room for it.

		if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
		{
		    ULONG cbpropT = poprop[1] - poprop[0];

		    if (ppoT->propid == PID_HEADINGPAIR)
		    {
			_FixHeadingPairVector(
					PATCHOP_EXPAND,
					pprop,
					&cbpropT);
		    }
		    else
		    if (ppoT->propid == PID_DOCPARTS)
		    {
			_FixDocPartsVector(
					PATCHOP_EXPAND,
					pprop,
					&cbpropT);
		    }
		}   // if (fDocSummaryInfo)
	    }   // for (ppoT = ppoTMax; --ppoT >= apoT; popropNew--)
	}   // if (cExpand != 0)



        //  ---------------------------------------------------------
	//  Patch the section size and the moved properties' offsets.
        //  ---------------------------------------------------------

	DebugTrace(0, DEBTRACE_PROPPATCH, (
	    "_FixPackedPropertySet: Patch section size %x->%x\n",
	    psh->cbSection,
	    psh->cbSection + cbdelta));

	psh->cbSection += cbdelta;

        // Iterate through the original PID/Offset array to update the
        // offsets.

	for (ppo = ppoBase; ppo < ppoMax; ppo++)
	{
            // Search the temporary PID/Offset array (which has the updated
            // offsets) for ppo->propid.

	    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
	    {
		if (ppo->propid == ppoT->propid)
		{
                    // We've found ppo->propid in the temporary PID/Offset
                    // array.  Copy the offset value from the temporary array
                    // to the actual array in the property set.

		    PROPASSERT(ppo->dwOffset == ppoT->dwOffset);
		    ppo->dwOffset = aopropFinal[ppoT - apoT];
#if DBGPROP
		    if (ppo->dwOffset != ppoT->dwOffset)
		    {
                        propDbg(( DEB_ITRACE,
                                  "_FixPackedPropertySet: Patch propid %x offset=%x->%x\n",
			          ppo->propid, ppoT->dwOffset, ppo->dwOffset ));
		    }
#endif
		    break;

		}   // if (ppo->propid == ppoT->propid)
	    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
	}   // for (ppo = ppoBase; ppo < ppoMax; ppo++)

        //  ------------
        //  Fix the tail
        //  ------------


        // If we have a tail, fix it's offset in the FmtID/Offset
        // array.  Also, if we've overall shrunk this section, bring
        // the tail in accordingly.

        if (_cbTail != 0)
	{
	    if (cbdelta < 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"_FixPackedPropertySet(_cbTail:shrink)",
			psh,
			Add2Ptr(pvSrc, cbdelta),
			pvSrc,
			_cbTail);
	    }

	    _PatchSectionOffsets(cbdelta);

	}   // if (_cbTail != 0)


        // If we get to this point we've successfully un-packed (or
        // un-over-padded) the property set, so we can clear the
        // state flag.

	_State &= ~CPSS_PACKEDPROPERTIES;

    }   // if (cExpand || cCompact)


    //  ----
    //  Exit
    //  ----

Exit:

    CoTaskMemFree( apoT );
    CoTaskMemFree( aopropShrink );
    CoTaskMemFree( aopropFinal );

#if i386 == 0
    CoTaskMemFree( (BYTE *) ppropbuf );
#endif // i386

}   // CPropertySetStream::_FixPackedPropertySet()


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixDocPartsVector
//
// Synopsis:    Align the memory image of a DocParts vector
//              The DocParts property is part of the DocSumInfo
//              property set (first section).  It is a vector
//              of strings, and in Ansi property sets it's packed
//              and must be un-packed.
//
// Arguments:	[PatchOp]	-- patch request
//		[pprop]         -- property value to be patched or sized
//		[pcbprop]	-- in:  length of buffer at pprop
//                                 out: computed property length
//
// Returns:     TRUE if property type and all elements meet expectations;
//		FALSE on error
//
// Note:	Operate on a DocumentSummaryInformation first section property,
//		PID_DOCPARTS.  This property is assumed to be an array of
//		VT_LPSTRs.
//
//		PATCHOP_COMPUTESIZE merely computes the size required to unpack
//		the property, and must assume it is currently unaligned.
//
//		PATCHOP_ALIGNLENGTHS patches all VT_LPSTR lengths to DWORD
//		multiples, and may rely on the property already being aligned.
//
//		PATCHOP_EXPAND expands the property from the Src to Dst buffer,
//		moving elements to DWORD boundaries, and patching VT_LPSTR
//		lengths to DWORD multiples.  The Src buffer is assumed to be
//		unaligned, and the Dst buffer is assumed to be properly sized.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixDocPartsVector(
    IN PATCHOP PatchOp,
    IN OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcbprop)
{
    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pprop != NULL);
    PROPASSERT(pcbprop != NULL);

    ULONG cbpropIn = *pcbprop;

    // Ensure we'll be able to read what we need

    if( cbpropIn < sizeof(pprop->dwType) + sizeof(DWORD) )
        // Not a recognizable docparts vector (probably corrupt)
        return FALSE;
    cbpropIn -= sizeof(pprop->dwType) + sizeof(DWORD);

    // We're looking for a vector of Ansi strings

    if ( PropByteSwap(pprop->dwType) == (VT_VECTOR | VT_LPSTR)
         &&
         _CodePage != CP_WINUNICODE)
    {
	ULONG cString;
	VOID *pv;

        // How many strings?
	cString = PropByteSwap( *(DWORD *) pprop->rgb );

        // Point to the start of the strings
	pv = Add2Ptr(pprop->rgb, sizeof(DWORD));

        // Fix the elements in this vector
	if (_FixDocPartsElements(PatchOp, cString, pv, pv, &cbpropIn))
	{
	    *pcbprop = cbpropIn + CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);
	    return(TRUE);
	}
    }
    return(FALSE);	// Not a recognizable DocParts vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixDocPartsElements
//
// Synopsis:    Iteratively align the memory image of DocParts elements
//
// Arguments:	[PatchOp]	-- patch request
//              [cString]	-- count of strings remaining in the vector
//              [pvDst]		-- aligned overlapping destination buffer
//              [pvSrc]		-- unaligned overlapping source buffer
//              [pcbprop]	-- in:  size of buffer at pvSrc
//                             out: pointer to computed property length
//
// Returns:     TRUE if all remaining elements meet expectations;
//              FALSE on error
//
// Note:        The pvDst & pvSrc buffers must be in property-set
//              byte order (little endian).
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixDocPartsElements(
    IN PATCHOP PatchOp,
    IN ULONG cString,
    OUT VOID *pvDst,
    IN VOID UNALIGNED const *pvSrc,
    IN OUT ULONG *pcbprop)
{
    ULONG cb = 0;
    PROPERTYSECTIONHEADER UNALIGNED *psh = _GetSectionHeader();
    ULONG cbpropIn = *pcbprop;
    const ULONG cStringMax = cString;
    BOOLEAN bRet = FALSE;

    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pvDst >= pvSrc);
    PROPASSERT(PatchOp != PATCHOP_ALIGNLENGTHS || pvDst == pvSrc);

    if (cString == 0)
    {
        *pcbprop = 0;
        return(TRUE);
    }

    ULONG* acb = (ULONG *) CoTaskMemAlloc(cStringMax * sizeof(ULONG));

    if (NULL == acb)
    {
        return FALSE;
    }

    while (TRUE)
    {
        if (cString == 0)
        {
            cbpropIn = 0;
            bRet = TRUE;
            break;
        }

        // Get the cb and validate the source.  If it's too long, return false,
        // and let the normal corruption-detection code deal with it.

        if( cbpropIn < sizeof(DWORD) )
        {
            bRet = FALSE;
            break;
        }
        cb = sizeof(DWORD) + PropByteSwap( *(DWORD UNALIGNED *) pvSrc );

        if( cbpropIn < cb )
        {
            bRet = FALSE;
            break;
        }
        cbpropIn -= cb;

        // If the caller serialized the vector properly, all we need to do is
        // to round up the string lengths to DWORD multiples, so readers that
        // treat these vectors as byte-aligned get faked out.  We expect
        // readers will not have problems with a DWORD aligned length, and a
        // '\0' character a few bytes earlier than the length indicates.

        if (PatchOp == PATCHOP_ALIGNLENGTHS)
        {
            cb = DwordAlign(cb);	// Caller says it's already aligned
        }

        cString = cString - 1;
        pvDst = Add2Ptr(pvDst, DwordAlign(cb));
        pvSrc = (VOID UNALIGNED const *)Add2ConstPtr(pvSrc, cb);
        acb[cString] = cb;  // save length so we can loop backwards
    } // while loop

    if (bRet == TRUE)
    {
        while (cString < cStringMax)
        {
            cb = acb[cString];     // get the previous length
            pvDst = Add2Ptr(pvDst, -(LONG)DwordAlign(cb));
            pvSrc = (VOID UNALIGNED const *)Add2ConstPtr(pvSrc, -(LONG)cb);
            cbpropIn = cbpropIn + DwordAlign(cb);

            if (PatchOp == PATCHOP_EXPAND)
            {
            // By the time we're called for expansion, the caller has ensured
            // that we have enough space at pvDst to do this move/zero without
            // overrunning someone's stack/heap/etc.

            PropMoveMemory(
		    "_FixDocPartsElements",
		    _GetSectionHeader(),
		    pvDst,
		    pvSrc,
		    cb);
            RtlZeroMemory(Add2Ptr(pvDst, cb), DwordRemain(cb));

            DebugTrace(0, DEBTRACE_PROPPATCH, (
                "_FixDocPartsElements: Move(%x:%s) "
                "cb=%x->%x off=%x->%x z=%x @%x\n",
                cString,
                Add2Ptr(pvDst, sizeof(ULONG)),
                cb - sizeof(ULONG),
                DwordAlign(cb) - sizeof(ULONG),
                _MapAddressToOffset((void const *)pvSrc),
                _MapAddressToOffset(pvDst),
                DwordRemain(cb),
                _MapAddressToOffset(Add2Ptr(pvDst, cb))));
            }
            if (PatchOp != PATCHOP_COMPUTESIZE)
            {
                PROPASSERT(
                    PatchOp == PATCHOP_ALIGNLENGTHS ||
                    PatchOp == PATCHOP_EXPAND);

                DebugTrace(0, DEBTRACE_PROPPATCH, (
                    "_FixDocPartsElements: Patch(%x:%s) cb=%x->%x\n",
                    cString,
                    Add2Ptr(pvDst, sizeof(ULONG)),
                    *(ULONG *) pvDst,
                    DwordAlign(*(ULONG *) pvDst)));

                *(ULONG *) pvDst = PropByteSwap( (ULONG) DwordAlign( PropByteSwap( *(ULONG *) pvDst )));
            }

            cString++;          // proceed to next element
        }
    }
    *pcbprop = cbpropIn;

    if (acb != NULL)
        CoTaskMemFree (acb);

    return bRet;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixHeadingPairVector
//
// Synopsis:    Align the memory image of a HeadingPair vector.
//              The HeadingPair property is part of the DocSumInfo
//              property set (first section).  It's a vector of
//              Variants, where the elements are alternating
//              strings and I4s (the string is a heading name,
//              and the I4 is the count of DocumentParts in that
//              heading).  In Ansi property sets, these elements
//              are packed, and must be un-packed.
//
// Arguments:	[PatchOp]	-- patch request
//		[pprop]         -- property value to be patched or sized
//		[pcbprop]	-- in:  size of buffer at pprop
//                                 out: pointer to computed property length
//
// Returns:     TRUE if property and all elements meet expectations;
//		FALSE on error
//
// Note:	Operate on a DocumentSummaryInformation first section property,
//		PID_HEADINGPAIR.  This property is assumed to be an array of
//		VT_VARIANTs with an even number of elements.  Each pair must
//		consist of a VT_LPSTR followed by a VT_I4.
//
//		PATCHOP_COMPUTESIZE merely computes the size required to unpack
//		the property, and must assume it is currently unaligned.
//
//		PATCHOP_ALIGNLENGTHS patches all VT_LPSTR lengths to DWORD
//		multiples, and may rely on the property already being aligned.
//
//		PATCHOP_EXPAND expands the property from the Src to Dst buffer,
//		moving elements to DWORD boundaries, and patching VT_LPSTR
//		lengths to DWORD multiples.  The Src buffer is assumed to be
//		unaligned, and the Dst buffer is assumed to be properly sized.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixHeadingPairVector(
    IN PATCHOP PatchOp,
    IN OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcbprop)
{
    ULONG celem;
    ULONG cbpropIn = *pcbprop;

    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pprop != NULL);
    PROPASSERT(pcbprop != NULL);

    // Ensure we have enough room in pprop to get the element count

    if( cbpropIn < CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG) )
        // Not what we're looking for (and corrupt, but we'll let the standard
        // code deal with that).
        return FALSE;

    // If the property is a variant vector, and
    // there are an even number of elements, and
    // the property set is Ansi ...

    celem = PropByteSwap(*(ULONG *) pprop->rgb);
    if( PropByteSwap(pprop->dwType) == (VT_VECTOR | VT_VARIANT)
        &&
	(celem & 1) == 0
        &&
        _CodePage != CP_WINUNICODE)
    {
	pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr(pprop->rgb, sizeof(ULONG));
        cbpropIn -= CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);

	if (_FixHeadingPairElements(PatchOp, celem/2, pprop, pprop, &cbpropIn))
	{
	    *pcbprop = cbpropIn + CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);
	    return(TRUE);
	}
    }
    return(FALSE);	// Not a recognizable HeadingPair vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixHeadingPairElements
//
// Synopsis:    Recursively align the memory image of HeadingPair elements
//
// Arguments:	[PatchOp]	-- patch request
//		[cPairs]	-- count of heading pairs remaining
//		[ppropDst]	-- aligned overlapping destination buffer
//		[ppropSrc]	-- unaligned overlapping source buffer
//		[pcbprop]	-- in:  size of buffer at ppropSrc
//                                 out: pointer to computed property length
//
// Returns:     TRUE if all remaining elements meet expectations;
//		FALSE on error
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixHeadingPairElements(
    IN PATCHOP PatchOp,
    IN ULONG cPairs,
    OUT SERIALIZEDPROPERTYVALUE *ppropDst,
    IN SERIALIZEDPROPERTYVALUE UNALIGNED const *ppropSrc,
    IN OUT ULONG *pcbprop)
{
    ULONG cbpropIn = *pcbprop;

    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(ppropDst >= ppropSrc);
    PROPASSERT(PatchOp != PATCHOP_ALIGNLENGTHS || ppropDst == ppropSrc);

    if (cPairs == 0)
    {
	*pcbprop = 0;
	return(TRUE);
    }

    // Ensure we can at least look at the type and length
    if( cbpropIn < CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG) )
        return FALSE;

    // If the first element of the pair is a VT_LPSTR, ...

    if( PropByteSwap(ppropSrc->dwType) == VT_LPSTR )
    {
	ULONG cb;

	// Compute size of the string element.

	cb = CB_SERIALIZEDPROPERTYVALUE
             +
             sizeof(ULONG)
             +
             PropByteSwap( *(DWORD UNALIGNED *) ppropSrc->rgb );

        // Ensure we can read all of this

        if( cbpropIn < cb  )
            return FALSE;

	// If the caller serialized the vector properly, all we need to do is
	// to round up the string lengths to DWORD multiples, so readers that
	// treat these vectors as byte-aligned get faked out.  We expect
	// readers will not have problems with a DWORD aligned length, and a
	// '\0' character a few bytes earlier than the length indicates.

	if (PatchOp == PATCHOP_ALIGNLENGTHS)
	{
	    cb = DwordAlign(cb);	// Caller says it's already aligned
	}

        // We're might increment cb next, but first ensure we have that much room
        if( cbpropIn < cb + CB_SERIALIZEDPROPERTYVALUE + sizeof(DWORD) )
            return FALSE;

	// So the first element was a VT_LPSTR, which is part of what we're looking for.
        // Now, we also want the second element of the pair to be a VT_I4, ...

	if ( PropByteSwap( (DWORD) VT_I4 )
             ==
             ( (SERIALIZEDPROPERTYVALUE UNALIGNED const *)
               Add2ConstPtr(ppropSrc, cb)
             )->dwType )
	{
            // So far, this looks like the special-case property we're after
            // (the first pair is an lpstr/i4).  Make a recursive call to see
            // if the remainder of the vector is the same (and depending on PatchOp,
            // actually fix up the remainder).

	    cb += CB_SERIALIZEDPROPERTYVALUE + sizeof(DWORD);
            cbpropIn -= cb;

	    if (_FixHeadingPairElements(
			    PatchOp,
			    cPairs - 1,
			    (SERIALIZEDPROPERTYVALUE *)
				    Add2Ptr(ppropDst, DwordAlign(cb)),
			    (SERIALIZEDPROPERTYVALUE UNALIGNED const *)
				    Add2ConstPtr(ppropSrc, cb),
			    &cbpropIn ))
	    {
                // Yes, the remainder of the vector matched what we're looking for,
                // and depending on PatchOp it may be already fixed.  In any case,
                // cbpropIn was updated to show its total size, so now let's show
                // the total size including this current pair.

		*pcbprop = cbpropIn + DwordAlign(cb);

                // Are we actually doing an expansion (as opposed to just calcing the cb)?

		if (PatchOp == PATCHOP_EXPAND)
		{
		    // Move the unaligned VT_I4 property back in memory to an
		    // aligned boundary, move the string back to a (possibly
		    // different) aligned boundary, zero the space in between
		    // the two and patch the string length to be a DWORD
		    // multiple to fake out code that expects vector elements
		    // to be byte aligned.
                    //
                    // If we're doing an expand, we know that the src and dst buffers
                    // are sufficiently large.

		    // Adjust byte count to include just the string element.

		    cb -= CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);

		    // Move the VT_I4 element.

		    PropMoveMemory(
			    "_FixHeadingPairElements:I4",
			    _GetSectionHeader(),
			    Add2Ptr(ppropDst, DwordAlign(cb)),
			    Add2ConstPtr(ppropSrc, cb),
			    CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG));

		    // Move the VT_LPSTR element.

		    PropMoveMemory(
			    "_FixHeadingPairElements:LPSTR",
			    _GetSectionHeader(),
			    ppropDst,
			    ppropSrc,
			    cb);

		    // Zero the space in between.

		    RtlZeroMemory(Add2Ptr(ppropDst, cb), DwordRemain(cb));

		    DebugTrace(0, DEBTRACE_PROPPATCH, (
		        "_FixHeadingPairElements: Move(%x:%s) "
			    "cb=%x->%x off=%x->%x z=%x @%x\n",
		        cPairs,
		        &ppropDst->rgb[sizeof(ULONG)],
		        PropByteSwap( *(ULONG *) ppropDst->rgb ),
		        DwordAlign(PropByteSwap( *(ULONG *) ppropDst->rgb )),
		        _MapAddressToOffset(ppropSrc),
		        _MapAddressToOffset(ppropDst),
		        DwordRemain(cb),
		        _MapAddressToOffset(Add2Ptr(ppropDst, cb))));
		}

		if (PatchOp != PATCHOP_COMPUTESIZE)
		{
		    PROPASSERT(
			PatchOp == PATCHOP_ALIGNLENGTHS ||
			PatchOp == PATCHOP_EXPAND);
#ifdef DBGPROP
		    SERIALIZEDPROPERTYVALUE const *ppropT =
			(SERIALIZEDPROPERTYVALUE const *)
			    Add2Ptr(ppropDst, DwordAlign(cb));
#endif
		    DebugTrace(0, DEBTRACE_PROPPATCH, (
			"_FixHeadingPairElements: Patch(%x:%s) "
			    "cb=%x->%x, vt=%x, %x\n",
			cPairs,
			&ppropDst->rgb[sizeof(ULONG)],
			PropByteSwap( *(ULONG *) ppropDst->rgb ),
			DwordAlign( PropByteSwap( *(ULONG *) ppropDst->rgb )),
			PropByteSwap( ppropT->dwType ),
			PropByteSwap( *(ULONG *) ppropT->rgb )));

		    // Patch the string length to be a DWORD multiple.

		    *(ULONG *) ppropDst->rgb
                        = PropByteSwap( (ULONG) DwordAlign( PropByteSwap( *(ULONG *) ppropDst->rgb )));
		}
		return(TRUE);
	    }
	}
    }
    return(FALSE);	// Not a recognizable HeadingPair vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertySet
//
// Synopsis:    Return the classid for the property set code
//
// Arguments:   [pspss]         -- pointer to buffer for output
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::QueryPropertySet(OUT STATPROPSETSTG *pspss,
                                     OUT NTSTATUS       *pstatus) const
{
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::QueryPropertySet" );
    propTraceParameters(( "pspss=%p", pspss ));

    if ((_State & CPSS_USERDEFINEDDELETED) || _cSection < 1)
    {
	StatusAccessDenied(pstatus, "QueryPropertySet: deleted or no section");
        goto Exit;
    }
    _MSTM(QueryTimeStamps)(
                pspss,
                (BOOLEAN) ((_Flags & CREATEPROP_NONSIMPLE) != 0));
    pspss->clsid = _pph->clsid;
    pspss->fmtid = _GetFormatidOffset(
			    (_State & CPSS_USERDEFINEDPROPERTIES)? 1 : 0)->fmtid;
    pspss->grfFlags = _CodePage == CP_WINUNICODE?
    PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI;

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetClassId
//
// Synopsis:    Set the classid for the property set code
//
// Arguments:   [pclsid]        -- pointer to new ClassId
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::SetClassId(IN GUID const *pclsid,
                               OUT NTSTATUS  *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::SetClassId" );
    propTraceParameters(( "clsid=%s", static_cast<const char*>(CStringize(*pclsid)) ));

    if (IsReadOnlyPropertySet(_Flags, _State))
    {
	StatusAccessDenied(pstatus, "SetClassId: deleted or read-only");
        goto Exit;
    }

    _SetModified(pstatus);
    if( !NT_SUCCESS(*pstatus) )
    {
        TraceStatus("SetClassId: couldn't SetModified");
        goto Exit;
    }

    _pph->clsid = *pclsid;

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::EnumeratePropids
//
// Synopsis:    enumerates the property ids in a prop set
//
// Arguments:   [pkey]     -- pointer to bookmark (0 implies beginning)
//              [pcprop]   -- on input: size; on output: # of props returned.
//              [apropids] -- output buffer
//              [pstatus]  -- pointer to NTSTATUS code
//
// Returns:     TRUE if more properties are available
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::EnumeratePropids(
    IN OUT ULONG *pkey,
    IN OUT ULONG  *pcprop,
    OPTIONAL OUT PROPID *apropids,
    OUT NTSTATUS *pstatus)
{
    PROPERTYIDOFFSET *ppo, *ppoStart, *ppoMax;
    ULONG cprop = 0;
    BOOLEAN fMorePropids = FALSE;
    PROPID propidPrev = *pkey;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::EnumeratePropids" );
    propTraceParameters(( "pkey=%p(%d), pcprop=%p(%d), apropids=%p",
                           pkey,*pkey,  pcprop,&pcprop, apropids ));

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "EnumeratePropids: deleted");
        goto Exit;
    }

    if (_LoadPropertyOffsetPointers(&ppoStart, &ppoMax, pstatus) == NULL)
    {
        // Either there's no section, or there was an error
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }
    else
    {
        // If the caller passed in the phKey cookie (it's really a propid),
        // move ppoStart up to the point just beyond it.

        if (propidPrev != 0)
        {
            for (ppo = ppoStart; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == propidPrev)
                {
                    ppoStart = ++ppo;
                    break;
                }
            }
        }

        // Now, starting a ppoStart, loop through the remaining
        // propids, until we find one that we can return
        // (we don't return, e.g. the propid for the dicitionary).

        for (ppo = ppoStart; ppo < ppoMax; ppo++)
        {
            if (ppo->propid != PID_DICTIONARY &&
                ppo->propid != PID_CODEPAGE &&
                ppo->propid != PID_LOCALE &&
                ppo->propid != PID_BEHAVIOR)
            {
                if (cprop >= *pcprop)
                {
                    fMorePropids = TRUE;
                    break;
                }
                if (apropids != NULL)
                {
                    apropids[cprop] = ppo->propid;
                }
                cprop++;
                propidPrev = ppo->propid;
            }
        }
    }
    *pkey = propidPrev;
    *pcprop = cprop;

    //  ----
    //  Exit
    //  ----

Exit:

    return(fMorePropids);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadPropertyOffsetPointers
//
// Synopsis:    Load start and (past) end pointers to PROPERTYIDOFFSET array
//
// Arguments:   [pppo]          -- pointer to base of PROPERTYIDOFFSET array
//              [pppoMax]       -- pointer past end of PROPERTYIDOFFSET array
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     Pointer to Section Header, NULL if section not present
//              or if there was an error.
//---------------------------------------------------------------------------

PROPERTYSECTIONHEADER *
CPropertySetStream::_LoadPropertyOffsetPointers(
    OUT PROPERTYIDOFFSET **pppo,
    OUT PROPERTYIDOFFSET **pppoMax,
    OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER *psh = NULL;
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());

    if (_cSection != 0)
    {
        psh = _GetSectionHeader();
        ULONG cbstm = _MSTM(GetSize)(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Ensure that we can read all of the PID/Offset
        // table.

        if (cbstm < _oSection ||
            cbstm < _oSection + CB_PROPERTYSECTIONHEADER ||
            cbstm < _oSection + CB_PROPERTYSECTIONHEADER +
                psh->cProperties * CB_PROPERTYIDOFFSET)
        {
            StatusCorruption(pstatus, "LoadPropertyOffsetPointers: stream size");
            goto Exit;
        }

        *pppo = psh->rgprop;
        *pppoMax = psh->rgprop + psh->cProperties;
    }

    //  ----
    //  Exit
    //  ----

Exit:
    if( !NT_SUCCESS(*pstatus) )
        psh = NULL;
    else if( NULL == psh )
        // This should never happen.
        *pstatus = STATUS_INTERNAL_DB_CORRUPTION;

    return(psh);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadProperty
//
// Synopsis:    return a pointer to the specified property value
//
// Arguments:   [propid]        -- property id for property
//              [pcbprop]       -- pointer to return property size, 0 on error
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     SERIALIZEDPROPERTYVALUE * -- NULL if not present
//---------------------------------------------------------------------------

SERIALIZEDPROPERTYVALUE *
CPropertySetStream::_LoadProperty(
    IN PROPID propid,
    OUT OPTIONAL ULONG *pcbprop,
    OUT NTSTATUS *pstatus )
{
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;
    SERIALIZEDPROPERTYVALUE *pprop = NULL;

    *pstatus = STATUS_SUCCESS;

    // Get a pointer to the section header, and to the beginning
    // and end of the propid/offset array.

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Do we have a section?
    if (psh != NULL)
    {
        // Loop through the propid/offset array in search of the 
        // target propid.

        for (ppo = ppoBase; ppo < ppoMax; ppo++)
        {
            // Verify that this offset is reasonable, and that the
            // property value's type is within the section size.

            if (IsDwordAligned(ppo->dwOffset)
                &&
                ppo->dwOffset >= CB_PROPERTYSECTIONHEADER
                                 +
                                 psh->cProperties * CB_PROPERTYIDOFFSET
                &&
                psh->cbSection >= ppo->dwOffset + CB_SERIALIZEDPROPERTYVALUE)
            {
                // If this isn't the propid we're looking for, move on.
                if (ppo->propid != propid)
                {
                    // Nope - move on.
                    continue;
                }

                // Yes, this is the property we're looking for.  Point
                // pprop to the serialized value.

                pprop = (SERIALIZEDPROPERTYVALUE *)
                    _MapOffsetToAddress(ppo->dwOffset);

                // Does the caller want to know the serialized size of this property?

                if (pcbprop != NULL)
                {
                    // Yes, we need to figure out the size.

                    ULONG cb;

                    // The size can't possibly be bigger than what's left of the section
                    // after the start of this property.

                    cb = psh->cbSection - ppo->dwOffset;

                    // The dictionary property requires special-case handling.

                    if (propid == PID_DICTIONARY)
                    {
                        *pcbprop = _DictionaryLength(
                                        (DICTIONARY const *) pprop,
                                        cb, // Bytes available at pprop
                                        pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    }

                    // Otherwise, just use PropertyLength to figure it out.

                    else
                    {
                         // cb shows bytes available at pprop
			*pcbprop = PropertyLengthNoEH(pprop, cb, 0, pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    }
                }   // if (pcbprop != NULL)

                if (pcbprop == NULL ||
                    psh->cbSection >= ppo->dwOffset + *pcbprop)
                {
                    // Success
                    goto Exit;
                }
            }   // if (IsDwordAligned(ppo->dwOffset)

            pprop = NULL;
            StatusCorruption(pstatus, "LoadProperty: property offset");
            goto Exit;
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(pprop);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::GetValue
//
// Synopsis:    return a pointer to the specified property value
//
// Arguments:   [propid]        -- property id of property
//              [pcbprop]       -- pointer to returned property length
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     pointer to property value
//---------------------------------------------------------------------------

SERIALIZEDPROPERTYVALUE const *
CPropertySetStream::GetValue(
    IN PROPID propid,
    OUT ULONG *pcbprop,
    OUT NTSTATUS *pstatus)
{
    SERIALIZEDPROPERTYVALUE *pprop = NULL;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::GetValue" );
    propTraceParameters(( "propid=0x%x, pcbprop=%p", propid, pcbprop ));

    pprop = NULL;

    // 2nd section hack

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "GetValue: deleted");
        goto Exit;
    }

    // You can't read the dictionary directly

    if (propid == PID_DICTIONARY)
    {
	DebugTrace(0, DEBTRACE_ERROR, ("GetValue: PID_DICTIONARY\n"));
	StatusInvalidParameter(pstatus, "GetValue: PID_DICTIONARY");
        goto Exit;
    }

    // You also can't read the special security & modify-time properties.

    if (propid == PID_SECURITY || propid == PID_MODIFY_TIME)
    {
        StatusError( pstatus, "PID_SECURITY, PID_MODIFY_TIME not supported", STATUS_NOT_SUPPORTED );

    }

    else
    {
        // So this is a valid property to read, get it into pprop.

	pprop = _LoadProperty(propid, pcbprop, pstatus);
        if( !NT_SUCCESS(*pstatus) )
        {
            pprop = NULL;
            goto Exit;
        }
    }   // if (propid == PID_SECURITY || propid == PID_MODIFY_TIME) ... else

#if DBGPROP
    if (pprop == NULL)
    {
        propDbg(( DEB_ITRACE, "GetValue: propid=%lx pprop=NULL\n", propid ));
    }
    else
    {
        char valbuf[CB_VALUESTRING];

        propDbg(( DEB_ITRACE,  "GetValue: propid=%lx pprop=%l" szX " vt=%hx val=%s cb=%l" szX "\n",
                                propid,
                                _MapAddressToOffset(pprop),
                                PropByteSwap( pprop->dwType ),
                                ValueToString(pprop, *pcbprop, valbuf, sizeof(valbuf)),
                                *pcbprop ));
    }
#endif

    //  ----
    //  Exit
    //  ----

Exit:

    if( STATUS_NOT_SUPPORTED == *pstatus )
        propSuppressExitErrors();

    return(pprop);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetValue
//
// Synopsis:    update/add/delete property values
//
// Arguments:   [cprop]         -- count of properties
//              [pip]           -- pointer to indirect indexes
//              [avar]          -- PROPVARIANT array
//              [apinfo]        -- PROPERTY_INFORMATION array
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//
// Note:        All the properties in the apinfo array can be classified into
//              one of the following categories:
//
//              PROPOP_IGNORE:
//                No change.  Deleting a non-existent property or the same
//                propid appears later in the apinfo array.
//
//              PROPOP_DELETE:
//                Deletion of an existing property.  Remove the
//                PROPERTYIDOFFSET structure from the property offset array and
//                and pack the remaining entries.  Delete the property value
//                and pack remaining property values
//
//              PROPOP_INSERT:
//                Addition of a new property.  Insert the new PROPERTYIDOFFSET
//                structure at the end of the property offset array.  Insert
//                the new property value at the end of the section/stream.
//
//              PROPOP_MOVE:
//                A property whose value needs to be updated out of place
//                because of a change in the property value's size.  A property
//                value is moved to the end of the section if it grows or
//                shrinks across a DWORD boundary.  The existing value is
//                removed from the section and the remaining values are packed.
//                Then, the new value is inserted at the end of the section.
//                The idea here is to move variable length properties that are
//                being changed frequently as near as possible to the end of
//                the stream to minimize the cost of maintaining a packed set
//                of property values.  Note that the property offset structure
//                is not moved around in the array.
//
//              PROPOP_UPDATE:
//                A property whose value can be updated in-place.  The property
//                value's new size is equal to the old size.  There are a
//                number of variant types that take up a fixed amount of space,
//                e.g., VT_I4, VT_R8 etc.  This would also apply to any
//                variable length property that is updated without changing
//                the property value's size across a DWORD boundary.
//
//              Note that while the property offset array is itself packed out
//              of necessity (to conform to the spec), there may be unused
//              entries at the end of the array that are not compressed out of
//              the stream when properties are deleted.  The unused space is
//              detected and reused when new properties are added later.
//---------------------------------------------------------------------------

#define CCHUNKSTACK     (sizeof(ascnkStack)/sizeof(ascnkStack[0]))

VOID
CPropertySetStream::SetValue(
    IN ULONG cprop,
    OPTIONAL IN OUT INDIRECTPROPERTY **ppip,
    IN PROPVARIANT const avar[],
    IN PROPERTY_INFORMATION *apinfo,
    OUT OPTIONAL USHORT *pCodePage,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    CStreamChunk ascnkStack[6];

    ULONG cpoReserve;
    ULONG cDelete, cInsert, cMove, cUpdate;

#if DBGPROP
    ULONG cIgnore;
    char valbuf[CB_VALUESTRING];
    KERNELSELECT(
    char valbuf2[CB_VALUESTRING],
    char varbuf[CB_VARIANT_TO_STRING]);
#endif

    ULONG iprop;
    ULONG cbstm;
    LONG cbChange, cbInsertMove;
    PROPERTYSECTIONHEADER *psh;
    int cIndirect = 0;
    CStreamChunk *pscnk0 = NULL;
    ULONG cbNewSize;

    USHORT NewCodePage = _CodePage;


    //  ----------
    //  Initialize
    //  ----------

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);
    *pstatus = STATUS_SUCCESS;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::SetValue" );
    propTraceParameters(( "cprop=%d, ppip=%p, avar=%p, apinfo=%p, pCodePage=%p",
                           cprop,    ppip,    avar,    apinfo,    pCodePage ));

    // Worst case, we will need chunks for:
    //  - the possible growth of the PROPERTYIDOFFSET array,
    //  - one for EACH property that is being modified,
    //  - and one chunk to mark the end of the property data.

    CStreamChunkList scl(
                        1 + cprop + 1,
                        1 + cprop + 1 <= CCHUNKSTACK? ascnkStack : NULL);

    PROPASSERT(_IsMapped());


    // Validate that this property set can be written to.
    if (IsReadOnlyPropertySet(_Flags, _State))
    {
        StatusAccessDenied(pstatus, "SetValue: deleted or read-only");
        goto Exit;
    }

    // Mark the propset dirty.
    _SetModified(pstatus);
    if( !NT_SUCCESS(*pstatus) )
    {
        TraceStatus( "SetValue: couldn't SetModified" );
        goto Exit;
    }

    psh = _GetSectionHeader();

    cpoReserve = 0;
    cDelete = cInsert = cMove = cUpdate = 0;
#if DBGPROP
    cIgnore = 0;
#endif
    cbInsertMove = cbChange = 0;

    pscnk0 = scl.GetFreeChunk(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    pscnk0->oOld = 0;
    pscnk0->cbChange = 0;
    PROPASSERT(pscnk0 == scl.GetChunk(0));

    cbstm = _oSection + psh->cbSection + _cbTail;
    PROPASSERT( cbstm <= _MSTM(GetSize)(pstatus) && NT_SUCCESS(*pstatus) );
    PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

    //  ------------------------
    //  Classify all the updates
    //  ------------------------

    // Loop through the properties in caller-provided array.
    //
    // Each update gets classified as ignore, delete, insert, move,
    // or update.
    //
    // Lookup the old value for each of the properties specified and
    // compute the current size.

    for (iprop = 0; iprop < cprop; iprop++)
    {
        ULONG i;
        ULONG cbPropOld = 0;
        SERIALIZEDPROPERTYVALUE const *pprop = NULL;

        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

        // Is this PROPID read-only?  E.g. the code page is a read-only property,
        // even if the property set is opened read/write.

        if (IsReadOnlyPropid(apinfo[iprop].pid))
        {
            BOOL fWritable = FALSE;

            // Read-only properties aren't settable except for two special
            // cases:  (1) we get called by the SetPropertyNames method
            // to create an empty dictionary; and (2) it's OK to set the
            // codepage/LCID on an empty property set.


            // Is this the SetPropertyNames case?

	    if (cprop == 1 &&
		apinfo[0].pid == PID_DICTIONARY &&
		apinfo[0].cbprop != 0 &&
                ( avar != NULL && avar[0].vt == VT_DICTIONARY )
               )
            {
                fWritable = TRUE;
            }

            // Or, is this a codepage/lcid going into an empty property set?

            else if( IsLocalizationPropid(apinfo[iprop].pid) )
            {
                // These properties may only be written as singletons, or
                // together, to an empty property set.  So we should be at
                // an iprop of 0 or 1.  We'll do all the checking at 0.

                if( 0 == iprop )
                {
                    // First, is this property set empty?
                    BOOLEAN fSettable = _IsLocalizationSettable(pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    if( fSettable )
                    {
                        // It's OK to set these props, so as long as either this
                        // is the only property being written, or there's one
                        // more and it's a localization property too, we're OK.

                        if( 1 == cprop )
                            fWritable = TRUE;
                        else if( 2 == cprop && IsLocalizationPropid(apinfo[1].pid) )
                            fWritable = TRUE;
                    }
                }
                else if( 1 == iprop )
                {
                    // This is valid iff iprop==0 was a localization property, and therefore
                    // we did the checking already.
                    if( IsLocalizationPropid(apinfo[0].pid) )
                        fWritable = TRUE;
                }

            }   // else if( IsLocalizationPropid(apinfo[iprop].pid) )


            // If we didn't just find an exception to the read-only rule,
            // then this is invalid.

            if( !fWritable )
	    {
                propDbg(( DEB_ITRACE,  "SetValue: read-only propid=%lx\n",
		                        apinfo[iprop].pid ));
                StatusInvalidParameter(pstatus, "SetValue: read-only PROPID");
                goto Exit;
	    }

            // Validate the codepage type, and put it into the NewCodePage local.

            if( PID_CODEPAGE == apinfo[iprop].pid && NULL != avar )
            {
                if( VT_I2 != avar[iprop].vt )
                {
                    propDbg(( DEB_ERROR, "SetValue:  invalid type for codepage (%d)\n",
                                          avar[iprop].vt ));
                    StatusInvalidParameter(pstatus, "SetValue: invalid type for CodePage");
                    goto Exit;
                }
                NewCodePage = avar[iprop].iVal;
            }

            // Validate the locale type.

            else if( PID_LOCALE == apinfo[iprop].pid && NULL != avar )
            {
                if( VT_UI4 != avar[iprop].vt )
                {
                    propDbg(( DEB_ERROR,  "SetValue:  invalid type for locale ID (%d)\n",
                                           avar[iprop].vt ));
                    StatusInvalidParameter(pstatus, "SetValue: invalid type for LCID");
                    goto Exit;
                }
            }

        }   // if (IsReadOnlyPropid(apinfo[iprop].pid))
        // When we get to this point, we have a writeable property.

        // Get a pointer to the serialized property value (if this property
        // doesn't already exist, pprop will be NULL).

        if (apinfo[iprop].pid != PID_ILLEGAL)
        {
            pprop = _LoadProperty(apinfo[iprop].pid, &cbPropOld, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);
        }

        // If this propid appears later in the input array, ignore it.
        // I.e., the caller passed in an array, and for some reason wrote
        // the same propid multiple times, so we'll ignore all but the last.

        for (i = iprop + 1; i < cprop; i++)
        {
            if (apinfo[i].pid == apinfo[iprop].pid)
            {
                // Ignore this one and wait for it to show
                // up again.

                #if DBGPROP
                    cIgnore++;
                #endif

                apinfo[iprop].operation = PROPOP_IGNORE;
                break;
            }
        }

        // If this propid appears only once or if it's the last instance,
        // load the property and compute its size.

        if (i == cprop)
        {
            VOID *pvStart = NULL;

            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

            // Validate that the property value is somewhat sane (this is checked
            // in detail at the appropriate times, but this check ensures we don't 
            // having any 32 bit rounding/wrapping errors).

            if( apinfo[iprop].cbprop > CBMAXPROPSETSTREAM )
            {
                StatusDiskFull(pstatus, "SetValue: invalid type for LCID");
                goto Exit;
            }

            // Are we overwriting a property that already exists?

            if (pprop != NULL)
            {
                // Yes, we're either deleting or overwriting an existing property.

                ULONG cbPropNew;

                PROPASSERT(apinfo[iprop].pid != PID_DICTIONARY);

                // A cbprop of 0 indicates that we should delete this property

                if (apinfo[iprop].cbprop == 0)
                {
                    propDbg(( DEB_ITRACE,
                              "SetValue: Deleting propid=%lx oOld=%l" szX
                              " vt=%hx val=%s cb=%l" szX "\n",
                              apinfo[iprop].pid, 
                              _MapAddressToOffset(pprop), 
                              PropByteSwap( pprop->dwType ),
                              ValueToString(pprop, cbPropOld, valbuf, sizeof(valbuf)), 
                              cbPropOld));

                    cbPropNew = 0;
                    cDelete++;
                    apinfo[iprop].operation = PROPOP_DELETE;

                }   // if (apinfo[iprop].cbprop == 0)

                // Otherwise, we're writing this property to the property set
                else
                {
                    /*
                    propDbg(( DEB_ITRACE, "SetValue: Modifying propid=%lx oOld=%l" szX
                                          " vt=%hx-->%hx cb=%l" szX "-->%l" szX " val=%s-->%s\n",
                                apinfo[iprop].pid,
                                _MapAddressToOffset(pprop),
                                PropByteSwap( pprop->dwType ),
			        avar[iprop].vt,
                                cbPropOld,
                                apinfo[iprop].cbprop,
                                ValueToString(pprop, cbPropOld, valbuf),
			        VariantToString(
				        avar[iprop],
				        varbuf,
				        sizeof( varbuf )) ));
                    */

                    cbPropNew = apinfo[iprop].cbprop;

                    // If this property is a different size than the existing value,
                    // then we'll write it to the end.

                    if (cbPropOld != cbPropNew)
                    {
                        cbInsertMove += apinfo[iprop].cbprop;
                        cMove++;
                        apinfo[iprop].operation = PROPOP_MOVE;
                    }

                    // Otherwise, we'll update the property value in place.
                    else
                    {
                        cUpdate++;
                        apinfo[iprop].operation = PROPOP_UPDATE;
                    }
                }   //    // if (apinfo[iprop].cbprop == 0) ... else

                // If we're deleting or moving, update the chunk list.

                if (apinfo[iprop].operation != PROPOP_UPDATE)
                {
                    // Update the list of chunks that need to be adjusted
                    CStreamChunk *pscnk = scl.GetFreeChunk(pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    pscnk->oOld = _MapAddressToOffset(pprop);
                    pscnk->cbChange = - (LONG) cbPropOld;
                }

                // Stream size change
                cbChange += cbPropNew - cbPropOld;

            }   // if (pprop != NULL)

            // Or, are we deleting a non-extant property?

            else if (apinfo[iprop].cbprop == 0)
            {
                // The request is to delete the property, but a NULL pprop indicates
                // that the property doesn't exist.  We'll ignore this part of the request.

                #if DBGPROP
                    cIgnore++;
                #endif
                PROPASSERT(apinfo[iprop].pid != PID_DICTIONARY);
                apinfo[iprop].operation = PROPOP_IGNORE;
            }

            // Otherwise, we're inserting a new property

            else
            {
                /*
                propDbg(( DEB_ITRACE,
                    "SetValue: Inserting new propid=%lx vt=%hx "
                        "cbNew=%l" szX " val=%s\n",
                    apinfo[iprop].pid,
		    avar[iprop].vt,
                    apinfo[iprop].cbprop,
		    VariantToString(
			avar[iprop],
			varbuf,
			sizeof( varbuf )) ));
                */

                PROPASSERT(apinfo[iprop].pid != PID_ILLEGAL);

                cbInsertMove += apinfo[iprop].cbprop;
                cbChange += apinfo[iprop].cbprop;

                cInsert++;
                apinfo[iprop].operation = PROPOP_INSERT;

            } // if (pprop != NULL) ... else if ... else

            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

            // In order to delete any old stream or storage type properties
            // we count the properties which used to be VT_STREAM etc.
            // Also, we count the properties which are to be created as
            // streams or storages.

            if (ppip != NULL && apinfo[iprop].operation != PROPOP_IGNORE)
            {
                if ((pprop != NULL && IsIndirectVarType(PropByteSwap(pprop->dwType)))
                    ||
                    (avar != NULL && IsIndirectVarType(avar[iprop].vt)))
                {
                    cIndirect++;
                }
            }
        }   // if (i == cprop)
    }   // for (iprop = 0; iprop < cprop; iprop++)
    // We're now done classifying each of the properties to be added.


    //  ------------------------------------------------------------
    //  Put existing, to-be-overwritten, indirect properties in ppip
    //  ------------------------------------------------------------

    // Did the caller give us an INDIRECTPROPERTY buffer, and are
    // there indirect properties being added and/or overwritten?

    if (ppip != NULL && cIndirect != 0)
    {
        // allocate needed space for indirect information
        INDIRECTPROPERTY *pipUse;

        // If cprop is 1, the caller-provided ppip is a pointer to an INDIRECTPROPERTY
        // that we can use.  Otherwise, we need to allocate space for it, and put
        // it in *ppip for the caller.

        if (cprop != 1)
        {
            pipUse = *ppip = reinterpret_cast<INDIRECTPROPERTY*>
                             ( CoTaskMemAlloc( sizeof(INDIRECTPROPERTY) * (cIndirect + 1) ));
            if (*ppip == NULL)
            {
                StatusNoMemory(pstatus, "SetValue: Indirect Name");
                goto Exit;
            }

            RtlZeroMemory( pipUse, sizeof(INDIRECTPROPERTY) * (cIndirect + 1) );
            pipUse[cIndirect].Index = MAXULONG;
        }
        else
        {
            pipUse = (INDIRECTPROPERTY *) ppip;
            RtlZeroMemory( pipUse, sizeof(*pipUse) );
        }

        // Loop through the properties in the input array, and put info about the
        // indirects (non-simple) being added or overrritten into the array at pipUse.

        int iIndirect = 0;
        for (iprop = 0; iprop < cprop; iprop++)
        {
            ULONG cbPropOld;
            SERIALIZEDPROPERTYVALUE const *pprop = NULL;

            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);
            if (apinfo[iprop].operation == PROPOP_IGNORE ||
                apinfo[iprop].pid == PID_ILLEGAL)
            {
                continue;
            }

            // Get the existing serialized property value, if there is one
            // (if there isn't, pprop will be NULL, but *pstatus will be success).

            pprop = _LoadProperty(apinfo[iprop].pid, &cbPropOld, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

            // If the property already exist, and it's indirect type, we need to load
            // pipUse with the indirect name so that the caller can delete it.

            if (pprop != NULL && IsIndirectVarType(PropByteSwap(pprop->dwType)))
            {
                CHAR *pszName;
                ULONG cbName;

                BOOL fAlloc = FALSE;  // Did we alloc pszName?

                // Point to the indirect property inline value (i.e. the name of the
                // stream/storage which holds it).

                if( VT_VERSIONED_STREAM == PropByteSwap(pprop->dwType) )
                {
                    if( cbPropOld < sizeof(GUID) + sizeof(ULONG) )
                    {
                        StatusError(pstatus, "SetValue:  corrupt versioned_stream guid",
                                    STATUS_INTERNAL_DB_CORRUPTION);
                        goto Exit;
                    }

                    // Before the value is a GUID and the string length.

                    cbPropOld -= sizeof(GUID) + sizeof(ULONG);
                    pszName = (CHAR *) Add2ConstPtr(pprop->rgb, sizeof(GUID) );
                    cbName = *(ULONG*) pszName;
                    pszName = (CHAR *) Add2ConstPtr(pszName, sizeof(ULONG) );
                }
                else
                {
                    if( cbPropOld < 2*sizeof(ULONG) )
                    {
                        StatusError(pstatus, "SetValue:  corrupt indirect string",
                                    STATUS_INTERNAL_DB_CORRUPTION);
                        goto Exit;
                    }

                    cbPropOld -= 2 * sizeof(ULONG);                             // Subtract size of VT & length
                    cbName = *(ULONG*) pprop->rgb;
                    pszName = (CHAR *) Add2ConstPtr(pprop->rgb, sizeof(ULONG)); // Move past length
                }

                // Validate the string is terminated properly.  _LoadProperty
                // already ensured that the property is readable and that the length
                // field makes sense (fits within the section).

                if( CP_WINUNICODE == _CodePage )
                {
                    WCHAR *pwszName = (WCHAR*) pszName;
                    if( L'\0' != pwszName[ cbName/sizeof(WCHAR) - 1 ] )
                    {
                        StatusError(pstatus, "SetValue:  corrupt indirect string",
                                    STATUS_INTERNAL_DB_CORRUPTION);
                        goto Exit;
                    }
                }
                else
                {
                    if( '\0' != pszName[ cbName - 1 ] )
                    {
                        StatusError(pstatus, "SetValue:  corrupt indirect string",
                                    STATUS_INTERNAL_DB_CORRUPTION);
                        goto Exit;
                    }
                }

                // Do we need to convert the name between Ansi & Unicode?

                if (_CodePage != CP_WINUNICODE      // Ansi propset
                    &&
                    OLECHAR_IS_UNICODE)             // Unicode OLE APIs
                {
                    // Convert the indirect reference to Unicode

                    PrpConvertToUnicode(
                                pszName,
                                cbName,
                                _CodePage,
                                (WCHAR **) &pszName,
                                &cbName,
                                pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    fAlloc = TRUE; // We need to free pszName
                }
                else
                if (_CodePage == CP_WINUNICODE      // Unicode propset
                    &&
                    !OLECHAR_IS_UNICODE )           // Ansi OLE APIs
                {
                    // Byte-Swap the Unicode indirect reference value

                    WCHAR *pwszBuffer = NULL;

                    // After this call, the appropriately swapped name will be
                    // in pszName.  If an alloc was required, pszBuffer will point
                    // to the new buffer (we must free this).

                    PBSInPlaceAlloc( (WCHAR**) &pszName, &pwszBuffer, pstatus );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    // Convert the reference value to Ansi.

                    PrpConvertToMultiByte(
                                (WCHAR*) pszName,
                                cbName,
                                CP_ACP,
                                (CHAR **) &pszName,
                                &cbName,
                                pstatus);
                    CoTaskMemFree( pwszBuffer );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    fAlloc = TRUE; // We need to free pszName
                }

                pipUse[iIndirect].poszName = reinterpret_cast<OLECHAR*>( CoTaskMemAlloc( cbName ));

                if (pipUse[iIndirect].poszName == NULL)
                {
                    StatusNoMemory(pstatus, "SetValue: Indirect Name2");
                    goto Exit;
                }

                RtlCopyMemory(
                        pipUse[iIndirect].poszName,
                        pszName,
                        cbName);


                // Is byte-swapping necessary?  It is if the property set
                // codepage is Unicode, and if OLECHARs are also Unicode.
                // If both are Ansi, then no byte-swapping is ever necessary,
                // and if one is Ansi and the other is Unicode, then we
                // already byte-swapped above during the conversion.

                if (_CodePage == CP_WINUNICODE
                    &&
                    OLECHAR_IS_UNICODE )
                {
                    // Convert from propset-endian to system-endian.
                    PBSBuffer( pipUse[iIndirect].poszName, cbName, sizeof(OLECHAR) );
                }

                // Clean up pszName

                if( fAlloc )
                {
                    // In the Unicode/MBCS conversions, we did an alloc which
                    // we must free now.

                    PROPASSERT(pszName != NULL);
                    PROPASSERT(
                        pszName !=
                        (CHAR *) Add2ConstPtr(pprop->rgb, sizeof(ULONG)));
                    CoTaskMemFree( pszName );
                }

            }   // if (pprop != NULL && IsIndirectVarType(PropByteSwap(pprop->dwType)))

            else if( avar == NULL || !IsIndirectVarType(avar[iprop].vt) )
            {
                // Neither the property being overwritten, nor the property
                // being written is indirect, so we can continue on to
                // check the next property (skipping the pipUse updating
                // below).

                continue;
            }

            // If we get here, we know that either this property is
            // an indirect type, or it's overwriting an indirect property (or both).
            // We established pipUse[].pszName above, so we just need to
            // insert the index and move on.

            pipUse[iIndirect].Index = iprop;
            iIndirect++;

        }   // for (iprop = 0; iprop < cprop; iprop++)

        PROPASSERT(iIndirect == cIndirect);

    }   // if (ppip != NULL && cIndirect != 0)


    propDbg(( DEB_ITRACE, "SetValue: Total Props %l" szX "\n", cprop ));
    propDbg(( DEB_ITRACE,
        "SetValue: Delete=%l" szX " Insert=%l" szX " Move=%l" szX
            " Update=%l" szX " Ignore=%l" szX "\n",
        cDelete, cInsert, cMove, cUpdate, cIgnore ));

    PROPASSERT(cDelete + cInsert + cMove + cUpdate + cIgnore == cprop);
    PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);


    //  --------------------------------------------------------
    //  Calculate the total size adjustments to the property set
    //  --------------------------------------------------------

    // If we need to grow the property offset array, detect any unused
    // entries at the end of the array that are available for reuse,
    // and adjust the size difference to reflect the reuse.

    if (cInsert > cDelete)
    {
        ULONG cpoReuse, cpoExpand;

        cpoExpand = cInsert - cDelete;
        cpoReuse = _CountFreePropertyOffsets(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (cpoReuse > cpoExpand)
        {
            cpoReuse = cpoExpand;
        }
        cpoExpand -= cpoReuse;

        // If adding a small number of new entries, but not reusing any old
        // ones, add 10% more reserved entries (but only up to 10 more) to
        // avoid having to continually grow the property offset array for
        // clients that insist on adding a few properties at a time.

        // We don't do this for the User-Defined property set, however,
        // because older apps assume that the dictionary immediately follows
        // the last entry in the PID/Offset array.

        if (cpoExpand >= 1 && cpoExpand <= 2 && cpoReuse == 0
            &&
            !(_State & CPSS_USERDEFINEDPROPERTIES)
           )
        {
           cpoReserve = 1 + min(psh->cProperties, 90)/10;
           cpoExpand += cpoReserve;
        }
        DebugTrace(0, Dbg, (
            "SetValue: Reusing %l" szX " offsets, Expanding %l" szX
                " offsets\n",
            cpoReuse,
            cpoExpand));

        pscnk0->oOld = CB_PROPERTYSECTIONHEADER +
               (psh->cProperties + cpoReuse) * CB_PROPERTYIDOFFSET;
        pscnk0->cbChange = cpoExpand * CB_PROPERTYIDOFFSET;
        cbChange += cpoExpand * CB_PROPERTYIDOFFSET;

        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

    }   // if (cInsert > cDelete)

    // Do we instead need to *shrink* the PID/Offset array?
    // If so, don't shrink any more than necessary.  We'll
    // leave up to min(10%,10) blank entries.
    // However, if this is the User-Defined property set,
    // there can never be any unused entries (for compatibility
    // with older apps), so we do a complete shrink.

    else if (cInsert < cDelete)
    {
        ULONG cpoRemove = 0;
        ULONG cpoDelta = cDelete - cInsert;

        // How many blank entries do we already have?
        ULONG cpoCurBlankEntries = _CountFreePropertyOffsets( pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if( _State & CPSS_USERDEFINEDPROPERTIES )
        {
            cpoRemove = cpoDelta;
        }
        else
        {
            // How many blank entries can we have?
            ULONG cpoMaxBlankEntries;
            cpoMaxBlankEntries = 1 + min(psh->cProperties - cpoDelta, 90)/10;

            // If, after deleting the properties, we'd have too many,
            // remove only enough to get us down to the max allowable.

            if( cpoCurBlankEntries + cpoDelta
                >
                cpoMaxBlankEntries
              )
            {
                cpoRemove = cpoCurBlankEntries + cpoDelta - cpoMaxBlankEntries;
            }
        }   // if( _State & CPSS_USERDEFINEDPROPERTIES )

        // Should we remove any PID/Offset entries?

        if( cpoRemove > 0 )
        {
            // Start removing at cpoRemove entries from the end of the PID/Offset array
            pscnk0->oOld = CB_PROPERTYSECTIONHEADER
                           +
                           (psh->cProperties + cpoCurBlankEntries - cpoRemove)
                           *
                           CB_PROPERTYIDOFFSET;

            // Remove the bytes of the cpoRemove entries.
            pscnk0->cbChange = - (LONG) (cpoRemove * CB_PROPERTYIDOFFSET );

            // Adjust the size of the section equivalently.
            cbChange += pscnk0->cbChange;
        }

    }   // else if (cInsert < cDelete)

    PROPASSERT(
        cbstm + cbChange >=
        _oSection + CB_PROPERTYSECTIONHEADER +
        (psh->cProperties + cInsert - cDelete) * CB_PROPERTYIDOFFSET +
	_cbTail);

    // If we need to grow the stream, do it now.

    if (cbChange > 0)
    {
        if (cbstm + cbChange > CBMAXPROPSETSTREAM)
        {
            StatusDiskFull(pstatus, "SetValue: 256k limit");
            goto Exit;
        }

        propDbg(( DEB_ITRACE,  "SetSize(%x) SetValue grow\n", cbstm + cbChange));

        _MSTM(SetSize)(cbstm + cbChange, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // reload all pointers into mapped image:

        psh = _GetSectionHeader();
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

	// If there's another section after this one, move it back to the
	// end of the stream now.

	if (_cbTail != 0)
	{
	    VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

	    PropMoveMemory(
		    "SetValue(_cbTail:grow)",
		    psh,
		    Add2Ptr(pvSrc, cbChange),
		    pvSrc,
		    _cbTail);
	}
    }   // if (cbChange > 0)

    // From this point on, the operation should succeed.
    // If necessary, the stream has already been grown.

    //  ----------------------------------------
    //  Write the new properties into the stream
    //  ----------------------------------------

    // Update the PID/Offset table, and compact the stream, creating a whole at the
    // end of the stream for the new property values.

    if (cDelete + cInsert + cMove != 0)
    {
        // Delete and compact property offsets in the section header.

        if (cDelete + cMove != 0)
        {
            _DeleteMovePropertyOffsets(apinfo, cprop, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            psh->cProperties -= cDelete;
        }
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

        // Use the last chunk to mark the section end, and sort the chunks
        // in ascending order by start offset.

        CStreamChunk *pscnk = scl.GetFreeChunk(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        pscnk->oOld = psh->cbSection;
        pscnk->cbChange = 0;

        scl.SortByStartAddress();

        // If we're reducing the number of properties, we may be shrinking
        // the PID/Offset array.  So, update that array now, since
        // we may remove some bytes at the end of it when we compact
        // the stream.

        if( cDelete > cInsert )
        {
            _UpdatePropertyOffsets( &scl, pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }

        // Compact the Stream following the directions in the
        // chunk list.

        _CompactStream(&scl);

        // If the number of properties is holding constant or increasing,
        // we can update the PID/Offset array now (because _CompactStream
        // allocated any necessary space for us).

        if( cDelete <= cInsert )
        {
            _UpdatePropertyOffsets( &scl, pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }

        // Set the new section size to include the deleted and inserted
        // property offsets, and the deleted property values.

        psh->cbSection += cbChange;

        // Insert new property offsets at the end of the array.

        if (cInsert + cMove != 0)
        {
            _InsertMovePropertyOffsets(
                                apinfo,
                                cprop,
                                psh->cbSection - cbInsertMove,
                                cpoReserve,
                                pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            psh->cProperties += cInsert;
        }

        PROPASSERT(cbstm + cbChange == _oSection + psh->cbSection + _cbTail);
	if (_cbTail != 0)
	{
	    // There's another section after this one; if we're shrinking
	    // the stream, move it up to the new end of the stream now.

	    if (cbChange < 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"SetValue(_cbTail:shrink)",
			psh,
			Add2Ptr(pvSrc, cbChange),
			pvSrc,
			_cbTail);
	    }
	    _PatchSectionOffsets(cbChange);
	}
    }   // if (cDelete + cInsert + cMove != 0)

    // Copy the new values.

    // NOTE: It might seem unnecessary to delay the in-place updates until
    // this for loop.  We do not perform the in-place updates while
    // classifying the changes because unmapping, remapping and changing
    // the size required for handling other updates can fail.  In the event
    // of such a failure, the update would not be atomic.  By delaying the
    // in-place updates, we provide some degree of atomicity.

    if (cInsert + cUpdate + cMove != 0)
    {
	BOOLEAN fDocSummaryInfo = FALSE;

	if ((_State &
             (CPSS_USERDEFINEDPROPERTIES | CPSS_DOCUMENTSUMMARYINFO)) ==
	     CPSS_DOCUMENTSUMMARYINFO)
	{
	    fDocSummaryInfo = TRUE;
	}

        for (iprop = 0; iprop < cprop; iprop++)
        {
            // Find property in the offset array and copy in the new value.
            if (apinfo[iprop].operation == PROPOP_INSERT ||
                apinfo[iprop].operation == PROPOP_UPDATE ||
                apinfo[iprop].operation == PROPOP_MOVE)
            {
                SERIALIZEDPROPERTYVALUE *pprop;
                ULONG cbprop;
                ULONG cIndirectProps;
                PROPID propid = apinfo[iprop].pid;

                pprop = _LoadProperty(propid, NULL, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
                PROPASSERT(pprop != NULL);

                // Special case for SetPropertyNames dictionary creation:

                if (propid == PID_DICTIONARY)
                {
                    PROPASSERT(CB_SERIALIZEDPROPERTYVALUE == CB_DICTIONARY);
                    PROPASSERT(apinfo[iprop].cbprop == CB_SERIALIZEDPROPERTYVALUE);
                    PROPASSERT(avar[iprop].vt == VT_DICTIONARY);
                    ((DICTIONARY *) pprop)->cEntries = 0;
                }   // if (propid == PID_DICTIONARY)
                else
                {
                    // Serialize the PROPVARIANT in avar
                    // directly into the mapped stream.  We ask for the
                    // count of indirect properties, even though we don't
                    // use it, in order to tell the routine that we
                    // can handle them.  Any handling that is actually
                    // required must be handled by our caller.

                    WORD wMinFormatRequired = 0;

                    // (This cbprop was actually originally calced by
                    // StgConvertVariantToPropertyNoEH)
                    cbprop = apinfo[iprop].cbprop;

                    pprop = StgConvertVariantToPropertyNoEH(
                                    &avar[iprop],
                                    _CodePage,
                                    pprop,
                                    &cbprop, 
                                    apinfo[iprop].pid,
                                    FALSE, FALSE,
                                    &cIndirectProps,
                                    &wMinFormatRequired,
                                    pstatus
                                    );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    // This property type might not have been supported in the original
                    // property set format.  If so, it may be necessary to increment
                    // the format in the header.

                    _pph->wFormat = max( _pph->wFormat, wMinFormatRequired );

                    PROPASSERT(pprop != NULL);
                    PROPASSERT(cbprop == DwordAlign(cbprop));
                    PROPASSERT(cbprop == apinfo[iprop].cbprop);

		    // If writing a DocumentSummaryInformation property
		    // for which an alignment hack is provided, hack it now.

		    if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
		    {
                        // The two vectors in the DocSumInfo property set
                        // (if Ansi) are un-packed, but we'll adjust the lengths
                        // so that if a propset reader expects them to be packed,
                        // it will still work.  E.g., a one character string will
                        // have a length of 4, with padding of NULL characters.

			ULONG cbpropT = cbprop;

			if (propid == PID_HEADINGPAIR)
			{
			    _FixHeadingPairVector(
					    PATCHOP_ALIGNLENGTHS,
					    pprop,
					    &cbpropT);
			}
			else if (propid == PID_DOCPARTS)
			{
			    _FixDocPartsVector(
					    PATCHOP_ALIGNLENGTHS,
					    pprop,
					    &cbpropT);
			}
		    }
                    propDbg(( DEB_ITRACE,  "SetValue:Insert: pph=%x pprop=%x cb=%3l" szX
                                           " vt=%4x val=%s o=%x oEnd=%x\n",
                        _pph,
                        pprop,
                        apinfo[iprop].cbprop,
                        PropByteSwap(pprop->dwType),
                        ValueToString(pprop, apinfo[iprop].cbprop, valbuf, sizeof(valbuf)),
                        _MapAddressToOffset(pprop),
                        _MapAddressToOffset(pprop) + apinfo[iprop].cbprop));

                }   // if (propid == PID_DICTIONARY) ... else
            }   // if (apinfo[iprop].operation == PROPOP_INSERT || ...
        }   // for (iprop = 0; iprop < cprop; iprop++)
    }   // if (cInsert + cUpdate + cMove != 0)

    // If we need to shrink the stream or if we are cleaning up after a
    // previous shrink that failed, do it last.

    if ( cbChange < 0 )
    {
        propDbg(( DEB_ITRACE, "SetSize(%x) SetValue shrink\n", cbstm + cbChange ));
        _MSTM(SetSize)(cbstm + cbChange, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

    if( NULL != pCodePage )
        *pCodePage = _CodePage = NewCodePage;

Exit:

    scl.Delete();

    if( !NT_SUCCESS(*pstatus) )
    {
        if( ppip != NULL && 0 != cIndirect )
        {
            INDIRECTPROPERTY *pipUse;

            pipUse = (1 == cprop) ? (INDIRECTPROPERTY*) ppip
                                  : *ppip;

            if( NULL != pipUse )
            {
                for (int iFree = 0; iFree < cIndirect; iFree++)
                {
                    CoTaskMemFree( pipUse[iFree].poszName );
                }
            }
            if (cprop != 1)
            {
                CoTaskMemFree( pipUse );
                *ppip = NULL;
            }
        }
    }   // if( !NT_SUCCESS(*pstatus) )


}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CountFreePropertyOffsets, private
//
// Synopsis:    counts available (free) property offsets at and of array
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     count of available property offsets at and of array
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_CountFreePropertyOffsets(OUT NTSTATUS *pstatus)
{
    PROPERTYIDOFFSET *ppo, *ppoMax;
    PROPERTYSECTIONHEADER const *psh;
    ULONG oMin = MAXULONG;
    ULONG oEnd;
    ULONG cFree = 0;

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (psh != NULL)
    {
        for ( ; ppo < ppoMax; ppo++)
        {
            if (oMin > ppo->dwOffset)
            {
                oMin = ppo->dwOffset;
            }
        }
    }
    if (oMin == MAXULONG)
    {
        goto Exit;
    }
    PROPASSERT(psh != NULL);
    oEnd = CB_PROPERTYSECTIONHEADER + psh->cProperties * CB_PROPERTYIDOFFSET;
    PROPASSERT(oEnd <= oMin);

    cFree = (oMin - oEnd)/CB_PROPERTYIDOFFSET;

Exit:

    return( cFree );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DeleteMovePropertyOffsets, private
//
// Synopsis:    updates the offsets following the changes to the stream
//
// Arguments:   [apinfo]        -- array of property information
//              [cprop]         -- number of properties
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_DeleteMovePropertyOffsets(
    IN PROPERTY_INFORMATION const *apinfo,
    IN ULONG cprop,
    OUT NTSTATUS *pstatus)
{
    ULONG i;
    ULONG cDelete;
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase = NULL, *ppoMax = NULL;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Remove the deleted properties

    DebugTrace(0, Dbg, ("Marking deleted/moved property offsets\n"));
    cDelete = 0;
    for (i = 0; i < cprop; i++)
    {
        if (apinfo[i].operation == PROPOP_DELETE ||
            apinfo[i].operation == PROPOP_MOVE)
        {
            for (ppo = ppoBase; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == apinfo[i].pid)
                {
                    DebugTrace(0, Dbg, (
                        "%sing propid=%lx oOld=%l" szX "\n",
                        apinfo[i].operation == PROPOP_DELETE? "Delet" : "Mov",
                        ppo->propid,
                        ppo->dwOffset));
                    if (apinfo[i].operation == PROPOP_DELETE)
                    {
                        cDelete++;
                        ppo->dwOffset = MAXULONG;
                    }
                    else
                    {
                        ppo->dwOffset = 0;
                    }
                    break;
                }
            }
        }
    }

    // scan once and compact the property offset array.

    if (cDelete > 0)
    {
        PROPERTYIDOFFSET *ppoDst = ppoBase;

        DebugTrace(0, Dbg, ("Compacting %l" szX " deleted props\n", cDelete));
        for (ppo = ppoBase; ppo < ppoMax; ppo++)
        {
            if (ppo->dwOffset != MAXULONG)
            {
                if (ppo > ppoDst)
                {
                    *ppoDst = *ppo;
                }
                DebugTrace(0, Dbg, (
                    "%sing propid=%lx oOld=%l" szX "\n",
                    ppo > ppoDst? "Compact" : "Preserv",
                    ppo->propid,
                    ppo->dwOffset));
                ppoDst++;
            }
        }
        PROPASSERT(cDelete == (ULONG) (ppoMax - ppoDst));
        DebugTrace(0, Dbg, ("Zeroing %l" szX " entries\n", cDelete));
        RtlZeroMemory(ppoDst, (BYTE *) ppoMax - (BYTE *) ppoDst);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_UpdatePropertyOffsets, private
//
// Synopsis:    update property offsets in section header
//
// Arguments:   [pscl]          -- list of chunks in stream that were changed
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_UpdatePropertyOffsets(
    IN CStreamChunkList const *pscl,
    OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo = NULL, *ppoMax = NULL;

    // Update the offsets for the existing properties.
    DebugTrace(0, Dbg, ("Updating existing property offsets\n"));

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    for ( ; ppo < ppoMax; ppo++)
    {
        if (ppo->dwOffset != 0)
        {
#if DBGPROP
            ULONG oOld = ppo->dwOffset;
#endif
            ppo->dwOffset = _GetNewOffset(pscl, ppo->dwOffset);

            DebugTrace(0, Dbg, (
                "UpdatePropertyOffsets: propid=%lx offset=%l" szX "-->%l" szX"\n",
                ppo->propid,
                oOld,
                ppo->dwOffset));
        }
    }

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_InsertMovePropertyOffsets, private
//
// Synopsis:    updates the offsets following the changes to the stream
//
// Arguments:   [apinfo]        -- array of property information
//              [cprop]         -- number of properties
//              [oInsert]       -- offset in section for new properties
//              [cpoReserve]    -- newly reserved property offsets to zero
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_InsertMovePropertyOffsets(
    IN PROPERTY_INFORMATION const *apinfo,
    IN ULONG cprop,
    IN ULONG oInsert,
    IN ULONG cpoReserve,
    OUT NTSTATUS *pstatus)
{
    ULONG i;
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase = NULL, *ppoMax = NULL;

    *pstatus = STATUS_SUCCESS;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Insert the new property offsets at the end.
    DebugTrace(0, Dbg, ("Inserting/Moving/Zeroing property offsets\n"));

    for (i = 0; i < cprop; i++)
    {
        if (apinfo[i].operation == PROPOP_INSERT)
        {
            ppo = ppoMax++;
            ppo->propid = apinfo[i].pid;
        }
        else if (apinfo[i].operation == PROPOP_MOVE)
        {
            for (ppo = ppoBase; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == apinfo[i].pid)
                {
                    PROPASSERT(ppo->dwOffset == 0);
                    break;
                }
            }
        }
        else
        {
            continue;
        }

        PROPASSERT(ppo->propid == apinfo[i].pid);
        ppo->dwOffset = oInsert;
        oInsert += apinfo[i].cbprop;

        DebugTrace(0, Dbg, (
            "%sing propid=%lx offset=%l" szX " size=%l" szX "\n",
            apinfo[i].operation == PROPOP_INSERT? "Insert" : "Mov",
            ppo->propid,
            ppo->dwOffset,
            apinfo[i].cbprop));
    }
    DebugTrace(0, Dbg, (
        "Zeroing %x property offsets o=%l" szX " size=%l" szX "\n",
        cpoReserve,
        _MapAddressToOffset(ppoMax),
        cpoReserve * CB_PROPERTYIDOFFSET));
    RtlZeroMemory(ppoMax, cpoReserve * CB_PROPERTYIDOFFSET);

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CompactStream, private
//
// Synopsis:    compact all of the property stream chunks
//
// Arguments:   [pscl]          -- list of chunks in stream that were changed
//
// Returns:     None
//
// Note:
//      Each chunk structure represents a contiguous range of the stream to be
//      completely removed or added.  A terminating chunk is appended to
//      transparently mark the end of the data stream.  The unmodified data
//      after each chunk (except the last one) must be preserved and compacted
//      as necessary.  Chunk structures contain section-relative offsets.
//
//      Invariants:
//      - Only the first chunk can represent an insertion; subsequent chunks
//        always represent deletions.
//      - The first chunk can never cause a deletion, but it might not cause
//        any change at all.
//      - The last chunk is a dummy used to mark the end of the stream.
//
//      Algorithm:
//      In the optimal case without insertions, each chunk's trailing data can
//      be moved ahead (compacted) individually in ascending chunk index order.
//      If the first chunk represents an insertion, then some consecutive
//      number of data blocks must be moved back (in *descending* chunk index
//      order) to make room for the insertion.
//
//      Walk the chunk array to find the first point where the accumulated size
//      change is less than or equal to zero.
//
//      After (possibly) compacting a single range in descending chunk index
//      order, compact all remaining chunks in ascending chunk index order.
//
//      Example: the first chunk inserts 18 bytes for new property offsets
//      (apo'[]), and the second two delete 10 bytes each (chnk1 & chnk2).
//      There are four chunks in the array, and three blocks of data to move.
//
//                   oOld   cbChange | AccumulatedChange  oNew
//      chunk[0]:     38      +18    |      +18            38  (apo'[])
//      chunk[1]:     48      -10    |       +8            50  (chnk1)
//      chunk[2]:     6c      -10    |       -8            74  (chnk2)
//      chunk[3]:     8c        0    |       -8            84  (end)
//
//      Data blocks are moved in the following sequence to avoid overlap:
//      DstOff  SrcOff  cbMove | Chunk#
//        60      58      14   |    1  chnk1/data2: descending pass (Dst > Src)
//        50      38      10   |    0  apo'[]/data1: descending pass (Dst > Src)
//        74      7c      10   |    2  chnk2/data3: ascending pass  (Dst < Src)
//
//      SrcOff = oOld - min(cbChange, 0)
//      DstOff = SrcOff + AccumulatedChange
//      cbMove = chnk[i+1].oOld - SrcOff
//
//      Before compacting:
//                   0           38      48      58         6c      7c      8c
//                   |            |       |       |          |       |       |
//                   V            V   10  V  -10  V    14    V  -10  V   10  V
//      +----+-------+----+-------+-------+-------+----------+-------+-------+
//      | ph | afo[] | sh | apo[] | data1 | chnk1 |  data2   | chnk2 | data3 |
//      +----+-------+----+-------+-------+-------+----------+-------+-------+
//
//      After compacting:
//                   0           38          50      60         74      84
//                   |            |           |       |          |       |
//                   V            V    +18    V   10  V    14    V   10  V
//      +----+-------+----+-------+-----------+-------+----------+-------+
//      | ph | afo[] | sh | apo[] |   apo'[]  | data1 |  data2   | data3 |
//      +----+-------+----+-------+-----------+-------+----------+-------+
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_CompactStream(
    IN CStreamChunkList const *pscl)
{
    ULONG i, iMax, iAscend;
    LONG cbChangeTotal, cbChangeTotalAscend;
    CStreamChunk const *pscnk;

    // Subtract one to avoid operating on the terminating chunk directly.

    iMax = pscl->Count() - 1;

    // If the first chunk does not indicate an insertion, the first for loop is
    // exited with i == 0.
    //
    // If the first chunk represents an insertion, either i == iMax or i itself
    // indexes the first chunk that can be compacted normally (in ascending
    // chunk index order).  In either case, we compact in descending chunk
    // index order starting just below i.

    DebugTrace(0, Dbg, (
        "CompactStream: %l" szX " chunks @%lx\n",
        pscl->Count(),
        pscl->GetChunk(0)));

    cbChangeTotal = 0;
    for (i = 0; i < iMax; i++)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);
        if (cbChangeTotal + pscnk->cbChange <= 0)
        {
            break;
        }
        cbChangeTotal += pscnk->cbChange;
    }
    iAscend = i;                                // save ascending order start
    cbChangeTotalAscend = cbChangeTotal;

    DebugTrace(0, Dbg, ("CompactStream: iAscend=%l" szX "\n", iAscend));

    // First compact range in descending chunk index order if necessary:

    while (i-- > 0)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);

        DebugTrace(0, Dbg, ("CompactStream: descend: i=%l" szX "\n", i));
#if DBGPROP
        pscl->AssertCbChangeTotal(pscnk, cbChangeTotal);
#endif
        _CompactChunk(pscnk, cbChangeTotal, pscl->GetChunk(i + 1)->oOld);
        cbChangeTotal -= pscnk->cbChange;
    }

    // Compact any remaining chunks in ascending chunk index order.

    cbChangeTotal = cbChangeTotalAscend;
    for (i = iAscend; i < iMax; i++)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);

        DebugTrace(0, Dbg, ("CompactStream: ascend: i=%l" szX "\n", i));
        cbChangeTotal += pscnk->cbChange;
#if DBGPROP
        pscl->AssertCbChangeTotal(pscnk, cbChangeTotal);
#endif
        _CompactChunk(pscnk, cbChangeTotal, pscl->GetChunk(i + 1)->oOld);
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CompactChunk, private
//
// Synopsis:    Compact the data block following one chunk
//
// Arguments:   [pscnk]         -- pointer to stream chunk
//              [cbChangeTotal] -- Bias for this chunk
//              [oOldNext]      -- offset of next chunk
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_CompactChunk(
    IN CStreamChunk const *pscnk,
    IN LONG cbChangeTotal,
    IN ULONG oOldNext)
{
#if DBG==1
    LONG cbDelta = cbChangeTotal + min(pscnk->cbChange, 0);

    DebugTrace(0, Dbg, (
        "CompactChunk(pscnk->oOld=%l" szX ", pscnk->cbChange=%s%l" szX "\n"
            "       cbChangeTotal=%s%l" szX
            ", cbDelta=%s%l" szX
            ", oOldNext=%l" szX ")\n",
        pscnk->oOld,
        pscnk->cbChange < 0? "-" : "",
        pscnk->cbChange < 0? -pscnk->cbChange : pscnk->cbChange,
        cbChangeTotal < 0? "-" : "",
        cbChangeTotal < 0? -cbChangeTotal : cbChangeTotal,
        cbDelta < 0? "-" : "",
        cbDelta < 0? -cbDelta : cbDelta,
        oOldNext));
#endif // DBG==1

    if (cbChangeTotal != 0)
    {
        ULONG oSrc;
        VOID const *pvSrc;

        oSrc = pscnk->oOld - min(pscnk->cbChange, 0);
        pvSrc = _MapOffsetToAddress(oSrc);
        PropMoveMemory(
                "CompactChunk",
                _GetSectionHeader(),
                (VOID *) Add2ConstPtr(pvSrc, cbChangeTotal),
                pvSrc,
                oOldNext - oSrc);
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_PatchSectionOffsets, private
//
// Synopsis:    patch section offsets after moving data around
//
// Arguments:   [cbChange]      -- size delta
//
// Returns:     none
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_PatchSectionOffsets(
    LONG cbChange)
{
    ULONG i;

    for (i = 0; i < _cSection; i++)
    {
	FORMATIDOFFSET *pfo;

	pfo = _GetFormatidOffset(i);
	if (pfo->dwOffset > _oSection)
	{
	    DebugTrace(0, DEBTRACE_PROPPATCH, (
		"PatchSectionOffsets(%x): %l" szX " + %l" szX " --> %l" szX "\n",
		i,
		pfo->dwOffset,
		cbChange,
		pfo->dwOffset + cbChange));
	    pfo->dwOffset += cbChange;
	}
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetNewOffset, private
//
// Synopsis:    gets the new address
//
// Arguments:   [pscl]          -- list of stream chunks that were changed
//              [oOld]          -- old offset
//
// Returns:     new offset
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_GetNewOffset(
    IN CStreamChunkList const *pscl,
    IN ULONG oOld) const
{
    // The Chunk list is sorted by start offsets.  Locate the chunk to which
    // the old offset belongs, then use the total change undergone by the chunk
    // to compute the new offset.

    ULONG i;
    ULONG iMax = pscl->Count();
    LONG cbChangeTotal = 0;

    for (i = 0; i < iMax; i++)
    {
        CStreamChunk const *pscnk = pscl->GetChunk(i);
        if (pscnk->oOld > oOld)
        {
            break;
        }
        cbChangeTotal += pscnk->cbChange;
        if (pscnk->oOld == oOld)
        {
            PROPASSERT(pscnk->cbChange >= 0);
            break;
        }
    }
    PROPASSERT(i < iMax);
    DebugTrace(0, Dbg, (
        "GetNewOffset: %l" szX " + %l" szX " --> %l" szX "\n",
        oOld,
        cbChangeTotal,
        oOld + cbChangeTotal));
    return(oOld + cbChangeTotal);
}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixUnalignedUDPropSet, private
//
// Synopsis:    Fixes a case seen with Visio where the user-defined
//              property set is not dword aligned.  The fix is to align
//              it (shifting everything else back) in memory.
//
// Arguments:   [*pcbstm]  -- in:  current stream size
//                            out: updated stream size.
//              [pstatus]  -- pointer to NTSTATUS code
//
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_FixUnalignedUDPropSet( ULONG *pcbstm,
                                            NTSTATUS *pstatus )
{
    *pstatus = STATUS_SUCCESS;

    //
    // Don't assume *any* class variables except _pph & _State are loaded yet!
    //

    ULONG cSection;
    UNALIGNED PROPERTYSECTIONHEADER* pshOld = NULL;
    PROPERTYSECTIONHEADER* pshNew = NULL;
    ULONG cbDelta = 0;
    ULONG cbTail = 0;
    ULONG oSection = 0;

    // We only do this fixup for the docsuminfo/userdefined property sets.

    if( !(_State & (CPSS_USERDEFINEDPROPERTIES|CPSS_DOCUMENTSUMMARYINFO)) )
        return;

    // Make sure we have a header.

    if( NULL == _pph )
        return;

    // Make sure the stream is at least big enough to have
    // a second section.

    if( *pcbstm < CB_PROPERTYSETHEADER + 2*CB_FORMATIDOFFSET )
        return;

    // We're only looking for a 2-section problem, so we're done if
    // there's only one section.

    cSection = _pph->reserved;
    if( 1 >= cSection )
        return;

    // Get the stream-relative offset of the second section.

    //oSection = _GetFormatidOffset(1)->dwOffset;
    oSection = ((FORMATIDOFFSET *) Add2Ptr(_pph, sizeof(*_pph)))[1].dwOffset;

    // If it's already aligned, then we're done.

    if( IsDwordAligned(oSection) )
        return;

    // Determine how much we need to add to make it aligned, and determine
    // the size of the stream after the misalignment point.

    cbDelta = DwordRemain(oSection);
    pshOld = (PROPERTYSECTIONHEADER *) Add2Ptr(_pph, oSection);
    pshNew = (PROPERTYSECTIONHEADER *) ( (ULONG_PTR) pshOld + cbDelta );
    
    // ?? This looks to be a convoluted way of saying
    // cbTail = *pcbstm - oSection
    cbTail = (ULONG)( (ULONG_PTR) pshOld - (ULONG_PTR) _pph );
    cbTail = *pcbstm - cbTail;

    // Make sure there's enough stream left to see the second section's header.
    // ?? This looks to be unnecssary (we don't read the section header anywhere),
    // but harmless so leaving intact to be safe.

    if( *pcbstm < oSection + sizeof(PROPERTYSECTIONHEADER) )
    {
        StatusCorruption (pstatus, "_FixUnalignedUDPropSet:  stream size too short to read section header");
        goto Exit;
    }

    // Reset the stream size, only in memory for now, to accomodate
    // cbDelta more bytes.

    _MSTM(SetSize)(
	    *pcbstm + cbDelta,
            FALSE,   // Not persistent, only in memory
	    (VOID **) &_pph,
            pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    *pcbstm += cbDelta;

    // Recalc the location of the section header (in memory) now
    // that we have a new _pph from the _MSTM call.

    pshOld = (PROPERTYSECTIONHEADER *) Add2Ptr(_pph, oSection);
    pshNew = (PROPERTYSECTIONHEADER *) ( (ULONG_PTR) pshOld + cbDelta );

    // Shift everything out by cbDelta bytes.

    RtlMoveMemory( pshNew,
                   pshOld,
                   cbTail );
    ((FORMATIDOFFSET *) Add2Ptr(_pph, sizeof(*_pph)))[1].dwOffset += cbDelta;

    *pstatus = STATUS_SUCCESS;

Exit:

    return;

}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ComputeMinimumSize, private
//
// Synopsis:    computes the minimum possible size of a property set stream
//
// Arguments:   [cbstm]         -- actual stream size
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     computed highest offset in use
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_ComputeMinimumSize(
    IN ULONG cbstm,
    OUT NTSTATUS *pstatus)
{
    ULONG oMax = 0;
    *pstatus = STATUS_SUCCESS;

    // Don't assume *any* class variables except _pph are loaded yet!

    if (_pph != NULL && cbstm != 0)
    {
        ULONG cbMin;
        ULONG i;
        ULONG cSection;

        cSection = 1;
        cbMin = 0;

        // Can we read _pph?

        if( cbstm < CB_PROPERTYSETHEADER )
        {
            StatusError(pstatus, "SetValue:  corrupt versioned_stream guid",
                        STATUS_INTERNAL_DB_CORRUPTION);
            goto Exit;
        }

        // Get the section count, and update cbMin to include everything
        // up to the first section.

        if (_HasPropHeader())
        {
            cSection = _pph->reserved;
            cbMin = CB_PROPERTYSETHEADER + cSection * CB_FORMATIDOFFSET;
        }
        oMax = cbMin;

        // Add the size of each section

        for (i = 0; i < cSection; i++)
        {
            ULONG oSectionEnd;

            // Get the section header.  This will validate that it's safe
            // to read up to and including the section header.

            PROPERTYSECTIONHEADER const *psh = _GetSectionHeader(i, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            cbMin += psh->cbSection;
            oSectionEnd = _MapAddressToAbsOffset(psh) + psh->cbSection;
            if (oMax < oSectionEnd)
            {
                oMax = oSectionEnd;
            }
        }

        // The following can't be asserted, because there may be
        // a correctable reason why cbstm < oMax at in the Open path
        // (see the Excel 5.0a problem in _FixSummaryInformation)
        //PROPASSERT(oMax <= cbstm);

        PROPASSERT(cbMin <= oMax);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // oMax may have been set before an error occurred.
    // In this case, set it to zero.

    if( !NT_SUCCESS(*pstatus) )
        oMax = 0;

    return(oMax);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DictionaryLength
//
// Synopsis:    compute length of property set dictionary
//
// Arguments:   [pdy]           -- pointer to dictionary
//              [cbbuf]         -- maximum length of accessible memory at pdy
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     Byte-granular count of bytes in dictionary
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_DictionaryLength(
    IN DICTIONARY const *pdy,
    IN ULONG cbbuf,
    OUT NTSTATUS *pstatus ) const
{
    ENTRY UNALIGNED const *pent;
    ULONG cbDict = CB_DICTIONARY;
    ULONG i;

    *pstatus = STATUS_SUCCESS;

    // Ensure we can read pdy->cEntries

    if( cbbuf < CB_DICTIONARY )
    {
        StatusCorruption(pstatus, "_DictionaryLength: section size");
        goto Exit;
    }

    // Loop through the dictionary entries

    for (i = 0, pent = &pdy->rgEntry[0];
         i < PropByteSwap( pdy->cEntries );
         i++, pent = _NextDictionaryEntry( pent ))
    {
        void *pvName = NULL;

        // Ensure the buffer is big enough to hold this entry
        // (_DictionaryEntryLength only looks at the
        // CB_DICTIONARY_ENTRY bytes, so this call is safe).

        if( cbbuf < cbDict + CB_DICTIONARY_ENTRY )
        {
            StatusCorruption(pstatus, "_DictionaryLength: section size");
            goto Exit;
        }

        if( cbbuf < (UINT_PTR) pent
                    - (UINT_PTR) pdy
                    + _DictionaryEntryLength( pent ))
        {
            StatusCorruption(pstatus, "_DictionaryLength: section size");
            goto Exit;
        }

        // Is the name null-terminated?

        pvName = (void*)pent->sz;
        if( CP_WINUNICODE == _CodePage
            &&
            S_OK != StringCchLengthW( (WCHAR*)pvName, pent->cch, NULL ))
            //L'\0' != ((WCHAR*)pvName)[ pent->cch - 1 ] )
        {
            StatusCorruption(pstatus, "_DictionaryLength: section size");
            goto Exit;
        }

        if( CP_WINUNICODE != _CodePage
            &&
            S_OK != StringCchLengthA( (CHAR*)pvName, pent->cch, NULL ))
            //'\0' != ((CHAR*)pvName)[ pent->cch - 1 ] )
        {
            StatusCorruption(pstatus, "_DictionaryLength: section size");
            goto Exit;
        }

        cbDict += _DictionaryEntryLength( pent );
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(cbDict);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_IsLocalizationSettable
//
// Synopsis:    Determine if this property set may be localized
//              (i.e., that the codepage & locale ID may be set).
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     TRUE if settable.
//+--------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_IsLocalizationSettable(
    OUT NTSTATUS *pstatus )
{
    BOOLEAN fSettable = FALSE;
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase = NULL, *ppoMax = NULL;

    *pstatus = STATUS_SUCCESS;

    // Get the section header

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // If the section is empty, then we're done.

    if( NULL == psh || 0 == psh->cProperties )
    {
        fSettable = TRUE;
        goto Exit;
    }

    // Walk through the properties in the set

    for (ppo = ppoBase; ppo < ppoMax; ppo++)
    {
        // Is this the dictionary?

        if( PID_DICTIONARY == ppo->propid )
        {
            // The dictionary is OK if it's empty.

            DICTIONARY const *pdy;

            pdy = reinterpret_cast<DICTIONARY const *>
                  ( _MapOffsetToAddress(ppo->dwOffset) );

            if( 0 != pdy->cEntries )
                goto Exit;  // fSettable == FALSE
        }

        // Or, is this an existing codepage or LCID property
        // (which are fine to overwrite)?

        else if( PID_CODEPAGE != ppo->propid
                 &&
                 PID_LOCALE   != ppo->propid )
        {
            // No, so we're done.
            goto Exit;  // fSettable == FALSE
        }
    }

    fSettable = TRUE;

Exit:

    return( fSettable );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_PropertyNameLength
//
// Synopsis:    compute length (*byte* count) of a property name
//
// Arguments:   [pvName]        -- property name, in the codepage of
//                                 the property set
//              [pcbName]       -- pointer to returned byte length of name
//
// Returns:     Minimum format version (wFormat) required for this name.
//
// Note:        The OLE 2.0 format mandates that the null be included as part
//              of the length of the name that is stored in the dictionary.
//              If the propset uses the Unicode code page, names contain
//              WCHARs, otherwise they contain CHARs.  In either case, the
//              length is a byte count that includes the L'\0' or '\0'.
//
//              Also note that this routine does not concern itself with
//              the byte-order of the name:  for Ansi names, it's irrelevant;
//              and for Unicode names, L'\0' == PropByteSwap(L'\0').
//
//+--------------------------------------------------------------------------

WORD
CPropertySetStream::_PropertyNameLength(
    IN VOID const *pvName,
    OUT ULONG *pcbName) const
{
    ULONG cchsz;

    if (_CodePage == CP_WINUNICODE)
    {
        cchsz = (ULONG)Prop_wcslen((WCHAR const *) pvName) + 1;
        *pcbName = cchsz * sizeof(WCHAR);
    }
    else
    {
        *pcbName = cchsz = (ULONG)strlen((char const *) pvName) + 1;
    }

    return( cchsz > CCH_MAXPROPNAMESZ ? PROPSET_WFORMAT_LONG_NAMES : PROPSET_WFORMAT_ORIGINAL );

}   // CPropertySetStream::_PropertyNameLength


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ComparePropertyNames
//
// Synopsis:    Compare two property names.
//
// Pre-Conditions:
//              The property names are in the codepage of the
//              property set.
//
// Arguments:   [pvName1]       -- property name 1
//              [pvName2]       -- property name 2
//              [fSameByteOrder]-- TRUE:  names are both big- or little-endian
//                                 FALSE: 2nd name is wrong endian in a big endian compile
//              [cbName]        -- byte count of name length
//                                 (includes terminator)
//
// Returns:     TRUE if names are equal
//+--------------------------------------------------------------------------



BOOLEAN
CPropertySetStream::_ComparePropertyNames(
    IN VOID const *pvName1,
    IN VOID const *pvName2,
    IN BOOL fSameByteOrder,
    IN ULONG cbName,
    OUT NTSTATUS *pstatus ) const
{

    #ifdef BIGENDIAN
    // If fSameByteOrder, we need to swap pvName2.
    #error BigEndian support in this routine needs to be implemented
    #endif

    int nCompare = 0;
    *pstatus = STATUS_SUCCESS;

    PROPASSERT( NULL != pvName1 && NULL != pvName2 );
    PROPASSERT( _SupportsLongNames() || CCH_MAXPROPNAMESZ >= CB2CCh(cbName) );

    // Now compare the strings

    if (_CodePage == CP_WINUNICODE)
    {
        // Compare Unicode strings

        PROPASSERT( IsUnicodeString(reinterpret_cast<const WCHAR*>(pvName1),cbName)
                    &&
                    IsUnicodeString(reinterpret_cast<const WCHAR*>(pvName2),cbName) );

        if( _IsCaseSensitive() )
        {
            nCompare = CompareStringW( _Locale,
                                       0,
                                       reinterpret_cast<WCHAR const *>(pvName1),
                                       -1,
                                       reinterpret_cast<WCHAR const *>(pvName2),
                                         -1 );
        }
        else
        {
            nCompare = CompareStringW( _Locale,
                                       NORM_IGNORECASE,
                                       reinterpret_cast<WCHAR const *>(pvName1),
                                       -1,
                                       reinterpret_cast<WCHAR const *>(pvName2),
                                       -1  );
        }

    }
    else
    {
        // Compare Ansi strings

        PROPASSERT( IsAnsiString(reinterpret_cast<const CHAR*>(pvName1), cbName)
                    &&
                    IsAnsiString(reinterpret_cast<const CHAR*>(pvName2), cbName) );

        if( _IsCaseSensitive() )
        {
            nCompare = CompareStringA( _Locale,
                                       0,
                                       reinterpret_cast<char const *>(pvName1),
                                       -1,
                                       reinterpret_cast<char const *>(pvName2),
                                       -1 );
        }
        else
        {
            nCompare = CompareStringA( _Locale,
                                       NORM_IGNORECASE,
                                       reinterpret_cast<char const *>(pvName1),
                                       -1,
                                       reinterpret_cast<char const *>(pvName2),
                                       -1 );
        }
    }


    if( CSTR_EQUAL == nCompare )
        return TRUE;
    else if( 0 == nCompare )
    {
        StatusError( pstatus, "Failed CompareString", HRESULT_FROM_WIN32(GetLastError()) );
    }

    return FALSE;

}   // CPropertySetStream::_ComparePropertyNames()



//+---------------------------------------------------------------------------
// Function:    CPropertySetStream::DuplicatePropertyName
//
// Synopsis:    Duplicate an OLECHAR property name string
//
// Arguments:   [poszName]  -- input string
//              [pstatus]   -- pointer to NTSTATUS code
//
// Returns:     pointer to new string
//---------------------------------------------------------------------------

OLECHAR *
CPropertySetStream::DuplicatePropertyName(
    IN OLECHAR const *poszName,
    OUT NTSTATUS *pstatus) const
{
    OLECHAR *poc = NULL;
    *pstatus = STATUS_SUCCESS;
    ULONG cbName = (1 + ocslen(poszName)) * sizeof(OLECHAR);

    if (cbName != 0)
    {
        poc = (OLECHAR *) _pma->Allocate(cbName);

        if (NULL == poc)
        {
            StatusNoMemory(pstatus, "DuplicatePropertyName: no memory");
            goto Exit;
        }
        RtlCopyMemory(poc, poszName, cbName);

    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(poc);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropid
//
// Synopsis:    translate a property name to a property id using the
//              dictionary on the property stream
//
// Arguments:   [poszName]      -- name of property
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     propid for property if found; PID_ILLEGAL if not found
//---------------------------------------------------------------------------

PROPID
CPropertySetStream::QueryPropid(
    IN OLECHAR const *poszName,
    OUT NTSTATUS *pstatus )
{
    //  ------
    //  Locals
    //  ------

    ULONG cbname;
    DICTIONARY const *pdy;
    ENTRY UNALIGNED const *pent;
    ULONG cdye;
    ULONG cbDict;               // BYTE granular size!
    VOID const *pvName = NULL;
    PROPID propid = PID_ILLEGAL;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::QueryPropid" );
    propTraceParameters(( "poszName=%s",
                          poszName ));

    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT( IsOLECHARString( poszName, MAXULONG ));
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);


    // Make sure this isn't a UD propset which has been deleted.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropid: deleted");
        goto Exit;
    }

    // Put the name into pvName, converting it if
    // necessary to the code-page of the property set.

    pvName = poszName;
    if (_CodePage == CP_WINUNICODE  // Property set is Unicode
        &&
        !OLECHAR_IS_UNICODE )       // Name is in Ansi
    {
        // Convert the caller-provided name from the system
        // Ansi codepage to Unicode.

        ULONG cb = 0;
        pvName = NULL;
        _OLECHARToWideChar( poszName, (ULONG)-1, CP_ACP,
                            (WCHAR**)&pvName, &cb, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    else
    if (_CodePage != CP_WINUNICODE  // Property set is Ansi
        &&
        OLECHAR_IS_UNICODE )        // Name is in Unicode
    {
        // Convert the caller-provided name from Unicode
        // to the propset's Ansi codepage.

        ULONG cb = 0;
        pvName = NULL;
        _OLECHARToMultiByte( poszName, (ULONG)-1, _CodePage,
                             (CHAR**)&pvName, &cb, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    // How long is this property name (in bytes, including terminator)?

    _PropertyNameLength(pvName, &cbname);

    // Ensure that this isn't an empty name.

    if( CP_WINUNICODE == _CodePage && sizeof(WCHAR) == cbname
        ||
        CP_WINUNICODE != _CodePage && sizeof(CHAR)  == cbname)
    {
        // Empty names are invalid
        StatusInvalidParameter(pstatus, "QueryPropid: name length");
        goto Exit;
    }

    // Get a pointer to the raw dictionary (this implicitly validates
    // the dictionary).

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Is there a dictionary?

    if (pdy != NULL)
    {
        // Yes - there is a dictionary.

        PROPERTYSECTIONHEADER const *psh = _GetSectionHeader();

        // Search the dictionary for an entry name matching
        // pvName.

        for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0];
             cdye > 0;
             cdye--, pent = _NextDictionaryEntry( pent ))
        {
            // If the byte-length matches what we're looking for,
            // and the names compare successfully, then we're done.

            if ( CCh2CB(PropByteSwap( pent->cch )) == cbname
                 &&
                 _ComparePropertyNames(pvName, pent->sz,
                                       FALSE, // pvName, pent->sz could be dif Endians
                                       cbname,
                                       pstatus)
               )
            {
                propid = PropByteSwap( pent->propid );
                break;
            }
            else if( !NT_SUCCESS(*pstatus) )
            {
                // There was an error during the property name comparison
                goto Exit;
            }

        }   // for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0]; ...

        PROPASSERT(cdye > 0 || pent == Add2ConstPtr(pdy, cbDict));

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:

    // If we did an alloc on the name to munge it,
    // delete that buffer now.  We must cast pvName
    // as a non-const in order for the compiler to accept
    // the free call.

    if( pvName != poszName )
        _pma->Free( (VOID*) pvName );

    return(propid);
}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertyNames
//
// Synopsis:    query dictionary names for the passed property ids.
//
// Arguments:   [cprop]          -- count of name to propid mappings to change
//              [apid]           -- array of property ids
//              [aposz]          -- array of pointers to the new names
//              [pstatus]        -- pointer to NTSTATUS code
//
// Returns:     TRUE if any of the properties exist.
//+--------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::QueryPropertyNames(
    IN ULONG cprop,
    IN PROPID const *apid,
    OUT OLECHAR *aposz[],
    OUT NTSTATUS *pstatus)
{
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!
    ULONG iprop;
    BOOLEAN fFound = FALSE;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

//    IFDBG( HRESULT &hr = *pstatus );
//    propITrace( "CPropertySetStream::QueryPropertyNames" );
//    propTraceParameters(( "cprop=%d, apid=%p, aposz=%p", cprop, apid, aposz ));

    // If this is an attempt to access a deleted UD
    // propset, exit now.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropertyNames: deleted");
        goto Exit;
    }

    // Validate the input array of strings.
    #if DBG
    for (iprop = 0; iprop < cprop; iprop++)
    {
        PROPASSERT(aposz[iprop] == NULL);
    }
    #endif

    // Get a pointer to the beginning of the dictionary
    // (this implicitely validates the dictionary)

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Did we get a dictionary?
    if (pdy != NULL)
    {
        // Yes, the dictionary exists.

        ULONG i;
        ENTRY UNALIGNED const *pent;

        // Iterate through each of the entries in the dictionary.

        for (i = 0, pent = &pdy->rgEntry[0];
             i < PropByteSwap( pdy->cEntries );
             i++, pent = _NextDictionaryEntry( pent ))
        {
            // Scan the input array of PIDs to see if one matches
            // this dictionary entry.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                if( PropByteSwap(pent->propid) == apid[iprop] )
                {
                    // We've found an entry in the dictionary
                    // that's in the input PID array.  Put the property's
                    // name in the caller-provided array (aposz).

                    PROPASSERT(aposz[iprop] == NULL);

                    // Do we need to convert to Unicode?

                    if (_CodePage != CP_WINUNICODE      // Ansi property set
                        &&
                        OLECHAR_IS_UNICODE)             // Unicode property names
                    {
                        ULONG cbName = 0;
                        _MultiByteToOLECHAR( (CHAR*)pent->sz, (ULONG)-1, _CodePage,
                                             &aposz[iprop], &cbName, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    }

                    // Or, do we need to convert to Ansi?
                    else if( _CodePage == CP_WINUNICODE      // Unicode property set
                             &&
                             !OLECHAR_IS_UNICODE )           // Ansi property names
                    {
                        ULONG cbName = 0;
                        WCHAR *pwszName = (WCHAR*) pent->sz;

                        // If necessary, swap the Unicode name in the dictionary,
                        // pointing pwszName to the new, byte-swapped, buffer.

                        PBSInPlaceAlloc( &pwszName, NULL, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // And convert to Ansi.
                        _WideCharToOLECHAR( pwszName, (ULONG)-1, CP_ACP,
                                            &aposz[iprop], &cbName, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // If we alloced a new buffer for byte-swapping,
                        // we can free it now.

                        if( pwszName != (WCHAR*) pent->sz )
                            CoTaskMemFree( pwszName );

                    }   // else if (_CodePage == CP_WINUNICODE ...

                    // Otherwise, both the propset & in-memory property names
                    // are both Unicode or both Ansi, so we can just do
                    // an alloc & copy.

                    else
                    {
                        aposz[iprop] = DuplicatePropertyName(
                                                    (OLECHAR *) pent->sz,
                                                    pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // If necessary, swap the in-memory copy.
                        PBSBuffer( (OLECHAR*) aposz[iprop],
                                   CCh2CB( PropByteSwap( pent->cch )),
                                   sizeof(OLECHAR) );

                    }   // if (_CodePage != CP_WINUNICODE ... else if ... else

                    PROPASSERT( IsOLECHARString( aposz[iprop], MAXULONG ));

                    fFound = TRUE;

                }   // if (pent->propid == apid[iprop])
            }   // for (iprop = 0; iprop < cprop; iprop++)
        }   // for (i = 0, pent = &pdy->rgEntry[0];

        PROPASSERT(pent == Add2ConstPtr(pdy, cbDict));

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:

    // If the property name simply didn't exist, return
    // a special success code.

    if( !fFound && NT_SUCCESS(*pstatus) )
	    *pstatus = STATUS_BUFFER_ALL_ZEROS;

    return( fFound );

}   // CPropertySetStream::QueryPropertyNames



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetPropertyNames
//
// Synopsis:    changes dictionary entry names associated with property ids.
//
// Arguments:   [cprop]         -- count of name to propid mappings to change
//              [apid]          -- array of property ids
//              [aposz]         -- array of pointers to the new names
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//
// Note:        Attempting to set a property name for a property that does not
//              exist in the property set is not an error.
//
//              Attempting to set a property name or property id that would
//		result in a duplicate name or property id causes the existing
//		entry(ies) to be replaced.
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::SetPropertyNames(
    IN ULONG cprop,
    IN const PROPID *apid,
    IN OPTIONAL OLECHAR const * const aposz[],
    OUT NTSTATUS *pstatus )
{

    //  ------
    //  Locals
    //  ------

    DICTIONARY *pdy = NULL;
    ULONG cbDictOld = 0;            // Byte granular Old dictionary size
    ULONG cbDictOldD = 0;           // Dword granular Old dictionary size
    ULONG iprop = 0;
    ULONG i = 0;
    ULONG cDel, cAdd;
    LONG cbDel, cbAdd;          // Byte granular sizes
    LONG cbChangeD;             // Dword granular size
    ENTRY UNALIGNED *pent;
    BOOLEAN fDupPropid = FALSE;
    BOOLEAN fDupName = FALSE;
    BOOLEAN fDeleteByName = FALSE;
    BOOLEAN fDeleteAll = FALSE;
    VOID **appvNames = NULL;

    ULONG cbstm;
    ULONG oDictionary;
    ULONG cbTail;
    ULONG cbNewSize;

    IFDBG( HRESULT &hr = *pstatus );
    propITrace( "CPropertySetStream::SetPropertyNames" );
    propTraceParameters(( "cprop=%d, apid=%p, aposz=%p",
                          cprop, apid, aposz ));

    
    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    //  --------
    //  Validate
    //  --------

    // Verify that this propset is modifiable.
    if (IsReadOnlyPropertySet(_Flags, _State))
    {
        StatusAccessDenied(pstatus, "SetPropertyNames: deleted or read-only");
        goto Exit;
    }

    if (aposz != NULL)
    {
        for (iprop = 0; iprop < cprop; iprop++)
        {
            PROPASSERT( IsOLECHARString( aposz[iprop], MAXULONG ));
        }
    }   // if (apwsz != NULL)

    //  ----------------------------------------------------------------
    //  If necessary, convert each of the caller-provided names:
    //  to Unicode (if the property set is Unicode) or Ansi (otherwise).
    //  ----------------------------------------------------------------

    // In the end, appvNames will have the names in the same codepage
    // as the property set.

    appvNames = (VOID **) aposz;
    if (appvNames != NULL)
    {
        // Do we need to convert the caller's names to Ansi?

        if( _CodePage != CP_WINUNICODE  // Property set is Ansi
            &&
            OLECHAR_IS_UNICODE )        // Caller's names are Unicode
        {
            // Allocate an array of cprop string pointers.

            appvNames = (VOID **) CoTaskMemAlloc( sizeof(char *) * cprop );
            if (appvNames == NULL)
            {
                StatusNoMemory(pstatus, "SetpropertyNames: Ansi Name Pointers");
                goto Exit;
            }
            RtlZeroMemory(appvNames, cprop * sizeof(appvNames[0]));

            // Convert the caller-provided property names from Unicode to
            // the property set's codepage.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                ULONG cb = 0;

                // Silently ignore PID_ILLEGAL
                if( PID_ILLEGAL == apid[iprop] ) continue;

                // Convert from aposz to appvNames
                appvNames[iprop] = NULL;
                _OLECHARToMultiByte( (OLECHAR*) aposz[iprop], (ULONG)-1, _CodePage,
                                     (CHAR**) &appvNames[iprop], &cb, pstatus );
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
            }

        }   // if( _CodePage != CP_WINUNICODE ...

        // Or, do we need to convert the caller's names to Unicode?

        if( _CodePage == CP_WINUNICODE  // Property set is Unicode
            &&
            !OLECHAR_IS_UNICODE  )      // Caller's names are Ansi
        {
            // Allocate an array of cprop string pointers.

            appvNames = (VOID **) CoTaskMemAlloc( sizeof(WCHAR*)*cprop );
            if (appvNames == NULL)
            {
                StatusNoMemory(pstatus, "SetpropertyNames: Unicode Name Pointers");
                goto Exit;
            }
            RtlZeroMemory(appvNames, cprop * sizeof(appvNames[0]));

            // Convert the caller-provided property names from the system
            // default Ansi codepage to Unicode.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                ULONG cb = 0;

                // Silently ignore PID_ILLEGAL
                if( PID_ILLEGAL == apid[iprop] ) continue;

                // Convert from aposz to appvNames
                appvNames[iprop] = NULL;
                _OLECHARToWideChar( (OLECHAR*) aposz[iprop], (ULONG)-1, CP_ACP,
                                    (WCHAR**) &appvNames[iprop], &cb, pstatus );
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
            }
        }   // if( _CodePage == CP_WINUNICODE )
    }   // if (appvNames != NULL)


    //  -----------------------------------------------------
    //  Compute total size of entries to be modified or added
    //  -----------------------------------------------------

    cbAdd = 0;
    cAdd = 0;
    for (iprop = 0; iprop < cprop; iprop++)
    {
        // Did the caller give us no array of names?  If so,
        // it means that the name for this PID is to be deleted.

        if (appvNames == NULL)
	{
            // If the PID is for the dictionary, then it must be the
            // only entry in apid, and it indicates that we're going to
            // delete all the names in the dictionary.

	    if (apid[iprop] == PID_DICTIONARY)
	    {
		if (cprop != 1)
		{
		    StatusInvalidParameter(pstatus, "SetPropertyNames: DeleteAll parms");
                    goto Exit;
		}
		fDeleteAll = TRUE;
	    }
        }

        // Otherwise, we're setting a new name for this PID.

	else
        {
            ULONG cbname;
            WORD wFormatRequired;

            // Silently ignore PID_ILLEGAL
            if( PID_ILLEGAL == apid[iprop] )
                continue;   // => for (iprop = 0; iprop < cprop; iprop++)

            // Validate the caller-provided length.

            wFormatRequired = _PropertyNameLength(appvNames[iprop], &cbname);

            if( CP_WINUNICODE == _CodePage && sizeof(WCHAR) == cbname
                ||
                CP_WINUNICODE != _CodePage && sizeof(CHAR)  == cbname)
            {
                // Empty names are not supported
                StatusInvalidParameter(pstatus, "SetPropertyNames: name length");
                goto Exit;
            }

            // Update the format if necessary (long property names were not
            // supported in version 0).

            _pph->wFormat = max( _pph->wFormat, wFormatRequired );

            // See if this propid or name appears later in the array.  If so,
            // we'll ignore it and wait for the final instance.

            for (i = iprop + 1; i < cprop; i++)
            {
                ULONG cbname2;

                if (apid[i] == apid[iprop])
                {
                    fDupPropid = TRUE;
                    break;
                }

                _PropertyNameLength(appvNames[i], &cbname2);

                if (cbname == cbname2 &&
                    _ComparePropertyNames(
                                appvNames[iprop],
                                appvNames[i],
                                TRUE, // Both names are in the same byte-order
                                cbname,
                                pstatus))
                {
                    fDupName = TRUE;
                    break;
                }
                else if( !NT_SUCCESS(*pstatus) )
                {
                    // There was an error in _ComparePropertyNames
                    goto Exit;
                }
            }

            // If this propid appears only once or if it's the last instance,
            // count it.  If the property set is Unicode, include DWORD padding.

            if (i == cprop)
            {
                propDbg(( DEB_ITRACE,
                    _CodePage == CP_WINUNICODE?
                        "Adding New Entry: propid=%lx  L'%ws'\n" :
                        "Adding New Entry: propid=%lx  '%s'\n",
                    apid[iprop],
                    appvNames[iprop]));

                cAdd++;

                cbAdd += CB_DICTIONARY_ENTRY + cbname;
                if( _CodePage == CP_WINUNICODE )
                {
                    cbAdd = DwordAlign( cbAdd );
                }
            }
        }
    }
    PROPASSERT( _CodePage == CP_WINUNICODE ? IsDwordAligned( cbAdd ) : TRUE );


    //  ---------------------------------------------
    //  Get the dictionary, creating it if necessary.
    //  ---------------------------------------------

    _SetModified( pstatus );
    if( !NT_SUCCESS(*pstatus) )
    {
        propDbg(( DEB_ERROR, "SetPropertyNames: Couldn't SetModified (%08x)\n", *pstatus ));
        goto Exit;
    }

    // Make two passes at getting the dictionary.  If it doesn't exist, create one and
    // try again.

    for (i = 0; i <= 2; i++)
    {
        PROPERTY_INFORMATION pinfo;
        PROPVARIANT var;

        // We should never require more than two passes

        if( 2 <= i )
        {
            StatusError( pstatus, "SetPropertyNames: infinite loop", STATUS_INTERNAL_DB_CORRUPTION );
            goto Exit;
        }

        // Get the dictionary (this implicitely validates it).

        pdy = (DICTIONARY *) _LoadProperty(PID_DICTIONARY, &cbDictOld, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // If we have the dictionary, move on (out of this loop)
        if (pdy != NULL)
        {
            break;
        }

        // There's no dictionary, we need to create one.

        PROPASSERT(i == 0);

        // Of course, if we're being asked to delete the dictionary or to do
        // nothing, then we're done (no need to create an empty one).

        if (cprop == 0 || appvNames == NULL)
        {
            goto Exit;
        }

        // If we get this far, we need to creat a new dictionary.

        propDbg(( DEB_ITRACE, "Creating empty dictionary\n"));
        PROPASSERT(CB_SERIALIZEDPROPERTYVALUE == CB_DICTIONARY);

        // Since the dictionary is actually implemented as a special property, 
        // we just have to call SetValue (there's some special-case code in SetValue,
        // though, for this case).

        pinfo.cbprop = CB_SERIALIZEDPROPERTYVALUE;
        pinfo.pid = PID_DICTIONARY;

        var.vt = VT_DICTIONARY;
        SetValue(1, NULL, &var, &pinfo, NULL, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        Validate(pstatus);     // Make sure dictionary was properly created
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        DebugTrace(0, Dbg, ("Created empty dictionary\n"));

    }   // for (i = 0; i <= 2; i++)
    
    // We now have the dictionary in pdy

    //  ----------------------------------------------------------------
    //  Compute total size of existing entries to be modified or deleted
    //  ----------------------------------------------------------------

    // Walk the dictionary looking for entries which are referenced
    // in the caller's 'apid' array or 'appvNames' array.

    cbDel = 0;
    cDel = 0;
    for (i = 0, pent = &pdy->rgEntry[0];
         i < PropByteSwap( pdy->cEntries );
         i++, pent = _NextDictionaryEntry( pent ))
    {
        propDbg(( DEB_ITRACE,
            _CodePage == CP_WINUNICODE?
                "Dictionary Entry @%lx: propid=%lx L'%ws'\n" :
                "Dictionary Entry @%lx: propid=%lx '%s'\n",
            pent,
            PropByteSwap( pent->propid ),
            pent->sz ));

        // For this dictionary entry, walk the caller's
        // 'apid' and 'appvNames' arrays, looking for a match.

        for (iprop = 0; iprop < cprop; iprop++)
        {
            // Silently ignore PID_ILLEGAL
            if( PID_ILLEGAL == apid[iprop] ) continue;

            // If we get to the bottom of this 'for' loop,
            // then we know that we've found an entry to delete.
            // If fDeleteAll, or the PID in apid matches this
            // dictionary entry, then we can fall to the bottom.
            // Otherwise, the following 'if' block checks the
            // name in 'appvNames' against this dictionary entry.

            if (!fDeleteAll
                &&
                apid[iprop] != PropByteSwap( pent->propid ))
            {
                // The caller's PID didn't match this dictionary entry,
                // does the name?

                ULONG cbname;

                // If we have no names from the caller, then we obviously
                // don't have a match, and we can continue on to check this
                // dictionary entry against the next of the caller's PIDs.

                if (appvNames == NULL)
                {
                    continue;
                }

                // Or, if this name from the caller doesn't match this
                // dictionary entry, we again can continue on to check
                // the next of the caller's properties.

                _PropertyNameLength(appvNames[iprop], &cbname);
                if (cbname != CCh2CB( PropByteSwap( pent->cch ))
                    ||
                    !_ComparePropertyNames(
                            appvNames[iprop],
                            pent->sz,
                            FALSE,  // appvNames & pent->sz may be dif endians.
                            cbname,
                            pstatus )
                   )
                {
                    // Check to see if there was an error from _ComparePropertyNames
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    continue;
                }

                // Show that at least one property delete is by name.
                // (This is for an optimization later).

                fDeleteByName = TRUE;

            }   // if (!fDeleteAll ...

            // If we reach this point, we're going to delete this entry
            // in the dictionary (either by propid, by name, or because
            // of fDeleteAll).  So update cDel & cbDel.

            propDbg(( DEB_ITRACE,
                "Deleting Entry (%s) @%lx: propid=%lx\n",
                fDeleteAll? "DeleteAll" :
                    apid[iprop] == PropByteSwap(pent->propid)
                                ? "replace by propid"
                                : "replace by name",
                pent,
                PropByteSwap( pent->propid )));

            cDel++;
            cbDel += _DictionaryEntryLength( pent );

            // We don't need to continue through the caller's arrays,
            // we can move on to the next dictionary entry.

            break;

        }   // for (iprop = 0; iprop < cprop; iprop++)
    }   // for (i = 0, pent = &pdy->rgEntry[0]; ...

    // At this point we've figured out what to add and delete.
    // cDel is the number of deletions and cbDel is the amount
    // of space occupied by those names.  Same for cAdd and cbAdd.

    PROPASSERT(pent == Add2Ptr(pdy, cbDictOld));
    PROPASSERT( _CodePage == CP_WINUNICODE ? IsDwordAligned( cbDel ) : TRUE );


    cbDictOldD = DwordAlign(cbDictOld);
    cbChangeD = DwordAlign(cbDictOld + cbAdd - cbDel) - cbDictOldD;

    cbstm = _oSection + _GetSectionHeader()->cbSection + _cbTail;
    oDictionary = _MapAddressToOffset(pdy);

    cbTail = cbstm - (_oSection + oDictionary + cbDictOldD);

    //  --------------------------------------------------------
    //  Before we change anything, grow the stream if necessary.
    //  --------------------------------------------------------

    if (cbChangeD > 0)
    {
        propDbg(( DEB_ITRACE,
            "SetSize(%x) dictionary grow\n", cbstm + cbChangeD));
        if (cbstm + cbChangeD > CBMAXPROPSETSTREAM)
        {
            StatusDiskFull(pstatus, "SetPropertyNames: 256k limit");
            goto Exit;
        }

        _MSTM(SetSize)(cbstm + cbChangeD, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Get a pointer to the new dictionary location

        pdy = (DICTIONARY *) _MapOffsetToAddress(oDictionary);

        // move everything after the dictionary back by cbChangeD bytes.

        PropMoveMemory(
            "SetPropertyNames:TailBack",
            _GetSectionHeader(),
            Add2Ptr(pdy, cbDictOldD + cbChangeD),
            Add2Ptr(pdy, cbDictOldD),
            cbTail);
    }

    //  -------------------------------------------------------------------
    //  Walk through the existing dictionary and compact unmodified entries
    //  toward the front.  New and modified entries will be appended later.
    //  -------------------------------------------------------------------

    VOID *pvSrc;
    VOID *pvDst;
    ULONG cbCopy;

    pvDst = pvSrc = pent = &pdy->rgEntry[0];
    cbCopy = 0;

    if (!fDeleteAll)
    {
        ULONG cb;

        // Loop through the dictionary entries

        for (i = 0; i < PropByteSwap(pdy->cEntries); i++)
        {
            // Search to see if this entry is in the caller's apid array.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                // Did we find an entry in the caller's array that is
                // this dictionary entry?

                if( apid[iprop] == PropByteSwap(pent->propid) )
                {
                    // Yes.  Break out so that we can overwrite
                    // the old value.
                    break;
                }

                // The propid didn't match this entry, but see if we're deleting
                // any of the properties by name.  This fDeleteByName indicates
                // that at least one property delete is by name.  This exists
                // to optimize the case wher all of the properties are specified
                // by ID, in that case we can skip all these semi-expensive operations.

                if (fDeleteByName)
                {
                    ULONG cbname;

                    _PropertyNameLength(appvNames[iprop], &cbname);
                    if (cbname == CCh2CB( PropByteSwap( pent->cch ))
                        &&
                        _ComparePropertyNames(
                                appvNames[iprop],
                                pent->sz,
                                FALSE,  // appvNames & pent->sz may be dif endians
                                cbname,
                                pstatus)
                       )
                    {
                        break;          // found an entry to be removed.
                    }
                    else if( !NT_SUCCESS(*pstatus) )
                    {
                        // There was an error in _ComparePropertyNames
                        goto Exit;
                    }
                }
            }   // for (iprop = 0; iprop < cprop; iprop++)

            // When we get to this point, we've figured out whether or not
            // this entry is being overwritten (if it is, iprop is less than
            // cprop).

            // Get info about this entry.

            cb = _DictionaryEntryLength( pent );
            pent = _NextDictionaryEntry( pent );

            // Are we overwriting this entry?

            if (iprop == cprop)
            {
                // No - keep this entry.  Keep track of how
                // big it is, so that we can copy it forward to cover
                // up any earlier wholes left by names we're going to
                // overwrite/delete.

                cbCopy += cb;
            }
            else
            {
                // Yes - this entry is being overwritten

                // Do we have to-keep names to copy forward?
                if (cbCopy != 0)
                {
                    // Yes.  If we've never copied anything yet, 
                    // src == dst, and we don't actually need to move
                    // anything.

                    if (pvSrc != pvDst)
                    {
                        // Move a group of to-keep names forward, overwrting
                        // some to-delete names.

                        PropMoveMemory(
                            "SetPropertyNames:Compact",
                            _GetSectionHeader(),
                            pvDst,
                            pvSrc,
                            cbCopy);
                    }

                    // Move pvDst past the names we're keeping.
                    pvDst = Add2Ptr(pvDst, cbCopy);
                    cbCopy = 0;
                }

                // Move pvSrc to this property - this is the next potential
                // place from which we'll copy.

                pvSrc = pent;
            }
        }   // for (i = 0; i < PropByteSwap(pdy->cEntries); i++)

        // Compact last chunk and point past compacted entries.

        if (cbCopy != 0 && pvSrc != pvDst)
        {
            PropMoveMemory(
                "SetPropertyNames:CompactLast",
                _GetSectionHeader(),
                pvDst,
                pvSrc,
                cbCopy);
        }
        pent = (ENTRY UNALIGNED *) Add2Ptr(pvDst, cbCopy);

    }   // if (!fDeleteAll)

    // Update the dictionary entry count according to what we 
    // just deleted.  Note that pent is left pointing to the first
    // available entry.

    pdy->cEntries = PropByteSwap( PropByteSwap(pdy->cEntries) - cDel );

    //  ------------------------------------
    //  Append new and modified entries now.
    //  ------------------------------------

    // New/modified entries get added at the end of the dictionary, in the whole left
    // by the deleted/overwritten names above and by the SetSize earlier.

    if (appvNames != NULL)
    {
        // Add each name to the property set.

        for (iprop = 0; iprop < cprop; iprop++)
        {
            // See if this propid appears later in the array
            // (but only bother with this if we know there was at
            // least one dup in apid).

            i = cprop;
            if (fDupPropid)
            {
                for (i = iprop + 1; i < cprop; i++)
                {
                    if (apid[i] == apid[iprop])
                    {
                        break;
                    }
                }
            }

            // If this is the last instance of the propid in the
            // apid array, see if this name appears later in the appvNames array
            // (but only bother with this check if we know there was at
            // least one dup name).

            if (i == cprop && fDupName)
            {
                ULONG cbname;

                _PropertyNameLength(appvNames[iprop], &cbname);

                for (i = iprop + 1; i < cprop; i++)
                {
                    ULONG cbname2;

                    _PropertyNameLength(appvNames[i], &cbname2);

                    if (cbname == cbname2 &&
                        _ComparePropertyNames(
                            appvNames[iprop],
                            appvNames[i],
                            TRUE,   // Both names are the same endian
                            cbname,
                            pstatus))
                    {
                        break;
                    }
                    else if( !NT_SUCCESS(*pstatus) )
                        // There was an error in _ComparePropertyNames
                        goto Exit;
                }
            }

            // Silently ignore PID_ILLEGAL
            if( PID_ILLEGAL == apid[iprop] ) continue;

            // If this propid & name appears only once or if it's the last instance,
            // append the mapping entry.

            if (i == cprop)
            {
                ULONG cbname;

                // Set the PID & character-count fields for this entry.

                _PropertyNameLength(appvNames[iprop], &cbname);
                pent->propid = PropByteSwap( apid[iprop] );
                pent->cch = PropByteSwap( CB2CCh( cbname ));

                // Copy the name into the dictionary.
                RtlCopyMemory(pent->sz, appvNames[iprop], cbname);

                // If this is a Unicode property set, we need to correct
                // the byte-order.

                if( CP_WINUNICODE == _CodePage )
                {
                    PBSBuffer( pent->sz, cbname, sizeof(WCHAR) );
                }

                // Zero-out the pad bytes.

		RtlZeroMemory(
			Add2Ptr(pent->sz, cbname),
			DwordRemain((ULONG) (ULONG_PTR) pent->sz + cbname));

                // Move pent to the next available entry.

                pent = _NextDictionaryEntry( pent );
            }
        }   // for (iprop = 0; iprop < cprop; iprop++)

        // We've added all the names, now let's update the entry count.
        pdy->cEntries = PropByteSwap( PropByteSwap(pdy->cEntries) + cAdd );

    }   // if (appvNames != NULL)

    // Zero the possible partial DWORD at the end of the dictionary.

    {
        ULONG cb = (ULONG) ((BYTE *) pent - (BYTE *) pdy);
        PROPASSERT(DwordAlign(cb) == cbDictOldD + cbChangeD);
        RtlZeroMemory(pent, DwordRemain(cb));
    }


    //  -----------------------------------------------------
    //  Adjust the remaining property offsets in the section.
    //  -----------------------------------------------------

    PROPERTYIDOFFSET *ppo, *ppoMax;
    PROPERTYSECTIONHEADER *psh;

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Don't rely on the dictionary being the first property.
    // Skip PID_DICTIONARY and adjust every other higher entry.

    for ( ; ppo < ppoMax; ppo++)
    {
        if (ppo->dwOffset > oDictionary)
        {
            ppo->dwOffset += cbChangeD;
            PROPASSERT(ppo->propid != PID_DICTIONARY);
        }
    }

    // Update the size of the section

    psh->cbSection += cbChangeD;

    // Did the dictionary shrink overall?

    if (cbChangeD < 0)
    {
        // Yes, it shrunk.
        // Move everything after the dictionary forward by cbChangeD bytes.

        PropMoveMemory(
            "SetPropertyNames:TailUp",
            _GetSectionHeader(),
            Add2Ptr(pdy, cbDictOldD + cbChangeD),
            Add2Ptr(pdy, cbDictOldD),
            cbTail);
    }

    // If there's a section after this one in the property set,
    // update the section offsets in the property set header.

    if (_cbTail != 0)
    {
	_PatchSectionOffsets(cbChangeD);
    }

    // If we need to shrink the stream or if we are cleaning up after a
    // previous shrink that failed, do it last.

    if ( cbChangeD < 0 )
    {
        propDbg(( DEB_ITRACE,
            "SetSize(%x) dictionary shrink\n",
            cbstm + cbChangeD));

        _MSTM(SetSize)(cbstm + cbChangeD, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // If we had to convert the array of names into a different
    // codepage, delete those temporary buffers now.

    if (appvNames != NULL && appvNames != (VOID **) aposz)
    {
        for (iprop = 0; iprop < cprop; iprop++)
        {
            _pma->Free( appvNames[iprop] );
        }
        CoTaskMemFree( appvNames );
    }

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateStructure
//
// Synopsis:    validate property set structure
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateStructure(OUT NTSTATUS *pstatus)
{
    PROPID propid;
    ULONG cb;

    OLECHAR *poszName = NULL;

    *pstatus = STATUS_SUCCESS;

    // Walk through properties to make sure all properties are consistent
    // and are contained within the section size.  A NULL return value
    // means _LoadProperty walked the entire section, so we can quit then.

    for (propid = PID_CODEPAGE; propid != PID_ILLEGAL; propid++)
    {
        SERIALIZEDPROPERTYVALUE const *pprop;

        pprop = GetValue(propid, &cb, pstatus);
        if( STATUS_NOT_SUPPORTED == *pstatus )
            // We're working with an up-level property set
            *pstatus = STATUS_SUCCESS;
        else if( !NT_SUCCESS(*pstatus) )
        {
            goto Exit;
        }

        if (NULL == pprop)
        {
            break;
        }
    }

    // Walk through dictionary entries to make sure all entries are consistent
    // and are contained within the dictionary size.  A FALSE return value
    // means QueryPropertyNameBuf walked the entire dictionary, so quit then.

    for (propid = PID_CODEPAGE + 1; propid != PID_ILLEGAL; propid++)
    {
        BOOL fExists;

        fExists = QueryPropertyNames( 1, &propid, &poszName, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if( !fExists )
        {
            break;
        }
        else
        {
            _pma->Free( poszName );
            poszName = NULL;
        }
    }

    if (_cSection > 1)
    {
	FORMATIDOFFSET const *pfo;

	if (_cSection != 2)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: csection(%x) != 2",
		_cSection));
	    StatusCorruption(pstatus, "_ValidateStructure: csection != 2");
            goto Exit;
	}
	pfo = _GetFormatidOffset(0);
	if (pfo->fmtid != guidDocumentSummary)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: DocumentSummary[0] fmtid"));
	    StatusCorruption(pstatus, "_ValidateStructure: DocumentSummary[0] fmtid");
            goto Exit;
	}
	if (!IsDwordAligned(pfo->dwOffset))
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: dwOffset[0] = %x",
		pfo->dwOffset));
	    StatusCorruption(pstatus, "_ValidateStructure: dwOffset[0]");
            goto Exit;
	}

	pfo = _GetFormatidOffset(1);
	if (pfo->fmtid != guidDocumentSummarySection2)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: DocumentSummary[1] fmtid"));
	    StatusCorruption(pstatus, "_ValidateStructure: DocumentSummary[1] fmtid");
            goto Exit;
	}
	if (!IsDwordAligned(pfo->dwOffset))
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: dwOffset[1] = %x",
		pfo->dwOffset));
	    StatusCorruption(pstatus, "_ValidateStructure: dwOffset[1]");
            goto Exit;
	}
    }   // if (_cSection > 1)

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnPropidCompare
//
// Synopsis:    qsort helper to compare propids in a PROPERTYIDOFFSET array.
//
// Arguments:   [ppo1]          -- pointer to PROPERTYIDOFFSET 1
//              [ppo2]          -- pointer to PROPERTYIDOFFSET 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
int __cdecl
fnPropidCompare(VOID const *ppo1, VOID const *ppo2)
{
    return(((PROPERTYIDOFFSET const *) ppo1)->propid -
           ((PROPERTYIDOFFSET const *) ppo2)->propid);
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnOffsetCompare
//
// Synopsis:    qsort helper to compare offsets in a PROPERTYIDOFFSET array.
//
// Arguments:   [ppo1]          -- pointer to PROPERTYIDOFFSET 1
//              [ppo2]          -- pointer to PROPERTYIDOFFSET 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

int __cdecl
fnOffsetCompare(VOID const *ppo1, VOID const *ppo2)
{
    return(((PROPERTYIDOFFSET const *) ppo1)->dwOffset -
           ((PROPERTYIDOFFSET const *) ppo2)->dwOffset);
}


//+--------------------------------------------------------------------------
// Member:      GetStringLength
//
// Synopsis:    return length of possibly unicode string.
//
// Arguments:   [CodePage]   -- TRUE if string is Unicode
//              [pwsz]       -- pointer to string
//              [cb]         -- MAXULONG or string length with L'\0' or '\0'
//
// Returns:     length of string in bytes including trailing L'\0' or '\0'
//+--------------------------------------------------------------------------

ULONG
GetStringLength(
    IN USHORT CodePage,
    IN WCHAR const *pwsz,
    IN ULONG cb)
{
    ULONG i;

    if (CodePage == CP_WINUNICODE)
    {
        for (i = 0; i < cb/sizeof(WCHAR); i++)
        {
            if (pwsz[i] == L'\0')
            {
                break;
            }
        }
        PROPASSERT(cb == MAXULONG || cb == (i + 1) * sizeof(WCHAR));
        return((i + 1) * sizeof(WCHAR));
    }
    else
    {
        char *psz = (char *) pwsz;

        for (i = 0; i < cb; i++)
        {
            if (psz[i] == '\0')
            {
                break;
            }
        }
        PROPASSERT(cb == MAXULONG || cb == (i + 1) * sizeof(char));
        return((i + 1) * sizeof(char));
    }
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateProperties
//
// Synopsis:    validate properties
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateProperties(OUT NTSTATUS *pstatus) const
{
    PROPERTYIDOFFSET *apo = NULL;
    PROPERTYSECTIONHEADER const *psh = _GetSectionHeader();
    static ULONG cValidate = 0;
    ULONG cbwasted = 0;
    ULONG cbtotal = 0;

    *pstatus = STATUS_SUCCESS;

    cValidate++;
    DebugTrace(0, DEBTRACE_PROPVALIDATE, (
	"_ValidateProperties(%x ppsstm=%x state=%x pph=%x)\n",
	cValidate,
	this,
	_State,
	_pph));

    if (psh->cProperties != 0)
    {
        PROPERTYIDOFFSET *ppo, *ppoMax;

        apo = reinterpret_cast<PROPERTYIDOFFSET*>
              ( CoTaskMemAlloc( sizeof(PROPERTYIDOFFSET) * (psh->cProperties + 1) ));
        if (apo == NULL)
        {
            *pstatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        RtlCopyMemory(
                apo,
                psh->rgprop,
                psh->cProperties * CB_PROPERTYIDOFFSET);

        ppoMax = apo + psh->cProperties;
        ppoMax->propid = PID_ILLEGAL;
        ppoMax->dwOffset = psh->cbSection;

        // Sort by property id and check for duplicate propids:

        qsort(apo, psh->cProperties, sizeof(apo[0]), &fnPropidCompare);

        for (ppo = apo; ppo < ppoMax; ppo++)
        {
            if (ppo->propid == PID_ILLEGAL ||
                ppo->propid == ppo[1].propid)
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateProperties(bad propid=%x @%x)\n",
                    ppo->propid,
                    ppo->dwOffset));
                StatusCorruption(pstatus, "_ValidateProperties: bad or dup propid");
                goto Exit;
            }


        }

        // Sort by offset and check for overlapping values.

        qsort(apo, psh->cProperties, sizeof(apo[0]), &fnOffsetCompare);

        cbtotal = _oSection;
        for (ppo = apo; ppo < ppoMax; ppo++)
        {
            ULONG cbdiff;   // Size of a prop according to PROPID/Offset table
            ULONG cbpropraw;// Size of prop based on knowledge of the type
            ULONG cbprop;   // cbpropraw + padding for alignment

            SERIALIZEDPROPERTYVALUE const *pprop = NULL;

            cbprop = MAXULONG;
            cbpropraw = cbprop;
            cbdiff = ppo[1].dwOffset - ppo->dwOffset;

            if (IsDwordAligned(ppo->dwOffset) &&
                IsDwordAligned(ppo[1].dwOffset))
            {
                pprop = (SERIALIZEDPROPERTYVALUE const *)
                            _MapOffsetToAddress(ppo->dwOffset);

                if (ppo->propid == PID_DICTIONARY)
                {
                    cbprop = _DictionaryLength(
                                    (DICTIONARY const *) pprop,
                                    cbdiff,
                                    pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    cbpropraw = cbprop;
                    cbprop = DwordAlign(cbprop);
                }
                else
                {
                    cbprop = PropertyLengthNoEH(pprop, cbdiff, 0, pstatus);
                    if( STATUS_NOT_SUPPORTED == *pstatus )
                    {
                        // We're working with an up-level property set.
                        // Assume it's OK.
                        cbprop = cbdiff;
                        *pstatus = STATUS_SUCCESS;
                    }
                    else if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    cbpropraw = cbprop;
                }

                DebugTrace(0, DEBTRACE_PROPVALIDATE, (
                    "_ValidateProperties(%x) i=%x cb=%x/%x/%x @%x/%x pid=%x\n",
                    cValidate,
                    ppo - apo,
                    cbprop,
                    cbdiff,
                    ppo->dwOffset,
                    pprop,
                    ppo->propid));
                cbtotal += cbdiff;

                // As long as we're looking at the properties, let's check for
                // property types that require a minimum format version (wFormat).

                if( PID_DICTIONARY == ppo->propid )
                    ;   // pprop->dwType isn't actually a type for the dictionary property
                else
                if( PROPSET_WFORMAT_EXPANDED_VTS > GetFormatVersion()
                    &&
                    (
                      !IsOriginalPropVariantType( static_cast<VARTYPE>(PropByteSwap( pprop->dwType )))
                      ||
                      (VT_BYREF & PropByteSwap(pprop->dwType))
                    )
                  )
                {
                    DebugTrace(0, DEBTRACE_ERROR, (
                        "_ValidateProperties(bad value type: propid/vt=%x/%x @%x/%x cb=%x/%x/%x ppsstm=%x)\n",
                        ppo->propid, pprop->dwType,
                        ppo->dwOffset, pprop,
                        cbpropraw, cbprop, cbdiff,
                        this));
                    StatusCorruption(pstatus, "_ValidateProperties: bad property type");
                    goto Exit;
                }

                // Technically, the OLE spec allows extra unused space
                // between properties, but this implementation never
                // writes out streams with space between properties.

                if( cbdiff == cbprop )
                {
                    continue;
                }
            }
            DebugTrace(0, DEBTRACE_ERROR, (
                "_ValidateProperties(bad value length: propid=%x @%x/%x cb=%x/%x/%x ppsstm=%x)\n",
                ppo->propid,
                ppo->dwOffset, pprop,
                cbpropraw, cbprop, cbdiff,
                this));
            StatusCorruption(pstatus, "_ValidateProperties: bad property length");
            goto Exit;

        }   // for (ppo = apo; ppo < ppoMax; ppo++)

    }   // if (psh->cProperties != 0)

    //  ----
    //  Exit
    //  ----

Exit:

    CoTaskMemFree( apo );

    DebugTrace(0, cbwasted != 0? 0 : Dbg, (
        "_ValidateProperties(wasted %x bytes, total=%x)\n",
        cbwasted,
        cbtotal));

}
#endif


#if DBGPROP
typedef struct tagENTRYVALIDATE         // ev
{
    ENTRY UNALIGNED const *pent;
    CPropertySetStream const *ppsstm;
} ENTRYVALIDATE;
#endif


//+--------------------------------------------------------------------------
// Member:      fnEntryPropidCompare
//
// Synopsis:    qsort helper to compare propids in a ENTRYVALIDATE array.
//
// Arguments:   [pev1]          -- pointer to ENTRYVALIDATE 1
//              [pev2]          -- pointer to ENTRYVALIDATE 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
int __cdecl
fnEntryPropidCompare(VOID const *pev1, VOID const *pev2)
{
    return(((ENTRYVALIDATE const *) pev1)->pent->propid -
           ((ENTRYVALIDATE const *) pev2)->pent->propid);
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnEntryNameCompare
//
// Synopsis:    qsort helper to compare names in a ENTRYVALIDATE array.
//
// Arguments:   [pev1]          -- pointer to ENTRYVALIDATE 1
//              [pev2]          -- pointer to ENTRYVALIDATE 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
int __cdecl
fnEntryNameCompare(VOID const *pev1, VOID const *pev2)
{
    ENTRY UNALIGNED const *pent1;
    ENTRY UNALIGNED const *pent2;
    INT rc;
    NTSTATUS Status = STATUS_SUCCESS;

    pent1 = ((ENTRYVALIDATE const *) pev1)->pent;
    pent2 = ((ENTRYVALIDATE const *) pev2)->pent;

    rc = PropByteSwap(pent1->cch) - PropByteSwap(pent2->cch);
    if (rc == 0)
    {
        rc = !((ENTRYVALIDATE const *) pev1)->ppsstm->_ComparePropertyNames(
                    pent1->sz,
                    pent2->sz,
                    TRUE,       // Both names have the same byte-order
                    ( (ENTRYVALIDATE const *)
                      pev1
                    )->ppsstm->CCh2CB(PropByteSwap( pent1->cch )),
                    &Status );
    }
    return(rc);
}
#endif


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateDictionary
//
// Synopsis:    validate property set dictionary
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateDictionary(OUT NTSTATUS *pstatus)
{
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!

    ENTRYVALIDATE *aev = NULL;
    ENTRYVALIDATE *pev, *pevMax;
    PROPERTYSECTIONHEADER const *psh;
    ENTRY UNALIGNED const *pent;
    ENTRY entMax;
    VOID const *pvDictEnd;

    *pstatus = STATUS_SUCCESS;

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (pdy != NULL && PropByteSwap(pdy->cEntries) != 0)
    {
        aev = reinterpret_cast<ENTRYVALIDATE*>
              ( CoTaskMemAlloc( sizeof(ENTRYVALIDATE) * (PropByteSwap(pdy->cEntries) + 1) ));
        if (aev == NULL)
        {
            *pstatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        psh = _GetSectionHeader();
        pent = pdy->rgEntry;
        pvDictEnd = Add2ConstPtr(pdy, cbDict);
        pevMax = aev + PropByteSwap( pdy->cEntries );

        for (pev = aev; pev < pevMax; pev++)
        {
            ULONG cb = _DictionaryEntryLength( pent );

            // If the cb is greater than the max allowed in original
            // property sets (after allowing for padding and per-entry
            // overhead), then check the wFormat field in the header.

            if( CB2CCh(cb) > CCH_MAXPROPNAME + CB_DICTIONARY_ENTRY + sizeof(DWORD) )
            {
                if( PROPSET_WFORMAT_LONG_NAMES > GetFormatVersion() )
                {
                    StatusCorruption(pstatus, "ValidateDictionary:  entry size too big for wFormat");
                    goto Exit;
                }
            }

            if (Add2ConstPtr(pent, cb) > pvDictEnd)
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad entry size for propid=%x)\n",
                    PropByteSwap( pev->pent->propid )));
                StatusCorruption(pstatus, "ValidateDictionary: entry size");
                goto Exit;
            }
            pev->pent = pent;
            pev->ppsstm = this;

#ifdef LITTLEENDIAN
            if (_CodePage == CP_WINUNICODE)
            {
                PROPASSERT(IsUnicodeString((WCHAR const *) pent->sz,
                                            CCh2CB(PropByteSwap( pent->cch ))));
            }
            else
            {
                PROPASSERT(IsAnsiString((char const *) pent->sz,
                                        CCh2CB( PropByteSwap( pent->cch ))));
            }
#endif

            pent = _NextDictionaryEntry( pent );
        }
        if ((VOID const *) pent != pvDictEnd)
        {
            StatusCorruption(pstatus, "ValidateDictionary: end offset");
            goto Exit;
        }
        entMax.cch = 0;
        entMax.propid = PID_ILLEGAL;
        pevMax->pent = &entMax;
        pevMax->ppsstm = this;

        // Sort by property id and check for duplicate propids:

        qsort(aev, PropByteSwap(pdy->cEntries), sizeof(aev[0]), &fnEntryPropidCompare);

        for (pev = aev; pev < pevMax; pev++)
        {
            if (PID_ILLEGAL == PropByteSwap(pev->pent->propid)
                ||
                pev[1].pent->propid == pev->pent->propid)
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad propid=%x)\n",
                    PropByteSwap( pev->pent->propid )));
                StatusCorruption(pstatus, "_ValidateDictionary: bad or dup propid");
                goto Exit;
            }
        }

        // Sort by property name and check for duplicate names:

        qsort(aev, PropByteSwap(pdy->cEntries), sizeof(aev[0]), &fnEntryNameCompare);

        for (pev = aev; pev < pevMax; pev++)
        {
            if (pev->pent->cch == 0
                ||
                ( pev->pent->cch == pev[1].pent->cch
                  &&
                  _ComparePropertyNames(
                         pev->pent->sz,
                         pev[1].pent->sz,
                         TRUE,              // Names are the same byte-order
                         CCh2CB(PropByteSwap(pev->pent->cch)),
                         pstatus)
                )
               )
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad name for propid=%x)\n",
                    PropByteSwap( pev->pent->propid )));
                StatusCorruption(pstatus, "_ValidateDictionary: bad or dup name");
                goto Exit;
            }
            else if( !NT_SUCCESS(*pstatus) )
                // There was an error in _ComparePropertyNames
                goto Exit;

        }   // for (pev = aev; pev < pevMax; pev++)
    }   // if (pdy != NULL && pdy->cEntries != 0)

    //  ----
    //  Exit
    //  ----

Exit:

    CoTaskMemFree( aev );

}
#endif  // DBGPROP


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Validate
//
// Synopsis:    validate entire property stream
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP

extern "C" BOOLEAN fValidatePropSets = KERNELSELECT(DBG, TRUE);

VOID
CPropertySetStream::Validate(OUT NTSTATUS *pstatus)
{
    if (fValidatePropSets && (_State & CPSS_USERDEFINEDDELETED) == 0)
    {
        ULONG cbstm = _MSTM(GetSize)(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Walk through section headers to make sure all sections are contained
        // within the stream size.

        if (_ComputeMinimumSize(cbstm, pstatus) != 0)
        {
            // If an error had occurred in the above call,
            // it would have returned zero.

            _ValidateStructure( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ValidateProperties( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ValidateDictionary( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ComputeMinimumSize(cbstm, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }
    }   // if (fValidatePropSets && (_State & CPSS_USERDEFINEDDELETED) == 0)

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}
#endif


//+--------------------------------------------------------------------------
// Function:    CopyPropertyValue
//
// Synopsis:    copy a property value into a supplied buffer
//
// Arguments:   [pprop]         -- property value (possibly NULL)
//              [cb]            -- property length
//              [ppropDst]      -- output buffer for property value
//              [pcb]           -- length of buffer (in); actual length (out)
//
// Returns:     None
//---------------------------------------------------------------------------

#ifdef WINNT
VOID
CopyPropertyValue(
    IN OPTIONAL SERIALIZEDPROPERTYVALUE const *pprop,
    IN ULONG cb,
    OUT SERIALIZEDPROPERTYVALUE *ppropDst,
    OUT ULONG *pcb)
{
#if DBG==1
    NTSTATUS Status;
#endif

    if (pprop == NULL)
    {
        static SERIALIZEDPROPERTYVALUE prop = { VT_EMPTY, };

        pprop = &prop;
        cb = CB_SERIALIZEDPROPERTYVALUE;
    }
    PROPASSERT(cb == PropertyLengthNoEH(pprop, cb, 0, &Status)
               &&
               NT_SUCCESS(Status) );

    RtlCopyMemory(ppropDst, pprop, min(cb, *pcb));
    *pcb = cb;
}
#endif  // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\ssmapstm.cxx ===
//+============================================================================
//
//  File:       SSMapStm.cxx
//
//  Purpose:    This file defines the CSSMappedStream class.
//              This class provdes a IMappedStream implementation
//              which maps an IStream from a Compound File.
//
//  History:
//
//      5/6/98  MikeHill
//              -   Use CoTaskMem rather than new/delete.
//
//+============================================================================

//  --------
//  Includes
//  --------

#include <pch.cxx>
#include "SSMapStm.hxx"

#include <privguid.h>       // IID_IMappedStream

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif


//+----------------------------------------------------------------------------
//
//  Method:     CSSMappedStream::Initialize
//
//  Synopsis:   Zero-out all of the member data.
//
//  Arguments:  None
//
//  Returns:    None
//
//
//+----------------------------------------------------------------------------

VOID
CSSMappedStream::Initialize()
{
    propDbg(( DEB_ITRACE, "CSSMappedStream::Initialize\n" ));

    _pstm = NULL;
    _pbMappedStream = NULL;
    _cbMappedStream = 0;
    _cbActualStreamSize = 0;
    _powner = NULL;
    _fLowMem = FALSE;
    _fDirty = FALSE;

#if DBGPROP
    _fChangePending = FALSE;
#endif

}   // CSSMappedStream::Initialize()


//+----------------------------------------------------------------------------
//
//  Member:     Constructor/Destructor
//
//  Synopsis:   Initialize/cleanup this object.
//
//+----------------------------------------------------------------------------

CSSMappedStream::CSSMappedStream( IStream *pstm )
{
    DfpAssert( NULL != pstm );

    // Initialize the member data.
    Initialize();

    // Keep a copy of the Stream that we're mapping.
    _pstm = pstm;
    _pstm->AddRef();
    _cRefs = 1;
}


CSSMappedStream::~CSSMappedStream( )
{
    // Just to be safe, free the mapping buffer (it should have
    // already been freed).

    DfpAssert( NULL == _pbMappedStream );
    CoTaskMemFree( _pbMappedStream );

    // If we've got the global reserved buffer locked,
    // free it now.

    if (_fLowMem)
    {
        g_ReservedMemory.UnlockMemory();
    }

    // Free the stream which we were mapping.

    if( NULL != _pstm )
        _pstm->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown members
//
//--------------------------------------------------------------------

HRESULT CSSMappedStream::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr = S_OK;

    // Validate the inputs

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----------------
    //  Perform the Query
    //  -----------------

    *ppvObject = NULL;

    if (IsEqualIID(riid,IID_IMappedStream) || IsEqualIID(riid,IID_IUnknown))
    {
        *ppvObject = (IMappedStream *)this;
        CSSMappedStream::AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return(hr);
}

ULONG   CSSMappedStream::AddRef(void)
{
    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

ULONG   CSSMappedStream::Release(void)
{
    LONG lRet;

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSSMappedStream::Open
//
//  Synopsis:   Open up the Stream which we're mapping, and
//              read it's data into a buffer.
//
//  Arguments:  [VOID*] powner
//                  The owner of this Stream.  We use this for the
//                  PrOnMappedStreamEvent call.
//              [HRESULT*] phr
//                  The return code.
//
//  Returns:    Nothing.
//
//+----------------------------------------------------------------------------


VOID
CSSMappedStream::Open( IN VOID     *powner,
                       OUT HRESULT *phr )
{
    HRESULT &hr = *phr;
    VOID *pv = NULL;
    DfpAssert(!_fLowMem);

    hr = S_OK;
    propITrace( "CSSMappedStream::Open" );

    // If given a pointer to the owner of this mapped stream,
    // save it.  This could be NULL (i.e., when called from
    // ReOpen).

    if( NULL != powner  )
        _powner = powner;

    // If we haven't already read the stream, read it now.

    if( NULL == _pbMappedStream )
    {
        STATSTG statstg;
        LARGE_INTEGER liSeek;

        DfpAssert( NULL != _pstm );
        DfpAssert( 0 == _cbMappedStream );
        DfpAssert( 0 == _cbActualStreamSize );

        // Get and validate the size of the Stream.

        *phr = _pstm->Stat( &statstg, STATFLAG_NONAME );
        if( FAILED(*phr) ) goto Exit;

        if( statstg.cbSize.HighPart != 0
            ||
            statstg.cbSize.LowPart > CBMAXPROPSETSTREAM )
        {
            *phr = STG_E_INVALIDHEADER;
            goto Exit;
        }
        _cbMappedStream = _cbActualStreamSize = statstg.cbSize.LowPart;

        // Allocate a buffer to hold the Stream.  If there isn't sufficient
        // memory in the system, lock and get the reserved buffer.  In the
        // end, 'pv' points to the appropriate buffer.

        pv = CoTaskMemAlloc( _cbActualStreamSize );

        if (pv == NULL)
        {
            pv = g_ReservedMemory.LockMemory();   // could wait until previous
                                                  // property call completes
            _fLowMem = TRUE;
        }
        _pbMappedStream = (BYTE*) pv;

        // Seek to the start of the Stream.

        liSeek.HighPart = 0;
        liSeek.LowPart = 0;
        *phr = _pstm->Seek( liSeek, STREAM_SEEK_SET, NULL );
        if( FAILED(*phr) ) goto Exit;

        // Read in the Stream.  But only if it is non-zero; some
        // stream implementations (namely the Mac StreamOnHGlobal imp)
        // don't allow 0-length reads.

        if( 0 != _cbActualStreamSize )
        {
            *phr = _pstm->Read(
                          _pbMappedStream,
                          _cbActualStreamSize,
                          &_cbMappedStream);
            if( FAILED(*phr) ) goto Exit;

            // Ensure that we got all the bytes we requested.

            if( _cbMappedStream != _cbActualStreamSize )
            {
                propDbg((DEBTRACE_ERROR,
                         "CSSMappedStream(%08X)::Open bytes-read (%lu) doesn't match bytes-requested (%lu)\n",
                         this, _cbMappedStream, _cbActualStreamSize ));
                *phr = STG_E_INVALIDHEADER;
                goto Exit;
            }
        }


#if BIGENDIAN==1
        // Notify our owner that we've read in new data.

        if( _powner != NULL && 0 != _cbMappedStream )
        {
            *phr = PrOnMappedStreamEvent( _powner, _pbMappedStream, _cbMappedStream );
            if( FAILED(*phr) ) goto Exit;
        }
#endif

    }   // if( NULL == _pbMappedStream )

    //  ----
    //  Exit
    //  ----

Exit:

    // If there was an error, free any memory we have.

    if( FAILED(*phr) )
    {
        propDbg((DEB_ERROR, "CSSMappedStream(%08X):Open exception returns %08X\n", this, *phr));

        if (_fLowMem)
            g_ReservedMemory.UnlockMemory();
        else
            CoTaskMemFree( pv );

        _pbMappedStream = NULL;
        _cbMappedStream = 0;
        _cbActualStreamSize = 0;
        _fLowMem = FALSE;
    }

    return;

}   // CSSMappedStream::Open


//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Flush
//
//  Synopsis:   Write out the mapping buffer to the Stream,
//              and Commit it.
//
//  Arguments:  [LONG*] phr
//                  An HRESULT return code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::Flush(OUT LONG *phr)
{

    HRESULT &hr = *phr;
    propITrace( "CSSMappedStream::Flush" );

    // Write out any data we have cached to the Stream.
    hr = Write();

    // Commit the Stream.
    if( SUCCEEDED(hr) )
    {
        hr = _pstm->Commit(STGC_DEFAULT);
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Close
//
//  Synopsis:   Close the mapped stream by writing out
//              the mapping buffer and then freeing it.
//
//  Arguments:  [LONG*] phr
//                  An HRESULT error code.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::Close(OUT LONG *phr)
{
    // Write the changes.  We don't need to Commit them,
    // they will be implicitely committed when the
    // Stream is Released.

    HRESULT &hr = *phr;
    propITrace( "CSSMappedStream::Close" );

    hr = Write();

    // Even if we fail the write, we must free the memory.
    // (PrClosePropertySet deletes everything whether or not
    // there was an error here, so we must free the memory.
    // There's no danger of this happenning due to out-of-
    // disk-space conditions, because the propset code
    // pre-allocates).

    CoTaskMemFree( _pbMappedStream );
    _pstm->Release();

    // Re-zero the member data.
    Initialize();

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::ReOpen
//
//  Synopsis:   Gets the caller a pointer to the already-opened
//              mapping buffer.  If it isn't already opened, then
//              it is opened here.
//
//  Arguments:  [VOID**] ppv
//                  Used to return the mapping buffer.
//              [LONG*] phr
//                  Used to return an HRESULT.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::ReOpen(IN OUT VOID **ppv, OUT LONG *phr)
{
    *ppv = NULL;

    Open(NULL,  // Unspecified owner.
         phr);

    if( SUCCEEDED(*phr) )
        *ppv = _pbMappedStream;

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Quiesce
//
//  Synopsis:   Unnecessary for this IMappedStream implementation.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::Quiesce(VOID)
{
    DfpAssert(_pbMappedStream != NULL);
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Map
//
//  Synopsis:   Used to get a pointer to the current mapping.
//
//  Arguments:  [BOOLEAN] fCreate
//                  Not used by this IMappedStream implementation.
//              [VOID**] ppv
//                  Used to return the mapping buffer.
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::Map(BOOLEAN fCreate, VOID **ppv)
{
    DfpAssert(_pbMappedStream != NULL);
    *ppv = _pbMappedStream;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Unmap
//
//  Synopsis:   Unnecessary for this IMappedStream implementation.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::Unmap(BOOLEAN fFlush, VOID **ppv)
{
    *ppv = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Write
//
//  Synopsis:   Writes the mapping buffer out to the original
//              Stream.
//
//  Arguments:  None.
//
//  Returns:    [HRESULT]
//                  S_FALSE => Nothing needed to be written
//
//--------------------------------------------------------------------
#define STACK_BYTES 16

HRESULT CSSMappedStream::Write ()
{
    HRESULT hr;
    ULONG cbWritten;
    LARGE_INTEGER liSeek;
    BOOL fOwnerSignaled = FALSE;

    propITrace( "CSSMappedStream::Write" );

    // We can return right away if there's nothing to write.
    // (_pbMappedStream may be NULL in the error path of our
    // caller).

    if (!_fDirty || NULL == _pbMappedStream )
    {
        propDbg((DEB_PROP_INFO, "CPubStream(%08X):Flush returns with not-dirty\n", this));

        return S_FALSE;
    }

    DfpAssert( _pstm != NULL );

#if BIGENDIAN==1
    // Notify our owner that we're about to perform a Write.
    // Note that there are no goto Exit calls prior to this point, because
    // we making a corresponding call to PrOnMappedStreamEvent (for byte-swapping)
    // in the Exit.
    hr = PrOnMappedStreamEvent( _powner, _pbMappedStream, _cbMappedStream );
    if( S_OK != hr ) goto Exit;
    fOwnerSignaled = TRUE;
#endif

    // Seek to the start of the Stream.
    liSeek.HighPart = 0;
    liSeek.LowPart = 0;
    hr = _pstm->Seek( liSeek, STREAM_SEEK_SET, NULL );
    if( FAILED(hr) ) goto Exit;

    // Write out the mapping buffer.
    hr = _pstm->Write(_pbMappedStream, _cbMappedStream, &cbWritten);
    if( S_OK != hr ) goto Exit;
    if( cbWritten != _cbMappedStream )
    {
        propDbg((DEB_ERROR,
                 "CSSMappedStream(%08X)::Write bytes-written (%lu) doesn't match bytes-requested (%lu)\n",
                 this, cbWritten, _cbMappedStream ));
        hr = STG_E_INVALIDHEADER;
        goto Exit;
    }

    // If the buffer is shrinking, this is a good time to shrink the Stream.
    if (_cbMappedStream < _cbActualStreamSize)
    {
        ULARGE_INTEGER uli;
        uli.HighPart = 0;
        uli.LowPart = _cbMappedStream;

        hr = _pstm->SetSize(uli);
        if( S_OK == hr )
        {
            _cbActualStreamSize = _cbMappedStream;
        }
    }

    //
    // If we changed the buffer size and it is less than the
    // actual underlying stream, then we need to zero out the memory
    // above the currrent size.
    //
    if (_cbMappedStream < _cbActualStreamSize)
    {
        PBYTE           pTemp;
        LARGE_INTEGER   li;
        DWORD           cbWrite = _cbActualStreamSize - _cbMappedStream;

        li.HighPart = 0;
        li.LowPart = _cbMappedStream;
        hr = _pstm->Seek(li,STREAM_SEEK_SET,NULL);
        if (SUCCEEDED(hr))
        {
            pTemp = reinterpret_cast<PBYTE>( CoTaskMemAlloc( cbWrite ));
            if (pTemp != NULL)
            {
                memset(pTemp,0,cbWrite);
                //
                // Successfully allocated memory for the write.  Write the
                // zeros out all at once.
                //
                hr = _pstm->Write(pTemp, cbWrite, NULL);
                if (FAILED(hr))
                {
                    propDbg((DEB_ERROR, "CSSMappedStream::Write "
                        "write failure\n",hr));
                    goto Exit;
                }
                CoTaskMemFree( pTemp );
            }
            else
            {
                //
                // We couldn't allocate memory.  So we will use a small
                // stack buffer instead.
                //
                BYTE   stackBuf[STACK_BYTES];
                memset(stackBuf, 0, STACK_BYTES);

                while (cbWrite >= STACK_BYTES)
                {
                    hr = _pstm->Write(stackBuf, STACK_BYTES, NULL);
                    if (FAILED(hr))
                    {
                        propDbg((DEB_ERROR, "CSSMappedStream::Write write failure\n",hr));
                        goto Exit;
                    }
                    cbWrite -= STACK_BYTES;
                }

                if (cbWrite < STACK_BYTES)
                {
                    hr = _pstm->Write(stackBuf, cbWrite, NULL);
                    if (FAILED(hr))
                    {
                        propDbg((DEB_ERROR, "CSSMappedStream::Write write failure\n",hr));
                        goto Exit;
                    }
                }
            }
        }
        else
        {
            propDbg((DEB_ERROR, "CSSMappedStream::Write seek failure\n",hr));
            goto Exit;
        }
    }
    //  ----
    //  Exit
    //  ----

Exit:

    // Notify our owner that we're done with the Write.  We do this
    // whether or not there was an error, because _pbMappedStream is
    // not modified, and therefore intact even in the error path.
    // This call allows the owner to correct the byte-order of the header.

#if BIGENDIAN==1
    if( fOwnerSignaled )
        DfpVerify( PrOnMappedStreamEvent( _powner, _pbMappedStream, _cbMappedStream ));
#endif

    if (hr == S_OK || hr == STG_E_REVERTED)
    {
        _fDirty = FALSE;
    }

    return hr;

}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::GetSize
//
//  Synopsis:   Returns the current size of the mapped stream.
//
//  Arguments:  [LONG*] phr
//                  Used to return an HRESULT.
//
//  Returns:    [ULONG]
//                  The current size.
//
//--------------------------------------------------------------------

ULONG CSSMappedStream::GetSize(OUT LONG *phr)
{
    HRESULT &hr = *phr;
    hr = S_OK;

    propITrace( "CSSMappedStream::GetSize" );

    // If necessary, open the Stream.

    if( NULL == _pbMappedStream )
    {
        Open(NULL,  // Unspecified owner
             phr);
    }

    if( SUCCEEDED(*phr) )
    {
        DfpAssert( NULL != _pbMappedStream );
    }

    // Return the size of the mapped stream.  If there was an
    // Open error, it will be zero, and *phr will be set.

    propDbg(( DEB_ITRACE, "CSSMappedStream::GetSize, size is %d\n", _cbMappedStream ));
    return _cbMappedStream;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::SetSize
//
//  Synopsis:   Set the size of the mapped stream.
//
//  Arguments:  [ULONG] cb
//                  The new size.
//              [BOOLEAN] fPersistent
//                  If not set, then this change will not be stored -
//                  thus the mapping buffer must be set, but the
//                  Stream itself must not.  This was added so that
//                  CPropertySetStream could grow the buffer for internal
//                  processing, when the Stream itself is read-only.
//              [VOID**] ppv
//                  Used to return the new mapping buffer location.
//
//  Returns:    None.
//
//  Pre-Conditions:
//              cb is below the maximum property set size.
//
//--------------------------------------------------------------------

VOID
CSSMappedStream::SetSize(ULONG cb,
                         IN BOOLEAN fPersistent,
                         VOID **ppv, OUT LONG *phr)
{
    BYTE            *pv;

    HRESULT &hr = *phr;

    hr = S_OK;
    DfpAssert(cb != 0);
    DfpAssert(cb <= CBMAXPROPSETSTREAM);

    propITrace( "CSSMappedStream::SetSize" );
    propTraceParameters(( "cb=%lu, fPersistent=%s, ppv=%p", cb, fPersistent?"True":"False" ));

    //
    // if we are growing the data, we should grow the stream
    //
    if (fPersistent && cb > _cbActualStreamSize)
    {
        ULARGE_INTEGER  uli;
        uli.HighPart = 0;
        uli.LowPart = cb;

        //----------------
        // Need to Grow!
        //----------------

        propDbg(( DEB_ITRACE, "Growing from %d to %d\n", _cbActualStreamSize, cb ));
        *phr = _pstm->SetSize( uli );

        if (FAILED(*phr) )
            goto Exit;
        else
            _cbActualStreamSize = cb;
    }

    //
    // We only get here if we either (1) didn't want to grow the
    // underlying stream, or (2) we successfully grew the underlying stream.
    //

    //
    // Re-size the buffer to the size specified in cb.
    //
    if ( _fLowMem )
    {
        // If we want to grow the buffer In low-memory conditions,
        // no realloc is necessary, because
        // _pbMappedStream is already large enough for the largest
        // property set.

        *ppv = _pbMappedStream;
    }
    else if ( cb != _cbMappedStream )
    {

            // We must re-alloc the buffer.

            pv = reinterpret_cast<BYTE*>( CoTaskMemAlloc( cb ));

            if ((pv == NULL) )
            {
                // allocation failed: we need to try using a backup mechanism for
                // more memory.
                // copy the data to the global reserved chunk... we will wait until
                // someone else has released it.  it will be released on the way out
                // of the property code.

                _fLowMem = TRUE;
                pv = g_ReservedMemory.LockMemory();
                if ( NULL == pv)
                {
                    *phr = E_OUTOFMEMORY;
                    goto Exit;
                }
                else if( NULL != _pbMappedStream)
                {
                    memcpy( pv, _pbMappedStream, min(cb,_cbMappedStream) );
                }
                CoTaskMemFree( _pbMappedStream );
            }
            else
            {
                memcpy( pv, _pbMappedStream, min(cb,_cbMappedStream) );
                CoTaskMemFree( _pbMappedStream );
            }

            _pbMappedStream = pv;
            *ppv = pv;
    }
    _cbMappedStream = cb;

    //  ----
    //  Exit
    //  ----

Exit:

    propDbg((DbgFlag(*phr,DEB_TRACE), "CSSMappedStream(%08X):SetSize %s returns hr=%08X\n",
                                    this, *phr != S_OK ? "exception" : "", *phr));

}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Lock
//
//  Synopsis:   Locking is not supported by this class.
//
//--------------------------------------------------------------------

NTSTATUS CSSMappedStream::Lock(BOOLEAN fExclusive)
{
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::Unlock
//
//  Synopsis:   Locking is not supported by this class.
//              However, this method still must check to
//              see if the reserved memory pool should be
//              freed for use by another property set.
//
//--------------------------------------------------------------------

NTSTATUS CSSMappedStream::Unlock(VOID)
{
    // if at the end of the properties set/get call we have the low
    // memory region locked, we flush to disk.
    HRESULT hr = S_OK;

    if (_fLowMem)
    {
        Flush(&hr);

        g_ReservedMemory.UnlockMemory();
        _pbMappedStream = NULL;
        _cbMappedStream = 0;
        _fLowMem = FALSE;
        propDbg((DEB_ERROR, "CPubStream(%08X):Unlock low-mem returns NTSTATUS=%08X\n",
            this, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::QueryTimeStamps
//
//  Synopsis:   Not used by this IMappedStream derivation.
//
//--------------------------------------------------------------------

VOID CSSMappedStream::QueryTimeStamps(STATPROPSETSTG *pspss, BOOLEAN fNonSimple) const
{
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::QueryModifyTime
//
//  Synopsis:   Not used by this IMappedStream derivation.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CSSMappedStream::QueryModifyTime(OUT LONGLONG *pll) const
{
    return(FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     Unused methods by this IMappedStream implementation:
//              QuerySecurity, IsWritable, GetHandle
//
//--------------------------------------------------------------------

BOOLEAN CSSMappedStream::QuerySecurity(OUT ULONG *pul) const
{
    return(FALSE);
}

BOOLEAN CSSMappedStream::IsWriteable() const
{
    return TRUE;
}

HANDLE CSSMappedStream::GetHandle(VOID) const
{
    return(INVALID_HANDLE_VALUE);
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::SetModified/IsModified
//
//--------------------------------------------------------------------

VOID CSSMappedStream::SetModified(OUT LONG *phr)
{
    _fDirty = TRUE;
    *phr = S_OK;
}

BOOLEAN CSSMappedStream::IsModified(VOID) const
{
    propDbg(( DEB_ITRACE, "CSSMappedStream::IsModified (%s)\n", _fDirty?"TRUE":"FALSE" ));
    return (BOOLEAN) _fDirty;
}

//+-------------------------------------------------------------------
//
//  Member:     CSSMappedStream::IsNtMappedStream/SetChangePending
//
//  Synopsis:   Debug routines.
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN CSSMappedStream::IsNtMappedStream(VOID) const
{
    return(FALSE);
}
#endif


#if DBGPROP
BOOLEAN CSSMappedStream::SetChangePending(BOOLEAN f)
{
    BOOL fOld = _fChangePending;
    _fChangePending = f;
    return((BOOLEAN)_fChangePending);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\stgvarb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       StgVarB.cxx
//
//  Contents:   C++ Base wrapper for PROPVARIANT.
//
//  History:    01-Aug-94 KyleP     Created
//              31-Jul-96 MikeHill  - Relaxed assert in IsUnicodeString.
//                                  - Allow NULL strings.
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include "debtrace.hxx"
#include <propset.h>
#include <propvar.h>

// These optionally-compiled directives tell the compiler & debugger
// where the real file, rather than the copy, is located.
#ifdef _ORIG_FILE_LOCATION_
#if __LINE__ != 25
#error File heading has change size
#else
#line 29 "\\nt\\private\\dcomidl\\stgvarb.cxx"
#endif
#endif

#if DBGPROP

BOOLEAN
IsUnicodeString(WCHAR const *pwszname, ULONG cb)
{
    if (cb != 0)
    {
	for (ULONG i = 0; pwszname[i] != L'\0'; i++)
	{
	}
        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.

        PROPASSERT(cb == MAXULONG || (i + 1) * sizeof(WCHAR) <= cb);
    }
    return(TRUE);
}


BOOLEAN
IsAnsiString(CHAR const *pszname, ULONG cb)
{
    if (cb != 0)
    {
        // If the string is NULL, then it's not not an Ansi string,
        // so we'll call it an Ansi string.

        if( NULL == pszname )
            return( TRUE );

	for (ULONG i = 0; pszname[i] != '\0'; i++)
	{
	}
        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.

	PROPASSERT(cb == MAXULONG || i + 1 <= cb);
    }
    return(TRUE);
}
#endif



#endif //ifdef WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utils.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       utils.cxx
//
//  Contents:   Utility classes/functions for property implementation.
//
//  Classes:    CPropSetName -- wraps buffer and conversion of fmtids
//              CStackBuffer -- utility class that allows a small number
//                              of items be on stack, but more be on heap.
//
//  Functions:  PropVariantClear
//              FreePropVariantArray
//              AllocAndCopy
//              PropVariantCopy
//
//  History:    1-Mar-95   BillMo      Created.
//             22-Feb-96   MikeHill    Removed an over-active assert.
//             22-May-96   MikeHill    Handle "unmappable character" in
//                                     NtStatusToScode.
//             12-Jun-96   MikeHill    - Added PropSysAllocString and PropSysFreeString.
//                                     - Added VT_I1 support (under ifdef)
//                                     - Fix PropVarCopy where the input VT_CF
//                                       has a zero size but a non-NULL pClipData.
//             29-Jul-96   MikeHill    - PropSet names:  WCHAR => OLECHAR
//                                     - Bug in PropVarCopy of 0-length VT_BLOB
//                                     - Support VT_BSTR_BLOB types (used in IProp.dll)
//             10-Mar-98   MikeHIll    Support Variant types in PropVariantCopy/Clear
//             06-May-98   MikeHill    - Use CoTaskMem rather than new/delete.
//                                     - Removed unused PropSysAlloc/FreeString.
//                                     - Support VT_VECTOR|VT_I1.
//                                     - Removed UnicodeCallouts support.
//                                     - Use oleaut32.dll wrappers, don't call directly.
//     5/18/98  MikeHill
//              -   Moved IsOriginalPropVariantType from utils.hxx.
//              -   Added IsVariantType.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#include <privoa.h>     // Private OleAut32 wrappers

#ifdef _MAC_NODOC
ASSERTDATA  // File-specific data for FnAssert
#endif

//+-------------------------------------------------------------------
//
//  Member:     CPropSetName::CPropSetName
//
//  Synopsis:   Initialize internal buffer with converted FMTID
//
//  Arguments:  [rfmtid] -- FMTID to convert
//
//--------------------------------------------------------------------

CPropSetName::CPropSetName(REFFMTID rfmtid)
{
    PrGuidToPropertySetName(&rfmtid, _oszName);
}

//+-------------------------------------------------------------------
//
//  Member:     CStackBuffer::Init
//
//  Synopsis:   Determine whether the class derived from this one
//              needs to have additional buffer allocated on the
//              heap and allocate it if neccessary.  Otherwise, if
//              there is space, use the internal buffer in the
//              derived class.
//
//  Arguments:  [cElements] -- the number of elements required.
//
//  Returns:    S_OK if buffer available
//              STG_E_INSUFFICIENTMEMORY if stack buffer was not
//                  big enough AND heap allocation failed.
//
//  Notes:      To be called directly by client after the derived
//              classes constructor initialized CStackBuffer.
//
//--------------------------------------------------------------------

HRESULT CStackBuffer::Init(ULONG cElements)
{
    if (cElements > _cElements)
    {
        _pbHeapBuf = reinterpret_cast<BYTE*>( CoTaskMemAlloc( cElements * _cbElement ));
        if (_pbHeapBuf == NULL)
        {
            return(STG_E_INSUFFICIENTMEMORY);
        }
        _cElements = cElements;
    }

    memset( _pbHeapBuf, 0, _cElements * _cbElement );

    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   PropVariantClear
//
//  Synopsis:   Deallocates the members of the PROPVARIANT that require
//              deallocation.
//
//  Arguments:  [pvarg] - variant to clear
//
//  Returns:    S_OK if successful,
//              STG_E_INVALIDPARAMETER if any part of the variant has
//                  an unknown vt type.  (In this case, ALL the elements
//                  that can be freed, will be freed.)
//
//  Modifies:   [pvarg] - the variant is left with vt = VT_EMPTY
//
//--------------------------------------------------------------------------

STDAPI PropVariantClear(PROPVARIANT *pvarg)
{

    ULONG l;
    HRESULT hr = S_OK;

    // Is there really anything to clear?
    if (pvarg == NULL)
        return(hr);

    // Validate the input
    VDATEPTROUT( pvarg, PROPVARIANT );

    switch (pvarg->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_ILLEGAL:

    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
        break;

    case VT_BSTR:
        if (pvarg->bstrVal != NULL)
            PrivSysFreeString( pvarg->bstrVal );
        break;

    case VT_BSTR_BLOB:
        if (pvarg->bstrblobVal.pData != NULL)
            CoTaskMemFree( pvarg->bstrblobVal.pData );
        break;
    case VT_BOOL:
    case VT_ERROR:
    case VT_FILETIME:
        break;

    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_CLSID:
        DfpAssert((void**)&pvarg->pszVal == (void**)&pvarg->pwszVal);
        DfpAssert((void**)&pvarg->pszVal == (void**)&pvarg->puuid);
        CoTaskMemFree( pvarg->pszVal ); // ptr at 0
        break;
        
    case VT_CF:
        if (pvarg->pclipdata != NULL)
        {
            CoTaskMemFree( pvarg->pclipdata->pClipData ); // ptr at 8
            CoTaskMemFree( pvarg->pclipdata );
        }
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        CoTaskMemFree( pvarg->blob.pBlobData ); //ptr at 4
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
        if (pvarg->pStream != NULL)
            pvarg->pStream->Release();
        break;

    case VT_VERSIONED_STREAM:
        if( NULL != pvarg->pVersionedStream )
        {
            if( NULL != pvarg->pVersionedStream->pStream )
                pvarg->pVersionedStream->pStream->Release();
            CoTaskMemFree( pvarg->pVersionedStream );
        }
        break;

    case VT_STORAGE:
    case VT_STORED_OBJECT:
        if (pvarg->pStorage != NULL)
            pvarg->pStorage->Release();
        break;

    case (VT_VECTOR | VT_I1):
    case (VT_VECTOR | VT_UI1):
    case (VT_VECTOR | VT_I2):
    case (VT_VECTOR | VT_UI2):
    case (VT_VECTOR | VT_I4):
    case (VT_VECTOR | VT_UI4):
    case (VT_VECTOR | VT_I8):
    case (VT_VECTOR | VT_UI8):
    case (VT_VECTOR | VT_R4):
    case (VT_VECTOR | VT_R8):
    case (VT_VECTOR | VT_CY):
    case (VT_VECTOR | VT_DATE):

FreeArray:
        DfpAssert((void**)&pvarg->caub.pElems == (void**)&pvarg->cai.pElems);
        CoTaskMemFree( pvarg->caub.pElems );
        break;

    case (VT_VECTOR | VT_BSTR):
        if (pvarg->cabstr.pElems != NULL)
        {
            for (l=0; l< pvarg->cabstr.cElems; l++)
            {
                if (pvarg->cabstr.pElems[l] != NULL)
                {
                    PrivSysFreeString( pvarg->cabstr.pElems[l] );
                }
            }
        }
        goto FreeArray;

    case (VT_VECTOR | VT_BSTR_BLOB):
        if (pvarg->cabstrblob.pElems != NULL)
        {
            for (l=0; l< pvarg->cabstrblob.cElems; l++)
            {
                if (pvarg->cabstrblob.pElems[l].pData != NULL)
                {
                    CoTaskMemFree( pvarg->cabstrblob.pElems[l].pData );
                }
            }
        }
        goto FreeArray;

    case (VT_VECTOR | VT_BOOL):
    case (VT_VECTOR | VT_ERROR):
        goto FreeArray;

    case (VT_VECTOR | VT_LPSTR):
    case (VT_VECTOR | VT_LPWSTR):
        if (pvarg->calpstr.pElems != NULL)
        {
            for (l=0; l< pvarg->calpstr.cElems; l++)
            {
                CoTaskMemFree( pvarg->calpstr.pElems[l] );
            }
        }
        goto FreeArray;

    case (VT_VECTOR | VT_FILETIME):
    case (VT_VECTOR | VT_CLSID):
        goto FreeArray;

    case (VT_VECTOR | VT_CF):
        if (pvarg->caclipdata.pElems != NULL)
            for (l=0; l< pvarg->caclipdata.cElems; l++)
            {
                CoTaskMemFree( pvarg->caclipdata.pElems[l].pClipData );
            }
        goto FreeArray;

    case (VT_VECTOR | VT_VARIANT):
        if (pvarg->capropvar.pElems != NULL)
            hr = FreePropVariantArray(pvarg->capropvar.cElems, pvarg->capropvar.pElems);
        goto FreeArray;

    default:

        // If it's not a type we recognize, give oleaut a try

        hr = PrivVariantClear( reinterpret_cast<VARIANT*>(pvarg) );
        if( DISP_E_BADVARTYPE == hr )
            hr = STG_E_INVALIDPARAMETER;

        break;
    }

    //  We have all of the important information about the variant, so
    //  let's clear it out.
    //
    PropVariantInit(pvarg);

    return (hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreePropVariantArray, public
//
//  Synopsis:   Frees a value array returned from ReadMultiple
//
//  Arguments:  [cval] - Number of elements
//              [rgvar] - Array
//
//  Returns:    S_OK if all types recognised and all freeable items were freed.
//              STG_E_INVALID_PARAMETER if one or more types were not
//              recognised but all items are freed too.
//
//  Notes:      Even if a vt-type is not understood, all the ones that are
//              understood are freed.  The error code will indicate
//              if *any* of the members were illegal types.
//
//----------------------------------------------------------------------------

STDAPI FreePropVariantArray (
        ULONG cVariants,
        PROPVARIANT *rgvars)
{
    HRESULT hr = S_OK;

    VDATESIZEPTROUT_LABEL(rgvars, cVariants * sizeof(PROPVARIANT),
                          Exit, hr );

    if (rgvars != NULL)
    {
        for ( ULONG I=0; I < cVariants; I++ )
        {
            if (STG_E_INVALIDPARAMETER == PropVariantClear ( rgvars + I ))
                hr = STG_E_INVALIDPARAMETER;
        }
    }

Exit:

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   AllocAndCopy
//
//  Synopsis:   Allocates enough memory to copy the passed data into and
//              then copies the data into the new buffer.
//
//  Arguments:  [cb] -- number of bytes of data to allocate and copy
//              [pvData]  --  the source of the data to copy
//              [phr] -- optional pointer to an HRESULT set to
//                       STG_E_INSUFFICIENTMEMORY if memory could
//                       not be allocated.
//              
//
//  Returns:    NULL if no memory could be allocated,
//              Otherwise, pointer to allocated and copied data.
//
//--------------------------------------------------------------------

void * AllocAndCopy(ULONG cb, void * pvData, HRESULT *phr /* = NULL */)
{
    void * pvNew  =  CoTaskMemAlloc( cb );
    if (pvNew != NULL)
    {
        memcpy(pvNew, pvData, cb);
    }
    else
    {
        if (phr != NULL)
        {
            *phr = STG_E_INSUFFICIENTMEMORY;
        }
    }
    return(pvNew);
}



//+-------------------------------------------------------------------
//
//  Function:   PropSysAllocString
//              PropSysFreeString
//
//  Synopsis:   Wrappers for OleAut32 routines.
//
//  Notes:      These PropSys* functions simply forward the call to
//              the PrivSys* routines in OLE32.  Those functions
//              will load OleAut32 if necessary, and forward the call.
//
//              The PrivSys* wrapper functions are provided in order to
//              delay the OleAut32 load.  The PropSys* functions below
//              are provided as a mechanism to allow the NTDLL PropSet
//              functions to call the PrivSys* function pointers.
//
//              The PropSys* functions below are part of the
//              UNICODECALLOUTS structure used by NTDLL.
//              These functions should go away when the property set
//              code is moved from NTDLL to OLE32.
//
//--------------------------------------------------------------------

STDAPI_(BSTR)
PropSysAllocString(OLECHAR FAR* pwsz)
{
    return( PrivSysAllocString( pwsz ));
}

STDAPI_(VOID)
PropSysFreeString(BSTR bstr)
{
    PrivSysFreeString( bstr );
    return;
}

//+---------------------------------------------------------------------------
//
//  Class:      CRGTypeSizes (instantiated in g_TypeSizes)
//
//  Synopsis:   This class maintains a table with an entry for
//              each of the VT types.  Each entry contains
//              flags and a byte-size for the type (each entry is
//              only a byte).
//
//              This was implemented as a class so that we could use
//              it like an array (using an overloaded subscript operator),
//              indexed by the VT.  An actual array would require
//              4K entries
//
//              Internally, this class keeps two tables, each containing
//              a range of VTs (the VTs range from 0 to 31, and 64 to 72).
//              Other values are treated as a special-case.
//
//----------------------------------------------------------------------------

//  -----------------------
//  Flags for table entries
//  -----------------------

#define BIT_VECTNOALLOC 0x80    // the VT_VECTOR with this type does not
                                // use heap allocation

#define BIT_SIMPNOALLOC 0x40    // the non VT_VECTOR with this type does not
                                // use heap allocation

#define BIT_INVALID     0x20    // marks an invalid type

#define BIT_SIZEMASK    0x1F    // mask for size of underlying type

//  Dimensions of the internal tables

#define MIN_TYPE_SIZES_A    VT_EMPTY        // First contiguous range of VTs
#define MAX_TYPE_SIZES_A    VT_LPWSTR

#define MIN_TYPE_SIZES_B    VT_FILETIME     // Second continuous range of VTs
#define MAX_TYPE_SIZES_B    VT_VERSIONED_STREAM

//  ----------------
//  class CRTTypeSizes
//  ----------------

class CRGTypeSizes
{

public:

    // Subscript Operator
    //
    // This is the only method on this class.  It is used to
    // read an entry in the table.

    unsigned char operator[]( int nSubscript )
    {
        // Is this in the first table?
        if( MIN_TYPE_SIZES_A <= nSubscript && nSubscript <= MAX_TYPE_SIZES_A )
        {
	    return( m_ucTypeSizesA[ nSubscript ] );
        }

        // Or, is it in the second table?
        else if( MIN_TYPE_SIZES_B<= nSubscript && nSubscript <= MAX_TYPE_SIZES_B )
        {
            return( m_ucTypeSizesB[ nSubscript - MIN_TYPE_SIZES_B ] );
        }

        // Or, is it a special-case value (not in either table)?
        else if( VT_BSTR_BLOB == nSubscript )
        {
	    return( sizeof(BSTRBLOB) );
        }

        // Otherwise, the VT is invalid.
        return( BIT_INVALID );
    }


private:

    // There are two ranges of supported VTs, so we have
    // one table for each.

    static const unsigned char m_ucTypeSizesA[];
    static const unsigned char m_ucTypeSizesB[];
};

//  --------------------------
//  Instantiate the CRGTypeSizes
//  --------------------------

CRGTypeSizes g_TypeSizes;

//  ----------------------------
//  Define the CTypeSizes tables
//  ----------------------------

const unsigned char CRGTypeSizes::m_ucTypeSizesA[] =
{                 BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_EMPTY= 0,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_NULL      = 1,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  2,                    //VT_I2        = 2,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_I4        = 3,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_R4        = 4,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_R8        = 5,
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(CY),           //VT_CY        = 6,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(DATE),         //VT_DATE      = 7,
                                                       sizeof(BSTR),         //VT_BSTR      = 8,
                                        BIT_INVALID |  0,                    //VT_DISPATCH  = 9,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(SCODE),        //VT_ERROR     = 10,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(VARIANT_BOOL), //VT_BOOL      = 11,
                                                       sizeof(PROPVARIANT),  //VT_VARIANT   = 12,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_UNKNOWN   = 13,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    // 14
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    // 15
		  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  1,                    //VT_I1        = 16,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  1,                    //VT_UI1       = 17,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  2,                    //VT_UI2       = 18,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_UI4       = 19,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_I8        = 20,
                  BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_UI8       = 21,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_INT  = 22,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_UINT = 23,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_VOID = 24,
    BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_HRESULT      = 25,
    BIT_INVALID |                                      0,                    //VT_PTR  = 26,
    BIT_INVALID |                                      0,                    //VT_SAFEARRAY    = 27,
    BIT_INVALID |                                      0,                    //VT_CARRAY       = 28,
    BIT_INVALID |                                      0,                    //VT_USERDEFINED  = 29,
														   sizeof(LPSTR),        //VT_LPSTR        = 30,
														   sizeof(LPWSTR)        //VT_LPWSTR       = 31,
};

const unsigned char CRGTypeSizes::m_ucTypeSizesB[] =
{
    // sizes for vectors of types marked ** are determined dynamically
    BIT_SIMPNOALLOC | BIT_VECTNOALLOC |     sizeof(FILETIME),     //VT_FILETIME                 = 64,
                                            0,                    //**VT_BLOB                   = 65,
                                            0,                    //**VT_STREAM                 = 66,
                                            0,                    //**VT_STORAGE                = 67,
                                            0,                    //**VT_STREAMED_OBJECT        = 68,
                                            0,                    //**VT_STORED_OBJECT          = 69,
                                            0,                    //**VT_BLOB_OBJECT            = 70,
                                            sizeof(CLIPDATA),     //VT_CF                       = 71,
                      BIT_VECTNOALLOC |     sizeof(CLSID),        //VT_CLSID                    = 72,
                                            0                     //**VT_VERSIONED_STREAM       = 73
};


//+---------------------------------------------------------------------------
//
//  Function:   PropVariantCopy, public
//
//  Synopsis:   Copies a PROPVARIANT
//
//  Arguments:  [pDest] -- the destination PROPVARIANT
//              [pvarg] - the source PROPVARIANT
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

STDAPI PropVariantCopy ( PROPVARIANT * pvOut, const PROPVARIANT * pvarg )
{
    HRESULT     hr = S_OK;
    register unsigned char TypeInfo;
    register int iBaseType;
    BOOL fInputValidated = FALSE;
    PROPVARIANT Temp, *pDest = &Temp;

    //  ----------
    //  Initialize
    //  ----------

    // Validate the inputs

    VDATEREADPTRIN_LABEL( pvarg, PROPVARIANT, Exit, hr );
    VDATEPTROUT_LABEL( pvOut, PROPVARIANT, Exit, hr );
    fInputValidated = TRUE;

    // Duplicate the source propvar to the temp destination.  For types with
    // no external buffer (e.g. an I4), this will be sufficient.  For
    // types with an external buffer, we'll now have both propvars
    // pointing to the same buffer.  So we'll have to re-allocate 
    // for the destination propvar and copy the data into it.
    //

    *pDest = *pvarg;

    // Get allocation info for this type.

    iBaseType = pvarg->vt & ~VT_VECTOR;
    TypeInfo = g_TypeSizes[ iBaseType ];    // Not to be confused with an ITypeInfo

    // If this is an invalid type, see if it's an oleaut Variant type

    if( (TypeInfo & BIT_INVALID) != 0 )
    {
        // Try copying it as a regular Variant
        PropVariantInit( pDest );
        hr = PrivVariantCopy( reinterpret_cast<VARIANT*>(pDest),
                              reinterpret_cast<VARIANT*>(const_cast<PROPVARIANT*>( pvarg )) );
        goto Exit;
    }

    //  -----------------------
    //  Handle non-vector types
    //  -----------------------

    if ((pvarg->vt & VT_VECTOR) == 0)
    {

        // Is this a type which requires an allocation (otherwise there's
        // nothing to do)?

        if ((TypeInfo & BIT_SIMPNOALLOC) == 0)
        {
            // Yes - an allocation is required.

            // Keep a copy of the allocated buffer, so that at the end of
            // this switch, we can distiguish the out-of-memory condition from
            // the no-alloc-required condition.

            void * pvAllocated = (void*)-1;

            switch (pvarg->vt)
            {
                case VT_BSTR:
                    if( NULL != pvarg->bstrVal )
                        // This does an alloc and a copy
                        pvAllocated = pDest->bstrVal = PrivSysAllocString( pvarg->bstrVal );
                    break;

                case VT_BSTR_BLOB:
                    if( NULL != pvarg->bstrblobVal.pData )
                        pvAllocated = pDest->bstrblobVal.pData = (BYTE*)
                            AllocAndCopy(pDest->bstrblobVal.cbSize, pvarg->bstrblobVal.pData);
                    break;

                case VT_LPSTR:
                    if (pvarg->pszVal != NULL)
                        pvAllocated = pDest->pszVal = (CHAR *)
                            AllocAndCopy((ULONG)strlen(pvarg->pszVal)+1, pvarg->pszVal);
                    break;

                case VT_LPWSTR:
                    if (pvarg->pwszVal != NULL)
                    {
                        ULONG cbString = ((ULONG)Prop_wcslen(pvarg->pwszVal)+1) * sizeof(WCHAR);
                        pvAllocated = pDest->pwszVal = (WCHAR *)
                            AllocAndCopy(cbString, pvarg->pwszVal);
                    }
                    break;

                case VT_CLSID:
                    if (pvarg->puuid != NULL)
                        pvAllocated = pDest->puuid = (GUID *)
                            AllocAndCopy(sizeof(*(pvarg->puuid)), pvarg->puuid);
                    break;
                
                case VT_CF:
                    // first check if CLIPDATA is present
                    if (pvarg->pclipdata != NULL)
                    {
                        // yes ... copy the clip data structure

                        pvAllocated = pDest->pclipdata = (CLIPDATA*)AllocAndCopy(
                            sizeof(*(pvarg->pclipdata)), pvarg->pclipdata);

                        // did we allocate the CLIPDATA ?
                        if (pvAllocated != NULL)
                        {
                            // yes ... initialize the destination.
                            pDest->pclipdata->pClipData = NULL;

                            // Is the input valid?
                            if (NULL == pvarg->pclipdata->pClipData
                                &&
                                0 != CBPCLIPDATA(*pvarg->pclipdata))
                            {
                                // no ... the input is not valid
                                hr = STG_E_INVALIDPARAMETER;
                                CoTaskMemFree( pDest->pclipdata );
                                pvAllocated = pDest->pclipdata = NULL;
                                break;
                            }

                            // Copy the actual clip data.  Note that if the source
                            // is non-NULL, we copy it, even if the length is 0.

                            if( NULL != pvarg->pclipdata->pClipData )
                            {
                                pvAllocated = pDest->pclipdata->pClipData =
                                    (BYTE*)AllocAndCopy(CBPCLIPDATA(*pvarg->pclipdata),
                                             pvarg->pclipdata->pClipData);
                            }

                        }   // if (pvAllocated != NULL)
                    }   // if (pvarg->pclipdata != NULL)
                    break;

                case VT_BLOB:
                case VT_BLOB_OBJECT:

                    // Is the input valid?
                    if (NULL == pvarg->blob.pBlobData
                        &&
                        0 != pvarg->blob.cbSize)
                    {
                        // no ... the input is not valid
                        hr = STG_E_INVALIDPARAMETER;
                        goto Exit;
                    }

                    // Copy the actual blob.  Note that if the source
                    // is non-NULL, we copy it, even if the length is 0.

                    if( NULL != pvarg->blob.pBlobData )
                    {
                        pvAllocated = pDest->blob.pBlobData =
                            (BYTE*)AllocAndCopy(pvarg->blob.cbSize,
                                     pvarg->blob.pBlobData);
                    }


                    break;

                case VT_STREAM:
                case VT_STREAMED_OBJECT:

                    if (pDest->pStream != NULL)
                            pDest->pStream->AddRef();
                    break;

                case VT_VERSIONED_STREAM:

                    if( NULL != pvarg->pVersionedStream )
                    {
                        LPVERSIONEDSTREAM pVersionedStream
                            = reinterpret_cast<LPVERSIONEDSTREAM>(CoTaskMemAlloc( sizeof(VERSIONEDSTREAM) ));
                        if( NULL == pVersionedStream )
                        {
                            hr = E_OUTOFMEMORY;
                            goto Exit;
                        }

                        *pVersionedStream = *pvarg->pVersionedStream;
                        if( NULL != pVersionedStream->pStream )
                            pVersionedStream->pStream->AddRef();

                        pDest->pVersionedStream = pVersionedStream;
                    }

                    break;


                case VT_STORAGE:
                case VT_STORED_OBJECT:

                    if (pDest->pStorage != NULL)
                            pDest->pStorage->AddRef();
                    break;

                case VT_VARIANT:

                    // drop through - this merely documents that VT_VARIANT has been thought of.
                    // VT_VARIANT is only supported as part of a vector.

                default:

                    hr = STG_E_INVALIDPARAMETER;
                    goto Exit;

            }   // switch (pvarg->vt)

            // If there was an error, we're done.
            if( FAILED(hr) )
                goto Exit;

            // pvAllocated was initialized to -1, so if it's NULL now,
            // there was an alloc failure.

            if (pvAllocated == NULL)
            {
                hr = STG_E_INSUFFICIENTMEMORY;
                goto Exit;
            }

        }   // if ((TypeInfo & BIT_SIMPNOALLOC) == 0)
    }   // if ((pvarg->vt & VT_VECTOR) == 0)

    //  -------------------
    //  Handle vector types
    //  -------------------

    else
    {
        // What's the byte-size of this type.

        ULONG cbType = TypeInfo & BIT_SIZEMASK;
        if (cbType == 0)
        {
            hr = STG_E_INVALIDPARAMETER;
            goto Exit;
        }

        // This depends on the pointer and count being in the same place in
        // each of CAUI1 CAI2 etc

        // allocate the array for pElems
        if (pvarg->caub.pElems == NULL || pvarg->caub.cElems == 0)
        {
            DfpAssert( hr == S_OK );
            goto Exit; // not really an error
        }

        // Allocate the pElems array (the size of which is
        // type-dependent), and copy the source into it.

        void *pvAllocated = pDest->caub.pElems = (BYTE *)
            AllocAndCopy(cbType * pvarg->caub.cElems, pvarg->caub.pElems);

        if (pvAllocated == NULL)
        {
            hr = STG_E_INSUFFICIENTMEMORY;
            goto Exit;
        }

        // If this type doesn't require secondary allocation (e.g.
        // a VT_VECTOR | VT_I4), then we're done.

        if ((TypeInfo & BIT_VECTNOALLOC) != 0)
        {
            // the vector needs no further allocation
            DfpAssert( hr == S_OK );
            goto Exit;
        }

        ULONG l;

        // vector types that require allocation ...
        // we first zero out the pointers so that we can use PropVariantClear
        // to clean up in the error case

        switch (pvarg->vt)
        {
        case (VT_VECTOR | VT_BSTR):
            // initialize for error case
            for (l=0; l< pvarg->cabstr.cElems; l++)
            {
                pDest->cabstr.pElems[l] = NULL;
            }
            break;

        case (VT_VECTOR | VT_BSTR_BLOB):
            // initialize for error case
            for (l=0; l< pvarg->cabstrblob.cElems; l++)
            {
                memset( &pDest->cabstrblob.pElems[l], 0, sizeof(BSTRBLOB) );
            }
            break;

        case (VT_VECTOR | VT_LPSTR):
        case (VT_VECTOR | VT_LPWSTR):
            // initialize for error case
            for (l=0; l< pvarg->calpstr.cElems; l++)
            {
                pDest->calpstr.pElems[l] = NULL;
            }
            break;

        case (VT_VECTOR | VT_CF):
            // initialize for error case
            for (l=0; l< pvarg->caclipdata.cElems; l++)
            {
                pDest->caclipdata.pElems[l].pClipData  = NULL;
            }
            break;

        case (VT_VECTOR | VT_VARIANT):
            // initialize for error case
            for (l=0; l< pvarg->capropvar.cElems; l++)
            {
                pDest->capropvar.pElems[l].vt = VT_ILLEGAL;
            }
            break;

        default:
            DfpAssert(!"Internal error: Unexpected type in PropVariantCopy");
            CoTaskMemFree( pvAllocated );
            hr = STG_E_INVALIDPARAMETER;
            goto Exit;
        }

        // This is a vector type which requires a secondary alloc.

        switch (pvarg->vt)
        {
            case (VT_VECTOR | VT_BSTR):
                for (l=0; l< pvarg->cabstr.cElems; l++)
                {
                    if (pvarg->cabstr.pElems[l] != NULL)
                    {
                        pDest->cabstr.pElems[l] = PrivSysAllocString( pvarg->cabstr.pElems[l]);
                        if (pDest->cabstr.pElems[l]  == NULL)
                        {
                            hr = STG_E_INSUFFICIENTMEMORY;
                            break;
                        }
                    }
                }
                break;

            case (VT_VECTOR | VT_BSTR_BLOB):
                for (l=0; l< pvarg->cabstrblob.cElems; l++)
                {
                    if (pvarg->cabstrblob.pElems[l].pData != NULL)
                    {
                        pDest->cabstrblob.pElems[l].cbSize
                            = pvarg->cabstrblob.pElems[l].cbSize;

                        pDest->cabstrblob.pElems[l].pData = (BYTE*)AllocAndCopy(
                            pvarg->cabstrblob.pElems[l].cbSize,
                            pvarg->cabstrblob.pElems[l].pData,
                            &hr );

                        if (hr != S_OK)
                            break;
                    }
                }
                break;
        
            case (VT_VECTOR | VT_LPWSTR):
                for (l=0; l< pvarg->calpwstr.cElems; l++)
                {
                    if (pvarg->calpwstr.pElems[l] != NULL)
                    {

                        pDest->calpwstr.pElems[l] = (LPWSTR)AllocAndCopy(
                            sizeof(WCHAR)*((ULONG)Prop_wcslen(pvarg->calpwstr.pElems[l])+1),
                            pvarg->calpwstr.pElems[l],
                            &hr);

                        if (hr != S_OK)
                            break;
                    }
                }
                break;

            case (VT_VECTOR | VT_LPSTR):
                for (l=0; l< pvarg->calpstr.cElems; l++)
                {
                    if (pvarg->calpstr.pElems[l] != NULL)
                    {
                        pDest->calpstr.pElems[l] = (LPSTR)AllocAndCopy(
                            (ULONG)strlen(pvarg->calpstr.pElems[l])+1,
                            pvarg->calpstr.pElems[l],
                            &hr);

                        if (hr != S_OK)
                            break;
                    }
                }
                break;

            case (VT_VECTOR | VT_CF):
                for (l=0; l< pvarg->caclipdata.cElems; l++)
                {
                    // Is the input valid?
                    if (NULL == pvarg->caclipdata.pElems[l].pClipData
                        &&
                        0 != CBPCLIPDATA(pvarg->caclipdata.pElems[l] ))
                    {
                        hr = STG_E_INVALIDPARAMETER;
                        break;
                    }

                    // Is there data to copy?
                    if (NULL != pvarg->caclipdata.pElems[l].pClipData)
                    {
                        pDest->caclipdata.pElems[l].pClipData  = (BYTE*)AllocAndCopy(
                            CBPCLIPDATA(pvarg->caclipdata.pElems[l]),
                            pvarg->caclipdata.pElems[l].pClipData,
                            &hr);

                        if (hr != S_OK)
                            break;
                    }
                }
                break;

            case (VT_VECTOR | VT_VARIANT):
                for (l=0; l< pvarg->capropvar.cElems; l++)
                {
                    hr = PropVariantCopy(pDest->capropvar.pElems + l,
                                         pvarg->capropvar.pElems + l);
                    if (hr != S_OK)
                    {
                        break;
                    }
                }
                break;

            default:
                DfpAssert(!"Internal error: Unexpected type in PropVariantCopy");
                CoTaskMemFree( pvAllocated );
                hr = STG_E_INVALIDPARAMETER;
                goto Exit;

        }   // switch (pvarg->vt)
    }   // if ((pvarg->vt & VT_VECTOR) == 0) ... else

    //  ----
    //  Exit
    //  ----

Exit:

    // If there was an error, and it wasn't a caller error
    // (in which case *pDest may not be writable), clear the
    // destination propvar.

    if (fInputValidated && hr != S_OK && E_INVALIDARG != hr)
    {
        // if *pDest == *pvarg, then we didn't alloc anything, and
        // nothing need be cleared, so we'll just init *pDest.
        // We can't free it because it may point to pvarg's buffers.

        if( !memcmp( pDest, pvarg, sizeof(PROPVARIANT) ))
            PropVariantInit( pDest );

        // Otherwise, we must have done some allocations for *pDest,
        // and must free them.

        else
            PropVariantClear( pDest );

    }

    if (SUCCEEDED(hr))
        *pvOut = Temp;

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   NtStatusToScode, public
//
//  Synopsis:   Attempts to map an NTSTATUS code to an SCODE
//
//  Arguments:  [nts] - NTSTATUS
//
//  Returns:    Appropriate status code
//
//  History:    29-Jun-93       DrewB   Created
//
//  Notes:      Assumes [nts] is an error code
//              This function is by no means exhaustively complete
//
//----------------------------------------------------------------------------

SCODE NtStatusToScode(NTSTATUS nts)
{
    SCODE sc;

    propDbg((DEB_ITRACE, "In  NtStatusToScode(%lX)\n", nts));

    switch(nts)
    {
    case STATUS_INVALID_PARAMETER:
    case STATUS_INVALID_PARAMETER_MIX:
    case STATUS_INVALID_PARAMETER_1:
    case STATUS_INVALID_PARAMETER_2:
    case STATUS_INVALID_PARAMETER_3:
    case STATUS_INVALID_PARAMETER_4:
    case STATUS_INVALID_PARAMETER_5:
    case STATUS_INVALID_PARAMETER_6:
    case STATUS_INVALID_PARAMETER_7:
    case STATUS_INVALID_PARAMETER_8:
    case STATUS_INVALID_PARAMETER_9:
    case STATUS_INVALID_PARAMETER_10:
    case STATUS_INVALID_PARAMETER_11:
    case STATUS_INVALID_PARAMETER_12:
        sc = STG_E_INVALIDPARAMETER;
        break;

    case STATUS_DUPLICATE_NAME:
    case STATUS_DUPLICATE_OBJECTID:
    case STATUS_OBJECTID_EXISTS:
    case STATUS_OBJECT_NAME_COLLISION:
        sc = STG_E_FILEALREADYEXISTS;
        break;

    case STATUS_NO_SUCH_DEVICE:
    case STATUS_NO_SUCH_FILE:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_NOT_A_DIRECTORY:
    case STATUS_FILE_IS_A_DIRECTORY:
    case STATUS_PROPSET_NOT_FOUND:
    case STATUS_NOT_FOUND:
    case STATUS_OBJECT_TYPE_MISMATCH:
        sc = STG_E_FILENOTFOUND;
        break;

    case STATUS_OBJECT_NAME_INVALID:
    case STATUS_OBJECT_PATH_SYNTAX_BAD:
    case STATUS_OBJECT_PATH_INVALID:
    case STATUS_NAME_TOO_LONG:
        sc = STG_E_INVALIDNAME;
        break;

    case STATUS_ACCESS_DENIED:
        sc = STG_E_ACCESSDENIED;
        break;

    case STATUS_NO_MEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        sc = STG_E_INSUFFICIENTMEMORY;
        break;

    case STATUS_INVALID_HANDLE:
    case STATUS_FILE_INVALID:
    case STATUS_FILE_FORCED_CLOSED:
        sc = STG_E_INVALIDHANDLE;
        break;

    case STATUS_INVALID_DEVICE_REQUEST:
    case STATUS_INVALID_SYSTEM_SERVICE:
    case STATUS_NOT_IMPLEMENTED:
        sc = STG_E_INVALIDFUNCTION;
        break;

    case STATUS_NO_MEDIA_IN_DEVICE:
    case STATUS_UNRECOGNIZED_MEDIA:
    case STATUS_DISK_CORRUPT_ERROR:
    case STATUS_DATA_ERROR:
        sc = STG_E_WRITEFAULT;
        break;

    case STATUS_OBJECT_PATH_NOT_FOUND:
        sc = STG_E_PATHNOTFOUND;
        break;

    case STATUS_SHARING_VIOLATION:
        sc = STG_E_SHAREVIOLATION;
        break;

    case STATUS_FILE_LOCK_CONFLICT:
    case STATUS_LOCK_NOT_GRANTED:
        sc = STG_E_LOCKVIOLATION;
        break;

    case STATUS_DISK_FULL:
        sc = STG_E_MEDIUMFULL;
        break;

    case STATUS_ACCESS_VIOLATION:
    case STATUS_INVALID_USER_BUFFER:
        sc = STG_E_INVALIDPOINTER;
        break;

    case STATUS_TOO_MANY_OPENED_FILES:
        sc = STG_E_TOOMANYOPENFILES;
        break;

    case STATUS_DIRECTORY_NOT_EMPTY:
        sc = HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY);
        break;

    case STATUS_DELETE_PENDING:
        sc = STG_E_REVERTED;
        break;

    case STATUS_INTERNAL_DB_CORRUPTION:
        sc = STG_E_INVALIDHEADER;
        break;

    case STATUS_UNSUCCESSFUL:
        sc = E_FAIL;
        break;
        
    case STATUS_UNMAPPABLE_CHARACTER:
        sc = HRESULT_FROM_WIN32( ERROR_NO_UNICODE_TRANSLATION );
        break;

    default:
        propDbg((DEB_TRACE, "NtStatusToScode: Unknown status %lX\n", nts));

        sc = HRESULT_FROM_WIN32(RtlNtStatusToDosError(nts));
        break;
    }

    propDbg((DEB_ITRACE, "Out NtStatusToScode => %lX\n", sc));
    return sc;
}

#if DBG!=0 && !defined(WINNT)

ULONG
DbgPrint(
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    CHAR Buffer[512];
    int cb;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);
    cb = PropVsprintfA(Buffer, Format, arglist);
    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 2] = '\n';
        Buffer[sizeof(Buffer) - 1] = '\0';
    }

    OutputDebugString(Buffer);

    return 0;
}
#endif


//+-------------------------------------------------------------------
//
//  Member:     ValidateInRGPROPVARIANT
//
//  Synopsis:   S_OK if PROPVARIANT[] is valid for Read.
//              E_INVALIDARG otherwise.
//
//--------------------------------------------------------------------

HRESULT
ValidateInRGPROPVARIANT( ULONG cpspec, const PROPVARIANT rgpropvar[] )
{
    // We verify that we can read the whole PropVariant[], but
    // we don't validate the content of those elements.

    HRESULT hr;
    VDATESIZEREADPTRIN_LABEL(rgpropvar, cpspec * sizeof(PROPVARIANT), Exit, hr);
    hr = S_OK;

Exit:

    return( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     ValidateOutRGPROPVARIANT
//
//  Synopsis:   S_OK if PROPVARIANT[] is valid for Write.
//              E_INVALIDARG otherwise.
//
//--------------------------------------------------------------------

HRESULT
ValidateOutRGPROPVARIANT( ULONG cpspec, PROPVARIANT rgpropvar[] )
{
    // We verify that we can write the whole PropVariant[], but
    // we don't validate the content of those elements.

    HRESULT hr;
    VDATESIZEPTROUT_LABEL(rgpropvar, cpspec * sizeof(PROPVARIANT), Exit, hr);
    hr = S_OK;

Exit:

    return( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     ValidateOutRGLPOLESTR.
//
//  Synopsis:   S_OK if LPOLESTR[] is valid for Write.
//              E_INVALIDARG otherwise.
//
//--------------------------------------------------------------------

HRESULT
ValidateOutRGLPOLESTR( ULONG cpropid, LPOLESTR rglpwstrName[] )
{
    HRESULT hr;
    VDATESIZEPTROUT_LABEL( rglpwstrName, cpropid * sizeof(LPOLESTR), Exit, hr );
    hr = S_OK;

Exit:

    return( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     ValidateInRGLPOLESTR
//
//  Synopsis:   S_OK if LPOLESTR[] is valid for Read.
//              E_INVALIDARG otherwise.
//
//--------------------------------------------------------------------

HRESULT
ValidateInRGLPOLESTR( ULONG cpropid, const OLECHAR* const rglpwstrName[] )
{
    // Validate that we can read the entire vector.

    HRESULT hr;
    VDATESIZEREADPTRIN_LABEL( rglpwstrName, cpropid * sizeof(LPOLESTR), Exit, hr );

    // Validate that we can at least read the first character of
    // each of the strings.

    for( ; cpropid > 0; cpropid-- )
    {
        VDATEREADPTRIN_LABEL( rglpwstrName[cpropid-1], WCHAR, Exit, hr );
    }

    hr = S_OK;

Exit:

    return( hr );
}





//+----------------------------------------------------------------------------
//
//  Function:   IsOriginalPropVariantType
//
//  Determines if a VARTYPE was one of the ones in the original PropVariant
//  definition (as defined in the OLE2 spec and shipped with NT4/DCOM95).
//
//+----------------------------------------------------------------------------

BOOL
IsOriginalPropVariantType( VARTYPE vt )
{
    if( vt & ~VT_TYPEMASK & ~VT_VECTOR )
        return( FALSE );

    switch( vt )
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_UI1: 
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
    case VT_CLSID:
    case VT_BLOB:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_UI1|VT_VECTOR:
    case VT_I2|VT_VECTOR:
    case VT_UI2|VT_VECTOR:
    case VT_BOOL|VT_VECTOR:
    case VT_I4|VT_VECTOR:
    case VT_UI4|VT_VECTOR:
    case VT_R4|VT_VECTOR:
    case VT_ERROR|VT_VECTOR:
    case VT_I8|VT_VECTOR:
    case VT_UI8|VT_VECTOR:
    case VT_R8|VT_VECTOR:
    case VT_CY|VT_VECTOR:
    case VT_DATE|VT_VECTOR:
    case VT_FILETIME|VT_VECTOR:
    case VT_CLSID|VT_VECTOR:
    case VT_CF|VT_VECTOR:
    case VT_BSTR|VT_VECTOR:
    case VT_BSTR_BLOB|VT_VECTOR:
    case VT_LPSTR|VT_VECTOR:
    case VT_LPWSTR|VT_VECTOR:
    case VT_VARIANT|VT_VECTOR:

        return( TRUE );
    }

    return( FALSE );
}



//+----------------------------------------------------------------------------
//
//  Function:   IsVariantType
//
//  Determines if a VARTYPE is one in the set of Variant types which are 
//  supported in the property set implementation.
//
//+----------------------------------------------------------------------------

BOOL
IsVariantType( VARTYPE vt )
{
    // Vectors are unsupported
    if( (VT_VECTOR | VT_RESERVED) & vt )
        return( FALSE );

    switch( VT_TYPEMASK & vt )
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_UNKNOWN:
    case VT_DISPATCH:
    case VT_BOOL:
    case VT_ERROR:
    case VT_DECIMAL:
    case VT_VARIANT:

        return( TRUE );

    default:

        return( FALSE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\iprop\privoa.cxx ===
#include <pch.cxx>

// Bring in the real code, but avoid compiler errors by
// preventing an unnecessary include of ole2int.h

#define _OLE2INT_H_
#include "..\\..\\..\\com\\class\\privoa.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\iprop\nt5props.h ===
#ifndef _IPROP_H_
#define _IPROP_H_


#if !defined(__objidl_h__) || !defined(_OBJBASE_H_)
#error ole2.h (specifically, objidl.h & objbase.h) must be included before iprop.h
#endif

EXTERN_C HRESULT __stdcall PrivStgOpenStorageEx (
            const WCHAR *pwcsName,
            DWORD grfMode,
            DWORD stgfmt,               // enum
            DWORD grfAttrs,             // reserved
            void *        pSecurity,    // supports IAccessControl
            void *        pTransaction, // coordinated transactions
            REFIID riid,
            void ** ppObjectOpen);

EXTERN_C HRESULT __stdcall PrivStgCreateStorageEx (
            const WCHAR* pwcsName,
            DWORD grfMode,
            DWORD stgfmt,               // enum
            DWORD grfAttrs,             // reserved
            void *        pSecurity,    // supports IAccessControl
            void *        pTransaction, // coordinated transactions
            REFIID riid,
            void ** ppObjectOpen);


#ifndef STGFMT_STORAGE
#define STGFMT_STORAGE          0
#define STGFMT_NATIVE           1
#define STGFMT_FILE             3
#define STGFMT_ANY              4
#define STGFMT_DOCFILE          5
#endif // #ifndef STGFMT_STORAGE



EXTERN_C HRESULT __stdcall PrivPropVariantCopy ( PROPVARIANT * pvarDest, const PROPVARIANT * pvarSrc );
EXTERN_C HRESULT __stdcall PrivPropVariantClear ( PROPVARIANT * pvar );
EXTERN_C HRESULT __stdcall PrivFreePropVariantArray ( ULONG cVariants, PROPVARIANT * rgvars );

#ifdef NT5PROPS_CI_APIS
EXTERN_C ULONG   __stdcall PrivStgPropertyLengthAsVariant( IN SERIALIZEDPROPERTYVALUE const *pprop, IN ULONG cbprop, IN USHORT CodePage, IN BYTE flags );
EXTERN_C SERIALIZEDPROPERTYVALUE * __stdcall
                           PrivStgConvertVariantToProperty( IN PROPVARIANT const *pvar, IN USHORT CodePage, OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop, IN OUT ULONG *pcb, IN PROPID pid, IN BOOLEAN fVariantVectorOrArray, OPTIONAL OUT ULONG *pcIndirect );
#endif

#define StgOpenStorageEx                PrivStgOpenStorageEx
#define StgCreateStorageEx              PrivStgCreateStorageEx
#define PropVariantCopy                 PrivPropVariantCopy
#define PropVariantClear                PrivPropVariantClear
#define FreePropVariantArray            PrivFreePropVariantArray
#define StgPropertyLengthAsVariant      PrivStgPropertyLengthAsVariant
#define StgConvertVariantToProperty     PrivStgConvertVariantToProperty

#endif // #ifndef _IPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\nffdrt\args.cxx ===
#include "pch.hxx"

#include "tbtest.hxx"

DWORD g_NoOpenStg  = FALSE;
DWORD g_CreateStg  = FALSE;
DWORD g_AnyStorage = FALSE;
DWORD g_ReleaseStg = FALSE;
DWORD g_AddRefStg  = FALSE;

DWORD g_NoOpenStm  = FALSE;
DWORD g_CreateStm  = FALSE;
DWORD g_ReadStm    = FALSE;
DWORD g_WriteStm   = FALSE;
DWORD g_AddRefStm  = FALSE;

DWORD g_SetClass   = FALSE;
DWORD g_Stat       = FALSE;

DWORD g_OplockFile = FALSE;
DWORD g_UseUpdater = FALSE;
DWORD g_Pause      = FALSE;
DWORD g_SuppressTime = FALSE;
DWORD g_CheckTime  = FALSE;
DWORD g_CheckIsStg = FALSE;
WCHAR g_tszFileName[ MAX_PATH ] = { L"001.bmp" };

void
StrLower( char *sz)
{
    while('\0' != *sz)
    {
        if(*sz >= 'A' && *sz <= 'Z')
            *sz += ('a' - 'A');
        sz++;
    }
}

void
Usage(WCHAR *wszApp)
{
    wprintf(L"%s options:\n", wszApp);

    printf("  -noopenstg\tDon't Open the file with IStorage.\n");
    printf("\t\tpstg->operations are not allowed.\n");

    printf("  -createstg\tOpen IStorage file for CreateStg(CREATE).\n");
    printf("\t\t\tOtherwise open with OpenStg()\n");
    printf("  -any\t\tOpen with STGFMT_ANY.  Otherwise use STGFMT_FILE\n");
    printf("  -releasestg\t\tRelease Storage before stream R/W\n");
    printf("  -addrefstg\t\tExtra Addref and release after creation\n");

    printf("\n");

    printf("  -noopenstm\tDon't open a stream.");
    printf("  pstm->operations not allowed\n");
    printf("  -createstm\tOpen w/ CreateStm(CREATE).  (otherwise OpenStm())\n");
    printf("  -readstm\tRead from the stream.  Mode is R/W\n");
    printf("  -writestm\tWrite to the stream.  Mode is R/W\n");
    printf("  -addrefstm\t\tExtra Addref and release after creation\n");

    printf("\n");

    printf("  -setclass\tCall pstg->SetClass()\n");
    printf("  -stat\t\tCall pstg->Stat()\n");
    
    printf("\n");

    printf("  -oplock\tOpen IStorage for Oplocking\n");
    printf("  -useupdater\tStart Updater and call IFilterStatus::PreFilter()\n");
    printf("  -pause\tPause before IO operations\n");
    printf("  -suppresstime\tCall ITimeAndNotifyControl->SuppressChanges\n");
    printf("  -checktime\tGet and print the FileTime before and after test\n");
    printf("  -checkisstg\tCall StgIsStorageFile before tring to Open Storage\n");
}

void
ParseArgs(
        int cArgs,
        WCHAR **pwszArgs)
{
    WCHAR *wszApp = *pwszArgs;

    ++pwszArgs;
    while( (--cArgs > 0) && ( ('-' == **pwszArgs) || ('/' == **pwszArgs) ) )
    {
        WCHAR *wszArg = *pwszArgs;
        
        ++wszArg;            // Advance over the '-'

        _wcslwr(wszArg);

        if(0 == wcscmp(L"noopenstg", wszArg))
            g_NoOpenStg = TRUE;

        else if(0 == wcscmp(L"createstg", wszArg))
            g_CreateStg = TRUE;

        else if(0 == wcscmp(L"any", wszArg))
            g_AnyStorage = TRUE;

        else if(0 == wcscmp(L"releasestg", wszArg))
            g_ReleaseStg = TRUE;

        else if(0 == wcscmp(L"addrefstg", wszArg))
            g_AddRefStg = TRUE;

        else if(0 == wcscmp(L"noopenstream", wszArg))
            g_NoOpenStm = TRUE;

        else if(0 == wcscmp(L"createstm", wszArg))
            g_CreateStm = TRUE;

        else if(0 == wcscmp(L"readstm", wszArg))
            g_ReadStm = TRUE;

        else if(0 == wcscmp(L"writestm", wszArg))
            g_WriteStm = TRUE;

        else if(0 == wcscmp(L"addrefstm", wszArg))
            g_AddRefStm = TRUE;

        else if(0 == wcscmp(L"setclass", wszArg))
            g_SetClass = TRUE;

        else if(0 == wcscmp(L"stat", wszArg))
            g_Stat = TRUE;

        else if(0 == wcscmp(L"oplock", wszArg))
            g_OplockFile = TRUE;

        else if(0 == wcscmp(L"useupdater", wszArg))
            g_UseUpdater = TRUE;

        else if(0 == wcscmp(L"pause", wszArg))
            g_Pause = TRUE;

        else if(0 == wcscmp(L"suppresstime", wszArg))
            g_SuppressTime = TRUE;

        else if(0 == wcscmp(L"checktime", wszArg))
            g_CheckTime = TRUE;

        else if(0 == wcscmp(L"checkisstg", wszArg))
            g_CheckIsStg = TRUE;

        else
        {
            printf("unknown argument '%s'\n", *pwszArgs);
            Usage(wszApp);
            exit(0);
        }
        ++pwszArgs;
    }

    if(0 < cArgs)
    {
        wcscpy( g_tszFileName, *pwszArgs );
        ++pwszArgs;
        --cArgs;
    }

    if(0 < cArgs)
    {
        printf("extra arguments ignored: ");
        while(--cArgs >= 0)
        {
            wprintf( L" %s", *pwszArgs);
            ++pwszArgs;
        }
        Usage(wszApp);
        printf("\n");
        exit(0);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\iprop\stubapi.cxx ===
#include <pch.cxx>

#include <funcs.hxx>
#include <dfentry.hxx>



DECLARE_INFOLEVEL(ol)
#define ntfsChk(a)      olChk(a)
#define ntfsErr(a,b)    olErr(a,b)
#define ntfsDebugOut(a) olDebugOut(a)
#define ntfsAssert(a)   olAssert(a)


//+---------------------------------------------------------------------------
//
//  Function:   DfOpenStorageEx
//
//  Synopsis:   Open storage and stream objects
//
//  Arguments:  [pwcsUsersName] - pathanme of the file
//              [fCreateAPI] - create or open
//              [grfMode] - open mode flags
//              [grfAttrs] -  reserved
//              [stgfmt] -  storage format
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//  Returns:    Appropriate status code
//
//  History:    12-Jul-95   HenryLee    Created
//
//----------------------------------------------------------------------------

STDAPI DfOpenStorageEx (
            const WCHAR* pwcsUsersName,
            BOOL     fCreateAPI,         // create vs open
            DWORD    grfMode,
            DWORD    stgfmt,             // enum
            DWORD    grfAttrs,           // reserved
            STGOPTIONS *pStgOptions,  
            void *   reserved,
            WCHAR *  pwcsNameSnapshot,
            REFIID   riid,
            void **  ppObjectOpen)
{
    HRESULT sc = S_OK;

    DWORD dwFullPathLen;
    WCHAR awcsFullName[_MAX_PATH], *pwcsFile;

    //
    // The ANY and STORAGE formats recursivly call back through here
    // for the correct real format (DOCFILE, NATIVE or FILE).  We only call
    // GetFullPathName on real formats, to avoid redundant calls as we
    // recurse.
    //  This then *requires* that the ANY and STORAGE must recurse (i.e. can't
    // call NFFOpen or NSS directly) because the filename has not been
    // properly prepared.
    //
    // For STGFMT_DOCFILE, let the docfile layer handle name checking
    //
    if(STGFMT_ANY != stgfmt &&
       STGFMT_STORAGE != stgfmt &&
       STGFMT_DOCFILE != stgfmt)
    {
        dwFullPathLen = GetFullPathNameW(pwcsUsersName, _MAX_PATH,
                                         awcsFullName,&pwcsFile);

        if (dwFullPathLen == 0)
        {
            DWORD dwErr = GetLastError();

            // In some circumstances (name == " ", for instance),
            // GetFullPathNameW can return 0 and GetLastError returns 0.
            // We want to return STG_E_INVALIDNAME for these.
            if (dwErr != NOERROR)
            {
                ntfsErr(EH_Err, Win32ErrorToScode(dwErr));
            }
            else
            {
                ntfsErr(EH_Err, STG_E_INVALIDNAME);
            }
        }
        else if (dwFullPathLen > _MAX_PATH)
            ntfsErr(EH_Err, STG_E_PATHNOTFOUND);
    }

    //-----------------------------------------
    //  Switch on STGFMT_
    //      STORAGE, NATIVE, DOCFILE, FILE, ANY
    //
    switch(stgfmt)
    {

    case STGFMT_FILE:
      {
        ntfsChk( NFFOpen( awcsFullName, grfMode, NFFOPEN_NORMAL,
                          fCreateAPI, riid, ppObjectOpen) );

      }	// case STGFMT_FILE
    break;

    case STGFMT_ANY:
      {
        DWORD stgfmt=STGFMT_STORAGE;
        //
        // Attempting to CREATE a Storage with STGFMT_ANY is ambiguous,
        // On NTFS either STGFMT_NATIVE or STGFMT_FILE could be appropriate,
        // and is therefore invalid.
        //
        if (fCreateAPI)
            ntfsChk (STG_E_INVALIDPARAMETER);

        //
        //   If the file is a storage then try STGFMT_STORAGE.
        // Otherwise try STGFMT_FILE.  
        //   If StgIsStorageFile() error'ed go ahead into the STGFMT_STORAGE
        // for consistant error return values.
        //
        if( S_OK == CNtfsStorage::IsNffAppropriate( pwcsUsersName ) )
            stgfmt = STGFMT_FILE;

        sc = DfOpenStorageEx (pwcsUsersName, fCreateAPI, grfMode, stgfmt,
                                grfAttrs, pStgOptions, reserved,
                                pwcsNameSnapshot, riid, ppObjectOpen);

        ntfsChk(sc);

      }	// case STGFMT_ANY;
    break;


    default:
        ntfsErr (EH_Err, STG_E_INVALIDPARAMETER);
        break;
    }

EH_Err:
    return sc;

};

//+---------------------------------------------------------------------------
//
//  Function:	StgCreateStorageEx, public
//
//  Synopsis:	Creates a storage or stream object
//
//  Arguments:	[pwcsName] - pathname of file
//              [grfMode] - open mode flags
//              [stgfmt] -  storage format
//              [grfAttrs] -  reserved
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//
//  Returns:	Appropriate status code
//
//  History:	12-Jul-95	HenryLee   Created
//
//----------------------------------------------------------------------------

typedef HRESULT (*PFNStgCreateStorageEx)( const WCHAR* pwcsName, DWORD grfMode, DWORD stgfmt,
                                          DWORD grfAttrs, void *pSecurity, void *pTransaction,
                                          REFIID riid, void **ppObjectOpen );

typedef HRESULT (*PFNStgOpenStorageEx)( const WCHAR *pwcsName, DWORD grfMode, DWORD stgfmt,
                                        DWORD grfAttrs, void *pSecurity, void *pTransaction,
                                        REFIID riid, void **ppObjectOpen );

HINSTANCE HInstOle32()
{
    static HINSTANCE hinstOLE32 = NULL;

    if( NULL == hinstOLE32 )
        hinstOLE32 = LoadLibrary( TEXT("ole32.dll") );

    return( hinstOLE32 );
}


WINOLEAPI StgCreateStorageEx (IN const WCHAR* pwcsName,
            IN  DWORD grfMode,
            IN  DWORD stgfmt,              // enum
            IN  DWORD grfAttrs,             // reserved
            IN  STGOPTIONS * pStgOptions,
            IN  void * reserved,
            IN  REFIID riid,
            OUT void ** ppObjectOpen)
{
    HRESULT sc = S_OK;
    WCHAR awcsTmpPath[_MAX_PATH];

    ntfsChk(ValidatePtrBuffer(ppObjectOpen));
    *ppObjectOpen = NULL;

    if (grfAttrs != 0)
        ntfsErr(EH_Err, STG_E_INVALIDFLAG);

    if ((grfMode & STGM_RDWR) == STGM_READ ||
        (grfMode & (STGM_DELETEONRELEASE | STGM_CONVERT)) ==
        (STGM_DELETEONRELEASE | STGM_CONVERT))
        ntfsErr(EH_Err, STG_E_INVALIDFLAG);

    if( STGFMT_FILE == stgfmt
        &&
        (IID_IPropertySetStorage == riid || IID_IStorage == riid || IID_IPropertyBagEx == riid)
      )
    {
        ntfsChk (DfOpenStorageEx (pwcsName, TRUE, grfMode, stgfmt, grfAttrs,
                     pStgOptions, reserved, NULL, riid, ppObjectOpen));
    }
    else
    {
        static PFNStgCreateStorageEx pfnStgCreateStorageEx = NULL;

        if( NULL == pfnStgCreateStorageEx )
            pfnStgCreateStorageEx = (PFNStgCreateStorageEx) GetProcAddress( HInstOle32(), "StgCreateStorageEx" );

        if( NULL == pfnStgCreateStorageEx )
            ntfsChk( E_FAIL );

        ntfsChk( pfnStgCreateStorageEx( pwcsName, grfMode, stgfmt, grfAttrs, pStgOptions, reserved, riid, ppObjectOpen ));
    }

    ntfsDebugOut((DEB_TRACE, "Out StgCreateStorageEx => %p\n", *ppObjectOpen));
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:	StgOpenStorageEx
//
//  Synopsis:	Open storage and stream objects
//
//  Arguments:	[pwcsName] - pathanme of the file
//              [grfMode] - open mode flags
//              [grfAttrs] -  reserved
//              [stgfmt] -  storage format
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//  Returns:	Appropriate status code
//
//  History:	12-Jul-95	HenryLee    Created
//
//----------------------------------------------------------------------------

WINOLEAPI StgOpenStorageEx (IN const WCHAR* pwcsName,
            IN  DWORD grfMode,
            IN  DWORD stgfmt,              // enum
            IN  DWORD grfAttrs,             // reserved
            IN  STGOPTIONS * pStgOptions,
            IN  void * reserved,
            IN  REFIID riid,
            OUT void ** ppObjectOpen)
{
    HRESULT sc = S_OK;
    WCHAR awcsTmpPath[_MAX_PATH];
    WCHAR * pwcsNameSnapshot = NULL;

    ntfsDebugOut((DEB_TRACE, "In  StgOpenStorageEx(%ws, %p, %p, %p, %p)\n",
                pwcsName, grfMode, stgfmt, riid, ppObjectOpen));

    ntfsChk(ValidatePtrBuffer(ppObjectOpen));
    *ppObjectOpen = NULL;

    if (pStgOptions!= NULL || reserved != NULL)
        ntfsErr (EH_Err, STG_E_INVALIDPARAMETER);

    if (grfAttrs != 0)
        ntfsErr(EH_Err, STG_E_INVALIDFLAG);
    
    ntfsChk (ValidateNameW (pwcsName, _MAX_PATH));


    if( (IID_IPropertySetStorage == riid || IID_IStorage == riid || IID_IPropertyBagEx == riid)
        &&
        ( STGFMT_FILE == stgfmt
          ||
          STGFMT_ANY == stgfmt && S_OK != StgIsStorageFile(pwcsName)
        )
      )
    {
        ntfsChk (DfOpenStorageEx (pwcsName, FALSE, grfMode, stgfmt, grfAttrs,
                 pStgOptions, reserved, pwcsNameSnapshot, riid, ppObjectOpen));
    }
    else
    {
        static PFNStgOpenStorageEx pfnStgOpenStorageEx = NULL;

        if( NULL == pfnStgOpenStorageEx )
            pfnStgOpenStorageEx = (PFNStgOpenStorageEx) GetProcAddress( HInstOle32(), "StgOpenStorageEx" );
        if( NULL == pfnStgOpenStorageEx )
            ntfsChk( E_FAIL );

        ntfsChk( pfnStgOpenStorageEx( pwcsName, grfMode, stgfmt, grfAttrs, pStgOptions, reserved,
                                      riid, ppObjectOpen ));
    }

    ntfsDebugOut((DEB_TRACE, "Out StgOpenStorageEx => %p\n", *ppObjectOpen));
EH_Err:

    return sc;
}


// Copied from stg\docfile\funcs.cxx
#ifdef WIN32
SCODE Win32ErrorToScode(DWORD dwErr)
{
    olAssert((dwErr != NO_ERROR) &&
	     aMsg("Win32ErrorToScode called on NO_ERROR"));

    SCODE sc = STG_E_UNKNOWN;

    switch (dwErr)
    {
    case ERROR_INVALID_FUNCTION:
	sc = STG_E_INVALIDFUNCTION;
	break;
    case ERROR_FILE_NOT_FOUND:
	sc = STG_E_FILENOTFOUND;
	break;
    case ERROR_PATH_NOT_FOUND:
	sc = STG_E_PATHNOTFOUND;
	break;
    case ERROR_TOO_MANY_OPEN_FILES:
	sc = STG_E_TOOMANYOPENFILES;
	break;
    case ERROR_ACCESS_DENIED:
    case ERROR_NETWORK_ACCESS_DENIED:
	sc = STG_E_ACCESSDENIED;
	break;
    case ERROR_INVALID_HANDLE:
	sc = STG_E_INVALIDHANDLE;
	break;
    case ERROR_NOT_ENOUGH_MEMORY:
	sc = STG_E_INSUFFICIENTMEMORY;
	break;
    case ERROR_NO_MORE_FILES:
	sc = STG_E_NOMOREFILES;
	break;
    case ERROR_WRITE_PROTECT:
	sc = STG_E_DISKISWRITEPROTECTED;
	break;
    case ERROR_SEEK:
	sc = STG_E_SEEKERROR;
	break;
    case ERROR_WRITE_FAULT:
	sc = STG_E_WRITEFAULT;
	break;
    case ERROR_READ_FAULT:
	sc = STG_E_READFAULT;
	break;
    case ERROR_SHARING_VIOLATION:
	sc = STG_E_SHAREVIOLATION;
	break;
    case ERROR_LOCK_VIOLATION:
	sc = STG_E_LOCKVIOLATION;
	break;
    case ERROR_HANDLE_DISK_FULL:
    case ERROR_DISK_FULL:
	sc = STG_E_MEDIUMFULL;
	break;
    case ERROR_FILE_EXISTS:
    case ERROR_ALREADY_EXISTS:
	sc = STG_E_FILEALREADYEXISTS;
	break;
    case ERROR_INVALID_PARAMETER:
	sc = STG_E_INVALIDPARAMETER;
	break;
    case ERROR_INVALID_NAME:
    case ERROR_BAD_PATHNAME:
    case ERROR_FILENAME_EXCED_RANGE:
	sc = STG_E_INVALIDNAME;
	break;
    case ERROR_INVALID_FLAGS:
	sc = STG_E_INVALIDFLAG;
	break;
    default:
	sc = WIN32_SCODE(dwErr);
	break;
    }

    return sc;
}
#endif


//+--------------------------------------------------------------
//
//  Function:   ValidateSNB, private
//
//  Synopsis:   Validates SNB memory
//
//  Arguments:  [snb] - SNB
//
//  Returns:    Appropriate status code
//
//  History:    10-Jun-92       DrewB   Created
//
//---------------------------------------------------------------

#include <docfilep.hxx>

// ***** From stg\docfile\funcs.cxx
SCODE ValidateSNB(SNBW snb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  ValidateSNB(%p)\n", snb));
    for (;;)
    {
	olChk(ValidatePtrBuffer(snb));
	if (*snb == NULL)
	    break;
	olChk(ValidateNameW(*snb, CWCMAXPATHCOMPLEN));
	snb++;
    }
    olDebugOut((DEB_ITRACE, "Out ValidateSNB\n"));
    return S_OK;
EH_Err:
    return sc;
}



//+--------------------------------------------------------------
//
//  Function:   CheckName, public
//
//  Synopsis:   Checks name for illegal characters and length
//
//  Arguments:  [pwcsName] - Name
//
//  Returns:    Appropriate status code
//
//  History:    11-Feb-92       DrewB   Created
//                              04-Dec-95               SusiA   Optimized
//
//---------------------------------------------------------------

// ***** From stg\docfile\funcs.cxx
#ifdef OLEWIDECHAR
SCODE CheckName(WCHAR const *pwcsName)
{
    LPCWSTR pChar;
    
    //Each character's position in the array is detrmined by its ascii numeric
    //value.  ":" is 58, so bit 58 of the array will be 1 if ":" is illegal.
    //32bits per position in the array, so 58/32 is in Invalid[1].
    //58%32 = 28th bit ( 0x04000000 ) in Invalid[1].

    /* Invalid characters:                               :  /  !   \ */
    static ULONG const Invalid[128/32] =
    {0x00000000,0x04008002,0x10000000,0x00000000};

    SCODE sc = STG_E_INVALIDNAME;
    olDebugOut((DEB_ITRACE, "In  CheckName(%ws)\n", pwcsName));

    __try
    {
        for (pChar = (LPCWSTR)pwcsName;
             pChar <= (LPCWSTR) &pwcsName[CWCMAXPATHCOMPLEN];
             pChar++)
        {
            if (*pChar == L'\0')
            {
                sc = S_OK;
                break;                  // Success
            }

            // Test to see if this is an invalid character
            if (*pChar < 128 &&
                // All values above 128 are valid
                (Invalid[*pChar / 32] & (1 << (*pChar % 32))) != 0)
                // check to see if this character's bit is set
            {
                break;                  // Failure: invalid Char
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
    }

    olDebugOut((DEB_ITRACE, "Out CheckName\n"));
    return sc;
    
}
#endif



/*
// Forwarders to the nt5props.dll version of the property APIs.

EXTERN_C HRESULT
PrivPropVariantCopy ( PROPVARIANT * pvarDest, const PROPVARIANT * pvarSrc )
{
    return( PropVariantCopy( pvarDest, pvarSrc ));
}

EXTERN_C HRESULT
PrivPropVariantClear ( PROPVARIANT * pvar )
{
    return( PropVariantClear( pvar ));
}

EXTERN_C HRESULT
PrivFreePropVariantArray ( ULONG cVariants, PROPVARIANT * rgvars )
{
    return( FreePropVariantArray( cVariants, rgvars ));
}


EXTERN_C ULONG
PrivStgPropertyLengthAsVariant( IN SERIALIZEDPROPERTYVALUE const *pprop,
                               IN ULONG cbprop, IN USHORT CodePage,
                               IN BYTE flags )
{
    return( StgPropertyLengthAsVariant( pprop, cbprop, CodePage, flags ));
}


EXTERN_C SERIALIZEDPROPERTYVALUE *
PrivStgConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVectorOrArray,  // Used for recursive calls
    OPTIONAL OUT ULONG *pcIndirect)
{
    return( StgConvertVariantToProperty( pvar, CodePage, pprop, pcb, pid, fVariantVectorOrArray, pcIndirect ));
}

*/
//+--------------------------------------------------------------
//
//  Function:   VerifyPerms, private
//
//  Synopsis:   Checks flags to see if they are valid
//
//  Arguments:  [grfMode] - Permissions
//              [fRoot] - TRUE if checking root storage
//
//  Returns:    Appropriate status code
//
//  Notes:      This routine is called when opening a root storage
//              or a subelement.  When changing root permissions,
//              use the fRoot flag to preserve compatibily for
//              return codes when opening subelements
//
//  History:    19-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE VerifyPerms(DWORD grfMode, BOOL fRoot)
{
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  VerifyPerms(%lX)\n", grfMode));

    // Check for valid flags
    if ((grfMode & STGM_RDWR) > STGM_READWRITE ||
	(grfMode & STGM_DENY) > STGM_SHARE_DENY_NONE ||
	(grfMode & ~(STGM_RDWR | STGM_DENY | STGM_DIRECT | STGM_TRANSACTED |
		     STGM_PRIORITY | STGM_CREATE | STGM_CONVERT |
		     STGM_NOSCRATCH |
#ifndef DISABLE_NOSNAPSHOT
		     STGM_NOSNAPSHOT |
#endif
#if WIN32 >= 300
		     STGM_EDIT_ACCESS_RIGHTS |
#endif
		     STGM_FAILIFTHERE | STGM_DELETEONRELEASE)))
	olErr(EH_Err, STG_E_INVALIDFLAG);

    // If priority is specified...
    if (grfMode & STGM_PRIORITY)
    {
	// Make sure no priority-denied permissions are specified
	if ((grfMode & STGM_RDWR) == STGM_WRITE ||
	    (grfMode & STGM_RDWR) == STGM_READWRITE ||
	    (grfMode & STGM_TRANSACTED))
	    olErr(EH_Err, STG_E_INVALIDFLAG);
    }

    // Check to make sure only one existence flag is specified
    // FAILIFTHERE is zero so it can't be checked
    if ((grfMode & (STGM_CREATE | STGM_CONVERT)) ==
	(STGM_CREATE | STGM_CONVERT))
	olErr(EH_Err, STG_E_INVALIDFLAG);

    // If not transacted and not priority, you can either be
    // read-only deny write or read-write deny all
    if ((grfMode & (STGM_TRANSACTED | STGM_PRIORITY)) == 0)
    {
	if ((grfMode & STGM_RDWR) == STGM_READ)
	{
	    //  we're asking for read-only access

	    if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE &&
#ifdef DIRECTWRITERLOCK
		    (!fRoot || (grfMode & STGM_DENY) != STGM_SHARE_DENY_NONE) &&
#endif
		(grfMode & STGM_DENY) != STGM_SHARE_DENY_WRITE)
	    {
		//  Can't allow others to have write access
		olErr(EH_Err, STG_E_INVALIDFLAG);
	    }
	}
	else
	{
	    //  we're asking for write access

#ifdef DIRECTWRITERLOCK
	    if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE &&
            (!fRoot || (grfMode & STGM_DENY) != STGM_SHARE_DENY_WRITE))
#else
	    if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE)
#endif
	    {
		//  Can't allow others to have any access
		olErr(EH_Err, STG_E_INVALIDFLAG);
	    }
	}
    }

    //If this is not a root open, we can't pass STGM_NOSCRATCH or
    // STGM_NOSNAPSHOT
    if (!fRoot && (grfMode & (STGM_NOSCRATCH | STGM_NOSNAPSHOT)))
    {
        olErr(EH_Err, STG_E_INVALIDFLAG);
    }
    
    if (grfMode & STGM_NOSCRATCH)
    {
	if (((grfMode & STGM_RDWR) == STGM_READ) ||
	    ((grfMode & STGM_TRANSACTED) == 0))
	{
	    olErr(EH_Err, STG_E_INVALIDFLAG);
	}
    }

    if (grfMode & STGM_NOSNAPSHOT)
    {
	if (((grfMode & STGM_DENY) == STGM_SHARE_EXCLUSIVE) ||
	    ((grfMode & STGM_DENY) == STGM_SHARE_DENY_WRITE) ||
	    ((grfMode & STGM_TRANSACTED) == 0) ||
	    ((grfMode & STGM_NOSCRATCH) != 0) ||
	    ((grfMode & STGM_CREATE) != 0) ||
	    ((grfMode & STGM_CONVERT) != 0))
	{
	    olErr(EH_Err, STG_E_INVALIDFLAG);
	}
    }

    olDebugOut((DEB_ITRACE, "Out VerifyPerms\n"));
    // Fall through
EH_Err:
    return sc;
}



//+--------------------------------------------------------------
//
//  Function:   StgIsStorageFileHandle, private
//
//  Synopsis:   Determines whether a handle is open on a storage file.
//              Spun off from StgIsStorageFile.  Internaly we use this
//
//  Arguments:  [hf] - Open File Handle (caller must seek it to 0)
//
//  Returns:    S_OK, S_FALSE or error codes
//
//  History:    07-May-98   MikeHill   Created
//              05-June-98  BChapman   Return Errors not just S_FALSE.
//                                     Add optional Overlapped pointer.
//
//---------------------------------------------------------------


STDAPI StgIsStorageFileHandle( HANDLE hf, LPOVERLAPPED povlp )
{
    DWORD cbRead;
    BYTE stgHeader[sizeof(SStorageFile)];   
    SCODE sc;
    LONG status;
    OVERLAPPED ovlp;
    
    FillMemory( stgHeader, sizeof(SStorageFile), 0xDE );

    if (povlp == NULL)
    {
	ovlp.Offset = 0;
	ovlp.OffsetHigh = 0;
	ovlp.hEvent = NULL;
    }

    if( !ReadFile( hf,
		   &stgHeader,
		   sizeof( stgHeader ),
		   &cbRead,
		   (povlp == NULL) ? &ovlp : povlp ) )
    {
        if( NULL != povlp )
        {
            status = GetLastError();
            if( ERROR_IO_PENDING == status)
            {
                status = ERROR_SUCCESS;
                if( !GetOverlappedResult( hf, povlp, &cbRead, TRUE ) )
                    status = GetLastError();
            }
            if(ERROR_SUCCESS != status && ERROR_HANDLE_EOF != status)
                olChk( HRESULT_FROM_WIN32( status ) );
        }
        else
            olErr( EH_Err, LAST_STG_SCODE );
    }

    // Don't worry about short reads.  If the read is short then
    // the signature checks will fail.
    
    sc = CheckSignature( ((SStorageFile*)stgHeader)->abSig );
    if(S_OK == sc)
        goto EH_Err;    // Done, return "Yes"

    olChk(sc);

    // It didn't error.  sc != S_OK then it
    // Must be S_FALSE.
    olAssert(S_FALSE == sc);

EH_Err:
    if( (STG_E_OLDFORMAT == sc) || (STG_E_INVALIDHEADER == sc) )
        sc = S_FALSE;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckSignature, private
//
//  Synopsis:   Checks the given memory against known signatures
//
//  Arguments:  [pb] - Pointer to memory to check
//
//  Returns:    S_OK - Current signature
//              S_FALSE - Beta 2 signature, but still successful
//              Appropriate status code
//
//  History:    23-Jul-93       DrewB   Created from header.cxx code
//
//----------------------------------------------------------------------------

//Identifier for first bytes of Beta 1 Docfiles
const BYTE SIGSTG_B1[] = {0xd0, 0xcf, 0x11, 0xe0, 0x0e, 0x11, 0xfc, 0x0d};
const USHORT CBSIGSTG_B1 = sizeof(SIGSTG_B1);

//Identifier for first bytes of Beta 2 Docfiles
const BYTE SIGSTG_B2[] = {0x0e, 0x11, 0xfc, 0x0d, 0xd0, 0xcf, 0x11, 0xe0};
const BYTE CBSIGSTG_B2 = sizeof(SIGSTG_B2);

SCODE CheckSignature(BYTE *pb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CheckSignature(%p)\n", pb));

    // Check for ship Docfile signature first
    if (memcmp(pb, SIGSTG, CBSIGSTG) == 0)
        sc = S_OK;

    // Check for Beta 2 Docfile signature
    else if (memcmp(pb, SIGSTG_B2, CBSIGSTG_B2) == 0)
        sc = S_FALSE;

    // Check for Beta 1 Docfile signature
    else if (memcmp(pb, SIGSTG_B1, CBSIGSTG_B1) == 0)
        sc = STG_E_OLDFORMAT;

    else
        sc = STG_E_INVALIDHEADER;

    olDebugOut((DEB_ITRACE, "Out CheckSignature => %lX\n", sc));
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   dfwcsnicmp, public
//
//  Synopsis:   wide character string compare that interoperates with what
//              we did on 16-bit windows.
//
//  Arguments:  [wcsa] -- First string
//              [wcsb] -- Second string
//              [len] -- Length to compare to
//
//  Returns:    > 0 if wcsa > wcsb
//              < 0 if wcsa < wcsb
//              0 is wcsa == wcsb
//
//  History:    11-May-95       PhilipLa        Created
//                              22-Nov-95       SusiA           Optimize comparisons
//
//  Notes:      This function is necessary because on 16-bit windows our
//              wcsnicmp function converted everything to uppercase and
//              compared the strings, whereas the 32-bit runtimes convert
//              everything to lowercase and compare.  This means that the
//              sort order is different for string containing [\]^_`
//
//----------------------------------------------------------------------------

int dfwcsnicmp(const WCHAR *wcsa, const WCHAR *wcsb, size_t len)
{
    if (!len)
        return 0;

    while (--len && *wcsa &&
                   ( *wcsa == *wcsb ||
                     CharUpperW((LPWSTR)*wcsa) == CharUpperW((LPWSTR)*wcsb)))
    {
        wcsa++;
        wcsb++;
    }
    return (int)(LONG_PTR)CharUpperW((LPWSTR)*wcsa) -
           (int)(LONG_PTR)CharUpperW((LPWSTR)*wcsb);
}

//+---------------------------------------------------------------------------
//
//  Member:     ValidateNameW, public
//
//  Synopsis:   Validate that a name is valid and no longer than the
//              size specified.
//
//  Arguments:  [pwcsName] -- Pointer to wide character string
//              [cchMax] -- Maximum length for string
//
//  Returns:    Appropriate status code
//
//  History:    23-Nov-98       PhilipLa        Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE ValidateNameW(LPCWSTR pwcsName, UINT cchMax)
{
    SCODE sc = S_OK;

    if (pwcsName == NULL)
        sc = STG_E_INVALIDNAME;
    else
    {
        __try
        {
                if ((UINT)lstrlenW(pwcsName) >= cchMax)
                    sc = STG_E_INVALIDNAME;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            sc = STG_E_INVALIDNAME;
        }
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\iprop\dllmain.cxx ===
//+============================================================================
//
//  File:       dllmain.cxx
//
//  Purpose:    This file provides the registration and deregistration 
//              functions for the IProp DLL:  DllRegisterServer and
//              DllUnregisterServer.  These two functions register/
//              deregister the property set marshaling code:
//              IPropertySetStorage, IPropertyStorage, IEnumSTATPROPSETSTG,
//              and IEnumSTATPROPSTG.  Note that this registration is
//              different from the typical server registration in that
//              it only registers the marshaling code, it does not 
//              register an instantiable COM server.  Also, no registration
//              takes place if OLE32 is already registered to perform
//              this marshaling.
//
//              The actual DllRegisterServer and DllUnregisterServer
//              implementations are at the end of this file.  First,
//              several helper functions are defined.
//
//+============================================================================

//  --------
//  Includes
//  --------

#include <pch.cxx>
#include <tchar.h>

// The following is from "olectl.h".  That file couldn't simply
// be included, however, because it isn't compatible with the
// special objidl.h and wtypes.h used by IProp DLL.

#define SELFREG_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0200)
#define SELFREG_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x020F)
#define SELFREG_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0200)
#define SELFREG_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x020F)

#define SELFREG_E_TYPELIB           (SELFREG_E_FIRST+0)
#define SELFREG_E_CLASS             (SELFREG_E_FIRST+1)

//  -------
//  Globals
//  -------

// Important DLL names.
const LPTSTR tszNameDll  = TEXT( "IProp.dll" );

// Registry entry descriptions
const LPTSTR tszOle32PSFactoryClsid     = TEXT( "{00000320-0000-0000-C000-000000000046}" );
const LPTSTR tszNamePropertySetStorage  = TEXT( "IPropertySetStorage" );
const LPTSTR tszNamePropertyStorage     = TEXT( "IPropertyStorage" );
const LPTSTR tszNameIEnumSTATPROPSETSTG = TEXT( "IEnumSTATPROPSETSTG" );
const LPTSTR tszNameIEnumSTATPROPSTG    = TEXT( "IEnumSTATPROPSTG" );

// GUIDs in Registry format
const LPTSTR tszGuidPropertySetStorage  = TEXT( "{0000013A-0000-0000-C000-000000000046}" );
const LPTSTR tszGuidPropertyStorage     = TEXT( "{00000138-0000-0000-C000-000000000046}" );
const LPTSTR tszGuidIEnumSTATPROPSETSTG = TEXT( "{0000013B-0000-0000-C000-000000000046}" );
const LPTSTR tszGuidIEnumSTATPROPSTG    = TEXT( "{00000139-0000-0000-C000-000000000046}" );

//+----------------------------------------------------------------------------
//
//  Function:   UpdateKeyAndSubKey
//  
//  Synopsis:   This function either creates or deletes first
//              a key and un-named value under HKEY_CLASSES_ROOT,
//              then a sub-key and associated un-named value.  The
//              caller indicates whether a create or delete should occur.
//
//              However, the caller may specify that nothing be done
//              if the sub-key exists and already has a specific
//              un-named REG_SZ value.
//
//  Inputs:     [const LPTSTR] tszMainKey (in)
//                  The name of the key under HKEY_CLASSES_ROOT.
//              [const LPTSTR] tszMainKeyDescription (in)
//                  The un-named REG_SZ value under this key (not necessary
//                  if fDelete is true).
//              [const LPTSTR] tszSubKey (in)
//                  The name of the key under the first key.
//              [const LPTSTR] tszSubKeyDescription (in)
//                  The un-named REG_SZ value to write under this sub-key
//                  (not necessary if fDelete is true).
//              [const LPTSTR] tszSubKeyCheck (in)
//                  If non-NULL, and the subkey already exists, see if
//                  this string matches an un-named REG_SZ value in 
//                  the sub-key.  If so, abort the operation and return
//                  ERROR_ALREADY_EXISTS.
//              [BOOL] fDelete
//                  If TRUE, delete the keys, if FALSE, create them.
//                  But this is ignored if tszSubKeyCheck matches
//                  (in which case nothing happens).
//
//  Returns:    [long] A GetLastError value.
//
//+----------------------------------------------------------------------------

long
UpdateKeyAndSubKey( const LPTSTR tszMainKey,
                    const LPTSTR tszMainKeyDescription,
                    const LPTSTR tszSubKey,
                    const LPTSTR tszSubKeyDescription,
                    const LPTSTR tszSubKeyCheck,
                    BOOL  fDelete )
{
    //  ------
    //  Locals
    //  ------

    long lResult = ERROR_SUCCESS;
    DWORD dwDisposition;

    HKEY hkeyMain = NULL;   // E.g. "HKEY_CLASSES_ROOT\\CLSID\\{.....}"
    HKEY hkeySub = NULL;    // E.g. ..."InProcServer32"

    //  -------------
    //  Open the keys
    //  -------------

    // Are we opening for delete?

    if( fDelete )
    {
        // Yes - we're deleting.  We'll just attempt to do an Open.
        dwDisposition = REG_OPENED_EXISTING_KEY;

        lResult = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                                tszMainKey,
                                0L,
                                KEY_ALL_ACCESS,
                                &hkeyMain );
        
        if( ERROR_SUCCESS == lResult )
        {
            lResult = RegOpenKeyEx( hkeyMain,
                                    tszSubKey,
                                    0L,
                                    KEY_ALL_ACCESS,
                                    &hkeySub );
        }

        if( ERROR_FILE_NOT_FOUND == lResult )
            lResult = ERROR_SUCCESS;
        else if( ERROR_SUCCESS != lResult )
            goto Exit;

    }   // if( fDelete )

    else
    {
        // We're not opening for delete.  So we'll use RegCreateKey,
        // which does an Open if the key exists, and a Create otherwise.

        lResult = RegCreateKeyEx( HKEY_CLASSES_ROOT,
                                  tszMainKey,
                                  0L,
                                  NULL,
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hkeyMain,
                                  &dwDisposition );
        if( lResult != ERROR_SUCCESS ) goto Exit;

        // Open the sub-key.

        lResult = RegCreateKeyEx( hkeyMain,
                                  tszSubKey,
                                  0L,
                                  NULL,
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hkeySub,
                                  &dwDisposition );
        if( ERROR_SUCCESS != lResult ) goto Exit;

    }   // if( fDelete ) ... else

    //  --------------------------
    //  Do we need to do anything?
    //  --------------------------

    // Does it look like we might not need to do anything?

    if( NULL != tszSubKeyCheck      // The caller said to check first
        &&
        NULL != hkeySub             // We Created or Opened a sub-key
        &&                          // Specifically, it was an Open.
        REG_OPENED_EXISTING_KEY	== dwDisposition )
    {
        // Yes - we need to see if the key already contains
        // tszSubKeyCheck.  If so, then we're done.

        DWORD dwType = 0;
        TCHAR tszData[ MAX_PATH ];
        DWORD dwDataSize = sizeof( tszData );

        // Is there an un-named value in this key?

        lResult = RegQueryValueEx( hkeySub,
                                   NULL,            // Name
                                   NULL,            // Reserved
                                   &dwType,         // E.g. REG_SZ
                                   (LPBYTE) tszData,// Return value
                                   &dwDataSize );   // In: size of buf. Out: size of value

        // We should have gotten a success-code or a not-extant code
        if( ERROR_SUCCESS != lResult
            &&
            ERROR_FILE_NOT_FOUND != lResult )
        {
            goto Exit;
        }

        // If we got an extant SZ value that matches tszSubKeyCheck,
        // then there's nothing we need do.

        if( ERROR_SUCCESS == lResult
            &&
            REG_SZ == dwType
            &&
            !_tcsicmp( tszData, tszSubKeyCheck )
          )
        {
            lResult = ERROR_ALREADY_EXISTS;
            goto Exit;
        }

    }   // if( REG_OPENED_EXISTING_KEY	== dwDisposition ...

    //  --------------------------
    //  Delete keys, or set values
    //  --------------------------

    if( fDelete )
    {
        // Reset the result code, since the code below may not set it.
        lResult = ERROR_SUCCESS;

        // We're doing a delete.  First, delete the sub-key, which
        // will delete any values.  If there was no subkey, hkeySub will
        // be NULL.

        if( NULL != hkeySub )
        {
            CloseHandle( hkeySub );
            hkeySub = NULL;

            lResult = RegDeleteKey( hkeyMain,
                                    tszSubKey );
            if( ERROR_SUCCESS != lResult ) goto Exit;
        }

        // Second, delete the main key

        if( NULL != hkeyMain )
        {
            CloseHandle( hkeyMain );
            hkeyMain = NULL;

            lResult = RegDeleteKey( HKEY_CLASSES_ROOT,
                                    tszMainKey );
            if( ERROR_SUCCESS != lResult ) goto Exit;
        }

    }	// if( fDelete )

    else
    {
        // We're adding to the Registry.  The two keys are now
        // created & opened, so we can add the REG_SZ values.

        // The REG_SZ value for the main key.
        lResult = RegSetValueEx(hkeyMain,
                                NULL,
                                0L,
                                REG_SZ,
                                (const BYTE *) tszMainKeyDescription,
                                sizeof(TCHAR) * (1 + _tcslen(tszMainKeyDescription) ));
        if( ERROR_SUCCESS != lResult ) goto Exit;

        // The REG_SZ value for the sub-key.
        lResult = RegSetValueEx(hkeySub,
                                NULL, 0L,
                                REG_SZ,
                                (const BYTE *) tszSubKeyDescription,
                                sizeof(TCHAR) * (1 + _tcslen(tszSubKeyDescription) ));
        if( ERROR_SUCCESS != lResult ) goto Exit;

    }	// if( fDelete ) ... else

    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != hkeySub )
        CloseHandle( hkeySub );

    if( NULL != hkeyMain )
        CloseHandle( hkeyMain );

    return( lResult );

}   // WriteKeyAndSubKey()


//+----------------------------------------------------------------------------
//
//  Function:   RegisterForMarshaling
//
//  Synopsis:   This function takes the GUID ane name of an interface
//              for which MIDL-generated marshaling code exists in the
//              caller-specified DLL.  First we try to update the
//              CLSID entries, but we'll fail this if the entries already
//              exist and reference OLE32 (OLE32 has better marshaling
//              code).  If this doesn't fail, then we'll update the
//              Interface entries.
//
//              The caller specifies if this "update" of the registry
//              is a write or a delete.  This this routine can be used
//              in either a registration or a de-registration.
//
//  Inputs:     [const LPTSTR] tszGuid (in)
//                  The GUID in registery format ("{...-...-...}")
//              [const LPTSTR] tszName (in)
//                  The name of the interface
//              [const LPTSTR] tszDllPath (in)
//                  The complete path and filename of the DLL which contains
//                  the marshaling code.
//              [BOOL] fDelete (in)
//                  Determines if we add to the Registry or delete from it.
//
//  Returns:    [long] a GetLastError() value
//
//+----------------------------------------------------------------------------


long
RegisterForMarshaling( const LPTSTR tszGuid,
                       const LPTSTR tszName,
                       const LPTSTR tszDllPath,
                       BOOL fDelete )
{
    //  ------
    //  Locals
    //  ------

    long lResult;
    TCHAR tszMainKey[ MAX_PATH ];

    //  -----------------------------------
    //  Update HKEY_CLASSES_ROOT\Interfaces
    //  -----------------------------------

    // Calculate the key name name
    _tcscpy( tszMainKey, TEXT( "Interface\\" ));
    _tcscat( tszMainKey, tszGuid );

    // Update the registry, but only if there isn't a current
    // entry pointing to OLE32's proxy/stub factory.

    lResult = UpdateKeyAndSubKey( tszMainKey,
                                  tszName,
                                  TEXT( "ProxyStubClsid32" ),
                                  tszGuid,
                                  tszOle32PSFactoryClsid,
                                  fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;


    //  ------------------------------
    //  Update HKEY_CLASSES_ROOT\CLSID
    //  ------------------------------

    // Calculate the name.
    _tcscpy( tszMainKey, TEXT( "CLSID\\" ));
    _tcscat( tszMainKey, tszGuid );

    // Update the entries.  This will add the path (if !fDelete) or remove
    // the registry entry (if fDelete) regardless of the current state
    // of the key; if we weren't supposed to remove it, the previous
    // call to UpdateKeyAndSubKey would have returned an error.

    lResult = UpdateKeyAndSubKey( tszMainKey,
                                  tszName,
                                  TEXT( "InprocServer32" ),
                                  tszDllPath, 
                                  NULL, // Add/delete, regardless of what exists
                                  fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( ERROR_ALREADY_EXISTS == lResult )
    {
        propDbg(( DEB_WARN, "IProp DLL UpdateKeyAndSubKey:  Entry already exists\n" ));
        lResult = ERROR_SUCCESS;
    }

    return( lResult );

}   // RegisterForMarshaling()


//+----------------------------------------------------------------------------
//
//  Function:   RegisterServer
//  
//  Synopsis:   This routine can be used with both DllRegisterServer and
//              DllUnregisterServer.  It adds/deletes IPropertySetStorage
//              IPropertyStorage, IEnumSTATPROPSETSTG, and IEnumSTATPROPSTG.
//
//  Inputs:     [BOOL] fDelete (in)
//                  Indicates whether the registry entries should be added
//                  or removed.
//
//  Returns:    [HRESULT]
//
//+----------------------------------------------------------------------------


STDAPI RegisterServer( BOOL fDelete )
{
    //  ------
    //  Locals
    //  ------

    LONG  lResult;

    //  -----
    //  Begin
    //  -----

    // Register IPropertySetStorage
    lResult = RegisterForMarshaling( tszGuidPropertySetStorage,
                                     tszNamePropertySetStorage,
                                     tszNameDll,
                                     fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;

    // Register IPropertyStorage
    lResult = RegisterForMarshaling( tszGuidPropertyStorage,
                                     tszNamePropertyStorage,
                                     tszNameDll,
                                     fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;

    // Register IEnumSTATPROPSETSTG
    lResult = RegisterForMarshaling( tszGuidIEnumSTATPROPSETSTG,
                                     tszNameIEnumSTATPROPSETSTG,
                                     tszNameDll,
                                     fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;

    // Register IEnumSTATPROPSTG
    lResult = RegisterForMarshaling( tszGuidIEnumSTATPROPSTG,
                                     tszNameIEnumSTATPROPSTG,
                                     tszNameDll,
                                     fDelete );
    if( ERROR_SUCCESS != lResult ) goto Exit;


    //  ----
    //  Exit
    //  ----

Exit:

    if( ERROR_SUCCESS != lResult )
    {
        propDbg(( DEB_ERROR, "IProp DLL RegisterServer failed (%lu)\n", lResult ));
        return( SELFREG_E_CLASS );
    }
    else
    {
        return( S_OK );
    }

}   // RegisterServer()



//+----------------------------------------------------------------------------
//
//  Function:   DllRegisterServer & DllUnregisterServer
//
//  Synopsis:   These routines are the standard DLL registration entry
//              points for a self-registering in-proc COM server.  They
//              are used to register the property set marshaling code.
//              These routines are called, for example,
//              by a setup program during installation and de-installation,
//              respectively.
//
//+----------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
    return( RegisterServer( FALSE ));
}

STDAPI DllUnregisterServer()
{
    return( RegisterServer( TRUE ));
}


void InitializeDebugging();
void UnInitializeDebugging();

BOOL WINAPI
DllMain( HANDLE hinst, DWORD dwReason, LPVOID lpv )
{
    #if DBG == 1
    {
        if( DLL_PROCESS_ATTACH == dwReason )
            InitializeDebugging();
        else if( DLL_PROCESS_DETACH == dwReason )
            UnInitializeDebugging();
    }
    #endif // #if DBG == 1

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\iprop\assert.cxx ===
// This file provides dbgout implementations for use when the property
// set code is built into a standalone dll (so that we don't require a
// checked OLE32).

#include <pch.cxx>

#if DBG == 1

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

static CRITICAL_SECTION s_csMessageBuf;
static char g_szMessageBuf[500];		// this is the message buffer

#include <dprintf.h>            // w4printf, w4dprintf prototypes

static int _cdecl w4dprintf(const char *format, ...)
{
	int ret;

    va_list va;
    va_start(va, format);
	ret = w4vdprintf(format, va);
    va_end(va);

	return ret;
}


static int _cdecl w4vdprintf(const char *format, va_list arglist)
{
	int ret;

	EnterCriticalSection(&s_csMessageBuf);
	ret = vsprintf(g_szMessageBuf, format, arglist);
	OutputDebugStringA(g_szMessageBuf);
	LeaveCriticalSection(&s_csMessageBuf);
	return ret;
}


void APINOT vdprintf(unsigned long ulCompMask,
              char const *pszComp,
              char const *ppszfmt,
              va_list     pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {

        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);

            // Chicago and Win32s debugging is usually through wdeb386
            // which needs carriage returns
#if WIN32 == 50 || WIN32 == 200
            w4dprintf("\r");
#endif
        }
    }
}



//  Private version of RtlAssert so debug versions really assert on free builds.

VOID PropAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
    CHAR szMessage[ 512 ];
    int nResponse;

    sprintf( szMessage, "File:\t%s\nLine:\t%d\nMessage:\t%s\n"
                        "\nPress Abort to kill the process, Retry to debug",
             FileName, LineNumber, NULL == Message ? "" : Message );

    nResponse = MessageBoxA( NULL, szMessage, "Assertion failed in NT5Props.dll", MB_ABORTRETRYIGNORE );
    if( IDRETRY == nResponse )
        DebugBreak();
    else if( IDABORT == nResponse )
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );

    return;
    

    /*
    char Response[ 2 ] = { "B" };   // In MSDEV there is no input, so default to break

    for ( ; ; ) {
        DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

        DbgPrompt( "Break, Ignore, terminate Process, Sleep 30 seconds, or terminate Thread (bipst)? ",
                   Response, sizeof( Response));
        switch ( toupper(Response[0])) {
        case 'B':
            DbgBreakPoint();
            break;
        case 'I':
            return;
            break;
        case 'P':
            NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
            break;
        case 'S':
            Sleep( 30000L);
            break;
        case 'T':
            NtTerminateThread( NtCurrentThread(), STATUS_UNSUCCESSFUL );
            break;
        default:
            DbgBreakPoint();
            break;
        }
    }

    DbgBreakPoint();
    NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
    */
}







void
InitializeDebugging()
{
    CHAR szValue[ 30 ];

    InitializeCriticalSection( &s_csMessageBuf );

    if (GetProfileStringA("CairOLE InfoLevels", // section
                          "prop",               // key
                          "3",                  // default value
                          szValue,              // return buffer
                          sizeof(szValue))) 
    {
        propInfoLevel = DEB_ERROR | DEB_WARN | strtoul (szValue, NULL, 16);
    }    

}

void
UnInitializeDebugging()
{
    DeleteCriticalSection( &s_csMessageBuf );
}





#endif // #if DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\nffdrt\main.cxx ===
#include "pch.hxx"

#include "tbtest.hxx"

#define OPEN     1
#define CREATE   2

extern "C" CLSID CLSID_ThumbnailUpdater;

EXTERN_C const IID IID_IFlatStorage = { /* b29d6138-b92f-11d1-83ee-00c04fc2c6d4 */
    0xb29d6138,
    0xb92f,
    0x11d1,
    {0x83, 0xee, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0xd4}
  };


void
Call_CreateUpdater(REFIID riid, void** ppv)
{
    HRESULT sc;

    sc = CoCreateInstance(CLSID_ThumbnailUpdater,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          riid,
                          ppv);
    if(FAILED(sc))
    {
        printf("CoCreateInstance of Thumbnaile Updater failed %x\n", sc);
        exit(0);
    }
}

HRESULT
Call_IFilterStatus(IFilterStatus *pIFS,
                 WCHAR * pwszFileName)
{
    HRESULT sc;

    sc = pIFS->PreFilter(pwszFileName);
    if(FAILED(sc))
    {
        printf("PreFilter returned %x\n", sc);
        exit(0);
    }
    return S_OK;
}

  
HRESULT
Call_CheckTime()
{
    FILETIME mtime, ctime, atime;
    DWORD rc;
    HANDLE hFile;

    hFile = CreateFile( g_tszFileName,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        printf("CheckTime File Open error %x\n", GetLastError());
        return S_OK;
    }

    if(!GetFileTime(hFile, &ctime, &atime, &mtime))
    {
        printf("GetFileTime Failed %x\n", GetLastError());
        exit(0);
    }
    CloseHandle(hFile);

    printf("file ctime=%x:%x, atime=%x:%x, mtime=%x:%x\n", ctime, atime, mtime);
    return S_OK;

}


IStorage *
Call_CreateOplockStorageFile(DWORD mode)
{
    IOplockStorage *pIOpStg;
    IStorage *pstg;

    HRESULT sc;

    Call_CreateUpdater(IID_IOplockStorage, (void**)&pIOpStg);

    switch(mode)
    {
    case CREATE:
        sc = pIOpStg->CreateStorageEx(
                        g_tszFileName,
                        STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        STGFMT_FILE,
                        0,
                        IID_IFlatStorage,
                        (void**)&pstg);
        break;

    case OPEN:
        sc = pIOpStg->OpenStorageEx(
                        g_tszFileName,
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        STGFMT_FILE,
                        0,
                        IID_IFlatStorage,
                        (void**)&pstg);
        break;

    default:
        printf("Bad file open mode\n");
        exit(0);
        break;
    }

    if(FAILED(sc))
    {
        printf("IOplockStorage::{Create/Open}StorageEx failed %x\n", sc);
        exit(0);
    }

    if(NULL != pIOpStg)
        pIOpStg->Release();

    return pstg;
}


IStorage *
Call_CreateStorageFile(DWORD mode)
{
    HRESULT hr;
    IStorage *pstg;
    DWORD stgfmt = STGFMT_FILE;

    if(g_AnyStorage)
        stgfmt = STGFMT_ANY;

    switch(mode)
    {
    case CREATE:
        hr = StgCreateStorageEx(
                g_tszFileName,
                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                stgfmt,
                0,0,0,
                IID_IFlatStorage,
                (void**)&pstg);
        break;

    case OPEN:
        hr = StgOpenStorageEx(
                g_tszFileName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                stgfmt,
                0,0,0,
                IID_IFlatStorage,
                (void**)&pstg);
        break;

    default:
        printf("Bad file open mode\n");
        exit(0);
        break;
    }

    
    if(FAILED(hr))
    {
        printf("Stg{Create/Open}StorageEx failed %x\n", hr);
        exit(0);
    }
    return pstg;
}

CLSID CLSID_JunkClassFile = { /* ce8103fd-905b-11d1-83eb-00c04fc2c6d4 */
    0xce8103fd,
    0x905b,
    0x11d1,
    {0x83, 0xeb, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0xd4}
};


void
Call_SetClass(IStorage *pstg)
{
    HRESULT sc;

    sc = pstg->SetClass(CLSID_JunkClassFile);
    if(FAILED(sc))
    {
        printf("SetClass Failed %x\n", sc);
        exit(0); 
    }
}

void
Call_Stat(
        IStorage *pstg,
        STATSTG *pstat)
{
    HRESULT sc;

    sc = pstg->Stat(pstat, 0);
    if(FAILED(sc))
    {
        printf("Stat failed %x\n");
        exit(0);
    }
    printf("Pathname is: %ws\n", pstat->pwcsName);
    if( IsEqualGUID(pstat->clsid, CLSID_JunkClassFile) )
        printf("Class GUID is OK\n");
    else if( IsEqualGUID(pstat->clsid, CLSID_NULL) )
        printf("Class GUID is NULL_CLSID\n");
    else
        printf("Class GUID is not the JunkClassGuid!!\n");
}

void
Call_QI(IUnknown *punk, REFIID riid, void **pv)
{
    HRESULT hr;

    hr = punk->QueryInterface(riid, pv);
    if(FAILED(hr))
    {
        printf("QI failed %x\n", hr);
        exit(0);
    }
}

IStream *
Call_OpenStream(IStorage *pstg, DWORD grfMode, int num)
{
    WCHAR name[80];
    IStream *pstm;
    HRESULT hr;

    wsprintf(name, L"%02d", num);


    if(grfMode & STGM_CREATE)
    {
        hr = pstg->CreateStream(name, grfMode|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
    }
    else
    {
        hr = pstg->OpenStream(name, 0, grfMode|STGM_SHARE_EXCLUSIVE, 0, &pstm);
    }
        
    if(FAILED(hr))
    {
        printf("CreateStream(%s) failed %x\n", name, hr);
        exit(0);
    }
    return pstm;
}

IStream *
Call_OpenCONTENTSStream(IStorage *pstg)
{
    IStream *pstm;
    HRESULT hr;

    hr = pstg->OpenStream(L"CONTENTS", 0,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            0,
            &pstm);
    
    if(FAILED(hr) || NULL == pstm)
    {
        printf("OpenContentStream failed %x\n", hr);
        exit(0);
    }
    return pstm;
}



IPropertyStorage *
Call_OpenPropStg(IStorage *pstg, DWORD mode, REFFMTID fmtid )
{
    IPropertySetStorage *ppropsetstg = NULL;
    IPropertyStorage *ppropstg = NULL;
    HRESULT hr = S_OK;

    hr = pstg->QueryInterface( IID_IPropertySetStorage, (void**)&ppropsetstg );
    if( FAILED(hr) )
    {
        printf( "QI for IPropertySetStorage failed %x\n", hr );
        exit(0);
    }

    switch(mode)
    {
    case CREATE:
        hr = ppropsetstg->Create(fmtid, NULL,
                PROPSETFLAG_DEFAULT,
                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                &ppropstg );
        break;

    case OPEN:
        hr = ppropsetstg->Open(fmtid,
                               STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                               &ppropstg );
        break;
        
    default:
        printf("Bad file open mode\n");
        exit(0);
        break;
    }
    if(FAILED(hr))
    {
        printf("OpenPropStg failed %x\n", hr);
        exit(0);
    }

    if( NULL != ppropsetstg )
        ppropsetstg->Release();

    return ppropstg;
}




void 
Call_SuppressChanges(ITimeAndNoticeControl *ptnc)
{
    HRESULT hr;

    hr = ptnc->SuppressChanges(0, 0);
    if(FAILED(hr))
    {
        printf("SuppressChanges failed %x\n", hr);
        exit(0);
    }
    printf("--------SuppressChanges called\n");
}

void
TestPause(char * sz)
{
    if(g_Pause)
    {
        printf("Before %s: press <return> to continue.", sz);
        getchar();
    }
}
    
EXTERN_C void
__cdecl
wmain(
        int argc,
        WCHAR **argv)
{
    IStorage *pstg=NULL;
    ITimeAndNoticeControl *ptnc=NULL;
    IFilterStatus *pIFS=NULL;
    DWORD fOpenMode;
    STATSTG stat;
    LONG cRefs;


    CoInitialize(NULL);

    ParseArgs(argc, argv);

    if(g_CheckTime)
        Call_CheckTime();

    if(g_CheckIsStg)
        printf("StgIsStorageFile = %x\n", StgIsStorageFile(g_tszFileName));

    if(g_UseUpdater)
    {
        Call_CreateUpdater(IID_IFilterStatus, (void**)&pIFS);
        Call_IFilterStatus(pIFS, g_tszFileName);
        pIFS->Release();

    }
    else if(!g_NoOpenStg)
    {
        if(g_CreateStg)
            fOpenMode = CREATE;
        else
            fOpenMode = OPEN;
    
        if(g_OplockFile)
            pstg = Call_CreateOplockStorageFile(fOpenMode);
        else
            pstg = Call_CreateStorageFile(fOpenMode);
    
        if(g_AddRefStg)
        {
            pstg->AddRef();
            pstg->Release();
        }

        if(g_SuppressTime)
        {
            Call_QI(pstg, IID_ITimeAndNoticeControl, (void**)&ptnc);
            Call_SuppressChanges(ptnc);
            ptnc->Release();
        }
    
        if(g_SetClass)
            Call_SetClass(pstg);
    
        if(g_Stat)
            Call_Stat(pstg, &stat);

        TestPause("OpenStream");

        if(!g_NoOpenStm)
        {
            char readBuffer[1024];
            ULONG cb, cbXfred;
            IStream *pstm=NULL;
            IStream *pstmContents=NULL;
            IPropertyStorage *ppropstg=NULL;
            PROPSPEC propspec;
            PROPVARIANT propvar;
            HRESULT hr;
    
            if(g_CreateStm)
            {
                pstm = Call_OpenStream(pstg, STGM_CREATE|STGM_READWRITE, 1);
                ppropstg = Call_OpenPropStg(pstg, CREATE, FMTID_SummaryInformation);
            }
            else
            {
                pstm = Call_OpenStream(pstg, STGM_READWRITE, 1);
                pstmContents = Call_OpenCONTENTSStream(pstg);
                ppropstg = Call_OpenPropStg(pstg, OPEN, FMTID_SummaryInformation);
            }
    
            if(g_AddRefStm)
            {
                pstm->AddRef();
                pstm->Release();
            }
    
            if( g_ReleaseStg )
            {
                pstg->Release();
                pstg = NULL;
            }
    
            if(g_WriteStm)
            {
                TestPause("WriteStream");

                hr = pstm->Write((void*)"First ", 6, &cbXfred);
                if(FAILED(hr))
                {
                    printf("First Write Failed with %x\n", hr);
                    exit(0);
                }
                hr = pstm->Write((void*)"Second", 6, &cb);
                if(FAILED(hr))
                {
                    printf("Second Write Failed with %x\n", hr);
                    exit(0);
                }
                printf("Wrote %d bytes, in two pieces\n", cbXfred+cb);

                propspec.ulKind = PRSPEC_PROPID;
                propspec.propid = PIDSI_TITLE;
                propvar.vt = VT_LPSTR;
                propvar.pszVal = "My Title";
                
                hr = ppropstg->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE );
                if(FAILED(hr))
                {
                    printf( "First WriteMultiple failed with %x\n", hr );
                    exit(0);
                }

                propspec.propid = PIDSI_COMMENTS;
                propvar.pszVal = "My Comments";

                hr = ppropstg->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE );
                if(FAILED(hr))
                {
                    printf( "Second WriteMultiple failed with %x\n", hr );
                    exit(0);
                }

                printf("Wrote two properties\n");

            }
            if(g_ReadStm)
            {
                TestPause("ReadStream");

                hr = pstm->Read((void*)readBuffer, sizeof(readBuffer), &cbXfred);
                if(FAILED(hr))
                {
                    printf("Read Failed with %x\n", hr);
                    exit(0);
                }
                readBuffer[cbXfred] = '\0';
                printf("Read %d bytes: \"%s\"\n", cbXfred, readBuffer);

                propspec.ulKind = PRSPEC_PROPID;
                propspec.propid = PIDSI_TITLE;

                hr = ppropstg->ReadMultiple( 1, &propspec, &propvar );
                if(FAILED(hr))
                {
                    printf("ReadMultiple failed with %x\n", hr );
                    exit(0);
                }

                printf("ReadMultiple the title:  \"%s\"\n", propvar.pszVal );
                PropVariantClear(&propvar);
            }
    
            if(NULL != pstm)
            {
                if( 0 != (cRefs = pstm->Release()))
                    printf("Last release of the Stream and still %d References!!\n", cRefs);
                pstm = NULL;
            }

            if(NULL != pstmContents)
            {
                if(0 != (cRefs = pstmContents->Release()))
                    printf("Last release of the PropertyStorage and still %d References!!\n", cRefs);
                pstmContents = NULL;
            }

            if(NULL != ppropstg)
            {
                if(0 != (cRefs = ppropstg->Release()))
                    printf("Last release of the PropertyStorage and still %d References!!\n", cRefs);
                ppropstg = NULL;
            }
        }
        
        if(NULL != pstg)
        {
            TestPause("Last Release");
            if(0 != (cRefs = pstg->Release()))
            {
                printf("Last release of the Storage and still %d References!!\n", cRefs);
            }
            pstg = NULL;
        }

    }

    if(g_CheckTime)
        Call_CheckTime();

    CoUninitialize();

    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\prpsetup\makefile.inc ===
############################################################################
#
#   Copyright (C) 1996-1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################
##
## Special MakeFile instructions for the IProp Setup
## (PrpSetup) utility
##
## This makefile compiles the resources.  Ordinarily,
## you cause the resources to be compiled by including
## the .rc file in your SOURCES macro.  This, however,
## compiles the .rc file during pass 1.  But our .rc
## file uses iprop.dll, which doesn't exist until pass 2.
## So, we don't include the .rc file in SOURCES, and
## we add all the necessary rules for building it here.
##

#
# Make sure we're not here on passes 0/1
#

!IF "$(NOLINK)" != ""
!ERROR *** PrpSetup makefile.inc included in pass 0/1
!ENDIF

#
# Make the exe file dependent on the res file.
#

$(TARGET) : $O\prpsetup.res

#
# Show how what resources need to be compiled.
#

$O\prpsetup.res : .\prpsetup.rc

# Show that the RC file should be re-compiled if the compressed
# DLL is updated.

prpsetup.rc : iprop.dl_

# Show how to build the compressed IProp DLL file

iprop.dl_ : $(_NTTREE)\iprop.dll
   @echo Compressing - $** to $@ > con:
   compress $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\cpropvar.cxx ===
#include "pch.cxx"

#include "CPropVar.hxx"
#include "CHResult.hxx"
#include <stdio.h>
#include <tchar.h>


// Declare this prototype here, for now.  For non-Mac, the prototype
// in "iofs.h" uses C decorations, but the definition in
// ntpropb.cxx uses C++.

#ifdef _MAC_NODOC
EXTERN_C BOOLEAN
#else
BOOLEAN __declspec(dllimport) __stdcall
#endif
RtlCompareVariants(
    USHORT CodePage,
    PROPVARIANT const *pvar1,
    PROPVARIANT const *pvar2);




/*
CPropVariant::InitializeVector(
    VARENUM v,
    ULONG cElements)
{
    ULONG cbElement;
    BOOLEAN fZero = FALSE;

    // Ignore vector flag.  This constructor is always for vectors only.

    vt = v | VT_VECTOR;

    switch (vt)
    {
    case VT_VECTOR | VT_UI1:
        cbElement = sizeof(caub.pElems[0]);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        cbElement = sizeof(cai.pElems[0]);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        cbElement = sizeof(cal.pElems[0]);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        cbElement = sizeof(cah.pElems[0]);
        break;

    case VT_VECTOR | VT_CLSID:
        cbElement = sizeof(GUID);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_CF:
        cbElement = sizeof(CLIPDATA);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
    case VT_VECTOR | VT_LPWSTR:
        cbElement = sizeof(VOID *);
        fZero = TRUE;
        break; 

    case VT_VECTOR | VT_VARIANT:
        cbElement = sizeof(PROPVARIANT);
        ASSERT(VT_EMPTY == 0);
        fZero = TRUE;
        break;

    default:
        ASSERT(!"CAllocStorageVariant -- Invalid vector type");
        vt = VT_EMPTY;
        break;
    }
    if (vt != VT_EMPTY)
    {
        caub.cElems = 0;
        caub.pElems = (BYTE *) CoTaskMemAlloc(cElements * cbElement);
        if (caub.pElems != NULL)
        {
            if (fZero)
            {
                memset(caub.pElems, 0, cElements * cbElement);
            }
            caub.cElems = cElements;
        }
    }
}
*/


VOID *
CPropVariant::_AddStringToVector(
    unsigned pos,
    const VOID *pv,
    ULONG cb,
    VARTYPE vtNew )
{
    vtNew |= VT_VECTOR;

    ASSERT(vtNew == (VT_VECTOR | VT_BSTR)   ||
           vtNew == (VT_VECTOR | VT_LPSTR)  ||
           vtNew == (VT_VECTOR | VT_LPWSTR) ||
           vtNew == (VT_VECTOR | VT_CF) );
    ASSERT(calpstr.pElems != NULL);

    if (pos >= calpstr.cElems)
    {
        char **ppsz = calpstr.pElems;

        calpstr.pElems =
            (char **) CoTaskMemAlloc((pos + 1) * sizeof(calpstr.pElems[0]));
        if (calpstr.pElems == NULL)
        {
            calpstr.pElems = ppsz;
            return(NULL);
        }

        if( NULL != ppsz )
            memcpy(calpstr.pElems, ppsz, calpstr.cElems * sizeof(calpstr.pElems[0]));

        memset(
            &calpstr.pElems[calpstr.cElems],
            0,
            ((pos + 1) - calpstr.cElems) * sizeof(calpstr.pElems[0]));

        calpstr.cElems = pos + 1;
        CoTaskMemFree(ppsz);
    }

    LPSTR psz;

    if( (VT_VECTOR | VT_BSTR) == vtNew )
    {
        if( NULL == pv )
        {
            psz = NULL;
        }
        else
        {
            psz = (LPSTR) SysAllocString( (BSTR) pv );
            if (psz == NULL)
            {
                return(NULL);
            }
        }

        if (calpstr.pElems[pos] != NULL)
        {
            SysFreeString((BSTR) calpstr.pElems[pos]);
        }
        calpstr.pElems[pos] = psz;
    }
    else
    {
        if( NULL == pv )
        {
            psz = NULL;
        }
        else
        {
            psz = (LPSTR) CoTaskMemAlloc((VT_BSTR == (vtNew & ~VT_VECTOR) )
                                           ? cb + sizeof(ULONG)
                                           : cb );
            if (psz == NULL)
            {
                return(NULL);
            }

            memcpy(psz, pv, cb);
        }

        if (calpstr.pElems[pos] != NULL)
        {
            CoTaskMemFree(calpstr.pElems[pos]);
        }
        calpstr.pElems[pos] = psz;
    }


    return(calpstr.pElems[pos]);
}


VOID *
CPropVariant::_AddScalerToVector(
    unsigned pos,
    const VOID *pv,
    ULONG cb)
{
    ASSERT(calpstr.pElems != NULL);

    if (pos >= calpstr.cElems)
    {
        char **ppsz = calpstr.pElems;

        calpstr.pElems =
            (char **) CoTaskMemAlloc((pos + 1) * cb);
        if (calpstr.pElems == NULL)
        {
            calpstr.pElems = ppsz;
            return(NULL);
        }

        memset(
            calpstr.pElems,
            0,
            ((pos + 1) - calpstr.cElems) * cb);

        if( NULL != ppsz )
            memcpy(calpstr.pElems, ppsz, calpstr.cElems * cb);

        calpstr.cElems = pos + 1;
        CoTaskMemFree(ppsz);
    }


    memcpy( (BYTE*)calpstr.pElems + pos*cb, pv, cb );
    return( (BYTE*)calpstr.pElems + pos*cb );

}



void
CPropVariant::SetCF(
    const CLIPDATA *pclipdata,
    ULONG pos)
{
    CLIPDATA *pclipdataNew;

    if (vt != (VT_VECTOR | VT_CF))
	{
		Clear();
		vt = VT_VECTOR | VT_CF;
	}

    pclipdataNew = (CLIPDATA*) _AddScalerToVector(pos, (VOID *) pclipdata, sizeof(CLIPDATA) );

    if( NULL != pclipdataNew
        &&
        NULL != pclipdata )
    {
        pclipdataNew->pClipData = (BYTE*) CoTaskMemAlloc( CBPCLIPDATA(*pclipdata) );
        if( NULL == pclipdataNew->pClipData )
        {
            ASSERT( !"Couldn't allocate pclipdataNew" );
            return;
        }
        else
        {
            pclipdataNew->cbSize = pclipdata->cbSize;
            pclipdataNew->ulClipFmt = pclipdata->ulClipFmt;

            memcpy( pclipdataNew->pClipData,
                    pclipdata->pClipData,
                    CBPCLIPDATA(*pclipdata) );
            return;
        }
    }
}


void
CPropVariant::SetBSTR(
    const BSTR posz,
    ULONG pos)
{
    ULONG cch;

    if( vt != (VT_BSTR | VT_VECTOR) ) Clear();

    if( NULL == posz )
        cch = 0;
    else
        cch = ocslen(posz) + 1;

    if (vt != (VT_VECTOR | VT_BSTR))
        Clear();

    _AddStringToVector(pos, (VOID *) posz,
                       sizeof(OLECHAR) * cch, VT_BSTR );

    vt = VT_BSTR | VT_VECTOR;
}




CPropVariant & CPropVariant::operator =(PROPVARIANT &propvar)
{
    if( INVALID_SUBSCRIPT == wReserved1 )
    {
        throw CHRESULT( (HRESULT) E_FAIL, OLESTR("Attempt to assign a singleton VT_VARIANT") );
        return (*this);
    }
    else
    {
        if( !(vt & VT_VECTOR)
            ||
            (vt & ~VT_VECTOR) != VT_VARIANT )
        {
            USHORT wReserved1Save = wReserved1;
            Clear();
            wReserved1 = wReserved1Save;
        }

        Set( VT_VARIANT | VT_VECTOR, (void*) &propvar, wReserved1 - 1 );
        wReserved1 = INVALID_SUBSCRIPT;
        return (*this);
    }
}
        

void
CPropVariant::SetPROPVARIANT( PROPVARIANT &propvar, ULONG pos )
{
    if( vt != (VT_VARIANT | VT_VECTOR) ) Clear();

    if (pos >= capropvar.cElems)
    {
        LPPROPVARIANT rgpropvar = capropvar.pElems;

        capropvar.pElems =
            (PROPVARIANT *) CoTaskMemAlloc((pos + 1) * sizeof(capropvar.pElems[0]));
        if (capropvar.pElems == NULL)
        {
            capropvar.pElems = rgpropvar;
            return;
        }

        if( NULL != rgpropvar )
            memcpy(capropvar.pElems, rgpropvar, capropvar.cElems * sizeof(capropvar.pElems[0]));

        memset(
            &capropvar.pElems[capropvar.cElems],
            0,
            ((pos + 1) - capropvar.cElems) * sizeof(capropvar.pElems[0]));
        capropvar.cElems = pos + 1;
        CoTaskMemFree(rgpropvar);
    }

    PropVariantClear( &capropvar.pElems[pos] );
    PropVariantCopy( &capropvar.pElems[pos], &propvar );

    vt = VT_VARIANT | VT_VECTOR;

    return;

}


void
CPropVariant::SetCF(const CLIPDATA *p)
{
    Clear();

    if( NULL == p )
        return;

    pclipdata = (CLIPDATA*) CoTaskMemAlloc( sizeof(CLIPDATA) );
    if( NULL == pclipdata )
    {
        return;
    }

    pclipdata->cbSize = p->cbSize;
    pclipdata->ulClipFmt = p->ulClipFmt;
    pclipdata->pClipData = NULL;

    if( sizeof(pclipdata->ulClipFmt) > p->cbSize )
    {
        throw CHRESULT( (HRESULT) E_FAIL, OLESTR("Invalid input CLIPDATA*") );
        return;
    }


    if( NULL != p->pClipData )
    {
        pclipdata->pClipData = (BYTE*) CoTaskMemAlloc( pclipdata->cbSize
                                                      - sizeof(pclipdata->ulClipFmt) );
        if( NULL == pclipdata->pClipData )
            return;

        memcpy( pclipdata->pClipData, p->pClipData, pclipdata->cbSize - sizeof(pclipdata->ulClipFmt) );
    }

    vt = VT_CF;

}

void
CPropVariant::SetCLSID( const CLSID *pclsid )
{
    Clear();

    puuid = (CLSID*) CoTaskMemAlloc( sizeof(CLSID) );
    if( NULL == puuid )
        throw CHRESULT( (HRESULT) E_OUTOFMEMORY, OLESTR("CPropVariant::SetCLSID couldn't alloc a new CLSID") );

    *puuid = *pclsid;
    vt = VT_CLSID;
}


void
CPropVariant::SetCLSID(
    const CLSID *pclsid,
    unsigned pos)
{
    CLSID *pclsidNew;

    if (vt != (VT_VECTOR | VT_CLSID))
	{
		Clear();
		vt = VT_VECTOR | VT_CLSID;
	}

    pclsidNew = (CLSID*) _AddScalerToVector(pos, (const VOID *) pclsid, sizeof(CLSID) );

    if( NULL != pclsidNew )
    {
        *pclsidNew = *pclsid;
    }
}

#define COMPARE_CHUNK_SIZE      4096

//+----------------------------------------------------------------------------
//
//  CPropVariant::Compare
//
//  Compare two CPropVariants.  This routine defers to the RtlCompareVariants
//  for most types.  Types not supported by that routine are handled here.
//
//+----------------------------------------------------------------------------

HRESULT
CPropVariant::Compare( PROPVARIANT *ppropvar1, PROPVARIANT *ppropvar2 )
{
    HRESULT hr = S_OK;

    VARTYPE vt1 = ppropvar1->vt;
    IStream *pStream1 = NULL, *pStream2 = NULL;
    BYTE *prgb1 = NULL, *prgb2 = NULL;
    CLargeInteger liCurrentSeek;

    switch( vt1 )
    {
    case VT_VERSIONED_STREAM:

        if( ppropvar1->pVersionedStream == NULL && ppropvar2->pVersionedStream == NULL )
            return( S_OK );
        else if( ppropvar1->pVersionedStream == NULL || ppropvar2->pVersionedStream == NULL )
            return( S_FALSE );
        else if( ppropvar1->pVersionedStream->guidVersion != ppropvar2->pVersionedStream->guidVersion )
            return( S_FALSE );

        pStream1 = ppropvar1->pVersionedStream->pStream;
        pStream2 = ppropvar2->pVersionedStream->pStream;

        // Fall through

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
        {
            // Note:  This comparisson effects the seek pointers, though
            // barring error they are restored on completion.

            STATSTG statstg1, statstg2;
            CULargeInteger uliSeek1, uliSeek2;

            if( NULL == pStream1 )
            {
                ASSERT( NULL == pStream2 );
                pStream1 = ppropvar1->pStream;
                pStream2 = ppropvar2->pStream;
            }

            if( ppropvar1->vt != ppropvar2->vt
                ||
                NULL == pStream1 && NULL != pStream2
                ||
                NULL != pStream1 && NULL == pStream2 )
            {
                return( S_FALSE );
            }

            hr = pStream1->Stat( &statstg1, STATFLAG_NONAME );
            if( FAILED(hr) ) goto Exit;
            hr = pStream2->Stat( &statstg2, STATFLAG_NONAME );
            if( FAILED(hr) ) goto Exit;

            if( CULargeInteger(statstg1.cbSize) != CULargeInteger(statstg2.cbSize) )
                return( S_FALSE );

            prgb1 = new BYTE[ COMPARE_CHUNK_SIZE ];
            if( NULL == prgb1 )
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            prgb2 = new BYTE[ COMPARE_CHUNK_SIZE ];
            if( NULL == prgb2 )
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            hr = pStream1->Seek( CLargeInteger(0), STREAM_SEEK_CUR, &uliSeek1 );
            if( FAILED(hr) ) goto Exit;
            hr = pStream2->Seek( CLargeInteger(0), STREAM_SEEK_CUR, &uliSeek2 );
            if( FAILED(hr) ) goto Exit;

            liCurrentSeek = CLargeInteger(0);

            CULargeInteger cbRemaining = statstg1.cbSize;
            while( cbRemaining > 0 )
            {
                ULONG cbRead1 = 0, cbRead2 = 0;

                hr = pStream1->Seek( liCurrentSeek, STREAM_SEEK_SET, NULL );
                if( FAILED(hr) ) goto Exit;

                hr = pStream1->Read( prgb1, COMPARE_CHUNK_SIZE, &cbRead1 );
                if( FAILED(hr) ) goto Exit;

                hr = pStream2->Seek( liCurrentSeek, STREAM_SEEK_SET, NULL );
                if( FAILED(hr) ) goto Exit;

                hr = pStream2->Read( prgb2, COMPARE_CHUNK_SIZE, &cbRead2 );
                if( FAILED(hr) ) goto Exit;

                if( cbRead1 != cbRead2 )
                {
                    hr = STG_E_READFAULT;
                    goto Exit;
                }

                if( memcmp( prgb1, prgb2, cbRead1 ) )
                {
                    hr = S_FALSE;
                    goto Exit;
                }

                liCurrentSeek += cbRead1;
                cbRemaining -= cbRead1;
            }

            hr = pStream1->Seek( static_cast<CLargeInteger>(uliSeek1), STREAM_SEEK_SET, NULL );
            if( FAILED(hr) ) goto Exit;

            hr = pStream2->Seek( static_cast<CLargeInteger>(uliSeek2), STREAM_SEEK_SET, NULL );
            if( FAILED(hr) ) goto Exit;

            hr = S_OK;
            goto Exit;

        }


    case VT_STORAGE:
    case VT_STORED_OBJECT:
        {

            if( ppropvar1->vt == ppropvar2->vt
                &&
                ( NULL == ppropvar1->vt
                  &&
                  NULL == ppropvar2->vt
                  ||
                  NULL != ppropvar1->vt
                  &&
                  NULL != ppropvar2->vt
                )
              )
            {
                return( S_OK );
            }
            else
            {
                return( S_FALSE );
            }
        }
        break;

    default:

        // For SafeArrays we just check the structure, not the data.

        if( VT_ARRAY & vt1 )
        {
            if( ppropvar1->vt != ppropvar2->vt 
                ||
                ppropvar1->parray->cDims != ppropvar2->parray->cDims
                ||
                SafeArrayGetElemsize(ppropvar1->parray) != SafeArrayGetElemsize(ppropvar2->parray) )
            {
                return (HRESULT) S_FALSE;
            }
            else
            {
                return (HRESULT) S_OK;
            }

        }
        else if( PropTestCompareVariants( CP_ACP,     // Ignored,
                                          ppropvar1,
                                          ppropvar2 ))
        {
            return( (HRESULT) S_OK );
        }
        else
        {
            return( (HRESULT) S_FALSE );
        }
        break;
    }

Exit:

    if( NULL != prgb1 )
        delete[] prgb1;
    if( NULL != prgb2 )
        delete[] prgb2;

    return( hr );
}


void
CPropVariant::Set( VARTYPE vtSet, void *pv, ULONG pos )
{
    BOOL fVector = (vtSet & VT_VECTOR) ? TRUE : FALSE;


    switch( vtSet & ~VT_VECTOR )
    {
        case VT_I1:

            if( fVector )
                SetI1( *(CHAR*) pv, pos );
            else
                SetI1( *(CHAR*) pv );

            break;

        case VT_UI1:

            if( fVector )
                SetUI1( *(UCHAR*) pv, pos );
            else
                SetUI1( *(UCHAR*) pv );

            break;

        case VT_I2:

            if( fVector )
                SetI2( *(short*) pv, pos );
            else
                SetI2( *(short*) pv );

            break;

        case VT_UI2:

            if( fVector )
                SetUI2( *(USHORT*) pv, pos );
            else
                SetUI2( *(USHORT*) pv );

            break;

        case VT_BOOL:

            if( fVector )
                SetBOOL( *(VARIANT_BOOL*) pv, pos );
            else
                SetBOOL( *(VARIANT_BOOL*) pv );

            break;

        case VT_I4:

            if( fVector )
                SetI4( *(long*) pv, pos );
            else
                SetI4( *(long*) pv );
            break;

        case VT_UI4:

            if( fVector )
                SetUI4( *(ULONG*) pv, pos );
            else
                SetUI4( *(ULONG*) pv );

            break;

        case VT_R4:

            if( fVector )
                SetR4( *(float*) pv, pos );
            else
                SetR4( *(float*) pv );

            break;

        case VT_ERROR:

            if( fVector )
                SetERROR( *(SCODE*) pv, pos );
            else
                SetERROR( *(SCODE*) pv );

            break;

        case VT_I8:

            if( fVector )
                SetI8( *(LARGE_INTEGER*) pv, pos );
            else
                SetI8( *(LARGE_INTEGER*) pv );
            break;

        case VT_UI8:

            if( fVector )
                SetUI8( *(ULARGE_INTEGER*) pv, pos );
            else
                SetUI8( *(ULARGE_INTEGER*) pv );

            break;

        case VT_R8:

            if( fVector )
                SetR8( *(double*) pv, pos );
            else
                SetR8( *(double*) pv );

            break;

        case VT_CY:

            if( fVector )
                SetCY( *(CY*) pv, pos );
            else
                SetCY( *(CY*) pv );

            break;

        case VT_DATE:

            if( fVector )
                SetDATE( *(DATE*) pv, pos );
            else
                SetDATE( *(DATE*) pv );

            break;

        case VT_FILETIME:

            if( fVector )
                SetFILETIME( *(FILETIME*) pv, pos );
            else
                SetFILETIME( *(FILETIME*) pv );

            break;

        case VT_CLSID:

            if( fVector )
                SetCLSID( *(CLSID*) pv, pos );
            else
                SetCLSID( *(CLSID*) pv );

            break;

        case VT_BLOB:

            ASSERT( !fVector );
            SetBLOB( *(BLOB*) pv );
            break;

        case VT_CF:

            if( fVector )
                SetCF( *(CLIPDATA**) pv, pos );
            else
                SetCF( *(CLIPDATA**) pv );
            
            break;

        case VT_STREAM:

            ASSERT( !fVector );
            SetSTREAM( *(IStream**) pv );
            break;

        case VT_STORAGE:

            ASSERT( !fVector );
            SetSTORAGE( *(IStorage**) pv );
            break;

        case VT_BSTR:

            if( fVector )
                SetBSTR( *(BSTR*) pv, pos );
            else
                SetBSTR( *(BSTR*) pv );

            break;

        case VT_LPSTR:

            if( fVector )
                SetLPSTR( *(LPSTR*) pv, pos );
            else
                SetLPSTR( *(LPSTR*) pv );

            break;

        case VT_LPWSTR:

            if( fVector )
                SetLPWSTR( *(LPWSTR*) pv, pos );
            else
                SetLPWSTR( *(LPWSTR*) pv );

            break;

        case VT_VARIANT:

            if( !fVector )
                throw CHRESULT( E_FAIL, OLESTR("CPropVariant::Set - attempt to set a singleton VT_VARIANT") );

            SetPROPVARIANT( *(PROPVARIANT*) pv, pos );

            break;

        case VT_DECIMAL:

            ASSERT( !fVector );
            SetDECIMAL( *(DECIMAL*) pv );
            break;

        default:

            ASSERT(0);
            throw CHRESULT( (HRESULT) E_FAIL, OLESTR("CPropVariant::Set invalid type") );

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\prpsetup\prpsetup.cxx ===
//+============================================================================
//
//  File:       PrpSetup.cxx
//
//  Purpose:    This file builds to an executable which installs the
//              IProp DLL in the System(32) directory.  This is provided
//              for the use of applications which re-distribute that DLL.
//
//  Usage:      PrpSetup [/u] [/c]
//
//              The /u option indicates that an un-install should be performed.
//              The /c option indicates that console output is desired.
//
//  History:    10/30/96    MikeHill    Get "iprop.dl_" from the exe's resources.
//
//+============================================================================

//  --------
//  Includes
//  --------

#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <stdio.h>

//  -------------
//  Global values
//  -------------

// Name-related information for the DLL
const LPTSTR tszResourceType       = TEXT( "FILE" );        // Resource type
const LPTSTR tszCompressedFilename = TEXT( "IPROP.DL_" );   // Temp file name
const LPTSTR tszTargetFilename     = TEXT( "IPROP.DLL" );   // Final file name

// The reg key where we keep the DLL's install ref-count.
const LPTSTR tszRegSharedDLLs
                = TEXT( "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs" );

// Registration functions in IProp DLL.
const LPTSTR tszRegistrationFunction    = TEXT( "DllRegisterServer" );
const LPTSTR tszUnregistrationFunction  = TEXT( "DllUnregisterServer" );


//  ------------
//  Return Codes
//  ------------

#define RETURN_SUCCESS                          0
#define RETURN_ARGUMENT_ERROR                   1
#define RETURN_COULDNT_CREATE_TEMP_FILE         2
#define RETURN_COULDNT_INSTALL_DLL              3
#define RETURN_COULDNT_DELETE_DLL               4
#define RETURN_COULDNT_REGISTER_DLL             5
#define RETURN_COULDNT_ACCESS_REGISTRY          6
#define RETURN_OUT_OF_MEMORY                    7
#define RETURN_INTERNAL_ERROR                   8


//+----------------------------------------------------------------------------
//
//  Function:   Register
//
//  Synopsis:   This function registers or de-registers the IProp DLL.
//
//  Inputs:     [BOOL] fUninstall (in)
//                  If true, call DllUnregisterServer, otherwise call
//                  DllRegisterServer
//
//  Returns:    [HRESULT]
//
//+----------------------------------------------------------------------------


HRESULT Register( BOOL fUninstall )
{
    HRESULT hr;
    HINSTANCE hinst = NULL;

    // A function pointer for the registration function
    typedef HRESULT (STDAPICALLTYPE FNREGISTRATION)();
    FNREGISTRATION *pfnRegistration = NULL;

    // Load the DLL

    hinst = LoadLibrary( tszTargetFilename );
    if( NULL == hinst )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Get the registration function

    pfnRegistration = (FNREGISTRATION*)
                      GetProcAddress( hinst,
                                      fUninstall ? tszUnregistrationFunction
                                                 : tszRegistrationFunction );
    if( NULL == pfnRegistration )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Register or De-register IProp.

    hr = (*pfnRegistration)();
    if( FAILED(hr) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != hinst )
        FreeLibrary( hinst );

    return( hr );
}



//+----------------------------------------------------------------------------
//
//  Function:   main()
//
//  Synopsis:   This program loads/removes IProp.DLL into/from the
//              System directory.  A ref-count of the number of installs
//              of this DLL is kept in the Registry.  The DLL is
//              also registered/deregistered.
//
//+----------------------------------------------------------------------------

HRESULT __cdecl main(int argc, char **argv)
{
    // File names and paths

    TCHAR tszSystemPath[_MAX_PATH+1];        // Path to System(32) directory
    TCHAR tszTempFilename[_MAX_PATH+1];      // Used by VerInstallFile()
    UINT cbTempFilename = sizeof( tszTempFilename ) - sizeof(TCHAR);
    TCHAR tszTargetPathAndFile[_MAX_PATH+1]; // E.g. "C:\Win\System32\IProp.dll"
    TCHAR tszTempPath[_MAX_PATH+1];          // E.g. "C:\Temp\"
                                             // E.g. "C:\Temp\iprop.dl_"
    TCHAR tszTempPathAndFile[_MAX_PATH+1] = {""};

    // Index into argv
    int nArgIndex;
    
    // User-settable flags.
    BOOL fConsole = FALSE;
    BOOL fInstall = FALSE;
    BOOL fUninstall = FALSE;

    // Registry data
    HKEY hkey;
    DWORD dwRegValueType;
    DWORD dwRefCount;
    DWORD cbRefCountSize = sizeof( dwRefCount );
    DWORD dwDisposition;

    // Handles for reading "iprop.dl_" out of the resources
    HRSRC hrsrcIProp = NULL;       // Handle to the "iprop.dl_" resource.
    HGLOBAL hglobIProp = NULL;     // Handle to the "iprop.dl_" data.
    LPVOID lpvIProp = NULL;        // Pointer to the "iprop.dl_" data.
    HMODULE hmodCurrent = NULL;    // Our module handle
    HANDLE hfileIProp = NULL;      // Handle to "%TEMP%\iprop.dl_" file


    // Misc.
    HRESULT hr = S_OK;
    INT  nReturnCode = RETURN_INTERNAL_ERROR;

    //  -----------------
    //  Process the Input
    //  -----------------

    for( nArgIndex = 1; nArgIndex < argc; nArgIndex++ )
    {
        if( // Is this argument an option?
            ( argv[nArgIndex][0] == '/'
              ||
              argv[nArgIndex][0] == '-'
            )
            && // and is it more than one character?
            argv[nArgIndex][1] != '\0'
            && // and is it exactly two characters?
            argv[nArgIndex][2] == '\0'
          )
        {
            // See if it's an argument we recognize.
            switch( argv[nArgIndex][1] )
            {
                // Installation

                case 'i':
                case 'I':

                    fInstall = TRUE;
                    break;

                // Uninstall
                case 'u':
                case 'U':

                    fUninstall = TRUE;
                    break;

                // Console output
                case 'c':
                case 'C':

                    fConsole = TRUE;
                    break;
            }
        }   // if( ( argv[nArgIndex][0] == '/' ...
    }   // for( nArgIndex = 1; nArgIndex < argc; nArgIndex++ )

    // Did we get an illegal command-line combination?

    if( fInstall && fUninstall )
    {
        nReturnCode = RETURN_ARGUMENT_ERROR;
        goto Exit;
    }

    // Did the user fail to tell us what to do?  If so,
    // display usage information.

    if( !fInstall && !fUninstall )
    {
        _tprintf( TEXT("\n") );
        _tprintf( TEXT("   Installation program for the Microsoft OLE Property Set Implementation\n") );
        _tprintf( TEXT("   Usage:    IProp [/i | /u] [/c]\n") );
        _tprintf( TEXT("   Options:  /i => Install\n")
                  TEXT("             /u => Uninstall\n")
                  TEXT("             /c => Console output\n") );
        _tprintf( TEXT("   Examples: IProp /i\n")
                  TEXT("             IProp /u /c\n") );
        
        nReturnCode = RETURN_SUCCESS;
        goto Exit;
    }


    //  ----------
    //  Initialize
    //  ----------

    // Find the target installation directory.

    if( GetSystemDirectory( tszSystemPath,
                            sizeof(tszSystemPath) - sizeof(TCHAR))
        == 0 )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        nReturnCode = RETURN_COULDNT_INSTALL_DLL;
        goto Exit;
    }
      
    // Determine the target's total path & filename.

    _tcscpy( tszTargetPathAndFile, tszSystemPath );
    _tcscat( tszTargetPathAndFile, TEXT("\\") );
    _tcscat( tszTargetPathAndFile, tszTargetFilename );

    // Generate the filename we'll use for the compressed
    // IProp DLL file ("iprop.dl_"); get the temp directory
    // and post-pend a filename to it.

    if( !GetTempPath( sizeof(tszTempPath), tszTempPath ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        nReturnCode = RETURN_COULDNT_CREATE_TEMP_FILE;
        goto Exit;
    }

    _tcscpy( tszTempPathAndFile, tszTempPath );
    _tcscat( tszTempPathAndFile, tszCompressedFilename );

    // Open the registry key that holds this DLL's ref-count.

    hr = RegCreateKeyEx( HKEY_LOCAL_MACHINE,    // Open key
                       tszRegSharedDLLs,        // Name of subkey
                       0L,                      // Reserved
                       NULL,                    // Class
                       0,                       // Options
                       KEY_ALL_ACCESS,          // SAM desired
                       NULL,                    // Security attributes
                       &hkey,                   // Result
                       &dwDisposition );        // "Created" or "Opened"
    if( ERROR_SUCCESS != hr )
    {
        hr = HRESULT_FROM_WIN32( hr );
        nReturnCode = RETURN_COULDNT_ACCESS_REGISTRY;
        goto Exit;
    }

    // Attempt to read our ref-count

    hr = RegQueryValueEx( hkey,                 // Open key
                          tszTargetPathAndFile, // Value name
                          NULL,                 // Reserved
                          &dwRegValueType,      // Out: value type
                          (LPBYTE) &dwRefCount, // Out: value
                          &cbRefCountSize );    // In: buf size, out: data size

    if( ERROR_FILE_NOT_FOUND == hr )
        // This entry didn't already exist.
        dwRefCount = 0;

    else if( ERROR_SUCCESS != hr )
    {
        // There was a real error during the Query attempt.
        hr = HRESULT_FROM_WIN32(hr);
        nReturnCode = RETURN_COULDNT_ACCESS_REGISTRY;
        goto Exit;
    }

    else if ( REG_DWORD != dwRegValueType )
    {
        // This is an invalid entry.  We won't abort, we'll just
        // re-initialize it to zero, and at the end we'll overwrite
        // whatever was already there.

        dwRefCount = 0;
    }


    if( fConsole )
    {
        if( fUninstall )
            _tprintf ( TEXT("Uninstalling \"%s\"\n"), tszTargetPathAndFile );
        else
            _tprintf( TEXT("Installing \"%s\"\n"), tszTargetPathAndFile );
    }

    //  ------------------------------
    //  Installation or Uninstallation
    //  ------------------------------

    if( fUninstall )
    {   // We're doing an Un-Install

        // Should we actually delete it?  We haven't done a dec-ref yet,
        // so in the normal case, on the last delete, the RefCount will 
        // currently be 1.

        if( dwRefCount <= 1 )
        {
            // Yes - we need to do a delete.  First unregister the IProp
            // DLL.  If there's an error we'll abort.  So we might leave
            // an unused file on the machine, but that's better than
            // possibly deleting a file that is still in use by another
            // app.

            hr = Register( fUninstall );
            if( FAILED(hr) )
            {
                nReturnCode = RETURN_COULDNT_REGISTER_DLL;
                goto Exit;
            }

            // And delete the file

            if( !DeleteFile( tszTargetPathAndFile )
                &&
                ERROR_FILE_NOT_FOUND != GetLastError() )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                nReturnCode = RETURN_COULDNT_DELETE_DLL;
                goto Exit;
            }

            if( fConsole )
                _tprintf( TEXT("Removed IProp.DLL\n") );

            // Zero-out the ref count.  We'll delete it from the 
            // registry later
 
            dwRefCount = 0;
        }
        else
        {
            // We don't need to delete it, just dec-ref it.
            dwRefCount--;

            if( fConsole )
                _tprintf( TEXT("IProp.DLL not removed (reference count is now %d)\n"), dwRefCount );
        }
    }   // if( fUninstall )

    else
    {   // We're doing an Install

        DWORD dwSize;           // Size of "iprop.dl_".
        DWORD cbWritten = 0;

        if( fConsole )
            _tprintf( TEXT("Extracting \"%s\"\n"), tszTempPathAndFile );

        // Get our module handle;

        hmodCurrent = GetModuleHandle( NULL );
        if( NULL == hmodCurrent )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_OUT_OF_MEMORY;
            goto Exit;
        }

        // Get the resource which is actually the compressed IProp DLL

        hrsrcIProp = FindResource( hmodCurrent,
                                   tszCompressedFilename,
                                   tszResourceType );
        if( NULL == hrsrcIProp )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_OUT_OF_MEMORY;
            goto Exit;
        }

        // Get the size of "iprop.dl_"

        dwSize = SizeofResource( hmodCurrent, hrsrcIProp );
        if( 0 == dwSize )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_OUT_OF_MEMORY;
            goto Exit;
        }

        // Get "iprop.dl_" into a memory buffer.

        hglobIProp = LoadResource( hmodCurrent, hrsrcIProp );
        if( NULL == hglobIProp )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_OUT_OF_MEMORY;
            goto Exit;
        }

        // Get a pointer to the "iprop.dl_" data.

        lpvIProp = LockResource( hglobIProp );
        if( NULL == lpvIProp )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_OUT_OF_MEMORY;
            goto Exit;
        }

        // Create a temporary file, which will be "iprop.dl_"

        hfileIProp = CreateFile(
                            tszTempPathAndFile,             // E.g. "C:\Temp\iprop.dl_"
                            GENERIC_READ | GENERIC_WRITE,   // Requested access
                            FILE_SHARE_READ,                // Sharing mode
                            NULL,                           // No security attributes
                            CREATE_ALWAYS,                  // Overwrite existing
                            FILE_ATTRIBUTE_NORMAL,          // Default attributes
                            NULL );                         // No template file
        if( INVALID_HANDLE_VALUE == hfileIProp )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_COULDNT_CREATE_TEMP_FILE;
            goto Exit;
        }
        
        // Write the contents of "iprop.dl_"

        if( !WriteFile( hfileIProp, lpvIProp, dwSize, &cbWritten, NULL ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            nReturnCode = RETURN_COULDNT_CREATE_TEMP_FILE;
            goto Exit;
        }

        // We must close the file, or VerInstallFile won't open it.

        CloseHandle( hfileIProp );
        hfileIProp = NULL;

        // Install the file.

        hr = VerInstallFile(  0,                      // Flags
                              tszCompressedFilename,  // Source filename
                              tszTargetFilename,      // Dest filename
                              tszTempPath,            // Source location
                              tszSystemPath,          // Target location
                              tszSystemPath,          // Location of old version
                              tszTempFilename,        // Out: name of temp file
                              &cbTempFilename);       // In: size of buf, Out: name

        // If VerInstallFile left a temporary file, delete it now.

        if( hr & VIF_TEMPFILE )
        {
            TCHAR tszDeleteTempFile[_MAX_PATH+1];

            _tcscpy( tszDeleteTempFile, tszSystemPath );
            _tcscat( tszDeleteTempFile, TEXT("\\") );
            _tcscat( tszDeleteTempFile, tszTempFilename );
            DeleteFile( tszDeleteTempFile );
        }

        // If the file was installed successfully, register it.

        if( 0 == hr )
        {
            hr = Register( fUninstall );
            if( FAILED(hr) )
            {
                nReturnCode = RETURN_COULDNT_REGISTER_DLL;
                goto Exit;
            }
        }

        // If the error wasn't "newer version exists", then we
        // have a fatal error.

        else if( 0 == (hr & VIF_SRCOLD) )
        {
            nReturnCode = RETURN_COULDNT_INSTALL_DLL;
            goto Exit;
        }
        else if( fConsole )
        {
            _tprintf( TEXT("A newer version of the file is already installed\n") );
        }


        // Do an add-ref.
        dwRefCount++;

    }   // if( fUninstall ) ... else


    //  ------------------
    //  Save the Ref-Count
    //  ------------------

    // Did we actually delete the DLL?

    if( 0 == dwRefCount )
    {
        // Delete our entry from the SharedDlls entry
        hr = RegDeleteValue( hkey, tszTargetPathAndFile );
        
        if( ERROR_FILE_NOT_FOUND == hr )
            hr = ERROR_SUCCESS;

        else if( ERROR_SUCCESS != hr )
        {
            hr = HRESULT_FROM_WIN32(hr);
            nReturnCode = RETURN_COULDNT_ACCESS_REGISTRY;
            goto Exit;
        }
    }
    else
    {
        // Otherwise, put the new ref-count in the registry.
        hr = RegSetValueEx(  hkey,                  // Open key
                             tszTargetPathAndFile,  // Value name
                             0,                     // Reserved
                             REG_DWORD,             // Value type
                             (LPBYTE) &dwRefCount,  // Value buffer
                             sizeof( dwRefCount )); // Size of value
        if( ERROR_SUCCESS != hr )
        {
            hr = HRESULT_FROM_WIN32(hr);
            nReturnCode = RETURN_COULDNT_ACCESS_REGISTRY;
            goto Exit;
        }
    }    // if( 0 == dwRefCount ) ... else


    //  ----
    //  Exit
    //  ----

Exit:

    if( fConsole )
    {
        // We only succeeded if hr is 0; VerInstallFile might return
        // a bitmapped error that doesn't look like an HRESULT error
        // code.

        if( 0 == hr )
            _tprintf( TEXT("%s successful\n"),
                      fUninstall ? TEXT("Uninstall") : TEXT("Install") );
        else
            _tprintf( TEXT("%s failed.  Return code = %d (%08X)\n"),
                      nReturnCode,
                      fUninstall ? TEXT("Uninstall") : TEXT("Install"),
                      hr );
    }

    // Remove the temporary file (we initialized this to "", so this
    // call should always return success or file-not-found).

    DeleteFile( tszTempPathAndFile );

    // Free all the handles we've used.

    if( hfileIProp ) CloseHandle( hfileIProp );
    if( lpvIProp )   GlobalUnlock( lpvIProp );


    return( nReturnCode );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\open.cxx ===
//+-----------------------------------------------------------------------
//
// File:        open.cxx
//
// Synopsis:    Helper functions for opening all kinds of FILE_STORAGE_TYPEs.
//
// History:     06-May-95       DaveStr     created
//
// Notes:
//
//------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <stgint.h>
#include <stgprop.h>
#define _CAIROSTG_
#include <olecairo.h>

extern BOOL g_fOFS;

HRESULT _Open(
    WCHAR        *path,
    FILE_STORAGE_TYPE type,
    BOOL         fCreate,
    HANDLE       *ph)
{
    NTSTATUS            status;
    UNICODE_STRING      str;
    IO_STATUS_BLOCK     iosb;
    OBJECT_ATTRIBUTES   oa;
    HRESULT             hr = S_OK;

    if ( !RtlDosPathNameToNtPathName_U(path,&str,NULL,NULL) )
    {
        hr = HRESULT_FROM_NT(STATUS_OBJECT_PATH_INVALID);
    }
    else
    {
        InitializeObjectAttributes(
                        &oa,
                        &str,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        (PSECURITY_DESCRIPTOR) NULL);

        status = NtCreateFile(ph,
                              FILE_GENERIC_READ  |
                                    FILE_GENERIC_WRITE |
                                    WRITE_OWNER |
                                    WRITE_DAC |
                                    SYNCHRONIZE |
                                    DELETE,
                              &oa,
                              &iosb, 
                              NULL,
                              0,
                              FILE_SHARE_READ,
                              ( fCreate ) ? FILE_CREATE : 0,
                              FILE_SYNCHRONOUS_IO_NONALERT |
                              (g_fOFS ? (FILE_STORAGE_TYPE_SPECIFIED |
                                    (type << FILE_STORAGE_TYPE_SHIFT)) : 0),
                              NULL,
                              0);

        if ( !NT_SUCCESS(status) )
        {
            hr = HRESULT_FROM_NT(status);
        }

        RtlFreeUnicodeString(&str);
    }

    return(hr);
}

static DWORD grfmode = (STGM_READWRITE | STGM_SHARE_EXCLUSIVE);

HRESULT OpenDir(
    WCHAR       *path,
    BOOL        fCreate,
    IStorage    **ppistg)
{
    if ( fCreate )
    {
        return(StgCreateStorage(path,
                                grfmode,
                                STGFMT_DIRECTORY,
                                NULL,
                                ppistg));
    }
    else
    {
        return(StgOpenStorage(path,
                              NULL,
                              grfmode,
                              NULL,
                              0,
                              ppistg));
    }
}

HRESULT OpenFile(
    WCHAR       *path,
    BOOL        fCreate,
    IStorage    **ppistg)
{
    if ( fCreate )
    {
        return(StgCreateStorage(path,
                                grfmode,
                                STGFMT_FILE,
                                NULL,
                                ppistg));
    }
    else
    {
        return(StgOpenStorage(path,
                              NULL,
                              grfmode,
                              NULL,
                              0,
                              ppistg));
    }
}

HRESULT OpenJP(
    WCHAR       *path,
    BOOL        fCreate,
    IStorage    **ppistg)
{
    HRESULT hr;
    HANDLE  h;

    hr = _Open(path, StorageTypeJunctionPoint, fCreate, &h);

    if ( SUCCEEDED(hr) )
    {
        if ( fCreate )
        {
            hr = StgCreateStorageOnHandle(h,
                                          grfmode,
                                          STGFMT_DIRECTORY,
                                          ppistg);
        }
        else
        {
            hr = StgOpenStorageOnHandle(h,
                                        grfmode,
                                        ppistg);
        }

        NtClose(h);
    }

    return(hr);
}

HRESULT OpenSC(
    WCHAR       *path,
    BOOL        fCreate,
    IStorage    **ppistg)
{
    if ( fCreate )
    {
        return(StgCreateStorage(path,
                                grfmode,
                                STGFMT_CATALOG,
                                NULL,
                                ppistg));
    }
    else
    {
        return(StgOpenStorage(path,
                              NULL,
                              grfmode,
                              NULL,
                              0,
                              ppistg));
    }
}

HRESULT OpenStg(
    WCHAR       *path,
    BOOL        fCreate,
    IStorage    **ppistg)

{
    if ( fCreate )
    {
        return(StgCreateStorage(path,
                                grfmode,
                                STGFMT_DOCUMENT,
                                NULL,
                                ppistg));
    }
    else
    {
        return(StgOpenStorage(path,
                              NULL,
                              grfmode,
                              NULL,
                              0,
                              ppistg));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\propdump.cxx ===
//+============================================================================
//
//  File:   PropDump.cxx
//
//  Purpose:
//          This file contains routines to dump all the properties of all
//          the property sets of a DocFile.  It's started by calling
//          DumpOleStorage().
//
//+============================================================================

//  --------
//  Includes
//  --------

#include "pch.cxx"


//  -------
//  Globals
//  -------

OLECHAR *oszDays[] =
{
    OLESTR("Sun"),
    OLESTR("Mon"),
    OLESTR("Tue"),
    OLESTR("Wed"),
    OLESTR("Thu"),
    OLESTR("Fri"),
    OLESTR("Sat")
};

OLECHAR *oszMonths[] =
{
    OLESTR("Jan"), OLESTR("Feb"), OLESTR("Mar"), OLESTR("Apr"), OLESTR("May"), OLESTR("Jun"),
    OLESTR("Jul"), OLESTR("Aug"), OLESTR("Sep"), OLESTR("Oct"), OLESTR("Nov"), OLESTR("Dec")
};


//+----------------------------------------------------------------------------
//+----------------------------------------------------------------------------

OLECHAR *
oszft(FILETIME *pft)
{
    static OLECHAR oszbuf[32];

#ifdef _MAC

    soprintf( oszbuf, OLESTR("%08X-%08X"), pft->dwHighDateTime, pft->dwLowDateTime );

#else

    FILETIME ftlocal;
    SYSTEMTIME st;

    oszbuf[0] = '\0';
    if (pft->dwHighDateTime != 0 || pft->dwLowDateTime != 0)
    {
        if (!FileTimeToLocalFileTime(pft, &ftlocal) ||
            !FileTimeToSystemTime(&ftlocal, &st))
        {
            return(OLESTR("Time???"));
        }
        soprintf(
            oszbuf,
            OLESTR("%s %s %2d %2d:%02d:%02d %4d"),
            oszDays[st.wDayOfWeek],
            oszMonths[st.wMonth - 1],
            st.wDay,
            st.wHour,
            st.wMinute,
            st.wSecond,
            st.wYear);
    }

#endif

    return(oszbuf);
}


VOID
DumpTime(OLECHAR *pozname, FILETIME *pft)
{
    LARGE_INTEGER UNALIGNED *pli = (LARGE_INTEGER UNALIGNED *) pft;

    ASYNC_PRINTF(
	"%s%08lx:%08lx%hs%s\n",
	pozname,
	pli->HighPart,
	pli->LowPart,
	pli->QuadPart == 0? g_szEmpty : " - ",
	oszft((FILETIME *) pft));
}


VOID
PrintGuid(GUID *pguid)
{
    ASYNC_PRINTF(
        "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        pguid->Data1,
        pguid->Data2,
        pguid->Data3,
        pguid->Data4[0],
        pguid->Data4[1],
        pguid->Data4[2],
        pguid->Data4[3],
        pguid->Data4[4],
        pguid->Data4[5],
        pguid->Data4[6],
        pguid->Data4[7]);
}


VOID
ListPropSetHeader(
    STATPROPSETSTG *pspss,
    OLECHAR *poszName)
{
    BOOLEAN fDocumentSummarySection2;
    OLECHAR oszStream[CCH_PROPSETSZ];

    fDocumentSummarySection2 = (BOOLEAN)
	memcmp(&pspss->fmtid, &FMTID_UserDefinedProperties, sizeof(GUID)) == 0;

    ASYNC_PRINTF(" Property set ");
    PrintGuid(&pspss->fmtid);

    RtlGuidToPropertySetName(&pspss->fmtid, oszStream);

    ASYNC_OPRINTF(
	OLESTR("\n  %hs Name %s"),
	(pspss->grfFlags & PROPSETFLAG_NONSIMPLE)?
	    "Embedding" : "Stream",
	oszStream);
    if (poszName != NULL || fDocumentSummarySection2)
    {
	ASYNC_OPRINTF(
	    OLESTR(" (%s)"),
	    poszName != NULL? poszName : OLESTR("User defined properties"));
    }
    ASYNC_PRINTF("\n");

    if (pspss->grfFlags & PROPSETFLAG_NONSIMPLE)
    {
	DumpTime(OLESTR("  Create Time "), &pspss->ctime);
    }
    DumpTime(OLESTR("  Modify Time "), &pspss->mtime);
    if (pspss->grfFlags & PROPSETFLAG_NONSIMPLE)
    {
	DumpTime(OLESTR("  Access Time "), &pspss->atime);
    }
}




typedef enum _PUBLICPROPSET
{
    PUBPS_UNKNOWN = 0,
    PUBPS_SUMMARYINFO = 3,
    PUBPS_DOCSUMMARYINFO = 4,
    PUBPS_USERDEFINED = 5,
} PUBLICPROPSET;


#define BSTRLEN(bstrVal)      *((ULONG *) bstrVal - 1)
ULONG
SizeProp(PROPVARIANT *pv)
{
    ULONG j;
    ULONG cbprop = 0;

    switch (pv->vt)
    {
    default:
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_UI1:
        cbprop = sizeof(pv->bVal);
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        cbprop = sizeof(pv->iVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        cbprop = sizeof(pv->lVal);
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        cbprop = sizeof(pv->hVal);
        break;

    case VT_CLSID:
        cbprop = sizeof(*pv->puuid);
        break;

    case VT_BLOB_OBJECT:
    case VT_BLOB:
        cbprop = pv->blob.cbSize + sizeof(pv->blob.cbSize);
        break;

    case VT_CF:
        cbprop = sizeof(pv->pclipdata->cbSize) +
                 pv->pclipdata->cbSize;
        break;

    case VT_BSTR:
	// count + string
	cbprop = sizeof(ULONG);
	if (pv->bstrVal != NULL)
	{
	    cbprop += BSTRLEN(pv->bstrVal);
	}
	break;

    case VT_LPSTR:
	// count + string + null char
	cbprop = sizeof(ULONG);
	if (pv->pszVal != NULL)
	{
	    cbprop += strlen(pv->pszVal) + 1;
	}
	break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_LPWSTR:
	// count + string + null char
	cbprop = sizeof(ULONG);
	if (pv->pwszVal != NULL)
	{
	    cbprop += sizeof(pv->pwszVal[0]) * (wcslen(pv->pwszVal) + 1);
	}
	break;

    //  vectors
    case VT_VECTOR | VT_UI1:
        cbprop = sizeof(pv->caub.cElems) +
             pv->caub.cElems * sizeof(pv->caub.pElems[0]);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        cbprop = sizeof(pv->cai.cElems) +
             pv->cai.cElems * sizeof(pv->cai.pElems[0]);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        cbprop = sizeof(pv->cal.cElems) +
             pv->cal.cElems * sizeof(pv->cal.pElems[0]);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        cbprop = sizeof(pv->cah.cElems) +
             pv->cah.cElems * sizeof(pv->cah.pElems[0]);
        break;

    case VT_VECTOR | VT_CLSID:
        cbprop = sizeof(pv->cauuid.cElems) +
             pv->cauuid.cElems * sizeof(pv->cauuid.pElems[0]);
        break;

    case VT_VECTOR | VT_CF:
        cbprop = sizeof(pv->caclipdata.cElems);
        for (j = 0; j < pv->caclipdata.cElems; j++)
        {
            cbprop += sizeof(pv->caclipdata.pElems[j].cbSize) +
                      DwordAlign(pv->caclipdata.pElems[j].cbSize);
        }
        break;

    case VT_VECTOR | VT_BSTR:
	cbprop = sizeof(pv->cabstr.cElems);
	for (j = 0; j < pv->cabstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->cabstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(BSTRLEN(pv->cabstr.pElems[j]));
	    }
	}
	break;

    case VT_VECTOR | VT_LPSTR:
	cbprop = sizeof(pv->calpstr.cElems);
	for (j = 0; j < pv->calpstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->calpstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(strlen(pv->calpstr.pElems[j]) + 1);
	    }
	}
	break;

    case VT_VECTOR | VT_LPWSTR:
	cbprop = sizeof(pv->calpwstr.cElems);
	for (j = 0; j < pv->calpwstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->calpwstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(
			sizeof(pv->calpwstr.pElems[j][0]) *
			(wcslen(pv->calpwstr.pElems[j]) + 1));
	    }
	}
	break;

    case VT_VECTOR | VT_VARIANT:
        cbprop = sizeof(pv->calpwstr.cElems);
        for (j = 0; j < pv->calpwstr.cElems; j++)
        {
            cbprop += SizeProp(&pv->capropvar.pElems[j]);
        }
        break;
    }
    return(DwordAlign(cbprop) + DwordAlign(sizeof(pv->vt)));
}


PUBLICPROPSET
GuidToPropSet(GUID *pguid)
{
    PUBLICPROPSET pubps = PUBPS_UNKNOWN;
	
    if (pguid != NULL)
    {
	if (memcmp(pguid, &FMTID_SummaryInformation, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_SUMMARYINFO;
	}
	else if (memcmp(pguid, &FMTID_DocSummaryInformation, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_DOCSUMMARYINFO;
	}
	else if (memcmp(pguid, &FMTID_UserDefinedProperties, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_USERDEFINED;
	}
    }
    return(pubps);
}


char
PrintableChar(char ch)
{
    if (ch < ' ' || ch > '~')
    {
        ch = '.';
    }
    return(ch);
}


VOID
DumpHex(BYTE *pb, ULONG cb, ULONG base)
{
    char *pszsep;
    ULONG r, i, cbremain = 0;
    int fZero = FALSE;
    int fSame = FALSE;

    for (r = 0; r < cb; r += 16)
    {
        cbremain = cb - r;
        if (r != 0 && cbremain >= 16)
        {
            if (pb[r] == 0)
            {
                ULONG j;

                for (j = r + 1; j < cb; j++)
                {
                    if (pb[j] != 0)
                    {
                        break;
                    }
                }
                if (j == cb)
                {
                    fZero = TRUE;
                    break;
                }
            }
            if (memcmp(&pb[r], &pb[r - 16], 16) == 0)
            {
                fSame = TRUE;
                continue;
            }
        }
        if (fSame)
        {
            ASYNC_PRINTF("\n\t  *");
            fSame = FALSE;
        }
        for (i = 0; i < min(cbremain, 16); i++)
        {
            pszsep = " ";
            if ((i % 8) == 0)           // 0 or 8
            {
                pszsep = "  ";
                if (i == 0)             // 0
                {
		    // start a new line
		    ASYNC_PRINTF("%s    %04x:", r == 0? "" : "\n", r + base);
		    pszsep = " ";
                }
            }
            ASYNC_PRINTF("%s%02x", pszsep, pb[r + i]);
        }
        if (i != 0)
        {
            ASYNC_PRINTF("%*s", 3 + (16 - i)*3 + ((i <= 8)? 1 : 0), "");
            for (i = 0; i < min(cbremain, 16); i++)
            {
                ASYNC_PRINTF("%c", PrintableChar(pb[r + i]));
            }
        }
    }
    if (r != 0)
    {
        ASYNC_PRINTF("\n");
    }
    if (fZero)
    {
        ASYNC_PRINTF("    Remaining %lx bytes are zero\n", cbremain);
    }
}


// Property Id's for Summary Info
#define PID_TITLE		0x00000002L	// VT_LPSTR
#define PID_SUBJECT		0x00000003L	// VT_LPSTR
#define PID_AUTHOR		0x00000004L	// VT_LPSTR
#define PID_KEYWORDS		0x00000005L	// VT_LPSTR
#define PID_COMMENTS		0x00000006L	// VT_LPSTR
#define PID_TEMPLATE		0x00000007L	// VT_LPSTR
#define PID_LASTAUTHOR		0x00000008L	// VT_LPSTR
#define PID_REVNUMBER		0x00000009L	// VT_LPSTR
#define PID_EDITTIME		0x0000000aL	// VT_FILETIME
#define PID_LASTPRINTED		0x0000000bL	// VT_FILETIME
#define PID_CREATE_DTM		0x0000000cL	// VT_FILETIME
#define PID_LASTSAVE_DTM	0x0000000dL	// VT_FILETIME
#define PID_PAGECOUNT		0x0000000eL	// VT_I4
#define PID_WORDCOUNT		0x0000000fL	// VT_I4
#define PID_CHARCOUNT		0x00000010L	// VT_I4
#define PID_THUMBNAIL		0x00000011L	// VT_CF
#define PID_APPNAME		0x00000012L	// VT_LPSTR
#define PID_SECURITY_DSI	0x00000013L	// VT_I4

// Property Id's for Document Summary Info
#define PID_CATEGORY		0x00000002L	// VT_LPSTR
#define PID_PRESFORMAT		0x00000003L	// VT_LPSTR
#define PID_BYTECOUNT		0x00000004L	// VT_I4
#define PID_LINECOUNT		0x00000005L	// VT_I4
#define PID_PARACOUNT		0x00000006L	// VT_I4
#define PID_SLIDECOUNT		0x00000007L	// VT_I4
#define PID_NOTECOUNT		0x00000008L	// VT_I4
#define PID_HIDDENCOUNT		0x00000009L	// VT_I4
#define PID_MMCLIPCOUNT		0x0000000aL	// VT_I4
#define PID_SCALE		0x0000000bL	// VT_BOOL
#define PID_HEADINGPAIR		0x0000000cL	// VT_VECTOR | VT_VARIANT
#define PID_DOCPARTS		0x0000000dL	// VT_VECTOR | VT_LPSTR
#define PID_MANAGER		0x0000000eL	// VT_LPSTR
#define PID_COMPANY		0x0000000fL	// VT_LPSTR
#define PID_LINKSDIRTY		0x00000010L	// VT_BOOL
#define PID_CCHWITHSPACES	0x00000011L	// VT_I4
#define PID_GUID		0x00000012L	// VT_LPSTR
#define PID_SHAREDDOC		0x00000013L	// VT_BOOL
#define PID_LINKBASE		0x00000014L	// VT_LPSTR
#define PID_HLINKS		0x00000015L	// VT_VECTOR | VT_VARIANT
#define PID_HYPERLINKSCHANGED	0x00000016L	// VT_BOOL


VOID
DisplayProps(
    GUID *pguid,
    ULONG cprop,
    PROPID apid[],
    STATPROPSTG asps[],
    PROPVARIANT *av,
    BOOLEAN fsumcat,
    ULONG *pcbprop)
{
    PROPVARIANT *pv;
    PROPVARIANT *pvend;
    STATPROPSTG *psps;
    BOOLEAN fVariantVector;
    PUBLICPROPSET pubps;

    fVariantVector = (asps == NULL);

    pubps = GuidToPropSet(pguid);
    pvend = &av[cprop];
    for (pv = av, psps = asps; pv < pvend; pv++, psps++)
    {
        ULONG j;
        ULONG cbprop;
        PROPID propid;
        OLECHAR *postrName;
        char *psz;
        BOOLEAN fNewLine = TRUE;
        int ccol;
        static char szNoFormat[] = " (no display format)";
        char achvt[19 + 8 + 1];

        cbprop = SizeProp(pv);
        *pcbprop += cbprop;

        postrName = NULL;
        if (asps != NULL)
        {
            propid = psps->propid;
            postrName = psps->lpwstrName;
        }
        else
        {
            ASSERT(apid != NULL);
            propid = apid[0];
        }

        ASYNC_PRINTF(" ");
        ccol = 0;

        if (propid != PID_ILLEGAL)
        {
            ASYNC_PRINTF(" %04x", propid);
            ccol += 5;
            if (propid & (0xf << 28))
            {
                ccol += 4;
            }
            else if (propid & (0xf << 24))
            {
                ccol += 3;
            }
            else if (propid & (0xf << 20))
            {
                ccol += 2;
            }
            else if (propid & (0xf << 16))
            {
                ccol++;
            }
        }
        if (postrName != NULL)
        {
	    ASYNC_OPRINTF(OLESTR(" '%s'"), postrName);
	    ccol += ocslen(postrName) + 3;
        }
        else if (fVariantVector)
        {
            ULONG i = (ULONG) ((ULONG_PTR)pv - (ULONG_PTR)av);

            ASYNC_PRINTF("[%x]", i);
            do
            {
                ccol++;
                i >>= 4;
            } while (i != 0);
            ccol += 2;
        }
        else
        {
            psz = NULL;

            switch (propid)
            {
                case PID_LOCALE:               psz = "Locale";           break;
                case PID_SECURITY:             psz = "SecurityId";       break;
                case PID_MODIFY_TIME:          psz = "ModifyTime";       break;
                case PID_CODEPAGE:             psz = "CodePage";         break;
                case PID_DICTIONARY:           psz = "Dictionary";       break;
            }
            if (psz == NULL)
		switch (pubps)
		{
		case PUBPS_SUMMARYINFO:
		    switch (propid)
		    {
		    case PID_TITLE:              psz = "Title";          break;
		    case PID_SUBJECT:            psz = "Subject";        break;
		    case PID_AUTHOR:             psz = "Author";         break;
		    case PID_KEYWORDS:           psz = "Keywords";       break;
		    case PID_COMMENTS:           psz = "Comments";       break;
		    case PID_TEMPLATE:           psz = "Template";       break;
		    case PID_LASTAUTHOR:         psz = "LastAuthor";     break;
		    case PID_REVNUMBER:          psz = "RevNumber";      break;
		    case PID_EDITTIME:           psz = "EditTime";       break;
		    case PID_LASTPRINTED:        psz = "LastPrinted";    break;
		    case PID_CREATE_DTM:         psz = "CreateDateTime"; break;
		    case PID_LASTSAVE_DTM:       psz = "LastSaveDateTime";break;
		    case PID_PAGECOUNT:          psz = "PageCount";      break;
		    case PID_WORDCOUNT:          psz = "WordCount";      break;
		    case PID_CHARCOUNT:          psz = "CharCount";      break;
		    case PID_THUMBNAIL:          psz = "ThumbNail";      break;
		    case PID_APPNAME:            psz = "AppName";        break;
		    case PID_DOC_SECURITY:       psz = "Security";       break;

		    }
		    break;

		case PUBPS_DOCSUMMARYINFO:
		    switch (propid)
		    {
		    case PID_CATEGORY:          psz = "Category";        break;
		    case PID_PRESFORMAT:        psz = "PresFormat";      break;
		    case PID_BYTECOUNT:         psz = "ByteCount";       break;
		    case PID_LINECOUNT:         psz = "LineCount";       break;
		    case PID_PARACOUNT:         psz = "ParaCount";       break;
		    case PID_SLIDECOUNT:        psz = "SlideCount";      break;
		    case PID_NOTECOUNT:         psz = "NoteCount";       break;
		    case PID_HIDDENCOUNT:       psz = "HiddenCount";     break;
		    case PID_MMCLIPCOUNT:       psz = "MmClipCount";     break;
		    case PID_SCALE:             psz = "Scale";           break;
		    case PID_HEADINGPAIR:       psz = "HeadingPair";     break;
		    case PID_DOCPARTS:          psz = "DocParts";        break;
		    case PID_MANAGER:           psz = "Manager";         break;
		    case PID_COMPANY:           psz = "Company";         break;
		    case PID_LINKSDIRTY:        psz = "LinksDirty";      break;
		    case PID_CCHWITHSPACES:     psz = "CchWithSpaces";   break;
		    case PID_GUID:              psz = "Guid";            break;
		    case PID_SHAREDDOC:         psz = "SharedDoc";       break;
		    case PID_LINKBASE:          psz = "LinkBase";        break;
		    case PID_HLINKS:            psz = "HLinks";          break;
		    case PID_HYPERLINKSCHANGED:	psz = "HyperLinksChanged";break;
		    }
		    break;
            }
            if (psz != NULL)
            {
                ASYNC_PRINTF(" %s", psz);
                ccol += strlen(psz) + 1;
            }
        }
#define CCOLPROPID 20
        if (ccol != CCOLPROPID)
	{
	    if (ccol > CCOLPROPID)
	    {
		ccol = -1;
	    }
            ASYNC_PRINTF("%s%*s", ccol == -1? "\n" : "", CCOLPROPID - ccol, "");
	}
        ASYNC_PRINTF(" %08x  %04x  %04x ", propid, cbprop, pv->vt);

        psz = "";
        switch (pv->vt)
        {
        default:
            psz = achvt;
            sprintf(psz, "Unknown (vt = %hx)", pv->vt);
            break;

        case VT_EMPTY:
            ASYNC_PRINTF("EMPTY");
            break;

        case VT_NULL:
            ASYNC_PRINTF("NULL");
            break;

        case VT_UI1:
            ASYNC_PRINTF("UI1 = %02lx", pv->bVal);
            psz = "";
            break;

        case VT_I2:
            psz = "I2";
            goto doshort;

        case VT_UI2:
            psz = "UI2";
            goto doshort;

        case VT_BOOL:
            psz = "BOOL";
doshort:
            ASYNC_PRINTF("%s = %04hx", psz, pv->iVal);
            psz = g_szEmpty;
            break;

        case VT_I4:
            psz = "I4";
            goto dolong;

        case VT_UI4:
            psz = "UI4";
            goto dolong;

        case VT_R4:
            psz = "R4";
            goto dolong;

        case VT_ERROR:
            psz = "ERROR";
dolong:
            ASYNC_PRINTF("%s = %08lx", psz, pv->lVal);
            psz = g_szEmpty;
            break;

        case VT_I8:
            psz = "I8";
            goto dolonglong;

        case VT_UI8:
            psz = "UI8";
            goto dolonglong;

        case VT_R8:
            psz = "R8";
            goto dolonglong;

        case VT_CY:
            psz = "R8";
            goto dolonglong;

        case VT_DATE:
            psz = "R8";
dolonglong:
            ASYNC_PRINTF(
                "%s = %08lx:%08lx",
                psz,
                pv->hVal.HighPart,
                pv->hVal.LowPart);
            psz = g_szEmpty;
            break;

        case VT_FILETIME:
            DumpTime(OLESTR("FILETIME =\n\t  "), &pv->filetime);
            fNewLine = FALSE;           // skip newline printf
            break;

        case VT_CLSID:
            ASYNC_PRINTF("CLSID =\n\t  ");
            PrintGuid(pv->puuid);
            break;

        case VT_BLOB:
            psz = "BLOB";
            goto doblob;

        case VT_BLOB_OBJECT:
            psz = "BLOB_OBJECT";
doblob:
            ASYNC_PRINTF("%s (cbSize %x)", psz, pv->blob.cbSize);
            if (pv->blob.cbSize != 0)
            {
                ASYNC_PRINTF(" =\n");
                DumpHex(pv->blob.pBlobData, pv->blob.cbSize, 0);
            }
            psz = g_szEmpty;
            break;

        case VT_CF:
            ASYNC_PRINTF(
                "CF (cbSize %x, ulClipFmt %x)\n",
                pv->pclipdata->cbSize,
                pv->pclipdata->ulClipFmt);
            DumpHex(pv->pclipdata->pClipData,
                    pv->pclipdata->cbSize - sizeof(pv->pclipdata->ulClipFmt),
                    0);
            break;

        case VT_STREAM:
            psz = "STREAM";
            goto dostring;

        case VT_STREAMED_OBJECT:
            psz = "STREAMED_OBJECT";
            goto dostring;

        case VT_STORAGE:
            psz = "STORAGE";
            goto dostring;

        case VT_STORED_OBJECT:
            psz = "STORED_OBJECT";
            goto dostring;

        case VT_BSTR:
            ASYNC_PRINTF(
		"BSTR (cb = %04lx)%s\n",
		pv->bstrVal == NULL? 0 : BSTRLEN(pv->bstrVal),
		pv->bstrVal == NULL? " NULL" : g_szEmpty);
            if (pv->bstrVal != NULL)
	    {
		DumpHex(
		    (BYTE *) pv->bstrVal,
		    BSTRLEN(pv->bstrVal) + sizeof(WCHAR),
		    0);
	    }
            break;

        case VT_LPSTR:
            psz = "LPSTR";
            ASYNC_PRINTF(
		"%s = %s%s%s",
		psz,
		pv->pszVal == NULL? g_szEmpty : "'",
		pv->pszVal == NULL? "NULL" : pv->pszVal,
		pv->pszVal == NULL? g_szEmpty : "'");
	    psz = g_szEmpty;
            break;

        case VT_LPWSTR:
            psz = "LPWSTR";
dostring:
            ASYNC_PRINTF(
		"%s = %s%ws%s",
		psz,
		pv->pwszVal == NULL? g_szEmpty : "'",
		pv->pwszVal == NULL? L"NULL" : pv->pwszVal,
		pv->pwszVal == NULL? g_szEmpty : "'");
            psz = g_szEmpty;
            break;

        //  vectors

        case VT_VECTOR | VT_UI1:
            ASYNC_PRINTF("UI1[%x] =", pv->caub.cElems);
            for (j = 0; j < pv->caub.cElems; j++)
            {
                if ((j % 16) == 0)
                {
                    ASYNC_PRINTF("\n    %02hx:", j);
                }
                ASYNC_PRINTF(" %02hx", pv->caub.pElems[j]);
            }
            break;

        case VT_VECTOR | VT_I2:
            psz = "I2";
            goto doshortvector;

        case VT_VECTOR | VT_UI2:
            psz = "UI2";
            goto doshortvector;

        case VT_VECTOR | VT_BOOL:
            psz = "BOOL";
doshortvector:
            ASYNC_PRINTF("%s[%x] =", psz, pv->cai.cElems);
            for (j = 0; j < pv->cai.cElems; j++)
            {
                if ((j % 8) == 0)
                {
                    ASYNC_PRINTF("\n    %04hx:", j);
                }
                ASYNC_PRINTF(" %04hx", pv->cai.pElems[j]);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_I4:
            psz = "I4";
            goto dolongvector;

        case VT_VECTOR | VT_UI4:
            psz = "UI4";
            goto dolongvector;

        case VT_VECTOR | VT_R4:
            psz = "R4";
            goto dolongvector;

        case VT_VECTOR | VT_ERROR:
            psz = "ERROR";
dolongvector:
            ASYNC_PRINTF("%s[%x] =", psz, pv->cal.cElems);
            for (j = 0; j < pv->cal.cElems; j++)
            {
                if ((j % 4) == 0)
                {
                    ASYNC_PRINTF("\n    %04x:", j);
                }
                ASYNC_PRINTF(" %08lx", pv->cal.pElems[j]);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_I8:
            psz = "I8";
            goto dolonglongvector;

        case VT_VECTOR | VT_UI8:
            psz = "UI8";
            goto dolonglongvector;

        case VT_VECTOR | VT_R8:
            psz = "R8";
            goto dolonglongvector;

        case VT_VECTOR | VT_CY:
            psz = "CY";
            goto dolonglongvector;

        case VT_VECTOR | VT_DATE:
            psz = "DATE";
dolonglongvector:
            ASYNC_PRINTF("%s[%x] =", psz, pv->cah.cElems);
            for (j = 0; j < pv->cah.cElems; j++)
            {
                if ((j % 2) == 0)
                {
                    ASYNC_PRINTF("\n    %04x:", j);
                }
                ASYNC_PRINTF(
                    " %08lx:%08lx",
                    pv->cah.pElems[j].HighPart,
                    pv->cah.pElems[j].LowPart);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_FILETIME:
            ASYNC_PRINTF("FILETIME[%x] =\n", pv->cafiletime.cElems);
            for (j = 0; j < pv->cafiletime.cElems; j++)
            {
		ASYNC_PRINTF("    %04x: ", j);
		DumpTime(OLESTR(""), &pv->cafiletime.pElems[j]);
            }
            fNewLine = FALSE;           // skip newline printf
            break;

        case VT_VECTOR | VT_CLSID:
            ASYNC_PRINTF("CLSID[%x] =", pv->cauuid.cElems);
            for (j = 0; j < pv->cauuid.cElems; j++)
            {
                ASYNC_PRINTF("\n    %04x: ", j);
                PrintGuid(&pv->cauuid.pElems[j]);
            }
            break;

        case VT_VECTOR | VT_CF:
            ASYNC_PRINTF("CF[%x] =", pv->caclipdata.cElems);
            for (j = 0; j < pv->caclipdata.cElems; j++)
            {
                ASYNC_PRINTF("\n    %04x: (cbSize %x, ulClipFmt %x) =\n",
                    j,
                    pv->caclipdata.pElems[j].cbSize,
                    pv->caclipdata.pElems[j].ulClipFmt);
                DumpHex(
                    pv->caclipdata.pElems[j].pClipData,
                    pv->caclipdata.pElems[j].cbSize - sizeof(pv->caclipdata.pElems[j].ulClipFmt),
		    0);
            }
            break;

        case VT_VECTOR | VT_BSTR:
            ASYNC_PRINTF("BSTR[%x] =", pv->cabstr.cElems);
            for (j = 0; j < pv->cabstr.cElems; j++)
            {
		BSTR bstr = pv->cabstr.pElems[j];

                ASYNC_PRINTF(
		    "\n    %04x: cb = %04lx%s\n",
		    j,
		    bstr == NULL? 0 : BSTRLEN(pv->cabstr.pElems[j]),
		    bstr == NULL? " NULL" : g_szEmpty);
		if (bstr != NULL)
		{
		    DumpHex((BYTE *) bstr, BSTRLEN(bstr) + sizeof(WCHAR), 0);
		}
            }
            break;

        case VT_VECTOR | VT_LPSTR:
            ASYNC_PRINTF("LPSTR[%x] =", pv->calpstr.cElems);
            for (j = 0; j < pv->calpstr.cElems; j++)
            {
		CHAR *psz = pv->calpstr.pElems[j];

                ASYNC_PRINTF(
		    "\n    %04x: %s%s%s",
		    j,
		    psz == NULL? g_szEmpty : "'",
		    psz == NULL? "NULL" : psz,
		    psz == NULL? g_szEmpty : "'");
            }
            break;

        case VT_VECTOR | VT_LPWSTR:
            ASYNC_PRINTF("LPWSTR[%x] =", pv->calpwstr.cElems);
            for (j = 0; j < pv->calpwstr.cElems; j++)
            {
		WCHAR *pwsz = pv->calpwstr.pElems[j];

                ASYNC_PRINTF(
		    "\n    %04x: %s%ws%s",
		    j,
		    pwsz == NULL? g_szEmpty : "'",
		    pwsz == NULL? L"NULL" : pwsz,
		    pwsz == NULL? g_szEmpty : "'");
            }
            break;

        case VT_VECTOR | VT_VARIANT:
            ASYNC_PRINTF("VARIANT[%x] =\n", pv->capropvar.cElems);
            DisplayProps(
		    pguid,
                    pv->capropvar.cElems,
                    &propid,
                    NULL,
                    pv->capropvar.pElems,
		    fsumcat,
                    pcbprop);
            fNewLine = FALSE;           // skip newline printf
            break;
        }
        if (*psz != '\0')
        {
            ASYNC_PRINTF("%s", psz);
            if (pv->vt & VT_VECTOR)
            {
                ASYNC_PRINTF("[%x]", pv->cal.cElems);
            }
            ASYNC_PRINTF("%s", szNoFormat);
        }
        if (!fVariantVector && apid != NULL && apid[pv - av] != propid)
        {
            ASYNC_PRINTF(" (bad PROPID: %04x)", apid[pv - av]);
            fNewLine = TRUE;
        }
        if (asps != NULL && pv->vt != psps->vt)
        {
            ASYNC_PRINTF(" (bad STATPROPSTG VARTYPE: %04x)", psps->vt);
            fNewLine = TRUE;
        }
        if (fNewLine)
        {
            ASYNC_PRINTF("\n");
        }
    }
}


STATPROPSTG aspsStatic[] = {
    { NULL, PID_CODEPAGE,    VT_I2 },
    { NULL, PID_MODIFY_TIME, VT_FILETIME },
    { NULL, PID_SECURITY,    VT_UI4 },
};
#define CPROPSTATIC      (sizeof(aspsStatic)/sizeof(aspsStatic[0]))


#define CB_STREAM_OVERHEAD      28
#define CB_PROPSET_OVERHEAD     (CB_STREAM_OVERHEAD + 8)
#define CB_PROP_OVERHEAD        8

HRESULT
DumpOlePropertySet(
    IPropertySetStorage *ppsstg,
    STATPROPSETSTG *pspss,
    ULONG *pcprop,
    ULONG *pcbprop)
{
    HRESULT hr;
    IEnumSTATPROPSTG *penumsps = NULL;
    IPropertyStorage *pps;
    ULONG cprop, cbpropset;
    PROPID propid;
    OLECHAR *poszName;
    ULONG ispsStatic;

    *pcprop = *pcbprop = 0;

    hr = ppsstg->Open(
		    pspss->fmtid,
		    STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
		    &pps);

    if( FAILED(hr) )
        return(hr);

    propid = PID_DICTIONARY;

    hr = pps->ReadPropertyNames(1, &propid, &poszName);
    if( (HRESULT) S_FALSE == hr )
        hr = S_OK;
    Check( S_OK, hr );

    ListPropSetHeader(pspss, poszName);
    if (poszName != NULL)
    {
	CoTaskMemFree(poszName);
    }

    cprop = cbpropset = 0;

    Check(S_OK, pps->Enum(&penumsps) );

    ispsStatic = 0;
    hr = S_OK;
    while (hr == S_OK)
    {
        STATPROPSTG sps = {NULL, 0, 0};
	PROPSPEC propspec;
	PROPVARIANT propvar;
	ULONG count = 0;

	hr = (HRESULT) S_FALSE;
	if (ispsStatic == 0)
	{
	    hr = penumsps->Next(1, &sps, &count);
	}

	if (hr != S_OK)
	{
	    if (hr == (HRESULT) S_FALSE)
	    {
		hr = S_OK;
		if (ispsStatic >= CPROPSTATIC)
		{
		    break;
		}
		sps = aspsStatic[ispsStatic];
		ispsStatic++;
		count = 1;
	    }
            Check( S_OK, hr );
	}
	PropVariantInit(&propvar);
	if (sps.lpwstrName != NULL)
	{
	    propspec.ulKind = PRSPEC_LPWSTR;
	    propspec.lpwstr = sps.lpwstrName;
	}
	else
	{
	    propspec.ulKind = PRSPEC_PROPID;
	    propspec.propid = sps.propid;
	}

        hr = pps->ReadMultiple(1, &propspec, &propvar);
	if (hr == (HRESULT) S_FALSE)
	{
	    if (g_fVerbose)
	    {
		ASYNC_PRINTF(
		    "%s(%u, %x) vt=%x returned hr=%x\n",
		    "IPropertyStorage::ReadMultiple",
		    ispsStatic,
		    propspec.propid,
		    propvar.vt,
		    hr);
	    }
	    ASSERT(propvar.vt == VT_EMPTY);
	    hr = S_OK;
	}
        Check( S_OK, hr );

	if (ispsStatic == 0 || propvar.vt != VT_EMPTY)
	{
	    ASSERT(count == 1);
	    cprop += count;
	    if (cprop == 1)
	    {
		ASYNC_PRINTF(g_szPropHeader);
	    }

	    DisplayProps(
		    &pspss->fmtid,
		    1,
		    NULL,
		    &sps,
		    &propvar,
		    FALSE,
		    &cbpropset);
	    g_pfnPropVariantClear(&propvar);
	}
	if (sps.lpwstrName != NULL)
	{
	    CoTaskMemFree(sps.lpwstrName);
	}
    }
    if (penumsps != NULL)
    {
	penumsps->Release();
    }
    pps->Release();
    if (cprop != 0)
    {
	cbpropset += CB_PROPSET_OVERHEAD + cprop * CB_PROP_OVERHEAD;
	ASYNC_PRINTF("  %04x bytes in %u properties\n\n", cbpropset, cprop);
    }
    *pcprop = cprop;
    *pcbprop = cbpropset;
    return(hr);
}


HRESULT
DumpOlePropertySets(
    IStorage *pstg,
    IPropertySetStorage *pIPropSetStorage,
    OLECHAR *aocpath)
{

    HRESULT hr = S_OK;
    IPropertySetStorage *ppsstg = pIPropSetStorage;
    ULONG cbproptotal = 0;
    ULONG cproptotal = 0;
    ULONG cpropset = 0;
    IID IIDpsstg = IID_IPropertySetStorage;

    if (ppsstg == NULL)
    {
        Check(S_OK, StgToPropSetStg( pstg, &ppsstg ));
    }

    {
	IEnumSTATPROPSETSTG *penumspss = NULL;

	Check(S_OK, ppsstg->Enum(&penumspss) );

	while (hr == S_OK)
	{
	    STATPROPSETSTG spss;
	    ULONG count;
	    BOOLEAN fDocumentSummarySection2;

	    hr = penumspss->Next(1, &spss, &count);

	    if (hr != S_OK)
	    {
		if (hr == (HRESULT) S_FALSE)
		{
		    hr = (HRESULT) S_OK;
		}

                Check( (HRESULT) S_OK, hr );
		break;
	    }
	    ASSERT(count == 1);

	    fDocumentSummarySection2 = FALSE;
	    while (TRUE)
	    {
		ULONG cprop, cbprop;
                HRESULT hr;

		hr = DumpOlePropertySet(
				ppsstg,
				&spss,
				&cprop,
				&cbprop);

                if( (HRESULT) STG_E_FILENOTFOUND == hr
                    &&
                    fDocumentSummarySection2 )
                {
                    hr = S_OK;
                }

		cpropset++;
		cproptotal += cprop;
		cbproptotal += cbprop;

		if (memcmp(&spss.fmtid, &FMTID_DocSummaryInformation, sizeof(FMTID)))
		{
		    break;
		}
		spss.fmtid = FMTID_UserDefinedProperties;
		fDocumentSummarySection2 = TRUE;
	    }
	}

	if (penumspss != NULL)
	{
	    penumspss->Release();
	}
	ppsstg->Release();
    }
    if ((cbproptotal | cproptotal | cpropset) != 0)
    {
	ASYNC_PRINTF(
	    " %04x bytes in %u properties in %u property sets\n",
	    cbproptotal,
	    cproptotal,
	    cpropset);
    }
    return(hr);
}


NTSTATUS
DumpOleStream(
    LPSTREAM pstm,
    ULONG cb)
{
    ULONG cbTotal = 0;

    while (TRUE)
    {
	ULONG cbOut;
	BYTE ab[4096];

	Check(S_OK, pstm->Read(ab, min(cb, sizeof(ab)), &cbOut) );
	if (cbOut == 0)
	{
	    break;
	}
	if (g_fVerbose)
	{
	    DumpHex(ab, cbOut, cbTotal);
	}
	cb -= cbOut;
	cbTotal += cbOut;
    }
    return(STATUS_SUCCESS);
}

VOID
DumpOleStorage(
    IStorage *pstg,
    IPropertySetStorage *pIPropertySetStorage,
    LPOLESTR aocpath )
{
    LPENUMSTATSTG penum;
    STATSTG ss;
    IStorage* pstgChild;
    LPSTREAM pstmChild;
    char *szType;
    OLECHAR *pocChild;
    HRESULT hr;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    Check( S_OK, DumpOlePropertySets(pstg, pIPropertySetStorage, aocpath) );

    if (NULL == pstg)
    {
        return;
    }
    Check( S_OK, pstg->EnumElements(0, NULL, 0, &penum) );

    pocChild = &aocpath[ocslen(aocpath)];

    // Continue enumeration until IEnumStatStg::Next returns non-S_OK

    while (TRUE)
    {
	ULONG ulCount;

        // Enumerate one element at a time
        hr = penum->Next(1, &ss, &ulCount);
        if( (HRESULT) S_FALSE == hr )
            break;
        else
            Check( S_OK, hr );

        // Select the human-readable type of object to display
        switch (ss.type)
        {
	    case STGTY_STREAM:    szType = "Stream";    break;
	    case STGTY_STORAGE:   szType = "Storage";   break;
	    case STGTY_LOCKBYTES: szType = "LockBytes"; break;
	    case STGTY_PROPERTY:  szType = "Property";  break;
	    default:              szType = "<Unknown>"; break;
        }
	if (g_fVerbose)
	{
	    ASYNC_OPRINTF(
		OLESTR("Type=%hs Size=%lx Mode=%lx LocksSupported=%lx StateBits=%lx '%s' + '%s'\n"),
		szType,
		ss.cbSize.LowPart,
		ss.grfMode,
		ss.grfLocksSupported,
		ss.grfStateBits,
		aocpath,
		ss.pwcsName);
	    ASYNC_PRINTF("ss.clsid = ");
	    PrintGuid(&ss.clsid);
	    ASYNC_PRINTF("\n");
	}

        // If a stream, output the data in hex format.

        if (ss.type == STGTY_STREAM)
        {
	    ASYNC_OPRINTF(
		OLESTR("Stream  %s:%s, Size=%lx\n"),
		aocpath,
		ss.pwcsName,
		ss.cbSize.LowPart);

	    Check(S_OK, pstg->OpenStream(
				    ss.pwcsName,
				    NULL,
				    STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
				    0,
				    &pstmChild) );

	    Check(S_OK, DumpOleStream(pstmChild, ss.cbSize.LowPart) );
	    pstmChild->Release();
	}

        // If a storage, recurse
        if (ss.type == STGTY_STORAGE)
        {
	    ASYNC_OPRINTF(
		OLESTR("Storage %s\\%s, Size=%lx\n"),
		aocpath,
		ss.pwcsName,
		ss.cbSize.LowPart);
            Check( S_OK, pstg->OpenStorage(
				    ss.pwcsName,
				    NULL,
				    STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
				    NULL,
				    0,
				    &pstgChild) );
	    *pocChild = L'\\';
	    ocscpy(pocChild + 1, ss.pwcsName);

	    DumpOleStorage(pstgChild, NULL, aocpath);
	    pstgChild->Release();

	    *pocChild = L'\0';
        }
        CoTaskMemFree(ss.pwcsName);
        PRINTF( "\n" );
    }
    penum->Release();
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\rtlstub.cxx ===
//+============================================================================
//
//  File:   RtlStub.cxx
//
//  Purpose:
//          This file provides some RTL routines which are also implemented
//          in NTDLL.  They are duplicated here so that we can build
//          PropTest without linking to NTDLL, which doesn't exist
//          on Win95.
//
//+============================================================================



#include "pch.cxx"          // Brings in most other includes/defines/etc.

#define BSTRLEN(bstrVal)      *((ULONG *) bstrVal - 1)

// we use static array instead of string literals because some systems
// have 4 bytes string literals, and would not produce the correct result
// for REF's 2 byte Unicode convention
// 
OLECHAR aocMap[CCH_MAP + 1] = {'a','b','c','d','e','f','g',
                               'h','i','j','k','l','m','n',
                               'o','p','q','r','s','t','u',
                               'v','w','x','y','z',
                               '0','1','2','3','4','5','\0'};

GUID guidSummary =
    { 0xf29f85e0,
      0x4ff9, 0x1068,
      { 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 } };

OLECHAR oszSummary[] = {'S','u','m','m','a','r','y',
                        'I','n','f','o','r','m','a','t','i','o','n','\0'};

GUID guidDocumentSummary =
    { 0xd5cdd502,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

OLECHAR oszDocumentSummary[] = {'D','o','c','u','m','e','n','t',
                                'S','u','m','m','a','r','y',
                                'I','n','f','o','r','m','a','t','i','o','n',
                                '\0'};

// Note that user defined properties are placed in section 2 with the below
// GUID as the FMTID -- alas, we did not expect Office95 to actually use it.

GUID guidDocumentSummarySection2 =
    { 0xd5cdd505,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

// *Global Info*

GUID guidGlobalInfo =
    { 0x56616F00,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Contents*

GUID guidImageContents =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Info*

GUID guidImageInfo =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };


//+--------------------------------------------------------------------------
// Function:    RtlGuidToPropertySetName
//
// Synopsis:    Map property set GUID to null-terminated UNICODE name string.
//
//              The awcname parameter is assumed to be a buffer with room for
//              CWC_PROPSETSZ (28) UNICODE characters.  The first character
//              is always WC_PROPSET0 (0x05), as specified by the OLE Appendix
//              B documentation.  The colon character normally used as an NT
//              stream name separator is not written to the caller's buffer.
//
//              No error is possible.
//
// Arguments:   IN GUID *pguid        -- pointer to GUID to convert
//              OUT OLECHAR aocname[] -- output string buffer
//
// Returns:     count of non-NULL characters in the output string buffer
//---------------------------------------------------------------------------

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[])
{
    ULONG cbitRemain = CBIT_BYTE;
    OLECHAR *poc = aocname;

    BYTE *pb;
    BYTE *pbEnd;    

    *poc++ = OC_PROPSET0;

    //  -----------------------
    //  Check for special-cases
    //  -----------------------

    // Note: CCH_PROPSET includes the OC_PROPSET0, and sizeof(osz...)
    // includes the trailing '\0', so sizeof(osz...) is ok because the
    // OC_PROPSET0 character compensates for the trailing NULL character.

    // Is this the SummaryInformation propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszSummary)/sizeof(OLECHAR));

    if (*pguid == guidSummary)
    {
        RtlCopyMemory(poc, oszSummary, sizeof(oszSummary));
        return(sizeof(oszSummary)/sizeof(OLECHAR));
    }

    // Is this The DocumentSummaryInformation or User-Defined propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszDocumentSummary)/sizeof(OLECHAR));

    if (*pguid == guidDocumentSummary || *pguid == guidDocumentSummarySection2)
    {
        RtlCopyMemory(poc, oszDocumentSummary, sizeof(oszDocumentSummary));
        return(sizeof(oszDocumentSummary)/sizeof(OLECHAR));
    }

    // Is this the Global Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszGlobalInfo)/sizeof(OLECHAR));
    if (*pguid == guidGlobalInfo)
    {
        RtlCopyMemory(poc, oszGlobalInfo, cboszGlobalInfo);
        return(cboszGlobalInfo/sizeof(OLECHAR));
    }

    // Is this the Image Contents propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageContents)/sizeof(OLECHAR));
    if (*pguid == guidImageContents)
    {
        RtlCopyMemory(poc, oszImageContents, cboszImageContents);
        return(cboszImageContents/sizeof(OLECHAR));
    }

    // Is this the Image Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageInfo)/sizeof(OLECHAR));
    if (*pguid == guidImageInfo)
    {
        RtlCopyMemory(poc, oszImageInfo, cboszImageInfo);
        return(cboszImageInfo/sizeof(OLECHAR));
    }


    //  ------------------------------
    //  Calculate the string-ized GUID
    //  ------------------------------

    // If this is a big-endian system, we need to convert
    // the GUID to little-endian for the conversion.

#if BIGENDIAN
    GUID guidByteSwapped = *pguid;
    PropByteSwap( &guidByteSwapped );
    pguid = &guidByteSwapped;
#endif

    // Point to the beginning and ending of the GUID
    pb = (BYTE*) pguid;
    pbEnd = pb + sizeof(*pguid);

    // Walk 'pb' through each byte of the GUID.

    while (pb < pbEnd)
    {
        ULONG i = *pb >> (CBIT_BYTE - cbitRemain);

        if (cbitRemain >= CBIT_CHARMASK)
        {
            *poc = MapChar(i);
            if (cbitRemain == CBIT_BYTE && *poc >= (OLECHAR)'a' 
                && *poc <= ((OLECHAR)'z'))
            {
                *poc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a') );
            }
            poc++;
            cbitRemain -= CBIT_CHARMASK;
            if (cbitRemain == 0)
            {
                pb++;
                cbitRemain = CBIT_BYTE;
            }
        }
        else
        {
            if (++pb < pbEnd)
            {
                i |= *pb << cbitRemain;
            }
            *poc++ = MapChar(i);
            cbitRemain += CBIT_BYTE - CBIT_CHARMASK;
        }
    }   // while (pb < pbEnd)

    *poc = OLESTR( '\0' );
    return(CCH_PROPSET);

}


//+--------------------------------------------------------------------------
// Function:    RtlPropertySetNameToGuid
//
// Synopsis:    Map non null-terminated UNICODE string to a property set GUID.
//
//              If the name is not properly formed as per
//              RtlGuidToPropertySetName(), STATUS_INVALID_PARAMETER is
//              returned.  The pguid parameter is assumed to point to a buffer
//              with room for a GUID structure.
//
// Arguments:   IN ULONG cocname     -- count of OLECHARs in string to convert
//              IN OLECHAR aocname[] -- input string to convert
//              OUT GUID *pguid      -- pointer to buffer for converted GUID
//
// Returns:     NTSTATUS
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlPropertySetNameToGuid(
    IN ULONG cocname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    OLECHAR const *poc = aocname;

    if (poc[0] == OC_PROPSET0)
    {
        //  -----------------------
        //  Check for Special-Cases 
        //  -----------------------

        // Note: cocname includes the OC_PROPSET0, and sizeof(osz...)
        // includes the trailing OLESTR('\0'), but the comparison excludes both
        // the leading OC_PROPSET0 and the trailing '\0'.

        // Is this SummaryInformation?
        if (cocname == sizeof(oszSummary)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszSummary, cocname - 1) == 0)
        {
            *pguid = guidSummary;
            return(STATUS_SUCCESS);
        }

        // Is this DocumentSummaryInformation?
        if (cocname == sizeof(oszDocumentSummary)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszDocumentSummary, cocname - 1) == 0)
        {
            *pguid = guidDocumentSummary;
            return(STATUS_SUCCESS);
        }

        // Is this Global Info?
        if (cocname == cboszGlobalInfo/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszGlobalInfo, cocname - 1) == 0)
        {
            *pguid = guidGlobalInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Info?
        if (cocname == cboszImageInfo/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszImageInfo, cocname - 1) == 0)
        {
            *pguid = guidImageInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Contents?
        if (cocname == cboszImageContents/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszImageContents, cocname - 1) == 0)
        {
            *pguid = guidImageContents;
            return(STATUS_SUCCESS);
        }

        //  ------------------
        //  Calculate the GUID
        //  ------------------

        // None of the special-cases hit, so we must calculate
        // the GUID from the name.

        if (cocname == CCH_PROPSET)
        {
            ULONG cbit;
            BYTE *pb = (BYTE *) pguid - 1;

            RtlZeroMemory(pguid, sizeof(*pguid));
            for (cbit = 0; cbit < CBIT_GUID; cbit += CBIT_CHARMASK)
            {
                ULONG cbitUsed = cbit % CBIT_BYTE;
                ULONG cbitStored;
                OLECHAR oc;

                if (cbitUsed == 0)
                {
                    pb++;
                }

                oc = *++poc - (OLECHAR)'A'; // assume upper case 
                // for wchar (unsigned) -ve values becomes a large number
                // but for char, which is signed, -ve is -ve
                if (oc > CALPHACHARS || oc < 0)
                {
                    // oops, try lower case
                    oc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a'));
                    if (oc > CALPHACHARS || oc < 0)
                    {
                        // must be a digit
                        oc += ((OLECHAR)'a') - ((OLECHAR)'0') + CALPHACHARS;
                        if (oc > CHARMASK)
                        {
                            goto Exit;                  // invalid character
                        }
                    }
                }
                *pb |= (BYTE) (oc << cbitUsed);

                cbitStored = min(CBIT_BYTE - cbitUsed, CBIT_CHARMASK);

                // If the translated bits wouldn't all fit in the current byte

                if (cbitStored < CBIT_CHARMASK)
                {
                    oc >>= CBIT_BYTE - cbitUsed;

                    if (cbit + cbitStored == CBIT_GUID)
                    {
                        if (oc != 0)
                        {
                            goto Exit;                  // extra bits
                        }
                        break;
                    }
                    pb++;

                    *pb |= (BYTE) oc;
                }
            }   // for (cbit = 0; cbit < CBIT_GUID; cbit += CBIT_CHARMASK)

            Status = STATUS_SUCCESS;

            // If byte-swapping is necessary, do so now on the calculated
            // GUID.

            PropByteSwap( pguid );

        }   // if (cocname == CCH_PROPSET)
    }   // if (poc[0] == OC_PROPSET0)


    //  ----
    //  Exit
    //  ----

Exit:

    return(Status);
}



inline BOOLEAN
_Compare_VT_BOOL(VARIANT_BOOL bool1, VARIANT_BOOL bool2)
{
    // Allow any non-zero value to match any non-zero value

    return((bool1 == FALSE) == (bool2 == FALSE));
}


BOOLEAN
_Compare_VT_CF(CLIPDATA *pclipdata1, CLIPDATA *pclipdata2)
{
    BOOLEAN fSame;

    if (pclipdata1 != NULL && pclipdata2 != NULL)
    {
        fSame = ( pclipdata1->cbSize == pclipdata2->cbSize
                  &&
                  pclipdata1->ulClipFmt == pclipdata2->ulClipFmt );

        if (fSame)
        {
            if (pclipdata1->pClipData != NULL && pclipdata2->pClipData != NULL)
            {
                fSame = memcmp(
                            pclipdata1->pClipData,
                            pclipdata2->pClipData,
                            CBPCLIPDATA(*pclipdata1)
                              ) == 0;
            }
            else
            {
                // They're the same if both are NULL, or if
                // they have a zero length (if they have a zero
                // length, either one may or may not be NULL, but they're
                // still considered the same).

                fSame = pclipdata1->pClipData == pclipdata2->pClipData
                        ||
                        CBPCLIPDATA(*pclipdata1) == 0;
            }
        }
    }
    else
    {
        fSame = pclipdata1 == pclipdata2;
    }
    return(fSame);
}


//+---------------------------------------------------------------------------
// Function:    RtlCompareVariants, public
//
// Synopsis:    Compare two passed PROPVARIANTs -- case sensitive for strings
//
// Arguments:   [CodePage]      -- CodePage
//              [pvar1]         -- pointer to PROPVARIANT
//              [pvar2]         -- pointer to PROPVARIANT
//
// Returns:     TRUE if identical, else FALSE
//---------------------------------------------------------------------------

#ifdef _MAC
EXTERN_C    // The Mac linker doesn't seem to be able to export with C++ decorations
#endif

BOOLEAN PROPSYSAPI PROPAPI
PropTestCompareVariants(
    USHORT CodePage,
    PROPVARIANT const *pvar1,
    PROPVARIANT const *pvar2)
{
    if (pvar1->vt != pvar2->vt)
    {
        return(FALSE);
    }

    BOOLEAN fSame;
    ULONG i;

    switch (pvar1->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        fSame = TRUE;
        break;

    case VT_I1:
    case VT_UI1:
        fSame = pvar1->bVal == pvar2->bVal;
        break;

    case VT_I2:
    case VT_UI2:
        fSame = pvar1->iVal == pvar2->iVal;
        break;

    case VT_BOOL:
        fSame = _Compare_VT_BOOL(pvar1->boolVal, pvar2->boolVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        fSame = pvar1->lVal == pvar2->lVal;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        fSame = pvar1->hVal.HighPart == pvar2->hVal.HighPart
                &&
                pvar1->hVal.LowPart  == pvar2->hVal.LowPart;
        break;

    case VT_CLSID:
        fSame = memcmp(pvar1->puuid, pvar2->puuid, sizeof(CLSID)) == 0;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        fSame = ( pvar1->blob.cbSize == pvar2->blob.cbSize );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->blob.pBlobData,
                        pvar2->blob.pBlobData,
                        pvar1->blob.cbSize) == 0;
        }
        break;

    case VT_CF:
        fSame = _Compare_VT_CF(pvar1->pclipdata, pvar2->pclipdata);
        break;

    case VT_BSTR:
        if (pvar1->bstrVal != NULL && pvar2->bstrVal != NULL)
        {
            fSame = ( BSTRLEN(pvar1->bstrVal) == BSTRLEN(pvar2->bstrVal) );
            if (fSame)
            {
                fSame = memcmp(
                            pvar1->bstrVal,
                            pvar2->bstrVal,
                            BSTRLEN(pvar1->bstrVal)) == 0;
            }
        }
        else
        {
            fSame = pvar1->bstrVal == pvar2->bstrVal;
        }
        break;

    case VT_LPSTR:
        if (pvar1->pszVal != NULL && pvar2->pszVal != NULL)
        {
            fSame = strcmp(pvar1->pszVal, pvar2->pszVal) == 0;
        }
        else
        {
            fSame = pvar1->pszVal == pvar2->pszVal;
        }
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_LPWSTR:
        if (pvar1->pwszVal != NULL && pvar2->pwszVal != NULL)
        {
            fSame = Prop_wcscmp(pvar1->pwszVal, pvar2->pwszVal) == 0;
        }
        else
        {
            fSame = pvar1->pwszVal == pvar2->pwszVal;
        }
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        fSame = ( pvar1->caub.cElems == pvar2->caub.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->caub.pElems,
                        pvar2->caub.pElems,
                        pvar1->caub.cElems * sizeof(pvar1->caub.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
        fSame = ( pvar1->cai.cElems == pvar2->cai.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cai.pElems,
                        pvar2->cai.pElems,
                        pvar1->cai.cElems * sizeof(pvar1->cai.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_BOOL:
        fSame = ( pvar1->cabool.cElems == pvar2->cabool.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->cabool.cElems; i++)
            {
                fSame = _Compare_VT_BOOL(
                                pvar1->cabool.pElems[i],
                                pvar2->cabool.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        fSame = ( pvar1->cal.cElems == pvar2->cal.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cal.pElems,
                        pvar2->cal.pElems,
                        pvar1->cal.cElems * sizeof(pvar1->cal.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        fSame = ( pvar1->cah.cElems == pvar2->cah.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cah.pElems,
                        pvar2->cah.pElems,
                        pvar1->cah.cElems *
                            sizeof(pvar1->cah.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CLSID:
        fSame = ( pvar1->cauuid.cElems == pvar2->cauuid.cElems );
        if (fSame)
        {
            fSame = memcmp(
                        pvar1->cauuid.pElems,
                        pvar2->cauuid.pElems,
                        pvar1->cauuid.cElems *
                            sizeof(pvar1->cauuid.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CF:
        fSame = ( pvar1->caclipdata.cElems == pvar2->caclipdata.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->caclipdata.cElems; i++)
            {
                fSame = _Compare_VT_CF(
                                &pvar1->caclipdata.pElems[i],
                                &pvar2->caclipdata.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_BSTR:
        fSame = ( pvar1->cabstr.cElems == pvar2->cabstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->cabstr.cElems; i++)
            {
                if (pvar1->cabstr.pElems[i] != NULL &&
                    pvar2->cabstr.pElems[i] != NULL)
                {
                    fSame = ( BSTRLEN(pvar1->cabstr.pElems[i])
                              ==
                              BSTRLEN(pvar2->cabstr.pElems[i]) );
                    if (fSame)
                    {
                        fSame = memcmp(
                                    pvar1->cabstr.pElems[i],
                                    pvar2->cabstr.pElems[i],
                                    BSTRLEN(pvar1->cabstr.pElems[i])) == 0;
                    }
                }
                else
                {
                    fSame = pvar1->cabstr.pElems[i] == pvar2->cabstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        fSame = ( pvar1->calpstr.cElems == pvar2->calpstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->calpstr.cElems; i++)
            {
                if (pvar1->calpstr.pElems[i] != NULL &&
                    pvar2->calpstr.pElems[i] != NULL)
                {
                    fSame = strcmp(
                                pvar1->calpstr.pElems[i],
                                pvar2->calpstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpstr.pElems[i] == 
                            pvar2->calpstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        fSame = ( pvar1->calpwstr.cElems == pvar2->calpwstr.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->calpwstr.cElems; i++)
            {
                if (pvar1->calpwstr.pElems[i] != NULL &&
                    pvar2->calpwstr.pElems[i] != NULL)
                {
                    fSame = Prop_wcscmp(
                                pvar1->calpwstr.pElems[i],
                                pvar2->calpwstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpwstr.pElems[i] == 
                            pvar2->calpwstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        fSame = ( pvar1->capropvar.cElems == pvar2->capropvar.cElems );
        if (fSame)
        {
            for (i = 0; i < pvar1->capropvar.cElems; i++)
            {
                fSame = PropTestCompareVariants(
                                CodePage,
                                &pvar1->capropvar.pElems[i],
                                &pvar2->capropvar.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT Comparison");
        fSame = FALSE;
        break;

    }
    return(fSame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\testdoc.cxx ===
#include "pch.cxx"

unsigned char g_achTestDoc[] = {
    0xd0,0xcf,0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x03,0x00,0xfe,0xff,0x09,0x00,//........>.......
    0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x03,0x00,0x00,0x00,//................
    0x01,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x52,0x00,0x6f,0x00,0x6f,0x00,0x74,0x00,0x20,0x00,0x45,0x00,0x6e,0x00,0x74,0x00,//R.o.o.t. .E.n.t.
    0x72,0x00,0x79,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//r.y.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x16,0x00,0x05,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x03,0x00,0x00,0x00,//................
    0x00,0x09,0x02,0x00,0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,//...............F
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x7f,0xd9,0x7b,//............P..{
    0x1a,0x05,0xba,0x01,0x06,0x00,0x00,0x00,0x40,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,//........@.......
    0x01,0x00,0x43,0x00,0x6f,0x00,0x6d,0x00,0x70,0x00,0x4f,0x00,0x62,0x00,0x6a,0x00,//..C.o.m.p.O.b.j.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x12,0x00,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//........n.......
    0x57,0x00,0x6f,0x00,0x72,0x00,0x64,0x00,0x44,0x00,0x6f,0x00,0x63,0x00,0x75,0x00,//W.o.r.d.D.o.c.u.
    0x6d,0x00,0x65,0x00,0x6e,0x00,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//m.e.n.t.........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x1a,0x00,0x02,0x01,0xff,0xff,0xff,0xff,0x04,0x00,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0xb5,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x4f,0x00,0x62,0x00,0x6a,0x00,0x65,0x00,0x63,0x00,0x74,0x00,0x50,0x00,0x6f,0x00,//O.b.j.e.c.t.P.o.
    0x6f,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//o.l.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x16,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x81,0x8f,0x87,0x7a,0x04,0xba,0x01,0x00,0x81,0x8f,0x87,//........z.......
    0x7a,0x04,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//z...............
    0x02,0x00,0x00,0x00,0xfd,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,//................
    0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x08,0x00,0x00,0x00,//................
    0x09,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x05,0x00,0x53,0x00,0x75,0x00,0x6d,0x00,0x6d,0x00,0x61,0x00,0x72,0x00,0x79,0x00,//..S.u.m.m.a.r.y.
    0x49,0x00,0x6e,0x00,0x66,0x00,0x6f,0x00,0x72,0x00,0x6d,0x00,0x61,0x00,0x74,0x00,//I.n.f.o.r.m.a.t.
    0x69,0x00,0x6f,0x00,0x6e,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//i.o.n...........
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x28,0x00,0x02,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//(...............
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0xdd,0x01,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x01,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,//................
    0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x08,0x00,0x00,0x00,//................
    0x09,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,//................
    0x0d,0x00,0x00,0x00,0x0e,0x00,0x00,0x00,0x17,0x00,0x00,0x00,0x10,0x00,0x00,0x00,//................
    0x11,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x13,0x00,0x00,0x00,0x14,0x00,0x00,0x00,//................
    0x15,0x00,0x00,0x00,0x16,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x18,0x00,0x00,0x00,//................
    0x19,0x00,0x00,0x00,0x1a,0x00,0x00,0x00,0x1b,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,//................
    0x1d,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x1f,0x00,0x00,0x00,0x20,0x00,0x00,0x00,//............ ...
    0x21,0x00,0x00,0x00,0x22,0x00,0x00,0x00,0x23,0x00,0x00,0x00,0x24,0x00,0x00,0x00,//!..."...#...$...
    0x25,0x00,0x00,0x00,0x26,0x00,0x00,0x00,0x27,0x00,0x00,0x00,0x28,0x00,0x00,0x00,//%...&...'...(...
    0x29,0x00,0x00,0x00,0x2a,0x00,0x00,0x00,0x2b,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,//)...*...+...,...
    0x2d,0x00,0x00,0x00,0x2e,0x00,0x00,0x00,0x2f,0x00,0x00,0x00,0x30,0x00,0x00,0x00,//-......./...0...
    0x31,0x00,0x00,0x00,0x32,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x34,0x00,0x00,0x00,//1...2...3...4...
    0x35,0x00,0x00,0x00,0x36,0x00,0x00,0x00,0x37,0x00,0x00,0x00,0x38,0x00,0x00,0x00,//5...6...7...8...
    0x39,0x00,0x00,0x00,0x3a,0x00,0x00,0x00,0x3b,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,//9...:...;...<...
    0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x02,0x00,0x00,0x00,0xab,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xca,0x00,0x00,0x00,//................
    0x05,0x00,0x00,0x00,0xeb,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x0d,0x01,0x00,0x00,//................
    0x04,0x00,0x00,0x00,0x2f,0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x4f,0x01,0x00,0x00,//..../.......O...
    0x01,0x00,0x00,0x00,0x62,0x01,0x00,0x00,0x0f,0x00,0x00,0x00,0x68,0x01,0x00,0x00,//....b.......h...
    0x10,0x00,0x00,0x00,0x70,0x01,0x00,0x00,0x12,0x00,0x00,0x00,0x78,0x01,0x00,0x00,//....p.......x...
    0x0e,0x00,0x00,0x00,0x93,0x01,0x00,0x00,0x09,0x00,0x00,0x00,0x9b,0x01,0x00,0x00,//................
    0x13,0x00,0x00,0x00,0xa5,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,//................
    0x4e,0x6f,0x72,0x6d,0x61,0x6c,0x2e,0x64,0x6f,0x74,0x00,0x1e,0x00,0x00,0x00,0x17,//Normal.dot......
    0x00,0x00,0x00,0x54,0x69,0x74,0x6c,0x65,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,//...Title of the 
    0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,0x00,0x19,0x00,//document........
    0x00,0x00,0x53,0x75,0x62,0x6a,0x65,0x63,0x74,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,//..Subject of the
    0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,0x00,0x1a,// document.......
    0x00,0x00,0x00,0x4b,0x65,0x79,0x77,0x6f,0x72,0x64,0x73,0x20,0x6f,0x66,0x20,0x74,//...Keywords of t
    0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,//he document.....
    0x00,0x1a,0x00,0x00,0x00,0x43,0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x73,0x20,0x6f,0x66,//.....Comments of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,// the document...
    0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x41,0x75,0x74,0x68,0x6f,0x72,0x20,0x6f,0x66,//.......Author of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,// the document...
    0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,//.......Bill More
    0x6c,0x00,0x02,0x00,0x00,0x00,0xe4,0x04,0x03,0x00,0x00,0x00,0x07,0x00,0x00,0x00,//l...............
    0x03,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x13,0x00,0x00,0x00,//....A...........
    0x4d,0x69,0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x20,0x57,0x6f,0x72,0x64,0x20,0x36,//Microsoft Word 6
    0x2e,0x30,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x02,//.0..............
    0x00,0x00,0x00,0x33,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,0x11,//...3............
    0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x03,0x00,0xfe,0xff,0x09,0x00,0x06,0x00,0x00,//.....>..........
    0x73,0x64,0x66,0x6f,0x69,0x68,0x73,0x64,0x66,0x0d,0xff,0xff,0xff,0xff,0xff,0xff,//sdfoihsdf.......
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x03,0x00,0x01,0x00,//................
    0x01,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x52,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..R.............
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..j.......j.....
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x08,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x08,0x00,0x00,0x08,0x00,//..........~.....
    0x00,0x00,0x86,0x08,0x00,0x00,0x0e,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..........j.....
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..j.......j.....
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x08,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x2a,0x00,//..............*.
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x46,0x6f,0x6f,0x20,0x42,0x61,0x72,0x0d,0x0d,0x73,0x64,0x66,0x6b,0x6a,0x68,0x73,//Foo Bar..sdfkjhs
    0x64,0x66,0x6b,0x6a,0x68,0x73,0x64,0x66,0x20,0x0d,0x73,0x20,0x64,0x6a,0x6b,0x73,//dfkjhsdf .s djks
    0x61,0x66,0x64,0x6c,0x6a,0x73,0x61,0x66,0x64,0x0d,0x73,0x64,0x66,0x6c,0x6b,0x68,//afdljsafd.sdflkh
    0x6a,0x73,0x66,0x61,0x64,0x6c,0x68,0x73,0x66,0x61,0x64,0x0d,0x73,0x64,0x66,0x68,//jsfadlhsfad.sdfh
    0xfe,0xff,0x00,0x00,0x03,0x33,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//.....3..........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xe0,0x85,0x9f,0xf2,//................
    0xf9,0x4f,0x68,0x10,0xab,0x91,0x08,0x00,0x2b,0x27,0xb3,0xd9,0x30,0x00,0x00,0x00,//.Oh.....+'..0...
    0xad,0x01,0x00,0x00,0x0e,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x98,0x00,0x00,0x00,//................
    0x01,0x00,0xfe,0xff,0x03,0x0a,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x09,0x02,0x00,//................
    0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x1c,0x00,0x00,0x00,//...........F....
    0x4d,0x69,0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x20,0x57,0x6f,0x72,0x64,0x20,0x36,//Microsoft Word 6
    0x2e,0x30,0x20,0x44,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x00,0x0a,0x00,0x00,0x00,//.0 Document.....
    0x4d,0x53,0x57,0x6f,0x72,0x64,0x44,0x6f,0x63,0x00,0x10,0x00,0x00,0x00,0x57,0x6f,//MSWordDoc.....Wo
    0x72,0x64,0x2e,0x44,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x36,0x00,0xf4,0x39,//rd.Document.6..9
    0xb2,0x71,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,//.q..............
    0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xdc,0xa5,0x68,0x00,0x45,0xc0,0x09,0x04,0x00,0x00,0x24,0x00,0x65,0x00,0x00,0x00,//..h.E.....$.e...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x09,0x03,0x00,0x00,//................
    0xb5,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//....J...........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x6a,0x00,0x00,0x00,//............j...
    0x00,0x08,0x00,0x00,0x6a,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//....j...j.......
    0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//j.......j.......
    0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x14,0x00,0x00,0x00,//j.......j.......
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x94,0x08,0x00,0x00,0x36,0x00,0x00,0x00,//............6...
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x0a,0x00,0x00,0x00,//................
    0xd4,0x08,0x00,0x00,0x0a,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x97,0x0b,0x00,0x00,0x31,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//....1...........
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x09,0x00,0x00,0x02,0x00,0x00,0x00,//................
    0x0a,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x09,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x0a,0x09,0x00,0x00,0x52,0x00,0x00,0x00,0x5c,0x09,0x00,0x00,0xec,0x00,0x00,0x00,//....R...\.......
    0x48,0x0a,0x00,0x00,0xec,0x00,0x00,0x00,0x34,0x0b,0x00,0x00,0x1e,0x00,0x00,0x00,//H.......4.......
    0xc8,0x0b,0x00,0x00,0x58,0x00,0x00,0x00,0x20,0x0c,0x00,0x00,0x95,0x00,0x00,0x00,//....X... .......
    0x52,0x0b,0x00,0x00,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//R...E...........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//........j.......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x03,0x00,0x00,0x09,0x03,0x00,0x00,0x19,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,//............J...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,//................
    0x00,0x03,0x00,0x00,0x08,0x03,0x00,0x00,0x09,0x03,0x00,0x00,0x1a,0x03,0x00,0x00,//................
    0x2a,0x03,0x00,0x00,0x3c,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,0xfe,0x00,0x01,0xc0,//*...<...J.......
    0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,//!......!......!.
    0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,//.....!......!...
    0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...!............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x06,//................
    0x0e,0x00,0x0f,0x00,0x08,0x00,0x01,0x00,0x4b,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,//........K.......
    0x1a,0x00,0x00,0x40,0xf1,0xff,0x02,0x00,0x1a,0x00,0x06,0x4e,0x6f,0x72,0x6d,0x61,//...@.......Norma
    0x6c,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x61,0x09,0x04,0x00,0x00,0x00,0x00,0x00,//l.......a.......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x00,//..............".
    0x41,0x40,0xf2,0xff,0xa1,0x00,0x22,0x00,0x16,0x44,0x65,0x66,0x61,0x75,0x6c,0x74,//A@...."..Default
    0x20,0x50,0x61,0x72,0x61,0x67,0x72,0x61,0x70,0x68,0x20,0x46,0x6f,0x6e,0x74,0x00,// Paragraph Font.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4a,0x00,//..............J.
    0x00,0x00,0x02,0x00,0xff,0xff,0xff,0xff,0x02,0x00,0xff,0xff,0xff,0xff,0x01,0x00,//................
    0x04,0x20,0xff,0xff,0x01,0x00,0x00,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x00,//. ........J.....
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x28,0x00,0x00,0x00,//............(...
    0x3a,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x01,0xc0,0x21,//:...H...J......!
    0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x01,//.....!.....!....
    0xc0,0x21,0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x03,0x00,0x00,0x4a,0x03,//.!.....!......J.
    0x00,0x00,0x02,0x00,0x00,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,0x03,0x00,0x2a,0x00,//........J.....*.
    0x0a,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,0x6c,0x1c,0x43,0x3a,0x5c,0x75,//.Bill Morel.C:\u
    0x73,0x65,0x72,0x73,0x5c,0x64,0x65,0x66,0x61,0x75,0x6c,0x74,0x5c,0x74,0x65,0x73,//sers\default\tes
    0x74,0x64,0x6f,0x63,0x2e,0x64,0x6f,0x63,0xff,0x40,0x5c,0x5c,0x4d,0x53,0x50,0x52,//tdoc.doc.@\\MSPR
    0x49,0x4e,0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,0x4f,0x52,//INT35\1/1049 COR
    0x50,0x41,0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x4e,0x65,0x30,0x30,0x3a,0x00,//PA 141B97.Ne00:.
    0x77,0x69,0x6e,0x73,0x70,0x6f,0x6f,0x6c,0x00,0x48,0x50,0x20,0x4c,0x61,0x73,0x65,//winspool.HP Lase
    0x72,0x4a,0x65,0x74,0x20,0x49,0x49,0x49,0x53,0x69,0x20,0x50,0x6f,0x73,0x74,0x53,//rJet IIISi PostS
    0x63,0x72,0x69,0x70,0x74,0x20,0x76,0x35,0x32,0x2e,0x33,0x00,0x5c,0x5c,0x4d,0x53,//cript v52.3.\\MS
    0x50,0x52,0x49,0x4e,0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,//PRINT35\1/1049 C
    0x4f,0x52,0x50,0x41,0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x20,0x03,0x50,0x03,//ORPA 141B97. .P.
    0x7c,0x00,0x70,0x00,0x13,0xdd,0x01,0x00,0x01,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,//|.p...........o.
    0x64,0x00,0x01,0x00,0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,//d.....,.........
    0x00,0x00,0x4c,0x65,0x74,0x74,0x65,0x72,0x00,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,//..Letter......o.
    0x64,0x00,0x01,0x00,0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,//d.....,.........
    0x00,0x00,0x4c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//..L.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x52,0x49,0x56,0x20,0x00,0x00,0x00,//........PRIV ...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x18,0x00,0x00,0x00,0x00,0x00,0x20,0x4e,0x20,0x4e,0x20,0x4e,0x00,0x00,0x10,0x27,//...... N N N...'
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5c,0x5c,0x4d,0x53,0x50,0x52,0x49,0x4e,//........\\MSPRIN
    0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,0x4f,0x52,0x50,0x41,//T35\1/1049 CORPA
    0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x20,0x03,0x50,0x03,0x7c,0x00,0x70,0x00,// 141B97. .P.|.p.
    0x13,0xdd,0x01,0x00,0x01,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,0x64,0x00,0x01,0x00,//..........o.d...
    0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x4c,0x65,//..,...........Le
    0x74,0x74,0x65,0x72,0x00,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,0x64,0x00,0x01,0x00,//tter......o.d...
    0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x4c,0x00,//..,...........L.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x50,0x52,0x49,0x56,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//....PRIV .......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,//................
    0x00,0x00,0x20,0x4e,0x20,0x4e,0x20,0x4e,0x00,0x00,0x10,0x27,0x00,0x00,0x00,0x00,//.. N N N...'....
    0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x00,0x48,0x00,0x00,0x00,0x48,0x00,0x00,0x00,//........H...H...
    0x08,0x00,0x01,0x00,0x01,0x00,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0x00,//......H.........
    0x00,0x00,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x17,//...@............
    0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x49,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x21,//...H...I...J...!
    0x00,0x09,0x03,0x00,0x00,0x00,0x00,0x21,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x20,//.......!....... 
    0x00,0x19,0x03,0x00,0x00,0x00,0x00,0x20,0x00,0x07,0x03,0x00,0x00,0x00,0x00,0x20,//....... ....... 
    0x00,0x08,0x03,0x00,0x00,0x00,0x00,0x31,0x00,0x15,0x16,0x90,0x01,0x00,0x00,0x54,//.......1.......T
    0x69,0x6d,0x65,0x73,0x20,0x4e,0x65,0x77,0x20,0x52,0x6f,0x6d,0x61,0x6e,0x00,0x0c,//imes New Roman..
    0x16,0x90,0x01,0x02,0x00,0x53,0x79,0x6d,0x62,0x6f,0x6c,0x00,0x0b,0x26,0x90,0x01,//.....Symbol..&..
    0x00,0x00,0x41,0x72,0x69,0x61,0x6c,0x00,0x22,0x00,0x04,0x00,0x31,0x08,0x8a,0x18,//..Arial."...1...
    0x00,0x00,0xd0,0x02,0x00,0x00,0x68,0x01,0x00,0x00,0x00,0x00,0x40,0x34,0xf4,0x85,//......h.....@4..
    0x05,0x3b,0xf4,0xa5,0x04,0x3b,0xf4,0xa5,0x03,0x00,0x03,0x00,0x00,0x00,0x07,0x00,//.;...;..........
    0x00,0x00,0x41,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x83,0x10,//..A.............
    0x05,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x01,0x00,0x04,0x00,//........A.......
    0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x74,0x03,0x00,0x00,0x00,0x00,//..........t.....
    0x95,0x00,0x00,0x00,0x16,0x54,0x69,0x74,0x6c,0x65,0x20,0x6f,0x66,0x20,0x74,0x68,//.....Title of th
    0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x18,0x53,0x75,0x62,0x6a,//e document..Subj
    0x65,0x63,0x74,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,//ect of the docum
    0x65,0x6e,0x74,0x2e,0x19,0x4b,0x65,0x79,0x77,0x6f,0x72,0x64,0x73,0x20,0x6f,0x66,//ent..Keywords of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x19,0x43,// the document..C
    0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x73,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,//omments of the d
    0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x17,0x41,0x75,0x74,0x68,0x6f,0x72,0x20,//ocument..Author 
    0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,//of the document.
    0x0a,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,0x6c,0x00,0x00,0x00,0x00,0x00,//.Bill Morel.....
    0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff //................
};

unsigned int g_cbTestDoc = sizeof(g_achTestDoc)/sizeof(g_achTestDoc[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\pch.cxx ===
//+============================================================================
//
//  File:       pch.cxx
//
//  Purpose:    This file composes the pre-compiled header for the
//              PropTest DRT.
//
//+============================================================================

#pragma warning( disable : 4291 )

#ifdef _MAC_NODOC

//  ================
//  Mac NODOC Format
//  ================

// The following set of pre-compiler directives is used in the
// Mac "NODOC" build environment.

    //  ----------------------------------------
    //  Build Environment Configuration Settings
    //  ----------------------------------------

    #define _PPCMAC                 // Macintosh PPC build
    #define OLE2ANSI                // Ansi OLE (OLECHAR == char)
    #undef WIN32                    // Do not include Win32 information
    #define IPROPERTY_DLL           // Use code for IProp.DLL
    #define BIGENDIAN 1             // Enable byte-swapping.
    #define IPROP_NO_OLEAUTO_H 1    // Don't try to include "oleauto.h"

    // If the NODOC environment's "debug" flag is set, then set the
    // NT environment's corresponding flag.

    #ifdef _DEBUG
        #define DBG 1   
    #endif

    //  ------
    //  Macros
    //  ------

    // The default Ansi CodePage
    #define CP_ACP   0

    // unsigned-long to Ansi
    #define ULTOA(ul, ch, i) _ultoa( ul, ch, i )

    // NTSTATUS and HRESULT information not available in the NODOC build.

    #define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

    #define FACILITY_WIN32                  7
    #define FACILITY_NT_BIT                 0x10000000
    #define HRESULT_FROM_WIN32(x)      (x ? ((HRESULT) (((x) &0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : 0 )
    #define ERROR_NO_UNICODE_TRANSLATION    1113L
    #define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)
    #define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)


    //  --------------
    //  Basic Includes
    //  --------------

    // NOOP two #defines that are unnecessary in the NODOC environment.

    #define __RPC_FAR
    #define __RPC_STUB

    // Include the property set information (this same file is included
    // in the shipping package for use by ISVs.
    #include "iprop.h"

    // Include macros for dealing with OLECHARs
    #include <olechar.h>


    //  --------
    //  TypeDefs
    //  --------

    typedef LONG        NTSTATUS;
    typedef ULONG       PROPID;


    //  ----------
    //  Prototypes
    //  ----------

    // IMalloc wrappers

    LPVOID __cdecl CoTaskMemAlloc( ULONG cb );
    LPVOID __cdecl CoTaskMemRealloc( LPVOID pvInput, ULONG cb );
    VOID __cdecl CoTaskMemFree( LPVOID pv );

    // wide-character routines.
    int wcscmp( const WCHAR*, const WCHAR* );
    UINT __cdecl wcslen( const WCHAR* ); // MACBUG: size_t?
    int wcsnicmp( const WCHAR*, const WCHAR*, UINT );
    WCHAR *wcscpy( WCHAR* wszDest, const WCHAR* wszSource );

    // Ansi/Unicode routines

    UINT __cdecl GetACP();

    // BSTR routines

    BSTR SysAllocString(BSTR);
    VOID SysFreeString(BSTR);


    //  -------
    //  Externs
    //  -------

    // An array used by UuidCreate()
    extern GUID g_curUuid;


    //  -------
    //  Inlines
    //  -------

    // Compare two FMTIDs
    inline BOOL operator == (const FMTID &fmtid1, const FMTID &fmtid2)
    {
        return IsEqualGUID( fmtid1, fmtid2 );
    }

    // Stub out the Win32 GetLastError() API.
    inline DWORD GetLastError(){ return 0; }

    // Stub out UuidCreate() by using a global list of
    // GUIDs

    inline void UuidCreate ( OUT GUID * pUuid )
    {
        g_curUuid.Data1++;
        *pUuid = g_curUuid;         // member to member copy
    }


    //  -----------------
    //  Extended Includes
    //  -----------------

    #include <propmac.hxx>      // Property macros
    #include "cpropvar.hxx"     // CPropVariant class
    #include "CDisplay.hxx"     // CDisplay class (used by PRINTF macros)
    #include "PropTest.hxx"     // General information


#else   // #ifdef _MAC_NODOC

//  =========
//  NT Format
//  =========

    #include <new.h>

    // We'll take all the same abstractions that IProp.dll uses
    #define IPROPERTY_DLL

    #define DfpAssert Win4Assert

    #define _OLE32_ 1
    extern "C"
    {
        #include <nt.h>
        #include <ntrtl.h>
        #include <nturtl.h>
        #include <windows.h>
    }

    #define _CAIROSTG_
    #include <stdio.h>
    #include <time.h>

    #define INITGUID
    #include "initguid.h"

    // Don't use the Win32 Unicode wcs routines, since they're
    // not available on Win95.

    #ifndef OLE2ANSI
        #undef ocscpy
        #undef ocscmp
        #undef ocscat
        #undef ocschr

        #define ocscpy      wcscpy
        #define ocscmp      wcscmp
        #define ocscat      wcscat
        #define ocschr      wcschr
    #endif

    #include <safedecl.hxx>
    #include <oaidl.h>
    #include <propset.h>
    #include <expdf.hxx>
    #include <propmac.hxx>
    #include <olechar.h>
    #include <propidl.h>

    /*
    #define NT5PROPS_CI_APIS
    #include "..\\..\\iprop\\nt5props.h"	// Map PrivStgEx to StgEx APIs
    #define PROPS_DLL   "nt5props.dll"
    */

    #include "global.hxx"
    #include "cpropvar.hxx"

    #include "PStgServ.h"
    #include "PropMshl.hxx"
    #include "PropTest.hxx"
    #include "cli.hxx"


    // We include these here instead of #including stgprops.hxx, because proptest
    // is built with DBG turned off so that it can run on Win95, and these declarations
    // are DBG only.

    EXTERN_C const IID IID_IStorageTest; //40621cf8-a17f-11d1-b28d-00c04fb9386d

    interface IStorageTest : public IUnknown
    {
    public:

        STDMETHOD(UseNTFS4Streams)( BOOL fUseNTFS4Streams ) = 0;
        STDMETHOD(GetFormatVersion)(WORD *pw) = 0;
        STDMETHOD(SimulateLowMemory)( BOOL fSimulate ) = 0;
        STDMETHOD(GetLockCount)() = 0;
        STDMETHOD(IsDirty)() = 0;
    };



    #pragma hdrstop

#endif

//  ==================
//  NT/Mac Information
//  ==================

//  ------
//  Macros
//  ------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\propmshl.cxx ===
/*
#include <stdio.h>
#include "PStgServ.h"
#include "PropMshl.hxx"
#include "CPropVar.hxx"
#include "CHResult.hxx"
#include "proptest.hxx"
*/

#include "pch.cxx"
#include <shellapi.h>

const IID IID_IPropertyStorageServer    = {0xaf4ae0d0,0xa37f,0x11cf,{0x8d,0x73,0x00,0xaa,0x00,0x4c,0xd0,0x1a}};
const IID IID_IPropertyStorageServerApp = {0xaf4ae0d1,0xa37f,0x11cf,{0x8d,0x73,0x00,0xaa,0x00,0x4c,0xd0,0x1a}};

CPropSpec g_rgcpropspecVariant[] = { OLESTR("SafeArray") };


CPropStgMarshalTest::CPropStgMarshalTest( )
{
    m_cAllProperties = 0;
    m_cSimpleProperties = 0;
    m_rgpropspec = NULL;
    m_rgpropvar = NULL;
    m_pwszDocFileName = NULL;
    m_fInitialized = FALSE;
}


CPropStgMarshalTest::~CPropStgMarshalTest()
{
    if( m_pwszDocFileName != NULL )
        delete m_pwszDocFileName;
}


HRESULT
CPropStgMarshalTest::Init( OLECHAR *pwszDocFileName,
                           PROPVARIANT rgpropvar[],
                           PROPSPEC    rgpropspec[],
                           ULONG       cAllProperties,
                           ULONG       cSimpleProperties )
{
    HRESULT hr = E_FAIL;

    // Validate the input.

    if( pwszDocFileName == NULL )
    {
        hr = STG_E_INVALIDPARAMETER;
        goto Exit;
    }

    m_cAllProperties = cAllProperties;
    m_cSimpleProperties = cSimpleProperties;
    m_rgpropvar = rgpropvar;
    m_rgpropspec = rgpropspec;

    // Copy the docfile name.

    m_pwszDocFileName = new WCHAR[ wcslen(pwszDocFileName) + 1 ];

    if( m_pwszDocFileName != NULL )
    {
        wcscpy( m_pwszDocFileName, pwszDocFileName );
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Register the local server.  We assume that it's either in
    // the local directory or in the path.

    if( g_fRegisterLocalServer )
    {
        HINSTANCE hinst = 0;
        DWORD dwWait;
        PROCESS_INFORMATION ProcessInformation;
        STARTUPINFO StartupInfo;

        memset( &StartupInfo, 0, sizeof(StartupInfo) );
        StartupInfo.cb = sizeof(StartupInfo);
        TCHAR tszCommand[] = TEXT("PStgServ.exe /RegServer");

        if( !CreateProcess( NULL,
                            tszCommand,
                            NULL, NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInformation ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Exit;
        }

        if( WAIT_OBJECT_0 != WaitForSingleObject( ProcessInformation.hProcess, INFINITE ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Exit;
        }

    }


    hr = S_OK;

Exit:

    return( hr );
}



HRESULT
CPropStgMarshalTest::Run()
{

    HRESULT hr = S_OK;

    IPropertyStorageServer *pserver = NULL;
    IStorage *pstg = NULL;
    IPropertySetStorage *ppsstg = NULL;
    IPropertyStorage *ppstg = NULL;
    DWORD   grfFlags=0;

    //  ------------------------
    //  Create a PropSet locally
    //  ------------------------

    // Create a local IPropertySetStorage

    hr = g_pfnStgCreateStorageEx (
            m_pwszDocFileName,
            STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
            DetermineStgFmt( g_enumImplementation ),
            0,
            NULL,
            NULL,
            PROPIMP_NTFS == g_enumImplementation ? IID_IFlatStorage : IID_IStorage,
            (void**) &pstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed open of local Storage") );

    hr = StgToPropSetStg( pstg, &ppsstg );
    if( FAILED(hr) ) ERROR_EXIT( TEXT("Couldn't create local IPropertySetStorage") );

    // Create an IPropertyStorage

    grfFlags = PROPSETFLAG_ANSI | PROPSETFLAG_NONSIMPLE;

    hr = ppsstg->Create( IID_IPropertyStorageServer, NULL,
                         grfFlags,
                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                         &ppstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't create a local IPropertyStorage") );
    RELEASE_INTERFACE( ppsstg );

    // Write properties to it and close it.

    hr = WriteProperties( ppstg, FALSE /* Not Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed to write properties to local PropStg") );

    RELEASE_INTERFACE( ppstg );
    RELEASE_INTERFACE( pstg );

    //  -----------------------------------------
    //  Verify the properties through a marshaled
    //  IPropertySetStorage
    //  -----------------------------------------

    // Get a remote IPropertySetStorage

    Status( TEXT("Starting Server") );
    hr = CoCreateInstance( IID_IPropertyStorageServerApp,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IPropertyStorageServer,
                           (void **)&pserver );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed CoCreateInstance") );

    hr = pserver->Initialize( g_enumImplementation, g_Restrictions );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't initialize property set storage server") );

    Status( TEXT("Requesting remote IPropertySetStorage") );
    hr = pserver->StgOpenPropSetStg( m_pwszDocFileName,
                                     STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                     &ppsstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed to open remote PropSetStg") );

    // Get an IPropertyStorage

    hr = ppsstg->Open( IID_IPropertyStorageServer,
                       STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                       &ppstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't create a local IPropertyStorage") );
    RELEASE_INTERFACE( ppsstg );

    // Read from the marshalled Storage and compare the properties against
    // the local copy we kept.

    Status( TEXT("Reading/verifying properties from marshalled IPropertySetStorage") );
    hr = ReadAndCompareProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed marshalled read and compare") );

    // Remove the existing properties via the marhsalled interface, and
    // re-write them.

    hr = DeleteProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't delete properties from remote IPropertySetStorage") );

    // Write the properties back to the remote storage.

    Status( TEXT("Writing properties through marshalled IPropertySetStorage") );
    hr = WriteProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't write properties to remote Storage") );
    RELEASE_INTERFACE( ppstg );


    //  -----------------------------------------
    //  Verify the properties through a marshaled
    //  IPropertyStorage
    //  -----------------------------------------

    // Get a remote IPropertyStorage

    Status( TEXT("Requesting remote IPropertyStorage") );
    hr = pserver->StgOpenPropStg( m_pwszDocFileName,
                                  IID_IPropertyStorageServer,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                  &ppstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed to open remote PropStg") );

    // Read from the marshalled Storage and compare the properties against
    // the local copy we kept.

    Status( TEXT("Reading/verifying properties from marshalled IPropertyStorage") );
    hr = ReadAndCompareProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Failed marshalled read and compare") );

    // Remove the existing properties via the marhsalled interface, and
    // re-write them.

    hr = DeleteProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't delete properties from remote Storage") );

    // Write the properties back to the remote storage.

    Status( TEXT("Writing properties through marshalled IPropertyStorage") );
    hr = WriteProperties( ppstg, TRUE /* Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't write properties to remote Storage") );

    RELEASE_INTERFACE( ppstg );
    RELEASE_INTERFACE( pserver );

    //  --------------------------------
    //  Re-verify the properties locally
    //  --------------------------------

    // Re-open the DocFile locally.

    hr = g_pfnStgOpenStorageEx( m_pwszDocFileName,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                STGFMT_ANY, //DetermineStgFmt( g_enumImplementation )
                                0L,
                                NULL,
                                NULL,
                                PROPIMP_NTFS == g_enumImplementation ? IID_IFlatStorage : IID_IStorage,
                                (PVOID*)&pstg );
    if (SUCCEEDED(hr))
    {
        hr = StgToPropSetStg( pstg, &ppsstg );
        if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't create IPropertySetStorage on local DocFile") );
    }
    else
    {
        hr = g_pfnStgOpenStorageEx( m_pwszDocFileName,
                                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    STGFMT_ANY, //DetermineStgFmt( g_enumImplementation )
                                    0L,
                                    NULL,
                                    NULL,
                                    IID_IPropertySetStorage,
                                    (PVOID*)&ppsstg );
    }

    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't re-open the File locally") );


    hr = ppsstg->Open( IID_IPropertyStorageServer,
                       STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                       &ppstg );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Couldn't open load IPropertyStorage") );
    RELEASE_INTERFACE( ppsstg );

    // Compare the properties in the property set, which we wrote through
    // the marshalled interface, against what they should be.

    Status( TEXT("Reading/verifying properties from local IPropertyStorage") );
    hr = ReadAndCompareProperties( ppstg, FALSE /* Not Marshaled */ );
    if(FAILED(hr)) ERROR_EXIT( TEXT("Properties written through marshalled interface do not appear correct") );

    RELEASE_INTERFACE( ppstg );
    RELEASE_INTERFACE( pstg );

Exit:

    RELEASE_INTERFACE( pstg );
    RELEASE_INTERFACE( ppsstg );
    RELEASE_INTERFACE( ppstg );
    RELEASE_INTERFACE( pserver );

    return( hr );
	
}



HRESULT CPropStgMarshalTest::WriteProperties( IPropertyStorage *ppstg, BOOL fMarshaled )
{
    HRESULT hr = E_FAIL;


    // Are we restricted to simple properties?
    if( RESTRICT_SIMPLE_ONLY & g_Restrictions )
    {
        // Write the simple properties
        hr = ppstg->WriteMultiple( m_cSimpleProperties, m_rgpropspec, m_rgpropvar, PID_FIRST_USABLE );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed WriteMultiple") );
    }

    // Or, are we marshaling with IProp (where non-simple properties don't work)?
    else if( fMarshaled && g_SystemInfo.fIPropMarshaling )
    {
        // Verify that we can't write the non-simple properties
        hr = ppstg->WriteMultiple( m_cAllProperties, m_rgpropspec, m_rgpropvar, PID_FIRST_USABLE );
        if( RPC_E_CLIENT_CANTMARSHAL_DATA != hr )
        {
            hr = E_FAIL;
            ERROR_EXIT( TEXT("Failed WriteMultiple") );
        }

        // Write the simple properties
        hr = ppstg->WriteMultiple( m_cSimpleProperties, m_rgpropspec, m_rgpropvar, PID_FIRST_USABLE );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed WriteMultiple") );
    }

    // Otherwise, write all the properties
    else
    {
        hr = ppstg->WriteMultiple( m_cAllProperties, m_rgpropspec, m_rgpropvar, PID_FIRST_USABLE );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed WriteMultiple") );
        Check( S_OK, ResetRGPropVar( (CPropVariant*)m_rgpropvar ));

        // Test with a SafeArray too.

        PROPVARIANT propvar;
        SAFEARRAY *psa = NULL;
        SAFEARRAYBOUND rgsaBound[] = { {2, 0} };

        psa = SafeArrayCreateEx( VT_I4, 1, rgsaBound, NULL );

        LONG rgIndices[] = {0};
        LONG lVal = 0;
        Check( S_OK, SafeArrayPutElement( psa, rgIndices, &lVal ));
        
        rgIndices[0] = lVal = 1;
        Check( S_OK, SafeArrayPutElement( psa, rgIndices, &lVal ));

        PropVariantInit( &propvar );
        propvar.vt = VT_ARRAY | VT_I4;
        propvar.parray = psa;
        psa = NULL;

        hr = ppstg->WriteMultiple( 1, g_rgcpropspecVariant, &propvar, PID_FIRST_USABLE );
        PropVariantClear( &propvar );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed WriteMultiple") );

    }


    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    return( hr );

}



HRESULT CPropStgMarshalTest::ReadAndCompareProperties( IPropertyStorage *ppstg, BOOL fMarshaled )
{
    HRESULT hr = E_FAIL;
    ULONG i;
    ULONG cProperties = 0;

    // Allocate a PROPVARIANT[] into which we can read the
    // properties

    PROPVARIANT *rgpropvar = new PROPVARIANT[ m_cAllProperties ];
    if( NULL == rgpropvar )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Are we restricted to only simple properties?
    if( RESTRICT_SIMPLE_ONLY & g_Restrictions )
    {
        cProperties = m_cSimpleProperties;

        // Read just the simple properties
        hr = ppstg->ReadMultiple( cProperties, m_rgpropspec, rgpropvar );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed ReadMultiple") );

    }

    // Or, are we marshaling with IProp (where non-simple properties don't work)?
    else if( fMarshaled && g_SystemInfo.fIPropMarshaling )
    {
        cProperties = m_cSimpleProperties;

        // Try to read all the properties, including the non-simples.
        hr = ppstg->ReadMultiple( m_cAllProperties, m_rgpropspec, rgpropvar );
        if( RPC_E_SERVER_CANTMARSHAL_DATA != hr )
        {
            hr = E_FAIL;
            ERROR_EXIT( TEXT("Failed ReadMultiple") );
        }

        // Now read just the simple properties
        hr = ppstg->ReadMultiple( cProperties, m_rgpropspec, rgpropvar );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed ReadMultiple") );
    }

    // Otherwise, read all the properties
    else
    {
        cProperties = m_cAllProperties;

        // Read the properties
        hr = ppstg->ReadMultiple( cProperties, m_rgpropspec, rgpropvar );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed ReadMultiple") );

        // Read and compare the safearray property

        PROPVARIANT propvar;
        PropVariantInit( &propvar );

        hr = ppstg->ReadMultiple( 1, g_rgcpropspecVariant, &propvar );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed ReadMultiple") );

        if( (VT_ARRAY | VT_I4) != propvar.vt
            ||
            NULL == propvar.parray
            ||
            1 != SafeArrayGetDim(propvar.parray) )
        {
            ERROR_EXIT( TEXT("Invalid type returned in ReadMultiple") );
        }

        LONG rgIndices[] = { 0 };
        LONG rglVal[] = { -1, -1 };

        hr = SafeArrayGetElement( propvar.parray, rgIndices, &rglVal[0] );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed SafeArrayGetElement") );

        rgIndices[0] = 1;
        hr = SafeArrayGetElement( propvar.parray, rgIndices, &rglVal[1] );
        if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed SafeArrayGetElement") );

        if( 0 != rglVal[0] || 1 != rglVal[1] )
            ERROR_EXIT( TEXT("SafeArray types don't match") );

        PropVariantClear( &propvar );
    }


    // Compare the properties with what we expect.

    for( i = 0; i < cProperties; i++ )
    {
        hr = CPropVariant::Compare( &rgpropvar[i], &m_rgpropvar[i] );
        if( S_OK != hr )
        {
            hr = E_FAIL;
            ERROR_EXIT( TEXT("Property mismatch") );
        }
    }

    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    if( NULL != rgpropvar )
    {
        g_pfnFreePropVariantArray( m_cAllProperties, rgpropvar );
        delete[]( rgpropvar );
    }

    return( hr );

}



HRESULT CPropStgMarshalTest::DeleteProperties( IPropertyStorage *ppstg, BOOL fMarshaled  )
{
    HRESULT hr = E_FAIL;
    ULONG cProperties;

    // Determine the correct number of properties to delete.

    if( (RESTRICT_SIMPLE_ONLY & g_Restrictions)
        ||
        (fMarshaled && g_SystemInfo.fIPropMarshaling) )
    {
        cProperties = m_cSimpleProperties;
    }
    else
        cProperties = m_cAllProperties;

    // Delete the properties

    hr = ppstg->DeleteMultiple( cProperties, m_rgpropspec );
    if( FAILED(hr) ) ERROR_EXIT( TEXT("Failed DeleteMultiple") );

    hr = S_OK;

Exit:

    return( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\daytona\makefile.inc ===
############################################################################
#
#   Copyright (C) 1996-1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!MESSAGE Old TARGET_DBG_DEFINES = "$(TARGET_DBG_DEFINES)"
TARGET_DBG_DEFINES=$(TARGET_DBG_DEFINES:-DDBG=-DNOT_DBG)
!MESSAGE New TARGET_DBG_DEFINES = "$(TARGET_DBG_DEFINES)"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\proptest.cxx ===
//+=================================================================
//
//  File:
//      PropTest.cxx
//
//  Description:
//      This file contains the main() and most supporting functions
//      for the PropTest command-line DRT.  Run "PropTest /?" for
//      usage information.
//
//+=================================================================




// tests to do:
//   IEnumSTATPROPSTG
//          Create some properties, named and id'd
//          Enumerate them and check
//              (check vt, lpwstrName, propid)
//              (check when asking for more than there is: S_FALSE, S_OK)
//          Delete one
//          Reset the enumerator
//          Enumerate them and check
//          Delete one
//
//          Reset the enumeratorA
//          Read one from enumeratorA
//          Clone enumerator -> enumeratorB
//          Loop comparing rest of enumerator contents
//
//          Reset the enumerator
//          Skip all
//          Check none left
//
//          Reset the enumerator
//          Skip all but one
//          Check one left
//
//       Check refcounting and IUnknown
//
// IPropertyStorage tests
//
//       Multiple readers/writers access tests
//


//+----------------------------------------------------------------------------
//
//  I n c l u d e s
//
//+----------------------------------------------------------------------------

#include "pch.cxx"          // Brings in most other includes/defines/etc.
#include "propstm.hxx"
#include "propstg.hxx"

//#include <memory.h>         //


//+----------------------------------------------------------------------------
//
//  G l o b a l s
//
//+----------------------------------------------------------------------------


OLECHAR g_aocMap[CCH_MAP + 1] = OLESTR("abcdefghijklmnopqrstuvwxyz012345");

// Special-case property set names

const OLECHAR oszSummaryInformation[] = OLESTR("\005SummaryInformation");
ULONG cboszSummaryInformation = sizeof(oszSummaryInformation);
const OLECHAR oszDocSummaryInformation[] = OLESTR("\005DocumentSummaryInformation");
ULONG cboszDocSummaryInformation = sizeof(oszDocSummaryInformation);
const OLECHAR oszGlobalInfo[] = OLESTR("\005Global Info");
ULONG cboszGlobalInfo = sizeof(oszGlobalInfo);
const OLECHAR oszImageContents[] = OLESTR("\005Image Contents");
ULONG cboszImageContents = sizeof(oszImageContents);
const OLECHAR oszImageInfo[] = OLESTR("\005Image Info");
ULONG cboszImageInfo = sizeof(oszImageInfo);


// Enumeration indicating how to get an IPropertySetStorage

EnumImplementation g_enumImplementation = PROPIMP_UNKNOWN;
DWORD g_Restrictions;

BOOL g_fRegisterLocalServer = TRUE;
BOOL g_fUseNt5PropsDll = FALSE;

// Property Set APIs (which may be in OLE32.dll or IProp.dll)

HINSTANCE g_hinstDLL = NULL;
FNSTGCREATEPROPSTG *g_pfnStgCreatePropStg = NULL;
FNSTGOPENPROPSTG *g_pfnStgOpenPropStg = NULL;
FNSTGCREATEPROPSETSTG *g_pfnStgCreatePropSetStg = NULL;
FNFMTIDTOPROPSTGNAME *g_pfnFmtIdToPropStgName = NULL;
FNPROPSTGNAMETOFMTID *g_pfnPropStgNameToFmtId = NULL;
FNPROPVARIANTCLEAR *g_pfnPropVariantClear = NULL;
FNPROPVARIANTCOPY *g_pfnPropVariantCopy = NULL;
FNFREEPROPVARIANTARRAY *g_pfnFreePropVariantArray = NULL;

FNSTGCREATESTORAGEEX             *g_pfnStgCreateStorageEx = NULL;
FNSTGOPENSTORAGEEX               *g_pfnStgOpenStorageEx = NULL;
FNSTGOPENSTORAGEONHANDLE         *g_pfnStgOpenStorageOnHandle = NULL;
FNSTGCREATESTORAGEONHANDLE       *g_pfnStgCreateStorageOnHandle = NULL;
FNSTGPROPERTYLENGTHASVARIANT     *g_pfnStgPropertyLengthAsVariant = NULL;
FNSTGCONVERTVARIANTTOPROPERTY    *g_pfnStgConvertVariantToProperty = NULL;
FNSTGCONVERTPROPERTYTOVARIANT    *g_pfnStgConvertPropertyToVariant = NULL;

// PictureIt! Format IDs

const FMTID fmtidGlobalInfo =
    { 0x56616F00,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

const FMTID fmtidImageContents =
    { 0x56616400,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

const FMTID fmtidImageInfo =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };


BOOL          g_fOFS;
LARGE_INTEGER g_li0;

CPropVariant  g_rgcpropvarAll[ CPROPERTIES_ALL ];
CPropSpec     g_rgcpropspecAll[ CPROPERTIES_ALL ];
const OLECHAR* g_rgoszpropnameAll[ CPROPERTIES_ALL ];

char g_szPropHeader[] = "  propid/name          propid    cb   type value\n";
char g_szEmpty[] = "";
BOOL g_fVerbose = FALSE;
BOOL g_stgmDumpFlags = 0;

// This flag indicates whether or not the run-time system supports
// IPropertySetStorage on the DocFile IStorage object.

BOOL g_fQIPropertySetStorage = FALSE;


// g_curUuid is used by UuidCreate().  Everycall to that function
// returns the current value of g_curUuid, and increments the DWORD
// field.

GUID g_curUuid =
{ /* e4ecf7f0-e587-11cf-b10d-00aa005749e9 */
    0xe4ecf7f0,
    0xe587,
    0x11cf,
    {0xb1, 0x0d, 0x00, 0xaa, 0x00, 0x57, 0x49, 0xe9}
};

// Instantiate an object for the Marshaling tests

#ifndef _MAC_NODOC
CPropStgMarshalTest g_cpsmt;
#endif

// On the Mac, instantiate a CDisplay object, which is used
// by these tests to write to the screen (see #define PRINTF).

#ifdef _MAC
CDisplay *g_pcDisplay;
#endif

// System information

SYSTEMINFO g_SystemInfo;


int g_nIndent = 0;
void Status( char* szMessage )
{
    for( int i = 0; i < g_nIndent; i++ )
        PRINTF( "    " );

    if( g_fVerbose )
        PRINTF( szMessage );
    else
        PRINTF( "." );

}   // STATUS()



//+----------------------------------------------------------------------------
//
//  Function:   IsOriginalPropVariantType
//
//  Determines if a VARTYPE was one of the ones in the original PropVariant
//  definition (as defined in the OLE2 spec and shipped with NT4/DCOM95).
//
//+----------------------------------------------------------------------------

// *** Duped from props\utils.cxx ***

BOOL
IsOriginalPropVariantType( VARTYPE vt )
{
    if( vt & ~VT_TYPEMASK & ~VT_VECTOR )
        return( FALSE );

    switch( vt )
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
    case VT_CLSID:
    case VT_BLOB:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_UI1|VT_VECTOR:
    case VT_I2|VT_VECTOR:
    case VT_UI2|VT_VECTOR:
    case VT_BOOL|VT_VECTOR:
    case VT_I4|VT_VECTOR:
    case VT_UI4|VT_VECTOR:
    case VT_R4|VT_VECTOR:
    case VT_ERROR|VT_VECTOR:
    case VT_I8|VT_VECTOR:
    case VT_UI8|VT_VECTOR:
    case VT_R8|VT_VECTOR:
    case VT_CY|VT_VECTOR:
    case VT_DATE|VT_VECTOR:
    case VT_FILETIME|VT_VECTOR:
    case VT_CLSID|VT_VECTOR:
    case VT_CF|VT_VECTOR:
    case VT_BSTR|VT_VECTOR:
    case VT_BSTR_BLOB|VT_VECTOR:
    case VT_LPSTR|VT_VECTOR:
    case VT_LPWSTR|VT_VECTOR:
    case VT_VARIANT|VT_VECTOR:

        return( TRUE );
    }

    return( FALSE );
}





//+=================================================================
//
//  Function:   _Check
//
//  Synopsis:   Verify that the actual HR is the expected
//              value.  If not, report an error and exit.
//
//  Inputs:     [HRESULT] hrExpected
//                  What we expected
//              [HRESULT] hrActual
//                  The actual HR of the previous operation.
//              [int] line
//                  The line number of the operation.
//
//  Outputs:    None.
//
//+=================================================================

void _Check(HRESULT hrExpected, HRESULT hrActual, LPCSTR szFile, int line)
{
    if (hrExpected != hrActual)
    {
        PRINTF("\nFailed with hr=%08x at line %d\n"
               "in \"%s\"\n"
               "(expected hr=%08x, GetLastError=%lu)\n",
                hrActual, line, szFile, hrExpected, GetLastError() );

        // On NT, we simply exit here.  On the Mac, where PropTest is a function rather
        // than a main(), we throw an exception so that the test may terminate somewhat
        // cleanly.

#ifdef _MAC
        throw CHRESULT( hrActual, OLESTR("Fatal Error") );
#else
        if( IsDebuggerPresent() )
            DebugBreak();

        exit(1);
#endif

    }
}

OLECHAR * GetNextTest()
{
    static int nTest;
    static OLECHAR ocsBuf[10];

    soprintf(ocsBuf, OLESTR("%d"), nTest++);

    return(ocsBuf);
}


VOID
CalcSafeArrayIndices( LONG iLinear, LONG rgIndices[], const SAFEARRAYBOUND rgsaBounds[], ULONG cDims )
{
    for( long i = 0; i < static_cast<long>(cDims) - 1; i++ )
    {
        LONG lProduct = rgsaBounds[cDims-1].cElements;

        for( int j = cDims-2; j > i; j-- )
            lProduct *= rgsaBounds[j].cElements;

        rgIndices[ i ] = rgsaBounds[i].lLbound + (iLinear / lProduct);
        iLinear %= lProduct;
    }

    rgIndices[ cDims-1 ] = rgsaBounds[cDims-1].lLbound + (iLinear % rgsaBounds[cDims-1].cElements);
}

ULONG
CalcSafeArrayElementCount( const SAFEARRAY *psa )
{
    ULONG cElems = 1;

    ULONG cDims = SafeArrayGetDim( const_cast<SAFEARRAY*>(psa) );

    for( ULONG i = 1; i <= cDims; i++ )
    {
        LONG lUpperBound = 0, lLowerBound = 0;

        Check( S_OK, SafeArrayGetLBound( const_cast<SAFEARRAY*>(psa), i, &lLowerBound ));
        Check( S_OK, SafeArrayGetUBound( const_cast<SAFEARRAY*>(psa), i, &lUpperBound ));

        cElems *= lUpperBound - lLowerBound + 1;
    }

    return( cElems );

}

VOID
CompareSafeArrays( SAFEARRAY *psa1, SAFEARRAY *psa2 )
{
    VARTYPE vt1, vt2;
    UINT cDims1, cDims2;
    UINT i;
    UINT cElems = 0;

    SAFEARRAYBOUND *rgsaBounds = NULL;
    LONG *rgIndices = NULL;

    Check( S_OK, SafeArrayGetVartype( psa1, &vt1 ));
    Check( S_OK, SafeArrayGetVartype( psa2, &vt2 ));
    Check( vt1, vt2 );

    cDims1 = SafeArrayGetDim( psa1 );
    cDims2 = SafeArrayGetDim( psa2 );
    Check( cDims1, cDims2 );

    Check( 0, memcmp( psa1->rgsabound, psa2->rgsabound, cDims1 * sizeof(SAFEARRAYBOUND) ));
    Check( psa1->fFeatures, psa2->fFeatures );
    Check( psa1->cbElements, psa2->cbElements );

    cElems = CalcSafeArrayElementCount( psa1 );

    switch( vt1 )
    {
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_BOOL:
    case VT_R4:
    case VT_R8:
    case VT_I8:
    case VT_UI8:

        Check( 0, memcmp( psa1->pvData, psa2->pvData, cDims1 * psa1->cbElements ));
        break;

    case VT_BSTR:

        rgsaBounds = new SAFEARRAYBOUND[ cDims1 ];
        Check( FALSE, NULL == rgsaBounds );
        rgIndices = new LONG[ cDims1 ];
        Check( FALSE, NULL == rgIndices );

        // The Bounds are stored in the safearray in reversed order.  Correct them so
        // that we can use CalcSafeArrayIndices

        for( i = 0; i < cDims1; i++ )
            rgsaBounds[i] = psa1->rgsabound[ cDims1-1-i ];

        for( i = 0; i < cElems; i++ )
        {
            BSTR *pbstr1 = NULL, *pbstr2 = NULL;
            CalcSafeArrayIndices( i, rgIndices, rgsaBounds, cDims1 );

            Check( S_OK, SafeArrayPtrOfIndex( psa1, rgIndices, reinterpret_cast<void**>(&pbstr1) ));
            Check( S_OK, SafeArrayPtrOfIndex( psa2, rgIndices, reinterpret_cast<void**>(&pbstr2) ));

            Check( *(reinterpret_cast<ULONG*>(*pbstr1)-1), *(reinterpret_cast<ULONG*>(*pbstr2)-1) );
            Check( 0, ocscmp( *pbstr1, *pbstr2 ));
        }

        break;

    case VT_VARIANT:

        rgsaBounds = new SAFEARRAYBOUND[ cDims1 ];
        Check( FALSE, NULL == rgsaBounds );
        rgIndices = new LONG[ cDims1 ];
        Check( FALSE, NULL == rgIndices );

        // The Bounds are stored in the safearray in reversed order.  Correct them so
        // that we can use CalcSafeArrayIndices

        for( i = 0; i < cDims1; i++ )
            rgsaBounds[i] = psa1->rgsabound[ cDims1-1-i ];

        for( i = 0; i < cElems; i++ )
        {
            CPropVariant *pcpropvar1 = NULL, *pcpropvar2 = NULL;
            CalcSafeArrayIndices( i, rgIndices, rgsaBounds, cDims1 );

            Check( S_OK, SafeArrayPtrOfIndex( psa1, rgIndices, reinterpret_cast<void**>(&pcpropvar1) ));
            Check( S_OK, SafeArrayPtrOfIndex( psa2, rgIndices, reinterpret_cast<void**>(&pcpropvar2) ));

            Check( TRUE, *pcpropvar1 == *pcpropvar2 );
        }


        break;

    default:
        Check( FALSE, TRUE );

    }   // switch( vt1 )


    delete[] rgIndices;
    delete[] rgsaBounds;
}


#ifndef _MAC    // SYSTEMTIME isn't supported on the Mac.
void Now(FILETIME *pftNow)
{
                SYSTEMTIME stStart;
                GetSystemTime(&stStart);
                SystemTimeToFileTime(&stStart, pftNow);
}
#endif


IStorage *_pstgTemp = NULL;
IStorage *_pstgTempCopyTo = NULL;  // _pstgTemp is copied to _pstgTempCopyTo

unsigned int CTempStorage::_iName;



PROPVARIANT * CGenProps::GetNext(int HowMany, int *pActual, BOOL fWrapOk, BOOL fNoNonSimple)
{
    PROPVARIANT *pVar = new PROPVARIANT[HowMany];

    if (pVar == NULL)
        return(NULL);

    for (int l=0; l<HowMany && _GetNext(pVar + l, fWrapOk, fNoNonSimple); l++) { };

    if (pActual)
        *pActual = l;

    if (l == 0)
    {
        delete pVar;
        return(NULL);
    }

    return(pVar);
}

BOOL CGenProps::_GetNext(PROPVARIANT *pVar, BOOL fWrapOk, BOOL fNoNonSimple)
{
    if (_vt == (VT_VECTOR | VT_CLSID)+1)
    {
        if (!fWrapOk)
            return(FALSE);
        else
            _vt = (VARENUM)2;
    }

    PROPVARIANT Var;
    BOOL fFirst = TRUE;

    do
    {
        GUID *pg;

        if (!fFirst)
        {
            g_pfnPropVariantClear(&Var);
        }

        fFirst = FALSE;

        memset(&Var, 0, sizeof(Var));
        Var.vt = (VARTYPE) _vt;
        (*((int*)&_vt))++;

        switch (Var.vt)
        {
        case VT_LPSTR:
                Var.pszVal = new CHAR[ 6 ];
                strcpy(Var.pszVal, "lpstr");
                break;
        case VT_LPWSTR:
                Var.pwszVal = new WCHAR[ 7 ];
                wcscpy(Var.pwszVal, L"lpwstr");
                break;
        case VT_CLSID:
                pg = new GUID;
                UuidCreate(pg);
                Var.puuid = pg;
                break;
        case VT_CF:
                Var.pclipdata = new CLIPDATA;
                Var.pclipdata->cbSize = 10;
                Var.pclipdata->pClipData = new BYTE[ 10 ];
                Var.pclipdata->ulClipFmt = 0;
                break;
        case VT_VERSIONED_STREAM:
                Var.pVersionedStream = new VERSIONEDSTREAM;
                UuidCreate( &Var.pVersionedStream->guidVersion );
                Var.pVersionedStream->pStream = NULL;
                break;
        }
    } while ( (fNoNonSimple && (Var.vt == VT_STREAM || Var.vt == VT_STREAMED_OBJECT ||
               Var.vt == VT_STORAGE || Var.vt == VT_STORED_OBJECT || Var.vt == VT_VERSIONED_STREAM)
              )
              ||
              !IsOriginalPropVariantType(Var.vt) );

    g_pfnPropVariantCopy(pVar, &Var);
    g_pfnPropVariantClear(&Var);

    return(TRUE);
}

VOID
CleanStat(ULONG celt, STATPROPSTG *psps)
{
    while (celt--)
    {
        delete [] psps->lpwstrName;
        psps++;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   PopulateRGPropVar
//
//  Synopsis:   This function fills an input array of PROPVARIANTs
//              with an assortment of properties.
//
//  Note:       For compatibility with the marshaling test, all
//              non-simple properties must be at the end of the array.
//
//+----------------------------------------------------------------------------


HRESULT
PopulateRGPropVar( CPropVariant rgcpropvar[],
                   CPropSpec    rgcpropspec[],
                   const OLECHAR *rgoszpropname[],
                   IStorage     *pstg )
{
    HRESULT hr = (HRESULT) E_FAIL;
    int  i;
    ULONG ulPropIndex = 0;
    CLIPDATA clipdataNull = {0, 0, NULL}, clipdataNonNull = {0, 0, NULL};

    CClipData cclipdataEmpty;
    cclipdataEmpty.Set( (ULONG) -1, "", 0 );


    // Initialize the PropVariants

    for( i = 0; i < CPROPERTIES_ALL; i++ )
    {
        rgcpropvar[i].Clear();
    }


    /*
    // Create a I1 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "I1 Property" );
    rgcpropvar[ulPropIndex] = (CHAR) 38;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_I1 );
    ulPropIndex++;

    // Create a vector of I1s

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "Vector|I1 Property" );
    rgcpropvar[ulPropIndex][1] = (CHAR) 22;
    rgcpropvar[ulPropIndex][0] = (CHAR) 23;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_VECTOR|VT_I1) );
    ulPropIndex++;
    */

    // Create a UI1 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "UI1 Property" );
    rgcpropvar[ulPropIndex] = (UCHAR) 39;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_UI1 );
    ulPropIndex++;

    // Create an I2 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "I2 Property" );
    rgcpropvar[ulPropIndex] = (short) -502;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_I2 );
    ulPropIndex++;

    // Create a UI2 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "UI2 Property" );
    rgcpropvar[ulPropIndex] = (USHORT) 502;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_UI2 );
    ulPropIndex++;

    // Create a BOOL property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "Bool Property" );
    rgcpropvar[ulPropIndex].SetBOOL( VARIANT_TRUE );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_BOOL );
    ulPropIndex++;

    // Create a I4 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "I4 Property" );
    rgcpropvar[ulPropIndex] = (long) -523;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_I4 );
    ulPropIndex++;

    // Create a UI4 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "UI4 Property" );
    rgcpropvar[ulPropIndex] = (ULONG) 530;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_UI4 );
    ulPropIndex++;

    // Create a R4 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "R4 Property" );
    rgcpropvar[ulPropIndex] = (float) 5.37;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_R4 );
    ulPropIndex++;

    // Create an ERROR property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "ERROR Property" );
    rgcpropvar[ulPropIndex].SetERROR( STG_E_FILENOTFOUND );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_ERROR );
    ulPropIndex++;

    // Create an I8 property

    LARGE_INTEGER large_integer;
    large_integer.LowPart = 551;
    large_integer.HighPart = 30;
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "I8 Property" );
    rgcpropvar[ulPropIndex] = large_integer;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_I8 );
    ulPropIndex++;

    // Create a UI8 property

    ULARGE_INTEGER ularge_integer;
    ularge_integer.LowPart = 561;
    ularge_integer.HighPart = 30;
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "UI8 Property" );
    rgcpropvar[ulPropIndex] = ularge_integer;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_UI8 );
    ulPropIndex++;

    // Create an R8 property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "R8 Property" );
    rgcpropvar[ulPropIndex] = (double) 571.36;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_R8 );
    ulPropIndex++;

    // Create a CY property

    CY cy;
    cy.Hi = 123;
    cy.Lo = 456;
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "Cy Property" );
    rgcpropvar[ulPropIndex] = cy;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_CY );
    ulPropIndex++;

    // Create a DATE property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "DATE Property" );
    rgcpropvar[ulPropIndex].SetDATE( 587 );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_DATE );
    ulPropIndex++;

    // Create a FILETIME property

    FILETIME filetime;
    filetime.dwLowDateTime = 0x767c0570;
    filetime.dwHighDateTime = 0x1bb7ecf;
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "FILETIME Property" );
    rgcpropvar[ulPropIndex] = filetime;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_FILETIME );
    ulPropIndex++;

    // Create a CLSID property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "CLSID Property" );
    rgcpropvar[ulPropIndex] = FMTID_SummaryInformation;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_CLSID );
    ulPropIndex++;

    // Create a vector of CLSIDs

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR( "CLSID Vector Property" );
    rgcpropvar[ulPropIndex][0] = FMTID_SummaryInformation;
    rgcpropvar[ulPropIndex][1] = FMTID_DocSummaryInformation;
    rgcpropvar[ulPropIndex][2] = FMTID_UserDefinedProperties;
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_CLSID | VT_VECTOR) );
    ulPropIndex++;

    // Create a BSTR property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("BSTR");
    rgcpropvar[ulPropIndex].SetBSTR( OLESTR("BSTR Value") );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_BSTR );
    ulPropIndex++;

    // Create a BSTR Vector property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("BSTR Vector");
    for( i = 0; i < 3; i++ )
    {
        OLECHAR olestrElement[] = OLESTR("# - BSTR Vector Element");
        olestrElement[0] = (OLECHAR) i%10 + OLESTR('0');
        rgcpropvar[ulPropIndex].SetBSTR( olestrElement, i );
    }

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_BSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create a variant vector BSTR property.

    rgcpropspec[ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("BSTR Variant Vector");

    for( i = 0; i < 3; i++ )
    {
        if( i == 0 )
        {
            rgcpropvar[ulPropIndex][0] = (PROPVARIANT) CPropVariant((long) 0x1234);
        }
        else
        {
            CPropVariant cpropvarBSTR;
            cpropvarBSTR.SetBSTR( OLESTR("# - Vector Variant BSTR") );
            (cpropvarBSTR.GetBSTR())[0] = (OLECHAR) i%10 + OLESTR('0');
            rgcpropvar[ulPropIndex][i] = (PROPVARIANT) cpropvarBSTR;
        }
    }

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_VARIANT | VT_VECTOR) );
    ulPropIndex++;

    // Create an LPSTR property

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("LPSTR Property");
    rgcpropvar[ulPropIndex]  = "LPSTR Value";

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_LPSTR );
    ulPropIndex++;

    // Create some ClipFormat properties

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("ClipFormat property");
    rgcpropvar[ ulPropIndex ]  = CClipData( L"Clipboard Data" );
    Check(TRUE,  rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("Empty ClipFormat property (NULL pointer)");
    clipdataNull.cbSize = 4;
    clipdataNull.ulClipFmt = (ULONG) -1;
    clipdataNull.pClipData = NULL;
    rgcpropvar[ ulPropIndex ] = clipdataNull;
    Check(TRUE,  rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("Empty ClipFormat property (non-NULL pointer)");
    clipdataNonNull.cbSize = 4;
    clipdataNonNull.ulClipFmt = (ULONG) -1;
    clipdataNonNull.pClipData = new BYTE[ 0 ];
    rgcpropvar[ ulPropIndex ] = clipdataNonNull;
    Check(TRUE,  rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;

    // Create a vector of ClipFormat properties

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("ClipFormat Array Property");
    rgcpropvar[ ulPropIndex ][0] = CClipData( L"Clipboard Date element 1" );
    rgcpropvar[ ulPropIndex ][1] = cclipdataEmpty;
    rgcpropvar[ ulPropIndex ][2] = clipdataNull;
    rgcpropvar[ ulPropIndex ][3] = clipdataNonNull;
    rgcpropvar[ ulPropIndex ][4] = CClipData( L"Clipboard Date element 2" );

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_CF | VT_VECTOR) );
    Check(TRUE,  rgcpropvar[ulPropIndex].Count() == 5 );
    ulPropIndex++;

    // Create an LPSTR|Vector property (e.g., the DocSumInfo
    // Document Parts array).

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("LPSTR|Vector property");
    rgcpropvar[ ulPropIndex ][0] = "LPSTR Element 0";
    rgcpropvar[ ulPropIndex ][1] = "LPSTR Element 1";

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_LPSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create an LPWSTR|Vector property

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("LPWSTR|Vector property");
    rgcpropvar[ ulPropIndex ][0] = L"LPWSTR Element 0";
    rgcpropvar[ ulPropIndex ][1] = L"LPWSTR Element 1";

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_LPWSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create a DocSumInfo HeadingPairs array.

    rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("HeadingPair array");

    rgcpropvar[ ulPropIndex ][0] = (PROPVARIANT) CPropVariant( "Heading 0" );
    rgcpropvar[ ulPropIndex ][1] = (PROPVARIANT) CPropVariant( (long) 1 );
    rgcpropvar[ ulPropIndex ][2] = (PROPVARIANT) CPropVariant( "Heading 1" );
    rgcpropvar[ ulPropIndex ][3] = (PROPVARIANT) CPropVariant( (long) 1 );

    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_VARIANT | VT_VECTOR) );
    ulPropIndex++;

    // Create some NULL (but extant) properties

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("Empty LPSTR");
    rgcpropvar[ulPropIndex]  = "";
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_LPSTR );
    ulPropIndex++;

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("Empty LPWSTR");
    rgcpropvar[ulPropIndex]  = L"";
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_LPWSTR );
    ulPropIndex++;

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("Empty BLOB");
    rgcpropvar[ulPropIndex] = CBlob(0);
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_BLOB );
    ulPropIndex++;

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("Empty BSTR");
    rgcpropvar[ulPropIndex].SetBSTR( OLESTR("") );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_BSTR );
    ulPropIndex++;

    // Create some NULL (and non-extant) properties

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("NULL BSTR");
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->vt = VT_BSTR;
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->bstrVal = NULL;
    ulPropIndex++;

    // ***
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("NULL LPSTR");
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->vt = VT_LPSTR;
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->pszVal = NULL;
    ulPropIndex++;

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("NULL LPWSTR");
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->vt = VT_LPWSTR;
    ((PROPVARIANT*)&rgcpropvar[ulPropIndex])->pwszVal = NULL;
    ulPropIndex++;
    // ***

    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("BSTR Vector with NULL element");
    rgcpropvar[ulPropIndex].SetBSTR( NULL, 0 );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == (VT_VECTOR | VT_BSTR) );
    ulPropIndex++;

    /*
    rgcpropspec[ulPropIndex] = rgoszpropname[ulPropIndex] = OLESTR("LPSTR Vector with NULL element");
    rgcpropvar[ulPropIndex].SetLPSTR( NULL, 0 );
    Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_VECTOR | VT_LPSTR );
    ulPropIndex++;
    */


    if( !(g_Restrictions & RESTRICT_SIMPLE_ONLY) )
    {
        // Create an IStream property

        IStream *pstmProperty = NULL;

        CheckLockCount( pstg, 0 );

        Check(S_OK, pstg->CreateStream( OLESTR("Stream Property"),
                                        STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        0L, 0L,
                                        &pstmProperty ));
        CheckLockCount( pstg, 0 );

        Check(S_OK, pstmProperty->Write("Hi There", 9, NULL ));
        Check(S_OK, pstmProperty->Seek( CLargeInteger(0), STREAM_SEEK_SET, NULL ));
        CheckLockCount( pstmProperty, 0 );

        rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("Stream Property");
        rgcpropvar[ ulPropIndex ] = pstmProperty;
        pstmProperty->Release();
        pstmProperty = NULL;
        Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_STREAM );
        ulPropIndex++;

        // Create a VersionedStream property

        VERSIONEDSTREAM VersionedStreamProperty;

        UuidCreate( &VersionedStreamProperty.guidVersion );

        Check(S_OK, pstg->CreateStream( OLESTR("Versioned Stream Property"),
                                        STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        0L, 0L,
                                        &VersionedStreamProperty.pStream ));
        Check(S_OK, VersionedStreamProperty.pStream->Write("Hi There, version", 9, NULL ));
        Check(S_OK, VersionedStreamProperty.pStream->Seek( CLargeInteger(0), STREAM_SEEK_SET, NULL ));

        rgcpropspec[ ulPropIndex ] = rgoszpropname[ ulPropIndex ] = OLESTR("Versioned Stream Property");
        rgcpropvar[ ulPropIndex ] = VersionedStreamProperty;
        RELEASE_INTERFACE( VersionedStreamProperty.pStream );
        Check( TRUE, rgcpropvar[ulPropIndex].VarType() == VT_VERSIONED_STREAM );
        ulPropIndex++;


        // Create an IStorage property

        IStorage *pstgProperty = NULL;
        Check(S_OK, StgCreateDocfile(NULL, STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_DELETEONRELEASE,
                                     0, &pstgProperty ));

        rgcpropspec[ ulPropIndex ] = rgoszpropname[ulPropIndex] = OLESTR("Storage Property");
        rgcpropvar[ ulPropIndex ] = pstgProperty;
        pstgProperty->Release();
        pstgProperty = NULL;
        Check(TRUE,  rgcpropvar[ulPropIndex].VarType() == VT_STORAGE );
        ulPropIndex++;
    }

    //  ----
    //  Exit
    //  ----

    delete [] clipdataNonNull.pClipData;
    memset( &clipdataNonNull, 0, sizeof(clipdataNonNull) );

    Check(TRUE,  CPROPERTIES_ALL >= ulPropIndex );
    hr = S_OK;
    return(hr);

}



HRESULT
ResetRGPropVar( CPropVariant rgcpropvar[] )
{
    HRESULT hr = S_OK;

    for( int i = 0; i < CPROPERTIES_ALL; i++ )
    {
        IStream *pstm = NULL;

        if( VT_STREAM == rgcpropvar[i].VarType()
            ||
            VT_STREAMED_OBJECT == rgcpropvar[i].VarType() )
        {
            pstm = rgcpropvar[i].GetSTREAM();
        }
        else if( VT_VERSIONED_STREAM == rgcpropvar[i].VarType() )
        {
            pstm = rgcpropvar[i].GetVERSIONEDSTREAM().pStream;
        }

        if( NULL != pstm )
        {
            hr = pstm->Seek( CLargeInteger(0), STREAM_SEEK_SET, NULL );
            if( FAILED(hr) ) goto Exit;
        }
    }

Exit:
    return( hr) ;
}


void
CheckFormatVersion( IPropertyStorage *ppropstg, WORD wExpected )
{
    HRESULT hr = S_OK;
    NTSTATUS status;
    WORD wActual;
    IStorageTest *ptest = NULL;

    hr = ppropstg->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&ptest) );
    if( SUCCEEDED(hr) )
    {
        Check( S_OK, ptest->GetFormatVersion(&wActual) );
        Check( wExpected, wActual );
        RELEASE_INTERFACE(ptest);
    }

    return;
}


void
CheckLockCount( IUnknown *punk, LONG lExpected )
{
    IStorageTest *ptest = NULL;
    HRESULT hr = S_OK;

    hr = punk->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&ptest) );
    if( SUCCEEDED(hr) )
        Check( lExpected, ptest->GetLockCount() );

    RELEASE_INTERFACE(ptest);
    return;
}




FILETIME operator - ( const FILETIME &ft1, const FILETIME &ft2 )
{
    FILETIME ftDiff;

    if( ft1 < ft2 )
    {
        ftDiff.dwLowDateTime  = 0;
        ftDiff.dwHighDateTime = 0;
    }

    else if( ft1.dwLowDateTime >= ft2.dwLowDateTime )
    {
        ftDiff.dwLowDateTime  = ft1.dwLowDateTime  - ft2.dwLowDateTime;
        ftDiff.dwHighDateTime = ft1.dwHighDateTime - ft2.dwHighDateTime;
    }
    else
    {
        ftDiff.dwLowDateTime = ft1.dwLowDateTime - ft2.dwLowDateTime;
        ftDiff.dwLowDateTime = (DWORD) -1 - ftDiff.dwLowDateTime;

        ftDiff.dwHighDateTime = ft1.dwHighDateTime - ft2.dwHighDateTime - 1;
    }

    return( ftDiff );
}

FILETIME operator -= ( FILETIME &ft1, const FILETIME &ft2 )
{
    ft1 = ft1 - ft2;
    return( ft1 );
}




void CheckTime(const FILETIME &ftStart, const FILETIME &ftPropSet)
{
    FILETIME ftNow;
    CoFileTimeNow(&ftNow);

    if (ftPropSet.dwLowDateTime == 0 && ftPropSet.dwHighDateTime == 0)
    {
        return;
    }

    // if ftPropSet < ftStart || ftNow < ftPropSet, error
    Check(TRUE,  ftStart <= ftPropSet && ftPropSet <= ftNow );
}


void
CheckStat(  IPropertyStorage *pPropSet, REFFMTID fmtid,
            REFCLSID clsid, ULONG PropSetFlag,
            const FILETIME & ftStart, DWORD dwOSVersion )
{
    STATPROPSETSTG StatPropSetStg;
    Check(S_OK, pPropSet->Stat(&StatPropSetStg));

    Check(TRUE, StatPropSetStg.fmtid == fmtid);
    Check(TRUE, StatPropSetStg.clsid == clsid);
    Check(TRUE, StatPropSetStg.grfFlags == PropSetFlag);
    Check(TRUE, StatPropSetStg.dwOSVersion == dwOSVersion);
    CheckTime(ftStart, StatPropSetStg.mtime);
    CheckTime(ftStart, StatPropSetStg.ctime);
    CheckTime(ftStart, StatPropSetStg.atime);
}


BOOL
IsEqualSTATPROPSTG(const STATPROPSTG *p1, const STATPROPSTG *p2)
{
    BOOL f1 = p1->propid == p2->propid;
    BOOL f2 = p1->vt == p2->vt;
    BOOL f3 = (p1->lpwstrName == NULL && p2->lpwstrName == NULL) ||
              ((p1->lpwstrName != NULL && p2->lpwstrName != NULL) &&
               ocscmp(p1->lpwstrName, p2->lpwstrName) == 0);
    return(f1 && f2 && f3);
}


void
CreateCodePageTestFile( LPOLESTR poszFileName, IStorage **ppStg )
{
    Check(TRUE,  poszFileName != NULL );

    //  --------------
    //  Initialization
    //  --------------

    TSafeStorage< IPropertySetStorage > pPSStg;
    TSafeStorage< IPropertyStorage > pPStg;

    PROPSPEC propspec;
    CPropVariant cpropvar;

    *ppStg = NULL;

    // Create the Docfile.

    Check(S_OK, g_pfnStgCreateStorageEx( poszFileName,
                                    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    DetermineStgFmt( g_enumImplementation ),
                                    0, NULL, NULL,
                                    DetermineStgIID( g_enumImplementation ),
                                    reinterpret_cast<void**>(ppStg) ));

    // Get an IPropertySetStorage

    Check(S_OK, StgToPropSetStg( *ppStg, &pPSStg ));

    // Create an IPropertyStorage

    Check(S_OK, pPSStg->Create( FMTID_NULL,
                                NULL,
                                PROPSETFLAG_ANSI,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));

    //  ----------------------
    //  Write a named property
    //  ----------------------

    // Write a named I4 property

    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = CODEPAGE_TEST_NAMED_PROPERTY;

    cpropvar = (LONG) 0x12345678;
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    //  --------------------------
    //  Write singleton properties
    //  --------------------------

    // Write an un-named BSTR.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_BSTR_PROPID;

    cpropvar.SetBSTR( OLESTR("BSTR Property") );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    // Write an un-named I4

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_I4_PROPID;

    cpropvar = (LONG) 0x76543210;
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    //  -----------------------
    //  Write vector properties
    //  -----------------------

    // Write a vector of BSTRs.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VBSTR_PROPID;

    cpropvar.SetBSTR( OLESTR("BSTR Element 1"), 1 );
    cpropvar.SetBSTR( OLESTR("BSTR Element 0"), 0 );
    Check(TRUE,  (VT_VECTOR | VT_BSTR) == cpropvar.VarType() );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

    //  -------------------------------
    //  Write Variant Vector Properties
    //  -------------------------------

    // Write a variant vector that has a BSTR

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VPROPVAR_BSTR_PROPID;

    CPropVariant cpropvarT;
    cpropvarT.SetBSTR( OLESTR("PropVar Vector BSTR") );
    cpropvar[1] = (PROPVARIANT) cpropvarT;
    cpropvar[0] = (PROPVARIANT) CPropVariant((long) 44);
    Check(TRUE,  (VT_VARIANT | VT_VECTOR) == cpropvar.VarType() );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, &cpropvar, PID_FIRST_USABLE ));

}   // CreateCodePageTestFile()


void
ModifyPropSetCodePage( IStorage *pStg, const FMTID &fmtid, USHORT usCodePage )
{

    Check(TRUE,  pStg != NULL );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    DWORD dwVT;
    ULONG cbWritten = 0;
    TSafeStorage< IStream > pStm;
    CPropVariant cpropvar;

    // Open the Stream

    RtlGuidToPropertySetName( &fmtid, aocPropSetName );
    Check(S_OK, pStg->OpenStream( aocPropSetName,
                                  NULL,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                  NULL,
                                  &pStm ));

    // Seek to the codepage property
    SeekToProperty( pStm, PID_CODEPAGE );

    // Move past the VT
    Check(S_OK, pStm->Read( &dwVT, sizeof(DWORD), NULL ));

    // Write the new code page.

    PropByteSwap( &usCodePage );
    Check(S_OK, pStm->Write( &usCodePage, sizeof(usCodePage), &cbWritten ));
    Check(TRUE, cbWritten == sizeof(usCodePage) );

}   // ModifyPropSetCodePage()

void
ModifyPropertyType( IStorage *pStg, const FMTID &fmtid, PROPID propid, VARTYPE vt )
{

    Check(TRUE,  pStg != NULL );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    DWORD dwVT;
    ULONG cbWritten = 0;
    TSafeStorage< IStream > pStm;
    CPropVariant cpropvar;

    // Open the Stream

    RtlGuidToPropertySetName( &fmtid, aocPropSetName );
    Check(S_OK, pStg->OpenStream( aocPropSetName,
                                  NULL,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                  NULL,
                                  &pStm ));

    // Seek to the property
    SeekToProperty( pStm, propid );

    // Write the new VT

    PropByteSwap( &vt );
    Check(S_OK, pStm->Write( &vt, sizeof(DWORD), &cbWritten ));
    Check(TRUE, cbWritten == sizeof(DWORD) );

}   // ModifyPropertyType()


void
SeekToProperty( IStream *pStm, PROPID propidSearch )
{

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    DWORD dwOffset = 0;
    DWORD dwcbSection = 0;
    DWORD dwcProperties = 0;
    ULONG ulcbWritten = 0;

    LARGE_INTEGER   liSectionOffset, liCodePageOffset;

    CPropVariant cpropvar;

    // Seek past the propset header and the format ID.

    liSectionOffset.HighPart = 0;
    liSectionOffset.LowPart = sizeof(PROPERTYSETHEADER) + sizeof(FMTID);
    Check(S_OK, pStm->Seek(liSectionOffset, STREAM_SEEK_SET, NULL ));

    // Move to the beginning of the property set.

    liSectionOffset.HighPart = 0;
    Check(S_OK, pStm->Read( &liSectionOffset.LowPart, sizeof(DWORD), NULL ));
    PropByteSwap(&liSectionOffset.LowPart);
    Check(S_OK, pStm->Seek( liSectionOffset, STREAM_SEEK_SET, NULL ));

    // Get the section size & property count.

    Check(S_OK, pStm->Read( &dwcbSection, sizeof(DWORD), NULL ));
    PropByteSwap( &dwcbSection );

    Check(S_OK, pStm->Read( &dwcProperties, sizeof(DWORD), NULL ));
    PropByteSwap( &dwcProperties );

    // Scan for the property.

    for( ULONG ulIndex = 0; ulIndex < dwcProperties; ulIndex++ )
    {
        PROPID propid;

        // Read in the PROPID
        Check(S_OK, pStm->Read( &propid, sizeof(PROPID), NULL ));

        // Read in this PROPIDs offset (we may not need it, but we want
        // to seek past it.
        Check(S_OK, pStm->Read( &dwOffset, sizeof(dwOffset), NULL ));
        PropByteSwap(dwOffset);

        // Is it the one we're looking for?
        if( PropByteSwap(propid) == propidSearch )
            break;

    }

    // Verify that the above for loop terminated because we found
    // the codepage.
    Check( TRUE, ulIndex < dwcProperties );

    // Move to the property.

    liSectionOffset.LowPart += dwOffset;
    Check(S_OK, pStm->Seek( liSectionOffset, STREAM_SEEK_SET, NULL ));

    return;

}   // SeekToProperty()





void
ModifyOSVersion( IStorage* pStg, DWORD dwOSVersion )
{

    Check(TRUE,  pStg != NULL );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    ULONG ulcbWritten = 0;

    LARGE_INTEGER   liOffset;
    TSafeStorage< IStream > pStm;

    // Open the Stream

    RtlGuidToPropertySetName( &FMTID_NULL, aocPropSetName );
    Check(S_OK, pStg->OpenStream( aocPropSetName,
                                  NULL,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                  NULL,
                                  &pStm ));


    // Seek to the OS Version field in the header.

    liOffset.HighPart = 0;
    liOffset.LowPart = sizeof(WORD) /*(byte-order)*/ + sizeof(WORD) /*(format)*/ ;
    Check(S_OK, pStm->Seek( liOffset, STREAM_SEEK_SET, NULL ));

    // Set the new OS Version

    PropByteSwap( &dwOSVersion );
    Check(S_OK, pStm->Write( &dwOSVersion, sizeof(dwOSVersion), &ulcbWritten ));
    Check(TRUE, ulcbWritten == sizeof(dwOSVersion) );


}   // ModifyOSVersion()



//+---------------------------------------------------------
//
//  Function:   MungePropertyStorage
//
//  Synopsis:   This routine munges the properties in a
//              Property Storage.  The values of the properties
//              remain the same, but the underlying serialization
//              is new (the properties are read, the property
//              storage is deleted, and the properties are
//              re-written).
//
//  Inputs:     [IPropertySetStorage*] ppropsetgstg (in)
//                  The Property Storage container.
//              [FMTID] fmtid
//                  The Property Storage to munge.
//
//  Returns:    None.
//
//  Note:       Property names in the dictionary for which
//              there is no property are not munged.
//
//+---------------------------------------------------------

#define MUNGE_PROPVARIANT_STEP  10

void
MungePropertyStorage( IPropertySetStorage *ppropsetstg,
                      FMTID fmtid )
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    ULONG celt, ulIndex;
    TSafeStorage< IPropertyStorage > ppropstg;

    IEnumSTATPROPSTG *penumstatpropstg = NULL;

    PROPVARIANT *rgpropvar = NULL;
    STATPROPSTG *rgstatpropstg = NULL;
    ULONG        cProperties = 0;

    // Allocate an array of PropVariants.  We may grow this later.
    rgpropvar = new PROPVARIANT[ MUNGE_PROPVARIANT_STEP ];
    Check( FALSE, NULL == rgpropvar );

    // Allocate an array of STATPROPSTGs.  We may grow this also.
    rgstatpropstg = new STATPROPSTG[ MUNGE_PROPVARIANT_STEP ];
    Check( FALSE, NULL == rgstatpropstg );

    //  -----------------
    //  Get an Enumerator
    //  -----------------

    // Open the Property Storage.  We may get an error if we're attempting
    // the UserDefined propset.  If it's file-not-found, then simply return,
    // it's not an error, and there's nothing to do.

    hr = ppropsetstg->Open( fmtid,
                            STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            &ppropstg );
    if( FMTID_UserDefinedProperties == fmtid
        &&
        (HRESULT) STG_E_FILENOTFOUND == hr )
    {
        goto Exit;
    }
    Check( S_OK, hr );

    // Get an Enumerator
    Check(S_OK, ppropstg->Enum( &penumstatpropstg ));


    //  --------------------------------------------
    //  Read & delete in all of the properties/names
    //  --------------------------------------------

    // Get the first property from the enumerator
    hr = penumstatpropstg->Next( 1, &rgstatpropstg[cProperties], &celt );
    Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );

    // Iterate through the properties.
    while( celt > 0 )
    {
        PROPSPEC propspec;
        propspec.ulKind = PRSPEC_PROPID;
        propspec.propid = rgstatpropstg[cProperties].propid;

        // Read and delete the property

        Check(S_OK, ppropstg->ReadMultiple( 1, &propspec, &rgpropvar[cProperties] ));
        Check(S_OK, ppropstg->DeleteMultiple( 1, &propspec ));

        // If there is a property name, delete it also.

        if( NULL != rgstatpropstg[cProperties].lpwstrName )
        {
            // We have a name.
            Check(S_OK, ppropstg->DeletePropertyNames( 1, &rgstatpropstg[cProperties].propid ));
        }

        // Increment the property count.
        cProperties++;

        // Do we need to grow the arrays?

        if( 0 != cProperties
            &&
            (cProperties % MUNGE_PROPVARIANT_STEP) == 0 )
        {
            // Yes - they must be reallocated.

            rgpropvar = (PROPVARIANT*)
                        CoTaskMemRealloc( rgpropvar,
                                          ( (cProperties + MUNGE_PROPVARIANT_STEP)
                                            *
                                            sizeof(*rgpropvar)
                                          ));
            Check( FALSE, NULL == rgpropvar );

            rgstatpropstg = (STATPROPSTG*)
                            CoTaskMemRealloc( rgstatpropstg,
                                              ( (cProperties + MUNGE_PROPVARIANT_STEP)
                                                 *
                                                 sizeof(*rgstatpropstg)
                                              ));
            Check( FALSE, NULL == rgstatpropstg );
        }

        // Move on to the next property.
        hr = penumstatpropstg->Next( 1, &rgstatpropstg[cProperties], &celt );
        Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );

    }   // while( celt > 0 )


    //  -------------------------------------
    //  Write the properties & names back out
    //  -------------------------------------

    for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
    {

        // Write the property.

        PROPSPEC propspec;
        propspec.ulKind = PRSPEC_PROPID;
        propspec.propid = rgstatpropstg[ ulIndex ].propid;

        Check(S_OK, ppropstg->WriteMultiple(1, &propspec, &rgpropvar[ulIndex], PID_FIRST_USABLE ));

        // If this property has a name, write it too.
        if( rgstatpropstg[ ulIndex ].lpwstrName != NULL )
        {
            Check(S_OK, ppropstg->WritePropertyNames(
                                            1,
                                            &rgstatpropstg[ulIndex].propid,
                                            &rgstatpropstg[ulIndex].lpwstrName ));
        }

    }   // for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )


    //  ----
    //  Exit
    //  ----

Exit:

    if( penumstatpropstg )
    {
        penumstatpropstg->Release();
        penumstatpropstg = NULL;
    }

    // Free the PropVariants
    if( rgpropvar )
    {
        g_pfnFreePropVariantArray( cProperties, rgpropvar );
        delete [] rgpropvar;
    }

    // Free the property names
    if( rgstatpropstg )
    {
        for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
        {
            if( NULL != rgstatpropstg[ ulIndex ].lpwstrName )
            {
                delete [] rgstatpropstg[ ulIndex ].lpwstrName;
            }
        }   // for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )

        delete [] rgstatpropstg;
    }


}   // MungePropertyStorage

//+---------------------------------------------------------
//
//  Function:   MungeStorage
//
//  Synopsis:   This routine munges the property sets in a
//              Storage.  The properties themselves are not
//              modified, but the serialized bytes are.
//              For each property set, all the properties are
//              read, the property set is deleted, and
//              the properties are re-written.
//
//  Inputs:     [IStorage*] pstg (in)
//                  The Storage to munge.
//
//  Returns:    None.
//
//  Note:       This routine only munges simple property
//              sets.
//
//+---------------------------------------------------------

void
MungeStorage( IStorage *pstg )
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    ULONG celt;

    STATPROPSETSTG statpropsetstg;
    STATSTG statstg;

    TSafeStorage< IPropertySetStorage > ppropsetstg;
    TSafeStorage< IPropertyStorage > ppropstg;

    IEnumSTATPROPSETSTG *penumstatpropsetstg;
    IEnumSTATSTG *penumstatstg;

    //  -----------------------------------------------
    //  Munge each of the property sets in this Storage
    //  -----------------------------------------------

    // Get the IPropertySetStorage interface
    Check(S_OK, StgToPropSetStg( pstg, &ppropsetstg ));

    // Get a property storage enumerator
    Check(S_OK, ppropsetstg->Enum( &penumstatpropsetstg ));

    // Get the first STATPROPSETSTG
    hr = penumstatpropsetstg->Next( 1, &statpropsetstg, &celt );
    Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );

    // Loop through the STATPROPSETSTGs.
    while( celt > 0 )
    {
        // Is this a simple property storage (we don't
        // handle non-simple sets)?

        if( !(statpropsetstg.grfFlags & PROPSETFLAG_NONSIMPLE) )
        {
            // Munge the Property Storage.
            MungePropertyStorage( ppropsetstg, statpropsetstg.fmtid );
        }

        // Get the next STATPROPSETSTG
        // If we just did the first section of the DocSumInfo
        // property set, then attempt the second section.

        if( FMTID_DocSummaryInformation == statpropsetstg.fmtid )
        {
            statpropsetstg.fmtid = FMTID_UserDefinedProperties;
        }
        else
        {
            hr = penumstatpropsetstg->Next( 1, &statpropsetstg, &celt );
            Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );
        }
    }

    // We're done with the Property Storage enumerator.
    penumstatpropsetstg->Release();
    penumstatpropsetstg = NULL;

    //  ------------------------------------------
    //  Recursively munge each of the sub-storages
    //  ------------------------------------------

    // Get the IEnumSTATSTG enumerator
    Check(S_OK, pstg->EnumElements( 0L, NULL, 0L, &penumstatstg ));

    // Get the first STATSTG structure.
    hr = penumstatstg->Next( 1, &statstg, &celt );
    Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );

    // Loop through the elements of this Storage.
    while( celt > 0 )
    {
        // Is this a sub-Storage which must be
        // munged?

        if( STGTY_STORAGE & statstg.type  // This is a Storage
            &&
            0x20 <= *statstg.pwcsName )   // But not a system Storage.
        {
            // We'll munge it.
            IStorage *psubstg;

            // Open the sub-storage.
            Check(S_OK, pstg->OpenStorage( statstg.pwcsName,
                                           NULL,
                                           STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                           NULL,
                                           0L,
                                           &psubstg ));

            // Munge the sub-storage.
            MungeStorage( psubstg );
            psubstg->Release();
            psubstg = NULL;
        }

        delete [] statstg.pwcsName;
        statstg.pwcsName = NULL;

        // Move on to the next Storage element.
        hr = penumstatstg->Next( 1, &statstg, &celt );
        Check( TRUE, (HRESULT) S_OK == hr || (HRESULT) S_FALSE == hr );
    }

    penumstatstg->Release();
    penumstatstg = NULL;


}   // MungeStorage



//+----------------------------------------------------------------------------
//+----------------------------------------------------------------------------

CLSID CObjectWithPersistStorage::_clsid = { /* 01c0652e-c97c-11d1-b2a8-00c04fb9386d */
    0x01c0652e,
    0xc97c,
    0x11d1,
    {0xb2, 0xa8, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
  };

CObjectWithPersistStorage::CObjectWithPersistStorage()
{
    _poszData = NULL;
    _cRefs = 1;
    _fDirty = FALSE;
}

CObjectWithPersistStorage::CObjectWithPersistStorage( const OLECHAR *posz )
{
    new(this) CObjectWithPersistStorage;
    _poszData = new OLECHAR[ ocslen(posz) + 1 ];
    Check( TRUE, NULL != _poszData );
    ocscpy( _poszData, posz );
    _fDirty = TRUE;
}

CObjectWithPersistStorage::~CObjectWithPersistStorage()
{
    delete[] _poszData;
}


ULONG
CObjectWithPersistStorage::AddRef()
{
    ULONG cRefs = InterlockedIncrement( &_cRefs );
    return( cRefs );
}

ULONG
CObjectWithPersistStorage::Release()
{
    ULONG cRefs = InterlockedDecrement( &_cRefs );
    if( 0 == cRefs )
        delete this;

    return( cRefs );
}


HRESULT
CObjectWithPersistStorage::QueryInterface( REFIID iid, void **ppvObject )
{
    if( IID_IPersistStorage == iid || IID_IUnknown == iid )
    {
        *ppvObject = static_cast<IPersistStorage*>(this);
        AddRef();
        return( S_OK );
    }
    else
        return( E_NOINTERFACE );
}


HRESULT
CObjectWithPersistStorage::GetClassID( CLSID *pclsid )
{
    *pclsid = GetClassID();
    return( S_OK );
}


HRESULT
CObjectWithPersistStorage::IsDirty( void)
{
    return( _fDirty );
}

HRESULT
CObjectWithPersistStorage::InitNew(
        /* [unique][in] */ IStorage __RPC_FAR *pStg)
{
    return( E_NOTIMPL );
}

HRESULT
CObjectWithPersistStorage::Load(
        /* [unique][in] */ IStorage __RPC_FAR *pStg)
{
    IStream *pStm = NULL;
    ULONG cbRead;

    Check( S_OK, pStg->OpenStream( OLESTR("CObjectWithPersistStorage"), NULL,
                                   STGM_READWRITE|STGM_SHARE_EXCLUSIVE, 0, &pStm ));

    _poszData = new OLECHAR[ MAX_PATH ];
    Check( TRUE, NULL != _poszData );

    Check( S_OK, pStm->Read( _poszData, sizeof(OLECHAR)*MAX_PATH, &cbRead ));
    _poszData[ MAX_PATH-1 ] = OLESTR('\0');

    Check( 0, RELEASE_INTERFACE( pStm ));

    return( S_OK );
}

HRESULT
CObjectWithPersistStorage::Save(
        /* [unique][in] */ IStorage __RPC_FAR *pStgSave,
        /* [in] */ BOOL fSameAsLoad)
{
    IStream *pStm = NULL;
    ULONG cbData, cbWritten;

    Check( S_OK, pStgSave->CreateStream( OLESTR("CObjectWithPersistStorage"),
                                         STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                         0, 0, &pStm ));

    cbData = sizeof(OLECHAR)*( 1 + ocslen(_poszData) );
    Check( S_OK, pStm->Write( _poszData, cbData, &cbWritten ));
    Check( TRUE, cbData == cbWritten );
    Check( 0, RELEASE_INTERFACE(pStm) );

    return( S_OK );
}


HRESULT
CObjectWithPersistStorage::SaveCompleted(
        /* [unique][in] */ IStorage __RPC_FAR *pStgNew)
{
    return( S_OK );
}

HRESULT
CObjectWithPersistStorage::HandsOffStorage( void)
{
    return( E_NOTIMPL );
}


BOOL
CObjectWithPersistStorage::operator ==( const CObjectWithPersistStorage &Other )
{
    return( Other._poszData == _poszData
            ||
            0 == ocscmp( Other._poszData, _poszData ));
}



CLSID
CObjectWithPersistStream::_clsid= { /* b447cba0-c991-11d1-b2a8-00c04fb9386d */
    0xb447cba0,
    0xc991,
    0x11d1,
    {0xb2, 0xa8, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
  };


CObjectWithPersistStream::CObjectWithPersistStream()
{
    _poszData = NULL;
    _cRefs = 1;
    _fDirty = FALSE;
}

CObjectWithPersistStream::CObjectWithPersistStream( const OLECHAR *posz )
{
    new(this) CObjectWithPersistStream;
    _poszData = new OLECHAR[ ocslen(posz) + 1 ];
    Check( TRUE, NULL != _poszData );
    ocscpy( _poszData, posz );
    _fDirty = TRUE;
}

CObjectWithPersistStream::~CObjectWithPersistStream()
{
    delete[] _poszData;
}


ULONG
CObjectWithPersistStream::AddRef()
{
    ULONG cRefs = InterlockedIncrement( &_cRefs );
    return( cRefs );
}

ULONG
CObjectWithPersistStream::Release()
{
    ULONG cRefs = InterlockedDecrement( &_cRefs );
    if( 0 == cRefs )
        delete this;

    return( cRefs );
}


HRESULT
CObjectWithPersistStream::QueryInterface( REFIID iid, void **ppvObject )
{
    if( IID_IPersistStream == iid || IID_IUnknown == iid )
    {
        *ppvObject = static_cast<IPersistStream*>(this);
        AddRef();
        return( S_OK );
    }
    else
        return( E_NOINTERFACE );
}


HRESULT
CObjectWithPersistStream::GetClassID( CLSID *pclsid )
{
    *pclsid = GetClassID();
    return( S_OK );
}


HRESULT
CObjectWithPersistStream::IsDirty( void)
{
    return( _fDirty );
}



HRESULT
CObjectWithPersistStream::Load(
       /* [unique][in] */ IStream __RPC_FAR *pStm)
{
    ULONG cbRead;

    _poszData = new OLECHAR[ MAX_PATH ];
    Check( TRUE, NULL != _poszData );

    Check( S_OK, pStm->Read( _poszData, sizeof(OLECHAR)*MAX_PATH, &cbRead ));
    _poszData[ MAX_PATH-1 ] = OLESTR('\0');

    return( S_OK );
}

HRESULT
CObjectWithPersistStream::Save(
       /* [unique][in] */ IStream __RPC_FAR *pStm,
       /* [in] */ BOOL fClearDirty)
{
    ULONG cbData, cbWritten;

    cbData = sizeof(OLECHAR)*( 1 + ocslen(_poszData) );
    Check( S_OK, pStm->Write( _poszData, cbData, &cbWritten ));
    Check( TRUE, cbData == cbWritten );

    return( S_OK );
}

HRESULT
CObjectWithPersistStream::GetSizeMax(
   /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize)
{
    return( E_NOTIMPL );
}

BOOL
CObjectWithPersistStream::operator ==( const CObjectWithPersistStream &Other )
{
    return( Other._poszData == _poszData
            ||
            0 == ocscmp( Other._poszData, _poszData ));
}



//+----------------------------------------------------------------------------
//+----------------------------------------------------------------------------

void
DeleteBagExProperties( IPropertyBagEx *pbag, const OLECHAR *poszPrefix )
{
    HRESULT hr = S_OK;
    IEnumSTATPROPBAG *penum = NULL;
    STATPROPBAG statpropbag;

    // Get an enumerator of the properties to be deleted.

    Check( S_OK, pbag->Enum( poszPrefix, 0, &penum ));

    // Loop through and delete the properties

    hr = penum->Next(1, &statpropbag, NULL );
    Check( TRUE, SUCCEEDED(hr) );

    while( S_OK == hr )
    {
        Check( S_OK, pbag->DeleteMultiple(1, &statpropbag.lpwstrName, 0 ));

        delete [] statpropbag.lpwstrName;
        statpropbag.lpwstrName = NULL;

        hr = penum->Next(1, &statpropbag, NULL );
        Check( TRUE, SUCCEEDED(hr) );

    }   // while( S_OK == hr )

    RELEASE_INTERFACE(penum);

    return;

}   // EmptyPropertyBagEx



//+----------------------------------------------------------------------------
//
//  Function:   DetermineSystemInfo
//
//  Synopsis:   Fill in the g_SystemInfo structure.
//
//  Inputs:     None.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void DetermineSystemInfo()
{
    // Initilize g_SystemInfo.

    g_SystemInfo.osenum = osenumUnknown;
    g_SystemInfo.fIPropMarshaling = FALSE;

#ifdef _MAC

    // Set the OS type.
    g_SystemInfo.osenum = osenumMac;

#else

    DWORD dwVersion;

    // Get the OS Version
    dwVersion = GetVersion();

    // Is this an NT system?

    if( (dwVersion & 0x80000000) == 0 )
    {
        // Is this at least NT4?
        if( LOBYTE(LOWORD( dwVersion )) >= 4 )
            g_SystemInfo.osenum = osenumNT4;

        // Or, is this pre-NT4?
        else
        if( LOBYTE(LOWORD( dwVersion )) == 3 )
        {
            g_SystemInfo.osenum = osenumNT3;
        }
    }

    // Otherwise, this is some kind of Win95 machine.
    else
    {
        HINSTANCE hinst;
        FARPROC farproc;

        // Load OLE32, and see if CoIntializeEx exists.  If it does,
        // then DCOM95 is installed.  Otherwise, this is just the base
        // Win95.

        hinst = LoadLibraryA( "ole32.dll" );
        Check( TRUE, hinst != NULL );

        farproc = GetProcAddress( hinst, "CoInitializeEx" );

        if( NULL != farproc )
        {
            g_SystemInfo.osenum = osenumDCOM95;
        }
        else if( ERROR_PROC_NOT_FOUND == GetLastError() )
        {
            g_SystemInfo.osenum = osenumWin95;
        }
    }   // if( (dwVersion & 0x80000000) == 0 )

    Check( TRUE, g_SystemInfo.osenum != osenumUnknown );

#endif // #ifdef _MAC ... #else

    if( osenumWin95 == g_SystemInfo.osenum
        ||
        osenumNT3 == g_SystemInfo.osenum
      )
    {
        g_SystemInfo.fIPropMarshaling = TRUE;
    }
}


void
DisplayUsage( LPSTR pszCommand )
{
#ifndef _MAC
    printf("\n");
    printf("   Usage: %s [options]\n", pszCommand);
    printf("   Options:\n");
    printf("      /s  run Standard tests\n" );
    printf("      /w  run the Word 6 test\n");
    printf("      /m  run the Marshaling test\n");
    printf("      /c  run the CoFileTimeNow\n");
    printf("      /p  run the Performance test\n");
    printf("      /a  run All tests\n" );
    printf("      /k  run the simple leaK test\n" );
    printf("      /n  use nt5props.dll rather than ole32.dll where possible\n");
    printf("          (mostly for STGFMT_FILE)\n" );
    printf("\n");
    printf("      /i# Implementation to use:\n");
    printf("             0 => Use DocFile and QI for IPropSetStg (default)\n");
    printf("             1 => Use DocFile and use Stg*Prop*Stg\n");
    printf("             3 => Use NSS\n");
    printf("             4 => Use NTFS native property sets\n");
    printf("      /l  Don't register the local server\n");
    printf("      /v  Verbose output\n" );
    printf("\n");
    printf("   File & Directory Options:\n" );
    printf("      /t <directory> specifies temporary directory\n" );
    printf("          (used during standard & optional tests - if not specified,\n" );
    printf("          a default will be used)\n" );
    printf("      /g <file> specifies a file to be munGed\n" );
    printf("          (propsets are read, deleted, & re-written)\n" );
    printf("      /d <file> specifies a file to be Dumped\n" );
    printf("          (propsets are dumped to stdout\n" );
    printf("\n");
    printf("   For Example:\n" );
    printf("      %s -smw /i1 -t d:\\test\n", pszCommand );
    printf("      %s -d word6.doc\n", pszCommand );
    printf("      %s -g word6.doc\n", pszCommand );
    printf("\n");

#endif

    return;
}



ULONG
ProcessCommandLine( int cArg, const LPSTR rgszArg[],
                    LPSTR *ppszFileToDump, LPSTR *ppszFileToMunge, LPSTR *ppszTemporaryDirectory )
{
    ULONG ulTestOptions = 0;
    ULONG ulTestOptionsT = 0;
    int nArgIndex;

    if( 2 > cArg )
    {
        goto Exit;
    }

    for( nArgIndex = 1; nArgIndex < cArg; nArgIndex++ )
    {
        if( rgszArg[nArgIndex][0] == '/'
            ||
            rgszArg[nArgIndex][0] == '-'
          )
        {
            BOOL fNextArgument = FALSE;

            for( int nOptionSubIndex = 1;
                 rgszArg[nArgIndex][nOptionSubIndex] != '\0' && !fNextArgument;
                 nOptionSubIndex++
               )
            {
                switch( rgszArg[nArgIndex][nOptionSubIndex] )
                {
                    case 's':
                    case 'S':

                        ulTestOptionsT |= TEST_STANDARD;
                        break;

                    case 'a':
                    case 'A':

                        ulTestOptionsT |= TEST_WORD6 | TEST_MARSHALING | TEST_COFILETIMENOW | TEST_PERFORMANCE;
                        break;

                    case 'g':
                    case 'G':

                        if( NULL != *ppszFileToMunge )
                            printf( "Error:  Only one file may be munged\n" );
                        else
                        {
                            nArgIndex++;
                            *ppszFileToMunge = &rgszArg[nArgIndex][0];
                            fNextArgument = TRUE;
                            if(**ppszFileToMunge == '-' || **ppszFileToMunge == '/')
                            {
                                printf( "Error:  Missing filename for munge option\n" );
                                goto Exit;
                            }
                        }
                        break;

                    case 'w':
                    case 'W':

                        ulTestOptionsT |= TEST_WORD6;
                        break;

                    case 'm':
                    case 'M':

                        ulTestOptionsT |= TEST_MARSHALING;
                        break;

                    case 'k':
                    case 'K':

                        ulTestOptionsT |= TEST_SIMPLE_LEAKS;
                        break;

                    case 'c':
                    case 'C':

                        ulTestOptionsT |= TEST_COFILETIMENOW;
                        break;

                    case 'p':
                    case 'P':

                        ulTestOptionsT |= TEST_PERFORMANCE;
                        break;

                    case 'i':
                    case 'I':
                    {
                        int nSubOption = rgszArg[nArgIndex][++nOptionSubIndex];

                        if( PROPIMP_UNKNOWN != g_enumImplementation )
                        {
                            printf( "Error in \"/i\" option (too many occurrences)\n" );
                            goto Exit;
                        }

                        switch( nSubOption )
                        {
                            case '0':   // default, if unspecified

                                g_enumImplementation = PROPIMP_DOCFILE_QI;
                                break;

                            case '1':

                                g_enumImplementation = PROPIMP_DOCFILE_OLE32;
                                break;

                            case '3':

                                g_enumImplementation = PROPIMP_STORAGE;
                                break;

                            case '4':

                                g_enumImplementation = PROPIMP_NTFS;
                                break;

                            default:

                                printf( "Error in \"/i\" option\n" );
                                goto Exit;
                        }

                        break;
                    }

                    case 't':
                    case 'T':

                        if( NULL != *ppszTemporaryDirectory )
                        {
                            printf( "Error:  Only one temporary directory may be specified\n" );
                        }
                        else
                        {
                            nArgIndex++;
                            *ppszTemporaryDirectory = &rgszArg[nArgIndex][0];
                            fNextArgument = TRUE;
                            if(**ppszTemporaryDirectory == '-'
                                ||
                               **ppszTemporaryDirectory == '/'
                              )
                            {
                                printf( "Error:  Missing name for temporary directory option\n" );
                                goto Exit;
                            }
                        }
                        break;

                    case 'l':
                    case 'L':

                        g_fRegisterLocalServer = FALSE;
                        break;

                    case 'n':
                    case 'N':

                        g_fUseNt5PropsDll = TRUE;
                        break;

                    case '?':

                        return( FALSE );
                        break;

                    case 'd':
                    case 'D':

                        if( NULL != *ppszFileToDump )
                        {
                            printf( "Error:  Only one file may be dumped\n" );
                            goto Exit;
                        }
                        else
                        {
                            nOptionSubIndex++;
                            switch (rgszArg[nArgIndex][nOptionSubIndex])
                            {
                            case 's':
                                g_stgmDumpFlags = STGM_SIMPLE;
                                break;
                            case '\0':
                                break;
                            default:
                                printf( "Error:  Invalid Flag used with dump option\n" );
                                return( FALSE );
                                break;
                            }
                            nArgIndex++;
                            *ppszFileToDump = &rgszArg[nArgIndex][0];
                            fNextArgument = TRUE;
                            if(**ppszFileToDump == '-' || **ppszFileToDump == '/')
                            {
                                printf( "Error:  Missing filename for dump option\n" );
                                goto Exit;
                            }
                        }
                        break;

                    case 'v':
                    case 'V':

                        g_fVerbose = TRUE;
                        break;

                    default:

                        printf( "Option '%c' ignored\n", rgszArg[nArgIndex][nOptionSubIndex] );
                        break;

                }   // switch( argv[nArgIndex][1] )

            }   // for( int nOptionSubIndex = 1; ...
        }   // if( argv[nArgIndex][0] == '/'
        else
        {
            break;
        }
    }   // for( ULONG nArgIndex = 2; nArgIndex < argc; nArgIndex++ )


    ulTestOptions = ulTestOptionsT;

    //  ----
    //  Exit
    //  ----

Exit:

    return( ulTestOptions );

}   // ProcessCommandLine



HRESULT CFlatStorage::Create( const WCHAR *pwszFile )
{
    HRESULT hr = E_FAIL;
    WCHAR wsz[ 2 * MAX_PATH ];

    wcsncpy( _wszPath, pwszFile, MAX_PATH );

    wcscpy( wsz, pwszFile );
    wcscat( wsz, L":Storage" );
    hr = g_pfnStgCreateStorageEx ( wsz,
            STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
            STGFMT_STORAGE,
            0,
            NULL,
            NULL,
            IID_IStorage,
            (void**) &_pStg );
    if( FAILED(hr) )
        return hr;
    RELEASE_INTERFACE( _pStg );

    hr = g_pfnStgOpenStorageEx ( pwszFile,
            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
            STGFMT_FILE,
            0,
            NULL,
            NULL,
            IID_IPropertySetStorage,
            (void**) &_pPropSetStg );
    if( FAILED(hr) )
        return hr;

    _hFile = CreateFile( wsz, //pwszFile,
                            GENERIC_READ|GENERIC_WRITE,
                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            0, NULL );
    if( INVALID_HANDLE_VALUE == _hFile )
        return HRESULT_FROM_WIN32( GetLastError() );

    hr = g_pfnStgOpenStorageOnHandle( _hFile,
                                        STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                        NULL, NULL,
                                        IID_IStorage,
                                        (void**) &_pStg );
    if( FAILED(hr) ) 
        return hr;

    return hr;
}


HRESULT CFlatStorage::Open( const WCHAR *pwszFile )
{
    HRESULT hr = E_FAIL;
    WCHAR wsz[ 2 * MAX_PATH ];

    wcsncpy( _wszPath, pwszFile, MAX_PATH );

    wcscpy( wsz, pwszFile );
    wcscat( wsz, L":Storage" );

    hr = g_pfnStgOpenStorageEx ( pwszFile,
            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
            STGFMT_ANY,
            0,
            NULL,
            NULL,
            IID_IPropertySetStorage,
            (void**) &_pPropSetStg );
    if( FAILED(hr) )
        return hr;

    _hFile = CreateFile( wsz, //pwszFile,
                            GENERIC_READ|GENERIC_WRITE,
                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            0, NULL );
    if( INVALID_HANDLE_VALUE == _hFile )
        return HRESULT_FROM_WIN32( GetLastError() );

    hr = g_pfnStgOpenStorageOnHandle( _hFile,
                                        STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                        NULL, NULL,
                                        IID_IStorage,
                                        (void**) &_pStg );
    if( FAILED(hr) ) 
        return hr;

    return hr;
}



HRESULT STDMETHODCALLTYPE CFlatStorage::QueryInterface(
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    HRESULT hr = E_FAIL;

    if( IID_IUnknown == riid 
        ||
        IID_IStorage == riid )
    {
        AddRef();
        *ppvObject = (IStorage*) this;
        return S_OK;
    }
    else if( IID_IPropertySetStorage == riid )
    {
        AddRef();
        *ppvObject = (IPropertySetStorage*) this;
        return S_OK;
    }

    return E_NOINTERFACE;

}

ULONG STDMETHODCALLTYPE CFlatStorage::AddRef( void )
{
    return ++_cRefs;
}

ULONG STDMETHODCALLTYPE CFlatStorage::Release( void)
{
    ULONG cRefs = --_cRefs;

    if(0 == cRefs )
    {
        RELEASE_INTERFACE( _pStg );
        RELEASE_INTERFACE( _pPropSetStg );
        delete this;
    }

    return cRefs;
}




#define Out wprintf

NTSTATUS GetProcessInfo(
    PSYSTEM_PROCESS_INFORMATION pspi )
{

    NUMBERFMT NumberFmt;
    LCID lcid = GetUserDefaultLCID();

    typedef NTSTATUS (__stdcall*PFNNtQuerySystemInformation)(ULONG,BYTE*,ULONG,VOID*);
    static BYTE ab[81920];
    static HINSTANCE hinstNTDLL = NULL;
    static PFNNtQuerySystemInformation pfnNtQuerySystemInformation = NULL;

    WCHAR *pwcImage = L"proptest.exe";

    if( NULL == pfnNtQuerySystemInformation )
    {
        if( NULL == hinstNTDLL )
        {
            hinstNTDLL = LoadLibrary( TEXT("ntdll.dll") );
            Check( FALSE, NULL == hinstNTDLL );
        }

        pfnNtQuerySystemInformation = (PFNNtQuerySystemInformation)
                                      GetProcAddress( hinstNTDLL,
                                                      "NtQuerySystemInformation" );
        Check( FALSE, NULL == pfnNtQuerySystemInformation );
    }

    NTSTATUS status = pfnNtQuerySystemInformation( SystemProcessInformation,
                                                   ab,
                                                   sizeof ab,
                                                   NULL );

    if ( NT_SUCCESS( status ) )
    {
        status = STATUS_OBJECT_NAME_NOT_FOUND;
        DWORD cbOffset = 0;
        PSYSTEM_PROCESS_INFORMATION p = 0;
        do
        {
            p = (PSYSTEM_PROCESS_INFORMATION)&(ab[cbOffset]);

            if ( ( L'*' == *pwcImage ) ||
                 ( 0 == *pwcImage ) ||
                 ( p->ImageName.Buffer &&
                   !_wcsicmp( pwcImage, p->ImageName.Buffer ) ) )
            {
                status = STATUS_SUCCESS;
                *pspi = *p;
                break;
            }

            cbOffset += p->NextEntryOffset;
        } while ( 0 != p->NextEntryOffset );
    }

    return( status );

} //GetProcessInfo


#ifdef _MAC
int __cdecl PropTestMain(int argc, char **argv, CDisplay *pcDisplay )
#else
int __cdecl main(int cArg, char *rgszArg[])
#endif
{
    ULONG ulTestOptions = 0L;
    CHAR* pszFileToMunge = NULL;
    CHAR* pszTemporaryDirectory = NULL;
    CHAR* pszFileToDump = NULL;

    #ifdef _MAC
        g_pcDisplay = pcDisplay;
        Check( S_OK, InitOleManager( OLEMGR_BIND_NORMAL ));

        #if DBG
            FnAssertOn( TRUE );
        #endif
    #endif

    // Print an appropriate header message

    #ifdef WINNT
    #ifdef _CAIRO_
        PRINTF("\nCairo Property Set Tests\n");
    #else
        PRINTF("\nSUR Property Set Tests\n");
    #endif
    #elif defined(_MAC)
        PRINTF("\nMacintosh Property Set Tests\n" );
    #else
        PRINTF("\nChicago Property Set Tests\n");
    #endif

    // Process the command-line

    ulTestOptions = ProcessCommandLine( cArg, rgszArg, &pszFileToDump, &pszFileToMunge, &pszTemporaryDirectory );
    if(( 0 == ulTestOptions ) && (NULL == pszFileToDump))
    {
        DisplayUsage( rgszArg[0] );
        exit(0);
    }

    // Ensure that that one of the "-i" options is specified.

    if( PROPIMP_UNKNOWN == g_enumImplementation )
    {
        g_enumImplementation = PROPIMP_DOCFILE_QI; // The default
    }

    if( PROPIMP_NTFS == g_enumImplementation )
        g_Restrictions = RESTRICT_DIRECT_ONLY | RESTRICT_NON_HIERARCHICAL;
    else
        g_Restrictions = RESTRICT_NONE;

    // This 'try' wraps the remainder of the routine.
    try
    {
        OLECHAR ocsDir[MAX_PATH+1], ocsTest[MAX_PATH+1],
                ocsTest2[MAX_PATH+1], ocsMarshalingTest[MAX_PATH+1],
                ocsTestOffice[MAX_PATH+1];

        CHAR    szDir[ MAX_PATH+1 ];
        CHAR    pszGeneratedTempDir[ MAX_PATH + 1 ];

        HRESULT hr;
        DWORD dwFileAttributes;

        UNREFERENCED_PARAMETER( dwFileAttributes );
        UNREFERENCED_PARAMETER( pszGeneratedTempDir );

        CoInitialize(NULL);

        ocscpy( ocsDir, OLESTR("") );

        //  ----------------------------------------------------
        //  Get the pointers to the necessary exported functions
        //  ----------------------------------------------------

        // We use explicit linking so that we can use either the OLE32.dll
        // or nt5props.dll exports.

        if( g_fUseNt5PropsDll )
        {
            // We're to use the propset APIs from nt5props.dll

            g_hinstDLL = LoadLibraryA( "nt5props.dll" );
            Check( TRUE, NULL != g_hinstDLL );

        }
        else
        {
            // We're to use the propset APIs from OLE32

            g_hinstDLL = LoadLibraryA( "ole32.dll" );
            Check( TRUE, NULL != g_hinstDLL );

        }

        g_pfnPropVariantCopy = (FNPROPVARIANTCOPY*)
                               GetProcAddress( g_hinstDLL,
                                               "PropVariantCopy" );
        Check( FALSE, NULL == g_pfnPropVariantCopy );

        g_pfnPropVariantClear = (FNPROPVARIANTCLEAR*)
                                GetProcAddress( g_hinstDLL,
                                                "PropVariantClear" );
        Check( FALSE, NULL == g_pfnPropVariantClear );

        g_pfnFreePropVariantArray = (FNFREEPROPVARIANTARRAY*)
                                    GetProcAddress( g_hinstDLL,
                                                    "FreePropVariantArray" );
        Check( FALSE, NULL == g_pfnFreePropVariantArray );

        g_pfnStgCreatePropSetStg = (FNSTGCREATEPROPSETSTG*)
                                   GetProcAddress( g_hinstDLL,
                                                   "StgCreatePropSetStg" );
        Check( FALSE, NULL == g_pfnStgCreatePropSetStg );

        g_pfnStgCreatePropStg = (FNSTGCREATEPROPSTG*)
                                GetProcAddress( g_hinstDLL,
                                                "StgCreatePropStg" );
        Check( FALSE, NULL == g_pfnStgCreatePropStg );

        g_pfnStgOpenPropStg = (FNSTGOPENPROPSTG*)
                              GetProcAddress( g_hinstDLL,
                                              "StgOpenPropStg" );
        Check( FALSE, NULL == g_pfnStgOpenPropStg );

        g_pfnFmtIdToPropStgName = (FNFMTIDTOPROPSTGNAME*)
                                  GetProcAddress( g_hinstDLL,
                                                  "FmtIdToPropStgName" );
        Check( FALSE, NULL == g_pfnFmtIdToPropStgName );

        g_pfnPropStgNameToFmtId = (FNPROPSTGNAMETOFMTID*)
                                  GetProcAddress( g_hinstDLL,
                                                  "PropStgNameToFmtId" );
        Check( FALSE, NULL == g_pfnPropStgNameToFmtId );

        g_pfnStgCreateStorageEx = (FNSTGCREATESTORAGEEX*)
                                  GetProcAddress( g_hinstDLL, "StgCreateStorageEx" );
        Check( FALSE, NULL == g_pfnStgCreateStorageEx );

        g_pfnStgOpenStorageEx = (FNSTGOPENSTORAGEEX*)
                                  GetProcAddress( g_hinstDLL, "StgOpenStorageEx" );
        Check( FALSE, NULL == g_pfnStgOpenStorageEx );

        g_pfnStgOpenStorageOnHandle = (FNSTGOPENSTORAGEONHANDLE*)
                                      GetProcAddress( g_hinstDLL, "StgOpenStorageOnHandle" );
        Check( FALSE, NULL == g_pfnStgOpenStorageOnHandle );

        /*
        g_pfnStgCreateStorageOnHandle = (FNSTGCREATESTORAGEONHANDLE*)
                                        GetProcAddress( g_hinstDLL, "StgCreateStorageOnHandle" );
        Check( FALSE, NULL == g_pfnStgCreateStorageOnHandle );
        */

        g_pfnStgPropertyLengthAsVariant = (FNSTGPROPERTYLENGTHASVARIANT*)
                                          GetProcAddress( g_hinstDLL, "StgPropertyLengthAsVariant" );
        Check( FALSE, NULL == g_pfnStgPropertyLengthAsVariant );

        g_pfnStgConvertVariantToProperty = (FNSTGCONVERTVARIANTTOPROPERTY*)
                                           GetProcAddress( g_hinstDLL, "StgConvertVariantToProperty" );
        Check( FALSE, NULL == g_pfnStgConvertVariantToProperty );

        g_pfnStgConvertPropertyToVariant = (FNSTGCONVERTPROPERTYTOVARIANT*)
                                           GetProcAddress( g_hinstDLL, "StgConvertPropertyToVariant" );
        Check( FALSE, NULL == g_pfnStgConvertPropertyToVariant );



        //  ------------------------
        //  Is there a file to dump?
        //  ------------------------

        if( NULL != pszFileToDump )
        {
            IStorage *pstg;
            IPropertySetStorage *pPropSetStg = NULL;
            IPropertyStorage *pPropStg = NULL;
            PROPSPEC psTest = {1, 2 }; // { 0, (ULONG) L"cimax" };
            PROPVARIANT propvar;

#if 0
            GUID const guidTest = { 0xCF2EAF90, 0x9311, 0x11CF, 0xBF, 0x8C,
                                    0x00, 0x20, 0xAF, 0xE5, 0x05, 0x08 };
            GetProcessInfo( L"proptest.exe" );
#endif

            PropTest_mbstoocs( ocsDir, sizeof(ocsDir), pszFileToDump );

            for( int i = 0; i < 1; i++ )
            {
                HRESULT     hr;

                if ( 0 == ( i % 100 ) )
                    printf(".");

                //
                // Attempt to open as docfile or NSS. If that fails,
                // then attempt to open as a FLAT_FILE.
                //
                hr = StgOpenStorageEx( ocsDir,
                                       g_stgmDumpFlags | STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                                       STGFMT_ANY,
                                       0L,
                                       NULL,
                                       NULL,
                                       IID_IStorage,
                                       (PVOID*)&pstg );
                if (FAILED(hr))
                {
                    hr = StgOpenStorageEx( ocsDir,
                                           g_stgmDumpFlags | STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                                           STGFMT_ANY,
                                           0L,
                                           NULL,
                                           NULL,
                                           IID_IPropertySetStorage,
                                           (PVOID*)&pPropSetStg );
                }
                Check(S_OK,hr);
                DumpOleStorage( pstg, pPropSetStg, ocsDir );

#if 0
                Check(S_OK, StgToPropSetStg( pstg, &pPropSetStg ));

                Check(S_OK, pPropSetStg->Open( guidTest,
                                               STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                               &pPropStg ));

                Check(S_OK, pPropStg->ReadMultiple( 1,
                                                    &psTest,
                                                    &propvar ));
                Check( TRUE, propvar.vt == VT_I4 );

                pPropStg->Release();

                pPropSetStg->Release();

#endif
                if (pstg)
                {
                    pstg->Release();
                }

            }

//            GetProcessInfo( L"proptest.exe" );

            printf( "Press enter key to exit ..." );
            getchar();

            return(0);
        }


        //  -------------------------
        //  Is there a file to munge?
        //  -------------------------

        if( NULL != pszFileToMunge )
        {
            IStorage *pstg;

            PropTest_mbstoocs( ocsDir, sizeof(ocsDir), pszFileToMunge );
            Check(S_OK, StgOpenStorage( ocsDir,
                                        NULL,
                                        STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        NULL,
                                        0L,
                                        &pstg ));
            MungeStorage( pstg );
            OPRINTF( OLESTR("\"%s\" successfully munged\n"), ocsDir );
            pstg->Release();
            return(0);
        }

        //  ----------------------------
        //  Create a temporary directory
        //  ----------------------------

        // If no temporary directory was specified, generate one.

    #ifndef _MAC
        if( NULL == pszTemporaryDirectory )
        {
            GetTempPathA(sizeof(pszGeneratedTempDir)/sizeof(pszGeneratedTempDir[0]), pszGeneratedTempDir);
            pszTemporaryDirectory = pszGeneratedTempDir;

        }

        // If necessary, add a path separator to the end of the
        // temp directory name.

        {
            CHAR chLast = pszTemporaryDirectory[ strlen(pszTemporaryDirectory) - 1];
            if( (CHAR) '\\' != chLast
                &&
                (CHAR) ':'  != chLast )
            {
                strcat( pszTemporaryDirectory, "\\" );
            }
        }
    #endif  // #ifndef _MAC

        int i=0;

    #ifndef _MAC
        // Verify that the user-provided directory path
        // exists

        dwFileAttributes = GetFileAttributesA( pszTemporaryDirectory );

        if( (DWORD) -1 ==  dwFileAttributes )
        {
            printf( "Error:  couldn't open temporary directory:  \"%s\"\n", pszTemporaryDirectory );
            exit(1);
        }
        else if( !(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            printf( "Error:  \"%s\" is not a directory\n", pszTemporaryDirectory );
            exit(1);
        }

        // Find a new directory name to use for temporary
        // files ("PrpTstX", where "X" is a number).

        do
        {
            // Post-pend a subdirectory name and counter
            // to the temporary directory name.

            strcpy( szDir, pszTemporaryDirectory );
            strcat( szDir, "PrpTst" );
            sprintf( strchr(szDir,0), "%d", i++ );

        }
        while (!PropTest_CreateDirectory(szDir, NULL));

        printf( "Generated files will be put in \"%s\"\n", szDir );
        strcat( szDir, "\\" );

        // Convert to an OLESTR.
        PropTest_mbstoocs( ocsDir, sizeof(ocsDir), szDir );

    #endif  // #ifndef _MAC

        //  --------------------------------
        //  Create necessary temporary files
        //  --------------------------------

        // If any of the standard or extended tests will be run,
        // create "testdoc" and "testdoc2".

        if( ulTestOptions )
        {
            IPropertySetStorage *pPropSetStg;

            // Create "testdoc"

            ocscpy(ocsTest, ocsDir);
            ocscat(ocsTest, OLESTR("testdoc"));

            if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
            {
                CFlatStorage *pcFlatStorage = new CFlatStorage();
                if( NULL == pcFlatStorage )
                    hr = E_OUTOFMEMORY;
                else
                {
                    hr = pcFlatStorage->Create( ocsTest );
                    _pstgTemp = (IStorage*) pcFlatStorage;
                }
            }
            else
            {
                hr = g_pfnStgCreateStorageEx (
                        ocsTest,
                        STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        DetermineStgFmt( g_enumImplementation ),
                        0,
                        NULL,
                        NULL,
                        DetermineStgIID( g_enumImplementation ),
                        (void**) &_pstgTemp );
            }
            if (hr != S_OK)
            {
                OPRINTF( OLESTR("Can't create %s (0x%08x)\n"), ocsTest, hr);
                exit(1);
            }

            // Create "testdoc2"

            ocscpy(ocsTest2, ocsDir);
            ocscat(ocsTest2, OLESTR("testdoc2"));

            hr = StgCreateDocfile(ocsTest2, STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      0, &_pstgTempCopyTo);
            if (hr != S_OK)
            {
                OPRINTF(OLESTR("Can't create %s\n"), ocsTest2);
                exit(1);
            }


        }   // if( ulTestOptions )

        //  ---------------------
        //  Finish initialization
        //  ---------------------

        // Indicate what type of marshaling is being used:  OLE32 or IPROP.

        DetermineSystemInfo();
        if( g_SystemInfo.fIPropMarshaling )
            PRINTF( "Using IPROP.DLL for marshaling\n" );
        else
            PRINTF( "Using OLE32.DLL for marshaling\n" );

        // Populate an array of propvars for use in tests.

        Check(S_OK, PopulateRGPropVar( g_rgcpropvarAll, g_rgcpropspecAll, g_rgoszpropnameAll, _pstgTemp ));


        //  --------------
        //  Standard Tests
        //  --------------

        // These are the standard tests that should run in
        // any environment.

        if( ulTestOptions & TEST_STANDARD )
        {

            PRINTF( "\nStandard Tests: " );
            g_nIndent++;

            if( g_fVerbose )
                PRINTF( "\n---------------\n" );


            test_LargePropertySet( _pstgTemp );

            // Run the quick tests.
            test_WriteReadAllProperties( ocsDir );

            // The codepage & lcid should be settable iff the property set is ~empty
            test_SettingLocalization( _pstgTemp );

            // Test the StgOpenStorageOnHandle API
            test_StgOnHandle( ocsDir );

            // Test invalid VTs
            test_UnsupportedProperties( _pstgTemp );

            // Test support for the new (to NT5) VTs (VTs from the Variant)
            test_ExtendedTypes( _pstgTemp );

            // Test the calculation of external memory requirements.
            test_PropertyLengthAsVariant( );

            // Test VT_ARRAY
            test_SafeArray( _pstgTemp );

            // Test each of the interfaces
            test_PropertyInterfaces(_pstgTemp);

            // Test StgCreate/OpenPropStg on CreateStreamOnHGlobal
            test_PropsetOnHGlobal();

            // Test the read-only range of reserved PROPIDs
            test_ReadOnlyReservedProperties( _pstgTemp );

            // Writing PID_ILLEGAL should be silently ignored.
            test_PidIllegal( _pstgTemp );

            // Test the Standalone APIs
            test_StandaloneAPIs( ocsDir );

            // Test for robustness (NTFS only)
            //test_Robustness( ocsDir );

            // Test read-only open of file with no property sets (NTFS only)
            test_PropsetOnEmptyFile( ocsDir );

            // Test having two read-only readers.
            test_MultipleReader( ocsDir );

            // Test PROPSETFLAG_CASE_SENSITIVE & long names
            test_VersionOneNames( _pstgTemp );

            // Test the low-memory support in IMappedStream
            test_LowMemory( _pstgTemp );

            // Test VT_BYREF
            test_ByRef( _pstgTemp );

            // Run the property bag tests

            Status( "Bag Tests\n" );
            g_nIndent++;
            {
                test_IPropertyBag( _pstgTemp );

                test_BagVtUnknown( _pstgTemp );
                test_BagDelete( _pstgTemp );
                test_EmptyBag( ocsDir );
                test_BagEnum( _pstgTemp );
                test_BagCoercion( _pstgTemp );
                test_BagOpenMethod( _pstgTemp );
            }
            --g_nIndent;

            // Test that code pages are handled properly.
            test_CodePages( ocsDir );

            // Test the PROPSETFLAG_UNBUFFERED flag in Stg*PropStg APIs
            test_PROPSETFLAG_UNBUFFERED( _pstgTemp );

            // Test FMTID<->Name conversions
            test_PropStgNameConversion( _pstgTemp );

            // Test the FMTID<->Name conversion APIs
            test_PropStgNameConversion2( );

            // Test StgOpenStorageEx for NTFS flat file support.
            test_ex_api(ocsDir);

            // Test Simple Mode DocFile
            test_SimpleDocFile(ocsDir);

            // Test the IStorage::CopyTo operation, using all combinations of
            // direct and transacted mode for the base and PropSet storages.
            // We don't run this test on the Mac because it doesn't have IStorages
            // which support IPropertySetStorages.

            #ifndef _MAC_NODOC

            if( PROPIMP_STORAGE == g_enumImplementation
                ||
                PROPIMP_DOCFILE_QI == g_enumImplementation )
        {
            for( int iteration = 0; iteration < 4; iteration++ )
            {
            OLECHAR aocStorageName[] = OLESTR( "#0 Test CopyTo" );
            aocStorageName[1] = (OLECHAR) iteration + OLESTR('0');

            test_CopyTo( _pstgTemp, _pstgTempCopyTo,
                         iteration & 2 ? STGM_TRANSACTED : STGM_DIRECT,  // For the base Storage
                         iteration & 1 ? STGM_TRANSACTED : STGM_DIRECT,  // For the PropSet Storages
                         aocStorageName );
            }
        }

            #endif  // #ifndef _MAC_NODOC


            // Generate the stock ticker property set example
            // from the OLE programmer's reference spec.
            test_OLESpecTickerExample( _pstgTemp );

            // Test Office Property Sets

            ocscpy(ocsTestOffice, ocsDir);
            ocscat(ocsTestOffice, OLESTR("Office"));
            test_Office( ocsTestOffice );
            test_Office2( _pstgTemp );

            // Verify parameter validation
            test_ParameterValidation( _pstgTemp );

            // Test PropVariantCopy
            test_PropVariantCopy();

            if( PROPIMP_NTFS != g_enumImplementation )
            {
                // Verify PropVariant validation
                test_PropVariantValidation( _pstgTemp );
            }

            if( !g_fVerbose )
                printf( "\n" );

            --g_nIndent;
            PRINTF( "Standard tests PASSED\n" );

        }   // if( ulTestOptions & TEST_STANDARD )

        //  --------------
        //  Extended Tests
        //  --------------

        if( ulTestOptions & ~TEST_STANDARD )
        {
            PRINTF( "\nExtended Tests: " );
            g_nIndent++;

            if( g_fVerbose )
                PRINTF( "\n---------------\n" );

            // Check the CoFileTimeNow fix.
            if( ulTestOptions & TEST_COFILETIMENOW )
                test_CoFileTimeNow();


            // Test for compatibility with Word 6.0 files.
            if( ulTestOptions & TEST_WORD6 )
                test_Word6(_pstgTemp, szDir);

            if( ulTestOptions & TEST_SIMPLE_LEAKS )
                test_SimpleLeaks( ocsDir );

            // Get some performance numbers.
            if ( ulTestOptions & TEST_PERFORMANCE )
                test_Performance( _pstgTemp );

            // Test marshaling.
#ifndef _MAC    // No property marshaling support on the Mac.

            if( ulTestOptions & TEST_MARSHALING )
            {
                PRINTF( "   Marshaling Test\n" );

                ocscpy(ocsMarshalingTest, ocsDir);
                ocscat(ocsMarshalingTest, OLESTR("Marshal"));

                Check(S_OK, g_cpsmt.Init( ocsMarshalingTest,
                                          (PROPVARIANT*) g_rgcpropvarAll,
                                          (PROPSPEC*) g_rgcpropspecAll,
                                          CPROPERTIES_ALL,
                                          CPROPERTIES_ALL_SIMPLE ));
                Check(S_OK, g_cpsmt.Run());

            }
#endif

            if( !g_fVerbose )
                PRINTF( "\n" );

            --g_nIndent;
            PRINTF( "Extended tests PASSED\n" );

        }   // if( ulTestOptions )
    }   // try

    catch( CHResult chr )
    {
    }
//Exit:
    // Clean up and exit.

    if( _pstgTemp != NULL )
        _pstgTemp->Release();

    if( _pstgTempCopyTo != NULL )
        _pstgTempCopyTo->Release();

    g_pfnFreePropVariantArray( CPROPERTIES_ALL, g_rgcpropvarAll );

    // Free the propspec array too.  It will free itself in its
    // destructor anyway, but by then it will be too late to
    // call CoTaskMemFree (since CoUninit will have been called
    // by then).
    {
        for( int i = 0; i < CPROPERTIES_ALL; i++ )
            g_rgcpropspecAll[i].FreeResources();
    }

    CoUninitialize();

#ifdef _MAC
    UninitOleManager();

    #if DBG
        FnAssertOn( FALSE );
    #endif

#endif

    if( g_hinstDLL ) FreeLibrary( g_hinstDLL );
    CoFreeUnusedLibraries();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\stg\props\utest\testcase.cxx ===
//+============================================================================
//
//  File:   TestCase.cxx
//
//  Description:
//          This file provides all of the actual test-cases for the
//          PropTest DRT.  Each test is a function, with a "test_"
//          prefix.
//
//+============================================================================

#include "pch.cxx"
#include <ddeml.h>      // For CP_WINUNICODE
#include "propstm.hxx"
#include "propstg.hxx"
#include "stgint.h"


EXTERN_C const IID
IID_IStorageTest = { /* 40621cf8-a17f-11d1-b28d-00c04fb9386d */
    0x40621cf8,
    0xa17f,
    0x11d1,
    {0xb2, 0x8d, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
  };

// Helper routine
inline ULONG
GetRefCount( IUnknown *punk )
{
    punk->AddRef();
    return( punk->Release() );
}

//+---------------------------------------------------------------
//
//  Function:   test_WriteReadAllProperties
//
//  Synopsis:   This test simply creates two new property
//              sets in a new file (one Ansi and one Unicode),
//              writes all the properties in g_rgcpropvarAll,
//              reads them back, and verifies that it reads what
//              it wrote.
//
//  Inputs:     [LPOLESTR] ocsDir (in)
//                  The directory in which a file can be created.
//
//  Outputs:    None.
//
//+---------------------------------------------------------------

void
test_WriteReadAllProperties( LPOLESTR ocsDir )
{
    OLECHAR ocsFile[ MAX_PATH ];
    FMTID fmtidAnsi, fmtidUnicode;
    UINT ExpectedCodePage;

    IStorage *pstg = NULL, *psubstg = NULL;
    IStream *pstm = NULL;
    IPropertySetStorage *ppropsetstg = NULL;
    IPropertyStorage *ppropstgAnsi = NULL, *ppropstgUnicode = NULL;

    CPropVariant rgcpropvar[ CPROPERTIES_ALL ];
    CPropVariant rgcpropvarAnsi[ CPROPERTIES_ALL ];
    CPropVariant rgcpropvarUnicode[ CPROPERTIES_ALL ];
    CPropVariant rgcpropvarBag[ CPROPERTIES_ALL ];
    CPropVariant rgcpropvarDefault[ 2 ];
    CPropSpec rgcpropspecDefault[ 2 ];

    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    IPropertyBagEx *pbag = NULL;

    ULONG ulIndex;

    ULONG cPropertiesAll = CPROPERTIES_ALL;


    Status( "Simple Write/Read Test\n" );

    //  ----------
    //  Initialize
    //  ----------

    // Generate FMTIDs.

    UuidCreate( &fmtidAnsi );
    UuidCreate( &fmtidUnicode );

    // Generate a filename from the directory name.

    ocscpy( ocsFile, ocsDir );
    ocscat( ocsFile, OLESTR( "AllProps.stg" ));

    //  ----------------
    //  Create a docfile
    //  ----------------

    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
    {
        CFlatStorage *pcFlatStorage = new CFlatStorage();
        Check( TRUE, pcFlatStorage != NULL );
        Check( S_OK, pcFlatStorage->Create( ocsFile ));
        pstg = (IStorage*) pcFlatStorage;

    }
    else
    {
        Check( S_OK, g_pfnStgCreateStorageEx( ocsFile,
                                        STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        DetermineStgFmt( g_enumImplementation ),
                                        0L,
                                        NULL,
                                        NULL,
                                        IID_IStorage, //DetermineStgIID( g_enumImplementation ),
                                        (void**) &pstg )); //(void**) &ppropsetstg ));
    }
    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, (void**) &ppropsetstg ));

    // Create the Property Storages

    Check( S_OK, ppropsetstg->Create( fmtidAnsi,
                                      &CLSID_NULL,
                                      ( (g_Restrictions & RESTRICT_UNICODE_ONLY) ? PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI )
                                      |
                                      ( (g_Restrictions & RESTRICT_SIMPLE_ONLY) ? PROPSETFLAG_DEFAULT: PROPSETFLAG_NONSIMPLE ),
                                      STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &ppropstgAnsi ));

    Check( S_OK, ppropsetstg->Create( fmtidUnicode,
                                      &CLSID_NULL,
                                      (g_Restrictions & RESTRICT_SIMPLE_ONLY) ? PROPSETFLAG_DEFAULT: PROPSETFLAG_NONSIMPLE,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      &ppropstgUnicode ));


    // Get a property bag.  This is also a convenient place to test that we can QI between
    // the storage and bag.

    // The CFlatStorage implementation doesn't support bags yet

    if( STGFMT_FILE != DetermineStgFmt( g_enumImplementation ))
    {
        IStorage *pstg2 = NULL;
        IPropertyBagEx *pbag2 = NULL;
        IUnknown *punk1 = NULL;
        IUnknown *punk2 = NULL;

        Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
        Check( S_OK, pbag->QueryInterface( DetermineStgIID( g_enumImplementation ), reinterpret_cast<void**>(&pstg2) ));
        Check( S_OK, pstg2->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag2) ));
        Check( TRUE, pbag == pbag2 && pstg == pstg2 );

        RELEASE_INTERFACE(pbag2);
        RELEASE_INTERFACE(pstg2);

        Check( S_OK, pstg->QueryInterface( IID_IUnknown, reinterpret_cast<void**>(&punk1) ));
        Check( S_OK, pbag->QueryInterface( IID_IUnknown, reinterpret_cast<void**>(&punk2) ));
        Check( TRUE, punk1 == punk2 );
        RELEASE_INTERFACE(punk1);
        RELEASE_INTERFACE(punk2);
    }

    // Write some simple properties

    Check( S_OK, ppropstgAnsi->WriteMultiple( CPROPERTIES_ALL_SIMPLE,
                                              g_rgcpropspecAll,
                                              g_rgcpropvarAll,
                                              PID_FIRST_USABLE ));

    // Verify the format version is 0
    CheckFormatVersion(ppropstgAnsi, 0);


    // Write to all property sets.

    Check( S_OK, ppropstgAnsi->WriteMultiple( cPropertiesAll,
                                              g_rgcpropspecAll,
                                              g_rgcpropvarAll,
                                              PID_FIRST_USABLE ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    // Verify that the format is now version 1, since we wrote a VersionedStream property
    CheckFormatVersion(ppropstgAnsi, 1);

    Check( S_OK, ppropstgUnicode->WriteMultiple( cPropertiesAll,
                                                 g_rgcpropspecAll,
                                                 g_rgcpropvarAll,
                                                 PID_FIRST_USABLE ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    if( NULL != pbag )
    {
        Check( S_OK, pbag->WriteMultiple( cPropertiesAll,
                                        g_rgoszpropnameAll,
                                        g_rgcpropvarAll ));
        Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));
    }


    // Close and re-open everything

    RELEASE_INTERFACE(ppropstgAnsi);
    RELEASE_INTERFACE(ppropstgUnicode);
    RELEASE_INTERFACE(pstg);
    RELEASE_INTERFACE(ppropsetstg);

    Check( 0, RELEASE_INTERFACE(pbag) ); //pbag->Release() );

    if( STGFMT_FILE == DetermineStgFmt( g_enumImplementation ) )
    {
        CFlatStorage *pcFlatStorage = new CFlatStorage();
        Check( TRUE, pcFlatStorage != NULL );
        Check( S_OK, pcFlatStorage->Open( ocsFile ));
        pstg = (IStorage*) pcFlatStorage;

    }
    else
    {
        Check( S_OK, g_pfnStgOpenStorageEx( ocsFile,
                                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                        DetermineStgFmt( g_enumImplementation ),
                                        0L,
                                        NULL,
                                        NULL,
                                        DetermineStgIID( g_enumImplementation ),
                                        (void**) &pstg )); //(void**) &ppropsetstg ));
    }
    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, (void**) &ppropsetstg ));

    // Create the Property Storages

    Check( S_OK, ppropsetstg->Open( fmtidAnsi,
                                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    &ppropstgAnsi ));

    Check( S_OK, ppropsetstg->Open( fmtidUnicode,
                                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    &ppropstgUnicode ));

    if( STGFMT_FILE != DetermineStgFmt( g_enumImplementation ) )
    {
        Check( S_OK, pstg->QueryInterface( IID_IPropertyBagEx, reinterpret_cast<void**>(&pbag) ));
    }

    // Read and verify the auto-generated properties.

    rgcpropspecDefault[0] = static_cast<PROPID>(PID_CODEPAGE);
    rgcpropspecDefault[1] = static_cast<PROPID>(PID_LOCALE);

    Check( S_OK, ppropstgAnsi->ReadMultiple( 2, rgcpropspecDefault, rgcpropvarDefault ));

    ExpectedCodePage = (g_Restrictions & RESTRICT_UNICODE_ONLY) ? CP_WINUNICODE : GetACP();
    Check( TRUE, VT_I2  == rgcpropvarDefault[0].vt );
    Check( TRUE, ExpectedCodePage == (UINT) rgcpropvarDefault[0].iVal );
    Check( TRUE, VT_UI4 == rgcpropvarDefault[1].vt );
    Check( TRUE, GetUserDefaultLCID() == rgcpropvarDefault[1].ulVal );

    Check( S_OK, ppropstgUnicode->ReadMultiple( 2, rgcpropspecDefault, rgcpropvarDefault ));

    ExpectedCodePage = CP_WINUNICODE;
    Check( TRUE, VT_I2  == rgcpropvarDefault[0].vt );
    Check( TRUE, ExpectedCodePage == (UINT) rgcpropvarDefault[0].iVal );
    Check( TRUE, VT_UI4 == rgcpropvarDefault[1].vt );
    Check( TRUE, GetUserDefaultLCID() == rgcpropvarDefault[1].ulVal );

    // Read from all property sets

    Check( S_OK, ppropstgAnsi->ReadMultiple( cPropertiesAll,
                                             g_rgcpropspecAll,
                                             rgcpropvarAnsi ));

    Check( S_OK, ppropstgUnicode->ReadMultiple( cPropertiesAll,
                                                g_rgcpropspecAll,
                                                rgcpropvarUnicode ));

    if( NULL != pbag )
    {
        Check( S_OK, pbag->ReadMultiple( cPropertiesAll, g_rgoszpropnameAll, rgcpropvarBag, NULL ));
    }

    // Compare the properties

    for( int i = 0; i < (int)cPropertiesAll; i++ )
    {
        Check( TRUE, rgcpropvarAnsi[i]    == g_rgcpropvarAll[i] );
        Check( TRUE, rgcpropvarUnicode[i] == g_rgcpropvarAll[i] );
        if( NULL != pbag )
            Check( TRUE, rgcpropvarBag[i] == g_rgcpropvarAll[i] );
    }

    // Show that we can delete everything

    Check( S_OK, ppropstgAnsi->DeleteMultiple( cPropertiesAll, g_rgcpropspecAll ));
    Check( S_OK, ppropstgUnicode->DeleteMultiple( cPropertiesAll, g_rgcpropspecAll ));
    if( NULL != pbag )
        Check( S_OK, pbag->DeleteMultiple( cPropertiesAll, g_rgoszpropnameAll, 0 ));

    // Re-write the properties, because it's convenient for debug sometimes
    // to have a file around with lots of properties in it.

    Check( S_OK, ppropstgAnsi->WriteMultiple( cPropertiesAll,
                                              g_rgcpropspecAll,
                                              g_rgcpropvarAll,
                                              PID_FIRST_USABLE ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    Check( S_OK, ppropstgUnicode->WriteMultiple( cPropertiesAll,
                                                 g_rgcpropspecAll,
                                                 g_rgcpropvarAll,
                                                 PID_FIRST_USABLE ));
    Check( S_OK, ResetRGPropVar( g_rgcpropvarAll ));

    RELEASE_INTERFACE(pstg);
    RELEASE_INTERFACE(ppropsetstg);
    RELEASE_INTERFACE(ppropstgAnsi);
    RELEASE_INTERFACE(ppropstgUnicode);

    Check( 0, RELEASE_INTERFACE(pbag) ); //pbag->Release() );

}   // test_WriteReadProperties



BOOL

StgConvertPropertyToVariantWrapper(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma,
    OUT NTSTATUS *pstatus )
{
    BOOL boolRet = FALSE;
    *pstatus = STATUS_SUCCESS;

    __try
    {
        boolRet = g_pfnStgConvertPropertyToVariant( pprop, CodePage, pvar, pma );
//        boolRet = RtlConvertPropertyToVariant( pprop, CodePage, pvar, pma );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        *pstatus = GetExceptionCode();
    }

    return( boolRet );
}



ULONG
StgPropertyLengthAsVariantWrapper( SERIALIZEDPROPERTYVALUE *pprop, ULONG cbprop, USHORT CodePage, BYTE flags,
                                   NTSTATUS *pstatus )
{
    ULONG cbRet = 0;
    *pstatus = STATUS_SUCCESS;

    __try
    {
        cbRet = g_pfnStgPropertyLengthAsVariant( pprop, cbprop, CodePage, 0 );
//        cbRet = PropertyLengthAsVariant( pprop, cbprop, CodePage, 0 );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        *pstatus = GetExceptionCode();
    }

    return( cbRet );
}


SERIALIZEDPROPERTYVALUE *
StgConvertVariantToPropertyWrapper(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVector,
    OPTIONAL OUT ULONG *pcIndirect,
    OUT NTSTATUS *pstatus )
{
    SERIALIZEDPROPERTYVALUE * ppropRet = NULL;
    *pstatus = STATUS_SUCCESS;

    __try
    {
        ppropRet = g_pfnStgConvertVariantToProperty( pvar, CodePage, pprop, pcb, pid, fVector, pcIndirect );
//        ppropRet = RtlConvertVariantToProperty( pvar, CodePage, pprop, pcb, pid, fVariantVectorOrArray, pcIndirect );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        *pstatus = GetExceptionCode();
    }

    return( ppropRet );

}


void
test_PidIllegal( IStorage *pstg )
{
    IPropertySetStorage *ppropsetstg = NULL;
    IPropertyStorage *ppropstg = NULL;
    ULONG cRefsOriginal = GetRefCount(pstg);
    CPropVariant rgcpropvarWrite[3], rgcpropvarRead[3];
    CPropSpec    rgcpropspec[3];
    PROPID       rgpropid[3];
    LPOLESTR     rgoszNames[3] = { NULL, NULL, NULL };

    // Get an IPropertyStorage

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&ppropsetstg) ));
    Check( S_OK, ppropsetstg->Create( FMTID_NULL, NULL, PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                      &ppropstg ));

    // Write a PID_ILLEGAL property.  Since it's ignored, nothing should be written.

    rgcpropvarWrite[0] = (long) 1234;
    rgcpropspec[0] = PID_ILLEGAL;
    Check( S_OK, ppropstg->WriteMultiple( 1, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
    Check( S_FALSE, ppropstg->ReadMultiple( 1, rgcpropspec, rgcpropvarRead ));

    // Write several normal properties
    SHORT sOriginal = 1234;
    LPOLESTR oszOriginalName = OLESTR("Second");

    rgcpropvarWrite[0] = (long) 5678;
    rgcpropvarWrite[1] = sOriginal;
    rgcpropvarWrite[2] = (float) 23.5;

    rgcpropspec[0] = OLESTR("First");
    rgcpropspec[1] = oszOriginalName;
    rgcpropspec[2] = OLESTR("Third");

    Check( S_OK, ppropstg->WriteMultiple( 3, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, ppropstg->ReadMultiple( 3, rgcpropspec, rgcpropvarRead ));
    Check( TRUE, rgcpropvarWrite[0] == rgcpropvarRead[0] );
    Check( TRUE, rgcpropvarWrite[1] == rgcpropvarRead[1] );
    Check( TRUE, rgcpropvarWrite[2] == rgcpropvarRead[2] );

    // Re-write the properties except for one.  The value of that property shouldn't change,
    // nor should its name.

    rgcpropvarWrite[0] = (short) 1234;
    rgcpropvarWrite[1] = (long) 5678;
    rgcpropvarWrite[2] = (double) 12.4;

    rgcpropspec[1] = PID_ILLEGAL;

    Check( S_OK, ppropstg->WriteMultiple( 3, rgcpropspec, rgcpropvarWrite, PID_FIRST_USABLE ));
    rgcpropspec[1] = oszOriginalName;
    Check( S_OK, ppropstg->ReadMultiple( 3, rgcpropspec, rgcpropvarRead ));
    Check( TRUE, rgcpropvarWrite[0]      == rgcpropvarRead[0] );
    Check( TRUE, CPropVariant(sOriginal) == rgcpropvarRead[1] );
    Check( TRUE, rgcpropvarWrite[2]      == rgcpropvarRead[2] );

    rgpropid[0] = PID_FIRST_USABLE;
    rgpropid[1] = PID_FIRST_USABLE + 1;
    rgpropid[2] = PID_FIRST_USABLE + 2;

    Check( S_OK, ppropstg->ReadPropertyNames( 3, rgpropid, rgoszNames ));
    Check( 0, wcscmp( rgcpropspec[0].lpwstr, rgoszNames[0] ));
    Check( 0, wcscmp( oszOriginalName, rgoszNames[1] ));
    Check( 0, wcscmp( rgcpropspec[2].lpwstr, rgoszNames[2] ));

    for( int i = 0; i < 3; i++ )
    {
        CoTaskMemFree( rgoszNames[i] );
        rgoszNames[i] = NULL;
    }

    // Re-write the names, again skipping one of them.

    rgoszNames[0] = OLESTR("Updated first");
    rgoszNames[1] = OLESTR("Updated second");
    rgoszNames[2] = OLESTR("Updated third");

    rgpropid[1] = PID_ILLEGAL;

    Check( S_OK, ppropstg->WritePropertyNames( 3, rgpropid, rgoszNames ));
    rgoszNames[0] = rgoszNames[1] = rgoszNames[2] = NULL;

    rgpropid[1] = PID_FIRST_USABLE + 1;
    Check( S_OK, ppropstg->ReadPropertyNames( 3, rgpropid, rgoszNames ));

    Check( 0, wcscmp( rgoszNames[0], OLESTR("Updated first") ));
    Check( 0, wcscmp( rgoszNames[1], oszOriginalName ));
    Check( 0, wcscmp( rgoszNames[2], OLESTR("Updated third") ));

    // Re-write just the one name, but skipping it.

    rgpropid[1] = PID_ILLEGAL;
    CoTaskMemFree( rgoszNames[1] );
    rgoszNames[1] = OLESTR("Write just the second");
    Check( S_OK, ppropstg->WritePropertyNames( 1, &rgpropid[1], &rgoszNames[1] ));

    rgoszNames[1] = NULL;
    rgpropid[1] = PID_FIRST_USABLE + 1;
    Check( S_OK, ppropstg->ReadPropertyNames( 1, &rgpropid[1], &rgoszNames[1] ));

    Check( 0, wcscmp( rgoszNames[1], oszOriginalName ));


    // Exit

    for( i = 0; i < 3; i++ )
        CoTaskMemFree( rgoszNames[i] );

    Check( 0, RELEASE_INTERFACE(ppropstg) );
    Check( cRefsOriginal, RELEASE_INTERFACE(ppropsetstg) );
}



void
test_PropertyLengthAsVariant( )
{
    Status( "StgPropertyLengthAsVariant, StgConvert*\n" );

    ULONG i = 0;
    BYTE *rgb = new BYTE[ 8192 ];
    Check( TRUE, NULL != rgb );

    CPropVariant rgcpropvar[ 7 ];
    ULONG rgcbExpected[ 7 ];

    CPropVariant *rgcpropvarSafeArray = NULL;
    SAFEARRAY *rgpsa[3];
    SAFEARRAYBOUND rgsaBounds[] = { {2,0}, {3,10}, {4,20} };  // [0..1], [10..12], [20..23]
    ULONG cDims = sizeof(rgsaBounds)/sizeof(rgsaBounds[0]);
    ULONG cElems = 0;

    rgcpropvar[i] = (long) 1234;    // VT_I4
    rgcbExpected[i] = 0;
    i++;

    rgcpropvar[i].SetBSTR( OLESTR("Hello, world") );    // Creates a copy
    rgcbExpected[i] = sizeof(OLESTR("Hello, world")) + sizeof(ULONG);
    i++;

    rgcpropvar[i][2] = (short) 2;    // VT_VECTOR | VT_I2
    rgcpropvar[i][1] = (short) 1;
    rgcpropvar[i][0] = (short) 0;
    rgcbExpected[i] = 3 * sizeof(short);
    i++;

    rgcpropvar[i][1] = (PROPVARIANT) CPropVariant( (unsigned long) 4 );       // VT_VECTOR | VT_VARIANT
    rgcpropvar[i][0] = (PROPVARIANT) CPropVariant( (BSTR) OLESTR("Hi there") );
    rgcbExpected[i] = 2 * sizeof(PROPVARIANT) + sizeof(OLESTR("Hi there")) + sizeof(ULONG);
    i++;


    rgpsa[0] = SafeArrayCreateEx( VT_I4, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[0] );
    cElems = CalcSafeArrayElementCount( rgpsa[0] );
    rgcbExpected[i+0] = sizeof(SAFEARRAY) - sizeof(SAFEARRAYBOUND)
                        + 3 * sizeof(SAFEARRAYBOUND)
                        + cElems * sizeof(LONG);

    rgpsa[1] = SafeArrayCreateEx( VT_BSTR, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[1] );
    rgcbExpected[i+1] = sizeof(SAFEARRAY) - sizeof(SAFEARRAYBOUND)
                        + 3 * sizeof(SAFEARRAYBOUND)
                        + cElems * sizeof(BSTR);

    rgpsa[2] = SafeArrayCreateEx( VT_VARIANT, 3, rgsaBounds, NULL );
    Check( TRUE, NULL != rgpsa[2] );
    rgcbExpected[i+2] = sizeof(SAFEARRAY) - sizeof(SAFEARRAYBOUND)
                        + 3 * sizeof(SAFEARRAYBOUND)
                        + cElems * sizeof(PROPVARIANT);

    rgcpropvarSafeArray = new CPropVariant[ cElems ];
    Check( FALSE, NULL == rgcpropvar );

    for( ULONG j = 0; j < cElems; j++ )
    {
        LONG rgIndices[3];
        CalcSafeArrayIndices( j, rgIndices, rgsaBounds, cDims );

        LONG lVal = static_cast<LONG>(j);
        Check( S_OK, SafeArrayPutElement( rgpsa[0], rgIndices, &lVal ));

        BSTR bstrVal = SysAllocString( OLESTR("0 BSTR Val") );
        *bstrVal = OLESTR('0') + static_cast<OLECHAR>(j);
        Check( S_OK, SafeArrayPutElement( rgpsa[1], rgIndices, bstrVal ));
        rgcbExpected[i+1] += ocslen(bstrVal) + sizeof(OLECHAR) + sizeof(ULONG);

        if( j & 1 )
            rgcpropvarSafeArray[j] = (long) j;
        else
        {
            rgcpropvarSafeArray[j].SetBSTR( bstrVal );
            rgcbExpected[i+2] += ocslen(bstrVal)*sizeof(OLECHAR) + sizeof(OLECHAR) + sizeof(ULONG);
        }
        Check( S_OK, SafeArrayPutElement( rgpsa[2], rgIndices, &rgcpropvarSafeArray[j] ));
        SysFreeString( bstrVal );
    }

    rgcpropvar[i].vt = VT_ARRAY | VT_I4;
    reinterpret_cast<VARIANT*>(&rgcpropvar[i])->parray = rgpsa[0];
    i++;

    rgcpropvar[i].vt = VT_ARRAY | VT_BSTR;
    reinterpret_cast<VARIANT*>(&rgcpropvar[i])->parray = rgpsa[1];
    i++;

    rgcpropvar[i].vt = VT_ARRAY | VT_VARIANT;
    reinterpret_cast<VARIANT*>(&rgcpropvar[i])->parray = rgpsa[2];
    i++;

    Check( sizeof(rgcpropvar)/sizeof(rgcpropvar[0]), i );

    for( i = 0; i < sizeof(rgcpropvar)/sizeof(rgcpropvar[0]); i++ )
    {
        PropTestMemoryAllocator ma;
        SERIALIZEDPROPERTYVALUE *pprop = NULL;
        CPropVariant cpropvarOut;
        ULONG cbWritten = 8192, cbAsVariant = 0;
        NTSTATUS status;
        ULONG cIndirect;

        pprop = StgConvertVariantToPropertyWrapper(
                        &rgcpropvar[i], CP_WINUNICODE,
                        reinterpret_cast<SERIALIZEDPROPERTYVALUE*>(rgb),
                        &cbWritten, PID_FIRST_USABLE,
                        FALSE,
                        &cIndirect,
                        &status );
        Check( TRUE, NT_SUCCESS(status) );
        Check( TRUE, NULL != pprop );

        cbAsVariant = StgPropertyLengthAsVariantWrapper(
                                reinterpret_cast<SERIALIZEDPROPERTYVALUE*>(rgb),
                                cbWritten, CP_WINUNICODE, 0, &status );
        Check( TRUE, NT_SUCCESS(status) );

        // Check that the cbAsVariant is at least big enough.  Also sanity check that
        // it's not huge.  We use a fudge multiple of 3 for this because the
        // StgPropertyLengthAsVariant can way overestimate (primarily because it
        // doesn't know if BSTRs will need conversion).

        Check( TRUE, cbAsVariant >= rgcbExpected[i] );
        Check( TRUE, cbAsVariant <= rgcbExpected[i]*3 );

        // Check that we can convert back to a PropVariant
        // (False because it's not an indirect property we're converting)

        Check( FALSE, StgConvertPropertyToVariantWrapper( reinterpret_cast<SERIALIZEDPROPERTYVALUE*>(rgb),
                                                         CP_WINUNICODE, &cpropvarOut,
                                                         &ma, &status ));
        Check( TRUE, NT_SUCCESS(status) );

        Check( TRUE, cpropvarOut == rgcpropvar[i] );

    }

    g_pfnFreePropVariantArray( cElems, rgcpropvarSafeArray );
    delete[] rgcpropvarSafeArray;
    g_pfnFreePropVariantArray( sizeof(rgcpropvar)/sizeof(rgcpropvar[0]), rgcpropvar );

    delete[] rgb;
}




void
test_LargePropertySet( IStorage *pstg )
{
    FMTID fmtid;
    IPropertySetStorage *pPropSetStg = NULL;
    IPropertyStorage *pPropStg = NULL;
    STATPROPSETSTG statpropsetstg;

    CPropSpec cpropspec;
    PROPVARIANT propvar;

    Status( "Large property sets\n" );

    Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, reinterpret_cast<void**>(&pPropSetStg) ));

    // Create a new property set.
    
    UuidCreate( &fmtid );
    Check( S_OK, pPropSetStg->Create( fmtid, NULL,
                                      PROPSETFLAG_DEFAULT,
                                      STGM_CREATE|STGM_SHARE_EXCLUSIVE|STGM_READWRITE,
                                      &pPropStg ));

    // Create a big property to write.  Make it just about the max, 1M
    // (it's hard to make it exactly the right size, because it depends on the
    // size of the propset header, overallocs, etc.).

    propvar.vt = VT_BLOB;    
    
    propvar.blob.cbSize = 1023 * 1024;
    propvar.blob.pBlobData = new BYTE[ propvar.blob.cbSize ];
    Check( FALSE, NULL == propvar.blob.pBlobData );

    cpropspec = O