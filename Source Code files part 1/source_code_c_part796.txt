 the signature.

                            CHAR PdbName[_MAX_PATH + 1];
                            CHAR NewPdbName[_MAX_PATH + 1];
                            CHAR Drive[_MAX_DRIVE + 1];
                            CHAR Dir[_MAX_DIR + 1];
                            CHAR Filename[_MAX_FNAME + 1];
                            CHAR FileExt[_MAX_EXT + 1];
                            BOOL rc;

                            memset(PdbName, 0, sizeof(PdbName));
                            memcpy(PdbName, ((PCHAR)pDebugCV)+ sizeof(NB10IH), DebugDirectory->SizeOfData - sizeof(NB10IH));

                            _splitpath(PdbName, NULL, NULL, Filename, FileExt);
                            _splitpath(SymbolFilePath, Drive, Dir, NULL, NULL);
                            _makepath(NewPdbName, Drive, Dir, Filename, FileExt);
#if defined(use_SplitSymbolsX)
                            rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, NULL);
                            if (rc) {
                                StringCchCopy(CreatedPdb, SizeOfPdbBuffer, NewPdbName);
                            }
#else
                            rc = CopyPdb(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE);
#endif

                            if (!rc) {
                                if (Flags & SPLITSYM_SYMBOLPATH_IS_SRC) {
                                    // Try the AltPdbPath.
                                    if ( S_OK != (hrRetCode = StringCbCopy(PdbName, sizeof(PdbName), AltPdbPath)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                    if ( S_OK != (hrRetCode = StringCbCat( PdbName, sizeof(PdbName), Filename)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                    if ( S_OK != (hrRetCode = StringCbCat( PdbName, sizeof(PdbName), FileExt)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }

#if defined(use_SplitSymbolsX)
                                    rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, NULL);
                                    if (rc) {
                                        StringCchCopy(CreatedPdb, SizeOfPdbBuffer, NewPdbName);
                                    }
#else
                                    rc = CopyPdb(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE);
#endif
                                }

                                if ( !rc) {
                                    // It's possible the name in the pdb isn't in the same location as it was when built.  See if we can
                                    //  find it in the same dir as the image...
                                    _splitpath(ImageName, Drive, Dir, NULL, NULL);
                                    _makepath(PdbName, Drive, Dir, Filename, FileExt);
#if defined(use_SplitSymbolsX)
                                    rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, NULL);
                                    if (rc) {
                                        StringCchCopy(CreatedPdb, SizeOfPdbBuffer, NewPdbName);
                                    }
#else
                                    rc = CopyPdb(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE);
#endif
                                }
                            }

                            if (rc) {
                                SetFileAttributes(NewPdbName, FILE_ATTRIBUTE_NORMAL);

                                // Change the data so only the pdb name is in the .dbg file (no path).

                                if (MiscDebugFound) {
                                    NewDebugSize = sizeof(NB10IH) + strlen(Filename) + strlen(FileExt) + 1;
                                    NewDebugData = (PCHAR) SymMalloc( NewDebugSize );

                                    ((PCVDD)NewDebugData)->nb10ih  = pDebugCV->nb10ih;
                                    if ( S_OK != (hrRetCode = StringCbCopy(NewDebugData + sizeof(NB10IH), NewDebugSize-sizeof(NB10IH), Filename)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                    if ( S_OK != (hrRetCode = StringCbCat( NewDebugData + sizeof(NB10IH), NewDebugSize-sizeof(NB10IH), FileExt)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }

                                    DebugDirectory->PointerToRawData = (ULONG) (NewDebugData - (PCHAR)ImageBase);
                                    DebugDirectory->SizeOfData = NewDebugSize;
                                } else {

                                    if ( S_OK != (hrRetCode = StringCbCopy( ((PCHAR)pDebugCV) + sizeof(NB10IH), DebugDirectory->SizeOfData - sizeof(NB10IH), Filename)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                    if ( S_OK != (hrRetCode = StringCbCat( ((PCHAR)pDebugCV)+ sizeof(NB10IH), DebugDirectory->SizeOfData - sizeof(NB10IH), FileExt)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                }
                            } else {
                                // Replace <Path>\<filename>.<ext> with just <filename>.<ext> in the debug data
                                if ( S_OK != (hrRetCode = StringCbCopy(((PCHAR)pDebugCV) + sizeof(NB10IH), DebugDirectory->SizeOfData - sizeof(NB10IH), Filename)) ) {
                                    dwLastError = hrRetCode;
                                    __leave;
                                }
                                if ( S_OK != (hrRetCode = StringCbCat( ((PCHAR)pDebugCV) + sizeof(NB10IH), DebugDirectory->SizeOfData - sizeof(NB10IH), FileExt)) ) {
                                    dwLastError = hrRetCode;
                                    __leave;
                                }
                                DebugDirectory->SizeOfData = sizeof(NB10IH) + strlen(Filename) + strlen(FileExt) + 1;
                            }

#if defined(use_SplitSymbolsX)
                        } else if ( pDebugCV->dwSig == 'SDSR') {
                            // Got a PDB.  The name immediately follows the signature.

                            CHAR PdbName[sizeof(((PRSDSI)(0))->szPdb)];
                            CHAR NewPdbName[_MAX_PATH+1];
                            CHAR Drive[_MAX_DRIVE+1];
                            CHAR Dir[_MAX_DIR+1];
                            CHAR Filename[_MAX_FNAME+1];
                            CHAR FileExt[_MAX_EXT+1];
                            BOOL rc;

                            ZeroMemory(PdbName, sizeof(PdbName));
                            memcpy(PdbName, ((PCHAR)pDebugCV)+ sizeof(RSDSIH), __min(DebugDirectory->SizeOfData - sizeof(RSDSIH), sizeof(PdbName)));

                            _splitpath(PdbName, NULL, NULL, Filename, FileExt);
                            _splitpath(SymbolFilePath, Drive, Dir, NULL, NULL);
                            _makepath(NewPdbName, Drive, Dir, Filename, FileExt);
                            rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, RSDSDllToLoad);
                            if (rc) {
                                StringCchCopy(CreatedPdb, SizeOfPdbBuffer, NewPdbName);
                            }
                            if (!rc) {
                                if (Flags & SPLITSYM_SYMBOLPATH_IS_SRC) {
                                    // Try the AltPdbPath.
                                    if ( S_OK != (hrRetCode = StringCbCopy(PdbName, sizeof(PdbName), AltPdbPath)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                    if ( S_OK != (hrRetCode = StringCbCat( PdbName, sizeof(PdbName), Filename)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                    if ( S_OK != (hrRetCode = StringCbCat( PdbName, sizeof(PdbName), FileExt)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                    rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, RSDSDllToLoad);
                                    if (rc) {
                                        StringCchCopy(CreatedPdb, SizeOfPdbBuffer, NewPdbName);
                                    }
                                }

                                if ( !rc) {
                                    // It's possible the name in the pdb isn't in the same location as it was when built.  See if we can
                                    //  find it in the same dir as the image...
                                    _splitpath(ImageName, Drive, Dir, NULL, NULL);
                                    _makepath(PdbName, Drive, Dir, Filename, FileExt);
                                    rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, RSDSDllToLoad);

                                    if (rc) {
                                        StringCchCopy(CreatedPdb, SizeOfPdbBuffer, NewPdbName);
                                    }
                                }
                            }

                            if (rc) {
                                SetFileAttributes(NewPdbName, FILE_ATTRIBUTE_NORMAL);

                                // Change the data so only the pdb name is in the .dbg file (no path).

                                if (MiscDebugFound) {
                                    NewDebugSize = sizeof(RSDSIH) + strlen(Filename) + strlen(FileExt) + 1;
                                    NewDebugData = (PCHAR) SymMalloc( NewDebugSize );
                                    ((PCVDD)NewDebugData)->rsdsih  = pDebugCV->rsdsih;
                                    if ( S_OK != (hrRetCode = StringCbCopy(NewDebugData + sizeof(RSDSIH), NewDebugSize-sizeof(RSDSIH), Filename)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                    if ( S_OK != (hrRetCode = StringCbCat( NewDebugData + sizeof(RSDSIH), NewDebugSize-sizeof(RSDSIH), FileExt)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }

                                    DebugDirectory->PointerToRawData = (ULONG) (NewDebugData - (PCHAR)ImageBase);
                                    DebugDirectory->SizeOfData = NewDebugSize;
                                } else {
                                    if ( S_OK != (hrRetCode = StringCbCopy(((PCHAR)pDebugCV) + sizeof(RSDSIH), DebugDirectory->SizeOfData - sizeof(RSDSIH), Filename)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                    if ( S_OK != (hrRetCode = StringCbCat( ((PCHAR)pDebugCV) + sizeof(RSDSIH), DebugDirectory->SizeOfData - sizeof(RSDSIH), FileExt)) ) {
                                        dwLastError = hrRetCode;
                                        __leave;
                                    }
                                }
                            } else {
                                // Replace <Path>\<filename>.<ext> with just <filename>.<ext> in the debug data
                                if ( S_OK != (hrRetCode = StringCbCopy(((PCHAR)pDebugCV) + sizeof(RSDSIH), DebugDirectory->SizeOfData - sizeof(RSDSIH), Filename)) ) {
                                    dwLastError = hrRetCode;
                                    __leave;
                                }
                                if ( S_OK != (hrRetCode = StringCbCat( ((PCHAR)pDebugCV) + sizeof(RSDSIH), DebugDirectory->SizeOfData - sizeof(RSDSIH), FileExt)) ) {
                                    dwLastError = hrRetCode;
                                    __leave;
                                }
                                DebugDirectory->SizeOfData = sizeof(RSDSIH) + strlen(Filename) + strlen(FileExt) + 1;
                            }

#endif
                        } else {
                            if (Flags & SPLITSYM_REMOVE_PRIVATE) {
                                if (RemovePrivateCvSymbolicEx(DebugDirectory->PointerToRawData + (PCHAR)ImageBase,
                                                        DebugDirectory->SizeOfData,
                                                        &NewDebugData,
                                                        &NewDebugSize)) {
                                    if (DebugDirectory->PointerToRawData != (ULONG) (NewDebugData - (PCHAR)ImageBase))
                                    {
                                        DebugDirectory->PointerToRawData = (ULONG) (NewDebugData - (PCHAR)ImageBase);
                                        DebugDirectory->SizeOfData = NewDebugSize;
                                    } else {
                                        NewDebugData = NULL;
                                    }
                                }
                            }
                        }
                    }

                    break;

                case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                    if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                        DebugSectionStart = DebugDirectory->PointerToRawData;
                    }

                    // W/o the OMAP, FPO is useless.
                    DiscardFPO = TRUE;
                    break;

                case IMAGE_DEBUG_TYPE_FIXUP:
                    if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                        DebugSectionStart = DebugDirectory->PointerToRawData;
                    }

                    // If all PRIVATE debug is removed, don't send FIXUP along.
                    if (Flags & SPLITSYM_REMOVE_PRIVATE) {
                        DebugDirectory->SizeOfData = 0;
                    }
                    break;

                default:
                    if (DebugDirectory->SizeOfData &&
                       (DebugDirectory->PointerToRawData < DebugSectionStart))
                    {
                        DebugSectionStart = DebugDirectory->PointerToRawData;
                    }

                    // Nothing else to special case...
                    break;
            }

            SizeOfSymbols += (DebugDirectory->SizeOfData + 3) & ~3; // Minimally align it all.
        }

        if (!MiscDebugFound) {
            NewFileSize = GetFileSize(FileHandle, NULL);

            CheckSumMappedFile( ImageBase,
                                NewFileSize,
                                &HeaderSum,
                                &CheckSum
                              );
            OptionalHeader->CheckSum = CheckSum;

            goto nomisc;
        }

        if (DiscardFPO) {
            pFpoDebugDirectory = NULL;
        }

        if (pFpoDebugDirectory) {
            // If FPO stays here, make a copy so we don't need to worry about stomping on it.

            FpoTableSize = pFpoDebugDirectory->SizeOfData;
            FpoTable = (PFPO_DATA) SymMalloc( FpoTableSize );

            if ( FpoTable == NULL ) {
                goto nosyms;
            }

            RtlMoveMemory( FpoTable,
                           (PCHAR) ImageBase + pFpoDebugDirectory->PointerToRawData,
                           FpoTableSize );
        }

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
            ImageDirectoryEntryToData( ImageBase,
                                       FALSE,
                                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                                       &ExportDirectorySize
                                     );
        if (ExportDirectory) {
            //
            // This particular piece of magic gets us the RVA of the
            // EXPORT section.  Dont ask.
            //

            RvaOffset = (ULONG_PTR)
                ImageDirectoryEntryToData( ImageBase,
                                           TRUE,
                                           IMAGE_DIRECTORY_ENTRY_EXPORT,
                                           &ExportDirectorySize
                                         ) - (ULONG_PTR)ImageBase;

            pp = (LPDWORD)((ULONG_PTR)ExportDirectory +
                          (ULONG_PTR)ExportDirectory->AddressOfNames - RvaOffset
                         );

            ExportedNamesSize = 1;
            for (i=0; i<ExportDirectory->NumberOfNames; i++) {
                Src = (LPSTR)((ULONG_PTR)ExportDirectory + *pp++ - RvaOffset);
                ExportedNamesSize += strlen( Src ) + 1;
            }
            ExportedNamesSize = (ExportedNamesSize + 16) & ~15;

            Dst = (LPSTR) SymMalloc( ExportedNamesSize );

            if (Dst != NULL) {
                ExportedNames = Dst;
                pp = (LPDWORD)((ULONG_PTR)ExportDirectory +
                              (ULONG_PTR)ExportDirectory->AddressOfNames - RvaOffset
                             );
                for (i=0; i<ExportDirectory->NumberOfNames; i++) {
                    Src = (LPSTR)((ULONG_PTR)ExportDirectory + *pp++ - RvaOffset);
                    while (*Dst++ = *Src++) {
                        ;
                    }
                }
            }
        } else {
            ExportedNamesSize = 0;
        }

        RuntimeFunctionTable = (PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)
            ImageDirectoryEntryToData( ImageBase,
                                       FALSE,
                                       IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                       &RuntimeFunctionTableSize
                                     );
        if (RuntimeFunctionTable == NULL) {
            RuntimeFunctionTableSize = 0;
            FunctionTableSize = 0;
            FunctionTable = NULL;
            }
        else {
            NumberOfFunctionTableEntries = RuntimeFunctionTableSize / sizeof( IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY );
            FunctionTableSize = NumberOfFunctionTableEntries * sizeof( IMAGE_FUNCTION_ENTRY );
            FunctionTable = (PIMAGE_FUNCTION_ENTRY) SymMalloc( FunctionTableSize );
            if (FunctionTable == NULL) {
                goto nosyms;
                }

            pSrc = RuntimeFunctionTable;
            pDst = FunctionTable;
            for (i=0; i<NumberOfFunctionTableEntries; i++) {
                //
                // Make .pdata entries in .DBG file relative.
                //
                pDst->StartingAddress = CLEAN_PD(pSrc->BeginAddress) - OptionalHeader->ImageBase;
                pDst->EndingAddress = CLEAN_PD(pSrc->EndAddress) - OptionalHeader->ImageBase;
                pDst->EndOfPrologue = CLEAN_PD(pSrc->PrologEndAddress) - OptionalHeader->ImageBase;
                pSrc += 1;
                pDst += 1;
                }
            }

        DbgFileHeaderSize = sizeof( DbgFileHeader ) +
                            ((FileHeader->NumberOfSections - (DebugSection ? 1 : 0)) *
                             sizeof( IMAGE_SECTION_HEADER )) +
                            ExportedNamesSize +
                            FunctionTableSize +
                            DebugDirectorySize;

        if (FunctionTable != NULL) {
            DbgFileHeaderSize += sizeof( IMAGE_DEBUG_DIRECTORY );
            memset( &FunctionTableDir, 0, sizeof( IMAGE_DEBUG_DIRECTORY ) );
            FunctionTableDir.Type = IMAGE_DEBUG_TYPE_EXCEPTION;
            FunctionTableDir.SizeOfData = FunctionTableSize;
            FunctionTableDir.PointerToRawData = DbgFileHeaderSize - FunctionTableSize;
        }

        DbgFileHeaderSize = ((DbgFileHeaderSize + 15) & ~15);

        BytesWritten = 0;

        if (SetFilePointer( SymbolFileHandle,
                            DbgFileHeaderSize,
                            NULL,
                            FILE_BEGIN
                          ) == DbgFileHeaderSize ) {

            for (i=0, DebugDirectory=DebugDirectories;
                 i < NumberOfDebugDirectories;
                 i++, DebugDirectory++) {

                DWORD WriteCount;

                if (DebugDirectory->SizeOfData) {
                    WriteFile( SymbolFileHandle,
                               (PCHAR) ImageBase + DebugDirectory->PointerToRawData,
                               (DebugDirectory->SizeOfData +3) & ~3,
                               &WriteCount,
                               NULL );

                    BytesWritten += WriteCount;
                }
            }
        }

        if (BytesWritten == SizeOfSymbols) {
            FileHeader->PointerToSymbolTable = 0;
            FileHeader->NumberOfSymbols = 0;
            FileHeader->Characteristics |= IMAGE_FILE_DEBUG_STRIPPED;

            if (DebugSection != NULL) {
                OptionalHeader->SizeOfImage = DebugSection->VirtualAddress;
                OptionalHeader->SizeOfInitializedData -= DebugSection->SizeOfRawData;
                FileHeader->NumberOfSections--;
                // NULL out that section
                memset(DebugSection, 0, IMAGE_SIZEOF_SECTION_HEADER);
            }

            NewFileSize = DebugSectionStart;  // Start with no symbolic

            //
            // Now that the data has moved to the .dbg file, rebuild the original
            // with MISC debug first and FPO second.
            //

            if (MiscDebugDirectory.SizeOfData) {
                if (MiscInRdata) {
                    // Just store the new name in the existing misc field...

                    ImageNameOffset = (ULONG_PTR) ((PCHAR)ImageBase +
                                      MiscDebugDirectory.PointerToRawData +
                                      FIELD_OFFSET( IMAGE_DEBUG_MISC, Data ));

                    RtlCopyMemory( (LPVOID) ImageNameOffset,
                                   ImageFilePathToSaveInImage,
                                   strlen(ImageFilePathToSaveInImage) + 1 );
                } else {
                    if (DebugSectionStart != MiscDebugDirectory.PointerToRawData) {
                        RtlMoveMemory((PCHAR) ImageBase + DebugSectionStart,
                                      (PCHAR) ImageBase + MiscDebugDirectory.PointerToRawData,
                                      MiscDebugDirectory.SizeOfData);
                    }

                    ImageNameOffset = (ULONG_PTR) ((PCHAR)ImageBase + DebugSectionStart +
                                      FIELD_OFFSET( IMAGE_DEBUG_MISC, Data ));

                    RtlCopyMemory( (LPVOID)ImageNameOffset,
                                   ImageFilePathToSaveInImage,
                                   strlen(ImageFilePathToSaveInImage) + 1 );

                    NewFileSize += MiscDebugDirectory.SizeOfData;
                    NewFileSize = (NewFileSize + 3) & ~3;
                }
            }

            if (FpoTable) {
                RtlCopyMemory( (PCHAR) ImageBase + NewFileSize,
                               FpoTable,
                               FpoTableSize );

                NewFileSize += FpoTableSize;
                NewFileSize = (NewFileSize + 3) & ~3;
            }

            // Make a copy of the Debug directory that we can write into the .dbg file

            DbgDebugDirectories = (PIMAGE_DEBUG_DIRECTORY) SymMalloc( NumberOfDebugDirectories * sizeof(IMAGE_DEBUG_DIRECTORY) );

            RtlMoveMemory(DbgDebugDirectories,
                            DebugDirectories,
                            sizeof(IMAGE_DEBUG_DIRECTORY) * NumberOfDebugDirectories);


            // Then write the MISC and (perhaps) FPO data to the image.

            FpoDebugDirectory.PointerToRawData = DebugSectionStart;
            DebugDirectorySize = 0;

            if (MiscDebugDirectory.SizeOfData != 0) {
                if (!MiscInRdata) {
                    MiscDebugDirectory.PointerToRawData = DebugSectionStart;
                    FpoDebugDirectory.PointerToRawData += MiscDebugDirectory.SizeOfData;
                    MiscDebugDirectory.AddressOfRawData = 0;
                }

                DebugDirectories[0] = MiscDebugDirectory;
                DebugDirectorySize  += sizeof(IMAGE_DEBUG_DIRECTORY);
            }

            if (pFpoDebugDirectory) {
                FpoDebugDirectory.AddressOfRawData = 0;
                DebugDirectories[DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY)] = FpoDebugDirectory;
                DebugDirectorySize += sizeof(IMAGE_DEBUG_DIRECTORY);
            }

            // Zero out remaining slots in image.

            if (NumberOfDebugDirectories < (DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY))) {
                ZeroMemory(&DebugDirectories[DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY)],
                           NumberOfDebugDirectories * sizeof(IMAGE_DEBUG_DIRECTORY) -
                           DebugDirectorySize);
            }

            OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size = DebugDirectorySize;

            DbgOffset = DbgFileHeaderSize;

            for (i = 0, j=0, DebugDirectory=DbgDebugDirectories;
                 i < NumberOfDebugDirectories; i++) {

                if (DebugDirectory[i].SizeOfData) {
                    DebugDirectory[j] = DebugDirectory[i];

                    DebugDirectory[j].AddressOfRawData = 0;
                    DebugDirectory[j].PointerToRawData = DbgOffset;

                    DbgOffset += (DebugDirectory[j].SizeOfData + 3 )& ~3;
                    j++;
                }
            }

            if (FunctionTable) {
                FunctionTableDir.PointerToRawData -= sizeof(IMAGE_DEBUG_DIRECTORY) * (NumberOfDebugDirectories - j);
            }
            NumberOfDebugDirectories = j;

            CheckSumMappedFile( ImageBase,
                                NewFileSize,
                                &HeaderSum,
                                &CheckSum
                              );
            OptionalHeader->CheckSum = CheckSum;

            DbgFileHeader.Signature = IMAGE_SEPARATE_DEBUG_SIGNATURE;
            DbgFileHeader.Flags = 0;
            DbgFileHeader.Machine = FileHeader->Machine;
            DbgFileHeader.Characteristics = FileHeader->Characteristics;
            DbgFileHeader.TimeDateStamp = FileHeader->TimeDateStamp;
            DbgFileHeader.CheckSum = CheckSum;
            DbgFileHeader.ImageBase = OptionalHeader->ImageBase;
            DbgFileHeader.SizeOfImage = OptionalHeader->SizeOfImage;
            DbgFileHeader.ExportedNamesSize = ExportedNamesSize;
            DbgFileHeader.DebugDirectorySize = NumberOfDebugDirectories * sizeof(IMAGE_DEBUG_DIRECTORY);
            if (FunctionTable) {
                DbgFileHeader.DebugDirectorySize += sizeof (IMAGE_DEBUG_DIRECTORY);
            }
            DbgFileHeader.NumberOfSections = FileHeader->NumberOfSections;
            memset( DbgFileHeader.Reserved, 0, sizeof( DbgFileHeader.Reserved ) );
            DbgFileHeader.SectionAlignment = OptionalHeader->SectionAlignment;

            SetFilePointer( SymbolFileHandle, 0, NULL, FILE_BEGIN );
            WriteFile( SymbolFileHandle,
                       &DbgFileHeader,
                       sizeof( DbgFileHeader ),
                       &BytesWritten,
                       NULL
                     );
            if (NtHeaders) {
                Sections = IMAGE_FIRST_SECTION( NtHeaders );
            } else {
                Sections = (PIMAGE_SECTION_HEADER)
                            ((ULONG_PTR)ImageBase +
                              ((PIMAGE_FILE_HEADER)ImageBase)->SizeOfOptionalHeader +
                              IMAGE_SIZEOF_FILE_HEADER );
            }
            WriteFile( SymbolFileHandle,
                       (PVOID)Sections,
                       sizeof( IMAGE_SECTION_HEADER ) * FileHeader->NumberOfSections,
                       &BytesWritten,
                       NULL
                     );

            if (ExportedNamesSize) {
                WriteFile( SymbolFileHandle,
                           ExportedNames,
                           ExportedNamesSize,
                           &BytesWritten,
                           NULL
                         );
            }

            WriteFile( SymbolFileHandle,
                       DbgDebugDirectories,
                       sizeof (IMAGE_DEBUG_DIRECTORY) * NumberOfDebugDirectories,
                       &BytesWritten,
                       NULL );


            if (FunctionTable) {
                WriteFile( SymbolFileHandle,
                           &FunctionTableDir,
                           sizeof (IMAGE_DEBUG_DIRECTORY),
                           &BytesWritten,
                           NULL );

                WriteFile( SymbolFileHandle,
                           FunctionTable,
                           FunctionTableSize,
                           &BytesWritten,
                           NULL
                         );
            }

            SetFilePointer( SymbolFileHandle, 0, NULL, FILE_END );
nomisc:
            FlushViewOfFile( ImageBase, NewFileSize );
            UnmapViewOfFile( ImageBase );

            SetFilePointer( FileHandle, NewFileSize, NULL, FILE_BEGIN );
            SetEndOfFile( FileHandle );

            TouchFileTimes( FileHandle, NULL );

            bSplitSymRetValue=TRUE;
            __leave;

        } else {
            CloseHandle( SymbolFileHandle );
            DeleteFile( SymbolFilePath );
        }

nosyms:
        dwLastError = GetLastError();
#endif
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwLastError = GetExceptionCode();
    }

    // SymFree checks that the pointer passed isn't null and
    //  sets the pointer to null after freeing the memory
    SymFree(DbgDebugDirectories);
    SymFree(ExportedNames);
    SymFree(FpoTable);
    SymFree(FunctionTable);
    SymFree(NewDebugData);

    if (FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(FileHandle);
    }

    if (SymbolFileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(SymbolFileHandle);
    }

    if (ImageBase) {
        UnmapViewOfFile(ImageBase);
    }

    if (dwLastError != 0) {
        SetLastError(dwLastError);
    }

    return(bSplitSymRetValue);
}


#if defined(use_SplitSymbolsX)
LPSTR CharNext(
    LPCSTR lpCurrentChar)
{
    if (IsDBCSLeadByte(*lpCurrentChar)) {
        lpCurrentChar++;
    }
    /*
     * if we have only DBCS LeadingByte, we will point string-terminaler.
     */

    if (*lpCurrentChar) {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;
}

LPSTR CharPrev(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar)
{
    if (lpCurrentChar > lpStart) {
        LPCSTR lpChar;
        BOOL bDBC = FALSE;

        for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
            if (!IsDBCSLeadByte(*lpChar))
                break;
            bDBC = !bDBC;
        }

        if (bDBC)
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\splitsymx.h ===
BOOL
SplitSymbolsX(
    LPSTR ImageName,
    LPSTR SymbolsPath,
    LPSTR SymbolFilePath,
    DWORD SizeOfSymbolFilePath,
    ULONG Flags,
    PCHAR RSDSDllToLoad,
    LPSTR CreatedPdb,
    DWORD SizeOfPdbBuffer
);

BOOL
CopyPdbX(
    CHAR const * szSrcPdb,
    CHAR const * szDestPdb,
    BOOL StripPrivate,
    CHAR const * szRSDSDllToLoad
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\symbols.h ===
//
// defines for symbol file searching
//

#include <cmnutil.hpp>

// this private API is in msdia20-msvcrt.lib

HRESULT
__cdecl
CompareRE(
    const wchar_t* pStr,
    const wchar_t* pRE,
    BOOL fCase
    );

#define SYMBOL_PATH             "_NT_SYMBOL_PATH"
#define ALTERNATE_SYMBOL_PATH   "_NT_ALT_SYMBOL_PATH"
#define SYMBOL_SERVER           "_NT_SYMBOL_SERVER"
#define SYMSRV_PROXY            "_NT_SYMBOL_PROXY"
#define SYMSRV                  "SYMSRV"
#define WINDIR                  "windir"
#define DBGHELP_TOKEN           "DBGHELP_TOKEN"
#define HASH_MODULO             253
#define OMAP_SYM_EXTRA          1024
#define CPP_EXTRA               2
#define OMAP_SYM_STRINGS        (OMAP_SYM_EXTRA * 256)
#define TMP_SYM_LEN             4096

// Possibly truncates and sign-extends a value to 64 bits.
#define EXTEND64(Val) ((ULONG64)(LONG64)(LONG)(Val))

//
// structures
//

typedef struct _LOADED_MODULE {
    PENUMLOADED_MODULES_CALLBACK      EnumLoadedModulesCallback32;
    PENUMLOADED_MODULES_CALLBACK64      EnumLoadedModulesCallback64;
    PVOID                               Context;
} LOADED_MODULE, *PLOADED_MODULE;

#define SYMF_DUPLICATE    0x80000000

typedef struct _SYMBOL_ENTRY {
    struct _SYMBOL_ENTRY        *Next;
    DWORD                       Size;
    DWORD                       Flags;
    DWORD64                     Address;
    LPSTR                       Name;
    ULONG                       NameLength;

    ULONG                       Segment;
    ULONG64                     Offset;
    ULONG                       TypeIndex;
    ULONG64                     ModBase;
    ULONG                       Register;
} SYMBOL_ENTRY, *PSYMBOL_ENTRY;

typedef struct _SECTION_START {
    ULONG64                     Offset;
    DWORD                       Size;
    DWORD                       Flags;
} SECTION_START, *PSECTION_START;

//
// source file and line number information
//
typedef struct _SOURCE_LINE {
    DWORD64             Addr;
    DWORD               Line;
} SOURCE_LINE, *PSOURCE_LINE;

typedef struct _SOURCE_ENTRY {
    struct _SOURCE_ENTRY       *Next;
    struct _SOURCE_ENTRY       *Prev;
    DWORD64                     MinAddr;
    DWORD64                     MaxAddr;
    LPSTR                       File;
    DWORD                       Lines;
    PSOURCE_LINE                LineInfo;
    ULONG                       ModuleId;
} SOURCE_ENTRY, *PSOURCE_ENTRY;

//
// Error values for failed symbol load
//
#define SYMLOAD_OK              0x0000
#define SYMLOAD_PDBUNMATCHED    0x0001
#define SYMLOAD_PDBNOTFOUND     0x0002
#define SYMLOAD_DBGNOTFOUND     0x0003
#define SYMLOAD_OTHERERROR      0x0004
#define SYMLOAD_OUTOFMEMORY     0x0005
#define SYMLOAD_HEADERPAGEDOUT  0x0006
#define SYMLOAD_PDBERRORMASK    0xff00
#define SYMLOAD_DEFERRED        0x80000000

//
// module flags
//
#define MIF_DEFERRED_LOAD   0x00000001
#define MIF_NO_SYMBOLS      0x00000002
#define MIF_ROM_IMAGE       0x00000004
#define MIF_NO_SIG          0x00000008
#define MIF_MISMATCHED_SIG  0x00000010

// Virtual Symbol

typedef struct _VIRTUAL_SYMBOL {
    CHAR    name[MAX_SYM_NAME + 1];
    DWORD64 addr;
    DWORD   size;
} VIRTUAL_SYMBOL, *PVIRTUAL_SYMBOL;

// for ImageSrc and PdbSrc elements

typedef enum  {
    srcNone = 0,
    srcSearchPath,
    srcImagePath,
    srcDbgPath,
    srcSymSrv,
    srcCVRec,
    srcHandle,
    srcMemory
};

typedef struct {
    DWORD rvaBeginAddress;
    DWORD rvaEndAddress;
    DWORD rvaPrologEndAddress;
    DWORD rvaExceptionHandler;
    DWORD rvaHandlerData;
} IMGHLP_RVA_FUNCTION_DATA, *PIMGHLP_RVA_FUNCTION_DATA;

typedef struct _MODULE_ENTRY {
    LIST_ENTRY                      ListEntry;
    ULONG64                         BaseOfDll;
    ULONG                           DllSize;
    ULONG                           TimeDateStamp;
    ULONG                           CheckSum;
    USHORT                          MachineType;
    CHAR                            ModuleName[64];
    CHAR                            AliasName[64];
    PSTR                            ImageName;
    PSTR                            LoadedImageName;
    PSTR                            LoadedPdbName;
    ULONG                           ImageType;
    ULONG                           ImageSrc;
    ULONG                           PdbSrc;
    PSYMBOL_ENTRY                   symbolTable;
    LPSTR                           SymStrings;
    PSYMBOL_ENTRY                   NameHashTable[HASH_MODULO];
    ULONG                           numsyms;
    ULONG                           MaxSyms;
    ULONG                           StringSize;
    SYM_TYPE                        SymType;
    SYM_TYPE                        lSymType;       // indicates the type of symbols that we attempted to load
    PDB *                           pdb;
    DBI *                           dbi;
    GSI *                           gsi;
    GSI *                           globals;
    TPI *                           ptpi;
    PIMAGE_SECTION_HEADER           SectionHdrs;
    ULONG                           NumSections;
    PFPO_DATA                       pFpoData;       // pointer to fpo data (x86)
    PFPO_DATA                       pFpoDataOmap;  // pointer to fpo data (x86)
    PIMGHLP_RVA_FUNCTION_DATA       pExceptionData; // pointer to pdata (risc)
    PVOID                           pPData;         // pdata acquired from pdb
    PVOID                           pXData;         // xdata acquired from pdb
    ULONG                           dwEntries;      // # of fpo or pdata recs
    ULONG                           cPData;         // number of pdb pdata entries
    ULONG                           cXData;         // number of pdb xdata entries
    ULONG                           cbPData;        // size of pdb xdata blob
    ULONG                           cbXData;        // size of pdb xdata blob
    POMAP                           pOmapFrom;      // pointer to omap data
    ULONG                           cOmapFrom;      // count of omap entries
    POMAP                           pOmapTo;        // pointer to omap data
    ULONG                           cOmapTo;        // count of omap entries
    SYMBOL_ENTRY                    TmpSym;         // used only for pdb symbols
    SYMBOL_ENTRY                    vsTmpSym;       // used only by virtual symbols
    SYMBOL_INFO                     si;             // used for dia symbols
    UCHAR                           siName[2048];   // must be contiguous with si
    SYMBOL_INFO                     vssi;           // used only by virtual symbols
    UCHAR                           vssiName[2048]; // must be contiguous with vssi
    ULONG                           Flags;
    HANDLE                          hFile;
    PIMAGE_SECTION_HEADER           OriginalSectionHdrs;
    ULONG                           OriginalNumSections;
    PSOURCE_ENTRY                   SourceFiles;
    PSOURCE_ENTRY                   SourceFilesTail;

    HANDLE                          hProcess;
    ULONG64                         InProcImageBase;
    BOOL                            fInProcHeader;
    DWORD                           dsExceptions;
    Mod                            *mod;
    USHORT                          imod;
    PBYTE                           pPdbSymbols;
    DWORD                           cbPdbSymbols;
    ULONG                           SymLoadError;
    ULONG                           code;           // used to pass back info to wrappers
    PVOID                           dia;
    CHAR                            SrcFile[_MAX_PATH + 1];
    DWORD                           CallerFlags;
    MODLOAD_DATA                    mld;
    PVOID                           CallerData;
    PVIRTUAL_SYMBOL                 vs;            // virtual symbol list
    DWORD                           cvs;           // number of virtual symbols
    BOOL                            processed;     // this flag is used for multi-pass module searches
    LONG                            cGlobals;
    BOOL                            loaded;        // indicates if symbols were loaded
    PBYTE                           stSrcSrv;
    DWORD                           cbSrcSrv;
    ULONG                           pdbdataAge;
    ULONG                           pdbdataSig;
    GUID                            pdbdataGuid;
    DWORD                           cvSig;
    BOOL                            fLines;
    BOOL                            fSymbols;
    BOOL                            fTypes;
    BOOL                            fPdbUnmatched;
    BOOL                            fDbgUnmatched;
    CVDD                            CVRec;
    SRCCODEINFO                     sci;
} MODULE_ENTRY, *PMODULE_ENTRY;

typedef struct _SOURCE_HINT {
    struct _SOURCE_HINT *next;
    LPSTR                filename;
    PMODULE_ENTRY        mi;
} SOURCE_HINT, *PSOURCE_HINT;

typedef VOID DBG_CONTEXT, *PDBG_CONTEXT;

#ifdef USE_CACHE

#define CACHE_BLOCK 40
#define CACHE_SIZE CACHE_BLOCK*CACHE_BLOCK

typedef struct _DIA_LARGE_DATA {
    BOOL Used;
    ULONG Index;
    ULONG LengthUsed;
    CHAR Bytes[500];
} DIA_LARGE_DATA, *PDIA_LARGE_DATA;

#define DIACH_ULVAL  0
#define DIACH_ULLVAL 1
#define DIACH_PLVAL  2
typedef struct _DIA_CACHE_DATA {
    ULONG type;
    union {
        ULONG ulVal;
        ULONGLONG ullVal;
        PDIA_LARGE_DATA plVal;
    };
} DIA_CACHE_DATA, *PDIA_CACHE_DATA;

typedef struct _DIA_CACHE_ENTRY {
    ULONG Age;
    union {
        struct {
            ULONG TypeId;
            IMAGEHLP_SYMBOL_TYPE_INFO DataType;
        } s;
        ULONGLONG SearchId;
    };
    ULONGLONG Module;
    DIA_CACHE_DATA Data;
} DIA_CACHE_ENTRY, *PDIA_CACHE_ENTRY;
#endif // USE_CACHE

typedef struct _PROCESS_ENTRY {
    LIST_ENTRY                      ListEntry;
    LIST_ENTRY                      ModuleList;
    PLIST_ENTRY                     NextModule;
    ULONG                           cRefs;
    HANDLE                          hProcess;
    DWORD                           pid;
    LPSTR                           SymbolSearchPath;
    PSYMBOL_REGISTERED_CALLBACK     pCallbackFunction32;
    PSYMBOL_REGISTERED_CALLBACK64   pCallbackFunction64;
    ULONG64                         CallbackUserContext;
    PSYMBOL_FUNCENTRY_CALLBACK      pFunctionEntryCallback32;
    PSYMBOL_FUNCENTRY_CALLBACK64    pFunctionEntryCallback64;
    ULONG64                         FunctionEntryUserContext;
    PIMAGEHLP_CONTEXT               pContext;
    IMAGEHLP_STACK_FRAME            StackFrame;
    PMODULE_ENTRY                   ipmi;
#ifdef USE_CACHE
    DIA_LARGE_DATA                  DiaLargeData[2*CACHE_BLOCK];
    DIA_CACHE_ENTRY                 DiaCache[CACHE_SIZE];
#endif // USE_CACHE
    PSOURCE_HINT                    SourceHints;          // list of prevously found source files and modules
} PROCESS_ENTRY, *PPROCESS_ENTRY;


#if 1
typedef struct _IMGHLP_DEBUG_DATA {
    DWORD   SizeOfStruct;
    PPROCESS_ENTRY pe;
    PCHAR   SymbolPath;
    ULONG64 InProcImageBase;
    ULONG64 ImageBaseFromImage;
    DWORD   SizeOfImage;
    DWORD   CheckSum;
    DWORD   TimeDateStamp;
    DWORD   Characteristics;
    USHORT  Machine;
    CHAR    ImageFilePath[MAX_PATH + 1];
    CHAR    OriginalImageFileName[MAX_PATH + 1];           // Retrieved from the .dbg file for cases when we only have a file handle...
    HANDLE  ImageFileHandle;
    PVOID   ImageMap;
    USHORT  iohMagic;
    CHAR    DbgFilePath[MAX_PATH + 1];
    CHAR    OriginalDbgFileName[MAX_PATH + 1];
    HANDLE  DbgFileHandle;
    PVOID   DbgFileMap;
    DWORD   DbgTimeDateStamp;
    DWORD   PdbAge;
    DWORD   PdbSignature;
    BOOL    PdbRSDS;
    GUID    PdbGUID;
    CHAR    PdbFileName[NB_PATH_SIZE + 1 ];
    CHAR    PdbReferencePath[MAX_PATH + 1];
    ULONG   ImageType;
    ULONG   ImageSrc;
    ULONG   PdbSrc;
    PCHAR   pMappedCv;
    PCHAR   pMappedCoff;
//  PCHAR   pMappedExportDirectory;
    PCHAR   pMappedDbgFunction;     // PIMAGE_FUNCTION_ENTRY from the .dbg file
    PVOID   pFpo;
    PVOID   pPData;                 // PIMAGE_RUNTIME_FUNCTION_ENTRY from the image.
    PVOID   pXData;
    POMAP   pOmapTo;
    POMAP   pOmapFrom;
    PIMAGE_SECTION_HEADER   pImageSections;
    PIMAGE_SECTION_HEADER   pDbgSections;
    PIMAGE_SECTION_HEADER   pOriginalSections;
    PIMAGE_SECTION_HEADER   pCurrentSections;
    DWORD   ddva;                   // only used by MapDebugInformation - virtual addr of debug dirs
    DWORD   cdd;                    // only used by MapDebugInformation - number of debug dirs
//  ULONG   NumberOfPdataFunctionEntries;
    ULONG   cFpo;
    ULONG   cPData;
    ULONG   cbPData;
    ULONG   cXData;
    ULONG   cbXData;
    ULONG   cOmapTo;
    ULONG   cOmapFrom;
    ULONG   cImageSections;
    ULONG   cDbgSections;
    ULONG   cOriginalSections;
    ULONG   cCurrentSections;
    ULONG   cMappedCv;
    ULONG   cMappedCoff;
    ULONG   ImageAlign;
    BOOL    fPE64;
    BOOL    fROM;
    BOOL    fCoffMapped;
    BOOL    fCvMapped;
    BOOL    fFpoMapped;
    BOOL    fPDataMapped;
    BOOL    fXDataMapped;
    BOOL    fOmapToMapped;
    BOOL    fOmapFromMapped;
    BOOL    fCurrentSectionsMapped;
    BOOL    fInProcHeader;
    BOOL    fTryAgain;
    HANDLE  hProcess;
    CHAR    ImageName[MAX_PATH + 1];
    DWORD   dsExports;
    DWORD   dsCoff;
    DWORD   dsCV;
    DWORD   dsMisc;
    DWORD   dsFPO;
    DWORD   dsOmapTo;
    DWORD   dsOmapFrom;
    DWORD   dsExceptions;
    LONG    cGlobals;               // amount of global symbols found
    union {
        IMAGE_EXPORT_DIRECTORY expdir;
        LONGLONG               makeitQWordAlign; // this address is deref'd
    };
    DWORD   fNeedImage;
    PVOID   dia;
    DWORD   flags;
    PMODULE_DATA md;
    DWORD64 oExports;
    DWORD   cExports;
    PMODLOAD_DATA mld;
    BOOL    fDbgTried;

    DWORD   CallerFlags;
    char    FoundPdb[MAX_PATH + 1];
    DWORD   LoadInfo;
    DWORD   error;
    ULONG   pdbdataAge;
    ULONG   pdbdataSig;
    GUID    pdbdataGuid;
    BOOL    fLines;
    BOOL    fSymbols;
    BOOL    fTypes;
    BOOL    fPdbUnmatched;
    BOOL    fDbgUnmatched;
} IMGHLP_DEBUG_DATA, *PIMGHLP_DEBUG_DATA;

#ifndef _WIN64

typedef struct {
    PIMGHLP_DEBUG_DATA idd;
} PIDI_HEADER, *PPIDI_HEADER;

typedef struct {
    PIDI_HEADER             hdr;
    IMAGE_DEBUG_INFORMATION idi;
} PIDI, *PPIDI;

#endif

#endif

// for returning from functions

inline
unsigned int
error(
    DWORD err
    )
{
    SetLastError(err);
    return 0;
}


// debug trace facility

int
WINAPIV
_pprint(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR          Format,
    ...
    );

int
WINAPIV
_peprint(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR Format,
    ...
    );

int
WINAPIV
_dprint(
    LPSTR format,
    ...
    );

int
WINAPIV
_eprint(
    LPSTR Format,
    ...
    );

#define option(a) (g.SymOptions & a)

#define dprint (option(SYMOPT_DEBUG) || g.hLog)&&_dprint
#define eprint (option(SYMOPT_DEBUG) || g.hLog)&&_eprint
#define cprint _dprint

#define dtrace (option(SYMOPT_DEBUG) || g.hLog)&&_dprint
#define etrace (option(SYMOPT_DEBUG) || g.hLog)&&_eprint

#define pprint (option(SYMOPT_DEBUG) || g.hLog)&&_pprint
#define peprint (option(SYMOPT_DEBUG) || g.hLog)&&_peprint
#define pcprint _pprint

BOOL
WINAPIV
evtprint(
    PPROCESS_ENTRY pe,
    DWORD          severity,
    DWORD          code,
    PVOID          object,
    LPSTR          format,
    ...
    );

BOOL
traceAddr(
    DWORD64 addr
    );

BOOL
traceName(
    PCHAR name
    );

BOOL
traceSubName(
    PCHAR name
    );

// for use with cvtype.h

typedef SYMTYPE *SYMPTR;

__inline
DWORD64
GetIP(
    PPROCESS_ENTRY pe
    )
{
    return pe->StackFrame.InstructionOffset;
}


typedef struct _PDB_INFO {
    CHAR    Signature[4];   // "NBxx"
    ULONG   Offset;         // always zero
    ULONG   sig;
    ULONG   age;
    CHAR    PdbName[_MAX_PATH];
} PDB_INFO, *PPDB_INFO;

#define n_name          N.ShortName
#define n_zeroes        N.Name.Short
#define n_nptr          N.LongName[1]
#define n_offset        N.Name.Long

//
// internal prototypes
//

void
InitModuleEntry(
    PMODULE_ENTRY mi
    );

PMODULE_ENTRY
GetModFromAddr(
    PPROCESS_ENTRY    pe,
    IN  DWORD64       addr
    );

DWORD_PTR
GetPID(
    HANDLE hProcess
    );

DWORD
GetProcessModules(
    HANDLE         hProcess,
    PGET_MODULE    cbGetModule,
    PVOID          Context
    );

VOID
FreeModuleEntry(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi
    );

void
ClearModuleFlags(
    PPROCESS_ENTRY pe
    );

char *
SymbolStatus(
    PMODULE_ENTRY mi,
    int           indent
    );

BOOL
PrepRE4Srch(
    PCSTR in,
    PSTR  out
    );

BOOL
ValidGuid(
    GUID *guid
    );

BOOL
GuidIsDword(
    GUID *guid
    );

PPROCESS_ENTRY
FindProcessEntry(
    HANDLE  hProcess
    );

PPROCESS_ENTRY
FindFirstProcessEntry(
    );

VOID
GetSymName(
    PIMAGE_SYMBOL Symbol,
    PUCHAR        StringTable,
    LPSTR         s,
    DWORD         size
    );

BOOL
ProcessOmapSymbol(
    PMODULE_ENTRY   mi,
    PSYMBOL_ENTRY   sym
    );

DWORD64
ConvertOmapFromSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias
    );

DWORD64
ConvertOmapToSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias,
    BOOL           fBackup
    );

POMAP
GetOmapFromSrcEntry(
    PMODULE_ENTRY  mi,
    DWORD64        addr
    );

VOID
DumpOmapForModule(
    PMODULE_ENTRY      mi
    );

VOID
ProcessOmapForModule(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA idd
    );

BOOL
LoadCoffSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA idd
    );

BOOL
LoadCodeViewSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA idd
    );

ULONG
LoadExportSymbols(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA idd
    );

PMODULE_ENTRY
GetModuleForPC(
    PPROCESS_ENTRY  ProcessEntry,
    DWORD64         dwPcAddr,
    BOOL            ExactMatch
    );

PSYMBOL_INFO
GetSymFromAddr(
    DWORD64         dwAddr,
    PDWORD64        pqwDisplacement,
    PMODULE_ENTRY   mi
    );

PSYMBOL_INFO
GetSymFromAddrByTag(
    DWORD64         dwAddr,
    DWORD           SymTag,
    PDWORD64        pqwDisplacement,
    PMODULE_ENTRY   mi
    );

PSYMBOL_INFO
GetSymFromToken(
    PMODULE_ENTRY   mi,
    DWORD           token
    );

PSYMBOL_ENTRY
cvGetSymFromAddr(
    DWORD64         dwAddr,
    PDWORD64        pqwDisplacement,
    PMODULE_ENTRY   mi
    );

LPSTR
StringDup(
    LPSTR str
    );

DWORD
ComputeHash(
    LPSTR   lpname,
    ULONG   cb
    );

PSYMBOL_INFO
FindSymbolByName(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    );

PFPO_DATA
SwSearchFpoData(
    DWORD     key,
    PFPO_DATA base,
    DWORD     num
    );

PIMGHLP_RVA_FUNCTION_DATA
GetFunctionEntryFromDebugInfo (
    PPROCESS_ENTRY  ProcessEntry,
    DWORD64         ControlPc
    );

PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntryIa64 (
    HANDLE        hProcess,
    DWORD64       ControlPc
    );

_PIMAGE_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntryAmd64 (
    HANDLE        hProcess,
    DWORD64       ControlPc
    );

BOOL
LoadedModuleEnumerator(
    HANDLE         hProcess,
    LPSTR          ModuleName,
    DWORD64        ImageBase,
    DWORD          ImageSize,
    PLOADED_MODULE lm
    );

LPSTR
symfmt(
    LPSTR DstName,
    LPSTR SrcName,
    ULONG Length
    );

BOOL
MatchSymName(
    LPSTR matchName,
    LPSTR symName
    );

BOOL
strcmpre(
    PCSTR pStr,
    PCSTR pRE,
    BOOL  fCase
    );

BOOL
SympConvertAnsiModule32ToUnicodeModule32(
    PIMAGEHLP_MODULE  A_Symbol32,
    PIMAGEHLP_MODULEW W_Symbol32
    );

BOOL
SympConvertUnicodeModule32ToAnsiModule32(
    PIMAGEHLP_MODULEW W_Symbol32,
    PIMAGEHLP_MODULE  A_Symbol32
    );

BOOL
SympConvertAnsiModule64ToUnicodeModule64(
    PIMAGEHLP_MODULE64  A_Symbol64,
    PIMAGEHLP_MODULEW64 W_Symbol64
    );

BOOL
SympConvertUnicodeModule64ToAnsiModule64(
    PIMAGEHLP_MODULEW64 W_Symbol64,
    PIMAGEHLP_MODULE64  A_Symbol64
    );

PSYMBOL_ENTRY
si2se(
    PSYMBOL_INFO  si,
    PSYMBOL_ENTRY se
    );

PSYMBOL_INFO
se2si(
    PSYMBOL_ENTRY se,
    PSYMBOL_INFO  si
    );

PIMAGEHLP_SYMBOL
se2sym(
    PSYMBOL_ENTRY    se,
    PIMAGEHLP_SYMBOL sym
    );

PIMAGEHLP_SYMBOL64
se2lsym(
    PSYMBOL_ENTRY      se,
    PIMAGEHLP_SYMBOL64 lsym
    );

PIMAGEHLP_SYMBOL
si2sym(
    PSYMBOL_INFO     si,
    PIMAGEHLP_SYMBOL sym
    );

PIMAGEHLP_SYMBOL64
si2lsym(
    PSYMBOL_INFO       si,
    PIMAGEHLP_SYMBOL64 lsym
    );

PSYMBOL_INFO
si2si(
    PSYMBOL_INFO  trg,
    PSYMBOL_INFO  src
    );

PIMAGEHLP_SYMBOL
lsym2sym(
    PIMAGEHLP_SYMBOL64 lsym,
    PIMAGEHLP_SYMBOL   sym
    );

PIMAGEHLP_SYMBOL64
sym2lsym(
    PIMAGEHLP_SYMBOL   sym,
    PIMAGEHLP_SYMBOL64 lsym
    );

PIMAGEHLP_LINE
lline2line(
    PIMAGEHLP_LINE64 lline,
    PIMAGEHLP_LINE   line
    );

PIMAGEHLP_LINE64
line2lline(
    PIMAGEHLP_LINE   line,
    PIMAGEHLP_LINE64 lline
    );

PMODULE_ENTRY
FindModule(
    HANDLE hModule,
    PPROCESS_ENTRY ProcessEntry,
    LPSTR ModuleName,
    BOOL fLoad
    );

LPSTR
SymUnDNameInternal(
    LPSTR UnDecName,
    DWORD UnDecNameLength,
    LPSTR DecName,
    DWORD MaxDecNameLength,
    DWORD MachineType,
    BOOL  IsPublic
    );

BOOL
sci2lline(
    PMODULE_ENTRY    mi,
    PSRCCODEINFO     sci,
    PIMAGEHLP_LINE64 line64);

void sciInit(PSRCCODEINFO sci);

BOOL
GetLineFromAddr(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY mi,
    DWORD64 Addr,
    PDWORD Displacement,
    PSRCCODEINFO sci
    );

PSOURCE_HINT
FindSourceFileInHintList(
    PPROCESS_ENTRY  pe,
    char           *filename
    );

// used by GetLineFromName

enum {
    mName,          // only file name must match
    mFullPath,      // must match the full path
    mBestMatch      // get the closest possible match
};

BOOL
GetLineFromName(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY mi,
    LPSTR FileName,
    DWORD LineNumber,
    PLONG Displacement,
    PSRCCODEINFO sci,
    DWORD method
    );

BOOL
AddLinesForCoff(
    PMODULE_ENTRY mi,
    PIMAGE_SYMBOL allSymbols,
    DWORD numberOfSymbols,
    PIMAGE_LINENUMBER LineNumbers
    );

BOOL
AddLinesForOmfSourceModule(
    PMODULE_ENTRY mi,
    BYTE *Base,
    OMFSourceModule *OmfSrcMod,
    PVOID PdbModule
    );

PSOURCE_ENTRY
FindNextSourceEntryForFile(
    PMODULE_ENTRY mi,
    LPSTR File,
    PSOURCE_ENTRY SearchFrom
    );

PSOURCE_ENTRY
FindPrevSourceEntryForFile(
    PMODULE_ENTRY mi,
    LPSTR File,
    PSOURCE_ENTRY SearchFrom
    );

BOOL
__stdcall
ReadInProcMemory(
    HANDLE    hProcess,
    DWORD64   addr,
    PVOID     buf,
    DWORD     bytes,
    DWORD    *bytesread
    );

BOOL
GetPData(
    HANDLE        hp,
    PMODULE_ENTRY mi
    );

BOOL
GetXData(
    HANDLE        hp,
    PMODULE_ENTRY mi
    );

PVOID
GetXDataFromBase(
    HANDLE     hp,
    DWORD64    base,
    ULONG*     size
    );

PVOID
GetUnwindInfoFromSymbols(
    HANDLE     hProcess,
    DWORD64    ModuleBase,
    ULONG      UnwindInfoAddress,
    ULONG*     Size
    );


// symbols.c

char *
TokenFromSymbolPath(
    char *path,
    char *token,
    int   size
    );

BOOL
CreateSymbolPath(
    int pass,
    char *base,
    char *iext,
    char *node,
    char *ext,
    char *path,
    size_t size
    );

BOOL
DoEnumCallback(
    PPROCESS_ENTRY pe,
    PSYMBOL_INFO   pSymInfo,
    ULONG          SymSize,
    PROC           EnumCallback,
    PVOID          UserContext,
    BOOL           Use64,
    BOOL           UsesUnicode
    );

#ifdef __cpluspluss
extern "C" {
#endif


BOOL
MatchSymbolName(
    PSYMBOL_ENTRY       sym,
    LPSTR               SymName
    );

// flags parameter to LoadSymbols

#define LS_QUALIFIED      0x1
#define LS_LOAD_LINES     0x2
#define LS_JUST_TEST      0x4
#define LS_FAIL_IF_LOADED 0x8

// flags indicate Next or Previous for many functions

#define NP_NEXT         1
#define NP_PREV         -1

BOOL
DoSymbolCallback (
    PPROCESS_ENTRY                  ProcessEntry,
    ULONG                           CallbackType,
    IN  PMODULE_ENTRY               mi,
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl64,
    LPSTR                           FileName
    );

BOOL
DoCallback(
    PPROCESS_ENTRY pe,
    ULONG          type,
    PVOID          data
    );

BOOL
IsCallback(
    PPROCESS_ENTRY pe
    );

BOOL
wcs2ansi(
    PWSTR pwsz,
    PSTR  psz,
    DWORD pszlen
    );

BOOL
ansi2wcs(
    PCSTR  psz,
    PWSTR pwsz,
    DWORD pwszlen
    );

PWSTR AnsiToUnicode(PSTR);
PSTR  UnicodeToAnsi(PWSTR);

void
RemoveSourceForModuleFromHintList(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi
    );

ULONG
GetAddressFromOffset(
    PMODULE_ENTRY mi,
    ULONG         section,
    ULONG64       Offset,
    PULONG64      pAddress
    );

VOID
AddSourceEntry(
    PMODULE_ENTRY mi,
    PSOURCE_ENTRY Src
    );

// from vsym.c

BOOL
vsAddSymbol(
    PMODULE_ENTRY mi,
    PCSTR         name,
    DWORD64       addr,
    DWORD         size
    );

BOOL
vsDeleteSymbol(
    PMODULE_ENTRY mi,
    PCSTR         name,
    DWORD64       addr
    );

BOOL
_vsEnumSymbols(
    PMODULE_ENTRY mi
    );

BOOL
vsMatchSymbol(
    PVIRTUAL_SYMBOL vs,
    PCSTR           name,
    DWORD64         addr
    );

PVIRTUAL_SYMBOL
vsGetSymbol(
    PMODULE_ENTRY mi,
    PCSTR         name,
    DWORD64       addr
    );

__inline
PVIRTUAL_SYMBOL
vsBlankSymbol(
    PMODULE_ENTRY mi
    )
{
    return vsGetSymbol(mi, NULL, 0);
}

BOOL
vsGetSymbols(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY  mi,
    IN PCSTR          mask,
    IN DWORD64        addr,
    IN PROC           callback,
    IN PVOID          context,
    IN BOOL           use64,
    IN BOOL           unicode
    );

__inline
BOOL
vsEnumSymbols(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY  mi,
    IN PCSTR          mask,
    IN PROC           callback,
    IN PVOID          context,
    IN BOOL           use64,
    IN BOOL           unicode
    )
{
    return vsGetSymbols(pe, mi, mask, 0, callback, context, use64, unicode);
}

__inline
BOOL
vsEnumSymbolsForAddr(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY  mi,
    IN DWORD64        addr,
    IN PROC           callback,
    IN PVOID          context,
    IN BOOL           use64,
    IN BOOL           unicode
    )
{
    return vsGetSymbols(pe, mi, NULL, addr, callback, context, use64, unicode);
}

PSYMBOL_INFO
vsFindSymbolByName(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    );

PSYMBOL_INFO
vsGetSymNextPrev(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    BOOL            direction
    );

PSYMBOL_INFO
vsGetSymFromAddr(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    PDWORD64        disp
    );

PSYMBOL_ENTRY
vsGetSymEntryFromAddr(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    PDWORD64        disp
    );

// from dia.c

BOOL diaInit();

void diaCleanup();

void
diaRelease(
    PVOID dia
    );

LONG
diaCountGlobals(
    PMODULE_ENTRY  mi
    );

BOOL
diaGetPdb(
    PIMGHLP_DEBUG_DATA idd
    );

BOOL
diaReadStream(
    PMODULE_ENTRY mi,
    char  *stream,
    PBYTE *buf,
    DWORD *size
    );

BOOL
diaEnumSourceFiles(
    IN PMODULE_ENTRY mi,
    IN PCHAR         mask,
    IN PSYM_ENUMSOURCFILES_CALLBACK cbSrcFiles,
    IN PVOID         context
    );

BOOL
diaGetSymbolsByTag(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi,
    PCSTR          name,
    DWORD64        addr,
    DWORD          tag,
    PROC           callback,
    PVOID          context,
    BOOL           use64,
    BOOL           unicode,
    DWORD          flags
    );

PSYMBOL_INFO
diaGetSymFromToken(
    PMODULE_ENTRY  mi,
    DWORD          token
    );

BOOL
diaGetPData(
    PMODULE_ENTRY mi
    );

BOOL
diaGetXData(
    PMODULE_ENTRY mi
    );

PSYMBOL_INFO
diaFindSymbolByName(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    );

BOOL
diaEnumerateSymbols(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY  mi,
    IN PCSTR          mask,
    IN PROC           callback,
    IN PVOID          UserContext,
    IN BOOL           Use64,
    IN BOOL           CallBackUsesUnicode
    );

BOOL
diaEnumSymForAddr(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY  mi,
    IN DWORD64        addr,
    IN PROC           callback,
    IN PVOID          context,
    IN BOOL           use64,
    IN BOOL           unicode
    );

PSYMBOL_INFO
diaGetSymFromAddr(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    PDWORD64        disp
    );

PSYMBOL_INFO
diaGetSymFromAddrByTag(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    DWORD           tag,
    PDWORD64        disp
    );

BOOL
diaEnumLines(
    IN  PPROCESS_ENTRY          pe,
    IN  PMODULE_ENTRY           mi,
    IN  PCSTR                   obj,
    IN  PCSTR                   file,
    IN  PSYM_ENUMLINES_CALLBACK cb,
    IN  PVOID                   context
    );

BOOL
diaGetLineFromAddr(
    PMODULE_ENTRY    mi,
    DWORD64          addr,
    PDWORD           displacement,
    PSRCCODEINFO     sci
    );

BOOL
diaGetLineNextPrev(
    PMODULE_ENTRY    mi,
    PIMAGEHLP_LINE64 line,
    DWORD            direction
    );

#define diaGetLineNext(mi, line) diaGetLineNextPrev(mi, line, NP_NEXT);
#define diaGetLinePrev(mi, line) diaGetLineNextPrev(mi, line, NP_PREV);

BOOL
diaGetLineFromName(
    PMODULE_ENTRY    mi,
    LPSTR            filename,
    DWORD            linenumber,
    PLONG            displacement,
    PSRCCODEINFO     sci,
    DWORD            method
    );

PSYMBOL_INFO
diaGetSymNextPrev(
    PMODULE_ENTRY mi,
    DWORD64       addr,
    int           direction
    );

DWORD
diaVersion(
    VOID
    );

BOOL
diaSetModFromIP(
    PPROCESS_ENTRY pe
    );

HRESULT
diaGetSymbolInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    );

BOOL
diaGetTiForUDT(
    PMODULE_ENTRY ModuleEntry,
    LPSTR         name,
    PSYMBOL_INFO  psi
    );

BOOL
diaEnumUDT(
    PMODULE_ENTRY ModuleEntry,
    LPSTR         name,
    PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    PVOID         EnumContext
    );

BOOL
diaGetFrameData(
    IN HANDLE Process,
    IN ULONGLONG Offset,
    OUT interface IDiaFrameData** FrameData
    );

BOOL
InitOutputString(
    PCHAR sz
    );

BOOL
TestOutputString(
    PCHAR sz
    );

// symmod.c

DWORD64
LoadModule(
    IN  HANDLE          hp,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize,
    IN  HANDLE          hFile,
    IN  PMODLOAD_DATA   data,
    IN  DWORD           flags
    );

BOOL
GetModule(
    HANDLE  hp,
    LPSTR   ModuleName,
    DWORD64 ImageBase,
    DWORD   ImageSize,
    PVOID   Context
    );

BOOL
GetDebugData(
    PIMGHLP_DEBUG_DATA idd
    );

BOOL
LoadSymbols(
    HANDLE        hp,
    PMODULE_ENTRY mi,
    DWORD         flags
    );

PIMGHLP_DEBUG_DATA
GetIDD(
    HANDLE        hFile,
    LPSTR         FileName,
    LPSTR         SymbolPath,
    ULONG64       ImageBase,
    DWORD         dwFlags
    );

BOOL 
ExtMatch(
    char *fname,
    char *ext
    );

__inline BOOL IsPdb(LPSTR fname)
{
    return ExtMatch(fname, ".pdb");
}

__inline BOOL IsDbg(LPSTR fname)
{
    return ExtMatch(fname, ".dbg");
}

PIMGHLP_DEBUG_DATA
InitIDD(
    HANDLE        hProcess,
    HANDLE        FileHandle,
    LPSTR         FileName,
    LPSTR         SymbolPath,
    ULONG64       ImageBase,
    DWORD         SizeOfImage,
    PMODLOAD_DATA mld,
    DWORD         CallerFlags,
    ULONG         dwFlags
    );

PIMGHLP_DEBUG_DATA
InitDebugData(
    VOID
    );

void
ReleaseDebugData(
    PIMGHLP_DEBUG_DATA,
    DWORD
    );

BOOL
IsImageMachineType64(
    DWORD MachineType
    );

ULONG
ReadImageData(
    IN  HANDLE  hprocess,
    IN  ULONG64 ul,
    IN  ULONG64 addr,
    OUT LPVOID  buffer,
    IN  ULONG   size
    );

PVOID
MapItRO(
      HANDLE FileHandle
      );

// servers.c

void
symsrvClose(
    VOID
    );

BOOL
symsrvPath(
    LPCSTR path
    );

DWORD
symsrvGetFile(
    IN  PPROCESS_ENTRY pe,
    IN  LPCSTR ServerInfo,
    IN  LPCSTR FileName,
    IN  GUID  *id,
    IN  DWORD  two,
    IN  DWORD  three,
    OUT LPSTR  FilePath
    );

DWORD
symsrvGetFileMultiIndex(
    IN  PPROCESS_ENTRY pe,
    IN  LPCSTR ServerInfo,
    IN  LPCSTR FileName,
    IN  DWORD  index1,
    IN  DWORD  index2,
    IN  DWORD  two,
    IN  DWORD  three,
    OUT LPSTR  FilePath
    );

void
symsrvClose(
    VOID
    );

void
symsrvSetOptions(
    ULONG_PTR options,
    ULONG64   data
    );

void
symsrvSetCallback(
    BOOL state
    );

void 
symsrvSetPrompts(
    VOID
    );

void symsrvSetDownstreamStore(
    char *dir
    );

BOOL
srcsrvInit(
    HANDLE hp
    );

BOOL
srcsrvCallback(
    UINT_PTR action,
    DWORD64 data,
    DWORD64 context
    );

#define gfnSrcSrvInit (g.fnSrcSrvInit)&&g.fnSrcSrvInit
#define gfnSrcSrvSetOptions (g.fnSrcSrvSetOptions)&&g.fnSrcSrvSetOptions
#define gfnSrcSrvGetOptions (g.fnSrcSrvGetOptions)&&g.fnSrcSrvGetOptions
#define gfnSrcSrvLoadModule (g.fnSrcSrvLoadModule)&&g.fnSrcSrvLoadModule
#define gfnSrcSrvUnloadModule (g.fnSrcSrvUnloadModule)&&g.fnSrcSrvUnloadModule
#define gfnSrcSrvCleanup (g.fnSrcSrvCleanup)&&g.fnSrcSrvCleanup
#define gfnSrcSrvRegisterCallback (g.fnSrcSrvRegisterCallback)&&g.fnSrcSrvRegisterCallback
#define gfnSrcSrvGetFile (g.fnSrcSrvGetFile)&&g.fnSrcSrvGetFile

#ifdef __cpluspluss
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\symbols.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    symbols.c

Abstract:

    This function implements a generic simple symbol handler.

Author:

    Wesley Witt (wesw) 1-Sep-1994

Environment:

    User Mode

--*/

#if (_WIN32_IE < 0x0400)                
 #undef _WIN32_IE                      
 #define _WIN32_IE 0x0400
#endif

#include "private.h"
#include "symbols.h"
#include "globals.h"
#include <shlobj.h>
#include <dbhpriv.h>
#include "fecache.hpp"

// common conversion routines

PSYMBOL_ENTRY
si2se(
    PSYMBOL_INFO  si,
    PSYMBOL_ENTRY se
    )
{
    se->Size       = si->SizeOfStruct;
    se->Flags      = si->Flags;
    se->Address    = si->Address;
    se->Size       = si->Size;
    if (si->Name)
        if (se->Name)
            strcpy(se->Name, si->Name); // SECURITY: Don't know size of target buffer.
        else
            se->Name = si->Name;
    se->NameLength = si->NameLen;
    // segment is not used
    // offset is not used
    se->TypeIndex  = si->TypeIndex;
    se->ModBase    = si->ModBase;
    se->Register   = si->Register;

    if (si->Register) {
        ((LARGE_INTEGER *) &se->Address)->HighPart = si->Register;
    }

    return se;
}

PSYMBOL_INFO
se2si(
    PSYMBOL_ENTRY se,
    PSYMBOL_INFO  si
    )
{
    si->Address = se->Address;
    si->Flags   = se->Flags;
    si->TypeIndex = se->TypeIndex;
    si->ModBase = se->ModBase;
    si->NameLen = se->NameLength;
    si->Size    = se->Size;
    si->Register = se->Register;
    if (se->Name && (strlen(se->Name) < si->MaxNameLen))
        CopyString(si->Name, se->Name, si->MaxNameLen);

    return si;
}


PIMAGEHLP_SYMBOL
se2sym(
    PSYMBOL_ENTRY    se,
    PIMAGEHLP_SYMBOL sym
    )
{
    assert(sym);

    sym->Address = 0;
    *sym->Name = 0;

    if (!se)
        return sym;

    sym->Address = (ULONG)se->Address;
    sym->Size    = se->Size;
    sym->Flags   = se->Flags;
    CatString(sym->Name, se->Name, sym->MaxNameLength);

    return sym;
}


PIMAGEHLP_SYMBOL64
se2lsym(
    PSYMBOL_ENTRY      se,
    PIMAGEHLP_SYMBOL64 lsym
    )
{
    assert(lsym);

    lsym->Address = 0;
    *lsym->Name = 0;

    if (!se)
        return lsym;

    lsym->Address = se->Address;
    lsym->Size    = se->Size;
    lsym->Flags   = se->Flags;
    CatString(lsym->Name, se->Name, lsym->MaxNameLength);

    return lsym;
}


PIMAGEHLP_SYMBOL
si2sym(
    PSYMBOL_INFO     si,
    PIMAGEHLP_SYMBOL sym
    )
{
    assert(sym);

    sym->Address = 0;
    *sym->Name = 0;

    if (!si)
        return sym;

    sym->Address = (ULONG)si->Address;
    sym->Size    = si->Size;
    sym->Flags   = si->Flags;
    sym->Flags ^= 0x7;     // filter out bad flags
    CatString(sym->Name, si->Name, sym->MaxNameLength);

    return ((si->Address >> 32) == 0) ? sym : NULL;
}


PIMAGEHLP_SYMBOL64
si2lsym(
    PSYMBOL_INFO       si,
    PIMAGEHLP_SYMBOL64 lsym
    )
{
    assert(lsym);

    lsym->Address = 0;
    *lsym->Name = 0;

    if (!si)
        return lsym;

    lsym->Address = si->Address;
    lsym->Size    = si->Size;
    lsym->Flags   = si->Flags;
    CatString(lsym->Name, si->Name, lsym->MaxNameLength);

    return lsym;
}


PSYMBOL_INFO
si2si(
    PSYMBOL_INFO  trg,
    PSYMBOL_INFO  src
    )
{
    ULONG len = trg->MaxNameLen;

    if (src->Name && (strlen(src->Name) < len))
    	memcpy(trg->Name, src->Name, len * sizeof(trg->Name[0]));

    *trg = *src;
    trg->MaxNameLen = len;

    return trg;
}


PIMAGEHLP_SYMBOL
lsym2sym(
    PIMAGEHLP_SYMBOL64 lsym,
    PIMAGEHLP_SYMBOL   sym
    )
{
    sym->Address = (DWORD)lsym->Address;
    sym->Size = lsym->Size;
    sym->Flags = lsym->Flags;
    sym->MaxNameLength = lsym->MaxNameLength;
    *sym->Name = 0;
    CatString(sym->Name, lsym->Name, sym->MaxNameLength);

    return ((lsym->Address >> 32) == 0) ? sym : NULL;
}


PIMAGEHLP_SYMBOL64
sym2lsym(
    PIMAGEHLP_SYMBOL   sym,
    PIMAGEHLP_SYMBOL64 lsym
    )
{
    lsym->Address = sym->Address;
    lsym->Size = sym->Size;
    lsym->Flags = sym->Flags;
    lsym->MaxNameLength = sym->MaxNameLength;
    lsym->Name[0] = 0;
    CatString(lsym->Name, sym->Name, lsym->MaxNameLength);

    return lsym;
}


PIMAGEHLP_LINE
lline2line(                     // SympConvertLine64To32(
    PIMAGEHLP_LINE64 lline,
    PIMAGEHLP_LINE   line
    )
{
    line->Key = lline->Key;
    line->LineNumber = lline->LineNumber;
    line->FileName = lline->FileName;
    line->Address = (DWORD)lline->Address;

    return ((lline->Address >> 32) == 0) ? line : NULL;
}


PIMAGEHLP_LINE64
line2lline(                     // SympConvertLine32To64(
    PIMAGEHLP_LINE   line,
    PIMAGEHLP_LINE64 lline
    )
{
    lline->Key = line->Key;
    lline->LineNumber = line->LineNumber;
    lline->FileName = line->FileName;
    lline->Address = line->Address;

    return lline;
}


// other utility routines

BOOL
GetSymNextPrev(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_SYMBOL64   Symbol,
    IN     int                  Direction
    );

typedef struct _STORE_OLD_CB {
    BOOL cb64;
    union{
        PSYM_ENUMSYMBOLS_CALLBACK   UserCallBackRoutine;
        PSYM_ENUMSYMBOLS_CALLBACK64 UserCallBackRoutine64;
    };
    PVOID         UserContext;
} STORE_OLD_CB;


BOOL
ImgHlpDummyCB(
    PSYMBOL_INFO  pSymInfo,
    ULONG         SymbolSize,
    PVOID         UserContext
    )
{
    STORE_OLD_CB *pOld = (STORE_OLD_CB *) UserContext;

    if (pSymInfo->Flags & SYMFLAG_REGREL) {
        LARGE_INTEGER li;
        li.HighPart = pSymInfo->Register;
        li.LowPart  = (ULONG) pSymInfo->Address;
        pSymInfo->Address = li.QuadPart;
    }

    if (pOld->cb64) {
        return (*pOld->UserCallBackRoutine64) (
                                            pSymInfo->Name,
                                            pSymInfo->Address,
                                            SymbolSize,
                                            pOld->UserContext );
    } else {
        return (*pOld->UserCallBackRoutine) (
                                            pSymInfo->Name,
                                            (ULONG) pSymInfo->Address,
                                            SymbolSize,
                                            pOld->UserContext );
    }
}


BOOL
TestOutputString(
    PCHAR sz
    )
{
    CHAR c;

    __try {
        c = *sz;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return false;
    }

    return true;
}


BOOL
InitOutputString(
    PCHAR sz
    )
{
    BOOL rc;

    rc = TestOutputString(sz);
    if (rc)
        *sz = 0;

    return rc;
}


char *
TokenFromSymbolPath(
    char *path,
    char *token,
    int   size
    )
{
    char *next;

    *token = 0;

    if (!path)
        return NULL;

    next = strchr(path, ';');

    if (!next)
        CopyString(token, path, size);
    else
        CopyNString(token, path, (ULONG)(next - path), size);
    trim(token);

    if (next && !*++next)
        next = NULL;

    return next;
}


BOOL
CreateSymbolPath(
    int pass,
    char *base,
    char *iext,
    char *node,
    char *ext,
    char *path,
    size_t size
    )
{
    if (!path || !base || !*base || !node || !*node || !ext || !*ext)
        return false;

    CopyString(path, base, size);
    EnsureTrailingBackslash(path);

    switch (pass)
    {
    case 1:
        // add the "symbols" directory
        CatString(path, "symbols", size);
        EnsureTrailingBackslash(path);
        // pass through
    case 2:
        // add the image extension
        CatString(path, iext, size);
        // pass through
    case 0:
        EnsureTrailingBackslash(path);
        break;
    default:
        return false;
    }

    CatString(path, node, size);
    CatString(path, ext, size);

    return true;
}


BOOL
DoEnumCallback(
    PPROCESS_ENTRY pe,
    PSYMBOL_INFO   pSymInfo,
    ULONG          SymSize,
    PROC           EnumCallback,
    PVOID          UserContext,
    BOOL           Use64,
    BOOL           UsesUnicode
    )
{
    BOOL rc = false;

    if (pSymInfo)
    {
        if (Use64 || (!UsesUnicode))
        {
            rc = (*(PSYM_ENUMERATESYMBOLS_CALLBACK)EnumCallback) (
                       pSymInfo,
                       SymSize,
                       UserContext);
        }
        else
        {
            PWSTR pszTmp = AnsiToUnicode(pSymInfo->Name);

            if (pszTmp)
            {
                strncpy(pSymInfo->Name, (LPSTR)pszTmp,  // SECURITY: Don't know size of output buffer.
                        min(pSymInfo->MaxNameLen, wcslen(pszTmp)));
                *((LPWSTR) &pSymInfo->Name[min(pSymInfo->MaxNameLen, wcslen(pszTmp)) - 1 ]) = 0;
                rc = (*(PSYM_ENUMERATESYMBOLS_CALLBACK)EnumCallback) (
                           pSymInfo,
                           SymSize,
                           UserContext );
                MemFree(pszTmp);
            }
        }
    }

    return rc;
}



void OpenLogFile(char *file)
{
    time_t stTime;
    char *szTime;

    if (g.hLog)
        return;

    g.hLog = _open(file, O_APPEND | O_CREAT | O_RDWR, S_IREAD | S_IWRITE);
    if (g.hLog == -1)
        g.hLog = 0;

    time(&stTime);
    szTime = ctime(&stTime);

    eprint("\n");
    dprint(szTime ? "new session: %s" : "new session:\n", szTime);
}


void CloseLogFile()
{
    time_t stTime;
    char *szTime;

    if (!g.hLog)
        return;

    time(&stTime);
    szTime = ctime(&stTime);

    dprint(szTime ? "closing session: %s" : "closing session:\n", szTime);

    _close(g.hLog);
    g.hLog = 0;
}


BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN LPSTR    UserSearchPath,
    IN BOOL     InvadeProcess
    )

/*++

Routine Description:

    This function initializes the symbol handler for
    a process.  The process is identified by the
    process handle passed into this function.

Arguments:

    hProcess        - Process handle.  If InvadeProcess is false
                      then this can be any unique value that identifies
                      the process to the symbol handler.

    UserSearchPath  - Pointer to a string of paths separated by semicolons.
                      These paths are used to search for symbol files.
                      The value NULL is acceptable.

    InvadeProcess   - If this is set to true then the process identified
                      by the process handle is "invaded" and it's loaded
                      module list is enumerated.  Each module is added
                      to the symbol handler and symbols are attempted
                      to be loaded.

Return Value:

    true            - The symbol handler was successfully initialized.

    false           - The initialization failed.  Call GetLastError to
                      discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY  pe;
    char log[MAX_PATH];

    __try {

        if (!g.SymInitialized) {
            g.SymInitialized = true;
            g.cProcessList = 0;
            InitializeListHead( &g.ProcessList );
        }

        *g.DebugToken = 0;
        GetEnvironmentVariable(DBGHELP_TOKEN, g.DebugToken, sizeof(g.DebugToken) / sizeof(g.DebugToken[0]));
        _strlwr(g.DebugToken);

        if (GetEnvironmentVariable("DBGHELP_LOG", log, MAX_PATH))
            OpenLogFile(log);

        if (GetEnvironmentVariable("DBGHELP_DBGOUT", log, MAX_PATH))
            g.fdbgout = true;

        if (pe = FindProcessEntry( hProcess )) {
            pe->cRefs++;
            SetLastError( ERROR_INVALID_HANDLE );
            return true;
        }

        pe = (PPROCESS_ENTRY) MemAlloc( sizeof(PROCESS_ENTRY) );
        if (!pe) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return false;
        }
        ZeroMemory( pe, sizeof(PROCESS_ENTRY) );

        pe->NextModule = NULL;
        pe->hProcess = hProcess;
        pe->pid = (int) GetPID(hProcess);
        pe->cRefs = 1;
        g.cProcessList++;
        InitializeListHead( &pe->ModuleList );
        InsertTailList( &g.ProcessList, &pe->ListEntry );

        if (!SymSetSearchPath( hProcess, UserSearchPath )) {
            //
            // last error code was set by SymSetSearchPath, so just return
            //
            SymCleanup( hProcess );
            return false;
        }

        if (!diaInit()) {
            SymCleanup( hProcess );
            return false;
        }

        if (InvadeProcess) {
            DWORD DosError = GetProcessModules(hProcess, GetModule, NULL);
            if (DosError) {
                SymCleanup( hProcess );
                SetLastError( DosError );
                return false;
            }
        }

        srcsrvInit(hProcess);


    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}


BOOL
IMAGEAPI
lSymCleanup(
    HANDLE hProcess
    )

/*++

Routine Description:

    This function cleans up the symbol handler's data structures
    for a previously initialized process.

Arguments:

    hProcess        - Process handle.

Return Value:

    true            - The symbol handler was successfully cleaned up.

    false           - The cleanup failed.  Call GetLastError to
                      discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY pe;
    PLIST_ENTRY    next;
    PMODULE_ENTRY  mi;
    PSOURCE_HINT   sh;
    PSOURCE_HINT   shnext;
    BOOL           rc = true;

    HeapDump("SymCleanup(before cleanup)\n");

    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return false;
        }

        if (--pe->cRefs)
            return true;

        next = pe->ModuleList.Flink;
        if (next) {
            while (next != &pe->ModuleList) {
                mi = CONTAINING_RECORD(next, MODULE_ENTRY, ListEntry);
                next = mi->ListEntry.Flink;
                FreeModuleEntry(pe, mi);
            }
        }

        for (sh = pe->SourceHints; sh; sh = shnext) {
            shnext = sh->next;
            MemFree(sh->filename);
            MemFree(sh);
        }

        symsrvClose();

        MemFree(pe->SymbolSearchPath);

        RemoveEntryList(&pe->ListEntry);
        MemFree(pe);
        g.cProcessList--;

        diaCleanup();

        // Assume that things are shutting down and
        // dump all the function entry caches.
        ClearFeCaches();

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        rc = false;
    }

    HeapDump("SymCleanup(after cleanup)\n");
    gfnSrcSrvCleanup(hProcess);
    CloseLogFile();

    return rc;
}


BOOL
IMAGEAPI
SymCleanup(
    HANDLE hProcess
    )
{
    BOOL rc = false;

    __try {

        EnterCriticalSection(&g.threadlock);
        rc = lSymCleanup(hProcess);

    } __finally  {

        LeaveCriticalSection(&g.threadlock);
    }

    return rc;
}


BOOL
IMAGEAPI
SymSetParentWindow(
    HWND hwnd
    )
{
    g.hwndParent = hwnd;
    symsrvSetPrompts();

    return true;
}


BOOL IsDirectoryWritable(char *dir)
{
    char fname[MAX_PATH + 1];

    if (!GetTempFileName(dir, "DBG", 0, fname))
        return false;
    
    DeleteFile(fname);
    return true;
}

typedef BOOL (*SHGETSPECIALFOLDERPATHA)(HWND, LPSTR, int, BOOL);

BOOL GetCommonAppDataDirectory(char *dir)
{
    char path[MAX_PATH + 1];
    static HMODULE hShell32 = 0;
    static SHGETSPECIALFOLDERPATHA fnSHGetSpecialFolderPathA = NULL;
    
    assert(dir);

    if (!hShell32) {
        hShell32 = LoadLibrary("shell32.dll");
        if (hShell32) 
            fnSHGetSpecialFolderPathA = (SHGETSPECIALFOLDERPATHA)GetProcAddress(hShell32, "SHGetSpecialFolderPathA");
        else
            hShell32 = (HMODULE)INVALID_HANDLE_VALUE;
    }

    if (hShell32 == (HMODULE)INVALID_HANDLE_VALUE)
        return false;
    if (!fnSHGetSpecialFolderPathA)
        return false;

    if (!fnSHGetSpecialFolderPathA(NULL, path, CSIDL_COMMON_APPDATA, false))
        return false;

    CopyString(dir, path, MAX_PATH + 1);
    EnsureTrailingBackslash(dir);
    CatString(dir, "dbg", MAX_PATH + 1);
    
    if (!CreateDirectory(dir, NULL)) {
        if( GetLastError() != ERROR_ALREADY_EXISTS ) 
            return false;
    }

    return true;
}


PCHAR IMAGEAPI SymSetHomeDirectory(PCSTR dir)
{
    char dstore[MAX_PATH + 1] = "";
    static char homedir[MAX_PATH + 1] = "";

    // If a valid new directory is passed, use it.
    // Otherwise, if the home directory has not
    // been initialized, do so.

    *homedir = 0;
    if (dir && *dir) 
    {
        CopyStrArray(homedir, dir);
    } 
    else if (!*g.HomeDir) 
    {
        char path[MAX_PATH + 1];
        char drive[_MAX_DRIVE + 1];
        char dir[_MAX_DIR + 1];
        if (GetModuleFileName(NULL, path, DIMA(path))) {
            _splitpath(path, drive, dir, NULL, NULL);
            CopyStrArray(path, drive);
            CatStrArray(path, dir);
            RemoveTrailingBackslash(path);
            CopyStrArray(homedir, path);
        } 
    }
    
    // If the home directory was changed, set it
    // and the new default downstream store.

    if (*homedir) 
    {
        if (!IsDirectoryWritable(homedir)) {
            if(!GetCommonAppDataDirectory(homedir)) {
                CopyStrArray(homedir, g.HomeDir);
                return homedir;
            }
        }

        CopyStrArray(g.HomeDir, homedir);

        CopyStrArray(g.SymDir, homedir);
        EnsureTrailingBackslash(g.SymDir);
        CatStrArray(g.SymDir, "sym");
        symsrvSetDownstreamStore(g.SymDir);
    } else
        CopyStrArray(homedir, g.HomeDir);

    // Return the current home directory.

    return homedir;
}


PCHAR
IMAGEAPI
SymGetHomeDirectory(
    DWORD  type,
    PSTR   dir,
    size_t size
    )
{
    char *tdir;
    static char sz[MAX_PATH + 1];

    if (!dir || type >= hdMax) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL; 
    }

    switch(type)
    {
    case hdBase:
        tdir = g.HomeDir;
        break;
    case hdSym:
        tdir = g.SymDir;
        break;
    case hdSrc:
        tdir = g.SrcDir;
        break;
    }

    if (strlen(tdir) >= size) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return NULL;
    }

    CopyString(dir, tdir, size);

    return dir;
}


DWORD
IMAGEAPI
SymSetOptions(
    DWORD   UserOptions
    )

/*++

Routine Description:

    This function changes the symbol handler's option mask.

Arguments:

    UserOptions     - The new options mask.

Return Value:

    The new mask is returned.

--*/

{
    BOOL  symsdebug;
    DWORD srcsopts;
    BOOL  secure;

    secure = option(SYMOPT_SECURE);
    g.SymOptions = UserOptions;

    srcsopts = (g.fnSrcSrvGetOptions) ? gfnSrcSrvGetOptions() : 0;
    if (option(SYMOPT_DEBUG)) {
        srcsopts |= SRCSRVOPT_DEBUG;
        symsdebug = true;
    } else {
        srcsopts &= ~SRCSRVOPT_DEBUG;
        symsdebug = false;
    }
    gfnSrcSrvSetOptions(srcsopts);

    symsrvSetCallback((symsdebug || g.hLog) ? true : false);

    if (!secure) {
        if (option(SYMOPT_SECURE))
            symsrvSetOptions(SSRVOPT_SECURE, 1);
    } else if (!option(SYMOPT_SECURE))
        g.SymOptions |= SYMOPT_SECURE;

    DoCallback(NULL, CBA_SET_OPTIONS, &g.SymOptions);
    return g.SymOptions;
}


DWORD
IMAGEAPI
SymGetOptions(
    VOID
    )

/*++

Routine Description:

    This function queries the symbol handler's option mask.

Arguments:

    None.

Return Value:

    The current options mask is returned.

--*/

{
    return g.SymOptions;
}


BOOL
IMAGEAPI
SymSetContext(
    HANDLE hProcess,
    PIMAGEHLP_STACK_FRAME StackFrame,
    PIMAGEHLP_CONTEXT Context
    )
{
    PPROCESS_ENTRY pe;

    pe = FindProcessEntry(hProcess);
    if (!pe)
        return false;

    pe->pContext = Context;
    pe->StackFrame = *StackFrame;

    return diaSetModFromIP(pe);
};


BOOL
SympEnumerateModules(
    IN HANDLE   hProcess,
    IN PROC     EnumModulesCallback,
    IN PVOID    UserContext,
    IN BOOL     Use64
    )

/*++

Routine Description:

    This is the worker function for the 32 and 64 bit versions.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    EnumModulesCallback - Callback pointer that is called once for each
                          module that is enumerated.  If the enum callback
                          returns false then the enumeration is terminated.

    UserContext         - This data is simply passed on to the callback function
                          and is completly user defined.

    Use64               - Supplies flag which determines whether to use the 32 bit
                          or 64 bit callback prototype.

Return Value:

    true                - The modules were successfully enumerated.

    false               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY  pe;
    PMODULE_ENTRY   mi;
    PLIST_ENTRY     Next;


    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return false;
        }

        Next = pe->ModuleList.Flink;
        if (Next) {
            while (Next != &pe->ModuleList) {
                mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = mi->ListEntry.Flink;
                if (Use64) {
                    if ( !(*(PSYM_ENUMMODULES_CALLBACK64)EnumModulesCallback) (
                            mi->ModuleName,
                            mi->BaseOfDll,
                            UserContext
                            )) {
                        break;
                    }
                } else {
                    if ( !(*(PSYM_ENUMMODULES_CALLBACK)EnumModulesCallback) (
                            mi->ModuleName,
                            (DWORD)mi->BaseOfDll,
                            UserContext
                            )) {
                        break;
                    }
                }
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}


BOOL
dbhfnModSymInfo(
    IN     HANDLE          hp,
    IN OUT PDBH_MODSYMINFO p
    )
{
    PMODULE_ENTRY  mi;
    PPROCESS_ENTRY pe;

    assert(p->function == dbhModSymInfo);

    pe = FindProcessEntry(hp);
    if (!pe) {
        SetLastError( ERROR_INVALID_HANDLE );
        return false;
    }

    if (p->sizeofstruct != sizeof(DBH_MODSYMINFO)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return false;
    }

    mi = GetModuleForPC(pe, p->addr, false);
    if (!mi) {
        SetLastError(ERROR_MOD_NOT_FOUND);
        return false;
    }

    p->type = mi->SymType;
    *p->file = 0;
    switch (p->type)
    {
    case SymPdb:
    case SymDia:
        if (mi->LoadedPdbName)
            CopyStrArray(p->file, mi->LoadedPdbName);
        break;
    default:
        if (mi->LoadedImageName)
            CopyStrArray(p->file, mi->LoadedImageName);
        break;
    }

    return true;
}


BOOL
dbhfnDiaVersion(
    IN OUT PDBH_DIAVERSION p
    )
{
    PMODULE_ENTRY mi;

    assert(p->function == dbhDiaVersion);

    if (p->sizeofstruct != sizeof(DBH_DIAVERSION)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return false;
    }

    p->ver = diaVersion();

    return true;
}


BOOL
dbhfnLoadPdb(
    IN OUT PDBH_LOADPDB p
    )
{
    PIMGHLP_DEBUG_DATA idd;
    MODLOAD_DATA mld;
    int i;

    idd = InitIDD(
        (HANDLE)6969,
        0,
        p->pdb,
        NULL,
        100000,
        0,
        &mld,
        0,
        0);

    if (!idd)
        return false;

    CopyString(idd->PdbFileName, p->pdb, MAX_PATH + 1);

    for (i = 0; i < 1000; i++) {
        dtrace("%d ", i);
        diaGetPdb(idd);
        if (idd->dia)
            diaRelease(idd->dia);
        idd->dia = NULL;
    }

    ReleaseDebugData(idd, IMGHLP_FREE_STANDARD);

    return true;
}


BOOL
IMAGEAPI
dbghelp(
    IN     HANDLE hp,
    IN OUT PVOID  data
    )
{
    DWORD *function;

    if (!data) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return false;
    }

    __try {

        function = (DWORD *)data;
        switch (*function)
        {
        case dbhModSymInfo:
            return dbhfnModSymInfo(hp, (PDBH_MODSYMINFO)data);

        case dbhDiaVersion:
            return dbhfnDiaVersion((PDBH_DIAVERSION)data);

        case dbhLoadPdb:
            return dbhfnLoadPdb((PDBH_LOADPDB)data);

        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return false;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return false;

    }

    return false;
}


BOOL
IMAGEAPI
SymEnumerateModules(
    IN HANDLE                      hProcess,
    IN PSYM_ENUMMODULES_CALLBACK EnumModulesCallback,
    IN PVOID                       UserContext
    )

/*++

Routine Description:

    This function enumerates all of the modules that are currently
    loaded into the symbol handler.  This is the 32 bit wrapper.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    EnumModulesCallback - Callback pointer that is called once for each
                          module that is enumerated.  If the enum callback
                          returns false then the enumeration is terminated.

    UserContext         - This data is simply passed on to the callback function
                          and is completly user defined.

Return Value:

    true                - The modules were successfully enumerated.

    false               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/
{
    return SympEnumerateModules(hProcess, (PROC)EnumModulesCallback, UserContext, false);
}


BOOL
IMAGEAPI
SymEnumerateModules64(
    IN HANDLE   hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback,
    IN PVOID    UserContext
    )

/*++

Routine Description:

    This function enumerates all of the modules that are currently
    loaded into the symbol handler.  This is the 64 bit wrapper.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    EnumModulesCallback - Callback pointer that is called once for each
                          module that is enumerated.  If the enum callback
                          returns false then the enumeration is terminated.

    UserContext         - This data is simply passed on to the callback function
                          and is completly user defined.

Return Value:

    true                - The modules were successfully enumerated.

    false               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/
{
    return SympEnumerateModules(hProcess, (PROC)EnumModulesCallback, UserContext, true);
}

DWORD
CalcItemSize(
    PDWORD64 pAddr,
    PDWORD64 pAddrsBase,
    UINT_PTR count
    )
{
    PDWORD64 p;
    PDWORD64 pAddrEnd;

    if (!pAddr)
        return 0;

    pAddrEnd = pAddrsBase + count;

    for (p = pAddr + 1; p <= pAddrEnd; p++) {
        if (*p != *pAddr)
            return (DWORD)(*p - *pAddr);
    }

    return 0;
}


BOOL
MatchModuleName(
    PMODULE_ENTRY mi,
    LPSTR         mask
    )
{
    if (!strcmpre(mi->AliasName, mask, false))
        return true;

    if (!strcmpre(mi->ModuleName, mask, false))
        return true;

    return false;
}


BOOL
SympEnumerateSymbols(
    IN HANDLE  hProcess,
    IN ULONG64 BaseOfDll,
    IN LPSTR   Mask,
    IN PROC    EnumSymbolsCallback,
    IN PVOID   UserContext,
    IN BOOL    Use64,
    IN BOOL    CallBackUsesUnicode
    )

/*++

Routine Description:

    This function enumerates all of the symbols contained the module
    specified by the BaseOfDll argument.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize

    BaseOfDll           - Base address of the DLL that symbols are to be
                          enumerated for

    EnumSymbolsCallback - User specified callback routine for enumeration
                          notification

    UserContext         - Pass thru variable, this is simply passed thru to the
                          callback function

    Use64               - Supplies flag which determines whether to use the 32 bit
                          or 64 bit callback prototype.

Return Value:

    true                - The symbols were successfully enumerated.

    false               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       mi;
    DWORD               i;
    PSYMBOL_ENTRY       sym;
    char                buf[2500];
    LPSTR               p;
    CHAR                modmask[200];
    BOOL                rc;
    int                 pass;
    BOOL                fCase;
    PSYMBOL_INFO        si;
    char                match[MAX_SYM_NAME + 100];

    static DWORD        flags[2] = {LS_JUST_TEST, LS_QUALIFIED | LS_FAIL_IF_LOADED};

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return false;
        }

        p = 0;
        modmask[0] = 0;
        if (Mask)
            p = strchr(Mask, '!');
        if (p > Mask) {
            memcpy(modmask, Mask, (int)(p - Mask));
            modmask[p-Mask] = 0;
            Mask = p + 1;
        } else if (!BaseOfDll) {
            // search is scoped to current scope
            rc = diaEnumerateSymbols(pe,
                                     NULL,
                                     Mask,
                                     EnumSymbolsCallback,
                                     UserContext,
                                     Use64,
                                     CallBackUsesUnicode);
            if (!rc && pe->ipmi && pe->ipmi->code == ERROR_CANCELLED) {
                pe->ipmi->code = 0;
                return true;
            }
            return rc;
        }

        if (Mask && *Mask)
            PrepRE4Srch(Mask, match);
        else
            *match = 0;

        for (pass = 0; pass < 2; pass++) {
            Next = pe->ModuleList.Flink;
            if (Next) {
                while (Next != &pe->ModuleList) {

                    mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                    Next = mi->ListEntry.Flink;
                    if (BaseOfDll) {
                        if (mi->BaseOfDll != BaseOfDll)
                            continue;
                    } else if (!MatchModuleName(mi, modmask)) {
                        continue;
                    }

                    if (!LoadSymbols(hProcess, mi, flags[pass])) {
                        if (GetLastError() == ERROR_CANCELLED)
                            return false;
                        continue;
                    }

                    if (mi->dia) {
                        rc = diaEnumerateSymbols(pe,
                                                 mi,
                                                 Mask,
                                                 EnumSymbolsCallback,
                                                 UserContext,
                                                 Use64,
                                                 CallBackUsesUnicode);
                    }

                    if (mi->numsyms) {
                        fCase = option(SYMOPT_CASE_INSENSITIVE) ? false : true;

                        si = (PSYMBOL_INFO)buf;
                        ZeroMemory(buf, sizeof(buf));
                        si->MaxNameLen  = sizeof(buf) - sizeof(SYMBOL_INFO);

                        for (i = 0; i < mi->numsyms; i++) {
                            sym = &mi->symbolTable[i];
                            if (*match && strcmpre(sym->Name, match, fCase))
                                continue;
                            se2si(sym, si);
                            si->ModBase = mi->BaseOfDll;
                            if (!DoEnumCallback(
                                       pe,
                                       si,
                                       si->Size,
                                       EnumSymbolsCallback,
                                       UserContext,
                                       Use64,
                                       CallBackUsesUnicode)) {
                                break;
                            }
                        }
                    }

                    rc = vsEnumSymbols(pe,
                                       mi,
                                       Mask,
                                       EnumSymbolsCallback,
                                       UserContext,
                                       Use64,
                                       CallBackUsesUnicode);
                    if (!rc) {
                        if (mi->code == ERROR_CANCELLED) {
                            mi->code = 0;
                            return true;
                        }
                        return rc;
                    }
                }
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}

BOOL
IMAGEAPI
SymEnumerateSymbols(
    IN HANDLE                       hProcess,
    IN ULONG                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )

/*++

Routine Description:

    This function enumerates all of the symbols contained the module
    specified by the BaseOfDll argument.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize

    BaseOfDll           - Base address of the DLL that symbols are to be
                          enumerated for

    EnumSymbolsCallback - User specified callback routine for enumeration
                          notification

    UserContext         - Pass thru variable, this is simply passed thru to the
                          callback function

Return Value:

    true                - The symbols were successfully enumerated.

    false               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/
{
    STORE_OLD_CB OldCB;

    OldCB.UserCallBackRoutine = EnumSymbolsCallback;
    OldCB.UserContext = UserContext;
    OldCB.cb64 = false;
    return SympEnumerateSymbols(hProcess,
                                    BaseOfDll,
                                    NULL,
                                    (PROC) (EnumSymbolsCallback ? &ImgHlpDummyCB : NULL),
                                    (PVOID) &OldCB,
                                    false,
                                    false);

}

BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN ULONG                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    STORE_OLD_CB OldCB;

    OldCB.UserCallBackRoutine = (PSYM_ENUMSYMBOLS_CALLBACK) EnumSymbolsCallback;
    OldCB.UserContext = UserContext;
    OldCB.cb64 = false;

    return SympEnumerateSymbols(hProcess,
                                    BaseOfDll,
                                    NULL,
                                    (PROC) (EnumSymbolsCallback ? &ImgHlpDummyCB : NULL),
                                    (PVOID) &OldCB,
                                    false,
                                    false);

}

BOOL
IMAGEAPI
SymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    STORE_OLD_CB OldCB;

    OldCB.UserCallBackRoutine64 = EnumSymbolsCallback;
    OldCB.UserContext = UserContext;
    OldCB.cb64 = true;

    return SympEnumerateSymbols(hProcess,
                                    BaseOfDll,
                                    NULL,
                                    (PROC) (EnumSymbolsCallback ? &ImgHlpDummyCB : NULL),
                                    (PVOID) &OldCB,
                                    false,
                                    false);
}

BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    STORE_OLD_CB OldCB;

    OldCB.UserCallBackRoutine64 = (PSYM_ENUMSYMBOLS_CALLBACK64) EnumSymbolsCallback;
    OldCB.UserContext = UserContext;
    OldCB.cb64 = true;

    return SympEnumerateSymbols(hProcess,
                                    BaseOfDll,
                                    NULL,
                                    (PROC) (EnumSymbolsCallback ? &ImgHlpDummyCB : NULL),
                                    (PVOID) &OldCB,
                                    false,
                                    false);

}

PSYMBOL_INFO
SympGetSymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on an address.
    This is the common worker function for the 32 and 64 bit API.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Address             - Address of the desired symbol.


    Displacement        - This value is set to the offset from the beginning
                          of the symbol.

Return Value:

    PSYMBOL_INFO        - relevent symbol information

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSYMBOL_INFO        si;

    BOOL rc;

    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe)
            return (PSYMBOL_INFO)(ULONG_PTR)error(ERROR_INVALID_HANDLE);

        mi = GetModuleForPC(pe, Address, false);
        if (!mi)
            return (PSYMBOL_INFO)(ULONG_PTR)error(ERROR_MOD_NOT_FOUND);

        if (!LoadSymbols(hProcess, mi, 0))
            return (PSYMBOL_INFO)(ULONG_PTR)error(ERROR_MOD_NOT_FOUND);

#ifdef DEBUGSYMTAG
        si = GetSymFromAddrByTag( Address, SymTagAnnotation, Displacement, mi );
        if (si)
            dprint("ANNOTATION: %xI64x %s %x\n", si->Address, si->Name, Displacement);
#endif

        si = GetSymFromAddr( Address, Displacement, mi );
        if (!si)
            return (PSYMBOL_INFO)(ULONG_PTR)error(ERROR_INVALID_ADDRESS);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return NULL;

    }

#if 0
    if (_stricmp(mi->ModuleName, "symstore"))
        return si;
    char sz[MAX_PATH + 1];
    SymGetSourceFile(hProcess, Address, "d:\\db\\symsrv\\symstore\\symstore.cpp", sz);
#endif
    return si;
}

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on an address.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Address             - Address of the desired symbol.


    Displacement        - This value is set to the offset from the beginning
                          of the symbol.

    Symbol              - Returns the found symbol

Return Value:

    true - The symbol was located.

    false - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    PSYMBOL_INFO si;

    si = SympGetSymFromAddr(hProcess, Address, Displacement);
    if (!si)
        return false;

    si2lsym(si, Symbol);

    return true;
}

BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD               Address,
    OUT PDWORD              Displacement,
    OUT PIMAGEHLP_SYMBOL    Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on an address.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Address             - Address of the desired symbol.


    Displacement        - This value is set to the offset from the beginning
                          of the symbol.

    Symbol              - Returns the found symbol

Return Value:

    true - The symbol was located.

    false - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    PSYMBOL_INFO si;
    DWORD64 qDisplacement;

    si = SympGetSymFromAddr(hProcess, Address, &qDisplacement);
    if (!si)
        return false;

    si2sym(si, Symbol);
    if (Displacement)
        *Displacement = (DWORD)qDisplacement;

    return true;
}


PSYMBOL_INFO
SympGetSymFromName(
    IN  HANDLE          hProcess,
    IN  LPSTR           Name
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on a name.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    SymName             - A string containing the symbol name.

    sym                 - Returns the located symbol

Return Value:

    true - The symbol was located.

    false - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/

{
    LPSTR               p;
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi = NULL;
    PLIST_ENTRY         Next;
    IMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl64;
    int                 pass;
    PSYMBOL_INFO        si;

    static DWORD        flags[2] = {LS_JUST_TEST, LS_QUALIFIED};

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return false;
        }

        // first check for fully qualified symbol name I.E. mod!sym

        p = strchr( Name, '!' );
        if (p > Name) {

            LPSTR ModName = (LPSTR)MemAlloc(p - Name + 1);
            if (!ModName) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return false;
            }
            memcpy(ModName, Name, (int)(p - Name));
            ModName[p-Name] = 0;

            //
            // the caller wants to look in a specific module
            //

            mi = FindModule(hProcess, pe, ModName, true);

            MemFree(ModName);

            if (mi != NULL) {
                si = FindSymbolByName( pe, mi, p+1 );
                if (si)
                    return si;
            }

            SetLastError( ERROR_MOD_NOT_FOUND );
            return false;
        }

        // now check, using context information

        si = FindSymbolByName( pe, NULL, Name );
        if (si)
            return si;

        // now just look in every module

        for (pass = 0; pass < 2; pass++) {
            Next = pe->ModuleList.Flink;
            while (Next != &pe->ModuleList) {
                mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = mi->ListEntry.Flink;

                if (!LoadSymbols(hProcess, mi, flags[pass])) {
                    if (GetLastError() == ERROR_CANCELLED)
                        return false;
                    continue;
                }

                si = FindSymbolByName( pe, mi, Name );
                if (si)
                    return si;
            }
        }

        SetLastError( ERROR_MOD_NOT_FOUND );
        return false;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    SetLastError( ERROR_INVALID_FUNCTION );
    return NULL;
}


BOOL
IMAGEAPI
SymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on a name.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    SymName             - A string containing the symbol name.

    Symbol              - Returns found symbol

Return Value:

    true - The symbol was located.

    false - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    PSYMBOL_INFO si;

    si = SympGetSymFromName(hProcess, Name);
    if (!si)
        return false;

    si2lsym(si, Symbol);

    return true;
}

BOOL
IMAGEAPI
SymGetSymFromName(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on a name.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    SymName             - A string containing the symbol name.

    Symbol              - Returns found symbol

Return Value:

    true - The symbol was located.

    false - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    PSYMBOL_INFO si;

    si = SympGetSymFromName(hProcess, Name);
    if (!si)
        return false;

    si2sym(si,Symbol);

    return true;
}


BOOL
IMAGEAPI
SymGetSymNext(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol32
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PIMAGEHLP_SYMBOL64 Symbol64;
    BOOL rc = false;

    Symbol64 = (PIMAGEHLP_SYMBOL64)MemAlloc(sizeof(IMAGEHLP_SYMBOL64) + Symbol32->MaxNameLength);

    if (Symbol64) {
        sym2lsym(Symbol32, Symbol64);
        if (SymGetSymNext64(hProcess, Symbol64)) {
            lsym2sym(Symbol64, Symbol32);
            rc = true;
        }

        MemFree(Symbol64);
    }
    return rc;
}


BOOL
IMAGEAPI
SymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    return GetSymNextPrev(hProcess, Symbol, 1);
}

BOOL
IMAGEAPI
SymGetSymPrev(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol32
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PIMAGEHLP_SYMBOL64 Symbol64;
    BOOL rc = false;

    Symbol64 = (PIMAGEHLP_SYMBOL64)MemAlloc(sizeof(IMAGEHLP_SYMBOL64) + Symbol32->MaxNameLength);

    if (Symbol64) {
        sym2lsym(Symbol32, Symbol64);
        if (SymGetSymPrev64(hProcess, Symbol64)) {
            lsym2sym(Symbol64, Symbol32);
            rc = true;
        }
        MemFree(Symbol64);
    }
    return rc;
}

BOOL
IMAGEAPI
SymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    return GetSymNextPrev(hProcess, Symbol, -1);
}


BOOL
GetSymNextPrev(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_SYMBOL64   Symbol,
    IN     int                  Direction
    )

/*++

Routine Description:

    Common code for SymGetSymNext and SymGetSymPrev.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

    Dir                 - Supplies direction to search

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    ULONG64             disp;
    ULONG64             addr;
    PSYMBOL_INFO        si;
    PSYMBOL_INFO        vssi;
    PSYMBOL_ENTRY       se;
    SYMBOL_ENTRY SymEntry = {0};

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return false;
        }

        mi = GetModuleForPC( pe, Symbol->Address, false );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return false;
        }

        if (!LoadSymbols(hProcess, mi, 0)) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return false;
        }

        addr = Symbol->Address;

        if (mi->dia) {

            si = diaGetSymNextPrev(mi, addr, Direction);
            vssi = vsGetSymNextPrev(mi, addr, Direction);
            si2lsym(si, Symbol);

        } else {

            se = cvGetSymFromAddr(addr, &disp, mi);
            if (se) {
                if (Direction > 0 && se+1 >= mi->symbolTable+mi->numsyms) {
                    se = NULL;
                } else if (Direction < 0 && se-1 < mi->symbolTable) {
                    se = NULL;
                }
                se += Direction;
            }
            se2lsym(se, Symbol);
        }

        vssi = vsGetSymNextPrev(mi, addr, Direction);
        if (vssi) {
            if (Symbol->Address) {
                if (Direction > 0) {
                    if (vssi->Address < Symbol->Address)
                        si2lsym(vssi, Symbol);
                } else if (Symbol->Address < vssi->Address) {
                    si2lsym(vssi, Symbol);
                }
            } else {
                si2lsym(vssi, Symbol);
            }
        }

        if (!Symbol->Address) {
            SetLastError(ERROR_INVALID_ADDRESS);
            return false;
        }

        return true;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return false;
}


BOOL
IMAGEAPI
SymGetSourceFile(
    IN  HANDLE  hProcess,
    IN  ULONG64 Base,
    IN  LPCSTR  FileSpec,
    OUT LPSTR   FilePath
    )
{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY  mi;
    PBYTE          stream;

    if (!FileSpec || !*FileSpec || !FilePath)
        return error(ERROR_INVALID_PARAMETER);

    if (!g.fnSrcSrvInit)
        return false;

    pe = FindProcessEntry(hProcess);
    if (!pe)
        return error(ERROR_INVALID_HANDLE);

    mi = GetModuleForPC(pe, Base, false);
    if (!mi)
        return error(ERROR_MOD_NOT_FOUND);

    if (!LoadSymbols(hProcess, mi, 0))
        return error(ERROR_MOD_NOT_FOUND);

    if (mi->cbSrcSrv == -1)
        return error(ERROR_NOT_SUPPORTED);

    if (!mi->cbSrcSrv) {
        diaReadStream(mi, "srcsrv", &stream, &mi->cbSrcSrv);
        if (mi->cbSrcSrv)
            gfnSrcSrvLoadModule(pe->hProcess,
                                (*mi->AliasName) ? mi->AliasName : mi->ModuleName,
                                mi->BaseOfDll,
                                stream,
                                mi->cbSrcSrv);
        MemFree(stream);
    }
    if (!mi->cbSrcSrv) {
        mi->cbSrcSrv = -1;
        return error(ERROR_NOT_SUPPORTED);
    }

    return gfnSrcSrvGetFile(pe->hProcess, mi->BaseOfDll, FileSpec, FilePath);
}


BOOL
IMAGEAPI
SymEnumLines(
    IN  HANDLE  hProcess,
    IN  ULONG64 Base,
    IN  PCSTR   Obj,
    IN  PCSTR   File,
    IN  PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    IN  PVOID   UserContext
    )
{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY  mi;

    __try {
        pe = FindProcessEntry(hProcess);
        if (!pe)
            return error(ERROR_INVALID_HANDLE);

        mi = GetModuleForPC(pe, Base, false);
        if (!mi)
            return error(ERROR_MOD_NOT_FOUND);

        if (!LoadSymbols(hProcess, mi, 0))
            return error(ERROR_MOD_NOT_FOUND);

        if (!mi->dia)
            return error(ERROR_NOT_SUPPORTED);

        return diaEnumLines(pe, mi, Obj, File, EnumLinesCallback, UserContext);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return false;
    }

    return true;
}


BOOL
IMAGEAPI
SymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 dwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    )

/*++

Routine Description:

    This function finds a source file and line number entry for the
    line closest to the given address.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    dwAddr              - Supplies an address for which a line is to be
                          located.

    pdwDisplacement     - Returns the offset between the given address
                          and the first instruction of the line.

    Line                - Returns the line and file information.

Return Value:

    true                - A line was located.

    false               - The line was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY  mi;
    SRCCODEINFO    sci;

    sciInit(&sci);

    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64))
            return error(ERROR_INVALID_PARAMETER);

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error( ERROR_INVALID_HANDLE );

        mi = GetModuleForPC( pe, dwAddr, false );
        if (!mi)
            return error( ERROR_MOD_NOT_FOUND );

        if (!LoadSymbols(hProcess, mi, 0))
            return error( ERROR_MOD_NOT_FOUND );

        if (!GetLineFromAddr(pe, mi, dwAddr, pdwDisplacement, &sci))
            return error( ERROR_INVALID_ADDRESS );

        sci2lline(mi, &sci, Line);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}

BOOL
IMAGEAPI
SymGetLineFromAddr(
    IN  HANDLE                  hProcess,
    IN  DWORD                   dwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    if (SymGetLineFromAddr64(hProcess, dwAddr, pdwDisplacement, &Line64)) {
        lline2line(&Line64, Line32);
        return true;
    } else {
        return false;
    }
}


BOOL
IMAGEAPI
SymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     LPSTR                ModuleName,
    IN     LPSTR                FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line64
    )

/*++

Routine Description:

    This function finds an entry in the source file and line-number
    information based on a particular filename and line number.

    A module name can be given if the search is to be restricted to
    a specific module.

    The filename can be omitted if a pure line number search is desired,
    in which case Line must be a previously filled out line number
    struct.  The module and file that Line->Address lies in is used
    to look up the new line number.  This cannot be used when a module
    name is given.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    ModuleName          - Module name or NULL.

    FileName            - File name or NULL.

    dwLineNumber        - Line number of interest.

    plDisplacement      - Difference between requested line number and
                          returned line number.

    Line                - Line information input and return.

Return Value:

    true                - A line was located.

    false               - A line was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi = NULL;
    PLIST_ENTRY         Next;
    IMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl64;
    int                 i;
    PSOURCE_HINT        sh;
    char                fname[MAX_PATH + 1];
    SRCCODEINFO         sci;
    SRCCODEINFO         tsci;

    static DWORD        flags[3] = {LS_JUST_TEST, LS_QUALIFIED | LS_LOAD_LINES, LS_QUALIFIED | LS_LOAD_LINES};
    static DWORD        method[3] = {mFullPath, mFullPath, mName};

    sciInit(&sci);
    sciInit(&tsci);

    __try {
        if (Line64->SizeOfStruct != sizeof(IMAGEHLP_LINE64))
            return error(ERROR_INVALID_PARAMETER);

        // If no file was given then it's assumed that the file
        // is the same as for the line information passed in.

        if (FileName)
            CopyStrArray(fname, FileName);
        else
            CopyStrArray(fname, Line64->FileName ? Line64->FileName : "");

        // get the process

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error( ERROR_INVALID_HANDLE );

        if (ModuleName != NULL) {

            //
            // The caller wants to look in a specific module.
            // A filename must be given in this case because it doesn't
            // make sense to do an address-driven search when a module
            // is explicitly specified since the address also specifies
            // a module.
            //

            if (!*fname)
                return error(ERROR_INVALID_PARAMETER);

            mi = FindModule(hProcess, pe, ModuleName, true);
            if (mi) {
                if (GetLineFromName(pe, mi, fname, dwLineNumber, plDisplacement, &sci, mFullPath))
                    return sci2lline(mi, &sci, Line64);
                if (GetLineFromName(pe, mi, fname, dwLineNumber, plDisplacement, &sci, mName))
                    return sci2lline(mi, &sci, Line64);
                return error(ERROR_NOT_FOUND);
            }

            return error( ERROR_MOD_NOT_FOUND );
        }

        if (!*fname) {
            // Only a line number has been given, implying that
            // it's a line in the same file as the given line is currently in.

            mi = GetModuleForPC( pe, Line64->Address, false );
            if (!mi)
                return error( ERROR_MOD_NOT_FOUND );

            if (!LoadSymbols(hProcess, mi, LS_LOAD_LINES))
                return error( ERROR_MOD_NOT_FOUND );

            if (GetLineFromName(pe, mi, fname, dwLineNumber, plDisplacement, &sci, mFullPath))
                return sci2lline(mi, &sci, Line64);
            if (GetLineFromName(pe, mi, fname, dwLineNumber, plDisplacement, &sci, mName))
                return sci2lline(mi, &sci, Line64);

            return error(ERROR_NOT_FOUND);
        }

        sh = FindSourceFileInHintList(pe, fname);
        if (sh) {
            if (GetLineFromName(pe, sh->mi, fname, dwLineNumber, plDisplacement, &sci, mFullPath))
                return sci2lline(sh->mi, &sci, Line64);
        }

        Next = pe->ModuleList.Flink;
        if (!Next)
            return error( ERROR_MOD_NOT_FOUND );

        ClearModuleFlags(pe);
        ZeroMemory(&sci, sizeof(sci));

        // Search for lines in 3 passes.
        //
        // 0. Look for exact match of full path name.  Check only modules with symbols loaded.
        // 1. Look for exact match of full path name.  Load all unloaded modules.
        // 2. Look for best match of path name.        All modules are already loaded.

        for (i = 0; i < 3; i++) {
            Next = pe->ModuleList.Flink;
            while (Next != &pe->ModuleList) {
                mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = mi->ListEntry.Flink;
#ifdef DEBUG
                if (traceSubName(mi->ModuleName)) // for setting debug breakpoints from DBGHELP_TOKEN
                    dtrace("debug(%s)\n", mi->ModuleName);
#endif
                if (mi->processed && (method[i] == mFullPath))
                    continue;
                if (!LoadSymbols(hProcess, mi, flags[i])) {
                    if (GetLastError() == ERROR_CANCELLED)
                        return false;
                    continue;
                }
                mi->processed = true;

                if (GetLineFromName(pe, mi, fname, dwLineNumber, plDisplacement, &tsci, method[i])) {
                    if (UpdateBestSrc(fname, sci.FileName, tsci.FileName))
                        memcpy(&sci, &tsci, sizeof(SRCCODEINFO));
                }
            }

            if (*sci.FileName)
                return sci2lline(mi, &sci, Line64);

            // Only the 1st pass works with loaded symbols.  The next pass will try
            // to load the rest.  Might as well quit now if the options don't allow it.

            if (option(SYMOPT_NO_UNQUALIFIED_LOADS))
                return error(ERROR_NOT_FOUND);
        }

        return error(ERROR_NOT_FOUND);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return error( ERROR_INVALID_FUNCTION );
}


BOOL
IMAGEAPI
SymGetLineFromName(
    IN     HANDLE               hProcess,
    IN     LPSTR                ModuleName,
    IN     LPSTR                FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    line2lline(Line32, &Line64);
    if (SymGetLineFromName64(hProcess,
                             ModuleName,
                             FileName,
                             dwLineNumber,
                             plDisplacement,
                             &Line64)) {
        return lline2line(&Line64, Line32) ? true : false;
    } else {
        return false;
    }
}


BOOL
IMAGEAPI
SymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )

/*++

Routine Description:

    This function returns line address information for the line immediately
    following the line given.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Line                - Supplies line number information for the line
                          prior to the one being located.

Return Value:

    true                - A line was located.  The Key, LineNumber and Address
                          of Line are updated.

    false               - No such line exists.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSOURCE_LINE        SrcLine;
    PSOURCE_ENTRY       Src;

    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64))
            return error(ERROR_INVALID_PARAMETER);

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error( ERROR_INVALID_HANDLE );

        mi = GetModuleForPC( pe, Line->Address, false );
        if (!mi)
            return error( ERROR_MOD_NOT_FOUND );

        if (!LoadSymbols(hProcess, mi, 0))
            return error( ERROR_MOD_NOT_FOUND );

        if (mi->dia)
            return diaGetLineNext(mi, Line);

        // Use existing information to look up module and then
        // locate the file information.  The key could be extended
        // to make this unnecessary but it's done as a validation step
        // more than as a way to save a DWORD.

        SrcLine = (PSOURCE_LINE)Line->Key;

        for (Src = mi->SourceFiles; Src != NULL; Src = Src->Next) {
            if (SrcLine >= Src->LineInfo &&
                SrcLine < Src->LineInfo+Src->Lines) {
                break;
            }
        }

        if (!Src)
            return error(ERROR_INVALID_PARAMETER);

        if (SrcLine == Src->LineInfo+Src->Lines-1)
            return error(ERROR_NO_MORE_ITEMS);

        SrcLine++;
        Line->Key = SrcLine;
        Line->LineNumber = SrcLine->Line;
        Line->Address = SrcLine->Addr;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}

BOOL
IMAGEAPI
SymGetLineNext(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE     Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    line2lline(Line32, &Line64);
    if (SymGetLineNext64(hProcess, &Line64)) {
        return lline2line(&Line64, Line32) ? true : false;
    } else {
        return false;
    }
}


BOOL
IMAGEAPI
SymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )

/*++

Routine Description:

    This function returns line address information for the line immediately
    before the line given.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Line                - Supplies line number information for the line
                          after the one being located.

Return Value:

    true                - A line was located.  The Key, LineNumber and Address
                          of Line are updated.

    false               - No such line exists.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSOURCE_LINE        SrcLine;
    PSOURCE_ENTRY       Src;

    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64))
            return error(ERROR_INVALID_PARAMETER);

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error( ERROR_INVALID_HANDLE );

        mi = GetModuleForPC( pe, Line->Address, false );
        if (!mi)
            return error( ERROR_MOD_NOT_FOUND );

        if (!LoadSymbols(hProcess, mi, 0))
            return error( ERROR_MOD_NOT_FOUND );

        if (mi->dia)
            return diaGetLinePrev(mi, Line);

        // Use existing information to look up module and then
        // locate the file information.  The key could be extended
        // to make this unnecessary but it's done as a validation step
        // more than as a way to save a DWORD.

        SrcLine = (PSOURCE_LINE)Line->Key;

        for (Src = mi->SourceFiles; Src != NULL; Src = Src->Next) {
            if (SrcLine >= Src->LineInfo &&
                SrcLine < Src->LineInfo+Src->Lines) {
                break;
            }
        }

        if (!Src)
            return error(ERROR_INVALID_PARAMETER);

        if (SrcLine == Src->LineInfo)
            return error(ERROR_NO_MORE_ITEMS);

        SrcLine--;
        Line->Key = SrcLine;
        Line->LineNumber = SrcLine->Line;
        Line->Address = SrcLine->Addr;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}

BOOL
IMAGEAPI
SymGetLinePrev(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE     Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    line2lline(Line32, &Line64);
    if (SymGetLinePrev64(hProcess, &Line64)) {
        return lline2line(&Line64, Line32) ? true : false;
    } else {
        return false;
    }
}


BOOL
IMAGEAPI
SymMatchFileName(
    IN  LPSTR  FileName,
    IN  LPSTR  Match,
    OUT LPSTR *FileNameStop,
    OUT LPSTR *MatchStop
    )

/*++

Routine Description:

    This function attempts to match a string against a filename and path.
    The match string is allowed to be a suffix of the complete filename,
    so this function is useful for matching a plain filename against
    a fully qualified filename.

    Matching begins from the end of both strings and proceeds backwards.
    Matching is case-insensitive and equates \ with /.

Arguments:

    FileName            - Filename to match against.

    Match               - String to match against filename.

    FileNameStop        - Returns pointer into FileName where matching stopped.
                          May be one before FileName for full matches.
                          May be NULL.

    MatchStop           - Returns pointer info Match where matching stopped.
                          May be one before Match for full matches.
                          May be NULL.

Return Value:

    true                - Match is a matching suffix of FileName.

    false               - Mismatch.

--*/

{
    LPSTR pF, pM;

    pF = FileName+strlen(FileName)-1;
    pM = Match+strlen(Match)-1;

    while (pF >= FileName && pM >= Match) {
        int chF, chM;

        chF = tolower(*pF);
        chF = chF == '\\' ? '/' : chF;
        chM = tolower(*pM);
        chM = chM == '\\' ? '/' : chM;

        if (chF != chM) {
            break;
        }

        pF--;
        pM--;
    }

    if (FileNameStop != NULL) {
        *FileNameStop = pF;
    }
    if (MatchStop != NULL) {
        *MatchStop = pM;
    }

    return pM < Match;
}


BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    )
/*++

Routine Description:

    Set the address of a callback routine to access extended function
    table entries directly. This function is useful when debugging
    Alpha processes where RUNTIME_FUNCTION_ENTRYs are available from
    sources other than in the image. Two existing examples are:

    1) Access to dynamic function tables for run-time code
    2) Access to function tables for ROM images

Arguments:

    hProcess    - Process handle, must have been previously registered
                  with SymInitialize.


    DirectFunctionTableRoutine - Address of direct function table callback routine.
                  On alpha this routine must return a pointer to the
                  RUNTIME_FUNCTION_ENTRY containing the specified address.
                  If no such entry is available, it must return NULL.

Return Value:

    true        - The callback was successfully registered

    false       - The initialization failed. Most likely failure is that
                  the hProcess parameter is invalid. Call GetLastError()
                  for specific error codes.
--*/
{
    PPROCESS_ENTRY  pe = NULL;

    __try {

        if (!CallbackFunction)
            return error(ERROR_INVALID_PARAMETER);

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error(ERROR_INVALID_PARAMETER);

        pe->pFunctionEntryCallback32 = CallbackFunction;
        pe->pFunctionEntryCallback64 = NULL;
        pe->FunctionEntryUserContext = (ULONG64)UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }
    return true;
}


BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    )
/*++

Routine Description:

    See SymRegisterFunctionEntryCallback64
--*/
{
    PPROCESS_ENTRY  pe = NULL;

    __try {

        if (!CallbackFunction)
            return error(ERROR_INVALID_PARAMETER);

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error(ERROR_INVALID_PARAMETER);

        pe->pFunctionEntryCallback32 = NULL;
        pe->pFunctionEntryCallback64 = CallbackFunction;
        pe->FunctionEntryUserContext = (ULONG64)UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }
    return true;
}

LPVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    )
{
    return SymFunctionTableAccess64(hProcess, EXTEND64(AddrBase));
}

LPVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )

/*++

Routine Description:

    This function finds a function table entry or FPO record for an address.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    AddrBase            - Supplies an address for which a function table entry
                          or FPO entry is to be located.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY  pe;
    PMODULE_ENTRY   mi;
    PVOID           rtf;
    ULONG_PTR       rva;
    DWORD           bias;
    DWORD           MachineType;

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError(ERROR_INVALID_HANDLE);
            return NULL;
        }

        // Dynamically generated function table entries
        // may not be in a module, so failing to
        // find a module is not a fatal error.
        mi = GetModuleForPC( pe, AddrBase, false );
        if (mi != NULL) {
            if (!LoadSymbols(hProcess, mi, 0)) {
                SetLastError(ERROR_MOD_NOT_FOUND);
                return NULL;
            }

            MachineType = mi->MachineType;
        } else {
            // We need to guess what kind of machine we
            // should be working with.  First see if ntdll
            // is loaded and if so use its machine type.
            mi = FindModule(hProcess, pe, "ntdll", true);
            if (mi != NULL) {
                MachineType = mi->MachineType;
            } else if (pe->ModuleList.Flink != NULL) {
                // Try the first module's type.
                mi = CONTAINING_RECORD( pe->ModuleList.Flink,
                                        MODULE_ENTRY, ListEntry );
            } else {
                // Use the complation machine.
#if defined(_M_IX86)
                MachineType = IMAGE_FILE_MACHINE_I386;
#elif defined(_M_IA64)
                MachineType = IMAGE_FILE_MACHINE_IA64;
#elif defined(_M_AMD64)
                MachineType = IMAGE_FILE_MACHINE_AMD64;
#else
#error( "unknown target machine" );
#endif
            }
        }

        switch (MachineType) {
            default:
                rtf = NULL;
                break;

            case IMAGE_FILE_MACHINE_I386:
                rtf = NULL;

                if (mi == NULL) {
                    SetLastError( ERROR_MOD_NOT_FOUND );
                    break;
                }

                DWORD64 caddr;

                if (!mi->pFpoData)
                    break;
                caddr = ConvertOmapToSrc( mi, AddrBase, &bias, true );
                if (caddr)
                    AddrBase = caddr + bias;
                rtf = SwSearchFpoData( (ULONG)(AddrBase - mi->BaseOfDll), mi->pFpoData, mi->dwEntries );
                if (rtf && mi->cOmapFrom && mi->pFpoDataOmap) {
                    rva = (ULONG_PTR)rtf - (ULONG_PTR)mi->pFpoData;
                    rtf = (PBYTE)mi->pFpoDataOmap + rva;
                }
                break;

            case IMAGE_FILE_MACHINE_IA64:
                rtf = LookupFunctionEntryIa64(hProcess, AddrBase);
                break;

            case IMAGE_FILE_MACHINE_AMD64:
                rtf = LookupFunctionEntryAmd64(hProcess, AddrBase);
                break;
        }

        if (!rtf) {
            SetLastError(ERROR_INVALID_ADDRESS);
            return NULL;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return NULL;

    }

    return rtf;
}


BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE              hProcess,
    IN  DWORD64             dwAddr,
    OUT PIMAGEHLP_MODULE64  ModuleInfo
    )
{
    PPROCESS_ENTRY          pe;
    PMODULE_ENTRY           mi;
    DWORD                   SizeOfStruct;

    DWORD dw = sizeof(CVDD);

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error( ERROR_INVALID_HANDLE );

        mi = GetModuleForPC( pe, dwAddr, false );
        if (!mi)
            return error( ERROR_MOD_NOT_FOUND );

        SizeOfStruct = ModuleInfo->SizeOfStruct;
        if (SizeOfStruct > sizeof(IMAGEHLP_MODULE64))
            return error( ERROR_INVALID_PARAMETER );

        ZeroMemory( ModuleInfo, SizeOfStruct);
        ModuleInfo->SizeOfStruct = SizeOfStruct;

        ModuleInfo->BaseOfImage = mi->BaseOfDll;
        ModuleInfo->ImageSize = mi->DllSize;
        ModuleInfo->NumSyms = mi->numsyms;
        ModuleInfo->CheckSum = mi->CheckSum;
        ModuleInfo->TimeDateStamp = mi->TimeDateStamp;
        ModuleInfo->SymType = mi->SymType;
        ModuleInfo->ModuleName[0] = 0;
        CatString( ModuleInfo->ModuleName, mi->ModuleName, sizeof(ModuleInfo->ModuleName));
        ModuleInfo->ImageName[0] = 0;
        if (mi->ImageName)
            CopyStrArray(ModuleInfo->ImageName, mi->ImageName);
        ModuleInfo->LoadedImageName[0] = 0;
        if (mi->LoadedImageName)
            CopyStrArray(ModuleInfo->LoadedImageName, mi->LoadedImageName);

        // if (ModuleInfo->SizeofStruct == 0x248)  // the original size
        //    return true

        // the following code supports the expanded structure

        if (ModuleInfo->SizeOfStruct < sizeof(IMAGEHLP_MODULE64))
            return true;

        ModuleInfo->LoadedPdbName[0] = 0;
        if (mi->LoadedPdbName)
            CopyStrArray(ModuleInfo->LoadedPdbName, mi->LoadedPdbName);
        ModuleInfo->CVSig = mi->cvSig;
        ModuleInfo->PdbSig = mi->pdbdataSig;
        memcpy(&ModuleInfo->PdbSig70, &mi->pdbdataGuid, sizeof(GUID));
        ModuleInfo->PdbAge = mi->pdbdataAge;
        ModuleInfo->PdbUnmatched = mi->fPdbUnmatched;
        ModuleInfo->DbgUnmatched = mi->fDbgUnmatched;
        ModuleInfo->LineNumbers = mi->fLines;
        ModuleInfo->GlobalSymbols = mi->fSymbols;
        ModuleInfo->TypeInfo = mi->fTypes;
        switch (mi->CVRec.dwSig)
        {
        case '01BN':
            CopyString(ModuleInfo->CVData, mi->CVRec.nb10i.szPdb, MAX_PATH * 3);
            break;
        case 'SDSR':
            CopyString(ModuleInfo->CVData, mi->CVRec.rsdsi.szPdb, MAX_PATH * 3);
            break;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}


BOOL
IMAGEAPI
SymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW   wModInfo
    )
{
    IMAGEHLP_MODULE aModInfo;

    if (wModInfo->SizeOfStruct != sizeof(IMAGEHLP_MODULEW))
        return error(ERROR_INVALID_PARAMETER);

    ZeroMemory(wModInfo, sizeof(IMAGEHLP_MODULEW));
    wModInfo->SizeOfStruct = sizeof(IMAGEHLP_MODULEW);

    if (!SympConvertUnicodeModule32ToAnsiModule32(
        wModInfo, &aModInfo))
    {
        return error(ERROR_INVALID_PARAMETER);
    }

    if (!SymGetModuleInfo(hProcess, dwAddr, &aModInfo)) {
        return false;
    }

    if (!SympConvertAnsiModule32ToUnicodeModule32(
        &aModInfo, wModInfo)) {

        return false;
    }
    return true;
}

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    IN  HANDLE              hProcess,
    IN  DWORD64             dwAddr,
    OUT PIMAGEHLP_MODULEW64 wModInfo
    )
{

    IMAGEHLP_MODULE64 aModInfo;

    if (!SympConvertUnicodeModule64ToAnsiModule64(
        wModInfo, &aModInfo)) {

        return false;
    }

    if (!SymGetModuleInfo64(hProcess, dwAddr, &aModInfo)) {
        return false;
    }

    if (!SympConvertAnsiModule64ToUnicodeModule64(
        &aModInfo, wModInfo)) {

        return false;
    }
    return true;
}

BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE   ModuleInfo
    )
{
    PPROCESS_ENTRY          pe;
    PMODULE_ENTRY           mi;
    DWORD                   SizeOfStruct;

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error( ERROR_INVALID_HANDLE );

        mi = GetModuleForPC( pe,
            dwAddr == (DWORD)-1 ? (DWORD64)-1 : dwAddr, false );
        if (!mi)
            return error( ERROR_MOD_NOT_FOUND );

        SizeOfStruct = ModuleInfo->SizeOfStruct;
        if (SizeOfStruct > sizeof(IMAGEHLP_MODULE))
            return error( ERROR_INVALID_PARAMETER );
        ZeroMemory( ModuleInfo, SizeOfStruct);
        ModuleInfo->SizeOfStruct = SizeOfStruct;

        ModuleInfo->BaseOfImage = (DWORD)mi->BaseOfDll;
        ModuleInfo->ImageSize = mi->DllSize;
        ModuleInfo->NumSyms = mi->numsyms;
        ModuleInfo->CheckSum = mi->CheckSum;
        ModuleInfo->TimeDateStamp = mi->TimeDateStamp;
        ModuleInfo->SymType = mi->SymType;
        ModuleInfo->ModuleName[0] = 0;
        CatString( ModuleInfo->ModuleName, mi->ModuleName, sizeof(ModuleInfo->ModuleName));
        if (mi->ImageName)
            CopyStrArray(ModuleInfo->ImageName, mi->ImageName);
        if (mi->LoadedImageName)
            CopyStrArray(ModuleInfo->LoadedImageName, mi->LoadedImageName);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}

DWORD64
IMAGEAPI
SymGetModuleBase64(
    IN  HANDLE  hProcess,
    IN  DWORD64 dwAddr
    )
{
    PPROCESS_ENTRY          pe;
    PMODULE_ENTRY           mi;


    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            return 0;
        }

        mi = GetModuleForPC( pe, dwAddr, false );
        if (mi == NULL) {
            return 0;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return mi->BaseOfDll;
}

DWORD
IMAGEAPI
SymGetModuleBase(
    IN  HANDLE hProcess,
    IN  DWORD  dwAddr
    )
{
    return (ULONG)SymGetModuleBase64(hProcess, dwAddr);
}

BOOL
IMAGEAPI
SymUnloadModule64(
    IN  HANDLE      hProcess,
    IN  DWORD64     BaseOfDll
    )

/*++

Routine Description:

    Remove the symbols for an image from a process' symbol table.

Arguments:

    hProcess - Supplies the token which refers to the process

    BaseOfDll - Supplies the offset to the image as supplies by the
        LOAD_DLL_DEBUG_EVENT and UNLOAD_DLL_DEBUG_EVENT.

Return Value:

    Returns true if the module's symbols were successfully unloaded.
    Returns false if the symbol handler does not recognize hProcess or
    no image was loaded at the given offset.

--*/

{
    PPROCESS_ENTRY  pe;
    PLIST_ENTRY     next;
    PMODULE_ENTRY   mi;

    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe) {
            return false;
        }

        next = pe->ModuleList.Flink;
        if (next) {
            while (next != &pe->ModuleList) {
                mi = CONTAINING_RECORD(next, MODULE_ENTRY, ListEntry);
                if (mi->BaseOfDll == BaseOfDll) {
                    RemoveEntryList(next);
                    gfnSrcSrvUnloadModule(hProcess, mi->BaseOfDll);
                    FreeModuleEntry(pe, mi);
                    ZeroMemory(pe->DiaCache, sizeof(pe->DiaCache));
                    ZeroMemory(pe->DiaLargeData, sizeof(pe->DiaLargeData));
                    return true;
                }
                next = mi->ListEntry.Flink;
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return false;
    }

    return false;
}

BOOL
IMAGEAPI
SymUnloadModule(
    IN  HANDLE      hProcess,
    IN  DWORD       BaseOfDll
    )
{
    return SymUnloadModule64(hProcess, BaseOfDll);
}

DWORD64
IMAGEAPI
SymLoadModuleEx(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize,
    IN  PMODLOAD_DATA   Data,
    IN  DWORD           Flags
    )

/*++

Routine Description:

    Loads the symbols for an image for use by the other Sym functions.

Arguments:

    hProcess - Supplies unique process identifier.

    hFile -

    ImageName - Supplies the name of the image file.

    ModuleName - ???? Supplies the module name that will be returned by
            enumeration functions ????

    BaseOfDll - Supplies loaded base address of image.

    DllSize


Return Value:


--*/

{
    __try {

        return LoadModule( hProcess, ImageName, ModuleName, BaseOfDll, DllSize, hFile, Data, Flags );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return 0;
    }
}



DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize
    )
{
    return SymLoadModuleEx(hProcess, hFile, ImageName, ModuleName, BaseOfDll, DllSize, NULL, 0);
}

DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           DllSize
    )
{
    return (DWORD)SymLoadModule64( hProcess, hFile, ImageName, ModuleName, BaseOfDll, DllSize );
}


BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL  sym,
    OUT LPSTR               UnDecName,
    OUT DWORD               UnDecNameLength
    )
{
    __try {

        if (SymUnDNameInternal( UnDecName,
                                UnDecNameLength-1,
                                sym->Name,
                                strlen(sym->Name),
                                IMAGE_FILE_MACHINE_UNKNOWN,
                                true )) {
            return true;
        } else {
            return false;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }
}

BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64  sym,
    OUT LPSTR               UnDecName,
    OUT DWORD               UnDecNameLength
    )
{
    __try {

        if (SymUnDNameInternal( UnDecName,
                                UnDecNameLength-1,
                                sym->Name,
                                strlen(sym->Name),
                                IMAGE_FILE_MACHINE_UNKNOWN,
                                true )) {
            return true;
        } else {
            return false;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }
}


BOOL
IMAGEAPI
SymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT LPSTR           SearchPath,
    IN  DWORD           SearchPathLength
    )

/*++

Routine Description:

    This function looks up the symbol search path associated with a process.

Arguments:

    hProcess - Supplies the token associated with a process.

Return Value:

    A pointer to the search path.  Returns NULL if the process is not
    know to the symbol handler.

--*/

{
    PPROCESS_ENTRY pe;


    __try {

        pe = FindProcessEntry( hProcess );

        if (!pe) {
            return false;
        }

        SearchPath[0] = 0;
        CatString( SearchPath, pe->SymbolSearchPath, SearchPathLength );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}


BOOL
IMAGEAPI
SymSetSearchPath(
    HANDLE      hProcess,
    LPSTR       UserSearchPath
    )

/*++

Routine Description:

    This functions sets the searh path to be used by the symbol loader
    for the given process.  If UserSearchPath is not supplied, a default
    path will be used.

Arguments:

    hProcess - Supplies the process token associated with a symbol table.

    UserSearchPath - Supplies the new search path to associate with the
        process. If this argument is NULL, the following path is generated:

        .;%_NT_SYMBOL_PATH%;%_NT_ALTERNATE_SYMBOL_PATH%

        It is ok if any or all of the environment variables is missing.

Return Value:

    A pointer to the new search path.  The user should not modify this string.
    Returns NULL if the process is not known to the symbol handler.

--*/

{
    PPROCESS_ENTRY  pe;
    LPSTR           p;
    DWORD           cbSymPath;
    DWORD           cb;
    char            ExpandedSearchPath[MAX_PATH];

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            return false;
        }

        if (pe->SymbolSearchPath) {
            MemFree(pe->SymbolSearchPath);
        }

        if (UserSearchPath) {
            cbSymPath = ExpandEnvironmentStrings(UserSearchPath,
                                     ExpandedSearchPath,
                                     sizeof(ExpandedSearchPath) / sizeof(ExpandedSearchPath[0]));
            if (cbSymPath < sizeof(ExpandedSearchPath)/sizeof(ExpandedSearchPath[0])) {
            pe->SymbolSearchPath = StringDup(ExpandedSearchPath);
            } else {
                pe->SymbolSearchPath = (LPSTR)MemAlloc( cbSymPath );
                ExpandEnvironmentStrings(UserSearchPath,
                                         pe->SymbolSearchPath,
                                         cbSymPath );
            }
        } else {

            //
            // ".;%_NT_SYMBOL_PATH%;%_NT_ALTERNATE_SYMBOL_PATH%
            //

            cbSymPath = 3;     // ".;" and ";" between env vars.

            //
            // GetEnvironmentVariable returns the size of the string
            // INCLUDING the '\0' in this case.
            //
            if (!option(SYMOPT_IGNORE_NT_SYMPATH)) {
                cbSymPath += GetEnvironmentVariable( SYMBOL_PATH, NULL, 0 );
                cbSymPath += GetEnvironmentVariable( ALTERNATE_SYMBOL_PATH, NULL, 0 );
            }

            p = pe->SymbolSearchPath = (LPSTR) MemAlloc( cbSymPath );
            if (!p) {
                return false;
            }

            *p++ = '.';
            --cbSymPath;

            if (!option(SYMOPT_IGNORE_NT_SYMPATH)) {
                cb = GetEnvironmentVariable(SYMBOL_PATH, p+1, cbSymPath-1);
                if (cb) {
                    *p = ';';
                    p += cb+1;
                    cbSymPath -= cb+1;
                }
                cb = GetEnvironmentVariable(ALTERNATE_SYMBOL_PATH, p+1, cbSymPath-1);
                if (cb) {
                    *p = ';';
                    p += cb+1;
                }
            }

            *p = 0;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    symsrvClose();

    return true;
}


BOOL
IMAGEAPI
EnumerateLoadedModules(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK     EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    )
{
    LOADED_MODULE lm;
    DWORD status = NO_ERROR;

    __try {

        lm.EnumLoadedModulesCallback32 = EnumLoadedModulesCallback;
        lm.EnumLoadedModulesCallback64 = NULL;
        lm.Context = UserContext;

        status = GetProcessModules( hProcess, (PGET_MODULE)LoadedModuleEnumerator, (PVOID)&lm );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return (status == NO_ERROR);
}


BOOL
IMAGEAPI
EnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    )
{
    LOADED_MODULE lm;
    DWORD status = NO_ERROR;

    __try {

        lm.EnumLoadedModulesCallback64 = EnumLoadedModulesCallback;
        lm.EnumLoadedModulesCallback32 = NULL;
        lm.Context = UserContext;

        status = GetProcessModules(hProcess,
                                   (PGET_MODULE)LoadedModuleEnumerator,
                                   (PVOID)&lm );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return (status == NO_ERROR);
}

BOOL
IMAGEAPI
SymRegisterCallback(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK   CallbackFunction,
    IN PVOID                         UserContext
    )
{
    PPROCESS_ENTRY  pe = NULL;

    __try {

        if (!CallbackFunction)
            return error(ERROR_INVALID_PARAMETER);

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error(ERROR_INVALID_PARAMETER);

        pe->pCallbackFunction32 = CallbackFunction;
        pe->pCallbackFunction64 = NULL;
        pe->CallbackUserContext = (ULONG64)UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}


BOOL
IMAGEAPI
SymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    )
{
    PPROCESS_ENTRY  pe = NULL;

    __try {

        if (!CallbackFunction)
            return error(ERROR_INVALID_PARAMETER);

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error(ERROR_INVALID_PARAMETER);

        pe->pCallbackFunction32 = NULL;
        pe->pCallbackFunction64 = CallbackFunction;
        pe->CallbackUserContext = UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}


void
InitModuleEntry(
    PMODULE_ENTRY mi
    )
{
    ZeroMemory(mi, sizeof(MODULE_ENTRY));
    mi->si.MaxNameLen = 2048;
    mi->vssi.MaxNameLen = 2048;
    mi->cGlobals = -1;
    mi->SymType = SymDeferred;
}


BOOL
SympConvertAnsiModule32ToUnicodeModule32(
    PIMAGEHLP_MODULE  aMod32,
    PIMAGEHLP_MODULEW wMod32
    )
{
    ZeroMemory(wMod32, sizeof(*wMod32));
    wMod32->SizeOfStruct = sizeof(*wMod32);

    wMod32->BaseOfImage = aMod32->BaseOfImage;
    wMod32->ImageSize = aMod32->ImageSize;
    wMod32->TimeDateStamp = aMod32->TimeDateStamp;
    wMod32->CheckSum = aMod32->CheckSum;
    wMod32->NumSyms = aMod32->NumSyms;
    wMod32->SymType = aMod32->SymType;

    if (!ansi2wcs(aMod32->ModuleName, wMod32->ModuleName, 256))
        return false;

    if (!ansi2wcs(aMod32->ImageName, wMod32->ImageName, 256))
        return false;

    if (!ansi2wcs(aMod32->LoadedImageName, wMod32->LoadedImageName, 256))
        return false;

    return true;
}

BOOL
SympConvertUnicodeModule32ToAnsiModule32(
    PIMAGEHLP_MODULEW wMod32,
    PIMAGEHLP_MODULE  aMod32
    )
{
    ZeroMemory(aMod32, sizeof(*aMod32));
    aMod32->SizeOfStruct = sizeof(*aMod32);

    aMod32->BaseOfImage = wMod32->BaseOfImage;
    aMod32->ImageSize = wMod32->ImageSize;
    aMod32->TimeDateStamp = wMod32->TimeDateStamp;
    aMod32->CheckSum = wMod32->CheckSum;
    aMod32->NumSyms = wMod32->NumSyms;
    aMod32->SymType = wMod32->SymType;

    if (!wcs2ansi(wMod32->ModuleName, aMod32->ModuleName, DIMA(wMod32->ModuleName)))
        return false;

    if (!wcs2ansi(wMod32->ImageName, aMod32->ImageName, DIMA(wMod32->ImageName)))
        return false;

    if (!wcs2ansi(wMod32->LoadedImageName, aMod32->LoadedImageName, DIMA(wMod32->LoadedImageName)))
        return false;

    return true;
}


BOOL
SympConvertAnsiModule64ToUnicodeModule64(
    PIMAGEHLP_MODULE64  aMod64,
    PIMAGEHLP_MODULEW64 wMod64
    )
{
    ZeroMemory(wMod64, sizeof(*wMod64));
    wMod64->SizeOfStruct = sizeof(*wMod64);

    wMod64->BaseOfImage = aMod64->BaseOfImage;
    wMod64->ImageSize = aMod64->ImageSize;
    wMod64->TimeDateStamp = aMod64->TimeDateStamp;
    wMod64->CheckSum = aMod64->CheckSum;
    wMod64->NumSyms = aMod64->NumSyms;
    wMod64->SymType = aMod64->SymType;

    if (!ansi2wcs(aMod64->ModuleName, wMod64->ModuleName, 256))
        return false;

    if (!ansi2wcs(aMod64->ImageName, wMod64->ImageName, 256))
        return false;

    if (!ansi2wcs(aMod64->LoadedImageName, wMod64->LoadedImageName, 256))
        return false;

    if (aMod64->SizeOfStruct < sizeof(IMAGEHLP_MODULE64))
        return true;

    if (!ansi2wcs(aMod64->LoadedPdbName, wMod64->LoadedPdbName, 256))
        return false;

    wMod64->CVSig = aMod64->CVSig;
    
    if (!ansi2wcs(aMod64->CVData, wMod64->CVData, MAX_PATH * 3))
        return false;

    wMod64->PdbSig = aMod64->PdbSig;
    memcpy(&wMod64->PdbSig70, &aMod64->PdbSig70, sizeof(GUID));
    wMod64->PdbAge = aMod64->PdbAge;
    wMod64->PdbUnmatched = aMod64->PdbUnmatched;
    wMod64->DbgUnmatched = aMod64->DbgUnmatched;
    wMod64->LineNumbers = aMod64->LineNumbers;
    wMod64->GlobalSymbols = aMod64->GlobalSymbols;
    wMod64->TypeInfo = aMod64->TypeInfo;

    return true;
}

BOOL
SympConvertUnicodeModule64ToAnsiModule64(
    PIMAGEHLP_MODULEW64 wMod64,
    PIMAGEHLP_MODULE64  aMod64
    )
{
    ZeroMemory(aMod64, sizeof(*aMod64));
    aMod64->SizeOfStruct = sizeof(*aMod64);

    aMod64->BaseOfImage = wMod64->BaseOfImage;
    aMod64->ImageSize = wMod64->ImageSize;
    aMod64->TimeDateStamp = wMod64->TimeDateStamp;
    aMod64->CheckSum = wMod64->CheckSum;
    aMod64->NumSyms = wMod64->NumSyms;
    aMod64->SymType = wMod64->SymType;

    if (!wcs2ansi(wMod64->ModuleName, aMod64->ModuleName, DIMA(wMod64->ModuleName)))
        return false;

    if (!wcs2ansi(wMod64->ImageName, aMod64->ImageName, DIMA(wMod64->ImageName)))
        return false;

    if (!wcs2ansi(wMod64->LoadedImageName, aMod64->LoadedImageName, DIMA(wMod64->LoadedImageName)))
        return false;

    return true;
}

BOOL
IMAGEAPI
SymAddSymbol(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Name,
    IN DWORD64                      Address,
    IN DWORD                        Size,
    IN DWORD                        Flags
    )
{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSYMBOL_ENTRY       psym;

    if (!Name || !*Name || !Address)
        return error(ERROR_INVALID_PARAMETER);

    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe)
            return error(ERROR_INVALID_HANDLE);

        mi = GetModuleForPC(pe, Address, false);
        if (!mi)
            return error(ERROR_MOD_NOT_FOUND);

        if (!LoadSymbols(hProcess, mi, 0))
            return error(ERROR_MOD_NOT_FOUND);

        return vsAddSymbol(mi, Name, Address, Size);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return false;
    }

    return true;
}


BOOL
IMAGEAPI
SymDeleteSymbol(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Name,
    IN DWORD64                      Address,
    IN DWORD                        Flags
    )
{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSYMBOL_ENTRY       psym;

    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe)
            return error(ERROR_INVALID_HANDLE);

        mi = GetModuleForPC(pe, Address, false);
        if (!mi)
            return error(ERROR_MOD_NOT_FOUND);

        if (!LoadSymbols(hProcess, mi, LS_JUST_TEST))
            return error(ERROR_MOD_NOT_FOUND);

        return vsDeleteSymbol(mi, Name, Address);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return false;
    }

    return true;
}


BOOL
IMAGEAPI
SymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    IN OUT PSYMBOL_INFO     Symbol
    )
{
    PSYMBOL_INFO si;

    si = SympGetSymFromAddr(hProcess, Address, Displacement);
    if (!si)
        return false;

    si2si(Symbol, si);

    return true;
}


BOOL
IMAGEAPI
SymFromAddrByTag(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    IN  DWORD               SymTag,
    OUT PDWORD64            Displacement,
    IN OUT PSYMBOL_INFO     Symbol
    )
{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSYMBOL_INFO        si;

    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe)
            return error(ERROR_INVALID_HANDLE);

        mi = GetModuleForPC(pe, Address, false);
        if (!mi)
            return error(ERROR_MOD_NOT_FOUND);

        if (!LoadSymbols(hProcess, mi, 0))
            return error(ERROR_MOD_NOT_FOUND);

        si = GetSymFromAddrByTag(Address, SymTag, Displacement, mi);
        if (!si)
            return error(ERROR_INVALID_ADDRESS);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return false;

    }

    si2si(Symbol, si);

    return true;
}


BOOL
IMAGEAPI
SymFromToken(
    IN  HANDLE              hProcess,
    IN  DWORD64             Base,
    IN  DWORD               Token,
    IN OUT PSYMBOL_INFO     Symbol
    )
{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSYMBOL_INFO        si;

    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe)
            return error(ERROR_INVALID_HANDLE);

        mi = GetModuleForPC(pe, Base, false);
        if (!mi)
            return error(ERROR_MOD_NOT_FOUND);

        if (!LoadSymbols(hProcess, mi, 0))
            return error(ERROR_MOD_NOT_FOUND);

        si = GetSymFromToken(mi, Token);
        if (!si)
            return error(ERROR_INVALID_ADDRESS);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return false;

    }

    si2si(Symbol, si);

    return true;
}


BOOL
IMAGEAPI
SymFromName(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    )
{
    SYMBOL_ENTRY sym;
    PSYMBOL_INFO si;

    si = SympGetSymFromName(hProcess, Name);
    if (!si)
        return false;

    si2si(Symbol, si);

    return true;
}


BOOL
IMAGEAPI
SymEnumSymbols(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Mask,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    return SympEnumerateSymbols(hProcess,
                                BaseOfDll,
                                (LPSTR)Mask,
                                (PROC) EnumSymbolsCallback,
                                UserContext,
                                false,
                                false);
}


BOOL
IMAGEAPI
SymEnumSymbolsByTag(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN DWORD                        SymTag,
    IN PCSTR                        Mask,
    IN DWORD                        Options,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    PPROCESS_ENTRY      pe;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       mi;
    DWORD               i;
    PSYMBOL_ENTRY       sym;
    char                buf[2500];
    LPSTR               p;
    CHAR                modmask[200];
    BOOL                rc;
    int                 pass;
    BOOL                fCase;
    PSYMBOL_INFO        si;
    char                match[MAX_SYM_NAME + 100];

    static DWORD        flags[2] = {LS_JUST_TEST, LS_QUALIFIED | LS_FAIL_IF_LOADED};

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return false;
        }

        p = 0;
        modmask[0] = 0;
        if (Mask)
            p = strchr(Mask, '!');
        if (p > Mask) {
            memcpy(modmask, Mask, (int)(p - Mask));
            modmask[p-Mask] = 0;
            Mask = p + 1;
        } else if (!BaseOfDll) {
            // search is scoped to current scope
            rc = diaGetSymbolsByTag(pe,
                                    NULL,
                                    Mask,
                                    0,
                                    SymTag,
                                    (PROC)EnumSymbolsCallback,
                                    UserContext,
                                    false,
                                    false,
                                    Options);
            if (!rc && pe->ipmi && pe->ipmi->code == ERROR_CANCELLED) {
                pe->ipmi->code = 0;
                return true;
            }
            return rc;
        }

        if (Mask && *Mask)
            PrepRE4Srch(Mask, match);
        else
            *match = 0;

        for (pass = 0; pass < 2; pass++) {
            Next = pe->ModuleList.Flink;
            if (Next) {
                while (Next != &pe->ModuleList) {

                    mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                    Next = mi->ListEntry.Flink;
                    if (BaseOfDll) {
                        if (mi->BaseOfDll != BaseOfDll)
                            continue;
                    } else if (!MatchModuleName(mi, modmask)) {
                        continue;
                    }

                    if (!LoadSymbols(hProcess, mi, flags[pass])) {
                        if (GetLastError() == ERROR_CANCELLED)
                            return false;
                        continue;
                    }

                    if (mi->dia) {
                        rc = diaGetSymbolsByTag(pe,
                                                mi,
                                                Mask,
                                                0,
                                                SymTag,
                                                (PROC)EnumSymbolsCallback,
                                                UserContext,
                                                false,
                                                false,
                                                Options);
                    }

                    if (mi->numsyms) {
                        fCase = option(SYMOPT_CASE_INSENSITIVE) ? false : true;

                        si = (PSYMBOL_INFO)buf;
                        ZeroMemory(buf, sizeof(buf));
                        si->MaxNameLen  = sizeof(buf) - sizeof(SYMBOL_INFO);

                        for (i = 0; i < mi->numsyms; i++) {
                            sym = &mi->symbolTable[i];
                            if (*match && strcmpre(sym->Name, match, fCase))
                                continue;
                            se2si(sym, si);
                            si->ModBase = mi->BaseOfDll;
                            if (!DoEnumCallback(
                                       pe,
                                       si,
                                       si->Size,
                                       (PROC)EnumSymbolsCallback,
                                       UserContext,
                                       false,
                                       false)) {
                                break;
                            }
                        }
                    }

                    rc = vsEnumSymbols(pe,
                                       mi,
                                       Mask,
                                       (PROC)EnumSymbolsCallback,
                                       UserContext,
                                       false,
                                       false);
                    if (!rc) {
                        if (mi->code == ERROR_CANCELLED) {
                            mi->code = 0;
                            return true;
                        }
                        return rc;
                    }
                }
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}


BOOL
IMAGEAPI
SymEnumObjs(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Mask,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    return SymEnumSymbolsByTag(hProcess, BaseOfDll, SymTagCompiland, Mask, 0, EnumSymbolsCallback, UserContext);
}


BOOL
EnumSymForAddr(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY mi,
    IN DWORD64 Address,
    IN PROC    EnumSymbolsCallback,
    IN PVOID   UserContext,
    IN BOOL    Use64,
    IN BOOL    CallBackUsesUnicode
    )
{
    PLIST_ENTRY         Next;
    DWORD               i;
    PSYMBOL_ENTRY       sym;
    LPSTR               szSymName;
    SYMBOL_ENTRY        SymEntry={0};
    CHAR                Buffer[2500];
    LPSTR               p;
    CHAR                modmask[200];
    BOOL                rc;
    int                 pass;
    BOOL                fCase;

    static DWORD        flags[2] = {LS_JUST_TEST, LS_QUALIFIED | LS_FAIL_IF_LOADED};

    __try {

        if (mi->dia) {
            rc = diaEnumSymForAddr(pe,
                                  mi,
                                  Address,
                                  EnumSymbolsCallback,
                                  UserContext,
                                  Use64,
                                  CallBackUsesUnicode);
            if (rc)
                rc = vsEnumSymbolsForAddr(pe,
                                          mi,
                                          Address,
                                          EnumSymbolsCallback,
                                          UserContext,
                                          Use64,
                                          CallBackUsesUnicode);
            if (!rc) {
                if (mi->code == ERROR_CANCELLED) {
                    mi->code = 0;
                    return true;
                }
                return rc;
            }
            return rc;
        }

        fCase = option(SYMOPT_CASE_INSENSITIVE) ? false : true;

        for (i = 0; i < mi->numsyms; i++) {
            PSYMBOL_INFO SymInfo = (PSYMBOL_INFO) &Buffer[0];

            sym = &mi->symbolTable[i];

            if (sym->Address != Address)
                continue;

            mi->TmpSym.Name[0] = 0;
            CatString( mi->TmpSym.Name, sym->Name, TMP_SYM_LEN );
            SymEntry = *sym;
            SymEntry.Name = mi->TmpSym.Name;

            SymInfo->MaxNameLen  = sizeof(Buffer) - sizeof(SYMBOL_INFO);

            se2si(&SymEntry, SymInfo);
            SymInfo->ModBase = mi->BaseOfDll;

            if (!DoEnumCallback(
                       pe,
                       SymInfo,
                       sym->Size,
                       EnumSymbolsCallback,
                       UserContext,
                       Use64,
                       CallBackUsesUnicode)) {
                return true;
            }
        }

        rc = vsEnumSymbolsForAddr(pe,
                                  mi,
                                  Address,
                                  EnumSymbolsCallback,
                                  UserContext,
                                  Use64,
                                  CallBackUsesUnicode);
        if (!rc) {
            if (mi->code == ERROR_CANCELLED) {
                mi->code = 0;
                return true;
            }
            return rc;
        }

        return true;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}

BOOL
IMAGEAPI
SymEnumSymbolsForAddr(
    IN HANDLE                       hProcess,
    IN DWORD64                      Address,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe)
            return error( ERROR_INVALID_HANDLE );

        mi = GetModuleForPC( pe, Address, false );
        if (!mi)
            return error( ERROR_MOD_NOT_FOUND );

        if (!LoadSymbols(hProcess, mi, 0))
            return error( ERROR_MOD_NOT_FOUND );

        return EnumSymForAddr(pe,
                              mi,
                              Address,
                              (PROC) EnumSymbolsCallback,
                              UserContext,
                              false,
                              false);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}


BOOL
IMAGEAPI
SymEnumSym(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    return SymEnumSymbols(hProcess,
                          BaseOfDll,
                          NULL,
                          EnumSymbolsCallback,
                          UserContext);
}


BOOL
IMAGEAPI
SymEnumTypes(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    PPROCESS_ENTRY      pe;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       mi;

    pe = FindProcessEntry( hProcess );
    if (!pe)
        return error( ERROR_INVALID_HANDLE );

    mi = NULL;
    Next = pe->ModuleList.Flink;
    if (Next) {
        while (Next != &pe->ModuleList) {
            mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
            if (!mi)
                break;
            Next = mi->ListEntry.Flink;
            if (mi->BaseOfDll == BaseOfDll)
                break;
        }
    }

    if (!mi) {
        return false;
    }

    if (!LoadSymbols(hProcess, mi, 0))
        return error(ERROR_MOD_NOT_FOUND);

    return diaEnumUDT(mi, "", EnumSymbolsCallback, UserContext);
}


BOOL
IMAGEAPI
SymGetTypeFromName(
    IN  HANDLE              hProcess,
    IN  ULONG64             BaseOfDll,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    )
{
    PPROCESS_ENTRY      pe;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       mi;

    pe = FindProcessEntry( hProcess );
    if (!pe)
        return error( ERROR_INVALID_HANDLE );

    mi = NULL;
    Next = pe->ModuleList.Flink;
    if (Next) {
        while (Next != &pe->ModuleList) {
            mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
            if (!mi)
                break;
            Next = mi->ListEntry.Flink;
            if (mi->BaseOfDll == BaseOfDll)
                break;
        }
    }

    if (!mi || mi->BaseOfDll != BaseOfDll) {
        LPSTR p;
        // first check for fully qualified symbol name I.E. mod!sym

        p = strchr( Name, '!' );
        if (p > Name) {

            LPSTR ModName = (LPSTR)MemAlloc(p - Name + 1);
            if (!ModName)
                return error( ERROR_NOT_ENOUGH_MEMORY );
            memcpy(ModName, Name, (int)(p - Name));
            ModName[p-Name] = 0;

            //
            // the caller wants to look in a specific module
            //

            mi = FindModule(hProcess, pe, ModName, true);

            MemFree(ModName);

            if (mi == NULL) {

                return false;
            }
            Name = p+1;
        } else {
            return false;
        }
    }

    if (!LoadSymbols(hProcess, mi, 0))
        return error(ERROR_MOD_NOT_FOUND);

    if (diaGetTiForUDT(mi, Name, Symbol)) {
        return true;
    } else {
        return false;
    }

    return false;
}

BOOL
strcmpre(
    PCSTR pStr,
    PCSTR pRE,
    BOOL  fCase
    )
{
    DWORD rc;
    WCHAR wstr[MAX_SYM_NAME + 2];
    WCHAR wre[MAX_SYM_NAME + 100];

    ansi2wcs(pStr, wstr, MAX_SYM_NAME + 2);
    ansi2wcs(pRE, wre, MAX_SYM_NAME + 100);

    rc = CompareRE(wstr, wre, fCase);
    if (rc == S_OK)
        return false;

    return true;
}


BOOL
IMAGEAPI
SymMatchString(
    IN LPSTR string,
    IN LPSTR expression,
    IN BOOL  fCase
    )
{
    return !strcmpre(string, expression, fCase);
}

BOOL
SymEnumSourceFiles(
    IN HANDLE  hProcess,
    IN ULONG64 ModBase,
    IN LPSTR   Mask,
    IN PSYM_ENUMSOURCFILES_CALLBACK cbSrcFiles,
    IN PVOID   UserContext
    )
{
    PPROCESS_ENTRY      pe;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       mi;
    DWORD               i;
    PSYMBOL_ENTRY       sym;
    LPSTR               szSymName;
    SYMBOL_ENTRY        SymEntry={0};
    CHAR                Buffer[2500];
    LPSTR               p;
    CHAR                modmask[200];
    BOOL                rc;
    int                 pass;
    BOOL                fCase;

    static DWORD        flags[2] = {LS_JUST_TEST, LS_QUALIFIED | LS_FAIL_IF_LOADED};

    if (!cbSrcFiles)
        return error(ERROR_INVALID_PARAMETER);

    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe)
            return error( ERROR_INVALID_HANDLE );

        p = 0;
        modmask[0] = 0;
        if (Mask)
            p = strchr(Mask, '!');
        if (p > Mask) {
            memcpy(modmask, Mask, (int)(p - Mask));
            modmask[p-Mask] = 0;
            Mask = p + 1;
        }

        for (pass = 0; pass < 2; pass++) {
            Next = pe->ModuleList.Flink;
            if (Next) {
                while (Next != &pe->ModuleList) {

                    mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                    Next = mi->ListEntry.Flink;
                    if (ModBase) {
                        if (mi->BaseOfDll != ModBase)
                            continue;
                    } else if (!MatchModuleName(mi, modmask)) {
                        continue;
                    }

                    if (!LoadSymbols(hProcess, mi, flags[pass])) {
                        if (GetLastError() == ERROR_CANCELLED)
                            return false;
                        continue;
                    }

                    if (mi->dia) {
                        rc = diaEnumSourceFiles(mi, Mask, cbSrcFiles, UserContext);
                        if (!rc) {
                            if (mi->code == ERROR_CANCELLED) {
                                mi->code = 0;
                                return true;
                            }
                            return rc;
                        }
                        continue;
                    }
#if 0
                    fCase = option(SYMOPT_CASE_INSENSITIVE) ? false : true;

                    for (i = 0; i < mi->numsyms; i++) {
                        PSYMBOL_INFO SymInfo = (PSYMBOL_INFO) &Buffer[0];

                        sym = &mi->symbolTable[i];

                        if (Mask  && *Mask && strcmpre(sym->Name, Mask, fCase))
                            continue;

                    }
#endif
                }
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return false;

    }

    return true;
}


PWSTR
AnsiToUnicode(
    PSTR pszAnsi
    )
{
    UINT uSizeUnicode;
    PWSTR pwszUnicode;

    if (!pszAnsi) {
        return NULL;
    }

    uSizeUnicode = (strlen(pszAnsi) + 1) * sizeof(wchar_t);
    pwszUnicode = (PWSTR)MemAlloc(uSizeUnicode);

    if (*pszAnsi && pwszUnicode) {

        ZeroMemory(pwszUnicode, uSizeUnicode);
        if (!MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
            pszAnsi, strlen(pszAnsi),
            pwszUnicode, uSizeUnicode)) {

            // Error. Free the string, return NULL.
            MemFree(pwszUnicode);
            pwszUnicode = NULL;
        }
    }

    return pwszUnicode;
}


BOOL
wcs2ansi(
    PWSTR pwsz,
    PSTR  psz,
    DWORD pszlen
    )
{
    BOOL rc;
    int  len;

    assert(psz && pwsz);

    len = wcslen(pwsz);
    if (!len) {
        *psz = 0;
        return true;
    }

    rc = WideCharToMultiByte(CP_ACP,
                             WC_SEPCHARS | WC_COMPOSITECHECK,
                             pwsz,
                             len,
                             psz,
                             pszlen,
                             NULL,
                             NULL);
    if (!rc)
        return false;

    psz[len] = 0;

    return true;
}


BOOL
ansi2wcs(
    PCSTR  psz,
    PWSTR pwsz,
    DWORD pwszlen
    )
{
    BOOL rc;
    int  len;

    assert(psz && pwsz);

    len = strlen(psz);
    if (!len) {
        *pwsz = 0L;
        return true;
    }

    rc = MultiByteToWideChar(CP_ACP,
                             MB_COMPOSITE,
                             psz,
                             len,
                             pwsz,
                             pwszlen);
    if (!rc)
        return false;

    pwsz[len] = 0;

    return true;
}


PSTR
UnicodeToAnsi(
    PWSTR pwszUnicode
    )
{
    UINT uSizeAnsi;
    PSTR pszAnsi;

    if (!pwszUnicode) {
        return NULL;
    }

    uSizeAnsi = wcslen(pwszUnicode) + 1;
    pszAnsi = (PSTR)MemAlloc(uSizeAnsi);

    if (*pwszUnicode && pszAnsi) {

        ZeroMemory(pszAnsi, uSizeAnsi);
        if (!WideCharToMultiByte(CP_ACP, WC_SEPCHARS | WC_COMPOSITECHECK,
            pwszUnicode, wcslen(pwszUnicode),
            pszAnsi, uSizeAnsi, NULL, NULL)) {

            // Error. Free the string, return NULL.
            free(pszAnsi);
            pszAnsi = NULL;
        }
    }

    return pszAnsi;
}


BOOL
IMAGEAPI
SymGetTypeInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    )
{
    HRESULT err;

    err = diaGetSymbolInfo(hProcess, ModBase, TypeId, GetType, pInfo);
    SetLastError((ULONG) err);
    return (err==S_OK);
}

//#ifdef _WIN64
#if 0
BOOL  __cdecl  PDBOpenTpi(PDB* ppdb, const char* szMode,  TPI** pptpi) {return false;}
BOOL  __cdecl  PDBCopyTo(PDB* ppdb, const char* szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved){return false;}
BOOL  __cdecl  PDBClose(PDB* ppdb) {return false;}
BOOL  __cdecl  ModQueryImod(Mod* pmod,  USHORT* pimod) {return false;}
BOOL  __cdecl  ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb) {return false;}
BOOL  __cdecl  DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off,  Mod** ppmod,  USHORT* pisect,  long* poff,  long* pcb){return false;}
BOOL  __cdecl  ModClose(Mod* pmod){return false;}
BOOL  __cdecl  DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext) {return false;}
BYTE* __cdecl  GSINextSym (GSI* pgsi, BYTE* pbSym) {return NULL;}
BOOL  __cdecl  PDBOpen(char* szPDB,char* szMode,SIG sigInitial,EC* pec,char szError[cbErrMax],PDB** pppdb) {return false;}
BOOL  __cdecl  TypesClose(TPI* ptpi){return false;}
BOOL  __cdecl  GSIClose(GSI* pgsi){return false;}
BOOL  __cdecl  DBIClose(DBI* pdbi){return false;}
BYTE* __cdecl  GSINearestSym (GSI* pgsi, USHORT isect, long off, long* pdisp){return NULL;}
BOOL  __cdecl  PDBOpenValidate(char* szPDB,char* szPath,char* szMode,SIG sig,AGE age,EC* pec,char szError[cbErrMax],PDB** pppdb){return false;}
BOOL  __cdecl  PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget,  DBI** ppdbi){return false;}
BOOL  __cdecl  DBIOpenPublics(DBI* pdbi,  GSI **ppgsi){return false;}
BOOL  __cdecl  DBIQuerySecMap(DBI* pdbi,  BYTE* pb, long* pcb){return false;}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\sympriv.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    symbolsp.c

Abstract:

    This function implements a generic simple symbol handler.

Author:

    Wesley Witt (wesw) 1-Sep-1994

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>
#include "private.h"
#include "symbols.h"
#include "globals.h"
#include "tlhelp32.h"

#include "fecache.hpp"

typedef BOOL   (WINAPI *PMODULE32)(HANDLE, LPMODULEENTRY32);
typedef HANDLE (WINAPI *PCREATE32SNAPSHOT)(DWORD, DWORD);

typedef ULONG (NTAPI *PRTLQUERYPROCESSDEBUGINFORMATION)(HANDLE,ULONG,PRTL_DEBUG_INFORMATION);
typedef PRTL_DEBUG_INFORMATION (NTAPI *PRTLCREATEQUERYDEBUGBUFFER)(ULONG,BOOLEAN);
typedef NTSTATUS (NTAPI *PRTLDESTROYQUERYDEBUGBUFFER)(PRTL_DEBUG_INFORMATION);
typedef NTSTATUS (NTAPI *PNTQUERYSYSTEMINFORMATION)(SYSTEM_INFORMATION_CLASS,PVOID,ULONG,PULONG);
typedef ULONG (NTAPI *PRTLNTSTATUSTODOSERROR)(NTSTATUS);
//typedef NTSTATUS (NTAPI *PNTQUERYINFORMATIONPROCESS)(UINT_PTR,PROCESSINFOCLASS,UINT_PTR,ULONG,UINT_PTR);
typedef NTSTATUS (NTAPI *PNTQUERYINFORMATIONPROCESS)(HANDLE,PROCESSINFOCLASS,PVOID,ULONG,PULONG);

DWORD_PTR Win95GetProcessModules(HANDLE, PGET_MODULE ,PVOID);
DWORD_PTR NTGetProcessModules(HANDLE, PGET_MODULE ,PVOID);
DWORD64 miGetModuleBase(HANDLE hProcess, DWORD64 Address);

// private version of qsort used to avoid compat problems on NT4 and win2k.
// code is published from base\crts
extern
void __cdecl dbg_qsort(void *, size_t, size_t,
                       int (__cdecl *) (const void *, const void *));


typedef struct _SYMBOL_INFO_LOOKUP {
    ULONG       Segment;
    ULONG64     Offset;
    PCHAR       NamePtr;
    SYMBOL_INFO SymInfo;
} SYMBOL_INFO_LOOKUP;


//
// Get the address form section no and offset in a PE file
//
ULONG
GetAddressFromOffset(
    PMODULE_ENTRY mi,
    ULONG         section,
    ULONG64       Offset,
    PULONG64      pAddress
    )
{
    ULONG Bias;
    
#ifdef DO_NB09
    *pAddress = mi->BaseOfDll + Offset;
    return true;
#endif

    if (section > mi->NumSections
        || !pAddress
        || !section
        || !mi
        )
    {
        // Invalid !!
        return false;
    }

    *pAddress = mi->BaseOfDll + mi->OriginalSectionHdrs[section-1].VirtualAddress + Offset;
    *pAddress = ConvertOmapFromSrc( mi, *pAddress, &Bias );
    if (*pAddress) {
        *pAddress += Bias;
    }
    return true;
}

/*
 * GetSymbolInfo
 *         This extracts useful information from a CV SYMBOl record into a generic
 *         SYMBOL_ENTRY structure.
 *
 *
 */
ULONG
GetSymbolInfo(
    PMODULE_ENTRY me,
    PCHAR         pRawSym,
    SYMBOL_INFO_LOOKUP  *pSymEntry
    )
{
    PCHAR SymbolInfo = pRawSym;
    ULONG symIndex, typeIndex=0, segmentNum=0;
    ULONG64 Offset=0, Address=0, Value=0;
//  ULONG Register=0, bpRel=0, BaseReg=0;
    BOOL HasAddr=false, HasValue=false;
    PSYMBOL_INFO pSymInfo = &pSymEntry->SymInfo;

    if ((pRawSym != NULL) && (pSymEntry != NULL)) {

        SymbolInfo = (PCHAR) pRawSym;
        typeIndex = 0;
        symIndex = ((SYMTYPE *) (pRawSym))->rectyp;
        ZeroMemory(pSymEntry, sizeof(SYMBOL_INFO));

        pSymInfo->ModBase = me->BaseOfDll;


#define ExtractSymName(from) (pSymEntry->NamePtr = ((PCHAR) from) + 1); pSymInfo->NameLen = (UCHAR) *((PUCHAR) from);
        switch (symIndex) {
        case S_COMPILE : // 0x0001   Compile flags symbol
        case S_REGISTER_16t : { // 0x0002   Register variable
            break;
        }
        case S_CONSTANT_16t : { // 0x0003   constant symbol
            DWORD len=4;
            CONSTSYM_16t *constSym;

            constSym = (CONSTSYM_16t *) SymbolInfo;
            typeIndex = constSym->typind;
//            GetNumericValue((PCHAR)&constSym->value, &Value, &len);

            pSymInfo->Flags |= SYMFLAG_VALUEPRESENT;
            pSymInfo->Value = Value;
            ExtractSymName((constSym->name + len));
            break;
        }
        case S_UDT_16t : { // 0x0004   User defined type
            UDTSYM_16t *udtSym;

            udtSym = (UDTSYM_16t *) SymbolInfo;
            typeIndex = udtSym->typind;
            ExtractSymName(udtSym->name); 
            break;
        }
        case S_SSEARCH : // 0x0005   Start Search
        case S_END : // 0x0006   Block, procedure, "with" or thunk end
        case S_SKIP : // 0x0007   Reserve symbol space in $$Symbols table
        case S_CVRESERVE : // 0x0008   Reserved symbol for CV internal use
        case S_OBJNAME : // 0x0009   path to object file name
        case S_ENDARG : // 0x000a   end of argument/return list
        case S_COBOLUDT_16t : // 0x000b   special UDT for cobol that does not symbol pack
        case S_MANYREG_16t : // 0x000c   multiple register variable
        case S_RETURN : // 0x000d   return description symbol
        case S_ENTRYTHIS : // 0x000e   description of this pointer on entry
            break;

        case S_BPREL16 : // 0x0100   BP-relative
        case S_LDATA16 : // 0x0101   Module-local symbol
        case S_GDATA16 : // 0x0102   Global data symbol
        case S_PUB16 : // 0x0103   a public symbol
        case S_LPROC16 : // 0x0104   Local procedure start
        case S_GPROC16 : // 0x0105   Global procedure start
        case S_THUNK16 : // 0x0106   Thunk Start
        case S_BLOCK16 : // 0x0107   block start
        case S_WITH16 : // 0x0108   with start
        case S_LABEL16 : // 0x0109   code label
        case S_CEXMODEL16 : // 0x010a   change execution model
        case S_VFTABLE16 : // 0x010b   address of virtual function table
        case S_REGREL16 : // 0x010c   register relative address
        case S_BPREL32_16t : { // 0x0200   BP-relative
            DATASYM16 *pData;

            pData = (DATASYM16 *) SymbolInfo;
            typeIndex = pData->typind;
            Offset = pData->off; segmentNum = pData->seg;
            HasAddr = true;
            ExtractSymName(pData->name);
            break;
        }

        case S_LDATA32_16t :// 0x0201   Module-local symbol
        case S_GDATA32_16t :// 0x0202   Global data symbol
        case S_PUB32_16t : { // 0x0203   a public symbol (CV internal reserved)
            DATASYM32_16t *pData;

            pData = (DATASYM32_16t *) SymbolInfo;
            typeIndex = pData->typind;
            Offset = pData->off; segmentNum = pData->seg;
            HasAddr = true;
            ExtractSymName(pData->name);
            break;
        }
        case S_LPROC32_16t : // 0x0204   Local procedure start
        case S_GPROC32_16t : { // 0x0205   Global procedure start
            PROCSYM32_16t *procSym;

            procSym = (PROCSYM32_16t *)SymbolInfo;
            // CONTEXT-SENSITIVE
            // Offset = procSym->off; segmentNum = procSym->seg;
            typeIndex = procSym->typind;
            ExtractSymName(procSym->name);
            break;
        }
        case S_THUNK32 : // 0x0206   Thunk Start
        case S_BLOCK32 : // 0x0207   block start
        case S_WITH32 : // 0x0208   with start
        case S_LABEL32 : // 0x0209   code label
        case S_CEXMODEL32 : // 0x020a   change execution model
        case S_VFTABLE32_16t : // 0x020b   address of virtual function table
        case S_REGREL32_16t : // 0x020c   register relative address
        case S_LTHREAD32_16t : // 0x020d   local thread storage
        case S_GTHREAD32_16t : // 0x020e   global thread storage
        case S_SLINK32 : // 0x020f   static link for MIPS EH implementation
        case S_LPROCMIPS_16t : // 0x0300   Local procedure start
        case S_GPROCMIPS_16t : { // 0x0301   Global procedure start
            break;
        }

        case S_PROCREF : { // 0x0400   Reference to a procedure
            // typeIndex = ((PDWORD) symReturned) + 3;
            break;
        }
        case S_DATAREF : // 0x0401   Reference to data
        case S_ALIGN : // 0x0402   Used for page alignment of symbols
        case S_LPROCREF : // 0x0403   Local Reference to a procedure

            // sym records with 32-bit types embedded instead of 16-bit
            // all have  0x1000 bit set for easy identification
            // only do the 32-bit target versions since we don't really
            // care about 16-bit ones anymore.
        case S_TI16_MAX : // 0x1000,
            break;

        case S_REGISTER : { // 0x1001   Register variable
            REGSYM *regSym;

            regSym             = (REGSYM *)SymbolInfo;
            typeIndex          = regSym->typind;
            pSymInfo->Flags    = SYMFLAG_REGISTER;
            pSymInfo->Register = (DWORD)regSym->reg;
            ExtractSymName(regSym->name);
            break;
        }

        case S_CONSTANT : { // 0x1002   constant symbol
            CONSTSYM *constSym;
            DWORD len=4, val;

            constSym = (CONSTSYM *) SymbolInfo;
//            GetNumericValue((PCHAR)&constSym->value, &Value, &len);

            pSymInfo->Flags |= SYMFLAG_VALUEPRESENT;
            pSymInfo->Value = Value;
            typeIndex = constSym->typind;
            ExtractSymName((constSym->name+len));
            break;
        }
        case S_UDT : { // 0x1003   User defined type
            UDTSYM *udtSym;

            udtSym = (UDTSYM *) SymbolInfo;
            typeIndex = udtSym->typind;
            ExtractSymName(udtSym->name);
            break;
        }

        case S_COBOLUDT : // 0x1004   special UDT for cobol that does not symbol pack
            break;

        case S_MANYREG : // 0x1005   multiple register variable
            break;

        case S_BPREL32 : { // 0x1006   BP-relative
            BPRELSYM32 *bprelSym;

            bprelSym = (BPRELSYM32 *)SymbolInfo;
            typeIndex = bprelSym->typind;
            pSymInfo->Flags   = SYMFLAG_FRAMEREL;
            pSymInfo->Address = bprelSym->off;
            ExtractSymName(bprelSym->name);
            break;
        }

        case S_LDATA32 : // 0x1007   Module-local symbol
        case S_GDATA32 : // 0x1008   Global data symbol
        case S_PUB32 : { // 0x1009   a public symbol (CV internal reserved)
            DATASYM32 *dataSym;

            dataSym = (DATASYM32 *)SymbolInfo;
            HasAddr = true;
            Offset = dataSym->off; segmentNum = dataSym->seg;
            typeIndex = dataSym->typind; //(PDWORD) symReturned;
            ExtractSymName(dataSym->name);  

            break;
        }
        case S_LPROC32 :  // 0x100a   Local procedure start
        case S_GPROC32 : { // 0x100b   Global procedure start
            PROCSYM32 *procSym;

            procSym = (PROCSYM32 *) SymbolInfo;
            // CONTEXT-SENSITIVE
            HasAddr = true;
            Offset = procSym->off; segmentNum = procSym->seg;
            typeIndex = procSym->typind;
            ExtractSymName(procSym->name);
            break;
        }

        case S_VFTABLE32 : // 0x100c   address of virtual function table
            break;

        case S_REGREL32 : { // 0x100d   register relative address
            REGREL32 *regrelSym;

            regrelSym = (REGREL32 *)SymbolInfo;
            typeIndex = regrelSym->typind;
            pSymInfo->Flags   = SYMFLAG_REGREL;
            pSymInfo->Address = regrelSym->off;
            pSymInfo->Register = (DWORD)regrelSym->reg;
            ExtractSymName(regrelSym->name);
            break;
        }

        case S_LTHREAD32 : // 0x100e   local thread storage
        case S_GTHREAD32 : // 0x100f   global thread storage
        case S_LPROCMIPS : // 0x1010   Local procedure start
        case S_GPROCMIPS : // 0x1011   Global procedure start
        case S_FRAMEPROC : // 0x1012   extra frame and proc information
        case S_COMPILE2 : // 0x1013   extended compile flags and info
        case S_MANYREG2 : // 0x1014   multiple register variable
        case S_LPROCIA64 : // 0x1015   Local procedure start (IA64)
        case S_GPROCIA64 : // 0x1016   Global procedure start (IA64)
        case S_RECTYPE_MAX :
        default:
            return false;
        } /* switch */


        if (HasAddr && GetAddressFromOffset(me, segmentNum, Offset, &Address)) {
            pSymInfo->Address   = Address;
        }

        pSymInfo->TypeIndex = typeIndex;
        pSymEntry->Offset   = Offset;
        pSymEntry->Segment  = segmentNum;

    } else {
        return false;
    }

    return true;
}

/*
 * cvExtractSymbolInfo
 *         This extracts useful information from a CV SYMBOl record into a generic
 *         SYMBOL_ENTRY structure.
 *
 *
 */
ULONG
cvExtractSymbolInfo(
    PMODULE_ENTRY me,
    PCHAR         pRawSym,
    PSYMBOL_ENTRY pSymEntry,
    BOOL          fCopyName
    )
{
    SYMBOL_INFO_LOOKUP SymInfoLookup={0};
    ULONG reg;

    pSymEntry->Size       = 0;
    pSymEntry->Flags      = 0;
    pSymEntry->Address    = 0;
    if (fCopyName)
        *pSymEntry->Name  = 0;
    else
        pSymEntry->Name   = 0;
    pSymEntry->NameLength = 0;
    pSymEntry->Segment    = 0;
    pSymEntry->Offset     = 0;
    pSymEntry->TypeIndex  = 0;
    pSymEntry->ModBase    = 0;

    if (GetSymbolInfo(me, pRawSym, &SymInfoLookup)) {
        LARGE_INTEGER li;
        pSymEntry->NameLength = SymInfoLookup.SymInfo.NameLen;
        pSymEntry->TypeIndex  = SymInfoLookup.SymInfo.TypeIndex;
        pSymEntry->Offset  = SymInfoLookup.Offset;
        pSymEntry->Segment = SymInfoLookup.Segment;
        pSymEntry->ModBase = me->BaseOfDll;
        // NOTE: this was implented as a mask - but used differently
        switch (SymInfoLookup.SymInfo.Flags)
        {
        case SYMFLAG_REGISTER:
            pSymEntry->Flags = SYMFLAG_REGISTER;
            pSymEntry->Address = SymInfoLookup.SymInfo.Register;
            break;

        case SYMFLAG_REGREL:
            // DBGHELP_HACK - HiPart of Addr = RegId , LowPart = Pffset
            pSymEntry->Flags = SYMFLAG_REGREL;
            li.LowPart         = (ULONG) SymInfoLookup.SymInfo.Address;
            li.HighPart        = SymInfoLookup.SymInfo.Register;
            pSymEntry->Segment = SymInfoLookup.SymInfo.Register;
            pSymEntry->Address = li.QuadPart;
            break;

        case SYMFLAG_FRAMEREL:
            pSymEntry->Flags = SYMFLAG_FRAMEREL;
            pSymEntry->Address = SymInfoLookup.SymInfo.Address;
            break;

        case SYMFLAG_VALUEPRESENT:
        default:
            pSymEntry->Address = SymInfoLookup.SymInfo.Address;
            break;
        }
        if (fCopyName) {
            if (!pSymEntry->Name)
                return false;
            *pSymEntry->Name = 0;
            strncpy(pSymEntry->Name, SymInfoLookup.NamePtr ? SymInfoLookup.NamePtr : "", SymInfoLookup.SymInfo.NameLen);  // SECURITY: Don't know size of output buffer.
        } else {
            pSymEntry->Name = SymInfoLookup.NamePtr;
        }
        return true;
    }

    return false;
}

DWORD_PTR
NTGetPID(
    HANDLE hProcess
    )
{
    HMODULE hModule;
    PNTQUERYINFORMATIONPROCESS NtQueryInformationProcess;
    PROCESS_BASIC_INFORMATION pi;
    NTSTATUS status;

    hModule = GetModuleHandle( "ntdll.dll" );
    if (!hModule) {
        return ERROR_MOD_NOT_FOUND;
    }

    NtQueryInformationProcess = (PNTQUERYINFORMATIONPROCESS)GetProcAddress(
        hModule,
        "NtQueryInformationProcess"
        );

    if (!NtQueryInformationProcess) {
        return ERROR_INVALID_FUNCTION;
    }


    // When running with the AppVerifier this will throw
    // a bad-handle exception when hProcess isn't actually
    // a process handle.  As that's an expected case, protect
    // against it.

    __try {
        status = NtQueryInformationProcess(hProcess,
                                           ProcessBasicInformation,
                                           &pi,
                                           sizeof(pi),
                                           NULL);

        if (!NT_SUCCESS(status))
            pi.UniqueProcessId = 0;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        pi.UniqueProcessId = 0;
    }

    return pi.UniqueProcessId;
}


//
// the block bounded by the #ifdef _X86_ statement
// contains the code for getting the PID from an
// HPROCESS when running under Win9X
//

#ifdef _X86_

#define HANDLE_INVALID                 ((HANDLE)0xFFFFFFFF)
#define HANDLE_CURRENT_PROCESS   ((HANDLE)0x7FFFFFFF)
#define HANDLE_CURRENT_THREAD    ((HANDLE)0xFFFFFFFE)
#define MAX_HANDLE_VALUE         ((HANDLE)0x00FFFFFF)


// Thread Information Block.

typedef struct _TIB {

    DWORD     unknown[12];
    DWORD_PTR ppdb;

} TIB, *PTIB;

// Task Data Block

typedef struct _TDB {

    DWORD unknown[2];
    TIB         tib;

} TDB, *PTDB;

typedef struct _OBJ {

    BYTE    typObj;             // object type
    BYTE    objFlags;           // object flags
    WORD    cntUses;            // count of this objects usage

} OBJ, *POBJ;

typedef struct _HTE {

    DWORD   flFlags;
    POBJ    pobj;

} HTE, *PHTE;

typedef struct _HTB {

    DWORD   chteMax;
    HTE     rghte[1];

} HTB, *PHTB;

typedef struct _W9XPDB {

    DWORD  unknown[17];
    PHTB   phtbHandles;

} W9XPDB, *PW9XPDB;

#pragma warning(disable:4035)

_inline struct _TIB * GetCurrentTib(void) { _asm mov eax, fs:[0x18] }

// stuff needed to convert local handle

#define IHTETOHANDLESHIFT  2
#define GLOBALHANDLEMASK  (0x453a4d3cLU)

#define IHTEFROMHANDLE(hnd) ((hnd) == HANDLE_INVALID ? (DWORD)(hnd) : (((DWORD)(hnd)) >> IHTETOHANDLESHIFT))

#define IHTEISGLOBAL(ihte) \
        (((ihte) >> (32 - 8 - IHTETOHANDLESHIFT)) == (((DWORD)GLOBALHANDLEMASK) >> 24))

#define IS_WIN32_PREDEFINED_HANDLE(hnd) \
        ((hnd == HANDLE_CURRENT_PROCESS)||(hnd == HANDLE_CURRENT_THREAD)||(hnd == HANDLE_INVALID))

DWORD
GetWin9xObsfucator(
  VOID
  )
/*++

Routine Description:

  GetWin9xObsfucator()


Arguments:

  none


Return Value:

  Obsfucator key used by Windows9x to hide Process and Thread Id's


Notes:

  The code has only been tested on Windows98SE and Millennium.


--*/
{
    DWORD ppdb       = 0;      // W9XPDB = Process Data Block
    DWORD processId  = (DWORD) GetCurrentProcessId();

    // get PDB pointer

    ppdb = GetCurrentTib()->ppdb;

    return ppdb ^ processId;
}


DWORD_PTR
GetPtrFromHandle(
  IN HANDLE Handle
  )
/*++

Routine Description:

  GetPtrFromHandle()


Arguments:

  Handle - handle from Process handle table


Return Value:

  Real Pointer to object


Notes:

  The code has only been tested on Windows98SE and Millennium.


--*/
{
    DWORD_PTR ptr  = 0;
    DWORD     ihte = 0;
    PW9XPDB   ppdb = 0;

    ppdb = (PW9XPDB) GetCurrentTib()->ppdb;

    // check for pre-defined handle values.

    if (Handle == HANDLE_CURRENT_PROCESS) {
        ptr = (DWORD_PTR) ppdb;
    } else if (Handle == HANDLE_CURRENT_THREAD) {
        ptr = (DWORD_PTR) CONTAINING_RECORD(GetCurrentTib(), TDB, tib);
    } else if (Handle == HANDLE_INVALID) {
        ptr = 0;
    } else {
        // not a special handle, we can perform our magic.

        ihte = IHTEFROMHANDLE(Handle);

        // if we have a global handle, it is only meaningful in the context
        // of the kernel process's handle table...we don't currently deal with
        // this type of handle

        if (!(IHTEISGLOBAL(ihte))) {
            ptr = (DWORD_PTR) ppdb->phtbHandles->rghte[ihte].pobj;
        }
    }

    return ptr;
}


DWORD_PTR
Win9xGetPID(
  IN HANDLE hProcess
  )
/*++

Routine Description:

  Win9xGetPid()


Arguments:

  hProcess - Process handle


Return Value:

  Process Id


Notes:

  The code has only been tested on Windows98SE and Millennium.


--*/
{
    static DWORD dwObsfucator = 0;

    // check to see that we have a predefined handle or an index into
    // our local handle table.

    if (IS_WIN32_PREDEFINED_HANDLE(hProcess) || (hProcess < MAX_HANDLE_VALUE)) {
        if (!dwObsfucator) {
            dwObsfucator = GetWin9xObsfucator();
            assert(dwObsfucator != 0);
        }
        return dwObsfucator ^ GetPtrFromHandle(hProcess);
    }

    // don't know what we have here

    return 0;
}

#endif // _X86_


DWORD_PTR
GetPID(
    HANDLE hProcess
    )
{
    OSVERSIONINFO VerInfo;

    if (hProcess == GetCurrentProcess())
        return GetCurrentProcessId();

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        return NTGetPID(hProcess);
    } else {
#ifdef _X86_
        return Win9xGetPID(hProcess);
#else
        return 0;
#endif
    }
}


PMODULE_ENTRY
GetModFromAddr(
    PPROCESS_ENTRY    pe,
    IN  DWORD64       addr
    )
{
    PMODULE_ENTRY mi = NULL;

    __try {
        mi = GetModuleForPC(pe, addr, false);
        if (!mi) {
            SetLastError(ERROR_MOD_NOT_FOUND);
            return NULL;
        }

        if (!LoadSymbols(pe->hProcess, mi, 0)) {
            SetLastError(ERROR_MOD_NOT_FOUND);
            return NULL;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return NULL;
    }

    return mi;
}


DWORD
GetProcessModules(
    HANDLE      hProcess,
    PGET_MODULE cbGetModule,
    PVOID       Context
    )
{
#ifdef _X86_
    OSVERSIONINFO VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        return NTGetProcessModules(hProcess, cbGetModule, Context);
    } else {
        return Win95GetProcessModules(hProcess, cbGetModule, Context);
    }
}


DWORD
Win95GetProcessModules(
    HANDLE      hProcess,
    PGET_MODULE cbGetModule,
    PVOID       Context
    )
{
    MODULEENTRY32 mi;
    PMODULE32     pModule32Next, pModule32First;
    PCREATE32SNAPSHOT pCreateToolhelp32Snapshot;
    HANDLE hSnapshot;
    HMODULE hToolHelp;
    DWORD pid;

    // get the PID:
    // this hack supports old bug workaround, in which callers were passing
    // a pid, because an hprocess didn't work on W9X.

    pid = GetPID(hProcess);
    if (!pid)
        pid = (DWORD)hProcess;

    // get the module list from toolhelp apis

    hToolHelp = GetModuleHandle("kernel32.dll");
    if (!hToolHelp)
        return ERROR_MOD_NOT_FOUND;

    pModule32Next = (PMODULE32)GetProcAddress(hToolHelp, "Module32Next");
    pModule32First = (PMODULE32)GetProcAddress(hToolHelp, "Module32First");
    pCreateToolhelp32Snapshot = (PCREATE32SNAPSHOT)GetProcAddress(hToolHelp, "CreateToolhelp32Snapshot");
    if (!pModule32Next || !pModule32First || !pCreateToolhelp32Snapshot)
        return ERROR_MOD_NOT_FOUND;

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
    if (hSnapshot == (HANDLE)-1) {
        return ERROR_MOD_NOT_FOUND;
    }

    mi.dwSize = sizeof(MODULEENTRY32);

    if (pModule32First(hSnapshot, &mi)) {
        do
        {
            if (!cbGetModule(
                    hProcess,
                    mi.szModule,
                    (DWORD) mi.modBaseAddr,
                    mi.modBaseSize,
                    Context))
            {
                break;
            }

        } while ( pModule32Next(hSnapshot, &mi) );
    }

    CloseHandle(hSnapshot);

    return(ERROR_SUCCESS);
}


DWORD
NTGetProcessModules(
    HANDLE      hProcess,
    PGET_MODULE cbGetModule,
    PVOID       Context
    )
{

#endif      // _X86_

    PRTLQUERYPROCESSDEBUGINFORMATION    RtlQueryProcessDebugInformation;
    PRTLCREATEQUERYDEBUGBUFFER          RtlCreateQueryDebugBuffer;
    PRTLDESTROYQUERYDEBUGBUFFER         RtlDestroyQueryDebugBuffer;
    HMODULE                             hModule;
    NTSTATUS                            Status;
    PRTL_DEBUG_INFORMATION              Buffer;
    ULONG                               i;
    DWORD_PTR                           ProcessId;

    hModule = GetModuleHandle( "ntdll.dll" );
    if (!hModule) {
        return ERROR_MOD_NOT_FOUND;
    }

    RtlQueryProcessDebugInformation = (PRTLQUERYPROCESSDEBUGINFORMATION)GetProcAddress(
        hModule,
        "RtlQueryProcessDebugInformation"
        );

    if (!RtlQueryProcessDebugInformation) {
        return ERROR_INVALID_FUNCTION;
    }

    RtlCreateQueryDebugBuffer = (PRTLCREATEQUERYDEBUGBUFFER)GetProcAddress(
        hModule,
        "RtlCreateQueryDebugBuffer"
        );

    if (!RtlCreateQueryDebugBuffer) {
        return ERROR_INVALID_FUNCTION;
    }

    RtlDestroyQueryDebugBuffer = (PRTLDESTROYQUERYDEBUGBUFFER)GetProcAddress(
        hModule,
        "RtlDestroyQueryDebugBuffer"
        );

    if (!RtlDestroyQueryDebugBuffer) {
        return ERROR_INVALID_FUNCTION;
    }

    Buffer = RtlCreateQueryDebugBuffer( 0, false );
    if (!Buffer) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ProcessId = GetPID(hProcess);

    // for backwards compatibility with an old bug
    if (!ProcessId)
        ProcessId = (DWORD_PTR)hProcess;

    ULONG QueryFlags = RTL_QUERY_PROCESS_MODULES |
                       RTL_QUERY_PROCESS_NONINVASIVE;

    if (option(SYMOPT_INCLUDE_32BIT_MODULES)) {
        QueryFlags |= RTL_QUERY_PROCESS_MODULES32;
    }

    Status = RtlQueryProcessDebugInformation(
        (HANDLE)ProcessId,
        QueryFlags,
        Buffer
        );

    if (Status != STATUS_SUCCESS) {
        RtlDestroyQueryDebugBuffer( Buffer );
        return(ImagepSetLastErrorFromStatus(Status));
    }

    for (i=0; i<Buffer->Modules->NumberOfModules; i++) {
        PRTL_PROCESS_MODULE_INFORMATION Module = &Buffer->Modules->Modules[i];
        if (!cbGetModule(
                hProcess,
                (LPSTR) &Module->FullPathName[Module->OffsetToFileName],
                (DWORD64)Module->ImageBase,
                (DWORD)Module->ImageSize,
                Context
                ))
        {
            break;
        }
    }

    RtlDestroyQueryDebugBuffer( Buffer );
    return ERROR_SUCCESS;
}


VOID
FreeModuleEntry(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi
    )
{
    FunctionEntryCache* Cache;

    if (pe && (Cache = GetFeCache(mi->MachineType, false)))
        Cache->InvalidateProcessOrModule(pe->hProcess, mi->BaseOfDll);
    if (pe && pe->ipmi == mi)
        pe->ipmi = NULL;
    MemFree( mi->symbolTable  );
    MemFree( mi->SectionHdrs );
    MemFree( mi->OriginalSectionHdrs );
    if (mi->pFpoData)
        VirtualFree( mi->pFpoData, 0, MEM_RELEASE );
    if (mi->pFpoDataOmap)
        VirtualFree( mi->pFpoDataOmap, 0, MEM_RELEASE );
    if (mi->pExceptionData)
        VirtualFree( mi->pExceptionData, 0, MEM_RELEASE );
    MemFree( mi->pPData );
    MemFree( mi->pXData );
    MemFree( mi->TmpSym.Name );
    MemFree(mi->vsTmpSym.Name);
    MemFree( mi->ImageName );
    MemFree( mi->LoadedImageName );
    MemFree( mi->LoadedPdbName );
    MemFree( mi->pOmapTo );
    MemFree( mi->pOmapFrom );
    MemFree( mi->CallerData );
    MemFree(mi->vs);
    if (mi->SourceFiles) {
        PSOURCE_ENTRY Src, SrcNext;

        for (Src = mi->SourceFiles; Src != NULL; Src = SrcNext) {
            SrcNext = Src->Next;
            MemFree(Src);
        }
    }
    RemoveSourceForModuleFromHintList(pe, mi);
    diaRelease(mi->dia);

    MemFree( mi );
}


void
ClearModuleFlags(
    PPROCESS_ENTRY pe
    )
{

    PLIST_ENTRY   next;
    PMODULE_ENTRY mi;

    next = pe->ModuleList.Flink;
    if (!next)
        return;

    while (next != &pe->ModuleList) {
        mi = CONTAINING_RECORD(next, MODULE_ENTRY, ListEntry);
        mi->processed = false;
        next = mi->ListEntry.Flink;
    }
}


BOOL
MatchSymbolName(
    PSYMBOL_ENTRY sym,
    LPSTR         SymName
    )
{
    if (!strcmpre(sym->Name, SymName, option(SYMOPT_CASE_INSENSITIVE) ? false : true))
        return true;

    return false;
}


PSYMBOL_ENTRY
HandleDuplicateSymbols(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    PSYMBOL_ENTRY   sym
    )
{
    DWORD                        i;
    DWORD                        Dups;
    DWORD                        NameSize;
    PIMAGEHLP_SYMBOL64           Sym64 = NULL;
    PIMAGEHLP_SYMBOL             Sym32 = NULL;
    PIMAGEHLP_SYMBOL64           pSym64 = NULL;
    PIMAGEHLP_SYMBOL             pSym32 = NULL;
    IMAGEHLP_DUPLICATE_SYMBOL64  DupSym64;
    IMAGEHLP_DUPLICATE_SYMBOL    DupSym32;
    PULONG                       SymSave = NULL;

    if (!pe->pCallbackFunction32 && !pe->pCallbackFunction64) {
        return sym;
    }

    if (!(sym->Flags & SYMF_DUPLICATE)) {
        return sym;
    }

    Dups = 0;
    NameSize = 0;
    for (i = 0; i < mi->numsyms; i++) {
        if ((mi->symbolTable[i].NameLength == sym->NameLength) &&
            (strcmp( mi->symbolTable[i].Name, sym->Name ) == 0)) {
                Dups += 1;
                NameSize += (mi->symbolTable[i].NameLength + 1);
        }
    }

    if (pe->pCallbackFunction32) {
        
        Sym32 = (PIMAGEHLP_SYMBOL) MemAlloc((sizeof(IMAGEHLP_SYMBOL) + MAX_SYM_NAME) * Dups);
        if (!Sym32) 
            goto cleanup;
        pSym64 = Sym64;

        SymSave = (PULONG) MemAlloc( sizeof(ULONG) * Dups );
        if (!SymSave) 
            goto cleanup;

        DupSym32.SizeOfStruct    = sizeof(IMAGEHLP_DUPLICATE_SYMBOL);
        DupSym32.NumberOfDups    = Dups;
        DupSym32.Symbol          = Sym32;
        DupSym32.SelectedSymbol  = (ULONG) -1;

        Dups = 0;
        for (i = 0; i < mi->numsyms; i++) {
            if ((mi->symbolTable[i].NameLength == sym->NameLength) &&
                (strcmp( mi->symbolTable[i].Name, sym->Name ) == 0)) {
                    pSym32->MaxNameLength = MAX_SYM_NAME;
                    se2sym(&mi->symbolTable[i], pSym32);
                    pSym32 = (PIMAGEHLP_SYMBOL)((PCHAR)pSym32 + sizeof(IMAGEHLP_SYMBOL) + MAX_SYM_NAME);
                    SymSave[Dups] = i;
                    Dups += 1;
            }
        }

    } else {
        
        Sym64 = (PIMAGEHLP_SYMBOL64) MemAlloc((sizeof(IMAGEHLP_SYMBOL64) + MAX_SYM_NAME) * Dups);
        if (!Sym64) 
            goto cleanup;
        pSym64 = Sym64;

        SymSave = (PULONG) MemAlloc( sizeof(ULONG) * Dups );
        if (!SymSave) 
            goto cleanup;

        DupSym64.SizeOfStruct    = sizeof(IMAGEHLP_DUPLICATE_SYMBOL64);
        DupSym64.NumberOfDups    = Dups;
        DupSym64.Symbol          = Sym64;
        DupSym64.SelectedSymbol  = (DWORD)-1;

        Dups = 0;
        for (i = 0; i < mi->numsyms; i++) {
            if ((mi->symbolTable[i].NameLength == sym->NameLength) &&
                (strcmp( mi->symbolTable[i].Name, sym->Name ) == 0)) 
            {
                pSym64->MaxNameLength = MAX_SYM_NAME;
                se2lsym(&mi->symbolTable[i], pSym64);
                pSym64 = (PIMAGEHLP_SYMBOL64)((PCHAR)pSym64 + sizeof(IMAGEHLP_SYMBOL64) + MAX_SYM_NAME);
                SymSave[Dups] = i;
                Dups += 1;
            }
        }
    }

    __try {

        if (pe->pCallbackFunction32) {
            pe->pCallbackFunction32(
                pe->hProcess,
                CBA_DUPLICATE_SYMBOL,
                (PVOID)&DupSym32,
                (PVOID)pe->CallbackUserContext
                );

            if (DupSym32.SelectedSymbol != (DWORD)-1) {
                if (DupSym32.SelectedSymbol < DupSym32.NumberOfDups) {
                    sym = &mi->symbolTable[SymSave[DupSym32.SelectedSymbol]];
                }
            }
        } else {
            pe->pCallbackFunction64(
                pe->hProcess,
                CBA_DUPLICATE_SYMBOL,
                (ULONG64)&DupSym64,
                pe->CallbackUserContext
                );

            if (DupSym64.SelectedSymbol != (DWORD)-1) {
                if (DupSym64.SelectedSymbol < DupSym64.NumberOfDups) 
                    sym = &mi->symbolTable[SymSave[DupSym64.SelectedSymbol]];
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

cleanup:
    MemFree(Sym32);
    MemFree(Sym64);
    MemFree(SymSave);

    return sym;
}


PSYMBOL_INFO
FindSymbolByName(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    )
{
    DWORD         hash;
    PSYMBOL_ENTRY sym;
    PSYMBOL_INFO  si;
    DWORD         i;
    char          sz[MAX_SYM_NAME + 5];

    if (!mi || mi->dia) {
        si = diaFindSymbolByName(pe, mi, SymName);
        if (si || !mi)
            return si;
        return vsFindSymbolByName(pe, mi, SymName);
    }

    hash = ComputeHash( SymName, strlen(SymName) );
    sym = mi->NameHashTable[hash];

    if (sym) {
        //
        // there are collision(s) so lets walk the
        // collision list and match the names
        //
        while( sym ) {
            if (MatchSymbolName( sym, SymName )) {
                sym = HandleDuplicateSymbols( pe, mi, sym );
                se2si(sym, &mi->si);
                return &mi->si;
            }
            sym = sym->Next;
        }
    }

    //
    // the symbol did not hash to anything valid
    // this is possible if the caller passed an undecorated name
    // now we must look linearly thru the list
    //
    PrepRE4Srch(SymName, sz);
    for (i=0; i<mi->numsyms; i++) {
        sym = &mi->symbolTable[i];
        if (MatchSymbolName( sym, sz )) {
            sym = HandleDuplicateSymbols( pe, mi, sym );
            se2si(sym, &mi->si);
            return &mi->si;
        }
    }

    return vsFindSymbolByName(pe, mi, SymName);
}


IMGHLP_RVA_FUNCTION_DATA *
SearchRvaFunctionTable(
    IMGHLP_RVA_FUNCTION_DATA *FunctionTable,
    LONG High,
    LONG Low,
    DWORD dwPC
    )
{
    LONG    Middle;
    IMGHLP_RVA_FUNCTION_DATA *FunctionEntry;

    // Perform binary search on the function table for a function table
    // entry that subsumes the specified PC.

    while (High >= Low) {

        // Compute next probe index and test entry. If the specified PC
        // is greater than of equal to the beginning address and less
        // than the ending address of the function table entry, then
        // return the address of the function table entry. Otherwise,
        // continue the search.

        Middle = (Low + High) >> 1;
        FunctionEntry = &FunctionTable[Middle];
        if (dwPC < FunctionEntry->rvaBeginAddress) {
            High = Middle - 1;

        } else if (dwPC >= FunctionEntry->rvaEndAddress) {
            Low = Middle + 1;

        } else {
            return FunctionEntry;
        }
    }
    return NULL;
}

PIMGHLP_RVA_FUNCTION_DATA
GetFunctionEntryFromDebugInfo (
    PPROCESS_ENTRY  pe,
    DWORD64         ControlPc
    )
{
    PMODULE_ENTRY mi;
    IMGHLP_RVA_FUNCTION_DATA   *FunctionTable;

    mi = GetModuleForPC( pe, ControlPc, false );
    if (mi == NULL) {
        return NULL;
    }

    if (!GetPData(pe->hProcess, mi)) {
        return NULL;
    }

    FunctionTable = (IMGHLP_RVA_FUNCTION_DATA *)mi->pExceptionData;
    return SearchRvaFunctionTable(FunctionTable, mi->dwEntries - 1, 0,
                                  (ULONG)(ControlPc - mi->BaseOfDll));
}


// NTRAID#96939-2000/03/27-patst
//
// All the platform dependent "LookupFunctionEntryXxx" should be retyped as returning
// a PIMAGE_FUNCTION_ENTRY64. This would require a modification of the callers, especially
// the IA64 specific locations that assume that the returned function entries contains RVAs
// and not absolute addresses. I implemented a platform-independant
// "per address space /  per module" cache of function entries - capable of supporting the
// dynamic function entries scheme but I fell short of time in delivering it.

PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntryIa64 (
    HANDLE        hProcess,
    DWORD64       ControlPc
    )
{
    FunctionEntryCache* Cache;
    FeCacheEntry* FunctionEntry;

    if ((Cache = GetFeCache(IMAGE_FILE_MACHINE_IA64, true)) == NULL) {
        return NULL;
    }

//
// IA64-NOTE 08/99: IA64 Function entries contain file offsets, not absolute relocated addresses.
//                  IA64 Callers assume this.
//


    // Don't specify the function table access callback or it will
    // cause recursion.

    FunctionEntry = Cache->
        Find(hProcess, ControlPc, ReadInProcMemory,
             miGetModuleBase, NULL);
    if ( FunctionEntry == NULL ) {
        return NULL;
    }

    tlsvar(Ia64FunctionEntry) = FunctionEntry->Data.Ia64;
    return &tlsvar(Ia64FunctionEntry);
}

_PIMAGE_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntryAmd64 (
    HANDLE        hProcess,
    DWORD64       ControlPc
    )
{
    FunctionEntryCache* Cache;
    FeCacheEntry* FunctionEntry;

    if ((Cache = GetFeCache(IMAGE_FILE_MACHINE_AMD64, true)) == NULL) {
        return NULL;
    }

    // Don't specify the function table access callback or it will
    // cause recursion.

    FunctionEntry = Cache->
        Find(hProcess, ControlPc, ReadInProcMemory,
             miGetModuleBase, NULL);
    if ( FunctionEntry == NULL ) {
        return NULL;
    }

    tlsvar(Amd64FunctionEntry) = FunctionEntry->Data.Amd64;
    return &tlsvar(Amd64FunctionEntry);
}

PFPO_DATA
SwSearchFpoData(
    DWORD     key,
    PFPO_DATA base,
    DWORD     num
    )
{
    PFPO_DATA  lo = base;
    PFPO_DATA  hi = base + (num - 1);
    PFPO_DATA  mid;
    DWORD      half;

    while (lo <= hi) {
        if (half = num / 2) {
            mid = lo + ((num & 1) ? half : (half - 1));
            if ((key >= mid->ulOffStart)&&(key < (mid->ulOffStart+mid->cbProcSize))) {
                return mid;
            }
            if (key < mid->ulOffStart) {
                hi = mid - 1;
                num = (num & 1) ? half : half-1;
            } else {
                lo = mid + 1;
                num = half;
            }
        } else
        if (num) {
            if ((key >= lo->ulOffStart)&&(key < (lo->ulOffStart+lo->cbProcSize))) {
                return lo;
            } else {
                break;
            }
        } else {
            break;
        }
    }
    return(NULL);
}

BOOL
DoSymbolCallback (
    PPROCESS_ENTRY                  pe,
    ULONG                           CallbackType,
    IN  PMODULE_ENTRY               mi,
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl64,
    LPSTR                           FileName
    )
{
    BOOL Status;
    IMAGEHLP_DEFERRED_SYMBOL_LOAD idsl32;

    Status = false;
    if (pe->pCallbackFunction32) {
        idsl32.SizeOfStruct  = sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD);
        idsl32.BaseOfImage   = (ULONG)mi->BaseOfDll;
        idsl32.CheckSum      = mi->CheckSum;
        idsl32.TimeDateStamp = mi->TimeDateStamp;
        idsl32.Reparse       = false;
        idsl32.FileName[0] = 0;
        idsl32.hFile         = mi->hFile;
        if (FileName) {
            CatString( idsl32.FileName, FileName, MAX_PATH );
        }

        __try {

            Status = pe->pCallbackFunction32(
                        pe->hProcess,
                        CallbackType,
                        (PVOID)&idsl32,
                        (PVOID)pe->CallbackUserContext
                        );
            idsl64->SizeOfStruct = sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64);
            idsl64->BaseOfImage = (ULONG64)(LONG64)(LONG)idsl32.BaseOfImage;
            idsl64->CheckSum = idsl32.CheckSum;
            idsl64->TimeDateStamp = idsl32.TimeDateStamp;
            idsl64->Reparse = idsl32.Reparse;
            idsl64->hFile = mi->hFile;
            if (idsl32.FileName) {
                CopyStrArray(idsl64->FileName, idsl32.FileName);
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    } else if (pe->pCallbackFunction64) {
        idsl64->SizeOfStruct  = sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64);
        idsl64->BaseOfImage   = mi->BaseOfDll;
        idsl64->CheckSum      = mi->CheckSum;
        idsl64->TimeDateStamp = mi->TimeDateStamp;
        idsl64->Reparse       = false;
        idsl64->FileName[0]   = 0;
        idsl64->hFile         = mi->hFile;
        if (FileName) {
            CatString(idsl64->FileName, FileName, MAX_PATH);
        }

        __try {

            Status = pe->pCallbackFunction64(
                        pe->hProcess,
                        CallbackType,
                        (ULONG64)(ULONG_PTR)idsl64,
                        pe->CallbackUserContext
                        );

        } __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    if (Status) {
        mi->CheckSum      = idsl64->CheckSum;
        mi->TimeDateStamp = idsl64->TimeDateStamp;
        mi->hFile         = idsl64->hFile;
    }

    return Status;
}


BOOL
DoCallback(
    PPROCESS_ENTRY pe,
    ULONG          type,
    PVOID          data
    )
{
    BOOL rc = true;

    __try {

        // if we weren't passed a process entry, then call all processes

        if (!pe) {
            BOOL        ret;
            PLIST_ENTRY next;

            next = g.ProcessList.Flink;
            if (!next)
                return false;

            while ((PVOID)next != (PVOID)&g.ProcessList) {
                pe = CONTAINING_RECORD( next, PROCESS_ENTRY, ListEntry );
                next = pe->ListEntry.Flink;
                if (!pe)
                    return rc;
                ret = DoCallback(pe, type, data);
                if (!ret)
                    rc = ret;
            }

            return rc;
        }

        // otherwise call this process

        if (pe->pCallbackFunction32) {
            rc = pe->pCallbackFunction32(pe->hProcess,
                                         type,
                                         data,
                                         (PVOID)pe->CallbackUserContext);
        } else if (pe->pCallbackFunction64) {
            rc = pe->pCallbackFunction64(pe->hProcess,
                                         type,
                                         (ULONG64)data,
                                         pe->CallbackUserContext);
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = false;
    }

    return rc;
}


BOOL
IsCallback(
    PPROCESS_ENTRY pe
    )
{
    __try {

        // if we weren't passed a process entry, then call all processes

        if (!pe) {
            PLIST_ENTRY next;

            next = g.ProcessList.Flink;
            if (!next)
                return false;

            while ((PVOID)next != (PVOID)&g.ProcessList) {
                pe = CONTAINING_RECORD( next, PROCESS_ENTRY, ListEntry );
                next = pe->ListEntry.Flink;
                if (!pe)
                    return false;
                if (IsCallback(pe))
                    return true;
            }

            return false;
        }

        // otherwise call this process

        if (pe->pCallbackFunction32) 
            return true;
        if (pe->pCallbackFunction64) 
            return true;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    return false;
}


void 
PrepOutputString(
    char *in, 
    char *out, 
    int len
    )
{
    int i;

    *out = 0;

    for (i = 0; *in && i < len; i++, in++, out++) {
        if (*in == '\b') 
            break;
        *out = *in;
    }
    
    *out = 0;
}


BOOL
PostEvent(
    PPROCESS_ENTRY      pe,
    PIMAGEHLP_CBA_EVENT evt
    )
{
    char sztxt[4098];
    BOOL fdbgout = false;
    
    if (!*evt->desc)
        return true;

    // write to log, if called for

    PrepOutputString(evt->desc, sztxt, 4098);
    if (g.hLog && *sztxt)
        _write(g.hLog, sztxt, strlen(sztxt));

    // write to debug terminal, if called for

    if (g.fdbgout) {
        fdbgout = true;
        OutputDebugString(sztxt);
    }

    // don't pass info-level messages, unless told to

    if ((evt->severity <= sevInfo) && !option(SYMOPT_DEBUG))
        return true;

    // If there is no callback function, send to the debug terminal.

    if (!IsCallback(pe)) {
        if (!fdbgout)
            OutputDebugString(sztxt);
        return true;
    }

    // Otherwise call the callback function.

    return DoCallback(pe, CBA_EVENT, evt);
}

BOOL
WINAPIV
evtprint(
    PPROCESS_ENTRY pe,
    DWORD          severity,
    DWORD          code,
    PVOID          object,
    LPSTR          format,
    ...
    )
{
    static char buf[1001] = "";
    IMAGEHLP_CBA_EVENT evt;
    va_list args;

    va_start(args, format);
    _vsnprintf(buf, sizeof(buf) - 1, format, args);
    buf[sizeof(buf)] = 0;
    va_end(args);
    if (!*buf)
        return true;

    evt.severity = severity;
    evt.code = code;
    evt.desc = buf;
    evt.object = object;

    return PostEvent(pe, &evt);
}

int
WINAPIV
_peprint(
    PPROCESS_ENTRY pe,
    LPSTR Format,
    ...
    )
{
    static char buf[1001];
    va_list args;

    va_start(args, Format);
    _vsnprintf(buf, sizeof(buf) - 1, Format, args);
    buf[sizeof(buf)] = 0;
    va_end(args);
    if (!*buf)
        return 1;

    if (!evtprint(pe, sevInfo, 0, NULL, buf))
        DoCallback(pe, CBA_DEBUG_INFO, buf);
    
    return 1;
}


int
WINAPIV
_pprint(
    PPROCESS_ENTRY pe,
    LPSTR Format,
    ...
    )
{
    static char buf[1001];
    va_list args;

    va_start(args, Format);
    CopyStrArray(buf, "DBGHELP: "); 
    _vsnprintf(buf + 9, sizeof(buf) - 10, Format, args);
    buf[sizeof(buf)] = 0;
    va_end(args);
    _peprint(pe, buf);
    return 1;
}

int
WINAPIV
_eprint(
    LPSTR format,
    ...
    )
{
    static char buf[1001];
    va_list args;

    va_start(args, format);
    _vsnprintf(buf, sizeof(buf) - 1, format, args);
    buf[sizeof(buf)] = 0;
    va_end(args);
    _peprint(NULL, buf);
    return 1;
}


int
WINAPIV
_dprint(
    LPSTR format,
    ...
    )
{
    static char buf[1001] = "DBGHELP: ";
    va_list args;

    va_start(args, format);
    _vsnprintf(buf + 9, sizeof(buf) - 10, format, args);
    buf[sizeof(buf)] = 0;
    va_end(args);
    _eprint(buf);
    return 1;
}

BOOL
traceAddr(
    DWORD64 addr
    )
{
    DWORD64 taddr = 0;

    if (!*g.DebugToken)
        return false;
    if (sscanf(g.DebugToken, "0x%I64x", &taddr) < 1)
        return false;
    taddr = EXTEND64(taddr);
    addr = EXTEND64(addr);
    return (addr == taddr);
}


BOOL
traceName(
    PCHAR name
    )
{
    if (!*g.DebugToken)
        return false;
    return !_strnicmp(name, g.DebugToken, strlen(g.DebugToken));
}


BOOL
traceSubName(
    PCHAR name
    )
{
    char *lname;
    int   len;
    BOOL  rc;

    if (!*g.DebugToken || !name || !*name)
        return false;
    len = strlen(name) + 1;
    lname = (char *)MemAlloc(sizeof(char) * len);
    if (!lname) 
        return false;
    CopyString(lname, name, len);
    _strlwr(lname);
    rc = strstr(lname, g.DebugToken) ? true : false;
    MemFree(lname);

    return rc;
}


char *
SymbolStatus(
    PMODULE_ENTRY mi,
    int           indent
    )
{
    static char pad[123];
    static char sz[MAX_PATH * 2];
    static char src[MAX_PATH];

    if (indent > 120)
        return NULL;

    ZeroMemory(pad, sizeof(pad));
    *pad = '\n';
    memset(pad + 1, ' ', indent);

    // do this only on-demand

    diaCountGlobals(mi);

    // get the name

    if (mi->LoadedImageName && *mi->LoadedImageName)
        CopyStrArray(src, mi->LoadedImageName);
    else
        CopyStrArray(src, "image");

    switch (mi->lSymType)
    {
    case SymNone:
        CopyStrArray(sz, "no symbols loaded");
        break;
    case SymCoff:
        if (mi->loaded)
            PrintString(sz, DIMA(sz), "coff symbols %s", mi->fLines ? "& lines " : "");
        else
            CopyStrArray(sz, "coff symbols not loaded");
        break;
    case SymCv:
        if (mi->loaded)
            PrintString(sz, DIMA(sz), "cv symbols %s", mi->fLines ? "& lines " : "");
        else
            CopyStrArray(sz, "cv symbols not loaded");
        break;
    case SymPdb:
    case SymDia:
        if (mi->cGlobals == -1)
            PrintString(sz, DIMA(sz), "- %s", mi->LoadedPdbName);
        else if (mi->cGlobals)
            PrintString(sz, DIMA(sz), "private symbols %s", mi->fLines ? "& lines " : "");
        else
            PrintString(sz, DIMA(sz), "public symbols %s", mi->fLines ? "& lines " : "");
        break;
    case SymExport:
        CopyStrArray(sz, "export symbols");
        if (!mi->loaded)
            CatStrArray(sz, " not loaded");
        break;
    case SymDeferred:
        CopyStrArray(sz, "symbol load deferred");
        break;
    case SymSym:
        CopyStrArray(sz, "symbol loaded from sym file");
        break;
    case SymVirtual:
        CopyStrArray(sz, "virtual symbol module");
        break;
    default:
        CopyStrArray(sz, "symbol error");
        break;
    }

    if (mi->LoadedImageName && *mi->LoadedImageName && IsDbg(mi->LoadedImageName)) {
        CatStrArray(sz, pad); // CatStrArray(sz, "\n         ");
        CatStrArray(sz, mi->LoadedImageName);
        CatStrArray(sz, mi->fDbgUnmatched ? " - unmatched" : "");
    }
    if (mi->LoadedPdbName && *mi->LoadedPdbName) {
        CatStrArray(sz, pad); // CatStrArray(sz, "\n         ");
        CatStrArray(sz, mi->LoadedPdbName);
        CatStrArray(sz, mi->fPdbUnmatched ? " - unmatched" : "");
    }


    return sz;
}


PPROCESS_ENTRY
FindProcessEntry(
    HANDLE  hProcess
    )
{
    PLIST_ENTRY                 next;
    PPROCESS_ENTRY              pe;
    DWORD                       count;

    next = g.ProcessList.Flink;
    if (!next) {
        return NULL;
    }

    for (count = 0; (PVOID)next != (PVOID)&g.ProcessList; count++) {
        assert(count < g.cProcessList);
        if (count >= g.cProcessList)
            return NULL;
        pe = CONTAINING_RECORD( next, PROCESS_ENTRY, ListEntry );
        next = pe->ListEntry.Flink;
        if (pe->hProcess == hProcess) {
            return pe;
        }
    }

    return NULL;
}

PPROCESS_ENTRY
FindFirstProcessEntry(
    )
{
    return CONTAINING_RECORD(g.ProcessList.Flink, PROCESS_ENTRY, ListEntry);
}


PMODULE_ENTRY
FindModule(
    HANDLE hProcess,
    PPROCESS_ENTRY pe,
    LPSTR ModuleName,
    BOOL fLoad
    )
{
    PLIST_ENTRY next;
    PMODULE_ENTRY mi;

    if (!ModuleName || !*ModuleName)
        return NULL;

    next = pe->ModuleList.Flink;
    if (next) {
        while ((PVOID)next != (PVOID)&pe->ModuleList) {
            mi = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
            next = mi->ListEntry.Flink;

            if ((_stricmp( mi->ModuleName, ModuleName ) == 0) ||
                (mi->AliasName[0] &&
                 _stricmp( mi->AliasName, ModuleName ) == 0))
            {
                if (fLoad && !LoadSymbols(hProcess, mi, 0)) {
                    return NULL;
                }

                return mi;
            }
        }
    }

    return NULL;
}


BOOL
PrepRE4Srch(
    PCSTR in,
    PSTR  out
    )
{
    LPSTR p;
    BOOL  rc;

    assert(in && out && strlen(in) <= MAX_SYM_NAME);

    rc = false;

    *out = 0;
    for (; *in; in++, out++) {
        if (*in == '_' && *(in + 1) == '_') {
            strcpy(out, "[_:][_:]"); // SECURITY: Don't know size of target buffer.
            out += 7;
            in++;
            rc = true;
        } else {
            *out = *in;
            if (*in == '*' || *in == '?')
                rc = true;
        }
    }
    *out = 0;

    return rc;
}


BOOL
ValidGuid(
    GUID *guid
    )
{
    int i;

    if (!guid)
        return false;

    if (guid->Data1)
        return true;
    if (guid->Data2)
        return true;
    if (guid->Data3)
        return true;
    for (i = 0; i < 8; i++) {
        if (guid->Data4[i])
            return true;
    }

    return false;
}


BOOL
GuidIsDword(
    GUID *guid
    )
{
    int i;

    if (!guid)
        return false;

    if (!guid->Data1)
        return false;
    if (guid->Data2)
        return false;
    if (guid->Data3)
        return false;
    for (i = 0; i < 8; i++) {
        if (guid->Data4[i])
            return false;
    }

    return true;
}


PSYMBOL_INFO
GetSymFromAddr(
    DWORD64         dwAddr,
    PDWORD64        pqwDisplacement,
    PMODULE_ENTRY   mi
    )
{
    PSYMBOL_INFO            si = NULL;
    PSYMBOL_INFO            vssi;
    PSYMBOL_ENTRY           sym = NULL;
    DWORD64                 disp = 0;
    DWORD64                 vsDisp;
    LONG                    High;
    LONG                    Low;
    LONG                    Middle;

#ifdef DEBUG
    if (traceAddr(dwAddr))   // for debug breakpoints ...
        dtrace("found 0x%I64x\n", dwAddr);
#endif

    if (mi == NULL) {
        return NULL;
    }

    if (mi->dia) {
        si = diaGetSymFromAddr(mi, dwAddr, &disp);
        vssi = vsGetSymFromAddr(mi, dwAddr, &vsDisp);
        if (vssi && vsDisp < disp) {
            if (pqwDisplacement)
                *pqwDisplacement = vsDisp;
            return vssi;
        }
        if (pqwDisplacement)
            *pqwDisplacement = disp;
        return si;
    }

    //
    // do a binary search to locate the symbol
    //

    if (mi->numsyms) {
        Low = 0;
        High = mi->numsyms - 1;

        while (High >= Low) {
            Middle = (Low + High) >> 1;
            sym = &mi->symbolTable[Middle];
            if (!sym)
                break;
            if (dwAddr < sym->Address) {
                High = Middle - 1;
            } else if (dwAddr >= sym->Address + sym->Size) {
                Low = Middle + 1;
            } else {
                if (pqwDisplacement) {
                    *pqwDisplacement = dwAddr - sym->Address;
                }
                break;
            }
        }

        if (sym) {
            if (sym->Address > dwAddr)
                sym = NULL;
            else 
                disp = dwAddr - sym->Address;
        }
    }

    vssi = vsGetSymFromAddr(mi, dwAddr, &vsDisp);
    if (vssi && (!sym || vsDisp < disp)) {
        if (pqwDisplacement)
            *pqwDisplacement = vsDisp;
        return vssi;
    }

    if (!sym)
        return NULL;

    if (pqwDisplacement)
        *pqwDisplacement = disp;

    se2si(sym, &mi->si);

    return &mi->si;
}


PSYMBOL_INFO
GetSymFromAddrByTag(
    DWORD64         dwAddr,
    DWORD           SymTag,
    PDWORD64        pqwDisplacement,
    PMODULE_ENTRY   mi
    )
{
    PSYMBOL_INFO            si = NULL;
    PSYMBOL_INFO            vssi;
    PSYMBOL_ENTRY           sym = NULL;
    DWORD64                 disp = 0;
    DWORD64                 vsDisp;
    LONG                    High;
    LONG                    Low;
    LONG                    Middle;

#ifdef DEBUG
    if (traceAddr(dwAddr))   // for debug breakpoints ...
        dtrace("found 0x%I64x\n", dwAddr);
#endif

    if (!mi)
        return NULL;

    if (mi->dia) {
        si = diaGetSymFromAddrByTag(mi, dwAddr, SymTag, &disp);
#if 0
        vssi = vsGetSymFromAddr(mi, dwAddr, &vsDisp);
        if (vssi && vsDisp < disp) {
            if (pqwDisplacement)
                *pqwDisplacement = vsDisp;
            return vssi;
        }
#endif    
        if (pqwDisplacement)
            *pqwDisplacement = disp;
    }

    return si;

    //
    // do a binary search to locate the symbol
    //

    if (mi->numsyms) {
        Low = 0;
        High = mi->numsyms - 1;

        while (High >= Low) {
            Middle = (Low + High) >> 1;
            sym = &mi->symbolTable[Middle];
            if (!sym)
                break;
            if (dwAddr < sym->Address) {
                High = Middle - 1;
            } else if (dwAddr >= sym->Address + sym->Size) {
                Low = Middle + 1;
            } else {
                if (pqwDisplacement) {
                    *pqwDisplacement = dwAddr - sym->Address;
                }
                break;
            }
        }

        if (sym) {
            if (sym->Address > dwAddr)
                sym = NULL;
            else 
                disp = dwAddr - sym->Address;
        }
    }

    vssi = vsGetSymFromAddr(mi, dwAddr, &vsDisp);
    if (vssi && (!sym || vsDisp < disp)) {
        if (pqwDisplacement)
            *pqwDisplacement = vsDisp;
        return vssi;
    }

    if (!sym)
        return NULL;

    if (pqwDisplacement)
        *pqwDisplacement = disp;

    se2si(sym, &mi->si);

    return &mi->si;
}


PSYMBOL_INFO
GetSymFromToken(
    PMODULE_ENTRY   mi,
    DWORD           token
    )
{
    if (!mi || !mi->dia)
        return NULL;

    return diaGetSymFromToken(mi, token);
}


PSYMBOL_ENTRY
cvGetSymFromAddr(
    DWORD64         dwAddr,
    PDWORD64        pqwDisplacement,
    PMODULE_ENTRY   mi
    )
{
    PSYMBOL_ENTRY           sym = NULL;
    PSYMBOL_ENTRY           vsSym;
    DWORD64                 disp = 0;
    DWORD64                 vsDisp;
    LONG                    High;
    LONG                    Low;
    LONG                    Middle;

#ifdef DEBUG
    if (traceAddr(dwAddr))   // for debug breakpoints ...
        dtrace("found 0x%I64x\n", dwAddr);
#endif

    if (!mi || mi->dia)
        return NULL;

    //
    // do a binary search to locate the symbol
    //

    if (mi->numsyms) {
        Low = 0;
        High = mi->numsyms - 1;

        while (High >= Low) {
            Middle = (Low + High) >> 1;
            sym = &mi->symbolTable[Middle];
            if (!sym)
                break;
            if (dwAddr < sym->Address) {
                High = Middle - 1;
            } else if (dwAddr >= sym->Address + sym->Size) {
                Low = Middle + 1;
            } else {
                if (pqwDisplacement) {
                    *pqwDisplacement = dwAddr - sym->Address;
                }
                break;
            }
        }

        if (sym) {
            if (sym->Address > dwAddr)
                sym = NULL;
            else
                disp = dwAddr - sym->Address;
        }
    }

    vsSym = vsGetSymEntryFromAddr(mi, dwAddr, &vsDisp);

    if (vsSym && (!sym || vsDisp < disp)) {
        if (pqwDisplacement)
            *pqwDisplacement = vsDisp;
        return vsSym;
    }

    if (pqwDisplacement)
        *pqwDisplacement = disp;

    return sym;
}


PMODULE_ENTRY
GetModuleForPC(
    PPROCESS_ENTRY  pe,
    DWORD64         dwPcAddr,
    BOOL            ExactMatch
    )
{
    PLIST_ENTRY   next;
    PMODULE_ENTRY mi = NULL;

    if (!pe)
        return NULL;

    next = pe->NextModule;

    if (dwPcAddr == (DWORD64)-1) {
        if (!next)
            return NULL;
        if ((PVOID)next == (PVOID)&pe->ModuleList) {
            // Reset to NULL so the list can be re-walked
            next = NULL;
            goto miss;
        }
        mi = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
        next = mi->ListEntry.Flink;
        goto hit;
    }

    next = pe->ModuleList.Flink;
    if (!next) 
        goto miss;

    while ((PVOID)next != (PVOID)&pe->ModuleList) {
        mi = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
        next = mi->ListEntry.Flink;
        if (!dwPcAddr) 
            goto hit;
        if (ExactMatch) {
            if (dwPcAddr == mi->BaseOfDll) {
               goto hit;
            }
        } else
        if ((dwPcAddr == mi->BaseOfDll && mi->DllSize == 0) ||
            ((dwPcAddr >= mi->BaseOfDll) &&
                (dwPcAddr  < mi->BaseOfDll + mi->DllSize))) {
               goto hit;
        }
    }


miss:
    // found nothing
    mi = NULL;

hit:
    EnterCriticalSection(&g.threadlock);
    pe->NextModule = next;
    LeaveCriticalSection(&g.threadlock);

    return mi;
}


DWORD
ComputeHash(
    LPSTR   lpbName,
    ULONG   cb
    )
{
    ULONG UNALIGNED *   lpulName;
    ULONG               ulEnd = 0;
    int                 cul;
    int                 iul;
    ULONG               ulSum = 0;

    while (cb & 3) {
        ulEnd |= (lpbName[cb - 1] & 0xdf);
        ulEnd <<= 8;
        cb -= 1;
    }

    cul = cb / 4;
    lpulName = (ULONG UNALIGNED *) lpbName;
    for (iul =0; iul < cul; iul++) {
        ulSum ^= (lpulName[iul] & 0xdfdfdfdf);
        ulSum = _lrotl( ulSum, 4);
    }
    ulSum ^= ulEnd;
    return ulSum % HASH_MODULO;
}

PSYMBOL_ENTRY
AllocSym(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    LPSTR           name
    )
{
    PSYMBOL_ENTRY       sym;
    ULONG               Length;


    if (mi->numsyms == mi->MaxSyms) {
//       dtrace("AllocSym: ERROR - symbols Table overflow!\n");
        return NULL;
    }

    if (!mi->StringSize) {
//      dtrace("AllocSym: ERROR - symbols strings not allocated for module!\n");
        return NULL;
    }

    Length = strlen(name);

    if ((Length + 1) > mi->StringSize) {
//      dtrace("AllocSym: ERROR - symbols strings buffer overflow!\n");
        return NULL;
    }

    sym = &mi->symbolTable[mi->numsyms];

    mi->numsyms += 1;
    sym->Name = mi->SymStrings;
    mi->SymStrings += (Length + 2);
    mi->StringSize -= (Length + 2);

    strcpy(sym->Name, name);    // SECURITY: Don't know size of target buffer.
    sym->Address = addr;
    sym->Size = 0;
    sym->Flags = 0;
    sym->Next = NULL;
    sym->NameLength = Length;

    return sym;
}

int __cdecl
SymbolTableAddressCompare(
    const void *e1,
    const void *e2
    )
{
    PSYMBOL_ENTRY    sym1 = (PSYMBOL_ENTRY) e1;
    PSYMBOL_ENTRY    sym2 = (PSYMBOL_ENTRY) e2;
    LONG64 diff;

    if ( sym1 && sym2 ) {
        diff = (sym1->Address - sym2->Address);
        return (diff < 0) ? -1 : (diff == 0) ? 0 : 1;
    } else {
        return 1;
    }
}

int __cdecl
SymbolTableNameCompare(
    const void *e1,
    const void *e2
    )
{
    PSYMBOL_ENTRY    sym1 = (PSYMBOL_ENTRY) e1;
    PSYMBOL_ENTRY    sym2 = (PSYMBOL_ENTRY) e2;

    return strcmp( sym1->Name, sym2->Name );
}

VOID
CompleteSymbolTable(
    PMODULE_ENTRY   mi
    )
{
    PSYMBOL_ENTRY       sym;
    PSYMBOL_ENTRY       symH;
    ULONG               Hash;
    ULONG               i;
    ULONG               dups;
    ULONG               seq;


    //
    // sort the symbols by name
    //
    dbg_qsort(
        mi->symbolTable,
        mi->numsyms,
        sizeof(SYMBOL_ENTRY),
        SymbolTableNameCompare
        );

    //
    // mark duplicate names
    //
    seq = 0;
    for (i=0; i<mi->numsyms; i++) {
        dups = 0;
        while ((mi->symbolTable[i+dups].NameLength == mi->symbolTable[i+dups+1].NameLength) &&
               (strcmp( mi->symbolTable[i+dups].Name, mi->symbolTable[i+dups+1].Name ) == 0)) {
                   mi->symbolTable[i+dups].Flags |= SYMF_DUPLICATE;
                   mi->symbolTable[i+dups+1].Flags |= SYMF_DUPLICATE;
                   dups += 1;
        }
        i += dups;
    }

    //
    // sort the symbols by address
    //
    dbg_qsort(
        mi->symbolTable,
        mi->numsyms,
        sizeof(SYMBOL_ENTRY),
        SymbolTableAddressCompare
        );

    //
    // calculate the size of each symbol
    //
    for (i=0; i<mi->numsyms; i++) {
        mi->symbolTable[i].Next = NULL;
        if (i+1 < mi->numsyms) {
            mi->symbolTable[i].Size = (ULONG)(mi->symbolTable[i+1].Address - mi->symbolTable[i].Address);
        }
    }

    //
    // compute the hash for each symbol
    //
    ZeroMemory( mi->NameHashTable, sizeof(mi->NameHashTable) );
    for (i=0; i<mi->numsyms; i++) {
        sym = &mi->symbolTable[i];

        Hash = ComputeHash( sym->Name, sym->NameLength );

        if (mi->NameHashTable[Hash]) {

            //
            // we have a collision
            //
            symH = mi->NameHashTable[Hash];
            while( symH->Next ) {
                symH = symH->Next;
            }
            symH->Next = sym;

        } else {

            mi->NameHashTable[Hash] = sym;

        }
    }
}


BOOL
CreateSymbolTable(
    PMODULE_ENTRY   mi,
    DWORD           SymbolCount,
    SYM_TYPE        SymType,
    DWORD           NameSize
    )
{
    //
    // allocate the symbol table
    //
    NameSize += OMAP_SYM_STRINGS;
    mi->symbolTable = (PSYMBOL_ENTRY) MemAlloc(
        (sizeof(SYMBOL_ENTRY) * (SymbolCount + OMAP_SYM_EXTRA)) + NameSize + (SymbolCount * CPP_EXTRA)
        );
    if (!mi->symbolTable) {
        return false;
    }

    //
    // initialize the relevant fields
    //
    mi->numsyms    = 0;
    mi->MaxSyms    = SymbolCount + OMAP_SYM_EXTRA;
    mi->SymType    = SymType;
    mi->StringSize = NameSize + (SymbolCount * CPP_EXTRA);
    mi->SymStrings = (LPSTR)(mi->symbolTable + SymbolCount + OMAP_SYM_EXTRA);

    return true;
}

PIMAGE_SECTION_HEADER
FindSection(
    PIMAGE_SECTION_HEADER   sh,
    ULONG                   NumSections,
    ULONG                   Address
    )
{
    ULONG i;
    for (i=0; i<NumSections; i++) {
        if (Address >= sh[i].VirtualAddress &&
            Address <  (sh[i].VirtualAddress + sh[i].Misc.VirtualSize)) {
                    return &sh[i];
        }
    }
    return NULL;
}

PVOID
GetSectionPhysical(
    HANDLE             hp,
    ULONG64            base,
    PIMGHLP_DEBUG_DATA idd,
    ULONG              Address
    )
{
    PIMAGE_SECTION_HEADER   sh;

    sh = FindSection( idd->pCurrentSections, idd->cCurrentSections, Address );
    if (!sh) {
        return 0;
    }

    return (PCHAR)idd->ImageMap + sh->PointerToRawData + (Address - sh->VirtualAddress);
}

BOOL
ReadSectionInfo(
    HANDLE             hp,
    ULONG64            base,
    PIMGHLP_DEBUG_DATA idd,
    ULONG              address,
    PVOID              buf,
    DWORD              size
    )
{
    PIMAGE_SECTION_HEADER   sh;
    DWORD_PTR status = true;

    sh = FindSection( idd->pCurrentSections, idd->cCurrentSections, address );
    if (!sh)
        return false;

    if (!hp) {
        status = (DWORD_PTR)memcpy((PCHAR)buf,
                               (PCHAR)base + sh->PointerToRawData + (address - sh->VirtualAddress),
                               size);
    } else {
        status = ReadImageData(hp, base, address, buf, size);
    }
    if (!status)
        return false;

    return true;
}


PCHAR
expptr(
    HANDLE             hp,
    ULONG64            base,
    PIMGHLP_DEBUG_DATA idd,
    ULONG              address
    )
{
    PIMAGE_SECTION_HEADER   sh;
    DWORD_PTR status = true;

    if (hp)
        return (PCHAR)base + address;

    sh = FindSection( idd->pCurrentSections, idd->cCurrentSections, address );
    if (!sh)
        return false;

    return (PCHAR)base + sh->PointerToRawData + (address - sh->VirtualAddress);
}


ULONG
LoadExportSymbols(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA idd
    )
{
    PULONG                  names;
    PULONG                  addrs;
    PUSHORT                 ordinals;
    PUSHORT                 ordidx = NULL;
    ULONG                   cnt;
    ULONG                   idx;
    PIMAGE_EXPORT_DIRECTORY expdir;
    PCHAR                   expbuf = NULL;
    ULONG                   i;
    PSYMBOL_ENTRY           sym;
    ULONG                   NameSize;
    HANDLE                  hp;
    ULONG64                 base;
    CHAR                    name[2048];
    BOOL                    rc;
    DWORD64                 endExports;
    PCHAR                   p;

    if (option(SYMOPT_EXACT_SYMBOLS))
        return 0;

    cnt = 0;

    // setup pointers for grabing data

    switch (idd->dsExports) {
    case dsInProc:
        hp = idd->hProcess;
        expbuf = (PCHAR)MemAlloc(idd->cExports);
        if (!expbuf)
            goto cleanup;
        if (!ReadImageData(hp, idd->InProcImageBase, idd->oExports, expbuf, idd->cExports))
            goto cleanup;
        base = (ULONG64)expbuf - idd->oExports;
        expdir = (PIMAGE_EXPORT_DIRECTORY)expbuf;
        break;
    case dsImage:
        hp = NULL;
        expbuf = NULL;
        if (!idd->ImageMap)
            idd->ImageMap = MapItRO(idd->ImageFileHandle);
        base = (ULONG64)idd->ImageMap;
        expdir = &idd->expdir;
        break;
    default:
        return 0;
    }

    names = (PULONG)expptr(hp, base, idd, expdir->AddressOfNames);
    if (!names)
        goto cleanup;

    addrs = (PULONG)expptr(hp, base, idd, expdir->AddressOfFunctions);
    if (!addrs)
        goto cleanup;

    ordinals = (PUSHORT)expptr(hp, base, idd, expdir->AddressOfNameOrdinals);
    if (!ordinals)
        goto cleanup;

    ordidx = (PUSHORT) MemAlloc( max(expdir->NumberOfFunctions, expdir->NumberOfNames) * sizeof(USHORT) );

    if (!ordidx)
        goto cleanup;

    cnt = 0;
    NameSize = 0;

    // count the symbols

    for (i=0; i<expdir->NumberOfNames; i++) {
        *name = 0;
        p = expptr(hp, base, idd, names[i]);
        if (!p)
            continue;
        CopyStrArray(name, p);
        if (!*name)
            continue;
        if (option(SYMOPT_UNDNAME)) {
            SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN, name, strlen(name), mi->MachineType, true );
            NameSize += strlen(mi->TmpSym.Name);
            cnt += 1;
        } else {
            NameSize += (strlen(name) + 2);
            cnt += 1;
        }
    }

    for (i=0,idx=expdir->NumberOfNames; i<expdir->NumberOfFunctions; i++) {
        if (!ordidx[i]) {
            NameSize += 16;
            cnt += 1;
        }
    }

    // allocate the symbol table

    if (!CreateSymbolTable( mi, cnt, SymExport, NameSize )) {
        cnt = 0;
        goto cleanup;
    }

    // allocate the symbols

    cnt = 0;
    endExports = idd->oExports + idd->cExports;

    for (i=0; i<expdir->NumberOfNames; i++) {
        idx = ordinals[i];
        ordidx[idx] = true;
        *name = 0;
        p = expptr(hp, base, idd, names[i]);
        if (!p)
            continue;
        CopyStrArray(name, p);
        if (!*name)
            continue;
        if (option(SYMOPT_UNDNAME)) {
            SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN, (LPSTR)name, strlen(name), mi->MachineType, true );
            sym = AllocSym( mi, addrs[idx] + mi->BaseOfDll, mi->TmpSym.Name);
        } else {
            sym = AllocSym( mi, addrs[idx] + mi->BaseOfDll, name);
        }
        if (sym) {
            cnt += 1;
        }
        if (idd->oExports <= addrs[idx]
            && addrs[idx] <= endExports)
        {
            sym->Flags |= SYMFLAG_FORWARDER;
        } else {
            sym->Flags |= SYMFLAG_EXPORT;
        }
    }

    for (i=0,idx=expdir->NumberOfNames; i<expdir->NumberOfFunctions; i++) {
        if (!ordidx[i]) {
            CHAR NameBuf[sizeof("Ordinal99999") + 1];       // Ordinals are only 64k max.
            CopyStrArray(NameBuf, "Ordinal");
            _itoa( i+expdir->Base, &NameBuf[7], 10 );
            sym = AllocSym( mi, addrs[i] + mi->BaseOfDll, NameBuf);
            if (sym) {
                cnt += 1;
            }
            idx += 1;
        }
    }

    CompleteSymbolTable( mi );

cleanup:
    if (expbuf) {
        MemFree(expbuf);
    }
    if (ordidx) {
        MemFree(ordidx);
    }

    return cnt;
}


BOOL
LoadCoffSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA idd
    )
{
    PIMAGE_COFF_SYMBOLS_HEADER pCoffHeader = (PIMAGE_COFF_SYMBOLS_HEADER)(idd->pMappedCoff);
    PUCHAR              stringTable;
    PIMAGE_SYMBOL       allSymbols;
    DWORD               numberOfSymbols;
    PIMAGE_LINENUMBER   LineNumbers;
    PIMAGE_SYMBOL       NextSymbol;
    PIMAGE_SYMBOL       Symbol;
    PSYMBOL_ENTRY       sym;
    CHAR                szSymName[256];
    DWORD               i;
    DWORD64             addr;
    DWORD               CoffSymbols = 0;
    DWORD               NameSize = 0;
    DWORD64             Bias;

    allSymbols = (PIMAGE_SYMBOL)((PCHAR)pCoffHeader +
                 pCoffHeader->LvaToFirstSymbol);
                                                  
    stringTable = (PUCHAR)pCoffHeader +
                  pCoffHeader->LvaToFirstSymbol +
                  (pCoffHeader->NumberOfSymbols * IMAGE_SIZEOF_SYMBOL);

    numberOfSymbols = pCoffHeader->NumberOfSymbols;
    LineNumbers = (PIMAGE_LINENUMBER)((PCHAR)pCoffHeader +
                        pCoffHeader->LvaToFirstLinenumber);

    //
    // count the number of actual symbols
    //
    NextSymbol = allSymbols;
    for (i= 0; i < numberOfSymbols; i++) {
        Symbol = NextSymbol++;
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_EXTERNAL &&
            Symbol->SectionNumber > 0) {
            GetSymName( Symbol, stringTable, szSymName, sizeof(szSymName) );
            if (szSymName[0] == '?' && szSymName[1] == '?' &&
                szSymName[2] == '_' && szSymName[3] == 'C'    ) {
                //
                // ignore strings
                //
            } else if (option(SYMOPT_UNDNAME)) {
                SymUnDNameInternal(mi->TmpSym.Name,
                                   TMP_SYM_LEN,
                                   szSymName,
                                   strlen(szSymName),
                                   mi->MachineType,
                                   true);
                NameSize += strlen(mi->TmpSym.Name);
                CoffSymbols += 1;
            } else {
                CoffSymbols += 1;
                NameSize += (strlen(szSymName) + 1);
            }
        }

        NextSymbol += Symbol->NumberOfAuxSymbols;
        i += Symbol->NumberOfAuxSymbols;
    }

    //
    // allocate the symbol table
    //
    if (!CreateSymbolTable( mi, CoffSymbols, SymCoff, NameSize )) {
        return false;
    }

    //
    // populate the symbol table
    //

    if (mi->Flags & MIF_ROM_IMAGE) {
        Bias = mi->BaseOfDll & 0xffffffff00000000;
    } else {
        Bias = mi->BaseOfDll;
    }

    NextSymbol = allSymbols;
    for (i= 0; i < numberOfSymbols; i++) {
        Symbol = NextSymbol++;
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_EXTERNAL &&
            Symbol->SectionNumber > 0) {
            GetSymName( Symbol, stringTable, szSymName, sizeof(szSymName) );
            addr = Symbol->Value + Bias;
            if (szSymName[0] == '?' && szSymName[1] == '?' &&
                szSymName[2] == '_' && szSymName[3] == 'C'    ) {
                //
                // ignore strings
                //
            } else if (option(SYMOPT_UNDNAME)) {
                SymUnDNameInternal(mi->TmpSym.Name,
                                   TMP_SYM_LEN,
                                   szSymName,
                                   strlen(szSymName),
                                   mi->MachineType,
                                   true);
                AllocSym( mi, addr, mi->TmpSym.Name);
            } else {
                AllocSym( mi, addr, szSymName );
            }
        }

        NextSymbol += Symbol->NumberOfAuxSymbols;
        i += Symbol->NumberOfAuxSymbols;
    }

    CompleteSymbolTable( mi );

    if (option(SYMOPT_LOAD_LINES)) 
        idd->fLines = AddLinesForCoff(mi, allSymbols, numberOfSymbols, LineNumbers);

    return true;
}

BOOL
LoadCodeViewSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA idd
    )
{
    DWORD                   i, j;
    PPROCESS_ENTRY          pe;
    OMFSignature           *omfSig;
    OMFDirHeader           *omfDirHdr;
    OMFDirEntry            *omfDirEntry;
    OMFSymHash             *omfSymHash;
    DATASYM32              *dataSym;
    DWORD64                 addr;
    DWORD                   CvSymbols;
    DWORD                   NameSize;
    SYMBOL_ENTRY            SymEntry;

    pe = FindProcessEntry( hProcess );
    if (!pe) {
        return false;
    }

    omfSig = (OMFSignature*) idd->pMappedCv;
    if ((*(DWORD *)(omfSig->Signature) != '80BN') &&
        (*(DWORD *)(omfSig->Signature) != '90BN') &&
        (*(DWORD *)(omfSig->Signature) != '11BN'))
    {
        if ((*(DWORD *)(omfSig->Signature) != '01BN') &&
            (*(DWORD *)(omfSig->Signature) != 'SDSR'))
        {
            pprint(pe, "unrecognized OMF sig: %x\n", *(DWORD *)(omfSig->Signature));
        }
        return false;
    }

    //
    // count the number of actual symbols
    //
    omfDirHdr = (OMFDirHeader*) ((ULONG_PTR)omfSig + (DWORD)omfSig->filepos);
    omfDirEntry = (OMFDirEntry*) ((ULONG_PTR)omfDirHdr + sizeof(OMFDirHeader));

    NameSize = 0;
    CvSymbols = 0;

    for (i=0; i<omfDirHdr->cDir; i++,omfDirEntry++) {
        LPSTR SymbolName;
        UCHAR SymbolLen;

        if (omfDirEntry->SubSection == sstGlobalPub) {
            omfSymHash = (OMFSymHash*) ((ULONG_PTR)omfSig + omfDirEntry->lfo);
            dataSym = (DATASYM32*) ((ULONG_PTR)omfSig + omfDirEntry->lfo + sizeof(OMFSymHash));
            for (j=sizeof(OMFSymHash); j<=omfSymHash->cbSymbol; ) {
                addr = 0;
                cvExtractSymbolInfo(mi, (PCHAR) dataSym, &SymEntry, false);
#ifndef DO_NB09
                if (SymEntry.Segment && (SymEntry.Segment <= mi->OriginalNumSections))
                {
                    addr = mi->OriginalSectionHdrs[SymEntry.Segment-1].VirtualAddress + SymEntry.Offset + mi->BaseOfDll;
#else
                if (1)
                {
                    addr = SymEntry.Offset+ mi->BaseOfDll;
#endif
                    SymbolName = SymEntry.Name;
                    SymbolLen =  (UCHAR) SymEntry.NameLength;
                    if (!SymbolName)
                    {
                        // ignore symbols with no name
                    } else if (SymbolName[0] == '?' &&
                        SymbolName[1] == '?' &&
                        SymbolName[2] == '_' &&
                        SymbolName[3] == 'C' )
                    {
                        //
                        // ignore strings
                        //
                    } else if (option(SYMOPT_UNDNAME)) {
                        SymUnDNameInternal(mi->TmpSym.Name,
                                           TMP_SYM_LEN,
                                           SymbolName,
                                           SymbolLen,
                                           mi->MachineType,
                                           true);
                        NameSize += strlen(mi->TmpSym.Name);
                        CvSymbols += 1;
                    } else {
                        CvSymbols += 1;
                        NameSize += SymbolLen + 1;
                    }
                }
                j += dataSym->reclen + 2;
                dataSym = (DATASYM32*) ((ULONG_PTR)dataSym + dataSym->reclen + 2);
            }
            break;
        }
    }
    
    //
    // allocate the symbol table
    //
    if (!CreateSymbolTable( mi, CvSymbols, SymCv, NameSize )) {
        pprint(pe, "CreateSymbolTable failed\n");
        return false;
    }

    //
    // populate the symbol table
    //
    omfDirHdr = (OMFDirHeader*) ((ULONG_PTR)omfSig + (DWORD)omfSig->filepos);
    omfDirEntry = (OMFDirEntry*) ((ULONG_PTR)omfDirHdr + sizeof(OMFDirHeader));
    for (i=0; i<omfDirHdr->cDir; i++,omfDirEntry++) {
        LPSTR SymbolName;
        if (omfDirEntry->SubSection == sstGlobalPub) {
            omfSymHash = (OMFSymHash*) ((ULONG_PTR)omfSig + omfDirEntry->lfo);
            dataSym = (DATASYM32*) ((ULONG_PTR)omfSig + omfDirEntry->lfo + sizeof(OMFSymHash));
            for (j=sizeof(OMFSymHash); j<=omfSymHash->cbSymbol; ) {
                addr = 0;
                cvExtractSymbolInfo(mi, (PCHAR) dataSym, &SymEntry, false);
#ifndef DO_NB09
                if (SymEntry.Segment && (SymEntry.Segment <= mi->OriginalNumSections))
                {
                    addr = mi->OriginalSectionHdrs[SymEntry.Segment-1].VirtualAddress + SymEntry.Offset + mi->BaseOfDll;
#else
                if (1)
                {
                    addr = SymEntry.Offset+ mi->BaseOfDll;
#endif
                    SymbolName = SymEntry.Name;
                    if (!SymbolName)
                    {
                        // ignore symbols with no name
                    } else if (SymbolName[0] == '?' &&
                        SymbolName[1] == '?' &&
                        SymbolName[2] == '_' &&
                        SymbolName[3] == 'C' )
                    {
                        //
                        // ignore strings
                        //
                    } else if (option(SYMOPT_UNDNAME)) {
                        SymUnDNameInternal(mi->TmpSym.Name,
                                           TMP_SYM_LEN,
                                           SymbolName,
                                           SymEntry.NameLength,
                                           mi->MachineType,
                                           true);
                        AllocSym( mi, addr, (LPSTR) mi->TmpSym.Name);
#ifdef DO_NB09
                        dtrace("0x%I64x %s\n", addr, mi->TmpSym.Name);
#endif                    
                    } else {
                        mi->TmpSym.NameLength = SymEntry.NameLength;
                        memcpy( mi->TmpSym.Name, SymbolName, mi->TmpSym.NameLength );
                        mi->TmpSym.Name[mi->TmpSym.NameLength] = 0;
                        AllocSym( mi, addr, mi->TmpSym.Name);
#ifdef DO_NB09
                        dtrace("0x%I86x %s\n", addr, mi->TmpSym.Name);
#endif                    
                    }
                }
                j += dataSym->reclen + 2;
                dataSym = (DATASYM32*) ((ULONG_PTR)dataSym + dataSym->reclen + 2);
            }
            break;
        }
        else if (omfDirEntry->SubSection == sstSrcModule && option(SYMOPT_LOAD_LINES)) {
#ifndef DO_NB09
            idd->fLines = AddLinesForOmfSourceModule(mi,
                                                    (PUCHAR)(idd->pMappedCv)+omfDirEntry->lfo,
                                                    (OMFSourceModule *)
                                                    ((PCHAR)(idd->pMappedCv)+omfDirEntry->lfo),
                                                    NULL);
#endif        
        }
    }

    CompleteSymbolTable( mi );

    return true;
}

VOID
GetSymName(
    PIMAGE_SYMBOL Symbol,
    PUCHAR        StringTable,
    LPSTR         s,
    DWORD         size
    )
{
    DWORD i;

    if (Symbol->n_zeroes) {
        for (i=0; i<8; i++) {
            if ((Symbol->n_name[i]>0x1f) && (Symbol->n_name[i]<0x7f)) {
                *s++ = Symbol->n_name[i];
            }
        }
        *s = 0;
    }
    else {
        strncpy( s, (char *) &StringTable[Symbol->n_offset], size );  // SECURITY: Don't know size of output buffer.
    }
}


VOID
ProcessOmapForModule(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA idd
    )
{
    PSYMBOL_ENTRY       sym;
    PSYMBOL_ENTRY       symN;
    DWORD               i;
    ULONG64             addr;
    DWORD               bias;
    PFPO_DATA           fpo;

    if (idd->cOmapTo && idd->pOmapTo) {
        if (idd->fOmapToMapped) {
            mi->pOmapTo = (POMAP)MemAlloc(idd->cOmapTo * sizeof(OMAP));
            if (mi->pOmapTo) {
                CopyMemory(
                    mi->pOmapTo,
                    idd->pOmapTo,
                    idd->cOmapTo * sizeof(OMAP)
                    );
            }
        } else {
            mi->pOmapTo = idd->pOmapTo;
        }
        mi->cOmapTo = idd->cOmapTo;
    }

    if (idd->cOmapFrom && idd->pOmapFrom) {
        if (idd->fOmapFromMapped) {
            mi->pOmapFrom = (POMAP)MemAlloc(idd->cOmapFrom * sizeof(OMAP));
            if (mi->pOmapFrom) {
                CopyMemory(
                    mi->pOmapFrom,
                    idd->pOmapFrom,
                    idd->cOmapFrom * sizeof(OMAP)
                    );
            }
        } else {
            mi->pOmapFrom = idd->pOmapFrom;
        }
        mi->cOmapFrom = idd->cOmapFrom;
    }

    if (mi->pFpoData) {
        //
        // if this module is BBT-optimized, then build
        // another fpo table with omap transalation
        //
        mi->pFpoDataOmap = (PFPO_DATA)VirtualAlloc(
            NULL,
            sizeof(FPO_DATA) * mi->dwEntries,
            MEM_COMMIT,
            PAGE_READWRITE
            );
        if (mi->pFpoDataOmap) {
            CopyMemory(
                mi->pFpoDataOmap,
                idd->pFpo,
                sizeof(FPO_DATA) * mi->dwEntries
                );
            for (i = 0, fpo = mi->pFpoDataOmap;
                 i < mi->dwEntries;
                 i++, fpo++) {
                addr =  ConvertOmapFromSrc(mi,
                                           mi->BaseOfDll + fpo->ulOffStart,
                                           &bias);
                if (addr)
                    fpo->ulOffStart = (ULONG)(addr - mi->BaseOfDll) + bias;
            }
            VirtualProtect(
                mi->pFpoData,
                sizeof(FPO_DATA) * mi->dwEntries,
                PAGE_READONLY,
                &i
                );
        }
    }

    if (!mi->pOmapFrom ||
        !mi->symbolTable ||
        ((mi->SymType != SymCoff) && (mi->SymType != SymCv))
       )
    {
        return;
    }

    for (i=0; i<mi->numsyms; i++) {
        ProcessOmapSymbol( mi, &mi->symbolTable[i] );
    }

    CompleteSymbolTable( mi );
}


BOOL
ProcessOmapSymbol(
    PMODULE_ENTRY       mi,
    PSYMBOL_ENTRY       sym
    )
{
    DWORD           bias;
    DWORD64         OptimizedSymAddr;
    DWORD           rvaSym;
    POMAPLIST       pomaplistHead;
    DWORD64         SymbolValue;
    DWORD64         OrgSymAddr;
    POMAPLIST       pomaplistNew;
    POMAPLIST       pomaplistPrev;
    POMAPLIST       pomaplistCur;
    POMAPLIST       pomaplistNext;
    DWORD           rva;
    DWORD           rvaTo;
    DWORD           cb;
    DWORD           end;
    DWORD           rvaToNext;
    LPSTR           NewSymName;
    CHAR            Suffix[32];
    DWORD64         addrNew;
    POMAP           pomap;
    PSYMBOL_ENTRY   symOmap;

    if ((sym->Flags & SYMF_OMAP_GENERATED) || (sym->Flags & SYMF_OMAP_MODIFIED)) {
        return false;
    }

    OrgSymAddr = SymbolValue = sym->Address;

    OptimizedSymAddr = ConvertOmapFromSrc( mi, SymbolValue, &bias );

    if (OptimizedSymAddr == 0) {
        //
        // No equivalent address
        //
        sym->Address = 0;
        return false;

    }

    //
    // We have successfully converted
    //
    sym->Address = OptimizedSymAddr + bias;

    rvaSym = (ULONG)(SymbolValue - mi->BaseOfDll);
    SymbolValue = sym->Address;

    pomap = GetOmapFromSrcEntry( mi, OrgSymAddr );
    if (!pomap) {
        goto exit;
    }

    pomaplistHead = NULL;

    //
    // Look for all OMAP entries belonging to SymbolEntry
    //

    end = (ULONG)(OrgSymAddr - mi->BaseOfDll + sym->Size);

    while (pomap && (pomap->rva < end)) {

        if (pomap->rvaTo == 0) {
            pomap++;
            continue;
        }

        //
        // Allocate and initialize a new entry
        //
        pomaplistNew = (POMAPLIST) MemAlloc( sizeof(OMAPLIST) );
        if (!pomaplistNew) {
            return false;
        }

        pomaplistNew->omap = *pomap;
        pomaplistNew->cb = pomap[1].rva - pomap->rva;

        pomaplistPrev = NULL;
        pomaplistCur = pomaplistHead;

        while (pomaplistCur != NULL) {
            if (pomap->rvaTo < pomaplistCur->omap.rvaTo) {
                //
                // Insert between Prev and Cur
                //
                break;
            }
            pomaplistPrev = pomaplistCur;
            pomaplistCur = pomaplistCur->next;
        }

        if (pomaplistPrev == NULL) {
            //
            // Insert in head position
            //
            pomaplistHead = pomaplistNew;
        } else {
            pomaplistPrev->next = pomaplistNew;
        }

        pomaplistNew->next = pomaplistCur;

        pomap++;
    }

    if (pomaplistHead == NULL) {
        goto exit;
    }

    pomaplistCur = pomaplistHead;
    pomaplistNext = pomaplistHead->next;

    //
    // we do have a list
    //
    while (pomaplistNext != NULL) {
        rva = pomaplistCur->omap.rva;
        rvaTo  = pomaplistCur->omap.rvaTo;
        cb = pomaplistCur->cb;
        rvaToNext = pomaplistNext->omap.rvaTo;

        if (rvaToNext == sym->Address - mi->BaseOfDll) {
            //
            // Already inserted above
            //
        } else if (rvaToNext < (rvaTo + cb + 8)) {
            //
            // Adjacent to previous range
            //
        } else {
            addrNew = mi->BaseOfDll + rvaToNext;
            Suffix[0] = '_';
            _ltoa( pomaplistNext->omap.rva - rvaSym, &Suffix[1], 10 );
            CopyNString(mi->TmpSym.Name,sym->Name, sym->NameLength, TMP_SYM_LEN);
            CatString(mi->TmpSym.Name, Suffix, TMP_SYM_LEN);
            symOmap = AllocSym( mi, addrNew, mi->TmpSym.Name);
            if (symOmap) {
                symOmap->Flags |= SYMF_OMAP_GENERATED;
            }
        }

        MemFree(pomaplistCur);

        pomaplistCur = pomaplistNext;
        pomaplistNext = pomaplistNext->next;
    }

    MemFree(pomaplistCur);

exit:
    if (sym->Address != OrgSymAddr) {
        sym->Flags |= SYMF_OMAP_MODIFIED;
    }

    return true;
}


DWORD64
ConvertOmapFromSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias
    )
{
    DWORD   rva;
    DWORD   comap;
    POMAP   pomapLow;
    POMAP   pomapHigh;
    DWORD   comapHalf;
    POMAP   pomapMid;


    *bias = 0;

    if (!mi->pOmapFrom) {
        return addr;
    }

    rva = (DWORD)(addr - mi->BaseOfDll);

    comap = mi->cOmapFrom;
    pomapLow = mi->pOmapFrom;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

        comapHalf = comap / 2;

        pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

        if (rva == pomapMid->rva) {
            if (pomapMid->rvaTo) {
                return mi->BaseOfDll + pomapMid->rvaTo;
            } else {
                return(0);      // No need adding the base.  This address was discarded...
            }
        }

        if (rva < pomapMid->rva) {
            pomapHigh = pomapMid;
            comap = (comap & 1) ? comapHalf : (comapHalf - 1);
        } else {
            pomapLow = pomapMid + 1;
            comap = comapHalf;
        }
    }

    //
    // If no exact match, pomapLow points to the next higher address
    //
    if (pomapLow == mi->pOmapFrom) {
        //
        // This address was not found
        //
        return 0;
    }

    if (pomapLow[-1].rvaTo == 0) {
        //
        // This address is in a discarded block
        //
        return 0;
    }

    //
    // Return the closest address plus the bias
    //
    *bias = rva - pomapLow[-1].rva;

    return mi->BaseOfDll + pomapLow[-1].rvaTo;
}


DWORD64
ConvertOmapToSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias,
    BOOL           fBackup
    )
{
    DWORD   rva;
    DWORD   comap;
    POMAP   pomapLow;
    POMAP   pomapHigh;
    DWORD   comapHalf;
    POMAP   pomapMid;

    *bias = 0;

    if (!mi->pOmapTo) {
        return addr;
    }

    rva = (DWORD)(addr - mi->BaseOfDll);

    comap = mi->cOmapTo;
    pomapLow = mi->pOmapTo;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

        comapHalf = comap / 2;

        pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

        if (rva == pomapMid->rva) {
            if (pomapMid->rvaTo == 0) {
                //
                // We may be at the start of an inserted branch instruction
                //

                if (fBackup) {
                    //
                    // Return information about the next lower address
                    //

                    rva--;
                    pomapLow = pomapMid;
                    break;
                }

                return 0;
            }

            return mi->BaseOfDll + pomapMid->rvaTo;
        }

        if (rva < pomapMid->rva) {
            pomapHigh = pomapMid;
            comap = (comap & 1) ? comapHalf : (comapHalf - 1);
        } else {
            pomapLow = pomapMid + 1;
            comap = comapHalf;
        }
    }

    //
    // If no exact match, pomapLow points to the next higher address
    //

    if (pomapLow == mi->pOmapTo) {
        //
        // This address was not found
        //
        return 0;
    }

    // find the previous valid item in the omap

    do {
        pomapLow--;
        if (pomapLow->rvaTo)
            break;
    } while (pomapLow > mi->pOmapTo);

    // should never occur

//  assert(pomapLow->rvaTo);
    if (pomapLow->rvaTo == 0) {
        return 0;
    }

    //
    // Return the new address plus the bias
    //
    *bias = rva - pomapLow->rva;

    return mi->BaseOfDll + pomapLow->rvaTo;
}

POMAP
GetOmapFromSrcEntry(
    PMODULE_ENTRY  mi,
    DWORD64        addr
    )
{
    DWORD   rva;
    DWORD   comap;
    POMAP   pomapLow;
    POMAP   pomapHigh;
    DWORD   comapHalf;
    POMAP   pomapMid;


    if (mi->pOmapFrom == NULL) {
        return NULL;
    }

    rva = (DWORD)(addr - mi->BaseOfDll);

    comap = mi->cOmapFrom;
    pomapLow = mi->pOmapFrom;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

        comapHalf = comap / 2;

        pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

        if (rva == pomapMid->rva) {
            return pomapMid;
        }

        if (rva < pomapMid->rva) {
            pomapHigh = pomapMid;
            comap = (comap & 1) ? comapHalf : (comapHalf - 1);
        } else {
            pomapLow = pomapMid + 1;
            comap = comapHalf;
        }
    }

    return NULL;
}


VOID
DumpOmapForModule(
    PMODULE_ENTRY      mi
    )
{
    POMAP pomap;
    DWORD i;

    i = sizeof(ULONG_PTR);
    i = sizeof(DWORD);

    if (!mi->pOmapFrom)
        return;

    dtrace("\nOMAP FROM:\n");
    for(i = 0, pomap = mi->pOmapFrom;
        i < 100; // mi->cOmapFrom;
        i++, pomap++)
    {
        dtrace("%8x %8x\n", pomap->rva, pomap->rvaTo);
    }

    if (!mi->pOmapTo)
        return;

    dtrace("\nOMAP TO:\n");
    for(i = 0, pomap = mi->pOmapTo;
        i < 100; // mi->cOmapTo;
        i++, pomap++)
    {
        dtrace("%8x %8x\n", pomap->rva, pomap->rvaTo);
    }
}


LPSTR
StringDup(
    LPSTR str
    )
{
    LPSTR ds;
    int   len;

    len = strlen(str) + 1;
    ds = (LPSTR)MemAlloc(len);
    if (ds) 
        CopyString(ds, str, len);
    return ds;
}


BOOL
LoadedModuleEnumerator(
    HANDLE         hProcess,
    LPSTR          ModuleName,
    DWORD64        ImageBase,
    DWORD          ImageSize,
    PLOADED_MODULE lm
    )
{
    if (lm->EnumLoadedModulesCallback64) {
        return lm->EnumLoadedModulesCallback64( ModuleName, ImageBase, ImageSize, lm->Context );
    } else {
        return lm->EnumLoadedModulesCallback32( ModuleName, (DWORD)ImageBase, ImageSize, lm->Context );
    }
}


LPSTR
SymUnDNameInternal(
    LPSTR UnDecName,
    DWORD UnDecNameLength,
    LPSTR DecName,
    DWORD DecNameLength,
    DWORD MachineType,
    BOOL  IsPublic
    )
{
    LPSTR p;
    ULONG i;
    LPSTR TmpDecName;

    *UnDecName = 0;

    __try {

        // strip leading periods - if any

        for (i = 0; i < DecNameLength; i++) {
            if (*DecName != '.')
                break;
            DecName += 1;
            DecNameLength -= 1;
        }

        if (*DecName == '?') {

            TmpDecName = (LPSTR)MemAlloc( 4096 );
            if (!TmpDecName) {
                strncat( UnDecName, DecName, min(DecNameLength,UnDecNameLength) );
                return UnDecName;
            }
            TmpDecName[0] = 0;
            strncat( TmpDecName, DecName, DecNameLength );

            if (UnDecorateSymbolName(TmpDecName,
                                     UnDecName,
                                     UnDecNameLength,
                                     UNDNAME_NAME_ONLY ) == 0 )
                strncat( UnDecName, DecName, min(DecNameLength,UnDecNameLength) );

            MemFree( TmpDecName );

        } else {

            if ((IsPublic && DecName[0] == '_')
                || DecName[0] == '@') {
                DecName += 1;
                DecNameLength -= 1;
            }

            p = 0;
            for (i = 0; i < DecNameLength; i++) {
                if (DecName [i] == '@') {
                    p = &DecName [i];
                    break;
                }
            }
            if (p) {
                i = (int)(p - DecName);
            } else {
                i = min(DecNameLength,UnDecNameLength);
            }

            strncat( UnDecName, DecName, i );
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        CatString(UnDecName, DecName, min(DecNameLength,UnDecNameLength));
    }

    if (option(SYMOPT_NO_CPP)) {
        while (p = strstr( UnDecName, "::" )) {
            p[0] = '_';
            p[1] = '_';
        }
    }

    return UnDecName;
}


BOOL
MatchSymName(
    LPSTR matchName,
    LPSTR symName
    )
{
    assert(matchName && symName);
    if (!*matchName || !*symName)
        return false;

    if (option(SYMOPT_CASE_INSENSITIVE)) {
        if (!_strnicmp(matchName, symName, MAX_SYM_NAME))
            return true;
    } else {
        if (!strncmp(matchName, symName, MAX_SYM_NAME))
            return true;
    }

    return false;
}


BOOL
__stdcall
ReadInProcMemory(
    HANDLE    hProcess,
    DWORD64   addr,
    PVOID     buf,
    DWORD     bytes,
    DWORD    *bytesread
    )
{
    DWORD                    rc;
    PPROCESS_ENTRY           pe;
    IMAGEHLP_CBA_READ_MEMORY rm;

    rm.addr      = addr;
    rm.buf       = buf;
    rm.bytes     = bytes;
    rm.bytesread = bytesread;

    rc = false;
    *bytesread = 0;

    __try {
        pe = FindProcessEntry(hProcess);
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return false;
        }

        if (pe->pCallbackFunction32) {
            rc = pe->pCallbackFunction32(pe->hProcess,
                                         CBA_READ_MEMORY,
                                         (PVOID)&rm,
                                         (PVOID)pe->CallbackUserContext);

        } else if (pe->pCallbackFunction64) {
            rc = pe->pCallbackFunction64(pe->hProcess,
                                         CBA_READ_MEMORY,
                                         (ULONG64)&rm,
                                         pe->CallbackUserContext);
        } else {
            SIZE_T RealBytesRead=0;
            rc = ReadProcessMemory(hProcess,
                                   (LPVOID)(ULONG_PTR)addr,
                                   buf,
                                   bytes,
                                   &RealBytesRead);
            *bytesread = (DWORD)RealBytesRead;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = false;
    }

    return (rc != false);
}

DWORD64
miGetModuleBase(
    HANDLE  hProcess,
    DWORD64 Address
    )
{
    IMAGEHLP_MODULE64 ModuleInfo = {0};
    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);

    if (SymGetModuleInfo64(hProcess, Address, &ModuleInfo)) {
        return ModuleInfo.BaseOfImage;
    } else {
        return 0;
    }
}

BOOL
GetPData(
    HANDLE        hp,
    PMODULE_ENTRY mi
    )
{
    BOOL status;
    ULONG cb;
    PCHAR pc;
    BOOL  fROM = false;
    IMAGE_DOS_HEADER DosHeader;
    IMAGE_NT_HEADERS ImageNtHeaders;
    PIMAGE_FILE_HEADER ImageFileHdr;
    PIMAGE_OPTIONAL_HEADER ImageOptionalHdr;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    ULONG feCount = 0;
    ULONG i;

    HANDLE fh = 0;
    PCHAR  base = NULL;
    USHORT                       filetype;
    PIMAGE_SEPARATE_DEBUG_HEADER  sdh;
    PIMAGE_DOS_HEADER dh;
    PIMAGE_NT_HEADERS inth;
    PIMAGE_OPTIONAL_HEADER32 ioh32;
    PIMAGE_OPTIONAL_HEADER64 ioh64;
    ULONG cdd;
    PCHAR p;
    PIMAGE_DEBUG_DIRECTORY dd;
    ULONG cexp = 0;
    ULONG tsize;
    ULONG csize = 0;

    // if the pdata is already loaded, return

    if (mi->pExceptionData)
        return true;

    if (!LoadSymbols(hp, mi, 0))
        return false;

    // try to get pdata from dia

    if (mi->dia) {
        if ((mi->pPData) && (mi->dsExceptions == dsDia))
            goto dia;

        if (diaGetPData(mi)) {
            p = (PCHAR)mi->pPData;
            csize = mi->cbPData;
            goto dia;
        }
    }

    if (!mi->dsExceptions)
        return false;

    // open the file and get the file type

    SetCriticalErrorMode();

    fh = CreateFile(mi->LoadedImageName,
                    GENERIC_READ,
                    g.OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    ResetCriticalErrorMode();

    if (fh == INVALID_HANDLE_VALUE)
        return false;

    base = (PCHAR)MapItRO(fh);
    if (!base)
        goto cleanup;
    p = base;

    filetype = *(USHORT *)p;
    if (filetype == IMAGE_DOS_SIGNATURE)
        goto image;
    if (filetype == IMAGE_SEPARATE_DEBUG_SIGNATURE)
        goto dbg;
    goto cleanup;

image:

    // process disk-based image

    dh = (PIMAGE_DOS_HEADER)p;
    p  += dh->e_lfanew;
    inth = (PIMAGE_NT_HEADERS)p;

    if (inth->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        ioh32 = (PIMAGE_OPTIONAL_HEADER32)&inth->OptionalHeader;
        p = base + ioh32->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
        csize = ioh32->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
    }
    else if (inth->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        ioh64 = (PIMAGE_OPTIONAL_HEADER64)&inth->OptionalHeader;
        p = base + ioh64->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
        csize = ioh64->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
    }

dia:

    if (!csize)
        goto cleanup;

    switch (mi->MachineType)
    {
    case IMAGE_FILE_MACHINE_ALPHA:
        cexp = csize / sizeof(IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY);
        break;
    case IMAGE_FILE_MACHINE_ALPHA64:
        cexp = csize / sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY);
        break;
    case IMAGE_FILE_MACHINE_IA64:
        cexp = csize / sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY);
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        cexp = csize / sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY);
        break;
    default:
        goto cleanup;
    }

    goto table;

dbg:

    // process dbg file

    sdh = (PIMAGE_SEPARATE_DEBUG_HEADER)p;
    cdd = sdh->DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY);
    p +=  sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
          (sdh->NumberOfSections * sizeof(IMAGE_SECTION_HEADER)) +
          sdh->ExportedNamesSize;
    dd = (PIMAGE_DEBUG_DIRECTORY)p;

    for (i = 0; i < cdd; i++, dd++) {
        if (dd->Type == IMAGE_DEBUG_TYPE_EXCEPTION) {
            p = base + dd->PointerToRawData;
            cexp = dd->SizeOfData / sizeof(IMAGE_FUNCTION_ENTRY);
            break;
        }
    }

table:

    // parse the pdata into a table

    if (!cexp)
        goto cleanup;

    tsize = cexp * sizeof(IMGHLP_RVA_FUNCTION_DATA);

    mi->pExceptionData = (PIMGHLP_RVA_FUNCTION_DATA)VirtualAlloc( NULL, tsize, MEM_COMMIT, PAGE_READWRITE );

    if (mi->pExceptionData) {
        PIMGHLP_RVA_FUNCTION_DATA pIRFD = mi->pExceptionData;
        switch (mi->MachineType) {

        case IMAGE_FILE_MACHINE_ALPHA:
            if (filetype == IMAGE_SEPARATE_DEBUG_SIGNATURE) {
                // easy case.  The addresses are already in rva format.
                PIMAGE_FUNCTION_ENTRY pFE = (PIMAGE_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pFE[i].StartingAddress;
                    pIRFD[i].rvaEndAddress       = pFE[i].EndingAddress;
                    pIRFD[i].rvaPrologEndAddress = pFE[i].EndOfPrologue;
                    pIRFD[i].rvaExceptionHandler = 0;
                    pIRFD[i].rvaHandlerData      = 0;
                }
            } else {
                PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pRFE[i].BeginAddress - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaEndAddress       = pRFE[i].EndAddress - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaPrologEndAddress = pRFE[i].PrologEndAddress - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaExceptionHandler = pRFE[i].ExceptionHandler - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaHandlerData      = pRFE[i].HandlerData - (ULONG)mi->BaseOfDll;
                }
            }
            break;

        case IMAGE_FILE_MACHINE_ALPHA64:
            {
                PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = (DWORD)(pRFE[i].BeginAddress - mi->BaseOfDll);
                    pIRFD[i].rvaEndAddress       = (DWORD)(pRFE[i].EndAddress - mi->BaseOfDll);
                    pIRFD[i].rvaPrologEndAddress = (DWORD)(pRFE[i].PrologEndAddress - mi->BaseOfDll);
                    pIRFD[i].rvaExceptionHandler = (DWORD)(pRFE[i].ExceptionHandler - mi->BaseOfDll);
                    pIRFD[i].rvaHandlerData      = (DWORD)(pRFE[i].HandlerData - mi->BaseOfDll);
                }
            }
            break;

        case IMAGE_FILE_MACHINE_IA64:
            {
                PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pRFE[i].BeginAddress;
                    pIRFD[i].rvaEndAddress       = pRFE[i].EndAddress;
                    pIRFD[i].rvaPrologEndAddress = pRFE[i].UnwindInfoAddress;
                    pIRFD[i].rvaExceptionHandler = 0;
                    pIRFD[i].rvaHandlerData      = 0;
                }
            }
            break;

        case IMAGE_FILE_MACHINE_AMD64:
            {
                _PIMAGE_RUNTIME_FUNCTION_ENTRY pRFE = (_PIMAGE_RUNTIME_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pRFE[i].BeginAddress;
                    pIRFD[i].rvaEndAddress       = pRFE[i].EndAddress;
                    pIRFD[i].rvaPrologEndAddress = pRFE[i].UnwindInfoAddress;
                    pIRFD[i].rvaExceptionHandler = 0;
                    pIRFD[i].rvaHandlerData      = 0;
                }
            }
            break;

        default:
            break;
        }

        VirtualProtect( mi->pExceptionData, tsize, PAGE_READONLY, &i );

        mi->dwEntries = cexp;
    }

cleanup:

    if (mi->pPData) {
        MemFree(mi->pPData);
        mi->pPData = NULL;
    }

    if (base)
        UnmapViewOfFile(base);

    if (fh)
        CloseHandle(fh);

    return (cexp) ? true : false;
}

BOOL
GetXData(
    HANDLE        hp,
    PMODULE_ENTRY mi
    )
{
    if (mi->pXData)
        return true;

    if (LoadSymbols(hp, mi, 0) && !mi->pXData && mi->dia && !diaGetXData(mi))
        return false;

    return (mi->pXData != NULL);
}

PVOID
GetXDataFromBase(
    HANDLE     hp,
    DWORD64    base,
    ULONG*     size
    )
{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY  mi;

    pe = FindProcessEntry(hp);
    if (!pe) {
        SetLastError(ERROR_INVALID_HANDLE);
        return NULL;
    }

    mi = GetModuleForPC(pe, base, false);
    if (!mi) {
        SetLastError(ERROR_MOD_NOT_FOUND);
        return NULL;
    }

    if (!GetXData(hp, mi))
        return NULL;

    if (size) *size = mi->cbXData;
    return mi->pXData;
}

PVOID
GetUnwindInfoFromSymbols(
    HANDLE     hProcess,
    DWORD64    ModuleBase,
    ULONG      UnwindInfoAddress,
    ULONG*     Size
    )
{
    ULONG XDataSize;

    PBYTE pXData = (PBYTE)GetXDataFromBase(hProcess, ModuleBase, &XDataSize);
    if (!pXData)
        return NULL;

    DWORD DataBase = *(DWORD*)pXData;
    pXData += sizeof(DWORD);

    if (DataBase > UnwindInfoAddress)
        return NULL;

    ULONG Offset = (ULONG)(ULONG_PTR)(UnwindInfoAddress - DataBase);

    if (Offset >= XDataSize)
        return NULL;

    if (Size) *Size = XDataSize - Offset;
    return pXData + Offset;
}


BOOL
IsRegularExpression(
    const char *sz)
{
    for (; *sz; sz++) {
        switch(*sz)
        {
        case '*':
        case '?':
        case '[':
        case ']':
            return true;
        }
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\symdbg.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    symdbg.c

Abstract:

    This module implements functions for splitting debugging information
    out of an image file and into a separate .DBG file.

Author:

    Steven R. Wood (stevewo) 4-May-1993

Revision History:

--*/

#include <private.h>
#include <symbols.h>
#include <globals.h>

#define ROUNDUP(x, y) ((x + (y-1)) & ~(y-1))

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#if !defined(_WIN64)

PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    HANDLE FileHandle,
    LPSTR FileName,
    LPSTR SymbolPath,
    ULONG ImageBase
    )

// Here's what we're going to try.  MapDebugInformation was only
// documented as returning COFF symbolic and every user I can find
// in the tree uses COFF exclusively.  Rather than try to make this
// api do everything possible, let's just leave it as a COFF only thing.

// The new debug info api (GetDebugData) will be internal only.

{
    PIMAGE_DEBUG_INFORMATION pIDI;
    CHAR szName[_MAX_FNAME];
    CHAR szExt[_MAX_EXT];
    PIMGHLP_DEBUG_DATA idd;
    PPIDI              pPIDI;
    DWORD sections;
    BOOL               SymbolsLoaded;
    HANDLE             hProcess;
    LPSTR sz;
    HANDLE hdb;
    DWORD dw;
    DWORD len;
    hProcess = GetCurrentProcess();

    idd = GetIDD(FileHandle, FileName, SymbolPath, ImageBase, NO_PE64_IMAGES);

    if (!idd)
        return NULL;

    pPIDI = (PPIDI)MemAlloc(sizeof(PIDI));
    if (!pPIDI)
        return NULL;

    ZeroMemory(pPIDI, sizeof(PIDI));
    pIDI = &pPIDI->idi;
    pPIDI->hdr.idd = idd;

    pIDI->ReservedSize            = sizeof(IMAGE_DEBUG_INFORMATION);
    pIDI->ReservedMachine         = idd->Machine;
    pIDI->ReservedCharacteristics = (USHORT)idd->Characteristics;
    pIDI->ReservedCheckSum        = idd->CheckSum;
    pIDI->ReservedTimeDateStamp   = idd->TimeDateStamp;
    pIDI->ReservedRomImage        = idd->fROM;

    // read info

    InitializeListHead( &pIDI->List );
    pIDI->ImageBase = (ULONG)idd->ImageBaseFromImage;

    len = strlen(idd->ImageFilePath) + 1;
    pIDI->ImageFilePath = (PSTR)MemAlloc(len);
    if (pIDI->ImageFilePath) {
        CopyString(pIDI->ImageFilePath, idd->ImageFilePath, len);
    }

    len = strlen(idd->OriginalImageFileName) + 1;
    pIDI->ImageFileName = (PSTR)MemAlloc(len);
    if (pIDI->ImageFileName) {
        CopyString(pIDI->ImageFileName, idd->OriginalImageFileName, len);
    }

    if (idd->pMappedCoff) {
        pIDI->CoffSymbols = (PIMAGE_COFF_SYMBOLS_HEADER)MemAlloc(idd->cMappedCoff);
        if (pIDI->CoffSymbols) {
            memcpy(pIDI->CoffSymbols, idd->pMappedCoff, idd->cMappedCoff);
        }
        pIDI->SizeOfCoffSymbols = idd->cMappedCoff;
    }

    if (idd->pFpo) {
        pIDI->ReservedNumberOfFpoTableEntries = idd->cFpo;
        pIDI->ReservedFpoTableEntries = (PFPO_DATA)idd->pFpo;
    }

    pIDI->SizeOfImage = idd->SizeOfImage;

    if (idd->DbgFilePath && *idd->DbgFilePath) {
        len = strlen(idd->DbgFilePath) + 1;
        pIDI->ReservedDebugFilePath = (PSTR)MemAlloc(len);
        if (pIDI->ReservedDebugFilePath) {
            CopyString(pIDI->ReservedDebugFilePath, idd->DbgFilePath, len);
        }
    }

    if (idd->pMappedCv) {
        pIDI->ReservedCodeViewSymbols       = idd->pMappedCv;
        pIDI->ReservedSizeOfCodeViewSymbols = idd->cMappedCv;
    }

    // for backwards compatibility
    if (idd->ImageMap) {
        sections = (DWORD)((char *)idd->pCurrentSections - (char *)idd->ImageMap);
        pIDI->ReservedMappedBase = MapItRO(idd->ImageFileHandle);
        if (pIDI->ReservedMappedBase) {
            pIDI->ReservedSections = (PIMAGE_SECTION_HEADER)idd->pCurrentSections;
            pIDI->ReservedNumberOfSections = idd->cCurrentSections;
            if (idd->ddva) {
                pIDI->ReservedDebugDirectory = (PIMAGE_DEBUG_DIRECTORY)((PCHAR)pIDI->ReservedMappedBase + idd->ddva);
                pIDI->ReservedNumberOfDebugDirectories = idd->cdd;
            }
        }
    }

    return pIDI;
}

BOOL
UnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION pIDI
    )
{
    PPIDI pPIDI;

    if (!pIDI)
        return true;

    if (pIDI->ImageFileName){
        MemFree(pIDI->ImageFileName);
    }

    if (pIDI->ImageFilePath) {
        MemFree(pIDI->ImageFilePath);
    }

    if (pIDI->ReservedDebugFilePath) {
        MemFree(pIDI->ReservedDebugFilePath);
    }

    if (pIDI->CoffSymbols) {
        MemFree(pIDI->CoffSymbols);
    }

    if (pIDI->ReservedMappedBase) {
        UnmapViewOfFile(pIDI->ReservedMappedBase);
    }

    pPIDI = (PPIDI)(PCHAR)((PCHAR)pIDI - sizeof(PIDI_HEADER));
    ReleaseDebugData(pPIDI->hdr.idd, IMGHLP_FREE_ALL);
    MemFree(pPIDI);

    return true;
}

#endif


LPSTR
ExpandPath(
    LPSTR lpPath
    )
{
    LPSTR   p, newpath, p1, p2, p3;
    CHAR    envvar[MAX_PATH];
    CHAR    envstr[MAX_PATH];
    ULONG   i, PathMax;

    if (!lpPath) {
        return(NULL);
    }

    p = lpPath;
    PathMax = strlen(lpPath) + MAX_PATH + 1;
    p2 = newpath = (LPSTR) MemAlloc( PathMax );

    if (!newpath) {
        return(NULL);
    }

    while( p && *p) {
        if (*p == '%') {
            i = 0;
            p++;
            while (p && *p && *p != '%') {
                envvar[i++] = *p++;
            }
            p++;
            envvar[i] = '\0';
            p1 = envstr;
            *p1 = 0;
            GetEnvironmentVariable( envvar, p1, MAX_PATH );
            while (p1 && *p1) {
                *p2++ = *p1++;
                if (p2 >= newpath + PathMax) {
                    PathMax += MAX_PATH;
                    p3 = (LPSTR)MemReAlloc(newpath, PathMax);
                    if (!p3) {
                        MemFree(newpath);
                        return(NULL);
                    } else {
                        p2 = p3 + (p2 - newpath);
                        newpath = p3;
                    }
                }
            }
        }
        *p2++ = *p++;
        if (p2 >= newpath + PathMax) {
            PathMax += MAX_PATH;
            p3 = (LPSTR)MemReAlloc(newpath, PathMax);
            if (!p3) {
                MemFree(newpath);
                return(NULL);
            } else {
                p2 = p3 + (p2 - newpath);
                newpath = p3;
            }
        }
    }
    *p2 = '\0';

    return newpath;
}


BOOL
CheckDirForFile(
    char  *srchpath,
    char  *found,
    DWORD  size,
    PFINDFILEINPATHCALLBACK callback,
    PVOID  context
    )
{
    char path[MAX_PATH + 1];
    char file[MAX_PATH + 1];
    char fname[_MAX_FNAME + 1] = "";
    char ext[_MAX_EXT + 1];
    WIN32_FIND_DATA fd;
    HANDLE hfind;
    HANDLE hfile = 0;
    BOOL rc;

    ShortFileName(srchpath, path, DIMA(path));
    EnsureTrailingBackslash(path);
    CatStrArray(path, "*");

    ZeroMemory(&fd, sizeof(fd));
    hfind = FindFirstFile(path, &fd);
    if (hfind == INVALID_HANDLE_VALUE)
        return false;

    ShortFileName(srchpath, path, DIMA(path));
    _splitpath(path, NULL, NULL, fname, ext);

    do {
        if (!strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, ".."))
            continue;
        CopyStrArray(file, path);
        EnsureTrailingBackslash(file);
        CatStrArray(file, fd.cFileName);
        if (isdir(file)) {
            EnsureTrailingBackslash(file);
            CatStrArray(file, fname);
            CatStrArray(file, ext);
            if (!fileexists(file))
                continue;
        }
        CopyString(found, file, MAX_PATH + 1);
        if (!callback)
            break;
        // otherwise call the callback
        rc = callback(found, context);
        // if it returns false, quit...
        if (!rc)
            return true;
        // otherwise continue
        *found = 0;
    } while (FindNextFile(hfind, &fd));


    // If there is no match, but a file exists in the symbol subdir with
    // a matching name, make sure that is what will be picked.

    CopyStrArray(file, srchpath);
    EnsureTrailingBackslash(file);
    CatStrArray(file, fname);
    CatStrArray(file, ext);
    if (fileexists(file))
        CopyStrArray(found, file);

    return false;
}


BOOL
IMAGEAPI
SymFindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FoundFile,
    PFINDFILEINPATHCALLBACK callback,
    PVOID  context
    )
{
    PPROCESS_ENTRY  pe = NULL;
    char path[MAX_PATH + 1];
    char dirpath[MAX_PATH + 1];
    char fname[MAX_PATH + 1];
    char token[MAX_PATH + 1];
    char *next;
    LPSTR emark;
    LPSTR spath;
    GUID  guid;
    GUID *pguid;
    BOOL  rc;
    LPSTR p;
    DWORD err;
    BOOL  ssrv = true;

    if (!FileName || !*FileName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return false;
    }

    // ignore the path...

    for (p = FileName + strlen(FileName); p >= FileName; p--) {
        if (*p == '\\') {
            FileName = p + 1;
            break;
        }
    }

#ifdef DEBUG
    if (traceSubName(FileName)) // for setting debug breakpoints from DBGHELP_TOKEN
        dtrace("debug(%s)\n", FileName);
#endif

    // prepare identifiers for symbol server

    if (flags & SSRVOPT_GUIDPTR) {
        pguid = (GUID *)id;
    } else {
        pguid = &guid;
        ZeroMemory(pguid, sizeof(GUID));
        if (!flags || (flags & SSRVOPT_DWORD))
            pguid->Data1 = PtrToUlong(id);
        else if (flags & SSRVOPT_DWORDPTR)
            pguid->Data1 = *(DWORD *)id;
    }

    // setup local copy of the symbol path

    *FoundFile = 0;
    spath = NULL;

    if (hprocess)
        pe = FindProcessEntry(hprocess);

    if (!SearchPath || !*SearchPath) {
        if (pe && pe->SymbolSearchPath) {
            spath = pe->SymbolSearchPath;
        }
    } else {
        spath = SearchPath;
    }

    if (!spath || !*spath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return false;
    }

    // for each node in the search path, look
    // for the file, or for it's symsrv entry


    for (next = TokenFromSymbolPath(spath, path, MAX_PATH + 1);
         *path;
         next = TokenFromSymbolPath(next, path, MAX_PATH + 1))
    {
        // look for the file in this node
        if (ssrv && symsrvPath(path)) {
            err = symsrvGetFile(pe,
                                path,
                                FileName,
                                pguid,
                                two,
                                three,
                                FoundFile);
            if (err == ERROR_NO_DATA)
                ssrv = false;
        } else {
            EnsureTrailingBackslash(path);
            CopyStrArray(dirpath, path);
            CatStrArray(dirpath, FileName);
            rc = CheckDirForFile(dirpath, FoundFile, MAX_PATH + 1, callback, context);
            if (rc) {
                pprint(pe, "%s - ", FoundFile);
                break;
            }
            CatStrArray(path, FileName);
            if (fileexists(path))
                strcpy(FoundFile, path);     // SECURITY: Don't know size of buffer.
        }

        // if we find a file, process it.

        if (*FoundFile) {
            // if no callback is specified, return with the filename filled in
            pprint(pe, "%s - ", FoundFile);
            if (!callback)
                break;
            // otherwise call the callback
            rc = callback(FoundFile, context);
            // if it returns false, quit...
            if (!rc)
                break;
            // otherwise continue
            peprint(pe, "mismatched\n");
            *FoundFile = 0;
        }
    }

    if (*FoundFile) {
        peprint(pe, "OK\n");
        return true;
    }

    return false;
}


BOOL
IMAGEAPI
FindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath
    )
{
    return SymFindFileInPath(hprocess, SearchPath, FileName, id, two, three, flags, FilePath, NULL, NULL);
}


BOOL
IMAGEAPI
FindFileInSearchPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    DWORD  one,
    DWORD  two,
    DWORD  three,
    LPSTR  FilePath
    )
{
    return FindFileInPath(hprocess, SearchPath, FileName, UlongToPtr(one), two, three, SSRVOPT_DWORD, FilePath);
}


HANDLE
IMAGEAPI
FindExecutableImage(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR ImageFilePath
    )
{
    return FindExecutableImageEx(FileName, SymbolPath, ImageFilePath, NULL, NULL);
}


HANDLE
CheckExecutableImage(
    LPCSTR Path,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData,
    DWORD flags
    )
{
    HANDLE FileHandle;
    char   TmpPath[MAX_PATH + 1];
    PIMGHLP_DEBUG_DATA idd;
    PPROCESS_ENTRY pe = NULL;

    SetCriticalErrorMode();

    idd = (PIMGHLP_DEBUG_DATA)CallerData;
    if (idd && (idd->SizeOfStruct == sizeof(IMGHLP_DEBUG_DATA)))
        pe = idd->pe;

    if (!CopyStrArray(TmpPath, Path))
        return INVALID_HANDLE_VALUE;
    pprint(pe, "%s - ", Path);
    FileHandle = CreateFile( Path,
                             GENERIC_READ,
                             g.OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ?
                             (FILE_SHARE_DELETE | FILE_SHARE_READ |
                              FILE_SHARE_WRITE) :
                             (FILE_SHARE_READ | FILE_SHARE_WRITE),
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                             );

    if (FileHandle != INVALID_HANDLE_VALUE) {
        if (Callback) {
            if (!Callback(FileHandle, TmpPath, CallerData)) {
                if (!(flags & SYMOPT_LOAD_ANYTHING)) {
                    pprint(pe, "%s - mismatched timestamp OK\n", Path);
                    CloseHandle(FileHandle);
                    FileHandle = INVALID_HANDLE_VALUE;
                } else
                    pprint(pe, "%s - mismatched timestamp\n", Path);
            }
        }
        if (FileHandle != INVALID_HANDLE_VALUE) {
            pprint(pe, "%s - OK\n", Path);
        }
    } else {
        peprint(pe, "%s\n", errortext(GetLastError()));
    }

    ResetCriticalErrorMode();

    return FileHandle;
}

typedef struct _FEIEP_STATE
{
    PFIND_EXE_FILE_CALLBACK UserCb;
    PVOID UserCbData;
    DWORD flags;
    HANDLE Return;
} FEIEP_STATE;


BOOL
CALLBACK
FindExSearchTreeCallback(
    LPCSTR FilePath,
    PVOID  CallerData
    )
{
    FEIEP_STATE* State = (FEIEP_STATE*)CallerData;

    State->Return =
        CheckExecutableImage(FilePath, State->UserCb, State->UserCbData,
                             State->flags);
    return State->Return != INVALID_HANDLE_VALUE;
}


BOOL
CheckDirForExecutable(
    char  *srchpath,
    char  *filename,
    char  *found,
    PENUMDIRTREE_CALLBACK callback,
    PVOID  context
    )
{
    char tmp[MAX_PATH + 1];
    char path[MAX_PATH + 1];
    char file[MAX_PATH + 1];
    char fname[_MAX_FNAME + 1] = "";
    char ext[_MAX_EXT + 1];
    WIN32_FIND_DATA fd;
    HANDLE hfind;
    HANDLE hfile = 0;
    BOOL rc;

    CopyStrArray(tmp, srchpath);
    EnsureTrailingBackslash(tmp);
    CatStrArray(tmp, filename);
    ShortFileName(tmp, path, DIMA(path));
    EnsureTrailingBackslash(path);
    CatStrArray(path, "*");

    ZeroMemory(&fd, sizeof(fd));
    hfind = FindFirstFile(path, &fd);
    if (hfind == INVALID_HANDLE_VALUE)
        return false;

    CopyStrArray(tmp, srchpath);
    EnsureTrailingBackslash(tmp);
    CatStrArray(tmp, filename);
    ShortFileName(tmp, path, DIMA(path));
    _splitpath(path, NULL, NULL, fname, ext);

    do {
        if (!strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, ".."))
            continue;
        CopyStrArray(file, path);
        EnsureTrailingBackslash(file);
        CatStrArray(file, fd.cFileName);
        if (isdir(file)) {
            EnsureTrailingBackslash(file);
            CatStrArray(file, fname);
            CatStrArray(file, ext);
            if (!fileexists(file))
                continue;
        }
        CopyString(found, file, MAX_PATH + 1);
        if (!callback)
            break;
        // otherwise call the callback
        rc = callback(found, context);
        // if it returns false, quit...
        if (rc)
            return true;
        // otherwise continue
        *found = 0;
    } while (FindNextFile(hfind, &fd));

    // If there is no match, but a file exists in the symbol subdir with
    // a matching name, make sure that is what will be picked.

    CopyStrArray(file, path);
    EnsureTrailingBackslash(file);
    CatStrArray(file, fname);
    CatStrArray(file, ext);
    if (fileexists(file))
        CopyStrArray(found, file);

    return false;
}


HANDLE
IMAGEAPI
FindExecutableImageExPass(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData,
    DWORD flags
    )
{
    LPSTR Start, End;
    HANDLE FileHandle = NULL;
    CHAR DirectoryPath[MAX_PATH + 1];
    LPSTR NewSymbolPath = NULL;
    PIMGHLP_DEBUG_DATA idd;
    PPROCESS_ENTRY pe = NULL;

    idd = (PIMGHLP_DEBUG_DATA)CallerData;
    if (idd && (idd->SizeOfStruct == sizeof(IMGHLP_DEBUG_DATA)))
        pe = idd->pe;

    __try {
        __try {
            if (GetFullPathName( FileName, MAX_PATH, ImageFilePath, &Start )) {
                FileHandle = CheckExecutableImage(ImageFilePath, Callback, CallerData, flags);
                if (FileHandle != INVALID_HANDLE_VALUE)
                    return FileHandle;
            }

            NewSymbolPath = ExpandPath(SymbolPath);
            Start = NewSymbolPath;
            while (Start && *Start != '\0') {
                FEIEP_STATE SearchTreeState;

                if (End = strchr( Start, ';' )) {
                    CopyNStrArray(DirectoryPath, Start, (ULONG)(End - Start));
                    End += 1;
                } else {
                    CopyStrArray(DirectoryPath, Start);
                }
                trim(DirectoryPath);

                if (symsrvPath(DirectoryPath))
                    goto next;

                SearchTreeState.UserCb = Callback;
                SearchTreeState.UserCbData = CallerData;
                SearchTreeState.flags = flags;
                if (CheckDirForExecutable(DirectoryPath, FileName, ImageFilePath, FindExSearchTreeCallback, &SearchTreeState)) {
                    pprint(pe, "%s found\n", ImageFilePath);
                    MemFree( NewSymbolPath );
                    return SearchTreeState.Return;
                }
                if (EnumDirTree(INVALID_HANDLE_VALUE, DirectoryPath, FileName, ImageFilePath, FindExSearchTreeCallback, &SearchTreeState )) {
                    pprint(pe, "%s found\n", ImageFilePath);
                    MemFree( NewSymbolPath );
                    return SearchTreeState.Return;
                } else {
                    pprint(pe, "%s not found in %s\n", FileName, DirectoryPath);
                }

next:
                Start = End;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(ERROR_INVALID_PARAMETER);
        }

        ImageFilePath[0] = '\0';

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    if (FileHandle) {
        CloseHandle(FileHandle);
    }

    if (NewSymbolPath) {
        MemFree( NewSymbolPath );
    }

    return NULL;
}


HANDLE
IMAGEAPI
FindExecutable(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData,
    DWORD flags
    )
{
    BOOL FullPath = false;
    BOOL PathComponents = false;
    HANDLE FileHandle;

    if (!FileName || !*FileName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // The filename may or may not contain path components.
    // Determine what kind of path it is.
    //

    if ((((FileName[0] >= 'a' && FileName[0] <= 'z') ||
          (FileName[0] >= 'A' && FileName[0] <= 'Z')) &&
         FileName[1] == ':') ||
        FileName[0] == '\\' ||
        FileName[0] == '/') {

        FullPath = true;
        PathComponents = true;

    } else if (strchr(FileName, '\\') ||
               strchr(FileName, '/')) {

        PathComponents = true;

    }

    // If the filename is a full path then it can be checked
    // for existence directly; there's no need to search
    // along any paths.
    if (FullPath) {
        __try {
            FileHandle = CheckExecutableImage(FileName, Callback, CallerData, flags);
            if (FileHandle != INVALID_HANDLE_VALUE) {
                strcpy(ImageFilePath, FileName);  // SECURITY: Don't know size of target buffer.
                return FileHandle;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return NULL;
        }
    } else {
        // If it's not a full path we need to do a first pass
        // with the filename as given.  This handles relative
        // paths and bare filenames.
        FileHandle = FindExecutableImageExPass(FileName, SymbolPath,
                                               ImageFilePath, Callback,
                                               CallerData, flags);
        if (FileHandle != NULL) {
            return FileHandle;
        }
    }

    // If we still haven't found it and the given filename
    // has path components we need to strip off the path components
    // and try again with just the base filename.
    if (PathComponents) {
        LPSTR BaseFile;

        BaseFile = strrchr(FileName, '\\');
        if (BaseFile == NULL) {
            BaseFile = strrchr(FileName, '/');
            if (BaseFile == NULL) {
                // Must be <drive>:.
                BaseFile = FileName + 1;
            }
        }

        // Skip path character to point to base file.
        BaseFile++;

        return FindExecutableImageExPass(BaseFile, SymbolPath,
                                         ImageFilePath, Callback,
                                         CallerData, flags);
    }

    return NULL;
}


HANDLE
IMAGEAPI
FindExecutableImageEx(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData
    )
{
    HANDLE hrc;

    hrc = FindExecutable(FileName,
                         SymbolPath,
                         ImageFilePath,
                         Callback,
                         CallerData,
                         0);
    if (hrc)
        return hrc;

    if (option(SYMOPT_LOAD_ANYTHING))
        hrc = FindExecutable(FileName,
                             SymbolPath,
                             ImageFilePath,
                             Callback,
                             CallerData,
                             SYMOPT_LOAD_ANYTHING);
     return hrc;
}


HANDLE
IMAGEAPI
FindDebugInfoFile(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath
    )
{
    return FindDebugInfoFileEx(FileName, SymbolPath, DebugFilePath, NULL, NULL);
}


void dbgerror(PPROCESS_ENTRY pe)
{
    DWORD err = GetLastError();

    switch (err)
    {
    case ERROR_FILE_NOT_FOUND:
        peprint(pe, "file not found\n");
        break;
    case ERROR_PATH_NOT_FOUND:
        peprint(pe, "path not found\n");
        break;
    case ERROR_NOT_READY:
        peprint(pe, "drive not ready\n");
        break;
    case ERROR_ACCESS_DENIED:
        peprint(pe, "access is denied\n");
        break;
    default:
        peprint(pe, "file error 0x%x\n", err);
        break;
    }
}


HANDLE
OpenDbg(
    PPROCESS_ENTRY pe,
    char *dbgpath,
    char *found,
    DWORD size,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID CallerData
    )
{
    HANDLE fh;
    static DWORD attrib = (DWORD)-1;

    if (attrib == (DWORD)-1) {
        if (g.OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            attrib = (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE);
        } else {
            attrib = (FILE_SHARE_READ | FILE_SHARE_WRITE);
        }
    }

    if (!*dbgpath || !size)
        return INVALID_HANDLE_VALUE;

    fh = CreateFile(dbgpath,
                    GENERIC_READ,
                    attrib,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (fh == INVALID_HANDLE_VALUE) {
        pprint(pe, "%s - %s\n", dbgpath, errortext(GetLastError())); // dbgerror(pe);
        return fh;
    }

    if (Callback && !Callback(fh, dbgpath, CallerData)) {
        pprint(pe, "%s - mismatched timestamp\n", dbgpath);
        CloseHandle(fh);
        fh = INVALID_HANDLE_VALUE;
        if (!*found)
            CopyString(found, dbgpath, size);
        return fh;
    }
    CopyString(found, dbgpath, size);

    // Don't display the okay message, if we are within modload().
    // We can tell if pe was set to anything but null.

    if (!pe)
        pprint(pe, "%s - OK", dbgpath);

    return fh;
}


HANDLE
CheckDirForDbgs(
    PPROCESS_ENTRY pe,
    char  *dbgpath,
    char  *found,
    DWORD  size,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID  CallerData
    )
{
    char path[MAX_PATH + 1];
    char dbg[MAX_PATH + 1];
    char fname[_MAX_FNAME + 1] = "";
    char ext[_MAX_EXT + 1];
    WIN32_FIND_DATA fd;
    HANDLE hfind;
    HANDLE hfile;

    ShortFileName(dbgpath, path, DIMA(path));
    EnsureTrailingBackslash(path);
    CatStrArray(path, "*");

    ZeroMemory(&fd, sizeof(fd));
    hfind = FindFirstFile(path, &fd);
    if (hfind == INVALID_HANDLE_VALUE)
        return hfind;

    do {
        if (!strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, ".."))
            continue;
        CopyStrArray(dbg, dbgpath);
        EnsureTrailingBackslash(dbg);
        CatStrArray(dbg, fd.cFileName);
        if (GetFileAttributes(dbg) & FILE_ATTRIBUTE_DIRECTORY) {
            if (!*fname)
                _splitpath(dbgpath, NULL, NULL, fname, ext);
            EnsureTrailingBackslash(dbg);
            CatStrArray(dbg, fname);
            CatStrArray(dbg, ext);
        } else {
            if (!IsDbg(dbg))
                continue;
        }
        hfile = OpenDbg(pe, dbg, found, size, Callback, CallerData);
        if (hfile != INVALID_HANDLE_VALUE) {
            CopyString(dbgpath, dbg, MAX_PATH + 1);
            return hfile;
        }
    } while (FindNextFile(hfind, &fd));

    return INVALID_HANDLE_VALUE;
}


HANDLE
IMAGEAPI
FindDebugInfoFileEx(
    IN  LPSTR FileName,
    IN  LPSTR SymbolPath,
    OUT LPSTR DebugFilePath,
    IN  PFIND_DEBUG_FILE_CALLBACK Callback,
    IN  PVOID CallerData
    )
/*++

Routine Description:

 The rules are:
   Look for
     1. <SymbolPath>\Symbols\<ext>\<filename>.dbg
     3. <SymbolPath>\<ext>\<filename>.dbg
     5. <SymbolPath>\<filename>.dbg
     7. <FileNamePath>\<filename>.dbg

Arguments:
    FileName - Supplies a file name in one of three forms: fully qualified,
                <ext>\<filename>.dbg, or just filename.dbg
    SymbolPath - semi-colon delimited

    DebugFilePath -

    Callback - May be NULL. Callback that indicates whether the Symbol file is valid, or whether
        the function should continue searching for another Symbol file.
        The callback returns true if the Symbol file is valid, or false if the function should
        continue searching.

    CallerData - May be NULL. Data passed to the callback.

Return Value:

  The name of the .dbg file and a handle to that file.

--*/
{
    HANDLE fh = INVALID_HANDLE_VALUE;
    char *espath = NULL;
    char  dbgfile[MAX_PATH + 1];
    char  dirbuf[_MAX_DIR];
    char  fname[_MAX_FNAME + 1];
    char  extbuf[_MAX_EXT + 1];
    char *ext;
    char   token[MAX_PATH + 1];
    char  *next;
    DWORD  pass;
    char   dbgpath[MAX_PATH + 1];
    char   found[MAX_PATH + 1];
    DWORD  junkbuf;
    DWORD *imageSrc = &junkbuf;
    DWORD  err;
    BOOL   ssrv = true;
    PIMGHLP_DEBUG_DATA idd;
    PPROCESS_ENTRY pe = NULL;
    char sympath[MAX_PATH * 6];
    char drive[_MAX_DRIVE + 1];
    char dir[_MAX_DIR + 1];

    assert(DebugFilePath);

    CopyStrArray(sympath, (SymbolPath) ? SymbolPath : "");

    idd = (PIMGHLP_DEBUG_DATA)CallerData;
    if (idd && (idd->SizeOfStruct == sizeof(IMGHLP_DEBUG_DATA))) {
        pe = idd->pe;
        *drive = 0;
        *dir = 0;
        _splitpath(idd->ImageFilePath, drive, dir, NULL, NULL);
        if (*drive || *dir) {
            RemoveTrailingBackslash(dir);
            CatStrArray(sympath, ";");
            CatStrArray(sympath, drive);
            CatStrArray(sympath, dir);
        }
    }

    __try {
        *DebugFilePath = 0;
        *found = 0;

        // Step 1.  What do we have?
        _splitpath(FileName, NULL, dirbuf, fname, extbuf);

        if (!_stricmp(extbuf, ".dbg")) {
            // We got a filename of the form: ext\filename.dbg.  Dir holds the extension already.
            ext = dirbuf;
        } else {
            // Otherwise, skip the period and null out the Dir.
            ext = CharNext(extbuf);
        }

        // if we were passed no file extension, try to calculate it from the idd

        if (CallerData) {
            if (idd->SizeOfStruct == sizeof(IMGHLP_DEBUG_DATA)) {
                if (!*ext)  {
                    if (*idd->ImageFilePath) {
                        _splitpath(idd->ImageFilePath, NULL, NULL, NULL, extbuf);
                    } else if (*idd->ImageName) {
                        _splitpath(idd->ImageName, NULL, NULL, NULL, extbuf);
                    }
                    ext = CharNext(extbuf);
                }
                imageSrc = &idd->ImageSrc;
            } else
                idd = NULL;
        }

        espath = ExpandPath(sympath);
        if (!espath)
            return NULL;

        SetCriticalErrorMode();

        // okay, let's walk through the directories in the symbol path

        next = TokenFromSymbolPath(espath, token, MAX_PATH + 1);
        while (*token) {
            fh = INVALID_HANDLE_VALUE;
            for (pass = 0; pass < 3; pass++) {
                *dbgpath = 0;
                if (symsrvPath(token)) {
                    if (pass || !idd || !ssrv)
                        break;
                    *imageSrc = srcSymSrv;
                    CopyStrArray(dbgfile, fname);
                    CatStrArray(dbgfile, ".dbg");
                    err = symsrvGetFileMultiIndex(NULL,
                                                  token,
                                                  dbgfile,
                                                  idd->TimeDateStamp,
                                                  idd->DbgTimeDateStamp,
                                                  idd->SizeOfImage,
                                                  0,
                                                  dbgpath);
                    if (err == ERROR_NO_DATA)
                        ssrv = false;
                } else {
                    if (pass && !*ext)
                        break;
                    *imageSrc = srcSearchPath;
                    if (!CreateSymbolPath(pass, token, ext, fname, ".dbg", dbgpath, DIMA(dbgpath)))
                        break;
                }
                // try to open the file

                if (*dbgpath) {
                    if (!pass)
                        fh = CheckDirForDbgs(pe, dbgpath, found, DIMA(found), Callback, CallerData);
                    if (fh == INVALID_HANDLE_VALUE)
                        fh = OpenDbg(pe, dbgpath, found, DIMA(found), Callback, CallerData);
                    if (fh != INVALID_HANDLE_VALUE)
                        break;
                }
            }

            if (fh != INVALID_HANDLE_VALUE)
                break;

            next = TokenFromSymbolPath(next, token, MAX_PATH + 1);
        }

        MemFree(espath);

        // if mismatched dbgs are okay and if we found something earlier, then open it

        if (!option(SYMOPT_EXACT_SYMBOLS) || option(SYMOPT_LOAD_ANYTHING)) {
            if ((!fh || fh == INVALID_HANDLE_VALUE) && *found) {
                // try again without timestamp checking
                *imageSrc = srcSearchPath;
                CopyStrArray(dbgpath, found);
                fh = OpenDbg(pe, dbgpath, found, DIMA(found), NULL, NULL);
            }
        }

        ResetCriticalErrorMode();

        if (fh == INVALID_HANDLE_VALUE)
            fh = NULL;
        if (fh)
            strcpy(DebugFilePath, dbgpath);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        if (fh != INVALID_HANDLE_VALUE)
            CloseHandle(fh);
        fh = NULL;
    }

    return fh;
}


BOOL
GetImageNameFromMiscDebugData(
    IN  HANDLE FileHandle,
    IN  PVOID MappedBase,
    IN  PIMAGE_NT_HEADERS32 NtHeaders,
    IN  PIMAGE_DEBUG_DIRECTORY DebugDirectories,
    IN  ULONG NumberOfDebugDirectories,
    OUT LPSTR ImageFilePath
    )
{
    IMAGE_DEBUG_MISC TempMiscData;
    PIMAGE_DEBUG_MISC DebugMiscData;
    ULONG BytesToRead, BytesRead;
    BOOLEAN FoundImageName;
    LPSTR ImageName;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;

    while (NumberOfDebugDirectories) {
        if (DebugDirectories->Type == IMAGE_DEBUG_TYPE_MISC) {
            break;
        } else {
            DebugDirectories += 1;
            NumberOfDebugDirectories -= 1;
        }
    }

    if (NumberOfDebugDirectories == 0) {
        return false;
    }

    OptionalHeadersFromNtHeaders(NtHeaders, &OptionalHeader32, &OptionalHeader64);

    if ((OPTIONALHEADER(MajorLinkerVersion) < 3) &&
        (OPTIONALHEADER(MinorLinkerVersion) < 36) ) {
        BytesToRead = FIELD_OFFSET( IMAGE_DEBUG_MISC, Reserved );
    } else {
        BytesToRead = FIELD_OFFSET( IMAGE_DEBUG_MISC, Data );
    }

    DebugMiscData = NULL;
    FoundImageName = false;
    if (MappedBase == 0) {
        if (SetFilePointer( FileHandle,
                            DebugDirectories->PointerToRawData,
                            NULL,
                            FILE_BEGIN
                          ) == DebugDirectories->PointerToRawData
           ) {
            if (ReadFile( FileHandle,
                          &TempMiscData,
                          BytesToRead,
                          &BytesRead,
                          NULL
                        ) &&
                BytesRead == BytesToRead
               ) {
                DebugMiscData = &TempMiscData;
                if (DebugMiscData->DataType == IMAGE_DEBUG_MISC_EXENAME) {
                    BytesToRead = DebugMiscData->Length - BytesToRead;
                    BytesToRead = BytesToRead > MAX_PATH ? MAX_PATH : BytesToRead;
                    if (ReadFile( FileHandle,
                                  ImageFilePath,
                                  BytesToRead,
                                  &BytesRead,
                                  NULL
                                ) &&
                        BytesRead == BytesToRead
                       ) {
                            FoundImageName = true;
                    }
                }
            }
        }
    } else {
        DebugMiscData = (PIMAGE_DEBUG_MISC)((PCHAR)MappedBase +
                                            DebugDirectories->PointerToRawData );
        if (DebugMiscData->DataType == IMAGE_DEBUG_MISC_EXENAME) {
            ImageName = (PCHAR)DebugMiscData + BytesToRead;
            BytesToRead = DebugMiscData->Length - BytesToRead;
            BytesToRead = BytesToRead > MAX_PATH ? MAX_PATH : BytesToRead;
            if (*ImageName != '\0' ) {
                memcpy( ImageFilePath, ImageName, BytesToRead );
                FoundImageName = true;
            }
        }
    }

    return FoundImageName;
}



#define MAX_DEPTH 32

BOOL
IMAGEAPI
EnumDirTree(
    HANDLE hProcess,
    PSTR   RootPath,
    PSTR   InputPathName,
    PSTR   OutputPathBuffer,
    PENUMDIRTREE_CALLBACK Callback,
    PVOID  CallbackData
    )
{
    // UnSafe...

    PCHAR FileName;
    PUCHAR Prefix = (PUCHAR) "";
    CHAR PathBuffer[ MAX_PATH+1 ];
    ULONG Depth;
    PCHAR PathTail[ MAX_DEPTH ];
    PCHAR FindHandle[ MAX_DEPTH ];
    LPWIN32_FIND_DATA FindFileData;
    UCHAR FindFileBuffer[ MAX_PATH + sizeof( WIN32_FIND_DATA ) ];
    BOOL Result;
    DWORD len;
    PPROCESS_ENTRY pe;

    SetCriticalErrorMode();;

    pe = FindProcessEntry(hProcess);

    if (!CopyStrArray(PathBuffer, RootPath))
        return false;
    FileName = InputPathName;
    while (*InputPathName) {
        if (*InputPathName == ':' || *InputPathName == '\\' || *InputPathName == '/') {
            FileName = ++InputPathName;
        } else {
            InputPathName = CharNext(InputPathName);
        }
    }
    FindFileData = (LPWIN32_FIND_DATA)FindFileBuffer;
    Depth = 0;
    Result = false;
    while (true) {
startDirectorySearch:
        PathTail[ Depth ] = strchr( PathBuffer, '\0' );
        len = DIMA(PathBuffer)
              - (DWORD)((DWORD_PTR)PathTail[ Depth ] - (DWORD_PTR)PathBuffer);
        if (PathTail[ Depth ] > PathBuffer
            && *CharPrev(PathBuffer, PathTail[ Depth ]) != '\\') {
            *(PathTail[ Depth ])++ = '\\';
        }

        CopyString( PathTail[ Depth ], "*.*", len );
        FindHandle[ Depth ] = (PCHAR) FindFirstFile( PathBuffer, FindFileData );
        if (GetLastError() == ERROR_NOT_READY) {
            pprint(pe, "%s - drive not ready\n", PathBuffer);
            break;
        }
        if (FindHandle[ Depth ] == INVALID_HANDLE_VALUE) {
            goto nextDirectory;
        }

        do {
            if (FindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (strcmp( FindFileData->cFileName, "." ) &&
                    strcmp( FindFileData->cFileName, ".." ) &&
                    Depth < MAX_DEPTH
                   ) {
                        CopyString(PathTail[ Depth ], FindFileData->cFileName, len);
                        CatString(PathTail[ Depth ], "\\", len);

                        Depth++;
                        goto startDirectorySearch;
                }
            } else
            if (!_stricmp( FindFileData->cFileName, FileName )) {
                CopyString( PathTail[ Depth ], FindFileData->cFileName, len );
                if (OutputPathBuffer)
                    strcpy( OutputPathBuffer, PathBuffer );   // SECURITY: Don't know size of target buffer.
                if (Callback != NULL) {
                    Result = Callback((LPCSTR)PathBuffer, CallbackData);
                } else {
                    Result = true;
                }
            }

restartDirectorySearch:
            if (Result)
                break;
            // poll for ctrl-c
            if (DoCallback(pe, CBA_DEFERRED_SYMBOL_LOAD_CANCEL, NULL))
                break;
        }
        while (FindNextFile( FindHandle[ Depth ], FindFileData ));
        FindClose( FindHandle[ Depth ] );

nextDirectory:
        if (Depth == 0) {
            break;
        }

        Depth--;
        goto restartDirectorySearch;
    }

    ResetCriticalErrorMode();

    return Result;
}

BOOL
IMAGEAPI
SearchTreeForFile(
    LPSTR RootPath,
    LPSTR InputPathName,
    LPSTR OutputPathBuffer
    )
{
    return EnumDirTree(INVALID_HANDLE_VALUE, RootPath, InputPathName, OutputPathBuffer, NULL, NULL);
}


BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    LPCSTR DirPath
    )
{
    LPSTR p, DirCopy;
    DWORD len;
    DWORD dw;

    // Make a copy of the string for editing.

    __try {
        len = strlen(DirPath) + 1;
        DirCopy = (LPSTR) MemAlloc(len);

        if (!DirCopy) {
            return false;
        }

        CopyString(DirCopy, DirPath, len);

        p = DirCopy;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == '\\') && (*(p+1) == '\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != '\\') {
                p = CharNext(p);
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != '\\') {
                p = CharNext(p);
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*(p+1) == ':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == '\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = '\0';
                dw = fnGetFileAttributes(DirCopy);
                // Nothing exists with this name.  Try to make the directory name and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectory(DirCopy,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            MemFree(DirCopy);
                            return false;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, but it's not a directory... Error
                        MemFree(DirCopy);
                        return false;
                    }
                }

                *p = '\\';
            }
            p = CharNext(p);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        MemFree(DirCopy);
        return(false);
    }

    MemFree(DirCopy);
    return true;
}

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
    )
{
    //
    // don't tell old apps about the new version.  It will
    // just scare them.
    //
    return &g.AppVersion;
}

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    LPAPI_VERSION av
    )
{
    __try {
        g.AppVersion = *av;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    if (g.AppVersion.Revision < 6) {
        //
        // For older debuggers, just tell them what they want to hear.
        //
        g.ApiVersion = g.AppVersion;
    }
    return &g.ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\symmod.c ===
/*
 * symmod.c
 */

#include <private.h>
#include <symbols.h>
#include <globals.h>
#include <psapi.h>

// this struct is used to initilaize the module data array for a new module

static MODULE_DATA gmd[NUM_MODULE_DATA_ENTRIES] =
{
    {mdHeader,                       dsNone, dsNone, false, NULL},
    {mdSecHdrs,                      dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_UNKNOWN,       dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_COFF,          dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_CODEVIEW,      dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_FPO,           dsNone, dsNone, false, NULL},  // true,  mdfnGetExecutableImage},
    {IMAGE_DEBUG_TYPE_MISC,          dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_EXCEPTION,     dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_FIXUP,         dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_OMAP_TO_SRC,   dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_OMAP_FROM_SRC, dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_BORLAND,       dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_RESERVED10,    dsNone, dsNone, false, NULL},
    {IMAGE_DEBUG_TYPE_CLSID,         dsNone, dsNone, false, NULL}
};

// prototypes - move them later

BOOL
modload(
    IN  HANDLE          hProcess,
    IN  PMODULE_ENTRY   mi
    );

BOOL
idd2mi(
    PPROCESS_ENTRY     pe,
    PIMGHLP_DEBUG_DATA idd,
    PMODULE_ENTRY      mi
    );

BOOL
imgReadLoaded(
    PIMGHLP_DEBUG_DATA idd
    );

BOOL
imgReadFromDisk(
    PIMGHLP_DEBUG_DATA idd
    );

BOOL
ReadHeader(
    PIMGHLP_DEBUG_DATA idd,
    DWORD datasrc
    );

BOOL
ReadCallerData(
    PIMGHLP_DEBUG_DATA idd
    );

BOOL
cbFindExe(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

BOOL
cbFindDbg(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

BOOL
ProcessCvForOmap(
    PIMGHLP_DEBUG_DATA idd
    );

void
RetrievePdbInfo(
    PIMGHLP_DEBUG_DATA idd
    );

DWORD
imgset(
    PMODULE_DATA md,
    DWORD        id,
    DWORD        hint,
    DWORD        src
    );

BOOL
FakePdbName(
    PIMGHLP_DEBUG_DATA idd
    );

// inline functions

__inline
DWORD
SectionContains (
    HANDLE hp,
    PIMAGE_SECTION_HEADER pSH,
    PIMAGE_DATA_DIRECTORY ddir
    );

// here's the real code


BOOL
LoadSymbols(
    HANDLE        hp,
    PMODULE_ENTRY mi,
    DWORD         flags
    )
{
    BOOL rc;

    if (flags & LS_JUST_TEST) {
        if ((mi->Flags & MIF_DEFERRED_LOAD) && !(mi->Flags & MIF_NO_SYMBOLS))
            return false;
        else
            return true;
    }

    if (flags & LS_QUALIFIED) {
        if (option(SYMOPT_NO_UNQUALIFIED_LOADS)) {
            if ((mi->Flags & MIF_DEFERRED_LOAD) && !(mi->Flags & MIF_NO_SYMBOLS))
                return false;
        }
    }

    if ((mi->Flags & MIF_DEFERRED_LOAD) && !(mi->Flags & MIF_NO_SYMBOLS)) {
        rc = modload(hp, mi);
        if (rc)
            rc = mi->SymType != SymNone;
        return rc;
    } else if (flags & LS_FAIL_IF_LOADED)
        return false;

    return true;
}


// This function exists just to be called by MapDebugInfo legacy code.

PIMGHLP_DEBUG_DATA
GetIDD(
    HANDLE        hFile,
    LPSTR         FileName,
    LPSTR         SymbolPath,
    ULONG64       ImageBase,
    DWORD         dwFlags
    )
{
    PIMGHLP_DEBUG_DATA          idd;
    BOOL                        rc = true;

    SetLastError(NO_ERROR);

    idd = InitIDD(0,
                  hFile,
                  FileName,
                  SymbolPath,
                  ImageBase,
                  0,
                  NULL,
                  0,
                  dwFlags);

    if (!idd)
        return NULL;

    rc = imgReadLoaded(idd);
    if (idd->error) {
        SetLastError(idd->error);
        goto error;
    }

    if (!rc)
        rc = imgReadFromDisk(idd);
    if (idd->error) {
        SetLastError(idd->error);
        goto error;
    }

    if (rc)
        rc = GetDebugData(idd);

    if (rc)
        return idd;

error:
    ReleaseDebugData(idd, IMGHLP_FREE_FPO | IMGHLP_FREE_SYMPATH | IMGHLP_FREE_PDATA | IMGHLP_FREE_XDATA);
    return NULL;
}


BOOL
modload(
    IN  HANDLE          hp,
    IN  PMODULE_ENTRY   mi
    )
{
    IMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PPROCESS_ENTRY              pe;
    ULONG                       i;
    PIMGHLP_DEBUG_DATA          idd;
    ULONG                       bias;
    PIMAGE_SYMBOL               lpSymbolEntry;
    PUCHAR                      lpStringTable;
    PUCHAR                      p;
    BOOL                        SymbolsLoaded = false;
    PCHAR                       CallbackFileName, ImageName;
    ULONG                       Size;
    DWORD                       cba;
    BOOL                        bFixLoadFailure;
    BOOL                        bFixPartialLoad;
    BOOL                        rc = true;

    g.LastSymLoadError = SYMLOAD_DEFERRED;
    SetLastError(NO_ERROR);

    pe = FindProcessEntry(hp);
    if (!pe) {
        SetLastError(ERROR_INVALID_HANDLE);
        return false;
    }

#ifdef DEBUG
    if (traceSubName(mi->ModuleName)) // for setting debug breakpoints from DBGHELP_TOKEN
        dtrace("debug(%s)\n", mi->ModuleName);
#endif

    if (mi->SymType == SymNone)
        return error(ERROR_MOD_NOT_FOUND);

    CallbackFileName = mi->LoadedImageName ? mi->LoadedImageName :
                       mi->ImageName ? mi->ImageName : mi->ModuleName;

    if (DoSymbolCallback(pe,
                         CBA_DEFERRED_SYMBOL_LOAD_CANCEL,
                         mi,
                         &idsl,
                         CallbackFileName))
    {
        pprint(pe, "Symbol loading cancelled\n");
        return error(ERROR_CANCELLED);
    }

    DoSymbolCallback(pe,
                     CBA_DEFERRED_SYMBOL_LOAD_START,
                     mi,
                     &idsl,
                     CallbackFileName);

    ImageName = mi->ImageName;
    bFixLoadFailure = false;
    bFixPartialLoad = false;

load:

    idd = InitIDD(
        hp,
        mi->hFile,
        ImageName,
        pe->SymbolSearchPath,
        mi->BaseOfDll,
        mi->DllSize,
        &mi->mld,
        mi->CallerFlags,
        0);

    if (!idd)
        return false;

    // First, try to load the image from the usual sources.  If we fail,
    // allow the caller to fix up the image information and try again.

    rc = imgReadLoaded(idd);
    if (!rc && !bFixPartialLoad) {
        bFixPartialLoad = true;
        if (DoSymbolCallback(pe,
                             CBA_DEFERRED_SYMBOL_LOAD_PARTIAL,
                             mi,
                             &idsl,
                             CallbackFileName)
            && idsl.Reparse)
        {
            ImageName = idsl.FileName;
            mi->hFile = idsl.hFile;
            CallbackFileName = idsl.FileName;
            ReleaseDebugData(idd, IMGHLP_FREE_FPO | IMGHLP_FREE_SYMPATH | IMGHLP_FREE_PDATA | IMGHLP_FREE_XDATA);
            goto load;
        }
    }

    // get info from the caller's data struct

    if (!rc)
        rc = ReadCallerData(idd);

    // Okay.  Let's try some of the less reliable methods, like searching
    // for images on disk, etc.

    if (!rc)
        rc = imgReadFromDisk(idd);

    // Load the symbolic information into temp storage.

    if (rc)
        rc = GetDebugData(idd);

    mi->SymLoadError = g.LastSymLoadError;
    if (idd->error)
        SetLastError(idd->error);

    // Load the debug info into the module info struct.

    __try {

        EnterCriticalSection(&g.threadlock);

        if (rc && (rc = idd2mi(pe, idd, mi))) {
            DoSymbolCallback(pe,
                             CBA_DEFERRED_SYMBOL_LOAD_COMPLETE,
                             mi,
                             &idsl,
                             CallbackFileName);
        }

    } __finally  {
        ReleaseDebugData(idd, IMGHLP_FREE_STANDARD);
        LeaveCriticalSection(&g.threadlock);
    }

    // If at this point, we have failed.  Let's tell the caller.
    // Try again, if it indicates we should.  Otherwise, let's fail.

    if (!rc && !bFixLoadFailure) {
        bFixLoadFailure = true;
        if (DoSymbolCallback(pe,
                             CBA_DEFERRED_SYMBOL_LOAD_FAILURE,
                             mi,
                             &idsl,
                             CallbackFileName)
            && idsl.Reparse)
        {
            ImageName = idsl.FileName;
            mi->hFile = idsl.hFile;
            CallbackFileName = idsl.FileName;
            goto load;
        }

        mi->SymType = SymNone;
        mi->Flags |= MIF_NO_SYMBOLS;
        rc = false;
    }

    // SymbolStatus function is expensive - call only if needed.
    if (option(SYMOPT_DEBUG)) {
        pprint(pe, "%s - %s\n",
               *mi->AliasName ? mi->AliasName : mi->ModuleName,
               SymbolStatus(mi, 9));
    }

    return rc;
}


DWORD64
LoadModule(
    IN  HANDLE          hp,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize,
    IN  HANDLE          hFile,
    IN  PMODLOAD_DATA   data,
    IN  DWORD           flags
    )
{
    IMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PPROCESS_ENTRY                  pe;
    PMODULE_ENTRY                   mi;
    LPSTR                           p;
    DWORD64                         ip;

#ifdef DEBUG
    if (traceSubName(ImageName)) // for setting debug breakpoints from DBGHELP_TOKEN
        dtrace("debug(%s)\n", ImageName);
#endif

    if (BaseOfDll == (DWORD64)-1)
        return 0;

    __try {
        CHAR c;
        if (ImageName)
            c = *ImageName;
        if (ModuleName)
            c = *ModuleName;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return error(ERROR_INVALID_PARAMETER);
    }

    // It is illegal to load pdb symbols without info to set the base address

    if (IsPdb(ImageName) && !BaseOfDll)
        return error(ERROR_INVALID_PARAMETER);

    // start loading

    pe = FindProcessEntry(hp);
    if (!pe) {
        return 0;
    }

    if (BaseOfDll)
        mi = GetModuleForPC(pe, BaseOfDll, true);
    else
        mi = NULL;

    if (mi) {
        //
        // in this case the symbols are already loaded
        // so the caller really wants the deferred
        // symbols to be loaded
        //
        if ((mi->Flags & MIF_DEFERRED_LOAD) &&  modload(hp, mi))
            return mi->BaseOfDll;
        else
            return 0;
    }

    //
    // look to see if there is an overlapping module entry
    //
    if (BaseOfDll) {
        do {
            mi = GetModuleForPC(pe, BaseOfDll, false);
            if (mi) {
                RemoveEntryList(&mi->ListEntry);

                DoSymbolCallback(
                    pe,
                    CBA_SYMBOLS_UNLOADED,
                    mi,
                    &idsl,
                    mi->LoadedImageName ? mi->LoadedImageName : mi->ImageName ? mi->ImageName : mi->ModuleName
                    );

                FreeModuleEntry(pe, mi);
            }
        } while(mi);
    }

    mi = (PMODULE_ENTRY)MemAlloc(sizeof(MODULE_ENTRY));
    if (!mi)
        return 0;

    InitModuleEntry(mi);

    mi->BaseOfDll = BaseOfDll;
    mi->DllSize = DllSize;
    mi->hFile = hFile;
    if (ImageName) {
        char SplitMod[_MAX_FNAME];

        mi->ImageName = StringDup(ImageName);
        _splitpath( ImageName, NULL, NULL, SplitMod, NULL );
        mi->ModuleName[0] = 0;
        CatString(mi->ModuleName, SplitMod, sizeof(mi->ModuleName));
        if (ModuleName && _stricmp( ModuleName, mi->ModuleName ) != 0) {
            mi->AliasName[0] = 0;
            CatString(mi->AliasName, ModuleName, sizeof(mi->AliasName));
        } else {
            mi->AliasName[0] = 0;
        }
    } else {
        if (ModuleName) {
            mi->AliasName[0] = 0;
            CatString( mi->AliasName, ModuleName, sizeof(mi->AliasName));
        }
    }
    mi->mod = NULL;
    mi->cbPdbSymbols = 0;
    mi->pPdbSymbols = NULL;

    mi->CallerFlags = flags;

    if (data) {
        if (data->ssize != sizeof(MODLOAD_DATA)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }
        memcpy(&mi->mld, data, data->ssize);
        mi->CallerData = MemAlloc(mi->mld.size);
        if (!mi->CallerData) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0;
        }
        mi->mld.data = mi->CallerData;
        memcpy(mi->mld.data, data->data, mi->mld.size);
    }

    if (option(SYMOPT_DEFERRED_LOADS) && BaseOfDll) {
        mi->Flags |= MIF_DEFERRED_LOAD;
        mi->SymType = SymDeferred;
    } else if (!modload( hp, mi )) {
        FreeModuleEntry(pe, mi);
        return 0;
    }

    InsertTailList( &pe->ModuleList, &mi->ListEntry);

    ip = GetIP(pe);
    if ((mi->BaseOfDll <= ip) && (mi->BaseOfDll + DllSize >= ip))
        diaSetModFromIP(pe);

#if 0
    SrcSrvLoadModule(hp,
                     (*mi->AliasName) ? mi->AliasName : mi->ModuleName,
                     mi->BaseOfDll,
                     mi->stSrcSrv,
                     mi->cbSrcSrv);
#else
//  char sz[MAX_PATH];
//  SymGetSourceFile(pe->hProcess, mi->BaseOfDll, "d:\\db\\symsrv\\symstore\\symstore.cpp", sz);
#endif

    return mi->BaseOfDll;
}


BOOL
GetModule(
    HANDLE  hp,
    LPSTR   ModuleName,
    DWORD64 ImageBase,
    DWORD   ImageSize,
    PVOID   Context
    )
{
    LoadModule(
            hp,
            ModuleName,
            NULL,
            ImageBase,
            ImageSize,
            NULL,
            0,
            NULL
            );

    return true;
}


BOOL
idd2mi(
    PPROCESS_ENTRY     pe,
    PIMGHLP_DEBUG_DATA idd,
    PMODULE_ENTRY      mi
    )
{
    ULONG i;

    idd->flags = mi->Flags;

    // The following code ONLY works if the dll wasn't rebased
    // during install.  Is it really useful?

    if (!mi->BaseOfDll) {
        //
        // This case occurs when modules are loaded multiple times by
        // name with no explicit base address.
        //
        if (GetModuleForPC( pe, idd->ImageBaseFromImage, true )) {
            if (idd->ImageBaseFromImage) {
                pprint(pe, "GetModuleForPC(%p, %I64x, true) failed\n",
                    pe,
                    idd->ImageBaseFromImage,
                    true
                    );
            } else {
                pprint(pe, "No base address for %s:  Please specify\n", mi->ImageName);
            }
            diaRelease(idd->dia);
            return false;
        }
        mi->BaseOfDll    = idd->ImageBaseFromImage;
    }

    if (!mi->DllSize) {
        mi->DllSize      = idd->SizeOfImage;
    }

    mi->hProcess         = idd->hProcess;
    mi->InProcImageBase  = idd->InProcImageBase;

    mi->CheckSum         = idd->CheckSum;
    mi->TimeDateStamp    = idd->TimeDateStamp;
    mi->MachineType      = idd->Machine;

    mi->ImageType        = idd->ImageType;
    mi->PdbSrc           = idd->PdbSrc;
    mi->ImageSrc         = idd->ImageSrc;

    if (!mi->MachineType && g.MachineType) {
        mi->MachineType = (USHORT) g.MachineType;
    }
    if (idd->dia) {
        mi->LoadedPdbName = StringDup(idd->PdbFileName);
        if (!mi->LoadedPdbName)
            return false;
    }
    if (idd->DbgFileMap) {
        mi->LoadedImageName = StringDup(idd->DbgFilePath);
    } else if (*idd->ImageFilePath) {
        mi->LoadedImageName = StringDup(idd->ImageFilePath);
    } else if (idd->dia) {
        mi->LoadedImageName = StringDup(idd->PdbFileName);
    } else {
        mi->LoadedImageName = StringDup("");
    }
    if (!mi->LoadedImageName)
        return false;

    if (idd->fROM) {
        mi->Flags |= MIF_ROM_IMAGE;
    }

    if (!mi->ImageName) {
        mi->ImageName = StringDup(idd->OriginalImageFileName);
        if (!mi->ImageName)
            return false;
        _splitpath( mi->ImageName, NULL, NULL, mi->ModuleName, NULL );
        if (*mi->ImageName)
            mi->AliasName[0] = 0;
    }

    mi->dsExceptions = idd->dsExceptions;

    if (idd->cFpo) {
        //
        // use virtualalloc() because the rtf search function
        // return a pointer into this memory.  we want to make
        // all of this memory read only so that callers cannot
        // stomp on imagehlp's data
        //
        mi->pFpoData = (PFPO_DATA)VirtualAlloc(
            NULL,
            sizeof(FPO_DATA) * idd->cFpo,
            MEM_COMMIT,
            PAGE_READWRITE
            );
        if (mi->pFpoData) {
            mi->dwEntries = idd->cFpo;
            CopyMemory(
                mi->pFpoData,
                idd->pFpo,
                sizeof(FPO_DATA) * mi->dwEntries
                );
            VirtualProtect(
                mi->pFpoData,
                sizeof(FPO_DATA) * mi->dwEntries,
                PAGE_READONLY,
                &i
                );
        }
    }

    // copy the pdata block from the pdb

    if (idd->pPData) {
        mi->pPData = MemAlloc(idd->cbPData);
        if (mi->pPData) {
            mi->cPData = idd->cPData;
            mi->cbPData = idd->cbPData;
            CopyMemory(mi->pPData, idd->pPData, idd->cbPData);
        }
    }

    if (idd->pXData) {
        mi->pXData = MemAlloc(idd->cbXData);
        if (mi->pXData) {
            mi->cXData = idd->cXData;
            mi->cbXData = idd->cbXData;
            CopyMemory(mi->pXData, idd->pXData, idd->cbXData);
        }
    }

    // now the sections

    mi->NumSections = idd->cCurrentSections;
    if (idd->fCurrentSectionsMapped) {
        mi->SectionHdrs = (PIMAGE_SECTION_HEADER) MemAlloc(
            sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
            );
        if (mi->SectionHdrs) {
            CopyMemory(
                mi->SectionHdrs,
                idd->pCurrentSections,
                sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
                );
        }
    } else {
        mi->SectionHdrs = idd->pCurrentSections;
    }

    if (idd->pOriginalSections) {
        mi->OriginalNumSections = idd->cOriginalSections;
        mi->OriginalSectionHdrs = idd->pOriginalSections;
    } else {
        mi->OriginalNumSections = mi->NumSections;
        mi->OriginalSectionHdrs = (PIMAGE_SECTION_HEADER) MemAlloc(
            sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
            );
        if (mi->OriginalSectionHdrs) {
            CopyMemory(
                mi->OriginalSectionHdrs,
                idd->pCurrentSections,
                sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
                );
        }
    }

    // symbols

    mi->TmpSym.Name = (LPSTR) MemAlloc( TMP_SYM_LEN );
    mi->vsTmpSym.Name = (LPSTR) MemAlloc( TMP_SYM_LEN );

    if (idd->dia) {
        mi->SymType = SymPdb;
        mi->lSymType = SymPdb;
        mi->loaded = true;
    } else {
        if (idd->pMappedCv) {
            mi->loaded = LoadCodeViewSymbols(
                mi->hProcess,
                mi,
                idd
                );
        }
        if (!mi->loaded && idd->pMappedCoff) {
            mi->loaded = LoadCoffSymbols(mi->hProcess, mi, idd);
        }

        if (!mi->loaded && idd->cExports) {
            mi->loaded = LoadExportSymbols( mi, idd );
            if (mi->loaded) {
                mi->PdbSrc = srcNone;
            }
        }
        if (idd->ImageType == dsVirtual) {
            mi->SymType = SymVirtual;
            mi->loaded = true;
        }

        mi->lSymType = mi->SymType;
        if (!mi->loaded) {
            mi->SymType = SymNone;
            if (mi->lSymType == SymDeferred)
                mi->lSymType = SymNone;
        }
    }

    mi->dia = idd->dia;
    mi->pdbdataSig = idd->pdbdataSig;
    mi->pdbdataAge = idd->pdbdataAge;
    memcpy(&mi->pdbdataGuid, &idd->pdbdataGuid, sizeof(GUID));
    if (idd->pMappedCv) {
        PSTR pszPdb;
        ULONG cbLeft;
        memcpy(&mi->CVRec, idd->pMappedCv, sizeof(mi->CVRec.dwSig));
        mi->cvSig = mi->CVRec.dwSig;
        
        if (mi->cvSig == NB10_SIG)
        {
            memcpy(&mi->CVRec, idd->pMappedCv, sizeof(mi->CVRec.nb10ih));
            pszPdb = (PSTR) &mi->CVRec + sizeof(mi->CVRec.nb10ih);
            cbLeft = sizeof(mi->CVRec) - sizeof(mi->CVRec.nb10ih);
            CopyString(pszPdb, (PSTR) idd->pMappedCv + sizeof(mi->CVRec.nb10ih), cbLeft);
        } else
        {
            memcpy(&mi->CVRec, idd->pMappedCv, sizeof(mi->CVRec.rsdsih));
            pszPdb = (PSTR) &mi->CVRec + sizeof(mi->CVRec.rsdsih);
            cbLeft = sizeof(mi->CVRec) - sizeof(mi->CVRec.rsdsih);
            CopyString(pszPdb, (PSTR) idd->pMappedCv + sizeof(mi->CVRec.rsdsih), cbLeft);
        }
    }
    mi->fTypes = idd->fTypes;
    mi->fLines = idd->fLines;
    mi->fSymbols = idd->fSymbols;
    mi->fTypes = idd->fTypes;
    mi->fPdbUnmatched = idd->fPdbUnmatched;
    mi->fDbgUnmatched = idd->fDbgUnmatched;

    ProcessOmapForModule( mi, idd );

    mi->Flags &= ~MIF_DEFERRED_LOAD;

    return true;
}


PIMGHLP_DEBUG_DATA
InitIDD(
    HANDLE        hProcess,
    HANDLE        FileHandle,
    LPSTR         FileName,
    LPSTR         SymbolPath,
    ULONG64       ImageBase,
    DWORD         SizeOfImage,
    PMODLOAD_DATA mld,
    DWORD         CallerFlags,
    ULONG         dwFlags
    )
{
    PIMGHLP_DEBUG_DATA idd;
    int len;

#ifdef DEBUG
    if (traceSubName(FileName)) // for setting debug breakpoints from DBGHELP_TOKEN
        dtrace("debug(%s)\n", FileName);
#endif

    // No File handle and   no file name.  Bail

    if (!(CallerFlags & SLMFLAG_VIRTUAL)) {
        if (!FileHandle && (!FileName || !*FileName))
            return NULL;
    }

    SetLastError(NO_ERROR);

    idd = (PIMGHLP_DEBUG_DATA)MemAlloc(sizeof(IMGHLP_DEBUG_DATA));
    if (!idd) {
        SetLastError(ERROR_OUTOFMEMORY);
        g.LastSymLoadError = SYMLOAD_OUTOFMEMORY;
        return NULL;
    }

    ZeroMemory(idd, sizeof(IMGHLP_DEBUG_DATA));

    idd->SizeOfStruct = sizeof(IMGHLP_DEBUG_DATA);
    idd->md = (PMODULE_DATA)MemAlloc(sizeof(gmd));
    if (!idd->md) {
        SetLastError(ERROR_OUTOFMEMORY);
        g.LastSymLoadError = SYMLOAD_OUTOFMEMORY;
        MemFree(idd);
        return NULL;
    }
    memcpy(idd->md, gmd, sizeof(gmd));

    // store off parameters

    idd->pe = FindProcessEntry(hProcess);
    idd->flags = dwFlags;
    idd->ImageFileHandle = FileHandle;
    idd->SizeOfImage = SizeOfImage;
    idd->CallerFlags = CallerFlags;
    if (FileName)
        CopyStrArray(idd->ImageFilePath, FileName);

    __try {

        idd->InProcImageBase = ImageBase;
        idd->hProcess = hProcess;
        idd->mld = mld;

        if (FileName)
            CopyStrArray(idd->ImageName, FileName);

        if (SymbolPath) {
            len = strlen(SymbolPath) + 1;
            idd->SymbolPath = (PCHAR)MemAlloc(len);
            if (idd->SymbolPath)
                CopyString(idd->SymbolPath, SymbolPath, len);
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        if (idd) {
            ReleaseDebugData(idd, IMGHLP_FREE_ALL);
            idd = NULL;
        }
    }

    return idd;
}


typedef BOOL (WINAPI *PENUMPROCESSMODULES)(HANDLE, HMODULE *, DWORD, LPDWORD);
typedef DWORD (WINAPI *PGETMODULEFILENAMEEXA)(HANDLE, HMODULE, LPSTR, DWORD);
typedef BOOL (WINAPI *PGETMODULEINFORMATION)(HANDLE, HMODULE, LPMODULEINFO, DWORD);

BOOL GetFileNameFromBase(HANDLE hp, ULONG64 base, char *name, DWORD cbname)
{
    HMODULE hmods[1024];
    DWORD cb;
    unsigned int i;
    char modname[MAX_PATH];
    MODULEINFO mi;
    static PENUMPROCESSMODULES fnEnumProcessModules = NULL;
    static PGETMODULEFILENAMEEXA fnGetModuleFileNameEx = NULL;
    static PGETMODULEINFORMATION fnGetModuleInformation = NULL;

    if (!hp || hp == INVALID_HANDLE_VALUE || !base || !name || !cbname)
        return false;

    // Get the functions from psapi...

    if (fnEnumProcessModules == (PENUMPROCESSMODULES)-1)
        return false;

    if (!fnEnumProcessModules) {
        HMODULE hmod = LoadLibrary("psapi.dll");
        if (!hmod || hmod == INVALID_HANDLE_VALUE) {
            fnEnumProcessModules = (PENUMPROCESSMODULES)-1;
            return false;
        }
        fnEnumProcessModules = (PENUMPROCESSMODULES)GetProcAddress(hmod, "EnumProcessModules");
        if (!fnEnumProcessModules) {
            fnEnumProcessModules = (PENUMPROCESSMODULES)-1;
            return false;
        }
        fnGetModuleFileNameEx = (PGETMODULEFILENAMEEXA)GetProcAddress(hmod, "GetModuleFileNameExA");
        if (!fnGetModuleFileNameEx) {
            fnGetModuleFileNameEx = (PGETMODULEFILENAMEEXA)-1;
            return false;
        }
        fnGetModuleInformation = (PGETMODULEINFORMATION)GetProcAddress(hmod, "GetModuleInformation");
        if (!fnGetModuleInformation) {
            fnGetModuleInformation = (PGETMODULEINFORMATION)-1;
            return false;
        }
    }
    
    // Get a list of all the modules in this process
    // and the full path to each.

    if(fnEnumProcessModules(hp, hmods, sizeof(hmods), &cb))
    {
        for (i = 0; i < (cb / sizeof(HMODULE)); i++) {
            if (!fnGetModuleFileNameEx(hp, hmods[i], modname, sizeof(modname)))
                continue;
            if (!fnGetModuleInformation(hp, hmods[i], &mi, sizeof(mi)))
                continue;
            if ((ULONG64)mi.lpBaseOfDll != base)
                continue;
            CopyString(name, modname, cbname);
            return true;
        }
    }

    return false;
}


BOOL
imgReadLoaded(
    PIMGHLP_DEBUG_DATA idd
    )
{
#ifdef DEBUG
    if (traceSubName(idd->ImageFilePath)) // for setting debug breakpoints from DBGHELP_TOKEN
        dtrace("debug(%s)\n", idd->ImageFilePath);
#endif

    __try {

        // if this is a virtual module, we're done

        if (idd->CallerFlags & SLMFLAG_VIRTUAL) {
            idd->ImageType = dsVirtual;
            return true;
        }

        // if we were passed a file handle, use it

        if (idd->ImageFileHandle) {
            HANDLE fh;
            if (!DuplicateHandle(GetCurrentProcess(),
                                 idd->ImageFileHandle,
                                 GetCurrentProcess(),
                                 &fh,
                                 GENERIC_READ,
                                 false,
                                 DUPLICATE_SAME_ACCESS
                                ))
            {
                return false;
            }
            
            GetFileNameFromBase(idd->hProcess, idd->InProcImageBase, idd->ImageFilePath, sizeof(idd->ImageFilePath));

            idd->ImageFileHandle = fh;
            idd->ImageSrc = srcHandle;
            if (ReadHeader(idd, dsImage))
                return true;
        }

        // if we have a base pointer into process memory.  See what we can get here.

        if (idd->InProcImageBase) {
            if (ReadHeader(idd, dsInProc)) {
                idd->ImageSrc = srcMemory;
                return true;
            }
        }

        return false;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return false;
    }

    return true;
}


BOOL
imgReadFromDisk(
    PIMGHLP_DEBUG_DATA idd
    )
/*
   Given:
     ImageFileHandle - Map the thing.  The only time FileHandle s/b non-null
                       is if we're given an image handle.  If this is not
                       true, ignore the handle.
    !ImageFileHandle - Use the filename and search for first the image name,
                       then the .dbg file, and finally a .pdb file.

    dwFlags:           NO_PE64_IMAGES - Return failure if only image is PE64.
                                        Used to implement MapDebugInformation()

*/
{
    int len;

    // If the file name is a pdb, let's just store it and move on.

    if (IsPdb(idd->ImageFilePath)) {
        CopyStrArray(idd->PdbFileName, idd->ImageFilePath);
        return true;
    }

    // Let's look for the image on disk.

    if (!option(SYMOPT_NO_IMAGE_SEARCH)) {
        // otherwise use the file name to open the disk image
        // only if we didn't have access to in-proc headers
        pprint(idd->pe, "No header for %s.  Searching for image on disk\n", idd->ImageName);
        idd->ImageFileHandle = FindExecutableImageEx(idd->ImageName,
                                                      idd->SymbolPath,
                                                      idd->ImageFilePath,
                                                      cbFindExe,
                                                      idd);
        if (idd->ImageFileHandle) {
            if (!idd->SizeOfImage) 
                GetFileSize(idd->ImageFileHandle, &idd->SizeOfImage);
            ReadHeader(idd, dsImage);
        }
    }

    return true;
}


BOOL
NoSymbols(
    PIMGHLP_DEBUG_DATA idd
    )
{
    return (!*idd->PdbFileName && !idd->pMappedCoff && !idd->pMappedCv);
}


BOOL
GetDebugData(
    PIMGHLP_DEBUG_DATA idd
    )
{
    char dbgfile[MAX_PATH + 1];
    BOOL rc;

    // If this is a virtual module, we are done.

    if (idd->ImageType == dsVirtual)
        return true;

    *dbgfile = 0;

    // Now we look for dbg files on all stripped images and unread headers.

    if (idd->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {

        if (*idd->OriginalDbgFileName)
            CopyStrArray(dbgfile, idd->OriginalDbgFileName);
        else
            CopyStrArray(dbgfile, idd->ImageName);
        pprint(idd->pe, "%s is stripped.  Searching for dbg file\n", dbgfile);

    } else if (!option(SYMOPT_EXACT_SYMBOLS) || option(SYMOPT_LOAD_ANYTHING)) {

        if (NoSymbols(idd)) {
            CopyStrArray(dbgfile, idd->ImageName);
            if (!idd->Characteristics)
                pprint(idd->pe, "No header for %s.  Searching for dbg file\n", dbgfile);
            else
                pprint(idd->pe, "No debug info for %s.  Searching for dbg file\n", dbgfile);
        }
    }

    if (*dbgfile) {
        idd->DbgFileHandle = FindDebugInfoFileEx(
                                dbgfile,
                                idd->SymbolPath,
                                idd->DbgFilePath,
                                cbFindDbg,
                                idd);

        if (!idd->DbgFileHandle)
            g.LastSymLoadError = SYMLOAD_DBGNOTFOUND;
        else
            ReadHeader(idd, dsDbg);
    }

    // We don't have an image, dbg, or pdb.  Let's just look for any old PDB.

    if (NoSymbols(idd) && (!option(SYMOPT_EXACT_SYMBOLS) || option(SYMOPT_LOAD_ANYTHING)))
    {
        if (FakePdbName(idd))
            pprint(idd->pe, "%s missing debug info.  Searching for pdb anyway\n", idd->ImageName);
    }

    // Get codeview information, either from pdb or within the image.

    if (*idd->PdbFileName) {
        rc = diaGetPdb(idd);
        if (!rc && IsPdb(idd->ImageFilePath))
            return false;
    } else if (idd->pMappedCv)
        ProcessCvForOmap(idd);

    return true;
}


PIMGHLP_DEBUG_DATA
InitDebugData(
    VOID
    )
{
    PIMGHLP_DEBUG_DATA idd;

    idd = (PIMGHLP_DEBUG_DATA)MemAlloc(sizeof(IMGHLP_DEBUG_DATA));
    if (!idd) {
        SetLastError(ERROR_OUTOFMEMORY);
        g.LastSymLoadError = SYMLOAD_OUTOFMEMORY;
        return NULL;
    }

    ZeroMemory(idd, sizeof(IMGHLP_DEBUG_DATA));

    idd->md = (PMODULE_DATA)MemAlloc(sizeof(gmd));
    if (!idd->md) {
        SetLastError(ERROR_OUTOFMEMORY);
        g.LastSymLoadError = SYMLOAD_OUTOFMEMORY;
        MemFree(idd);
        return NULL;
    }
    memcpy(idd->md, gmd, sizeof(gmd));

    return idd;
}


void
ReleaseDebugData(
    PIMGHLP_DEBUG_DATA idd,
    DWORD              dwFlags
    )
{
    if (!idd)
        return;

    if (idd->ImageMap) {
        UnmapViewOfFile(idd->ImageMap);
    }

    if (idd->ImageFileHandle) {
        CloseHandle(idd->ImageFileHandle);
    }

    if (idd->DbgFileMap) {
        UnmapViewOfFile(idd->DbgFileMap);
    }

    if (idd->DbgFileHandle) {
        CloseHandle(idd->DbgFileHandle);
    }

    if ((dwFlags & IMGHLP_FREE_FPO) &&
        idd->pFpo &&
        !idd->fFpoMapped
       )
    {
        MemFree(idd->pFpo);
    }

    if ((dwFlags & IMGHLP_FREE_PDATA) &&
        idd->pPData &&
        !idd->fPDataMapped
       )
    {
        MemFree(idd->pPData);
    }

    if ((dwFlags & IMGHLP_FREE_XDATA) &&
        idd->pXData &&
        !idd->fXDataMapped
       )
    {
        MemFree(idd->pXData);
    }

    if ((dwFlags & IMGHLP_FREE_PDATA) &&
        idd->pMappedCoff &&
        !idd->fCoffMapped
       )
    {
        MemFree(idd->pMappedCoff);
    }

    if ((dwFlags & IMGHLP_FREE_PDATA) &&
        idd->pMappedCv &&
        !idd->fCvMapped
       )
    {
        MemFree(idd->pMappedCv);
    }

    if ((dwFlags & IMGHLP_FREE_OMAPT)
         && idd->pOmapTo
         && !idd->fOmapToMapped)
    {
        MemFree(idd->pOmapTo);
    }

    if ((dwFlags & IMGHLP_FREE_OMAPF)
        && idd->pOmapFrom
        && !idd->fOmapFromMapped)
    {
        MemFree(idd->pOmapFrom);
    }

    if ((dwFlags & IMGHLP_FREE_OSECT) &&
        idd->pOriginalSections
       )
    {
        MemFree(idd->pOriginalSections);
    }

    if ((dwFlags & IMGHLP_FREE_CSECT) &&
        idd->pCurrentSections &&
        !idd->fCurrentSectionsMapped
       )
    {
        MemFree(idd->pCurrentSections);
    }

    if (idd->SymbolPath) {
        MemFree(idd->SymbolPath);
    }

    MemFree(idd->md);

    MemFree(idd);

    return;
}


BOOL
ExtMatch(
    char *fname,
    char *ext
    )
{
    char fext[_MAX_EXT + 1];

    if (!fname)
        return false;

    _splitpath(fname, NULL, NULL, NULL, fext);
    if (_strcmpi(fext, ext))
        return false;

    return true;
}


BOOL
ReadHeader(
    PIMGHLP_DEBUG_DATA idd,
    DWORD datasrc
    )
{
    BOOL                         status;
    ULONG                        cb;
    IMAGE_DOS_HEADER             dh;
    IMAGE_NT_HEADERS32           nh32;
    IMAGE_NT_HEADERS64           nh64;
    PIMAGE_ROM_OPTIONAL_HEADER   rom = NULL;
    IMAGE_SEPARATE_DEBUG_HEADER  sdh;
    PIMAGE_FILE_HEADER           fh;
    PIMAGE_DEBUG_MISC            md;
    ULONG                        ddva;
    ULONG                        shva;
    ULONG                        nSections;
    PIMAGE_SECTION_HEADER        psh;
    IMAGE_DEBUG_DIRECTORY        dd;
    PIMAGE_DATA_DIRECTORY        datadir;
    PCHAR                        pCV;
    ULONG                        i;
    int                          nDebugDirs = 0;
    HANDLE                       hp;
    ULONG64                      base;
    IMAGE_ROM_HEADERS            ROMImage;
    DWORD                        rva;
    PCHAR                        filepath;
    IMAGE_EXPORT_DIRECTORY       expdir;
    DWORD                        fsize;
    BOOL                         rc;
    USHORT                       filetype;
#ifdef DO_NBO9
    ULONG                        hdrsig;
    char                         cvsig[5];
    char                         cvsig2[5];
    long                         cvpos;
#endif

    // setup pointers for grabing data

    switch (datasrc) {
    case dsInProc:
        hp = idd->hProcess;
        base = idd->InProcImageBase;
        fsize = 0;
        filepath = idd->ImageFilePath;
        idd->PdbSrc = srcCVRec;
        break;
    case dsImage:
        hp = NULL;
        idd->ImageMap = MapItRO(idd->ImageFileHandle);
        base = (ULONG64)idd->ImageMap;
        fsize = GetFileSize(idd->ImageFileHandle, NULL);
        filepath = idd->ImageFilePath;
        idd->PdbSrc = srcImagePath;
        break;
    case dsDbg:
        hp = NULL;
        idd->DbgFileMap = MapItRO(idd->DbgFileHandle);
        base = (ULONG64)idd->DbgFileMap;
        fsize = GetFileSize(idd->DbgFileHandle, NULL);
        filepath = idd->DbgFilePath;
        idd->PdbSrc = srcDbgPath;
        break;
    default:
        return false;
    }

    // some initialization
    idd->fNeedImage = false;
    rc = false;
    ddva = 0;

    __try {

        // test the file type

        status = ReadImageData(hp, base, 0, &filetype, sizeof(filetype));
        if (!status) {
            g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
            return false;
        }
        idd->ImageType = datasrc;
        if (filetype == IMAGE_SEPARATE_DEBUG_SIGNATURE)
            goto dbg;

        if (filetype == IMAGE_DOS_SIGNATURE)
        {
            // grab the dos header

            status = ReadImageData(hp, base, 0, &dh, sizeof(dh));
            if (!status) {
                g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
                return false;
            }

#ifdef DO_NB09
            // test 16 bit image...

            if (idd->SizeOfImage) {
                ZeroMemory(cvsig, 5);
                ZeroMemory(cvsig2, 5);
                cvpos = 0;
                status = ReadImageData(hp, base, idd->SizeOfImage - 8, cvsig, 4);
                status = ReadImageData(hp, base, idd->SizeOfImage - 4, &cvpos, sizeof(cvpos));
                status = ReadImageData(hp, base, idd->SizeOfImage - cvpos, cvsig2, 4);
                if (*cvsig && !strcmp(cvsig, cvsig2)) {
                    pCV = (PCHAR)MemAlloc(cvpos);
                    if (!pCV)
                        return false;
                    status = ReadImageData(hp, base, idd->SizeOfImage - cvpos, pCV, cvpos);
                    idd->pMappedCv = (PCHAR)pCV;
                    idd->cMappedCv = cvpos;
                    return true;
                }
            } 
#endif

            // grab the pe header

#ifdef DO_NB09
            status = ReadImageData(hp, base, dh.e_lfanew, &hdrsig, sizeof(hdrsig));
            if (!status) {
                g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
                return false;
            }
#endif

            status = ReadImageData(hp, base, dh.e_lfanew, &nh32, sizeof(nh32));
            if (!status) {
                g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
                return false;
            }

            // read header info

            if (nh32.Signature != IMAGE_NT_SIGNATURE) {

                // if header is not NT sig, this is a ROM image

                rom = (PIMAGE_ROM_OPTIONAL_HEADER)&nh32.OptionalHeader;
                fh = &nh32.FileHeader;
                shva = dh.e_lfanew + sizeof(DWORD) +
                       sizeof(IMAGE_FILE_HEADER) + fh->SizeOfOptionalHeader;
            }

        } else if (filetype == IMAGE_FILE_MACHINE_I386) {

            // This is an X86 ROM image
            status = ReadImageData(hp, base, 0, &nh32.FileHeader, sizeof(nh32.FileHeader)+sizeof(nh32.OptionalHeader));
            if (!status)
                return false;
            nh32.Signature = 'ROM ';

        } else {
            // This may be a ROM image

            status = ReadImageData(hp, base, 0, &ROMImage, sizeof(ROMImage));
            if (!status) {
                g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
                return false;
            }
            if ((ROMImage.FileHeader.Machine == IMAGE_FILE_MACHINE_I386)  ||
                (ROMImage.FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA) ||
                (ROMImage.FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA64))
            {
                rom = (PIMAGE_ROM_OPTIONAL_HEADER)&ROMImage.OptionalHeader;
                fh = &ROMImage.FileHeader;
                shva = sizeof(IMAGE_FILE_HEADER) + fh->SizeOfOptionalHeader;
            } else {
                return false;
            }
        }

        if (rom) {
            if (rom->Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
                idd->fROM = true;
                idd->iohMagic = rom->Magic;

                idd->ImageBaseFromImage = rom->BaseOfCode;
                idd->SizeOfImage = rom->SizeOfCode;
                idd->CheckSum = 0;
            } else {
                idd->error = ERROR_BAD_FORMAT;
                return false;
            }

        } else {

            // otherwise, get info from appropriate header type for 32 or 64 bit

            if (IsImageMachineType64(nh32.FileHeader.Machine)) {

                // Reread the header as a 64bit header.
                status = ReadImageData(hp, base, dh.e_lfanew, &nh64, sizeof(nh64));
                if (!status) {
                    g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
                    return false;
                }

                fh = &nh64.FileHeader;
                datadir = nh64.OptionalHeader.DataDirectory;
                shva = dh.e_lfanew + sizeof(nh64);
                idd->iohMagic = nh64.OptionalHeader.Magic;
                idd->fPE64 = true;       // seems to be unused

                if (datasrc == dsImage || datasrc == dsInProc) {
                    idd->ImageBaseFromImage = nh64.OptionalHeader.ImageBase;
                    idd->ImageAlign = nh64.OptionalHeader.SectionAlignment;
                    idd->CheckSum = nh64.OptionalHeader.CheckSum;
                }
                idd->SizeOfImage = nh64.OptionalHeader.SizeOfImage;
            }
            else {
                fh = &nh32.FileHeader;
                datadir = nh32.OptionalHeader.DataDirectory;
                idd->iohMagic = nh32.OptionalHeader.Magic;
                if (nh32.Signature == 'ROM ') {
                    shva = sizeof(nh32.FileHeader)+sizeof(nh32.OptionalHeader);
                } else {
                    shva = dh.e_lfanew + sizeof(nh32);
                }

                if (datasrc == dsImage || datasrc == dsInProc) {
                    idd->ImageBaseFromImage = nh32.OptionalHeader.ImageBase;
                    idd->ImageAlign = nh32.OptionalHeader.SectionAlignment;
                    idd->CheckSum = nh32.OptionalHeader.CheckSum;
                }
                idd->SizeOfImage = nh32.OptionalHeader.SizeOfImage;
            }
        }

        imgset(idd->md, mdHeader, datasrc, datasrc);

        // read the section headers

        nSections = fh->NumberOfSections;
        psh = (PIMAGE_SECTION_HEADER) MemAlloc(nSections * sizeof(IMAGE_SECTION_HEADER));
        if (!psh)
            goto debugdirs;
        status = ReadImageData(hp, base, shva, psh, nSections * sizeof(IMAGE_SECTION_HEADER));
        if (!status)
            goto debugdirs;

        // store off info to return struct

        idd->pCurrentSections = psh;
        idd->cCurrentSections = nSections;
        idd->pImageSections   = psh;
        idd->cImageSections   = nSections;
        idd->Machine = fh->Machine;
        idd->TimeDateStamp = fh->TimeDateStamp;
        idd->Characteristics = fh->Characteristics;

        imgset(idd->md, mdSecHdrs, datasrc, datasrc);

        // get information from the sections

        for (i = 0; i < nSections; i++, psh++) {
            DWORD offset;

            if (idd->fROM &&
                ((fh->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) == 0) &&
                (!strcmp((LPSTR)psh->Name, ".rdata")))
            {
                nDebugDirs = 1;
                ddva = psh->VirtualAddress;
                break;
            }
            if (offset = SectionContains(hp, psh, &datadir[IMAGE_DIRECTORY_ENTRY_EXPORT]))
            {
                idd->dsExports = datasrc;
                idd->cExports = datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                idd->oExports = offset;
                ReadImageData(hp, base, offset, &idd->expdir, sizeof(idd->expdir));
            }

            if (offset = SectionContains(hp, psh, &datadir[IMAGE_DIRECTORY_ENTRY_DEBUG]))
            {
                ddva = offset;
                nDebugDirs = datadir[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);
            }
        }

        goto debugdirs;

dbg:

        // grab the dbg header

        status = ReadImageData(hp, base, 0, &sdh, sizeof(sdh));
        if (!status)
            return false;

        // Only support .dbg files for X86 and Alpha (32 bit).

        if ((sdh.Machine != IMAGE_FILE_MACHINE_I386)
            && (sdh.Machine != IMAGE_FILE_MACHINE_ALPHA))
        {
            UnmapViewOfFile(idd->DbgFileMap);
            idd->DbgFileMap = 0;
            return false;
        }

        idd->ImageAlign = sdh.SectionAlignment;
        idd->CheckSum = sdh.CheckSum;
        idd->Machine = sdh.Machine;
        idd->TimeDateStamp = sdh.TimeDateStamp;
        idd->Characteristics = sdh.Characteristics;
        if (!idd->ImageBaseFromImage) {
            idd->ImageBaseFromImage = sdh.ImageBase;
        }

        if (!idd->SizeOfImage) {
            idd->SizeOfImage = sdh.SizeOfImage;
        }

        nSections = sdh.NumberOfSections;
        psh = (PIMAGE_SECTION_HEADER) MemAlloc(nSections * sizeof(IMAGE_SECTION_HEADER));
        if (!psh)
            goto debugdirs;
        status = ReadImageData(hp,
                               base,
                               sizeof(IMAGE_SEPARATE_DEBUG_HEADER),
                               psh,
                               nSections * sizeof(IMAGE_SECTION_HEADER));
        if (!status)
            goto debugdirs;

        idd->pCurrentSections   = psh;
        idd->cCurrentSections   = nSections;
        idd->pDbgSections       = psh;
        idd->cDbgSections       = nSections;
//        idd->ExportedNamesSize = sdh.ExportedNamesSize;

        if (sdh.DebugDirectorySize) {
            nDebugDirs = (int)(sdh.DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY));
            ddva = sizeof(IMAGE_SEPARATE_DEBUG_HEADER)
                   + (sdh.NumberOfSections * sizeof(IMAGE_SECTION_HEADER))
                   + sdh.ExportedNamesSize;
        }

debugdirs:

        rc = true;

        // copy the virtual addr of the debug directories over for MapDebugInformation

        if (datasrc == dsImage) {
            idd->ddva = ddva;
            idd->cdd  = nDebugDirs;
        }

        // read the debug directories

        while (nDebugDirs) {

            status = ReadImageData(hp, base, (ULONG_PTR)ddva, &dd, sizeof(dd));
            if (!status)
                return false;

            if (!dd.SizeOfData)
                goto nextdebugdir;

            // indicate that we found the debug directory

            imgset(idd->md, dd.Type, datasrc, dsNone);

            // these debug directories are processed both in-proc and from file

            switch (dd.Type)
            {
            case IMAGE_DEBUG_TYPE_CODEVIEW:
                // get info on pdb file
                if (hp) { // in-proc image
                    if (!dd.AddressOfRawData)
                        return false;
                    if (!(pCV = (PCHAR)MemAlloc(dd.SizeOfData)))
                        break;
                    status = ReadImageData(hp, base, dd.AddressOfRawData, pCV, dd.SizeOfData);
                    if (!status) {
                        MemFree(pCV);
                        return false;
                    }
                } else { // file-base image
                    if (dd.PointerToRawData >= fsize)
                        break;
                    pCV = (PCHAR)base + dd.PointerToRawData;
                    idd->fCvMapped = true;
                }
                idd->pMappedCv = (PCHAR)pCV;
                idd->cMappedCv = dd.SizeOfData;
                idd->dsCV = datasrc;
                RetrievePdbInfo(idd);
                imgset(idd->md, dd.Type, dsNone, datasrc);
                break;

            case IMAGE_DEBUG_TYPE_MISC:
                // on stripped files, find the dbg file
                // on dbg file, find the original file name
                if (dd.PointerToRawData < fsize) {
                    md = (PIMAGE_DEBUG_MISC)((PCHAR)base + dd.PointerToRawData);
                    if (md->DataType != IMAGE_DEBUG_MISC_EXENAME)
                        break;
                    if (datasrc == dsDbg) {
                        if (!*idd->OriginalImageFileName)
                            CopyStrArray(idd->OriginalImageFileName, (LPSTR)md->Data);
                        break;
                    }
                    if (fh->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                        CopyStrArray(idd->OriginalDbgFileName, (LPSTR)md->Data);
                        idd->DbgTimeDateStamp = dd.TimeDateStamp;
                    } else {
                        CopyStrArray(idd->OriginalImageFileName, (LPSTR)md->Data);
                    }
                }
                imgset(idd->md, dd.Type, dsNone, datasrc);
                break;

            case IMAGE_DEBUG_TYPE_COFF:
                if (dd.PointerToRawData < fsize) {
//                  idd->fNeedImage = true;
                    idd->pMappedCoff = (PCHAR)base + dd.PointerToRawData;
                    idd->cMappedCoff = dd.SizeOfData;
                    idd->fCoffMapped = true;
                    idd->dsCoff = datasrc;
                    imgset(idd->md, dd.Type, dsNone, datasrc);
                } else {
                    idd->fNeedImage = true;
                }
                break;
            }

            // these debug directories are only processed for disk-based images

            if (dd.PointerToRawData < fsize) {

                switch (dd.Type)
                {
                case IMAGE_DEBUG_TYPE_FPO:
                    idd->pFpo = (PCHAR)base + dd.PointerToRawData;
                    idd->cFpo = dd.SizeOfData / SIZEOF_RFPO_DATA;
                    idd->fFpoMapped = true;
                    idd->dsFPO = datasrc;
                    imgset(idd->md, dd.Type, dsNone, datasrc);
                    break;

                case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                    idd->pOmapTo = (POMAP)((PCHAR)base + dd.PointerToRawData);
                    idd->cOmapTo = dd.SizeOfData / sizeof(OMAP);
                    idd->fOmapToMapped = true;
                    idd->dsOmapTo = datasrc;
                    imgset(idd->md, dd.Type, dsNone, datasrc);
                    break;

                case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                    idd->pOmapFrom = (POMAP)((PCHAR)base + dd.PointerToRawData);
                    idd->cOmapFrom = dd.SizeOfData / sizeof(OMAP);
                    idd->fOmapFromMapped = true;
                    idd->dsOmapFrom = datasrc;
                    imgset(idd->md, dd.Type, dsNone, datasrc);
                    break;

                case IMAGE_DEBUG_TYPE_EXCEPTION:
                    idd->dsExceptions = datasrc;
                    imgset(idd->md, dd.Type, dsNone, datasrc);
                    break;
                }
            }

nextdebugdir:

            ddva += sizeof(IMAGE_DEBUG_DIRECTORY);
            nDebugDirs--;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

          // We might have gotten enough information
          // to be okay.  So don't indicate error.
    }

    return rc;
}


BOOL
ReadCallerData(
    PIMGHLP_DEBUG_DATA idd
    )
{
    PMODLOAD_DATA mld = idd->mld;
    PIMAGE_DEBUG_DIRECTORY dd;
    PCHAR pCV;
    DWORD cdd;
    DWORD i;

    if (!mld)
        return false;

    if (!mld->ssize
        || !mld->size
        || !mld->data)
        return false;

    switch (mld->ssig)
    {
    case DBHHEADER_DEBUGDIRS:
        cdd = mld->size / sizeof(IMAGE_DEBUG_DIRECTORY);
        dd = (PIMAGE_DEBUG_DIRECTORY)mld->data;
        for (i = 0; i < cdd; i++, dd++) {
            if (dd->Type != IMAGE_DEBUG_TYPE_CODEVIEW)
                continue;
            pCV = (PCHAR)mld->data + dd->PointerToRawData;
            idd->fCvMapped = true;
            idd->pMappedCv = (PCHAR)pCV;
            idd->cMappedCv = dd->SizeOfData;
            idd->dsCV = dsCallerData;
            idd->PdbSignature = 0;
            idd->PdbAge = 0;
            RetrievePdbInfo(idd);
            imgset(idd->md, dd->Type, dsNone, dsCallerData);
            break;
        }
        return true;

    }

    return false;
}


BOOL
cbFindExe(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    )
{
    PIMGHLP_DEBUG_DATA idd;
    PIMAGE_FILE_HEADER FileHeader = NULL;
    PVOID ImageMap = NULL;
    BOOL rc;

    if (!CallerData)
        return true;

    idd = (PIMGHLP_DEBUG_DATA)CallerData;
    if (!idd->TimeDateStamp)
        return true;

    // Crack the image and let's see what we're working with
    ImageMap = MapItRO(FileHandle);
    if (!ImageMap)
        return true;

    // Check the first word.  We're either looking at a normal PE32/PE64 image, or it's
    // a ROM image (no DOS stub) or it's a random file.
    switch (*(PUSHORT)ImageMap) {
        case IMAGE_FILE_MACHINE_I386:
            // Must be an X86 ROM image (ie: ntldr)
            FileHeader = &((PIMAGE_ROM_HEADERS)ImageMap)->FileHeader;

            // Make sure
            if (!(FileHeader->SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER32) &&
                idd->iohMagic == IMAGE_NT_OPTIONAL_HDR32_MAGIC))
            {
                FileHeader = NULL;
            }
            break;

        case IMAGE_FILE_MACHINE_ALPHA:
        case IMAGE_FILE_MACHINE_ALPHA64:
        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AMD64:
            // Should be an Alpha/IA64 ROM image (ie: osloader.exe)
            FileHeader = &((PIMAGE_ROM_HEADERS)ImageMap)->FileHeader;

            // Make sure
            if (!(FileHeader->SizeOfOptionalHeader == sizeof(IMAGE_ROM_OPTIONAL_HEADER) &&
                 idd->iohMagic == IMAGE_ROM_OPTIONAL_HDR_MAGIC))
            {
                FileHeader = NULL;
            }
            break;

        case IMAGE_DOS_SIGNATURE:
            {
                PIMAGE_NT_HEADERS NtHeaders = ImageNtHeader(ImageMap);
                if (NtHeaders) {
                    FileHeader = &NtHeaders->FileHeader;
                }
            }
            break;

        default:
            break;
    }

    // default return is a match

    rc = true;

    // compare timestamps

    if (FileHeader && FileHeader->TimeDateStamp != idd->TimeDateStamp)
        rc = false;

    idd->ImageSrc = srcSearchPath;

    // cleanup

    if (ImageMap)
        UnmapViewOfFile(ImageMap);

    return rc;
}


BOOL
cbFindDbg(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    )
{
    PIMGHLP_DEBUG_DATA idd;
    PIMAGE_SEPARATE_DEBUG_HEADER DbgHeader;
    PVOID FileMap;
    BOOL  rc;

    rc = true;

    if (!CallerData)
        return true;

    idd = (PIMGHLP_DEBUG_DATA)CallerData;

    FileMap = MapItRO(FileHandle);

    if (!FileMap) {
        return false;
    }

    DbgHeader = (PIMAGE_SEPARATE_DEBUG_HEADER)FileMap;

    // Only support .dbg files for X86 and Alpha (32 bit).

    if ((DbgHeader->Signature != IMAGE_SEPARATE_DEBUG_SIGNATURE) ||
        ((DbgHeader->Machine != IMAGE_FILE_MACHINE_I386) &&
         (DbgHeader->Machine != IMAGE_FILE_MACHINE_ALPHA)))
    {
        rc = false;
        goto cleanup;
    }

    if (idd->DbgTimeDateStamp)
        rc = (idd->DbgTimeDateStamp == DbgHeader->TimeDateStamp) ? true : false;
    if (!rc && idd->TimeDateStamp)
        rc = (idd->TimeDateStamp == DbgHeader->TimeDateStamp) ? true : false;

cleanup:
    if (FileMap)
        UnmapViewOfFile(FileMap);

    return rc;
}


BOOL
ProcessCvForOmap(
    PIMGHLP_DEBUG_DATA idd
    )
{
    OMFSignature    *omfSig;
    OMFDirHeader    *omfDirHdr;
    OMFDirEntry     *omfDirEntry;
    OMFSegMap       *omfSegMap;
    OMFSegMapDesc   *omfSegMapDesc;
    DWORD            i, j, k, SectionSize;
    DWORD            SectionStart;
    PIMAGE_SECTION_HEADER   Section;

    if (idd->cOmapFrom) {
        // If there's omap, we need to generate the original section map

        omfSig = (OMFSignature *)idd->pMappedCv;
        omfDirHdr = (OMFDirHeader*) ((PCHAR)idd->pMappedCv + (DWORD)omfSig->filepos);
        omfDirEntry = (OMFDirEntry*) ((PCHAR)omfDirHdr + sizeof(OMFDirHeader));

        if (!omfDirHdr->cDir) {
            idd->cOmapFrom = 0;
            idd->cOmapTo = 0;
        }

        for (i=0; i<omfDirHdr->cDir; i++,omfDirEntry++) {
            if (omfDirEntry->SubSection == sstSegMap) {

                omfSegMap = (OMFSegMap*) ((PCHAR)idd->pMappedCv + omfDirEntry->lfo);

                omfSegMapDesc = (OMFSegMapDesc*)&omfSegMap->rgDesc[0];

                SectionStart = *(DWORD *)idd->pOmapFrom;
                SectionSize = 0;

                Section = (PIMAGE_SECTION_HEADER) MemAlloc(omfSegMap->cSeg * sizeof(IMAGE_SECTION_HEADER));

                if (Section) {
                    for (j=0, k=0; j < omfSegMap->cSeg; j++) {
                        if (omfSegMapDesc[j].frame) {
                            // The linker sets the frame field to the actual section header number.  Zero is
                            // used to track absolute symbols that don't exist in a real sections.

                            Section[k].VirtualAddress =
                                SectionStart =
                                    SectionStart + ((SectionSize + (idd->ImageAlign-1)) & ~(idd->ImageAlign-1));
                            Section[k].Misc.VirtualSize =
                                SectionSize = omfSegMapDesc[j].cbSeg;
                            k++;
                        }
                    }

                    idd->pOriginalSections = Section;
                    idd->cOriginalSections = k;
                }
            }
        }
    }

    return true;
}


__inline
DWORD
SectionContains (
    HANDLE hp,
    PIMAGE_SECTION_HEADER pSH,
    PIMAGE_DATA_DIRECTORY ddir
    )
{
    DWORD rva = 0;

    if (!ddir->VirtualAddress)
        return 0;

    if (ddir->VirtualAddress >= pSH->VirtualAddress) {
        if ((ddir->VirtualAddress + ddir->Size) <= (pSH->VirtualAddress + pSH->SizeOfRawData)) {
            rva = ddir->VirtualAddress;
            if (!hp)
                rva = rva - pSH->VirtualAddress + pSH->PointerToRawData;
        }
    }

    return rva;
}


void
RetrievePdbInfo(
    PIMGHLP_DEBUG_DATA idd
    )
{
    CHAR szRefDrive[_MAX_DRIVE];
    CHAR szRefPath[_MAX_DIR];
    PCVDD pcv = (PCVDD)idd->pMappedCv;

    if (idd->PdbSignature)
        return;

    switch (pcv->dwSig)
    {
    case '01BN':
        idd->PdbAge = pcv->nb10i.age;
        idd->PdbSignature = pcv->nb10i.sig;
        CopyStrArray(idd->PdbFileName, pcv->nb10i.szPdb);
        break;
    case 'SDSR':
        idd->PdbRSDS = true;
        idd->PdbAge = pcv->rsdsi.age;
        memcpy(&idd->PdbGUID, &pcv->rsdsi.guidSig, sizeof(GUID));
        CopyStrArray(idd->PdbFileName, pcv->rsdsi.szPdb);
        break;
    default:
        return;
    }

    // XXX: get rid of this variable

    CopyStrArray(idd->PdbReferencePath, "");
}


DWORD
imgset(
    PMODULE_DATA md,
    DWORD        id,
    DWORD        hint,
    DWORD        src
    )
{
    DWORD i;

    for (i = 0; i < NUM_MODULE_DATA_ENTRIES; md++, i++) {
        if (md->id == id) {
            if (hint != dsNone)
                md->hint = hint;
            if (src != dsNone)
                md->src = src;
            return i;
        }
    }

    return 0;
}

BOOL
FakePdbName(
    PIMGHLP_DEBUG_DATA idd
    )
{
    CHAR szName[_MAX_FNAME];

    // nothing to do

    if (*idd->PdbFileName)
        return false;
    if (idd->PdbSignature)
        return false;

    // nothing to work with

    if (!idd->ImageName)
        return false;

    // generate pdb name from image

    _splitpath(idd->ImageName, NULL, NULL, szName, NULL);
    if (!*szName)
        return false;

    CopyStrArray(idd->PdbFileName, szName);
    CatStrArray(idd->PdbFileName, ".pdb");

    return true;
}


BOOL
IsImageMachineType64(
    DWORD MachineType
    )
{
   switch(MachineType) {
   case IMAGE_FILE_MACHINE_AXP64:
   case IMAGE_FILE_MACHINE_IA64:
   case IMAGE_FILE_MACHINE_AMD64:
       return true;
   default:
       return false;
   }
}


ULONG
ReadImageData(
    IN  HANDLE  hprocess,
    IN  ULONG64 ul,
    IN  ULONG64 addr,
    OUT LPVOID  buffer,
    IN  ULONG   size
    )
{
    ULONG bytesread;

    if (hprocess) {

        ULONG64 base = ul;

        BOOL rc;

        rc = ReadInProcMemory(hprocess,
                              base + addr,
                              buffer,
                              size,
                              &bytesread);

        if (!rc || (bytesread < (ULONG)size))
            return 0;

    } else {

        PCHAR p = (PCHAR)ul + addr;

        memcpy(buffer, p, size);
    }

    return size;
}


PVOID
MapItRO(
      HANDLE FileHandle
      )
{
    PVOID MappedBase = NULL;

    if (FileHandle) {

        HANDLE MappingHandle = CreateFileMapping( FileHandle, NULL, PAGE_READONLY, 0, 0, NULL );
        if (MappingHandle) {
            MappedBase = MapViewOfFile( MappingHandle, FILE_MAP_READ, 0, 0, 0 );
            CloseHandle(MappingHandle);
        }
    }

    return MappedBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\symstress.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <assert.h>
#include <imagehlp.h>
#include <dbhpriv.h>
#include <cvconst.h>
#include <cmnutil.hpp>

#ifndef true
 #define true TRUE
 #define false FALSE
#endif

#define MAX_STR         256
#define WILD_UNDERSCORE 1
#define SYM_BUFFER_SIZE (sizeof(IMAGEHLP_SYMBOL64) + MAX_SYM_NAME)
#define SI_BUFFER_SIZE (sizeof(SYMBOL_INFO) + MAX_SYM_NAME)

BOOL  gDisplay = true;
DWORD gcEnum = 0;
DWORD gcAddr = 0;

#define pprintf (gDisplay)&&printf

typedef struct _GENINFO {
    HANDLE hp;
    char   modname[MAX_PATH + 1];
} GENINFO, *PGENINFO;

typedef struct {
    char    mask[MAX_STR];
    DWORD64 base;
} ENUMSYMDATA, *PENUMSYMDATA;


typedef enum
{
    cmdQuit = 0,
    cmdHelp,
    cmdVerbose,
    cmdLoad,
    cmdUnload,
    cmdEnum,
    cmdName,
    cmdAddr,
    cmdBase,
    cmdNext,
    cmdPrev,
    cmdLine,
    cmdSymInfo,
    cmdDiaVer,
    cmdUndec,
    cmdFindFile,
    cmdEnumSrcFiles,
    cmdAdd,
    cmdDelete,
    cmdSymbolServer,
    cmdEnumForAddr,
    cmdLocals,
    cmdMax
};

typedef BOOL (*CMDPROC)(char *params);

typedef struct _CMD
{
    char    token[MAX_STR + 1];
    char    shorttoken[4];
    CMDPROC fn;
} CMD, *PCMD;


BOOL fnQuit(char *);
BOOL fnHelp(char *);
BOOL fnVerbose(char *);
BOOL fnLoad(char *);
BOOL fnUnload(char *);
BOOL fnEnum(char *);
BOOL fnName(char *);
BOOL fnAddr(DWORD64 addr);
BOOL fnBase(char *);
BOOL fnNext(char *);
BOOL fnPrev(char *);
BOOL fnLine(char *);
BOOL fnSymInfo(char *);
BOOL fnDiaVer(char *);
BOOL fnUndec(char *);
BOOL fnFindFile(char *);
BOOL fnEnumSrcFiles(char *);
BOOL fnAdd(char *);
BOOL fnDelete(char *);
BOOL fnSymbolServer(char *);
BOOL fnEnumForAddr(char *);
BOOL fnLocals(char *);


CMD gCmd[cmdMax] =
{
    {"quit",    "q", fnQuit},
    {"help",    "h", fnHelp},
    {"verbose", "v", fnVerbose},
    {"load",    "l", fnLoad},
    {"unload",  "u", fnUnload},
    {"enum",    "x", fnEnum},
    {"name",    "n", fnName},
    {"addr",    "a", fnLoad},
    {"base",    "b", fnBase},
    {"next",    "t", fnNext},
    {"prev",    "v", fnPrev},
    {"line",    "i", fnLine},
    {"sym" ,    "s", fnSymInfo},
    {"dia",     "d", fnDiaVer},
    {"undec",   "n", fnUndec},
    {"ff",      "f", fnFindFile},
    {"src",     "r", fnEnumSrcFiles},
    {"add",     "+", fnAdd},
    {"del",     "-", fnDelete},
    {"ss",      "y", fnSymbolServer},
    {"enumaddr","m", fnEnumForAddr},
    {"locals",  "z", fnLocals}
};

char    gModName[MAX_STR];
char    gImageName[MAX_STR];
char    gSymbolSearchPath[MAX_STR];
DWORD64 gBase;
DWORD64 gDefaultBase;
DWORD64 gDefaultBaseForVirtualMods;
DWORD   gOptions;
HANDLE  gHP;

// symbol server stuff

HINSTANCE                       ghSrv;
PSYMBOLSERVERPROC               gfnSymbolServer;
PSYMBOLSERVERCLOSEPROC          gfnSymbolServerClose;
PSYMBOLSERVERSETOPTIONSPROC     gfnSymbolServerSetOptions;
PSYMBOLSERVERGETOPTIONSPROC     gfnSymbolServerGetOptions;

int
WINAPIV
dprintf(
    LPSTR Format,
    ...
    )
{
    static char buf[1000] = "DBGHELP: ";
    va_list args;

    if ((gOptions & SYMOPT_DEBUG) == 0)
        return 1;

    va_start(args, Format);
    _vsnprintf(buf, sizeof(buf)-9, Format, args);
    va_end(args);
    fputs(buf, stdout);
    return 1;
}


__inline int ucase(int c)
{
    return (gOptions & SYMOPT_CASE_INSENSITIVE) ? toupper(c) : c;
}


#define MAX_FORMAT_STRINGS 8

char *
dispaddr(
    ULONG64 addr
    )
/*++

Routine Description:

    Format a 64 bit address, showing the high bits or not
    according to various flags.  This version does not print
    leading 0's.

    An array of static string buffers is used, returning a different
    buffer for each successive call so that it may be used multiple
    times in the same dprintf.

Arguments:

    addr - Supplies the value to format

Return Value:

    A pointer to the string buffer containing the formatted number

--*/
{
    static char sz[20];

    if ((addr >> 32) != 0)
        PrintString(sz, DIMA(sz), "%x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    else
        PrintString(sz, DIMA(sz), "%x", (ULONG)addr);

    return sz;
}

BOOL
validnum(
    char *sz
    )
{
    int c;

    for (; *sz; sz++)
    {
        c = tolower(*sz);
        if (c >= '0' && c <= '9')
            continue;
        if (c >= 'a' && c <= 'f')
            continue;
        return false;
    }

    return true;
}

DWORD64
sz2addr(
    char *sz
    )
{
    char   *p;
    DWORD64 addr = 0;

    if (sz && *sz)
    {
        p = sz;
        if (*(p + 1) == 'x' || *(p + 1) == 'X')
            p += 2;
        if (!validnum(p))
            return 0;
        if (sscanf(p, "%I64x", &addr) < 1)
            return 0;
    }

    return addr;
}


void dumpsym(
    PIMAGEHLP_SYMBOL64 sym
    )
{
    pprintf(" name : %s\n", sym->Name);
    pprintf(" addr : %s\n", dispaddr(sym->Address));
    pprintf(" size : %x\n", sym->Size);
    pprintf("flags : %x\n", sym->Flags);
}


void dumpsym32(
    PIMAGEHLP_SYMBOL sym
    )
{
    pprintf(" name : %s\n", sym->Name);
    pprintf(" addr : %s\n", dispaddr(sym->Address));
    pprintf(" size : %x\n", sym->Size);
    pprintf("flags : %x\n", sym->Flags);
}


void dumpline(
    PIMAGEHLP_LINE64 line
    )
{
    pprintf("%s %s %d\n", dispaddr(line->Address), line->FileName, line->LineNumber);
}


char* g_SymTagNames[] =
{
    "SymTagNull",
    "SymTagExe",
    "SymTagCompiland",
    "SymTagCompilandDetails",
    "SymTagCompilandEnv",
    "SymTagFunction",
    "SymTagBlock",
    "SymTagData",
    "SymTagAnnotation",
    "SymTagLabel",
    "SymTagPublicSymbol",
    "SymTagUDT",
    "SymTagEnum",
    "SymTagFunctionType",
    "SymTagPointerType",
    "SymTagArrayType",
    "SymTagBaseType",
    "SymTagTypedef",
    "SymTagBaseClass",
    "SymTagFriend",
    "SymTagFunctionArgType",
    "SymTagFuncDebugStart",
    "SymTagFuncDebugEnd",
    "SymTagUsingNamespace",
    "SymTagVTableShape",
    "SymTagVTable",
    "SymTagCustom",
    "SymTagThunk",
    "SymTagCustomType",
    "SymTagManagedType",
    "SymTagDimension",
};

char* dispsymtag(
    ULONG symtag
    )
{
    if (symtag >= SymTagMax) {
        return "<Invalid>";
    } else {
        return g_SymTagNames[symtag];
    }
}

void dumpsi(
    PSYMBOL_INFO si
    )
{
    pprintf("   name : %s\n", si->Name);
    pprintf("   addr : %s\n", dispaddr(si->Address));
    pprintf("   size : %x\n", si->Size);
    pprintf("  flags : %x\n", si->Flags);
    pprintf("   type : %x\n", si->TypeIndex);
    pprintf("modbase : %s\n", dispaddr(si->ModBase));
    pprintf("  value : %s\n", dispaddr(si->Value));
    pprintf("    reg : %x\n", si->Register);
    pprintf("  scope : %s (%x)\n", dispsymtag(si->Scope), si->Scope);
    pprintf("    tag : %s (%x)\n", dispsymtag(si->Tag), si->Tag);
}


BOOL
MatchPattern(
    char *sz,
    char *pattern
    )
{
    char c, p, l;

    if (!*pattern)
        return true;

    for (; ;) {
        p = *pattern++;
        p = (char)ucase(p);
        switch (p) {
            case 0:                             // end of pattern
                return *sz ? false : true;  // if end of string true

            case '*':
                while (*sz) {               // match zero or more char
                    if (MatchPattern (sz++, pattern)) {
                        return true;
                    }
                }
                return MatchPattern (sz, pattern);

            case '?':
                if (*sz++ == 0) {           // match any one char
                    return false;                   // not end of string
                }
                break;

            case WILD_UNDERSCORE:
                while (*sz == '_') {
                    sz++;
                }
                break;

            case '[':
                if ( (c = *sz++) == 0) {    // match char set
                    return false;                   // syntax
                }

                c = (CHAR)ucase(c);
                l = 0;
                while (p = *pattern++) {
                    if (p == ']') {             // if end of char set, then
                        return false;           // no match found
                    }

                    if (p == '-') {             // check a range of chars?
                        p = *pattern;           // get high limit of range
                        if (p == 0  ||  p == ']') {
                            return false;           // syntax
                        }

                        if (c >= l  &&  c <= p) {
                            break;              // if in range, move on
                        }
                    }

                    l = p;
                    if (c == p) {               // if char matches this element
                        break;                  // move on
                    }
                }

                while (p  &&  p != ']') {       // got a match in char set
                    p = *pattern++;             // skip to end of set
                }

                break;

            default:
                c = *sz++;
                if (ucase(c) != p) {          // check for exact char
                    return false;                   // not a match
                }

                break;
        }
    }
}


BOOL
cbEnumSymbols(
    PSYMBOL_INFO  si,
    ULONG         size,
    PVOID         context
    )
{
    PENUMSYMDATA esd = (PENUMSYMDATA)context;

    if (gDisplay)
    {
        pprintf(" %8s : ", dispaddr(si->Address));
        if (si->Flags & SYMF_FORWARDER)
            pprintf("%c ", 'F');
        else if (si->Flags & SYMF_EXPORT)
            pprintf("%c ", 'E');
        else
            pprintf("  ");
        pprintf("%s\n", si->Name);
    }
    gcEnum++;
    gcAddr++;
    fnAddr(si->Address + 2);

    return true;
}


BOOL
cbEnumSym(
  PTSTR   name,
  DWORD64 address,
  ULONG   size,
  PVOID   context
  )
{
    PENUMSYMDATA esd = (PENUMSYMDATA)context;

    if (MatchPattern(name, esd->mask))
        pprintf("%s : %s\n", dispaddr(address), name);

    return true;
}


BOOL
cbSrcFiles(
    PSOURCEFILE pSourceFile,
    PVOID       UserContext
    )
{
    DWORD dw;
    BOOL rc;
    LONG disp;
    IMAGEHLP_LINE64 line;
    GENINFO *gi = (GENINFO *)UserContext;

    if (!pSourceFile)
        return false;

    if (!strcmp(pSourceFile->FileName, "d:\\pat\\test\\test.c")
        || !strcmp(pSourceFile->FileName, "d:\\pat\\lines\\lines.c"))
    {
        pprintf("%s\n", pSourceFile->FileName);
    }
    else
        pprintf("%s\n", pSourceFile->FileName);

    if (!gi)
        return true;

    line.SizeOfStruct = sizeof(line);
    rc = SymGetLineFromName64(gi->hp, gi->modname, pSourceFile->FileName, 1, &disp, &line);

#if 0
    for (dw = line.LineNumber + 1; rc; dw = line.LineNumber + 1) {
        dumpline(&line);
        rc = SymGetLineFromName64(gi->hp, gi->modname, pSourceFile->FileName, dw, &disp, &line);
    }
#else
    while (rc)
    {
        dumpline(&line);
        rc = SymGetLineNext64(gi->hp, &line);
    }

    do {
        rc = SymGetLinePrev64(gi->hp, &line);
        if (rc)
            dumpline(&line);
    } while (rc);
#endif

    return true;
}


BOOL
cbSymbol(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    )
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PIMAGEHLP_CBA_READ_MEMORY        prm;
    IMAGEHLP_MODULE64                mi;
    PUCHAR                           p;
    ULONG                            i;

    idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD64) CallbackData;

    switch ( ActionCode ) {
        case CBA_DEBUG_INFO:
            dprintf("%s", (LPSTR)CallbackData);
            break;

#if 0
    case CBA_DEFERRED_SYMBOL_LOAD_CANCEL:
        if (fControlC)
        {
            fControlC = 0;
            return true;
        }
        break;
#endif

        case CBA_DEFERRED_SYMBOL_LOAD_START:
            dprintf("loading symbols for %s\n", gModName);
            break;

        case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
            if (idsl->FileName && *idsl->FileName)
                dprintf( "*** Error: could not load symbols for %s\n", idsl->FileName );
            else
                dprintf( "*** Error: could not load symbols [MODNAME UNKNOWN]\n");
            break;

        case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:
            break;

        case CBA_SYMBOLS_UNLOADED:
            dprintf("unloaded symbols for %s\n", gModName);
            break;

#if 0
        case CBA_READ_MEMORY:
            prm = (PIMAGEHLP_CBA_READ_MEMORY)CallbackData;
            return g_Target->ReadVirtual(prm->addr,
                                         prm->buf,
                                         prm->bytes,
                                         prm->bytesread) == S_OK;
#endif

        default:
            return false;
    }

    return false;
}


BOOL fnQuit(char *param)
{
    pprintf("goodbye\n");
    return false;
}


BOOL fnHelp(char *param)
{
    pprintf("      dbh commands :\n");
    pprintf("h             help : prints this message\n");
    pprintf("q             quit : quits this program\n");
    pprintf("v verbose <on/off> : controls debug spew\n");
    pprintf("l   load <modname> : loads the requested module\n");
    pprintf("u           unload : unloads the current module\n");
    pprintf("x      enum <mask> : enumerates all matching symbols\n");
    pprintf("n   name <symname> : finds a symbol by it's name\n");
    pprintf("a      addr <addr> : finds a symbol by it's hex address\n");
    pprintf("m  enumaddr <addr> : lists all symbols with a certain hex address\n");
    pprintf("b   base <address> : sets the new default base address\n");
    pprintf("t   next <add/nam> : finds the symbol after the passed sym\n");
    pprintf("v   prev <add/nam> : finds the symbol before the passed sym\n");
    pprintf("i    line <file:#> : finds the matching line number\n");
    pprintf("s              sym : displays type and location of symbols\n");
    pprintf("d              dia : displays the DIA version\n");
    pprintf("f ff <path> <file> : finds file in path\n");
    pprintf("r       src <mask> : lists source files\n");
    pprintf("+  add <name addr> : adds symbols with passed name and address\n");
    pprintf("-  del <name/addr> : deletes symbols with passed name or address\n");
    pprintf("y               ss : executes a symbol server command\n");
    pprintf("m  enumaddr <addr> : enum all symbols for address\n");
    pprintf("z    locals <name> : enum all scoped symbols for a named function\n");

    return true;
}


BOOL fnVerbose(char *param)
{
    int opts = gOptions;

    if (!param || !*param)
        pprintf("");
    else if (!_strcmpi(param, "on"))
        opts |= SYMOPT_DEBUG;
    else if (!_strcmpi(param, "off"))
        opts = gOptions & ~SYMOPT_DEBUG;
    else
        pprintf("verbose <on//off>\n");

    gOptions = SymSetOptions(opts);

    pprintf("verbose mode %s.\n", gOptions & SYMOPT_DEBUG ? "on" : "off");

    return true;
}


BOOL fnLoad(char *param)
{
    char    ext[MAX_STR];
    char    mod[MAX_STR];
    char    image[MAX_STR];
    DWORD   flags = 0;
    DWORD64 addr  = 0;

    CopyStrArray(image, (param && *param) ? param : "VIRTUAL");
    _splitpath(image, NULL, NULL, mod, ext);

    if (!*ext) {
        flags = SLMFLAG_VIRTUAL;
        addr = gDefaultBaseForVirtualMods;
    } else if (!_strcmpi(ext, ".pdb")) {
        addr = gDefaultBaseForVirtualMods;
    } else {
        addr = gDefaultBase;
    }

    fnUnload(NULL);

    CopyStrArray(gModName, mod);

    addr = SymLoadModuleEx(gHP,
                           NULL,       // hFile,
                           param,      // ImageName,
                           mod,        // ModuleName,
                           addr,       // BaseOfDll,
                           0x1000000,  // SizeOfDll
                           NULL,       // Data
                           flags);     // Flags

    if (!addr)
    {
        *gModName = 0;
        pprintf("error 0x%x loading %s\n", GetLastError(), param);
        return false;
    }

    if (gBase && !SymUnloadModule64(gHP, gBase))
        pprintf("error unloading %s at %s\n", gModName, dispaddr(gBase));

    CopyStrArray(gImageName, image);
    gBase = addr;

    return true;
}


BOOL fnUnload(char *param)
{
    if (!gBase)
        return true;

    if (!SymUnloadModule64(gHP, gBase))
        pprintf("error unloading %s at %s\n", gModName, dispaddr(gBase));

    gBase = 0;
    *gModName = 0;

    return true;
}


BOOL fnEnum(char *param)
{
    BOOL rc;
    ENUMSYMDATA esd;

    esd.base = gBase;
    CopyStrArray(esd.mask, param ? param : "");

    rc = SymEnumSymbols(gHP, gBase, param, cbEnumSymbols, &esd);
    if (!rc)
        pprintf("error 0x%0 calling SymEnumSymbols()\n", GetLastError());

    return true;
}


BOOL fnEnumSrcFiles(char *param)
{
    BOOL rc;
    GENINFO gi;

    gi.hp = gHP;
    CopyStrArray(gi.modname, gModName);

    rc = SymEnumSourceFiles(gHP, gBase, param, cbSrcFiles, &gi);
    if (!rc)
        pprintf("error 0x%0 calling SymEnumSourceFiles()\n", GetLastError());

    return true;
}


BOOL fnName(char *param)
{
#if 0
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    char               name[MAX_STR];

    if (!param || !*param)
    {
        pprintf("name <symbolname> - finds a symbol by it's name\n");
        return true;
    }
    PrintString(name, DIMA(name), "%s!%s", gModName, param);

    sym = malloc(SYM_BUFFER_SIZE);
    if (!sym)
        return false;
    ZeroMemory(sym, SYM_BUFFER_SIZE);
    sym->MaxNameLength = MAX_SYM_NAME;

    if (SymGetSymFromName64(gHP, name, sym))
        if (gDisplay)
            dumpsym(sym);
    free(sym);

    return true;
#else
    PSYMBOL_INFO si;
    char         name[MAX_STR];

    if (!param || !*param)
    {
        pprintf("name <symbolname> - finds a symbol by it's name\n");
        return true;
    }
    PrintString(name, DIMA(name), "%s!%s", gModName, param);

    si = (PSYMBOL_INFO)malloc(SI_BUFFER_SIZE);
    if (!si)
        return false;
    ZeroMemory(si, SI_BUFFER_SIZE);
    si->MaxNameLen = MAX_SYM_NAME;

    if (SymFromName(gHP, name, si))
        dumpsi(si);
    free(si);

    return true;
#endif
}


BOOL fnAddr(DWORD64 addr)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    DWORD64            disp;
    PSYMBOL_INFO       si;
    IMAGEHLP_LINE64    line;
    DWORD              ldisp;

    if (!addr)
    {
        pprintf("addr <address> : finds a symbol by it's hex address\n");
        return true;
    }

#if 0
    sym = (PIMAGEHLP_SYMBOL64)malloc(SYM_BUFFER_SIZE);
    if (!sym)
        return false;
    ZeroMemory(sym, SYM_BUFFER_SIZE);
    sym->MaxNameLength = MAX_SYM_NAME;

    rc = SymGetSymFromAddr64(gHP, addr, &disp, sym);
    if (rc)
    {
        if (gDisplay)
        {
            pprintf("%s", sym->Name);
            if (disp)
                pprintf("+%I64x", disp);
            pprintf("\n");
            dumpsym(sym);
        }
    }

    free(sym);

    line.SizeOfStruct = sizeof(line);
    rc = SymGetLineFromAddr64(gHP, addr, &ldisp, &line);
    if (rc && gDisplay)
        pprintf("%s %d\n", line.FileName, line.LineNumber);

#else
    si = (PSYMBOL_INFO)malloc(SI_BUFFER_SIZE);
    if (!si)
        return false;
    ZeroMemory(si, SI_BUFFER_SIZE);
    si->MaxNameLen = MAX_SYM_NAME;

    rc = SymFromAddr(gHP, addr, &disp, si);
    if (rc)
    {
        pprintf("%s", si->Name);
        if (disp)
            pprintf("+%I64x", disp);
        pprintf("\n");
        dumpsi(si);
    }

    free(si);

    line.SizeOfStruct = sizeof(line);
    rc = SymGetLineFromAddr64(gHP, addr, &ldisp, &line);
    if (rc && gDisplay)
        pprintf("%s %d\n", line.FileName, line.LineNumber);

#endif

    return true;
}


BOOL fnEnumForAddr(char *param)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    DWORD64            addr;
    DWORD64            disp;
    ENUMSYMDATA        esd;

    addr = sz2addr(param);
    if (!addr)
    {
        pprintf("enumaddr <addr> : lists all symbols with a certain hex address\n");
        return true;
    }

    esd.base = gBase;
    CopyStrArray(esd.mask, "");

    rc = SymEnumSymbolsForAddr(gHP, addr, cbEnumSymbols, &esd);
    if (!rc)
        pprintf("error 0x%0 calling SymEnumSymbolsForAddr()\n", GetLastError());

    return true;
}


BOOL fnLocals(char *param)
{
    BOOL                 rc;
    PSYMBOL_INFO         si;
    char                 name[MAX_STR];
    IMAGEHLP_STACK_FRAME frame;
    ENUMSYMDATA          esd;
    SYMBOL_INFO_PACKAGE  sp;

    if (!param || !*param)
    {
        pprintf("name <symbolname> - finds a symbol by it's name\n");
        return true;
    }
    PrintString(name, DIMA(name), "%s!%s", gModName, param);

    si = (PSYMBOL_INFO)malloc(SI_BUFFER_SIZE);
    if (!si)
        return false;
    ZeroMemory(si, SI_BUFFER_SIZE);
    si->MaxNameLen = MAX_SYM_NAME;

    if (!SymFromName(gHP, name, si))
        goto exit;

    pprintf("dumping locals for %s...\n", si->Name);

    ZeroMemory(&frame, sizeof(frame));
    frame.InstructionOffset = si->Address;

    SymSetContext(gHP, &frame, NULL);

    esd.base = gBase;
    CopyStrArray(esd.mask, "*");
    if (!SymEnumSymbols(gHP, 0, esd.mask, cbEnumSymbols, &esd))
        pprintf("error 0x%0 calling SymEnumSymbols()\n", GetLastError());

exit:
    free(si);

    return true;
}


PIMAGEHLP_SYMBOL64 SymbolFromName(char *param)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    char               name[MAX_STR];

    assert(name & *name);

    sym = (PIMAGEHLP_SYMBOL64)malloc(SYM_BUFFER_SIZE);
    if (!sym)
        return false;
    ZeroMemory(sym, SYM_BUFFER_SIZE);
    sym->MaxNameLength = MAX_SYM_NAME;

    PrintString(name, DIMA(name), "%s!%s", gModName, param);
    rc = SymGetSymFromName64(gHP, name, sym);
    if (!rc) {
        free(sym);
        return NULL;
    }

    return sym;
}


BOOL fnNextPrev(int direction, char *param)
{
#if 1
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    DWORD64            addr;
    char               name[MAX_STR];

    addr = sz2addr(param);
    if (!addr)
    {
        sym = SymbolFromName(param);
        if (!sym)
            return true;
        addr = sym->Address;
        if (!addr) {
            free(sym);
            return true;
        }
    }
    else
    {
        sym = (PIMAGEHLP_SYMBOL64)malloc(SYM_BUFFER_SIZE);
        if (!sym)
            return false;
    }

    if (direction > 0)
        rc = SymGetSymNext64(gHP, sym);
    else
        rc = SymGetSymPrev64(gHP, sym);

    if (rc && gDisplay)
        dumpsym(sym);

    free(sym);

    return true;
#else
    BOOL               rc;
    PIMAGEHLP_SYMBOL   sym;
    DWORD64            addr;
    char               name[MAX_STR];
    DWORD              disp;

    sym = malloc(SYM_BUFFER_SIZE);
    if (!sym)
        return false;
    sym->MaxNameLength = MAX_STR;

    addr = sz2addr(param);
    if (!addr)
        rc = SymGetSymFromName(gHP, param, sym);
    else
        rc = SymGetSymFromAddr(gHP, (DWORD)addr, &disp, sym);

    if (rc) {
        if (direction > 0)
            rc = SymGetSymNext(gHP, sym);
        else
            rc = SymGetSymPrev(gHP, sym);

        if (rc & gDisplay)
            dumpsym32(sym);
    }

    free(sym);

    return true;
#endif
}


BOOL fnNext(char *param)
{
    return fnNextPrev(1, param);
}


BOOL fnPrev(char *param)
{
    return fnNextPrev(-1, param);
}


BOOL fnBase(char *param)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    DWORD64            addr;
    DWORD64            disp;

    addr = sz2addr(param);
    if (!addr)
    {
        pprintf("base <address> : sets the base address for module loads\n");
        return true;
    }

    gDefaultBase = addr;
    gDefaultBaseForVirtualMods = addr;
    if (gBase)
        fnLoad(gImageName);

    return true;
}


BOOL fnLine(char *param)
{
    char              *file;
    DWORD              linenum;
    BOOL               rc;
    IMAGEHLP_LINE64    line;
    LONG               disp;

    if (!param || !*param)
        return true;

    file = param;

    while (*param != ':') {
        if (!*param)
            return true;
        param++;
    }
    *param++ = 0;
    linenum = atoi(param);
    if (!linenum)
        return true;

    memset(&line, 0, sizeof(line));
    line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);
    rc = SymGetLineFromName64(gHP,
                              gModName,
                              file,
                              linenum,
                              &disp,
                              &line);

    if (!rc) {
        pprintf("line: error 0x%x looking for %s#%d\n",
               GetLastError(),
               file,
               linenum);
        return true;
    }

    pprintf("file : %s\n", line.FileName);
    pprintf("line : %d\n", linenum);
    pprintf("addr : %s\n", dispaddr(line.Address));
    pprintf("disp : %x\n", disp);

    return true;
}


BOOL fnSymInfo(char *param)
{
    DBH_MODSYMINFO msi;

    if (!gBase)
        return true;

    msi.function     = dbhModSymInfo;
    msi.sizeofstruct = sizeof(msi);
    msi.addr         = gBase;

    if (!dbghelp(gHP, (PVOID)&msi))
        pprintf("error grabbing symbol info\n");

    pprintf("%s: symtype=%x, src=%s\n", gModName, msi.type, msi.file);

    return true;
}


BOOL fnDiaVer(char *param)
{
    DBH_DIAVERSION dv;

    dv.function     = dbhDiaVersion;
    dv.sizeofstruct = sizeof(dv);

    if (!dbghelp(0, (PVOID)&dv))
        pprintf("error grabbing dia version info\n");

    pprintf("DIA version %d\n", dv.ver);

    return true;
}

BOOL fnUndec(char *param)
{
    DWORD rc;
    char uname[MAX_SYM_NAME + 1];

    if (!param || !*param)
    {
        pprintf("undec <symbolname> - undecorates a C++ mangled symbol name\n");
        return true;
    }

    rc = UnDecorateSymbolName(param, uname, MAX_SYM_NAME, UNDNAME_COMPLETE);
    if (!rc) {
        pprintf("error 0x%u undecorating %s\n", GetLastError(), param);
    } else {
        pprintf("%s = %s\n", param, uname);
    }

    return true;
}

BOOL fnFindFile(char *param)
{
    DWORD rc;
    char  root[MAX_PATH + 1];
    char  file[MAX_PATH + 1];
    char  found[MAX_PATH + 1];

    if (!param)
    {
        pprintf("ff <root path> <file name> - finds file in path\n");
        return true;
    }

    rc = sscanf(param, "%s %s", root, file);
    if ((rc < 2) || !*root || !*file)
    {
        pprintf("ff <root path> <file name> - finds file in path\n");
        return true;
    }

    *found = 0;

    rc = SearchTreeForFile(root, file, found);

    if (!rc) {
        pprintf("error 0x%u looking for %s\n", GetLastError(), file);
    } else {
        pprintf("found %s\n", found);
    }

    return true;
}

BOOL fnAdd(char *param)
{
    BOOL               rc;
    DWORD64            addr;
    DWORD              size;
    char              *p;
    char               name[MAX_STR];
    char              *n;

    if (!param || !*param) {
        pprintf("add <name address> : must specify a symbol name and address.\n");
        return true;
    }

    p = param;
    while (isspace(*p)) p++;
    *name = 0;
    for (n = name; *p; p++, n++) {
        if (isspace(*p)) {
            *n = 0;
            break;
        }
        *n = *p;
    }

    addr = 0;
    size = 0;
    while (isspace(*p)) p++;
    if (*(p + 1) == 'x' || *(p + 1) == 'X')
        p += 2;
    rc = sscanf(p, "%I64x %x", &addr, &size);
    if ((rc < 2) || !addr || !*name)
    {
        pprintf("add <name address> : must specify a symbol name and address.\n");
        return true;
    }

    rc = SymAddSymbol(gHP, 0, name, addr, size, 0);
    if (!rc)
        pprintf("Error 0x%x trying to add symbol\n", GetLastError());

    return true;
}


BOOL fnDelete(char *param)
{
    BOOL               rc;
    DWORD64            addr;
    DWORD              err;
    char              *name = NULL;

    if (!param || !*param) {
        pprintf("del <name/address> : must specify a symbol name or address to delete.\n");
        return true;
    }

    addr = sz2addr(param);
    if (!addr)
        name = param;

    rc = SymDeleteSymbol(gHP, 0, name, addr, 0);
    if (!rc) {
        err = GetLastError();
        if (err == ERROR_NOT_FOUND)
            pprintf("Couldn't find %s to delete.\n", param);
        else
            pprintf("Error 0x%x trying to delete symbol\n", err);
    }

    return true;
}


BOOL fnSymbolServer(char *param)
{
    DWORD opt  = 0;
    DWORD data = 0;

    // initialize server, if needed

    if (ghSrv == (HINSTANCE)INVALID_HANDLE_VALUE)
        return false;

    if (!ghSrv) {
        ghSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        ghSrv = LoadLibrary("symsrv.dll");
        if (ghSrv) {
            gfnSymbolServer = (PSYMBOLSERVERPROC)GetProcAddress(ghSrv, "SymbolServer");
            if (!gfnSymbolServer) {
                FreeLibrary(ghSrv);
                ghSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
            }
            gfnSymbolServerClose = (PSYMBOLSERVERCLOSEPROC)GetProcAddress(ghSrv, "SymbolServerClose");
            gfnSymbolServerSetOptions = (PSYMBOLSERVERSETOPTIONSPROC)GetProcAddress(ghSrv, "SymbolServerSetOptions");
            gfnSymbolServerGetOptions = (PSYMBOLSERVERGETOPTIONSPROC)GetProcAddress(ghSrv, "SymbolServerGetOptions");
        } else {
            ghSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        }
    }

    // bail, if we have no valid server

    if (ghSrv == INVALID_HANDLE_VALUE) {
        pprintf("SymSrv load failure.\n");
        return false;
    }

    if (param) {
        if (sscanf(param, "%x %x", &opt, &data) > 0)
        {
            if (opt)
                gfnSymbolServerSetOptions(opt, data);
        }
    }
    opt = (DWORD)gfnSymbolServerGetOptions();
    pprintf("SYMSRV options: 0x%x\n", opt);

    return true;
}


char *GetParameters(char *cmd)
{
    char *p     = cmd;
    char *param = NULL;

    while (*p++)
    {
        if (isspace(*p))
        {
            *p++ = 0;
             return *p ? p : NULL;
        }
    }

    return NULL;
}


void prompt()
{
    if (!*gModName)
        pprintf("dbh: ");
    else
        pprintf("%s [%I64x]: ", gModName, gBase);
}


int InputLoop()
{
    char  cmd[MAX_STR + 1];
    char *params;
    int   i;
    BOOL  rc;

    pprintf("\n");

    do
    {

        prompt();
        if (!fgets(cmd, sizeof(cmd), stdin))
            return 0;
        params = GetParameters(cmd);

        for (i = 0; i < cmdMax; i++)
        {
            if (!_strcmpi(cmd, gCmd[i].token) ||
                !_strcmpi(cmd, gCmd[i].shorttoken))
                break;
        }

        if (i == cmdMax)
        {
            pprintf("[%s] is an unrecognized command.\n", cmd);
            rc = true;
            continue;
        }
        else
            rc = gCmd[i].fn(params);

    } while (rc);

    return 0;
}


BOOL init()
{
    int i;
    BOOL rc;

    *gModName = 0;
    gBase = 0;;
    gDefaultBaseForVirtualMods = 0x1000000;

    pprintf("dbh: initializing...\n");
    i = GetEnvironmentVariable("_NT_SYMBOL_PATH", gSymbolSearchPath, MAX_STR);
    if (i < 1)
        *gSymbolSearchPath = 0;
    pprintf("Symbol Path = [%s]\n", gSymbolSearchPath);

    gHP = GetCurrentProcess();
    rc = SymInitialize(gHP, gSymbolSearchPath, false);
    if (!rc)
    {
        pprintf("error 0x%x from SymInitialize()\n", GetLastError());
        return rc;
    }
    rc = SymInitialize(gHP, gSymbolSearchPath, false);
    if (!rc)
    {
        pprintf("error 0x%x from SymInitialize()\n", GetLastError());
        return rc;
    }

    gOptions = SymSetOptions(SYMOPT_CASE_INSENSITIVE | SYMOPT_UNDNAME | SYMOPT_LOAD_LINES | SYMOPT_ALLOW_ABSOLUTE_SYMBOLS | SYMOPT_NO_PUBLICS | SYMOPT_DEBUG);
    pprintf("SymOpts = 0x%x\n", gOptions);

    rc = SymRegisterCallback64(gHP, cbSymbol, 0);
    if (!rc)
    {
        pprintf("error 0x%x from SymRegisterCallback64()\n", GetLastError());
        return rc;
    }

    return rc;
}


void cleanup()
{
    int i;

    fnUnload(NULL);
    for (i = 0; i < 50; i++)
        SymCleanup(gHP);
}


BOOL cmdline(int argc, char *argv[])
{
    int   i;
    char *p;

    for (i = 1; i < argc; i++)
    {
        p = argv[i];
        switch (*p)
        {
        case '/':
        case '-':
            p++;
            switch (tolower(*p))
            {
            case 's':
                gDisplay = false;
                break;
            default:
                pprintf("%s is an unknown switch\n", argv[i]);
                break;
            }
            break;

        default:
            if (!fnLoad(argv[i]))
                return false;
            break;
        }
    }

    return true;
}

#include <crtdbg.h>

__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD rc = 0;

    _CrtSetDbgFlag( ( _CRTDBG_CHECK_ALWAYS_DF | _CRTDBG_LEAK_CHECK_DF ) | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG ) );

    if (!init())
        return 1;
    if (!cmdline(argc, argv))
        return 1;
    fnEnum("*");
#if 1
    fnEnumSrcFiles("*");
#endif
    cleanup();

    dprintf("%d symbols enumerated.\n", gcEnum);
    dprintf("%d symbols searched by address.\n", gcAddr);

    _CrtDumpMemoryLeaks();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\undname.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    undname.c

Abstract:

    This is the main source file for the UNDNAME utility program.
    This is a simple command line utility for undecorating C++ symbol
    names.

Author:

    Weslwy Witt (wesw) 09-June-1993

Revision History:

--*/

#include <private.h>
#include <ntverp.h>
#include <common.ver>


void
Usage( void )
{
    fprintf( stderr,
             "usage: UNDNAME [-f] decorated-names...\n"
             "       -f Undecorate fully.  Default is to only undecorate the class::member\n");
    exit( 1 );
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char UnDecoratedName[4000];
    DWORD Flags;

    fputs(VER_PRODUCTNAME_STR "\nUNDNAME Version " VER_PRODUCTVERSION_STR, stderr );
    fputs(VER_LEGALCOPYRIGHT_STR "\n\n", stderr);

    if (argc <= 1) {
        Usage();
    }

    if ((argv[1][0] == '-') && (argv[1][1] == 'f')) {
        Flags = UNDNAME_COMPLETE;
        argc--;
        argv++;
    } else {
        Flags = UNDNAME_NAME_ONLY;
    }

    if (argc <= 1) {
        Usage();
    }

    while (--argc) {
        UnDecorateSymbolName( *++argv, UnDecoratedName, sizeof(UnDecoratedName), Flags );
        printf( ">> %s == %s\n", *argv, UnDecoratedName );
    }

    exit( 0 );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\upddbgi.c ===
#include <private.h>
#include <globals.h>

// Random debug info modification functions for imagehlp


BOOL
IMAGEAPI
UpdateDebugInfoFile(
    LPSTR ImageFileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath,
    PIMAGE_NT_HEADERS32 NtHeaders
    )
{
    return UpdateDebugInfoFileEx(
                ImageFileName,
                SymbolPath,
                DebugFilePath,
                NtHeaders,
                NtHeaders->OptionalHeader.CheckSum);
}

BOOL
IMAGEAPI
UpdateDebugInfoFileEx(
    LPSTR ImageFileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath,
    PIMAGE_NT_HEADERS32 NtHeaders,
    DWORD OldCheckSum
    )
{
    // UnSafe...

    HANDLE hDebugFile, hMappedFile;
    PVOID MappedAddress;
    PIMAGE_SEPARATE_DEBUG_HEADER DbgFileHeader;
    DWORD dwError = ERROR_SUCCESS;

#ifdef _BUILDING_UPDDBG_
    OSVERSIONINFO OSVerInfo;
    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OSVerInfo);
#endif

    hDebugFile = FindDebugInfoFile(
                    ImageFileName,
                    SymbolPath,
                    DebugFilePath
                    );
    if ( hDebugFile == NULL ) {
        return FALSE;
    }
    CloseHandle(hDebugFile);

    hDebugFile = CreateFile( DebugFilePath,
                             GENERIC_READ | GENERIC_WRITE,
                             g.OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );
    if ( hDebugFile == INVALID_HANDLE_VALUE ) {
        return FALSE;
    }

    hMappedFile = CreateFileMapping(
                    hDebugFile,
                    NULL,
                    PAGE_READWRITE,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        CloseHandle(hDebugFile);
        return FALSE;
    }

    MappedAddress = MapViewOfFile(hMappedFile,
                        FILE_MAP_WRITE,
                        0,
                        0,
                        0
                        );
    CloseHandle(hMappedFile);
    if ( !MappedAddress ) {
        CloseHandle(hDebugFile);
        return FALSE;
    }

    DbgFileHeader = (PIMAGE_SEPARATE_DEBUG_HEADER)MappedAddress;
    if (DbgFileHeader->ImageBase != NtHeaders->OptionalHeader.ImageBase ||
        DbgFileHeader->CheckSum != NtHeaders->OptionalHeader.CheckSum   ||
        DbgFileHeader->SizeOfImage != NtHeaders->OptionalHeader.SizeOfImage
       ) {
        DbgFileHeader->ImageBase = NtHeaders->OptionalHeader.ImageBase;
        if (OldCheckSum != DbgFileHeader->CheckSum) {
            DbgFileHeader->Flags |= IMAGE_SEPARATE_DEBUG_MISMATCH;
            dwError = ERROR_INVALID_DATA;
        }
        DbgFileHeader->CheckSum = NtHeaders->OptionalHeader.CheckSum;
        DbgFileHeader->TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
        DbgFileHeader->SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
        FlushViewOfFile(MappedAddress,0);
        UnmapViewOfFile(MappedAddress);
        TouchFileTimes(hDebugFile,NULL);
        CloseHandle(hDebugFile);
        SetLastError(dwError);
        return TRUE;
    } else {
        FlushViewOfFile(MappedAddress,0);
        UnmapViewOfFile(MappedAddress);
        CloseHandle(hDebugFile);
        return FALSE;
    }
}
#ifndef _BUILDING_UPDDBG_

BOOL
IMAGEAPI
RemovePrivateCvSymbolic(
    PCHAR   DebugData,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    )
{
    BOOL rc;
    rc = RemovePrivateCvSymbolicEx(DebugData, 0, NewDebugData, NewDebugSize);
    if (rc && (*NewDebugSize == 0) && (*NewDebugData == DebugData)) {
        *NewDebugData = NULL;
    }
    return(rc);
}

BOOL
IMAGEAPI
RemovePrivateCvSymbolicEx(
    PCHAR   DebugData,
    ULONG   DebugSize,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    )
{
    OMFSignature       *CvDebugData, *NewStartCvSig, *NewEndCvSig;
    OMFDirEntry        *CvDebugDirEntry;
    OMFDirHeader       *CvDebugDirHead;
    unsigned int        i, j;
    PCHAR               NewCvData;
    ULONG               NewCvSize = 0, NewCvOffset;
    BOOL                RC = FALSE;

    __try {
        CvDebugDirHead  = NULL;
        CvDebugDirEntry = NULL;
        CvDebugData = (OMFSignature *)DebugData;

        if ((((*(PULONG)(CvDebugData->Signature)) == '90BN') ||
             ((*(PULONG)(CvDebugData->Signature)) == '80BN') ||
             ((*(PULONG)(CvDebugData->Signature)) == '11BN'))  &&
            ((CvDebugDirHead = (OMFDirHeader *)((PUCHAR) CvDebugData + CvDebugData->filepos)) != NULL) &&
            ((CvDebugDirEntry = (OMFDirEntry *)((PUCHAR) CvDebugDirHead + CvDebugDirHead->cbDirHeader)) != NULL)) {

            // Walk the directory.  Keep what we want, zero out the rest.

            for (i=0, j=0; i < CvDebugDirHead->cDir; i++) {
                switch (CvDebugDirEntry[i].SubSection) {
                    case sstSegMap:
                    case sstSegName:
                    case sstOffsetMap16:
                    case sstOffsetMap32:
                    case sstModule:
                    case SSTMODULE:
                    case SSTPUBLIC:
                    case sstPublic:
                    case sstPublicSym:
                    case sstGlobalPub:
                        CvDebugDirEntry[j] = CvDebugDirEntry[i];
                        NewCvSize += CvDebugDirEntry[j].cb;
                        NewCvSize = (NewCvSize + 3) & ~3;
                        if (i != j++) {
                            // Clear the old entry.
                            RtlZeroMemory(&CvDebugDirEntry[i], CvDebugDirHead->cbDirEntry);
                        }
                        break;

                    default:
                        RC = TRUE;
                        RtlZeroMemory(CvDebugDirEntry[i].lfo + (PUCHAR) CvDebugData, CvDebugDirEntry[i].cb);
                        RtlZeroMemory(&CvDebugDirEntry[i], CvDebugDirHead->cbDirEntry);
                        break;
                }
            }

            // Now, allocate the new cv data.

            CvDebugDirHead->cDir = j;

            NewCvSize += (j * CvDebugDirHead->cbDirEntry) + // The directory itself
                            CvDebugDirHead->cbDirHeader +   // The directory header
                            (sizeof(OMFSignature) * 2);     // The signature/offset pairs at each end.

            NewCvData = (PCHAR) MemAlloc( NewCvSize );

            // And move the stuff we kept into the new section.

            NewCvOffset = sizeof(OMFSignature);

            RtlCopyMemory(NewCvData + NewCvOffset, CvDebugDirHead, CvDebugDirHead->cbDirHeader);

            CvDebugDirHead = (OMFDirHeader *) (NewCvData + NewCvOffset);

            NewCvOffset += CvDebugDirHead->cbDirHeader;

            RtlCopyMemory(NewCvData + NewCvOffset,
                        CvDebugDirEntry,
                        CvDebugDirHead->cDir * CvDebugDirHead->cbDirEntry);

            CvDebugDirEntry = (OMFDirEntry *)(NewCvData + NewCvOffset);

            NewCvOffset += (CvDebugDirHead->cbDirEntry * CvDebugDirHead->cDir);

            for (i=0; i < CvDebugDirHead->cDir; i++) {
                RtlCopyMemory(NewCvData + NewCvOffset,
                            CvDebugDirEntry[i].lfo + (PCHAR) CvDebugData,
                            CvDebugDirEntry[i].cb);
                CvDebugDirEntry[i].lfo = NewCvOffset;
                NewCvOffset += (CvDebugDirEntry[i].cb + 3) & ~3;
            }


            // Re-do the start/end signatures

            NewStartCvSig = (OMFSignature *) NewCvData;
            NewEndCvSig   = (OMFSignature *) ((PCHAR)NewCvData + NewCvOffset);
            *(PULONG)(NewStartCvSig->Signature) = *(PULONG)(CvDebugData->Signature);
            NewStartCvSig->filepos = (int)((PCHAR)CvDebugDirHead - (PCHAR)NewStartCvSig);
            *(PULONG)(NewEndCvSig->Signature) = *(PULONG)(CvDebugData->Signature);
            NewCvOffset += sizeof(OMFSignature);
            NewEndCvSig->filepos = (LONG)NewCvOffset;

            // Set the return values appropriately

            *NewDebugData = NewCvData;
            *NewDebugSize = NewCvSize;

        } else {
            if (*(PULONG)(CvDebugData->Signature) == '01BN') {
                *NewDebugData = DebugData;
                *NewDebugSize = DebugSize;
                RC = TRUE;
            } else {
                // Not NB10, NB09 or NB08.  Forget we ever heard of it.
                *NewDebugData = DebugData;
                *NewDebugSize = 0;
                RC = TRUE;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        RC = FALSE;
    }

    return(RC);
}

#include <copypdb.c>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\tracepdb.c ===
//TracePDB - Extracts trace information from the PDB
// This small tool is used to extract the same trace information that binplace does, but can be used 'after the fact'
// that is if you have the full symbols PDB but no trace information, TracePDB can generate the trace
// tmf and tmc files for you.

#ifdef __cplusplus
extern "C"{
#endif

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <dbghelp.h>
#include "wppfmt.h"


int _cdecl main(int argc, char** argv)
{
    DWORD status;
    TCHAR lppath[MAX_PATH] ;
    TCHAR lppath_tmp[MAX_PATH];
    TCHAR pdbname[MAX_PATH] ;
    INT len, targv=0 ;
    BOOL Verbose = FALSE ;
    BOOL bPDBName = FALSE ;
    LPSTR szRSDSDllToLoad = NULL;
    

    TCHAR helptext[] = "Usage: TracePDB  -f <pdbname> [-p <path>]  [-v]\n"
                       "       Options:\n"
//                     "         -r recurse into subdirectories\n"
                       "         -f specifies the PDBName from which to extract tmf's\n"
                       "         -p specifies the path to create the tmf's,\n"
                       "                by default the current directory.\n"
                       "         -v verbose, displays actions taken \n"  ;



    if (GetCurrentDirectory(MAX_PATH,lppath) == 0 ) {
       fputs("TracePDB: no current directory\n", stdout) ;
       exit(-1);
    }


    while (--argc > 0) {
        ++targv;
        if (argv[targv][0] == '-' || argv[targv][0] == '/') {  // argument found

            if (argv[targv][1] == 'h' || argv[targv][1] == 'H'
                                      || argv[targv][1] == '?')
            {
                fputs(helptext, stdout);
                return 1;
            } else if (argv[targv][1] == 'f') {
                if (--argc >0 ) {
                    ++targv ;
                    if ((strlen(argv[targv])+1) > MAX_PATH) {
                        fputs("TracePDB: PDBname toolarge\n", stdout);
                        exit(-1);
                    }
                    strncpy(pdbname,argv[targv],strlen(argv[targv])+1);
                    bPDBName = TRUE ;
                }
            } else if (argv[targv][1] == 'p') {
                if (--argc >0 ) {
                    ++ targv ;
                    if ((strlen(argv[targv])+1) > MAX_PATH) {
                        fputs("TracePDB: Path larger than MAX_PATH\n", stdout);
                        exit(-1);
                    }
                    strncpy(lppath,argv[targv],strlen(argv[targv])+1);
                }
            } else if (argv[targv][1] == 'v') {
                Verbose = TRUE ;
            } else {
                fputs(helptext, stdout);
            }
        }
    }

    if (!bPDBName) {
        printf("TracePDB: No PDB specified?\n\n%s",helptext);
        return (1);
    }

    if ((szRSDSDllToLoad = (LPSTR) malloc(MAX_PATH+1)) == NULL) {
        fputs("TracePDB: malloc failed\n", stdout);
        return FALSE ;
    }
    strcpy( szRSDSDllToLoad, "mspdb70.dll");

    //Append a '\' and check if the path name is a valid directory
    _sntprintf(lppath_tmp,MAX_PATH,_T("%s\\"),lppath);
    lppath_tmp[MAX_PATH-1] = _T('\0');
	
    if (!MakeSureDirectoryPathExists(lppath_tmp))
    {
        _tprintf ("TracePDB: Invalid Path Name %s\n", lppath);
        return 0;
    }

	status = BinplaceWppFmt(pdbname,
                            lppath,
                            szRSDSDllToLoad,
                            TRUE  // always verbose
                            ) ;

    if (status != ERROR_SUCCESS) {
        printf("TracePDB: failed with error %d\n", status);
    }

    return 0;
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\verfix.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    verfix.c

Abstract:

    This module fixes updates the major and minor subsystem version
    numbers in an executable and recomputes the checksum.

Author:

    Robert Reichel (robertre) 2-May-1993

Revision History:

--*/

#include <private.h>


#define NEW_MAJOR_VERSION  3
#define NEW_MINOR_VERSION  10

void Usage()
{
    fputs(  "usage: VERFIX [-?] [-v] [-q] image-names...\n"
            "              [-?] display this message\n"
            "              [-n #.#] Subsystem Major.Minor versions (default to 3.10)\n"
            "              [-q] quiet on failure\n"
            "              [-v] verbose output\n",
          stderr);
    exit( 1 );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID BaseAddress;
    ULONG CheckSum;
    ULONG FileLength;
    ULONG HeaderSum;
    ULONG OldCheckSum;
    USHORT MajorSubsystemVersion;
    USHORT MinorSubsystemVersion;
    ULONG NewMajorSubsystemVersion = NEW_MAJOR_VERSION;
    ULONG NewMinorSubsystemVersion = NEW_MINOR_VERSION;
    LPSTR ImageName;
    BOOLEAN fVerbose = FALSE;
    BOOLEAN fQuiet = FALSE;
    LPSTR s;
    UCHAR c;

    if (argc <= 1) {
        Usage();
        }

    --argc;
    while (argc) {
        s = *++argv;
        if ( *s == '-' ) {
            while (c=*++s) {
                switch (c) {
                    case 'q':
                    case 'Q':
                        fQuiet = TRUE;
                        break;

                    case 'v':
                    case 'V':
                        fVerbose=TRUE;
                        break;

                    case 'n':
                    case 'N':
                        s = *++argv;
                        --argc;
                        sscanf(s, "%d.%d", &NewMajorSubsystemVersion, &NewMinorSubsystemVersion);
                        goto NextArgument;
                        break;

                    case 'h':
                    case 'H':
                    case '?':
                        Usage();

                    default:
                        fprintf( stderr, "VERFIX: illegal option /%c\n", c );
                        Usage();
                    }
                }
        } else {
            ImageName = s;
            FileHandle = CreateFile( ImageName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL
                                   );
            if (FileHandle == INVALID_HANDLE_VALUE) {
                if (!fQuiet) {
                    fprintf( stderr, "VERFIX: Unable to open %s (%u) - skipping\n", ImageName, GetLastError() );
                    goto NextArgument;
                }
            }

            MappingHandle = CreateFileMapping( FileHandle,
                                           NULL,
                                           PAGE_READWRITE,
                                           0,
                                           0,
                                           NULL
                                         );
            if (MappingHandle == NULL) {
                CloseHandle( FileHandle );
                if (!fQuiet) {
                    fprintf( stderr, "VERFIX: Unable to create mapping object for file %s (%u) - skipping\n", ImageName, GetLastError() );
                }
            } else {
                BaseAddress = MapViewOfFile( MappingHandle,
                                             FILE_MAP_READ | FILE_MAP_WRITE,
                                             0,
                                             0,
                                             0
                                           );
                CloseHandle( MappingHandle );
                if (BaseAddress == NULL) {
                    CloseHandle( FileHandle );
                    if (!fQuiet ) {
                        fprintf( stderr, "VERFIX: Unable to map view of file %s (%u) - skipping\n", ImageName, GetLastError() );
                    }
                } else {
                    //
                    // Get the length of the file in bytes and compute the checksum.
                    //

                    FileLength = GetFileSize( FileHandle, NULL );

                    //
                    // Obtain a pointer to the header information.
                    //

                    NtHeaders = ImageNtHeader( BaseAddress );
                    if (NtHeaders == NULL) {
                        CloseHandle( FileHandle );
                        UnmapViewOfFile( BaseAddress );
                        if (!fQuiet) {
                            fprintf( stderr, "VERFIX: %s is not a valid image file - skipping\n", ImageName, GetLastError() );
                        }
                    } else {
                        //
                        // Write the information to the file.  Update the
                        // SubsystemVersion major and minor codes.
                        //

                        MajorSubsystemVersion = NtHeaders->OptionalHeader.MajorSubsystemVersion;
                        MinorSubsystemVersion = NtHeaders->OptionalHeader.MinorSubsystemVersion;
                        OldCheckSum = NtHeaders->OptionalHeader.CheckSum;

                        NtHeaders->OptionalHeader.MajorSubsystemVersion = (USHORT)NewMajorSubsystemVersion;
                        NtHeaders->OptionalHeader.MinorSubsystemVersion = (USHORT)NewMinorSubsystemVersion;

                        //
                        // Recompute and reset the checksum of the modified file.
                        //

                        (VOID) CheckSumMappedFile( BaseAddress,
                                                   FileLength,
                                                   &HeaderSum,
                                                   &CheckSum
                                                 );

                        NtHeaders->OptionalHeader.CheckSum = CheckSum;

                        if (fVerbose) {
                            printf( "%s - Old version: %u.%u  Old Checksum: %x",
                                    ImageName, MajorSubsystemVersion, MinorSubsystemVersion, OldCheckSum
                                  );

                            printf( "  New version: %u.%u  New Checksum: %x\n",
                                    NtHeaders->OptionalHeader.MajorSubsystemVersion,
                                    NtHeaders->OptionalHeader.MinorSubsystemVersion,
                                    NtHeaders->OptionalHeader.CheckSum
                                  );
                        }

                        if (!FlushViewOfFile( BaseAddress, FileLength )) {
                            if (!fQuiet) {
                                fprintf( stderr,
                                         "VERFIX: Flush of %s failed (%u)\n",
                                         ImageName,
                                         GetLastError()
                                       );
                            }
                        }

                        UnmapViewOfFile( BaseAddress );
                        if (!TouchFileTimes( FileHandle, NULL )) {
                            if (!fQuiet) {
                                fprintf( stderr, "VERFIX: Unable to touch file %s (%u)\n", ImageName, GetLastError() );
                            }
                        }

                        CloseHandle( FileHandle );
                    }
                }
            }
        }
NextArgument:
        --argc;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\util.h ===
/*--

Copyright (c) 1995  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Utility functions for dbghelp.

Author:

    Pat Styles (patst) 6-Dec-2001

Environment:

    User Mode

--*/

#ifndef true
 #define true TRUE
 #define false FALSE
#endif

int
ReverseCmp(
    char *one,
    char *two
    );

BOOL
UpdateBestSrc(
    char *cmp,
    char *trg,
    char *src
    );

BOOL
ShortNodeName(
    char  *in,
    char  *out,
    size_t osize
    );

BOOL
ShortFileName(
    char  *in,
    char  *out,
    size_t osize
    );

BOOL
ToggleFailCriticalErrors(
    BOOL reset
    );

DWORD
fnGetFileAttributes(
    char *lpFileName
    );

#define SetCriticalErrorMode()   ToggleFailCriticalErrors(FALSE)
#define ResetCriticalErrorMode() ToggleFailCriticalErrors(TRUE)

__inline
BOOL exists(char *path)
{
    DWORD attrib = fnGetFileAttributes(path);

    if (attrib == 0xFFFFFFFF)
        return false;
    
    return true;
}


__inline
BOOL fileexists(char *path)
{
    DWORD attrib = fnGetFileAttributes(path);

    if (attrib == 0xFFFFFFFF)
        return false;
    if (attrib & FILE_ATTRIBUTE_DIRECTORY)
        return false;
    return true;
}


__inline
BOOL isdir(char *path)
{
    DWORD attrib = fnGetFileAttributes(path);

    if (attrib == 0xFFFFFFFF)
        return false;
    if (attrib & FILE_ATTRIBUTE_DIRECTORY)
        return true;
    return false;
}


void rtrim(LPSTR sz);

void ltrim(LPSTR sz);

void trim(LPSTR sz);

char *errortext(DWORD err);

VOID RemoveTrailingBackslash(LPSTR sz);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\util.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Utility functions for dbghelp.

Author:

    Pat Styles (patst) 6-Dec-2001

Environment:

    User Mode

--*/

#include "private.h"
#include "symbols.h"
#include "globals.h"
#include <dbhpriv.h>

int
ReverseCmp(
    char *one,
    char *two
    )
{
    char *p1;
    char *p2;
    int   i;

    p1 = one + strlen(one) - 1;
    p2 = two + strlen(two) - 1;

    for (i = 0; p1 >= one && p2 >= two;  i++, p1--, p2--) {
        if (*p1 != *p2)
            return i;
    }

    return i;
}


BOOL
UpdateBestSrc(
    char *cmp,
    char *trg,
    char *src
    )
{
    assert(cmp && *cmp && trg && src);

    if (!*trg || (ReverseCmp(cmp, src) > ReverseCmp(cmp, trg))) {
        strcpy(trg, src);
        return true;
    }

    return false;
}


BOOL
ShortNodeName(
    char  *in,
    char  *out,
    size_t osize
    )
{
    char *p;

    assert(in);

    if (osize < 1 || !out)
        return false;

    CopyString(out, in, osize);

    for (p = out + strlen(out) -1; p >= out; p--) {
        if (*p == '~') {
            *(++p) = 'X';
            *(++p) = 0;
            return true;
        }
        if (*p < '0' || *p > '9') 
            return false;
    }

    return false;
}


BOOL
ShortFileName(
    char  *in,
    char  *out,
    size_t osize)
{
    char drive[_MAX_DRIVE + 1];
    char dir[_MAX_DIR + 1];
    char fname[_MAX_FNAME + 1];
    char ext[_MAX_EXT + 1];
    char nfname[_MAX_FNAME + 1];
    BOOL rc;

    _splitpath(in, drive, dir, fname, ext);

    rc = ShortNodeName(fname, nfname, DIMA(nfname));

    CopyString(out, drive, osize);
    CatString(out, dir, osize);
    CatString(out, nfname, osize);
    CatString(out, ext, osize);

    return rc;
}

BOOL
ToggleFailCriticalErrors(
    BOOL reset
    )
{
    static UINT oldmode = 0;

    if (!option(SYMOPT_FAIL_CRITICAL_ERRORS))
        return false;

    if (reset)
        SetErrorMode(oldmode);
    else
        oldmode = SetErrorMode(SEM_FAILCRITICALERRORS);

    return true;
}


DWORD
fnGetFileAttributes(
    char *lpFileName
    )
{
    DWORD rc;

    SetCriticalErrorMode();
    rc = GetFileAttributes(lpFileName);
    ResetCriticalErrorMode();

    return rc;
}


void
rtrim(
    LPSTR sz
    )
{
    LPSTR p;

    assert(sz);

    for (p = sz + strlen(sz) - 1; p >= sz; p--) {
        if (!isspace(*p))
            break;
        *p = 0;
    }
}


void
ltrim(
    LPSTR sz
    )
{
    LPSTR p;
   
    assert(sz);

    for (p = sz; *p; p++) {
        if (!isspace(*p))
            break;
    }

    if (p == sz)
        return;

    for (; *p; p++, sz++) 
        *sz = *p;
    *sz = 0;
}


void
trim(
    LPSTR sz
    )
{
    rtrim(sz);
    ltrim(sz);
}


char *errortext(DWORD err)
{
    char *sz;

    switch (err)
    {
    case ERROR_FILE_NOT_FOUND:
        return "file not found";
    case ERROR_PATH_NOT_FOUND:
        return "path not found";
    case ERROR_NOT_READY:
        return "drive not ready";
    case ERROR_ACCESS_DENIED:
        return "access is denied";
    default:
        sz = FormatStatus(err);
        return (sz) ? sz : "";
    }
}


VOID
RemoveTrailingBackslash(
    LPSTR sz
    )
{
    int i;

    assert(sz);

    i = lstrlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == '\\')
        sz[i - 1] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\userdump.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    userdump.c

Abstract:

    This module implements full user-mode dump writing.

--*/

#include "private.h"

// hack to make it build
typedef ULONG UNICODE_STRING32;
typedef ULONG UNICODE_STRING64;

#include <ntiodump.h>

#include <cmnutil.hpp>

// This should match INVALID_SET_FILE_POINTER on 32-bit systems.
#define DMPP_INVALID_OFFSET ((DWORD_PTR)-1)

DWORD_PTR
DmppGetFilePointer(
    HANDLE hFile
    )
{
#ifdef _WIN64
    LONG dwHigh = 0;
    DWORD dwLow;

    dwLow = SetFilePointer(hFile, 0, &dwHigh, FILE_CURRENT);
    if (dwLow == INVALID_SET_FILE_POINTER && GetLastError()) {
        return DMPP_INVALID_OFFSET;
    } else {
        return dwLow | ((DWORD_PTR)dwHigh << 32);
    }
#else
    return SetFilePointer(hFile, 0, NULL, FILE_CURRENT);
#endif
}

BOOL
DmppWriteAll(
    HANDLE hFile,
    LPVOID pBuffer,
    DWORD dwLength
    )
{
    DWORD dwDone;
    
    if (!WriteFile(hFile, pBuffer, dwLength, &dwDone, NULL)) {
        return FALSE;
    }
    if (dwDone != dwLength) {
        SetLastError(ERROR_WRITE_FAULT);
        return FALSE;
    }

    return TRUE;
}

WCHAR *
DmppGetHotFixString(
    )
{
    WCHAR *pszBigBuffer = NULL;
    HKEY hkey = 0;

    //
    // Get the hot fixes. Concat hotfixes into a list that looks like:
    //  "Qxxxx, Qxxxx, Qxxxx, Qxxxx"
    //        
    RegOpenKeyExW(HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix", 0, KEY_READ, &hkey);

    if (hkey) {
        DWORD dwMaxKeyNameLen = 0;
        DWORD dwNumSubKeys = 0;
        WCHAR *pszNameBuffer = NULL;
        
        if (ERROR_SUCCESS != RegQueryInfoKeyW(hkey,     // handle of key to query
                                            NULL,               // address of buffer for class string
                                            NULL,               // address of size of class string buffer
                                            0,                  // reserved
                                            &dwNumSubKeys,      // address of buffer for number of subkeys
                                            &dwMaxKeyNameLen,   // address of buffer for longest subkey name length
                                            NULL,               // address of buffer for longest class string length
                                            NULL,               // address of buffer for number of value entries
                                            NULL,               // address of buffer for longest value name length
                                            NULL,               // address of buffer for longest value data length
                                            NULL,               // address of buffer for security descriptor length
                                            NULL)) {            // address of buffer for last write time);


        
            pszNameBuffer = (WCHAR *) calloc(dwMaxKeyNameLen, sizeof(WCHAR));
            pszBigBuffer = (WCHAR *) calloc(dwMaxKeyNameLen * dwNumSubKeys 
                // Factor in the space required for each ", " between the hotfixes
                + (dwNumSubKeys -1) * 2, sizeof(WCHAR));
        
            if (!pszNameBuffer || !pszBigBuffer) {
                if (pszBigBuffer) {
                    free(pszBigBuffer);
                    pszBigBuffer = NULL;
                }
            } else {
                DWORD dw;
                // So far so good, get each entry
                for (dw=0; dw<dwNumSubKeys; dw++) {
                    DWORD dwSize = dwMaxKeyNameLen;
                    
                    if (ERROR_SUCCESS == RegEnumKeyExW(hkey, 
                                                      dw, 
                                                      pszNameBuffer, 
                                                      &dwSize, 
                                                      0, 
                                                      NULL, 
                                                      NULL, 
                                                      NULL)) {

                        // concat the list
                        wcscat(pszBigBuffer, pszNameBuffer);
                        if (dw < dwNumSubKeys-1) {
                            wcscat(pszBigBuffer, L", ");
                        }
                    }
                }
            }
        }
        
        if (pszNameBuffer) {
            free(pszNameBuffer);
        }

        RegCloseKey(hkey);
    }

    return pszBigBuffer;
}

BOOL
DbgHelpCreateUserDump(
    LPSTR                              CrashDumpName,
    PDBGHELP_CREATE_USER_DUMP_CALLBACK DmpCallback,
    PVOID                              lpv
    )
{
    UINT uSizeDumpFile;
    UINT uSizeUnicode;
    PWSTR pwszUnicode = NULL;
    BOOL b;

    if (CrashDumpName) {
        
        uSizeDumpFile = strlen(CrashDumpName);
        uSizeUnicode = (uSizeDumpFile + 1) * sizeof(wchar_t);
        pwszUnicode = (PWSTR)calloc(uSizeUnicode, 1);
        if (!pwszUnicode) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        *pwszUnicode = UNICODE_NULL;
        if (*CrashDumpName) {

            if (!MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                     CrashDumpName, uSizeDumpFile,
                                     pwszUnicode, uSizeUnicode))
            {
                // Error. Free the string, return NULL.
                free(pwszUnicode);
                return FALSE;
            }
        }
    }

    b = DbgHelpCreateUserDumpW(pwszUnicode, DmpCallback, lpv);

    if (pwszUnicode) {
        free(pwszUnicode);
    }
    return b;
}

BOOL
DbgHelpCreateUserDumpW(
    LPWSTR                             CrashDumpName,
    PDBGHELP_CREATE_USER_DUMP_CALLBACK DmpCallback,
    PVOID                              lpv
    )

/*++

Routine Description:

    Create a usermode dump file.

Arguments:

    CrashDumpName - Supplies a name for the dump file.

    DmpCallback - Supplies a pointer to a callback function pointer which
        will provide debugger service such as ReadMemory and GetContext.

    lpv - Supplies private data which is sent to the callback functions.

Return Value:

    TRUE - Success.

    FALSE - Error.

--*/

{
    OSVERSIONINFO               OsVersion = {0};
    USERMODE_CRASHDUMP_HEADER   DumpHeader = {0};
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    BOOL                        rval;
    PVOID                       DumpData;
    DWORD                       DumpDataLength;


#ifndef _WIN64
    C_ASSERT(DMPP_INVALID_OFFSET == INVALID_SET_FILE_POINTER);
#endif
    
    if (CrashDumpName == NULL) {
        DmpCallback( DMP_DUMP_FILE_HANDLE, &hFile, &DumpDataLength, lpv );
    } else {
        //
        // This code used to create an explicit NULL DACL
        // security descriptor so that the resulting
        // dump file is all-access.  This caused problems
        // with people and tools scanning the code for NULL DACL
        // usage.  Rather than try to create a complicated
        // "correct" security descriptor, we just use no
        // descriptor and get default security.  If the caller
        // desires specific security they can create their
        // own file and pass in the handle via DMP_DUMP_FILE_HANDLE.
        //

        hFile = CreateFileW(
            CrashDumpName,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    }

    if ((hFile == NULL) || (hFile == INVALID_HANDLE_VALUE)) {
        return FALSE;
    }

    // Write out an empty header
    if (!DmppWriteAll( hFile, &DumpHeader, sizeof(DumpHeader) )) {
        goto bad_file;
    }

    //
    // write the debug event
    //
    DumpHeader.DebugEventOffset = DmppGetFilePointer( hFile );
    if (DumpHeader.DebugEventOffset == DMPP_INVALID_OFFSET) {
        goto bad_file;
    }
    DmpCallback( DMP_DEBUG_EVENT, &DumpData, &DumpDataLength, lpv );
    if (!DmppWriteAll( hFile, DumpData, sizeof(DEBUG_EVENT) )) {
        goto bad_file;
    }

    //
    // write the memory map
    //
    DumpHeader.MemoryRegionOffset = DmppGetFilePointer( hFile );
    if (DumpHeader.MemoryRegionOffset == DMPP_INVALID_OFFSET) {
        goto bad_file;
    }
    do {
        __try {
            rval = DmpCallback(
                DMP_MEMORY_BASIC_INFORMATION,
                &DumpData,
                &DumpDataLength,
                lpv
                );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }
        if (rval) {
            DumpHeader.MemoryRegionCount += 1;
            if (!DmppWriteAll( hFile, DumpData, sizeof(MEMORY_BASIC_INFORMATION) )) {
                goto bad_file;
            }
        }
    } while( rval );

    //
    // write the thread contexts
    //
    DumpHeader.ThreadOffset = DmppGetFilePointer( hFile );
    if (DumpHeader.ThreadOffset == DMPP_INVALID_OFFSET) {
        goto bad_file;
    }
    do {
        __try {
            rval = DmpCallback(
                DMP_THREAD_CONTEXT,
                &DumpData,
                &DumpDataLength,
                lpv
                );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }
        if (rval) {
            if (!DmppWriteAll( hFile, DumpData, DumpDataLength )) {
                goto bad_file;
            }
            DumpHeader.ThreadCount += 1;
        }
    } while( rval );

    //
    // write the thread states
    //
    DumpHeader.ThreadStateOffset = DmppGetFilePointer( hFile );
    if (DumpHeader.ThreadStateOffset == DMPP_INVALID_OFFSET) {
        goto bad_file;
    }
    do {
        __try {
            rval = DmpCallback(
                DMP_THREAD_STATE,
                &DumpData,
                &DumpDataLength,
                lpv
                );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }
        if (rval) {
            if (!DmppWriteAll( hFile, DumpData, sizeof(CRASH_THREAD) )) {
                goto bad_file;
            }
        }
    } while( rval );

    //
    // write the module table
    //
    DumpHeader.ModuleOffset = DmppGetFilePointer( hFile );
    if (DumpHeader.ModuleOffset == DMPP_INVALID_OFFSET) {
        goto bad_file;
    }
    do {
        __try {
            rval = DmpCallback(
                DMP_MODULE,
                &DumpData,
                &DumpDataLength,
                lpv
                );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }
        if (rval) {
            if (!DmppWriteAll(
                hFile,
                DumpData,
                sizeof(CRASH_MODULE) +
                ((PCRASH_MODULE)DumpData)->ImageNameLength
                )) {
                goto bad_file;
            }
            DumpHeader.ModuleCount += 1;
        }
    } while( rval );

    //
    // write the virtual memory
    //
    DumpHeader.DataOffset = DmppGetFilePointer( hFile );
    if (DumpHeader.DataOffset == DMPP_INVALID_OFFSET) {
        goto bad_file;
    }
    do {
        __try {
            rval = DmpCallback(
                DMP_MEMORY_DATA,
                &DumpData,
                &DumpDataLength,
                lpv
                );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }
        if (rval) {
            if (!DmppWriteAll(
                hFile,
                DumpData,
                DumpDataLength
                )) {
                goto bad_file;
            }
        }
    } while( rval );

    //
    // VersionInfoOffset will be an offset into the dump file that will contain 
    // misc information about drwatson. The format of the information 
    // will be a series of NULL terminated strings with two zero 
    // terminating the multistring. The string will be UNICODE.
    //
    // FORMAT:
    //  This data refers to the specific data about Dr. Watson
    //      DRW: OS version: XX.XX
    //          OS version of headers
    //      DRW: build: XXXX
    //          Build number of Dr. Watson binary
    //      DRW: QFE: X
    //          QFE number of the Dr. Watson binary
    //  Refers to info describing the OS on which the app crashed,
    //  including Service pack, hotfixes, etc...
    //      CRASH: OS SP: X
    //          Service Pack number of the OS where the app AV'd (we 
    //          already store the build number, but not the SP)
    //
    DumpHeader.VersionInfoOffset = DmppGetFilePointer( hFile );
    if (DumpHeader.VersionInfoOffset == DMPP_INVALID_OFFSET) {
        goto bad_file;
    }

    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx( &OsVersion )) {
        goto bad_file;
    }

    {
        WCHAR szBuf[1024] = {0};
        WCHAR * psz = szBuf;
        ULONG Left = DIMA(szBuf) - 1;
        ULONG Len;
        WCHAR * pszHotfixes;

#define ADVANCE() \
    Len = wcslen(psz) + 1; \
    if (Len <= Left) { psz += Len; Left -= Len; } else { Left = 0; }
        
        CatStringW(psz, L"DRW: OS version", Left);
        ADVANCE();
        // Let the printf function convert it from ANSI to unicode
        PrintStringW(psz, Left, L"%S", VER_PRODUCTVERSION_STRING);
        ADVANCE();
        
        CatStringW(psz, L"DRW: build", Left);
        ADVANCE();
        PrintStringW(psz, Left, L"%d", (int) VER_PRODUCTBUILD);
        ADVANCE();

        CatStringW(psz, L"DRW: QFE", Left);
        ADVANCE();
        PrintStringW(psz, Left, L"%d", (int) VER_PRODUCTBUILD_QFE);
        ADVANCE();

        CatStringW(psz, L"CRASH: OS SP", Left);
        ADVANCE();
        if (OsVersion.szCSDVersion[0]) {
            // Let the printf function convert it from ANSI to unicode
            PrintStringW(psz, Left, L"%S", OsVersion.szCSDVersion);
        } else {
            CatStringW(psz, L"none", Left);
        }
        ADVANCE();

        CatStringW(psz, L"CRASH: Hotfixes", Left);
        ADVANCE();
        pszHotfixes = DmppGetHotFixString ();
        if (pszHotfixes) {
            CatStringW(psz, pszHotfixes, Left);
            free(pszHotfixes);
        } else {
            CatStringW(psz, L"none", Left);
        }
        ADVANCE();

        // Include last terminating zero
        *psz++ = 0;

        // Calc length of data.  This should always fit in a ULONG.
        DumpDataLength = (ULONG)((PBYTE) psz - (PBYTE) szBuf);
        if (!DmppWriteAll(
            hFile,
            szBuf,
            DumpDataLength
            )) {
            goto bad_file;
        }
    
    }

    //
    // re-write the dump header with some valid data
    //
    
    DumpHeader.Signature = USERMODE_CRASHDUMP_SIGNATURE;
    DumpHeader.MajorVersion = OsVersion.dwMajorVersion;
    DumpHeader.MinorVersion =
        (OsVersion.dwMinorVersion & 0xffff) |
        (OsVersion.dwBuildNumber << 16);
#if defined(_M_IX86)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_I386;
    DumpHeader.ValidDump = USERMODE_CRASHDUMP_VALID_DUMP32;
#elif defined(_M_IA64)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_IA64;
    DumpHeader.ValidDump = USERMODE_CRASHDUMP_VALID_DUMP64;
#elif defined(_M_AXP64)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_AXP64;
    DumpHeader.ValidDump = USERMODE_CRASHDUMP_VALID_DUMP64;
#elif defined(_M_ALPHA)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_ALPHA;
    DumpHeader.ValidDump = USERMODE_CRASHDUMP_VALID_DUMP32;
#elif defined(_M_AMD64)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_AMD64;
    DumpHeader.ValidDump = USERMODE_CRASHDUMP_VALID_DUMP64;
#else
#error( "unknown target machine" );
#endif

    if (SetFilePointer( hFile, 0, 0, FILE_BEGIN ) == INVALID_SET_FILE_POINTER) {
        goto bad_file;
    }
    if (!DmppWriteAll( hFile, &DumpHeader, sizeof(DumpHeader) )) {
        goto bad_file;
    }

    //
    // close the file
    //
    if (CrashDumpName)
    {
        CloseHandle( hFile );
    }
    return TRUE;

bad_file:

    if (CrashDumpName)
    {
        CloseHandle( hFile );
        DeleteFileW( CrashDumpName );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\vwndia64.c ===
/**
***  Copyright  (C) 1996-1999 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
****************************************************************************
***
*** Thierry 09/21/99 - v16
*** WARNING: ntos\rtl\ia64\vunwind.c and sdktools\imagehlp\vwndia64.c are
***          identical. For sake of maintenance and for debug purposes,
***          please keep them as this. Thank you.
***
****************************************************************************
**/

#define _CROSS_PLATFORM_
#define _IA64REG_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#include "globals.h"
#include "ia64inst.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <stdlib.h>

#ifdef _IMAGEHLP_SOURCE_
#include <symbols.h>

#define NOT_IMAGEHLP(E)
#define FUNCTION_ENTRY_IS_IMAGE_STYLE
#define RtlVirtualUnwind VirtualUnwindIa64
#define VUW_DEBUG_PRINT OutputDebugString

#else  // !_IMAGEHLP_SOURCE_

#define NOT_IMAGEHLP(E) E
#define VUW_DEBUG_PRINT DbgPrint

#endif // !_IMAGEHLP_SOURCE_

#ifdef MASK
#undef MASK
#endif // MASK
#define MASK(bp,value)  (value << bp)

//
// ABI values
//

#define SVR4_ABI      0
#define HPUX_ABI      1
#define NT_ABI        2


#ifdef KERNEL_DEBUGGER
#define FUNCTION_ENTRY_IS_IMAGE_STYLE
#define RtlVirtualUnwind VirtualUnwind
#endif

#define STATE_RECORD_STACK_SIZE 32

#define SPILLSIZE_OF_FLOAT128_IN_DWORDS   4
#define SPILLSIZE_OF_ULONGLONG_IN_DWORDS  2

#define REGISTER_SIZE                sizeof(ULONGLONG)
#define STATIC_REGISTER_SET_SIZE     32
#define SLOTS_PER_BUNDLE             3

#define R1_MASK              0xC0
#define R1_PREFIX            0x0
#define R1_REGION_TYPE_MASK  0x20
#define R1_LENGTH_MASK       0x1F

#define R2_MASK              0xE0
#define R2_PREFIX            0x40

#define R3_MASK              0xE0
#define R3_PREFIX            0x60
#define R3_REGION_TYPE_MASK  0x3

#define P1_MASK              0xE0
#define P1_PREFIX            0x80
#define P2_MASK              0xF0
#define P2_PREFIX            0xA0
#define P3_MASK              0xF8
#define P3_PREFIX            0xB0
#define P4_MASK              0xFF
#define P4_PREFIX            0xB8
#define P5_MASK              0xFF
#define P5_PREFIX            0xB9
#define P6_MASK              0xE0
#define P6_PREFIX            0xC0
#define P7_MASK              0xF0
#define P7_PREFIX            0xE0
#define P8_MASK              0xFF
#define P8_PREFIX            0xF0
#define P9_MASK              0xFF
#define P9_PREFIX            0xF1
#define P10_MASK             0xFF
#define P10_PREFIX           0xFF

#define B1_MASK              0xC0
#define B1_PREFIX            0x80
#define B1_TYPE_MASK         0x20
#define B1_LABEL_MASK        0x1F
#define B2_MASK              0xE0
#define B2_PREFIX            0xC0
#define B2_ECOUNT_MASK       0x1F
#define B3_MASK              0xF0
#define B3_PREFIX            0xE0
#define B4_MASK              0xF0
#define B4_PREFIX            0xF0
#define B4_TYPE_MASK         0x08

//
// P3 descriptor type
//

#define PSP_GR               0
#define RP_GR                1
#define PFS_GR               2
#define PREDS_GR             3
#define UNAT_GR              4
#define LC_GR                5
#define RP_BR                6
#define RNAT_GR              7
#define BSP_GR               8
#define BSPSTORE_GR          9
#define FPSR_GR              10
#define PRIUNAT_GR           11

//
// P7 descriptor type
//

#define MEM_STACK_F          0
#define MEM_STACK_V          1
#define SPILL_BASE           2
#define PSP_SPREL            3
#define RP_WHEN              4
#define RP_PSPREL            5
#define PFS_WHEN             6
#define PFS_PSPREL           7
#define PREDS_WHEN           8
#define PREDS_PSPREL         9
#define LC_WHEN              10
#define LC_PSPREL            11
#define UNAT_WHEN            12
#define UNAT_PSPREL          13
#define FPSR_WHEN            14
#define FPSR_PSPREL          15

//
// P8 descriptor type
//

#define PSP_PSPREL           0
#define RP_SPREL             1
#define PFS_SPREL            2
#define PREDS_SPREL          3
#define LC_SPREL             4
#define UNAT_SPREL           5
#define FPSR_SPREL           6
#define BSP_WHEN             7
#define BSP_PSPREL           8
#define BSP_SPREL            9
#define BSPSTORE_WHEN        10
#define BSPSTORE_PSPREL      11
#define BSPSTORE_SPREL       12
#define RNAT_WHEN            13
#define RNAT_PSPREL          14
#define RNAT_SPREL           15
#define PRIUNAT_WHEN         16
#define PRIUNAT_PSPREL       17
#define PRIUNAT_SPREL        18


#define STACK_POINTER_GR     12

#define FIRST_PRESERVED_GR                4
#define LAST_PRESERVED_GR                 7
#define NUMBER_OF_PRESERVED_GR            4
#define NUMBER_OF_SCRATCH_GR              24

#define FIRST_LOW_PRESERVED_FR            2
#define LAST_LOW_PRESERVED_FR             5
#define NUMBER_OF_LOW_PRESERVED_FR        4

#define FIRST_HIGH_PRESERVED_FR           16
#define LAST_HIGH_PRESERVED_FR            31
#define NUMBER_OF_HIGH_PRESERVED_FR       16
#define NUMBER_OF_PRESERVED_FR            (NUMBER_OF_LOW_PRESERVED_FR+NUMBER_OF_HIGH_PRESERVED_FR)

#define FIRST_PRESERVED_BR                1
#define LAST_PRESERVED_BR                 5
#define NUMBER_OF_PRESERVED_BR            5

#define NUMBER_OF_PRESERVED_MISC          8

#define NUMBER_OF_PRESERVED_REGISTERS     (NUMBER_OF_PRESERVED_MISC+NUMBER_OF_PRESERVED_BR)


#define REG_MISC_BASE        0
#define REG_PREDS            (REG_MISC_BASE+0)
#define REG_SP               (REG_MISC_BASE+1)
#define REG_PFS              (REG_MISC_BASE+2)
#define REG_RP               (REG_MISC_BASE+3)
#define REG_UNAT             (REG_MISC_BASE+4)
#define REG_LC               (REG_MISC_BASE+5)
#define REG_NATS             (REG_MISC_BASE+6)
#define REG_FPSR             (REG_MISC_BASE+7)

#define REG_BR_BASE          (REG_MISC_BASE+NUMBER_OF_PRESERVED_MISC)

#define REG_BSP              0xff // REG_MISC_BASE+8
#define REG_BSPSTORE         0xff // REG_MISC_BASE+9
#define REG_RNAT             0xff // REG_MISC_BASE+10

//
// Where is a preserved register saved?
//
//     1. stack general register
//     2. memory stack (pspoff)
//     3. memory stack (spoff)
//     4. branch register
//

#define GENERAL_REG          0
#define PSP_RELATIVE         1
#define SP_RELATIVE          2
#define BRANCH_REG           3


#define ADD_STATE_RECORD(States, RegionLength, DescBeginIndex)       \
    States.Top++;                                                    \
    States.Top->IsTarget = FALSE;                                    \
    States.Top->MiscMask = 0;                                        \
    States.Top->FrMask = 0;                                          \
    States.Top->GrMask = 0;                                          \
    States.Top->Label = (LABEL)0;                                    \
    States.Top->Ecount = 0;                                          \
    States.Top->RegionLen = RegionLength;                            \
    States.Top->RegionBegin = UnwindContext.SlotCount;               \
    States.Top->SpWhen = 0;                                          \
    States.Top->SpAdjustment = 0;                                    \
    States.Top->SpillBase = (States.Top-1)->SpillPtr;                \
    States.Top->SpillPtr = (States.Top-1)->SpillPtr;                 \
    States.Top->Previous = States.Current;                           \
    States.Top->DescBegin = DescBeginIndex;                          \
    States.Current = States.Top


#define VALID_LABEL_BIT_POSITION    15

#define LABEL_REGION(Region, Label)                                    \
    Region->Label = Label;                                             \
    Region->MiscMask |= (1 << VALID_LABEL_BIT_POSITION)

#define IS_REGION_LABELED(Region)  \
    (Region->MiscMask & (1 << VALID_LABEL_BIT_POSITION))

#define CHECK_LABEL(State, Label) \
    ( (IS_REGION_LABELED(State)) && (Label == State->Label) )


#define EXTRACT_NAT_FROM_UNAT(NatBit)  \
    NatBit = (UCHAR)((IntNats >> (((ULONG_PTR)Source & 0x1F8) >> 3)) & 0x1);


#define UW_DEBUG(x) SdbOut x

typedef struct _REGISTER_RECORD {
    ULONG Where : 2;                  // 2-bit field
    ULONG SaveOffset : 30;            // 30 bits for offset, big enough?
    ULONG When;                       // slot offset relative to region
} REGISTER_RECORD, *PREGISTER_RECORD;

typedef ULONG LABEL;

typedef struct _STATE_RECORD {
    struct _STATE_RECORD *Previous;   // pointer to outer nested prologue
    BOOLEAN IsTarget;       // TRUE if the control pc is in this prologue
    UCHAR GrMask;           // Mask that specifies which GRs to be restored
    USHORT MiscMask;        // Mask that specifies which BRs and misc. registers
                            // are to be restored.
                            // N.B. MSBit indicates Label is valid or not.
    ULONG FrMask;           // Mask that specifies which FRs to be restored
    ULONG SpAdjustment;     // size of stack frame allocated in the prologue
    ULONG SpWhen;           // slot offset relative to region
    ULONG SpillPtr;         // current spill location
    ULONG SpillBase;        // spill base of the region
    ULONG RegionBegin;      // first slot of region relative to function entry
    ULONG RegionLen;        // number of slots in the region
    LABEL Label;            // label that identifies a post-prologue state
    ULONG Ecount;           // number of prologue regions to pop
    ULONG DescBegin;        // first prologue descriptor for the region
    ULONG DescEnd;          // last prologue descriptor for the region
} STATE_RECORD, *PSTATE_RECORD;

typedef struct _UNWIND_CONTEXT {
    REGISTER_RECORD MiscRegs[NUMBER_OF_PRESERVED_REGISTERS];
    REGISTER_RECORD Float[NUMBER_OF_PRESERVED_FR];
    REGISTER_RECORD Integer[NUMBER_OF_PRESERVED_GR];
    BOOLEAN ActiveRegionFound;
    UCHAR AlternateRp;
    USHORT Version;
    PUCHAR Descriptors;               // beginning of descriptor data
    ULONG Size;                       // total size of all descriptors
    ULONG DescCount;                  // number of descriptor bytes processed
    ULONG TargetSlot;
    ULONG SlotCount;
} UNWIND_CONTEXT, *PUNWIND_CONTEXT;

typedef struct _STATE_RECORD_STACK {
    ULONG Size;
    PSTATE_RECORD Current;
    PSTATE_RECORD Top;
    PSTATE_RECORD Base;
} STATE_RECORD_STACK, *PSTATE_RECORD_STACK;

#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

static const USHORT MiscContextOffset[NUMBER_OF_PRESERVED_REGISTERS] = {
    OFFSET(IA64_CONTEXT, Preds),
    OFFSET(IA64_CONTEXT, IntSp),
    OFFSET(IA64_CONTEXT, RsPFS),
    OFFSET(IA64_CONTEXT, BrRp),
    OFFSET(IA64_CONTEXT, ApUNAT),
    OFFSET(IA64_CONTEXT, ApLC),
    0,
    0,
    OFFSET(IA64_CONTEXT, BrS0),
    OFFSET(IA64_CONTEXT, BrS1),
    OFFSET(IA64_CONTEXT, BrS2),
    OFFSET(IA64_CONTEXT, BrS3),
    OFFSET(IA64_CONTEXT, BrS4)
};

static const USHORT MiscContextPointersOffset[NUMBER_OF_PRESERVED_REGISTERS] = {
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, Preds),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, IntSp),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, RsPFS),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrRp),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, ApUNAT),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, ApLC),
    0,
    0,
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS0),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS1),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS2),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS3),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS4)
};

static const PSTR RegOffsetNames[NUMBER_OF_PRESERVED_REGISTERS] = {
    "Preds",
    "IntSp",
    "RsPFS",
    "BrRp",
    "ApUNAT",
    "ApLC",
    "<invalid>",
    "<invalid>",
    "BrS0",
    "BrS1",
    "BrS2",
    "BrS3",
    "BrS4",
};

static const UCHAR P3RecordTypeToRegisterIndex[] =
    {REG_SP, REG_RP, REG_PFS, REG_PREDS, REG_UNAT, REG_LC, REG_RP,
     REG_RNAT, REG_BSP, REG_BSPSTORE, REG_FPSR};

static const UCHAR P7RecordTypeToRegisterIndex[] =
    {0, REG_SP, 0, REG_SP, REG_RP, REG_RP, REG_PFS, REG_PFS, REG_PREDS,
     REG_PREDS, REG_LC, REG_LC, REG_UNAT, REG_UNAT, REG_FPSR, REG_FPSR};

static const UCHAR P8RecordTypeToRegisterIndex[] =
    {REG_SP, REG_RP, REG_PFS, REG_PREDS, REG_LC, REG_UNAT, REG_FPSR,
     REG_BSP, REG_BSP, REG_BSP, REG_BSPSTORE, REG_BSPSTORE, REG_BSPSTORE,
     REG_RNAT, REG_RNAT, REG_RNAT, REG_NATS, REG_NATS, REG_NATS};


/*++
            
Description:

    The next code defines mechanism to handle the context of
    the unwind process

--*/


/*++

Routine Description:

    Initializes the FixupTable

Arguments:

    iContext - index of the context in UnwindContext

--*/

void
Vwndia64InitFixupTable(UINT iContext)
{
    if (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        PVWNDIA64_UNWIND_CONTEXT pContext = tlsvar(UnwindContext) + iContext;
        ZeroMemory(pContext->FixupTable, sizeof(pContext->FixupTable));
    }
}


/*++

Routine Description:

    Adds new fixup region into the table

Arguments:

    iContext - index of the context in UnwindContext
    Begin, End, Fixup - fixup region data

--*/

void
Vwndia64AddFixupRegion(UINT iContext,
                       ULONGLONG Ip,
                       ULONGLONG Begin, ULONGLONG End, ULONGLONG Fixup)
{
    if (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        PVWNDIA64_UNWIND_CONTEXT pContext = tlsvar(UnwindContext) + iContext;

        PVWNDIA64_FUXUP_REGION FixupReg = pContext->FixupTable;
        PVWNDIA64_FUXUP_REGION FixupRegLast = FixupReg + 
                                              VWNDIA64_FIXUP_TABLE_SIZE;

        //
        // Search for the empty region
        //
        while (
            (FixupReg < FixupRegLast) &&
            (FixupReg->Fixup &&
                ((FixupReg->Ip != Ip) ||
                 (FixupReg->Begin != Begin) ||
                 (FixupReg->End != End) ||
                 (FixupReg->Fixup != Fixup))))
        {
            ++FixupReg;
        }

        if (FixupReg >= FixupRegLast) // not found (rare)
        {
            //
            // Scroll the table (destructive)
            //
            MoveMemory(pContext->FixupTable, 
                       pContext->FixupTable + 1,
                       sizeof(pContext->FixupTable) - 
                            sizeof(VWNDIA64_FUXUP_REGION));
            FixupReg = FixupRegLast - 1;

            UW_DEBUG((2, "AddFixup: Table overflow\n"));
        }

        FixupReg->Ip = Ip;
        FixupReg->Begin = Begin;
        FixupReg->End = End;
        FixupReg->Fixup = Fixup;

        UW_DEBUG((2, "AddFixup: IP %016I64x, "
                  "%016I64x - %016I64x -> %016I64x\n",
                  Ip, Begin, End, Fixup));
    }
    else
    {
        UW_DEBUG((2, "AddFixup: Bad context\n"));
    }
}

/*++

Routine Description:

    Fixes the address using the specified fixup table

Arguments:

    iContext - index of the context in UnwindContext
    Size - size of the buffer in bytes
    Addr - point to the address that have to be fixed

Return Value:

    Addr contains the fixed value

--*/

void
Vwndia64FixAddress(UINT iContext, IN OUT ULONGLONG* Addr)
{
    if (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        PVWNDIA64_UNWIND_CONTEXT pContext = tlsvar(UnwindContext) + iContext;
        PVWNDIA64_FUXUP_REGION FixupReg = NULL;

        UW_DEBUG((2, "FixAddr: Look for %016I64x\n", *Addr));
        
        //
        // find last containing region
        //
        {
            PVWNDIA64_FUXUP_REGION FixupSearch = pContext->FixupTable;
            PVWNDIA64_FUXUP_REGION FixupRegLast = FixupSearch + 
                                                  VWNDIA64_FIXUP_TABLE_SIZE;

            while ((FixupSearch < FixupRegLast) && FixupSearch->Fixup)
            {
                if ((FixupSearch->Begin <= *Addr) && (*Addr < FixupSearch->End))
                {
                    FixupReg = FixupSearch;
                }
                ++FixupSearch;
            }
        }

        if (FixupReg)
        {
            *Addr = FixupReg->Fixup - (FixupReg->End - *Addr);
            UW_DEBUG((2, "  Fix to %016I64x\n", *Addr));
        }
    }
    else
    {
        UW_DEBUG((2, "FixAddr: Bad context\n"));
    }
}

/*++

Routine Description:

    Checks whether specified Ip exists in fixup table

Arguments:

    iContext - index of the context in UnwindContext
    Ip - to search

Return Value:

    Addr contains the fixed value

--*/

BOOL
Vwndia64IsFixupIp(UINT iContext, ULONGLONG Ip)
{
    if (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        PVWNDIA64_UNWIND_CONTEXT pContext = tlsvar(UnwindContext) + iContext;

        PVWNDIA64_FUXUP_REGION FixupSearch = pContext->FixupTable;
        PVWNDIA64_FUXUP_REGION FixupRegLast = FixupSearch + 
                                              VWNDIA64_FIXUP_TABLE_SIZE;

        while ((FixupSearch < FixupRegLast) &&
               FixupSearch->Ip && (FixupSearch->Ip != Ip))
        {
            ++FixupSearch;
        }

        return (FixupSearch->Ip == Ip);
    }

    return FALSE;
}

/*++

Routine Description:

    Initializes the new context

Return Value:

    returns ID of the record (index in UnwindContext)

--*/

UINT
Vwndia64NewContext()
{
    UINT* iContext = &tlsvar(UnwindContextNew);
    
    if (*iContext >= VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        *iContext = 0;
    }

    Vwndia64InitFixupTable(*iContext);
    tlsvar(UnwindContext[*iContext]).bFailureReported = FALSE;

    return (*iContext)++;
}

/*++

Routine Description:

    Checks if the specified context index valid and
    creates new context if otherwise

--*/

BOOL
Vwndia64ValidateContext(UINT* iContext)
{
    if (!iContext) return FALSE;
    if (*iContext >= VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        *iContext = Vwndia64NewContext();
        return FALSE;
    }
    return TRUE;
}

/*++

Routine Description:

    Check whether any failure have been reported

Arguments:

    iContext - index of the context in UnwindContext

Return Value:

    Returns true whether any failure have been reported

--*/

BOOL
Vwndia64FailureReported(UINT iContext)
{
    PVWNDIA64_UNWIND_CONTEXT pContext;
    
    pContext = tlsvar(UnwindContext);
    return (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE) ? 
            pContext[iContext].bFailureReported : FALSE;
}

/*++

Routine Description:

    Reports failure and sets appropriate flag is the unwind context

Arguments:

    iContext - index of the context in UnwindContext;
               use (-1) to report unconditionaly

Return Value:

    none

--*/

void
Vwndia64ReportFailure(UINT iContext, LPCSTR szFormat, ...)
{
    if ((g.SymOptions & SYMOPT_DEBUG) != SYMOPT_DEBUG)
    {
        return;
    }

    if (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        PVWNDIA64_UNWIND_CONTEXT pContext = tlsvar(UnwindContext) + iContext;
        if (pContext->bFailureReported)
        {
            return;
        }
        pContext->bFailureReported = TRUE;
    }

    //
    // Printout failure
    //
    {
        char buf[1024];
        va_list args;

        va_start(args, szFormat);
        CopyStrArray(buf, "DBGHELP: ");
        _vsnprintf(buf + 9, sizeof(buf) - 11, szFormat, args);
        va_end(args);

        dprint(NULL, buf);
    }
}

UCHAR
NewParsePrologueRegionPhase0 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD StateRecord,
    IN OUT PUCHAR AbiImmContext
    );

VOID
NewParsePrologueRegionPhase1 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD StateRecord
    );


VOID
SrInitialize (
    IN PSTATE_RECORD_STACK StateTable,
    IN PSTATE_RECORD StateRecord,
    IN ULONG Size
    )
{
    StateTable->Size = Size;
    StateTable->Base = StateRecord;
    StateTable->Top = StateRecord;
    StateTable->Current = StateRecord;
    RtlZeroMemory(StateTable->Top, sizeof(STATE_RECORD));
}

ULONG
ReadLEB128 (
    IN PUCHAR Descriptors,
    IN OUT PULONG CurrentDescIndex
    )
{
    PUCHAR Buffer;
    ULONG Value;
    ULONG ShiftCount = 7;
    ULONG Count;

    Buffer = Descriptors + *CurrentDescIndex;
    Count = 1;

    Value = Buffer[0] & 0x7F;
    if (Buffer[0] & 0x80) {
        while (TRUE) {
            Value += ((Buffer[Count] & 0x7F) << ShiftCount);
            if (Buffer[Count++] & 0x80) {
                ShiftCount += 7;
            } else {
                break;
            }
        }
    }

    *CurrentDescIndex += Count;

    return Value;
}

ULONGLONG
RestorePreservedRegisterFromGR (
    IN PIA64_CONTEXT Context,
    IN SHORT BsFrameSize,
    IN SHORT RNatSaveIndex,
    IN SHORT GrNumber,
#ifdef _IMAGEHLP_SOURCE_
    IN HANDLE hProcess,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    IN UINT iContext,
    OUT BOOL *Succeed,
#else
    OUT ULONG64 *SourceAddress,
#endif // _IMAGEHLP_SOURCE_
    OUT PUCHAR Nat OPTIONAL
    )
{
    ULONGLONG Result = 0;
    SHORT Offset;
    SHORT Temp;
#ifdef _IMAGEHLP_SOURCE_
    ULONG Size;
#endif // _IMAGEHLP_SOURCE_

#ifdef _IMAGEHLP_SOURCE_
    *Succeed = FALSE;
#endif // _IMAGEHLP_SOURCE_

    if (GrNumber >= STATIC_REGISTER_SET_SIZE) {

        Offset = GrNumber - STATIC_REGISTER_SET_SIZE;
        if ( Offset < BsFrameSize ) {

            Temp = Offset + RNatSaveIndex - IA64_NAT_BITS_PER_RNAT_REG;
            while (Temp >= 0) {
                Offset++;
                Temp -= IA64_NAT_BITS_PER_RNAT_REG;
            }
            Offset = Offset * sizeof(ULONGLONG);

#ifdef _IMAGEHLP_SOURCE_
            {
                ULONGLONG Reg = (ULONGLONG)Context->RsBSP + (ULONGLONG)Offset;
                Vwndia64FixAddress(iContext, &Reg);
                *Succeed = ReadMemory(hProcess, Reg,
                                      &Result, sizeof(ULONGLONG), &Size);
            }
#else
            *SourceAddress = (ULONG64)(Context->RsBSP + Offset);
            Result = *(PULONGLONG)(Context->RsBSP + Offset);
#endif // _IMAGEHLP_SOURCE_

        } else {

            UW_DEBUG((1, "ERROR: Invalid GR!\n"));
        }

    } else {

        if (GrNumber == 0 || GrNumber == 12) {

            //
            // Invalid GR number -> Invalid Unwind Descriptor
            //

            UW_DEBUG((1, "ERROR: Invalid GR!\n"));

        } else {

            UW_DEBUG((1, "WARNING: Target register is not a stacked GR!\n"));
            Offset = GrNumber - 1;
            NOT_IMAGEHLP(*SourceAddress = (ULONG64)(&Context->IntGp + Offset));
            Result = *(&Context->IntGp + Offset);

#ifdef _IMAGEHLP_SOURCE_
            *Succeed = TRUE;
#endif // _IMAGEHLP_SOURCE_

        }
    }

    if (ARGUMENT_PRESENT(Nat)) {

        //
        // TBD: Pick up the corresponding Nat bit
        //

        *Nat = (UCHAR) 0;

    }

    return (Result);
}

UCHAR
ParseBodyRegionDescriptors (
    IN PUNWIND_CONTEXT UnwindContext,
    IN PSTATE_RECORD_STACK StateTable,
    IN ULONG RegionLen
    )
{
    LABEL Label;
    UCHAR FirstByte;
    BOOLEAN EcountDefined;
    BOOLEAN CopyLabel;
    ULONG Ecount;
    ULONG SlotOffset;
    PSTATE_RECORD StateTablePtr;
    PUCHAR Descriptors;

    CopyLabel = EcountDefined = FALSE;
    Descriptors = UnwindContext->Descriptors;

    while (UnwindContext->DescCount < UnwindContext->Size) {

        FirstByte = Descriptors[UnwindContext->DescCount++];

        if ( (FirstByte & B1_MASK) == B1_PREFIX ) {

            Label = (LABEL)(FirstByte & B1_LABEL_MASK);
            if (FirstByte & B1_TYPE_MASK) {

                //
                // copy the entry state
                //

                CopyLabel = TRUE;

            } else {

                //
                // label the entry state
                //

                LABEL_REGION(StateTable->Top, Label);
            }

            UW_DEBUG((1, "Body region desc B1: copy=%d, label_num=%d\n",
                     FirstByte & B1_TYPE_MASK ? TRUE : FALSE, Label));

        } else if ( (FirstByte & B2_MASK) == B2_PREFIX ) {

            Ecount = FirstByte & B2_ECOUNT_MASK;
            SlotOffset = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            EcountDefined = TRUE;

            UW_DEBUG((1, "Epilog desc B2: ecount=%d, LEB128(slot)=%d\n",
                      Ecount, SlotOffset));

        } else if ( (FirstByte & B3_MASK) == B3_PREFIX ) {

            SlotOffset = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            Ecount = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            EcountDefined = TRUE;

            UW_DEBUG((1, "Epilog desc B3: ecount=%d, LEB128 val=%d\n",
                      Ecount, SlotOffset));

        } else if ( (FirstByte & B4_MASK) == B4_PREFIX ) {

            Label = ReadLEB128(Descriptors, &UnwindContext->DescCount);

            if (FirstByte & B4_TYPE_MASK) {

                //
                // copy the entry state
                //

                CopyLabel = TRUE;

            } else {

                //
                // label the current top of stack
                //

                LABEL_REGION(StateTable->Top, Label);
            }

            UW_DEBUG((1, "Body region desc B4: copy=%d, label_num=%d\n",
                     FirstByte & B4_TYPE_MASK, Label));

        } else {

            //
            // Encounter another region header record
            //

            break;
        }
    }

    if (CopyLabel) {
        StateTablePtr = StateTable->Top;
        while (TRUE) {
            if (CHECK_LABEL(StateTablePtr, Label)) {
                StateTable->Current = StateTablePtr;
                break;
            } else if ((StateTablePtr == StateTable->Base)) {
                UW_DEBUG((1, "Undefined Label %d\n", Label));
                break;
            }
            StateTablePtr--;
        }
    }

    if (EcountDefined) {

        Ecount++;    // Ecount specifies additional level of prologue
                     // regions to undo (i.e. a value of 0 implies 1
                     // prologue region)

        if (UnwindContext->ActiveRegionFound == FALSE) {
            while (Ecount-- > 0) {
                if (StateTable->Current->Previous) {
                    StateTable->Current = StateTable->Current->Previous;
                }

#if DBG
                else {
                    UW_DEBUG((1, "WARNING: Ecount is greater than the # of active prologues!\n"));
                }
#endif // DBG

            }
        } else {

            //
            // control PC is in this body/epilog region
            //

            if ((UnwindContext->SlotCount + RegionLen - SlotOffset)
                    <= UnwindContext->TargetSlot)
            {
                PSTATE_RECORD SrPointer;

                StateTable->Current->Ecount = Ecount;
                SrPointer = StateTable->Current;
                while (Ecount > 0) {

                    if (SrPointer->Previous) {
                        SrPointer->Ecount = Ecount;
                        SrPointer->SpWhen = 0;
                        SrPointer->SpAdjustment = 0;
                        SrPointer = SrPointer->Previous;
                    }

#if DBG
                    else {
                        UW_DEBUG((1, "WARNING: Ecount is greater than the # of active prologues!\n"));
                    }
#endif // DBG
                    Ecount--;

                }
            }
        }
    }

    return FirstByte;
}

ULONGLONG
ProcessInterruptRegion (
#ifdef _IMAGEHLP_SOURCE_
    IN HANDLE hProcess,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    IN UINT iContext,
#else
    IN PIA64_KNONVOLATILE_CONTEXT_POINTERS ContextPointers,
#endif _IMAGEHLP_SOURCE_
    IN PUNWIND_CONTEXT UnwindContext,
    IN PIA64_CONTEXT Context,
    IN SHORT BsFrameSize,
    IN SHORT RNatSaveIndex,
    IN UCHAR AbiImmContext
    )
{
    //
    // no prologue descriptor in interrupt region.
    //

    ULONGLONG NextPc;
    ULONG Index;
    SHORT TempFrameSize;
    BOOLEAN Success;
#ifdef _IMAGEHLP_SOURCE_
    ULONG Size;
#else
    PIA64_CONTEXT PrevContext;
    PVOID *Source;
    PVOID Address;
#endif _IMAGEHLP_SOURCE_


    if (AbiImmContext != IA64_CONTEXT_FRAME) {

        PIA64_KTRAP_FRAME TrapFrame;
        PIA64_KEXCEPTION_FRAME ExFrame;
#ifdef _IMAGEHLP_SOURCE_
        IA64_KTRAP_FRAME TF;
        IA64_KEXCEPTION_FRAME ExF;
#endif // _IMAGEHLP_SOURCE_

        TrapFrame = (PIA64_KTRAP_FRAME) Context->IntSp;
#ifdef _IMAGEHLP_SOURCE_
        if (!ReadMemory(hProcess, Context->IntSp, &TF, sizeof(IA64_KTRAP_FRAME), &Size))
        {
            return 0;
        }
        TrapFrame = &TF;
#endif // _IMAGEHLP_SOURCE_

        Context->ApDCR = TrapFrame->ApDCR;
        Context->ApUNAT = TrapFrame->ApUNAT;
        Context->StFPSR = TrapFrame->StFPSR;
        Context->Preds = TrapFrame->Preds;
        Context->IntSp = TrapFrame->IntSp;
        Context->StIPSR = TrapFrame->StIPSR;
        Context->StIFS = TrapFrame->StIFS;
        Context->BrRp = TrapFrame->BrRp;
        Context->RsPFS = TrapFrame->RsPFS;

#ifndef _IMAGEHLP_SOURCE_
        if (ARGUMENT_PRESENT(ContextPointers)) {
            ContextPointers->ApUNAT = &TrapFrame->ApUNAT;
            ContextPointers->IntSp = &TrapFrame->IntSp;
            ContextPointers->BrRp = &TrapFrame->BrRp;
            ContextPointers->RsPFS = &TrapFrame->RsPFS;
            ContextPointers->Preds = &TrapFrame->Preds;
        }
#endif // _IMAGEHLP_SOURCE_

        switch (AbiImmContext) {

        case IA64_SYSCALL_FRAME:

            //
            // System Call Handler Frame
            //

            BsFrameSize = (SHORT)(TrapFrame->StIFS >> IA64_PFS_SIZE_SHIFT);
            BsFrameSize &= IA64_PFS_SIZE_MASK;
            break;

        case IA64_INTERRUPT_FRAME:
        case IA64_EXCEPTION_FRAME:

            //
            // External Interrupt Frame / Exception Frame
            //

            BsFrameSize = (SHORT)TrapFrame->StIFS & IA64_PFS_SIZE_MASK;
            break;

        default:

            break;
        }

        RNatSaveIndex = (SHORT)(TrapFrame->RsBSP >> 3) & IA64_NAT_BITS_PER_RNAT_REG;
        TempFrameSize = BsFrameSize - RNatSaveIndex;
        while (TempFrameSize > 0) {
            BsFrameSize++;
            TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
        }

        NextPc = Ia64InsertIPSlotNumber(TrapFrame->StIIP,
                     ((TrapFrame->StIPSR >> PSR_RI) & 0x3));

#ifdef _IMAGEHLP_SOURCE_
        if (TrapFrame->RsBSP != Context->RsBSP &&
            TrapFrame->RsBSP != Context->RsBSP +
            BsFrameSize * sizeof(ULONGLONG)) {
            ULONG64 Fixup = Context->RsBSP;
            if ((TrapFrame->RsBSP & 0x1ff) ==
                ((Fixup + BsFrameSize * sizeof(ULONGLONG)) & 0x1ff)) {
                Fixup += BsFrameSize * sizeof(ULONGLONG);
            }
            Vwndia64AddFixupRegion(iContext,
                                   NextPc,
                                   TrapFrame->RsBSPSTORE, TrapFrame->RsBSP,
                                   Fixup);
        }
#endif // _IMAGEHLP_SOURCE_

        Context->RsBSP = TrapFrame->RsBSP - BsFrameSize * sizeof(ULONGLONG);
        Context->RsBSPSTORE = Context->RsBSP;
        Context->RsRNAT = TrapFrame->RsRNAT;

        return (NextPc);
    }

    //
    // Kernel-to-User thunk, context of the previous frame can be
    // found on the user stack (i.e. context's address = sp+SCRATCH_AREA)
    //

#ifdef _IMAGEHLP_SOURCE_
    if (!ReadMemory(hProcess,
                    Context->IntSp + IA64_STACK_SCRATCH_AREA,
                    Context,
                    sizeof(IA64_CONTEXT),
                    &Size))
    {
        return 0;
    }
    NextPc = Ia64InsertIPSlotNumber(Context->StIIP,
                                       ((Context->StIPSR >> PSR_RI) & 0x3));
#else

    PrevContext = (PIA64_CONTEXT)(Context->IntSp + IA64_STACK_SCRATCH_AREA);

    RtlCopyMemory(&Context->BrRp, &PrevContext->BrRp,
                  (NUMBER_OF_PRESERVED_BR+3) * sizeof(ULONGLONG));
    RtlCopyMemory(&Context->FltS0, &PrevContext->FltS0,
                  NUMBER_OF_LOW_PRESERVED_FR * sizeof(FLOAT128));
    RtlCopyMemory(&Context->FltS4, &PrevContext->FltS4,
                  NUMBER_OF_HIGH_PRESERVED_FR * sizeof(FLOAT128));
    RtlCopyMemory(&Context->IntS0, &PrevContext->IntS0,
                  NUMBER_OF_PRESERVED_GR * sizeof(ULONGLONG));
    RtlCopyMemory(&Context->IntV0, &PrevContext->IntV0,                  
                  NUMBER_OF_SCRATCH_GR * sizeof(ULONGLONG));
    Context->IntT0 = PrevContext->IntT0;    
    Context->IntT1 = PrevContext->IntT1;    

    Context->IntSp = PrevContext->IntSp;
    Context->IntNats = PrevContext->IntNats;
    Context->ApUNAT = PrevContext->ApUNAT;
    Context->ApLC = PrevContext->ApLC;
    Context->ApEC = PrevContext->ApEC;
    Context->Preds = PrevContext->Preds;
    Context->RsPFS = PrevContext->RsPFS;
    Context->RsBSP = PrevContext->RsBSP;
    Context->RsBSPSTORE = PrevContext->RsBSPSTORE;
    Context->RsRSC = PrevContext->RsRSC;
    Context->RsRNAT = PrevContext->RsRNAT;
    Context->StIFS = PrevContext->StIFS;
    Context->StIPSR = PrevContext->StIPSR;
    NextPc = Ia64InsertIPSlotNumber(PrevContext->StIIP,
                 ((PrevContext->StIPSR >> PSR_RI) & 0x3));

#endif // _IMAGEHLP_SOURCE_

    return(NextPc);
}


#ifdef _IMAGEHLP_SOURCE_

BOOL
IsValidUnwindInfo64 (
    const IA64_UNWIND_INFO* pUnwindInfo
    )
/*++

Routine Description:

    This function validates the unwind info record

Return Value:

    returns false if record looks like invalid
--*/

{
    if (!pUnwindInfo) return FALSE;

    switch (pUnwindInfo->Version) {
    case 1:
    case 2:
    case 3: 
        if (
            !pUnwindInfo->DataLength ||
            (pUnwindInfo->DataLength > ((1024 / sizeof(ULONG64)) * 64)))
        {
            return FALSE;
        }
        break;
    default:
        return FALSE;
    } // switch

    return TRUE;
} // IsValidUnwindInfo64

BOOL 
GetUnwindInfo(
    IN HANDLE hProcess,
    IN ULONGLONG ImageBase,
    IN ULONG UnwindInfoAddress,

    IN OUT PIA64_UNWIND_INFO UnwindInfo,
    IN OUT PUCHAR* Descriptors,
    IN OUT PULONG DescriptorsSize,

    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    )
{
    ULONG BytesRead = 0;

    //
    // try to get UnwindInfo from the image
    //
    ULONG64 UnwindInfoPtr = ImageBase + UnwindInfoAddress;

    if (ReadMemory(hProcess, UnwindInfoPtr, 
                   UnwindInfo, sizeof(*UnwindInfo), &BytesRead) &&
        (BytesRead == sizeof(*UnwindInfo)) &&
        IsValidUnwindInfo64(UnwindInfo))
    {
        if (!Descriptors)
        {
            return TRUE;
        }

        if (!UnwindInfo->DataLength) 
        {
            *Descriptors = NULL;
            *DescriptorsSize = 0;
            return TRUE;
        }

        ULONG Size = UnwindInfo->DataLength * sizeof(ULONGLONG);
        *Descriptors = (PUCHAR)MemAlloc(Size);

        if (*Descriptors &&
            ReadMemory(hProcess, 
                       UnwindInfoPtr + sizeof(*UnwindInfo), 
                       *Descriptors, Size, &BytesRead) &&
            BytesRead == Size) 
        {
            if (DescriptorsSize) 
            {
                *DescriptorsSize = Size;
            }
            return TRUE;
        }
        MemFree(*Descriptors);
    }

    //
    // try to get UnwindInfo from the symbols
    //
    ULONG XDataSize;
    PBYTE pXData = 
        (PBYTE)GetUnwindInfoFromSymbols(hProcess, 
                                        ImageBase, 
                                        UnwindInfoAddress, 
                                        &XDataSize);

    if (pXData && (XDataSize >= sizeof(*UnwindInfo))) 
    {
        memcpy(UnwindInfo, pXData, sizeof(*UnwindInfo));

        if (IsValidUnwindInfo64(UnwindInfo)) 
        {
            if (!Descriptors)
            {
                return TRUE;
            }

            if (!UnwindInfo->DataLength)
            {
                *Descriptors = NULL;
                *DescriptorsSize = 0;
                return TRUE;
            }

            ULONG Size = UnwindInfo->DataLength * sizeof(ULONG64);

            if (Size <= (XDataSize - sizeof(*UnwindInfo)))
            {
                *Descriptors = (PUCHAR)MemAlloc(Size);
                if (*Descriptors)
                {
                    memcpy(*Descriptors, 
                           pXData + sizeof(*UnwindInfo), 
                           Size);

                    if (DescriptorsSize) 
                    {
                        *DescriptorsSize = Size;
                    }

                    return TRUE;
                }
                MemFree(*Descriptors);
            }
        }
    }

    return FALSE;
}
#endif // defined(_IMAGEHLP_SOURCE_)

ULONGLONG
RtlVirtualUnwind (
#ifdef _IMAGEHLP_SOURCE_
    IN  HANDLE hProcess,
    IN  ULONGLONG ImageBase,
    IN  ULONGLONG ControlPc,
    IN  PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    OUT PIA64_CONTEXT ContextRecord,
    IN  PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    IN  UINT iContext
#define ContextPointers ((PIA64_KNONVOLATILE_CONTEXT_POINTERS)0)
#else
    IN ULONGLONG ImageBase,
    IN ULONGLONG ControlPc,
    IN PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    IN OUT PIA64_CONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PFRAME_POINTERS EstablisherFrame,
    IN OUT PIA64_KNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
#endif
    )

/*++

Routine Description:

    This function virtually unwinds the specfified function by executing its
    prologue code backwards.

    If the function is a leaf function, then the address where control left
    the previous frame is obtained from the context record. If the function
    is a nested function, but not an exception or interrupt frame, then the
    prologue code is executed backwards and the address where control left
    the previous frame is obtained from the updated context record.

    Otherwise, an exception or interrupt entry to the system is being unwound
    and an especially coded prologue restores the return address twice. Once
    from the fault instruction address and once from the saved return address
    register. The first restore is returned as the function value and the
    second restore is placed in the updated context record.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    ImageBase - Supplies the base address of the module to which the
        function belongs.

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    InFunction - Supplies a pointer to a variable that receives whether the
        control PC is within the current function.

    EstablisherFrame - Supplies a pointer to a variable that receives the
        the establisher frame pointer value.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    The address where control left the previous frame is returned as the
    function value.

--*/

{
#ifdef _IMAGEHLP_SOURCE_
    BOOL Succeed;
#endif // _IMAGEHLP_SOURCE_
    PUCHAR Descriptors = NULL;
    UCHAR AbiImmContext = 0xFF;
    ULONG Mask;
    ULONGLONG NextPc;
    ULONG RegionLen;
    UCHAR FirstByte;
    UCHAR Nat;
    SHORT BsFrameSize;                  // in 8-byte units
    SHORT LocalFrameSize;                  // in 8-byte units
    SHORT TempFrameSize;                // in 8-byte units
    SHORT RNatSaveIndex;
    ULONG i;
    PULONG Buffer;
    BOOLEAN IsPrologueRegion;
    BOOLEAN PspRestored;
    ULONGLONG PreviousIntSp;
    PVOID Destination;
    ULONG64 Source;
    ULONG64 *CtxPtr;
    ULONG64 *NatCtxPtr;
    ULONG64 IntNatsSource;
    ULONG64 IntNats;
    ULONG Size;
    ULONG DescrSize;
    ULONGLONG OldTopRnat;
    ULONGLONG NewTopRnat;
    UNWIND_CONTEXT UnwindContext;
    PSTATE_RECORD SrPointer;
    STATE_RECORD_STACK StateTable;
    STATE_RECORD StateRecords[STATE_RECORD_STACK_SIZE];

    BsFrameSize = (SHORT)ContextRecord->StIFS & IA64_PFS_SIZE_MASK;
    RNatSaveIndex = (SHORT)(ContextRecord->RsBSP >> 3) & IA64_NAT_BITS_PER_RNAT_REG;
    TempFrameSize = RNatSaveIndex + BsFrameSize - IA64_NAT_BITS_PER_RNAT_REG;
    while (TempFrameSize >= 0) {
        BsFrameSize++;
        TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
    }

#ifdef _IMAGEHLP_SOURCE_
    {
        IA64_UNWIND_INFO UnwindInfo;
        if (!GetUnwindInfo(hProcess, ImageBase, FunctionEntry->UnwindInfoAddress, 
                          &UnwindInfo, &Descriptors, &Size, 
                          ReadMemory))
        {
            Vwndia64ReportFailure(-1, 
                                  "Can't read Unwind Info - "
                                      "StackWalk can not continue\n");
            return 0;
        }

        UnwindContext.Version = UnwindInfo.Version;
    }
#else
    {
        ULONG64 UnwindInfoPtr = ImageBase + FunctionEntry->UnwindInfoAddress;
        UnwindContext.Version = ((PIA64_UNWIND_INFO)UnwindInfoPtr)->Version;
        Size = ((PIA64_UNWIND_INFO)UnwindInfoPtr)->DataLength * sizeof(ULONGLONG);
        Descriptors = (PUCHAR)UnwindInfoPtr + sizeof(IA64_UNWIND_INFO);
    }
#endif // _IMAGEHLP_SOURCE_

    UnwindContext.Size = Size;
    UnwindContext.ActiveRegionFound = FALSE;
    UnwindContext.AlternateRp = 0;
    UnwindContext.DescCount = 0;
    UnwindContext.SlotCount = 0;
    UnwindContext.TargetSlot = (ULONG)(((ControlPc - FunctionEntry->BeginAddress - ImageBase) >> 4) * SLOTS_PER_BUNDLE + ((ControlPc >> 2) & 0x3));
    UnwindContext.Descriptors = Descriptors;

    SrInitialize(&StateTable, StateRecords, STATE_RECORD_STACK_SIZE);

    if (Size) {
        FirstByte = Descriptors[UnwindContext.DescCount++];
    }


    while ( (UnwindContext.DescCount < UnwindContext.Size) &&
            (!UnwindContext.ActiveRegionFound) )
    {

        //
        // Assume a prologue region but not an interrupt region.
        //

        IsPrologueRegion = TRUE;

        //
        // Based on the type of region header, dispatch
        // to the corresponding routine that processes
        // the succeeding descriptors until the next
        // region header record.
        //

        if ((FirstByte & R1_MASK) == R1_PREFIX) {

            //
            // region header record in short format
            //

            RegionLen = FirstByte & R1_LENGTH_MASK;

            if (FirstByte & R1_REGION_TYPE_MASK) {
                IsPrologueRegion = FALSE;
            } else {
                ADD_STATE_RECORD(StateTable, RegionLen, UnwindContext.DescCount);
            }

            UW_DEBUG((1, "Region R1 format: body=%x, length=%d\n",
                     IsPrologueRegion ? 0 : 1, RegionLen));

        } else if ((FirstByte & R2_MASK) == R2_PREFIX) {

            //
            // general prologue region header
            // N.B. Skip the 2nd byte of the header and proceed to read
            //      the region length; the header descriptors will be
            //      processed again in phase 1.
            //

            ULONG R2DescIndex;

            R2DescIndex = UnwindContext.DescCount - 1;
            UnwindContext.DescCount++;
            RegionLen = ReadLEB128(Descriptors, &UnwindContext.DescCount);
            ADD_STATE_RECORD(StateTable, RegionLen, R2DescIndex);
            UW_DEBUG((1, "Region R2: body=0, length=%d\n", RegionLen));

        } else if ((FirstByte & R3_MASK) == R3_PREFIX) {

            //
            // region header record in long format
            //

            RegionLen = ReadLEB128(Descriptors, &UnwindContext.DescCount);

            switch (FirstByte & R3_REGION_TYPE_MASK) {

            case 0:      // prologue region header

                ADD_STATE_RECORD(StateTable, RegionLen, UnwindContext.DescCount);
                break;

            case 1:      // body region header

                IsPrologueRegion = FALSE;
                break;

            }

            UW_DEBUG((1, "Region R3: body=%x, length=%d\n",
                      IsPrologueRegion ? 0 : 1, RegionLen));

        } else {

            //
            // Not a region header record -> Invalid unwind descriptor.
            //

            UW_DEBUG((1, "Invalid unwind descriptor!\n"));

        }

        if (UnwindContext.TargetSlot < (UnwindContext.SlotCount + RegionLen)) {
            UnwindContext.ActiveRegionFound = TRUE;
            StateTable.Current->IsTarget = IsPrologueRegion;
        }

        if (IsPrologueRegion) {
            FirstByte = NewParsePrologueRegionPhase0(&UnwindContext,
                                                     StateTable.Current,
                                                     &AbiImmContext);
        } else {
            FirstByte = ParseBodyRegionDescriptors(&UnwindContext,
                                                   &StateTable,
                                                   RegionLen);
        }

        UnwindContext.SlotCount += RegionLen;
    }

    //
    // Restore the value of psp and save the current NatCr.
    // N.B. If the value is restored from stack/bstore, turn off the
    //      corresponding sp bit in the saved mask associated with the
    //      prologue region in which psp is saved.
    //

    if (ARGUMENT_PRESENT(ContextPointers)) {
        IntNatsSource = (ULONG64)ContextPointers->ApUNAT;
    }
    IntNats = ContextRecord->ApUNAT;
    PreviousIntSp = ContextRecord->IntSp;
    PspRestored = FALSE;

    SrPointer = StateTable.Current;
    while (SrPointer != StateTable.Base) {
        NewParsePrologueRegionPhase1(&UnwindContext, SrPointer);

        if (SrPointer->MiscMask & (1 << REG_SP)) {
            if (UnwindContext.MiscRegs[REG_SP].Where == GENERAL_REG) {
                PreviousIntSp = RestorePreservedRegisterFromGR (
                                    ContextRecord,
                                    BsFrameSize,
                                    RNatSaveIndex,
                                    (SHORT)UnwindContext.MiscRegs[REG_SP].SaveOffset,
#ifdef _IMAGEHLP_SOURCE_
                                    hProcess,
                                    ReadMemory,
                                    iContext,
                                    &Succeed,
#else
                                    &Source,
#endif // _IMAGEHLP_SOURCE_
                                    &Nat
                                    );
#ifdef _IMAGEHLP_SOURCE_
                if (!Succeed) {
                    return 0;
                }

                UW_DEBUG((1, "Restored IntSp to %I64x\n", PreviousIntSp));
                
#endif // _IMAGEHLP_SOURCE_

            } else {

                Source = ContextRecord->IntSp + UnwindContext.MiscRegs[REG_SP].SaveOffset*4;
#ifdef _IMAGEHLP_SOURCE_
                if (!ReadMemory(hProcess, (ULONG64)(Source), &PreviousIntSp, sizeof(ULONGLONG), &Size)) {
                    return 0;
                }
#else
                PreviousIntSp = *(PULONGLONG)Source;
#endif // _IMAGEHLP_SOURCE_
                EXTRACT_NAT_FROM_UNAT(Nat);

            }
            ContextRecord->IntNats &= ~(0x1 << STACK_POINTER_GR);
            ContextRecord->IntNats |= (Nat << STACK_POINTER_GR);
            SrPointer->MiscMask &= ~(1 << REG_SP);
            if (ARGUMENT_PRESENT(ContextPointers)) {
                CtxPtr = (ULONG64 *)((ULONG_PTR)ContextPointers +
                                   MiscContextPointersOffset[REG_SP]);
                *CtxPtr = Source;
            }
            PspRestored = TRUE;
        }
        if (PspRestored == FALSE) {
            PreviousIntSp += SrPointer->SpAdjustment * 4;
        }
        SrPointer = SrPointer->Previous;
    }

    if (AbiImmContext != 0xFF) {

        ContextRecord->IntSp = PreviousIntSp;  // trap/context frame address
        NextPc = ProcessInterruptRegion(
#ifdef _IMAGEHLP_SOURCE_
                     hProcess,
                     ReadMemory,
                     iContext,
#else
                     ContextPointers,
#endif _IMAGEHLP_SOURCE_
                     &UnwindContext,
                     ContextRecord,
                     BsFrameSize,
                     RNatSaveIndex,
                     AbiImmContext);

        goto FastExit;
    }

    //
    // Restore the contents of any preserved registers saved in this frame.
    //

    SrPointer = StateTable.Current;
    while (SrPointer != StateTable.Base) {

        Mask = SrPointer->MiscMask;
        UW_DEBUG((1, "MiscMask = 0x%x\n", Mask));

        for (i = 0; i < NUMBER_OF_PRESERVED_REGISTERS; i++) {
            Destination = (PVOID)((ULONG_PTR)ContextRecord + MiscContextOffset[i]);
            if (Mask & 0x1) {

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    CtxPtr = (ULONG64 *)((ULONG_PTR)ContextPointers +
                                       MiscContextPointersOffset[i]);
                    Source = *CtxPtr;
                }

                if (UnwindContext.MiscRegs[i].Where == GENERAL_REG) {

                    *(PULONGLONG)Destination =
                        RestorePreservedRegisterFromGR (
                            ContextRecord,
                            BsFrameSize,
                            RNatSaveIndex,
                            (SHORT)UnwindContext.MiscRegs[i].SaveOffset,
#ifdef _IMAGEHLP_SOURCE_
                            hProcess,
                            ReadMemory,
                            iContext,
                            &Succeed,
#else
                            &Source,
#endif // _IMAGEHLP_SOURCE_
                            NULL
                            );
#ifdef _IMAGEHLP_SOURCE_
                    if (!Succeed) {
                        *(PULONGLONG)Destination = 0;
                    } else {
                        UW_DEBUG((1, "Restored %s to %I64x\n",
                                  RegOffsetNames[i],
                                  *(PULONGLONG)Destination));
                    }

#endif // _IMAGEHLP_SOURCE_

                } else if (UnwindContext.MiscRegs[i].Where == BRANCH_REG) {

                    //
                    // restore return pointer from branch register
                    //

                    USHORT Offset;

                    Offset = (USHORT)UnwindContext.MiscRegs[i].SaveOffset-FIRST_PRESERVED_BR;
                    Source = (ULONG64)(&ContextRecord->BrS0 + Offset);
#ifdef _IMAGEHLP_SOURCE_
                    Vwndia64FixAddress(iContext, &Source);

                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        *(PULONGLONG)Destination = 0;
                    } else {
                        UW_DEBUG((1, "Restored %s to %I64x\n",
                                  RegOffsetNames[i],
                                  *(PULONGLONG)Destination));
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_

                } else if (UnwindContext.MiscRegs[i].Where == PSP_RELATIVE) {

                    if ((SrPointer->Ecount == 0) || (UnwindContext.MiscRegs[i].SaveOffset <= (IA64_STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                        Source = PreviousIntSp + IA64_STACK_SCRATCH_AREA
                                     - UnwindContext.MiscRegs[i].SaveOffset*4;

                        if (i == REG_NATS) {
                            Destination = (PVOID)&IntNats;
                            IntNatsSource = Source;
                        }

#ifdef _IMAGEHLP_SOURCE_
                        if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                            *(PULONGLONG)Destination = 0;
                        } else {
                            UW_DEBUG((1, "Restored %s to %I64x\n",
                                      RegOffsetNames[i],
                                      *(PULONGLONG)Destination));
                        }
#else
                        *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_
                    }

                } else if (UnwindContext.MiscRegs[i].Where == SP_RELATIVE) {

                    //
                    // Make the necessary adjustment depending on whether
                    // the preserved register is saved before or after the
                    // stack pointer has been adjusted in this prologue.
                    //

                    if (UnwindContext.MiscRegs[i].When >= SrPointer->SpWhen && SrPointer->RegionLen != 0)
                    {
                        Source = ContextRecord->IntSp 
                            + UnwindContext.MiscRegs[i].SaveOffset*4;
                    }
                    else {
                        Source = ContextRecord->IntSp + SrPointer->SpAdjustment*4 
                            + UnwindContext.MiscRegs[i].SaveOffset*4;
                    }

                    if (i == REG_NATS) {
                        Destination = (PVOID)&IntNats;
                        IntNatsSource = Source;
                    }

#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        *(PULONGLONG)Destination = 0;
                    } else {
                        UW_DEBUG((1, "Restored %s to %I64x\n",
                                  RegOffsetNames[i],
                                  *(PULONGLONG)Destination));
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_
                }

                if (ARGUMENT_PRESENT(ContextPointers) && (i != REG_NATS)) {
                    *CtxPtr = Source;
                }

            } else if (Mask == 0) {

                //
                // No more registers to restore
                //

                break;
            }

            Mask = Mask >> 1;
        }

        //
        // Restore preserved FRs (f2 - f5, f16 - f31)
        //

        Mask = SrPointer->FrMask;
        Destination = (PVOID)&ContextRecord->FltS0;
        CtxPtr = (ULONG64 *)&ContextPointers->FltS0;

        UW_DEBUG((1, "FrMask = 0x%x\n", Mask));
        for (i = 0; i < NUMBER_OF_PRESERVED_FR; i++) {
            if (Mask & 0x1) {

                if ((SrPointer->Ecount == 0) || (UnwindContext.Float[i].SaveOffset <= (IA64_STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                    Source = PreviousIntSp + IA64_STACK_SCRATCH_AREA
                                 - UnwindContext.Float[i].SaveOffset*4;
#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(FLOAT128), &Size)) {
                        *(PULONGLONG)Destination = 0;
                    }
#else
                    *(FLOAT128 *)Destination = *(FLOAT128 *)Source;
#endif // _IMAGEHLP_SOURCE_

                    if (ARGUMENT_PRESENT(ContextPointers)) {
                        *CtxPtr = Source;
                    }
                }

            } else if (Mask == 0) {
                break;
            }

            Mask = Mask >> 1;

            if (i == (NUMBER_OF_LOW_PRESERVED_FR - 1)) {
                Destination = (PVOID)&ContextRecord->FltS4;
                CtxPtr = (ULONG64 *)(&ContextPointers->FltS4);
            } else {
                Destination = (PVOID)((FLOAT128 *)Destination+1);
                CtxPtr++;
            }
        }

        //
        // Restore preserved GRs (r4 - r7)
        //

        Mask = SrPointer->GrMask;
        Destination = (PVOID)&ContextRecord->IntS0;
        CtxPtr = (ULONG64 *)&ContextPointers->IntS0;
        NatCtxPtr = (ULONG64 *)&ContextPointers->IntS0Nat;

        UW_DEBUG((1, "GrMask = 0x%x\n", Mask));
        for (i = 0; i < NUMBER_OF_PRESERVED_GR; i++)
        {
            if (Mask & 0x1) {

                if ((SrPointer->Ecount == 0) || (UnwindContext.Integer[i].SaveOffset <= (IA64_STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                    Source = PreviousIntSp + IA64_STACK_SCRATCH_AREA
                                 - UnwindContext.Integer[i].SaveOffset*4;

#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        *(PULONGLONG)Destination = 0;
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)Source;
#endif // _IMAGEHLP_SOURCE_
                    EXTRACT_NAT_FROM_UNAT(Nat);
                    Nat = (UCHAR)((IntNats >> (((ULONG_PTR)Source & 0x1F8) >> 3)) & 0x1);
                    ContextRecord->IntNats &= ~(0x1 << (i+FIRST_PRESERVED_GR));
                    ContextRecord->IntNats |= (Nat << (i+FIRST_PRESERVED_GR));

#ifndef _IMAGEHLP_SOURCE_
                    if (ARGUMENT_PRESENT(ContextPointers)) {
                        *CtxPtr = Source;
                        *NatCtxPtr = IntNatsSource;
                    }
#endif
                }

            } else if (Mask == 0) {
                break;
            }

            Mask = Mask >> 1;
            Destination = (PVOID)((PULONGLONG)Destination+1);
            CtxPtr++;
            NatCtxPtr++;
        }

        ContextRecord->IntSp += SrPointer->SpAdjustment * 4;
        SrPointer = SrPointer->Previous;
    }

    ContextRecord->IntSp = PreviousIntSp;

    //
    // Restore the value of the epilogue count from the PFS
    //

    ContextRecord->ApEC = (ContextRecord->RsPFS >> IA64_PFS_EC_SHIFT) &
                               ~(((ULONGLONG)1 << IA64_PFS_EC_SIZE) - 1);
    if (ARGUMENT_PRESENT(ContextPointers)) {
        ContextPointers->ApEC = ContextPointers->RsPFS;
    }


FastExit:

    NOT_IMAGEHLP(*InFunction = TRUE);
    NOT_IMAGEHLP(EstablisherFrame->MemoryStackFp = ContextRecord->IntSp);
    NOT_IMAGEHLP(EstablisherFrame->BackingStoreFp = ContextRecord->RsBSP);

#ifdef _IMAGEHLP_SOURCE_
    if (Descriptors)
        MemFree(Descriptors);
#endif // _IMAGEHLP_SOURCE_

    if (AbiImmContext == 0xFF) {

        NextPc = *(&ContextRecord->BrRp + UnwindContext.AlternateRp);
#ifndef _IMAGEHLP_SOURCE_
        NextPc = RtlIa64InsertIPSlotNumber((NextPc-0x10), 2);
#endif // _IMAGEHLP_SOURCE_

        //
        // determine the local frame size of previous frame and compute
        // the new bsp.
        //

        OldTopRnat = (ContextRecord->RsBSP+(BsFrameSize-1)*8) | IA64_RNAT_ALIGNMENT;

        ContextRecord->StIFS = MASK(IA64_IFS_V, (ULONGLONG)1) | ContextRecord->RsPFS;
        BsFrameSize = (SHORT)ContextRecord->StIFS & IA64_PFS_SIZE_MASK;
        LocalFrameSize = (SHORT)(ContextRecord->StIFS >> IA64_PFS_SIZE_SHIFT) & IA64_PFS_SIZE_MASK;
        TempFrameSize = LocalFrameSize - RNatSaveIndex;
        while (TempFrameSize > 0) {
            LocalFrameSize++;
            BsFrameSize++;
            TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
        }
        ContextRecord->RsBSP -= LocalFrameSize * 8;
        ContextRecord->RsBSPSTORE = ContextRecord->RsBSP;

        //
        // determine if the RNAT field needs to be updated.
        //

        NewTopRnat = (ContextRecord->RsBSP+(BsFrameSize-1)*8) | IA64_RNAT_ALIGNMENT;

        if (NewTopRnat < OldTopRnat) {

#ifdef _IMAGEHLP_SOURCE_
            Destination = &ContextRecord->RsRNAT;
            Source = NewTopRnat;
            if (!ReadMemory(hProcess, (ULONG64)Source, Destination, 8, &Size)) {
                *(PULONGLONG)Destination = 0;
            }
#else
            ContextRecord->RsRNAT = *(PULONGLONG)(NewTopRnat);
#endif // _IMAGEHLP_SOURCE_

        }
    }

#ifdef _IMAGEHLP_SOURCE_
    UW_DEBUG((1, "NextPc = 0x%I64x, PSP = 0x%I64x, BSP = 0x%I64x\n",
               (ULONGLONG)NextPc,
               (ULONGLONG)ContextRecord->IntSp,
               (ULONGLONG)ContextRecord->RsBSP));
#else
    UW_DEBUG((1, "NextPc = 0x%I64x, PSP = 0x%I64x, BSP = 0x%I64x\n",
               (ULONGLONG)NextPc,
               EstablisherFrame->MemoryStackFp,
               EstablisherFrame->BackingStoreFp));
#endif // _IMAGEHLP_SOURCE_
    return (NextPc);
}

UCHAR
NewParsePrologueRegionPhase0 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD State,
    IN OUT PUCHAR AbiImmContext
    )
{
    PUCHAR Desc = UwContext->Descriptors;
    ULONG Offset;
    ULONG FrameSize;
    ULONG Index;
    UCHAR RecType;
    UCHAR FirstByte;
    UCHAR SecondByte;
    ULONG GrSave;
    ULONG TempMask;
    ULONG i;

    FirstByte = 0;

    while (UwContext->DescCount < UwContext->Size) {

        FirstByte = Desc[UwContext->DescCount++];

        if ( (FirstByte & P1_MASK) == P1_PREFIX) {

            continue;

        } else if ( (FirstByte & P2_MASK) == P2_PREFIX ) {

            UwContext->DescCount++;

        } else if ( (FirstByte & P3_MASK) == P3_PREFIX ) {

            UwContext->DescCount++;

        } else if ( (FirstByte & P4_MASK) == P4_PREFIX ) {

            UwContext->DescCount += ((State->RegionLen+3) >> 2);

        } else if ( (FirstByte & P5_MASK) == P5_PREFIX ) {

            UwContext->DescCount += 3;

        } else if ( (FirstByte & P6_MASK) == P6_PREFIX ) {

            continue;

        } else if ( (FirstByte & P7_MASK) == P7_PREFIX ) {

            RecType = FirstByte & ~P7_MASK;

            switch (RecType) {

            case MEM_STACK_F:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                FrameSize = ReadLEB128(Desc, &UwContext->DescCount);

                if (UwContext->TargetSlot > (UwContext->SlotCount+Offset) || State->RegionLen == 0)
                {
                    State->SpAdjustment += FrameSize*4;
                    State->SpWhen = Offset;
                }
                break;

            case SPILL_BASE:

                State->SpillBase = ReadLEB128(Desc, &UwContext->DescCount);
                State->SpillPtr = State->SpillBase;
                break;

            case MEM_STACK_V:
            case RP_WHEN:
            case PFS_WHEN:
            case PREDS_WHEN:
            case LC_WHEN:
            case UNAT_WHEN:
            case FPSR_WHEN:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                if ((State->IsTarget) &&
                    (UwContext->TargetSlot > (UwContext->SlotCount+Offset)))
                {
                    Index = P7RecordTypeToRegisterIndex[RecType];
                    if (!(State->MiscMask & (1 << Index))) {
                        State->MiscMask |= MASK(Index,1);
                        UwContext->MiscRegs[Index].When = Offset;
                    } else {
                        UW_DEBUG((1, "Duplicate descriptors,"));
                        UW_DEBUG((1, "unwinder may produce incorrect result!\n"));
                    }
                }
                UW_DEBUG((1, "Prolog P7: type=%d slot= %d\n", RecType, Offset));
                break;

            case PSP_SPREL:
            case RP_PSPREL:
            case PFS_PSPREL:
            case PREDS_PSPREL:
            case LC_PSPREL:
            case UNAT_PSPREL:
            case FPSR_PSPREL:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                break;

            default:

                UW_DEBUG((1, "Invalid record type for descriptor P7!\n"));

            }

        } else if ( (FirstByte & P8_MASK) == P8_PREFIX ) {

            RecType = Desc[UwContext->DescCount++];

            switch (RecType) {

            case PSP_PSPREL:
            case RP_SPREL:
            case PFS_SPREL:
            case PREDS_SPREL:
            case LC_SPREL:
            case UNAT_SPREL:
            case FPSR_SPREL:
            case BSP_PSPREL:
            case BSP_SPREL:
            case BSPSTORE_PSPREL:
            case BSPSTORE_SPREL:
            case RNAT_PSPREL:
            case RNAT_SPREL:
            case PRIUNAT_PSPREL:
            case PRIUNAT_SPREL:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                UW_DEBUG((1, "Prolog P8: type=%d slot= %d\n", RecType, Offset));
                break;

            case BSP_WHEN:
            case BSPSTORE_WHEN:
            case RNAT_WHEN:
            case PRIUNAT_WHEN:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                if ((State->IsTarget) &&
                    (UwContext->TargetSlot > (UwContext->SlotCount+Offset)))
                {
                    Index = P7RecordTypeToRegisterIndex[RecType];
                    if (!(State->MiscMask & (1 << Index))) {
                        State->MiscMask |= MASK(Index,1);
                        UwContext->MiscRegs[Index].When = Offset;
                    } else {
                        UW_DEBUG((1, "Duplicate descriptors,"));
                        UW_DEBUG((1, "unwinder may produce incorrect result!\n"));
                    }
                }
                UW_DEBUG((1, "Prolog P8: type=%d slot= %d\n", RecType, Offset));
                break;

            default:

                UW_DEBUG((1, "Invalid record type for descriptor P8!\n"));

            }

        } else if ( (FirstByte & P9_MASK) == P9_PREFIX ) {

            UwContext->DescCount += 2;
            VUW_DEBUG_PRINT("Format P9 not supported yet!\n");

        } else if ( (FirstByte & P10_MASK) == P10_PREFIX ) {

            UCHAR Abi = Desc[UwContext->DescCount++];
            UCHAR Context = Desc[UwContext->DescCount++];

            *AbiImmContext = Context;

            if (Abi != NT_ABI) {
                VUW_DEBUG_PRINT("Unknown ABI unwind descriptor\n");
            }

        } else {

            //
            // Encounter another region header record
            //

            break;
        }
    }

    State->DescEnd = UwContext->DescCount - 2;

    return FirstByte;
}

VOID
NewParsePrologueRegionPhase1 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD State
    )
{
    ULONG FrameSize;
    ULONG Offset;
    ULONG GrSave;
    ULONG BrBase;
    ULONG Index;
    ULONG Count;
    UCHAR RecType;
    UCHAR FirstByte, SecondByte;   // 1st & 2nd bytes of a region header record
    ULONG DescIndex;
    ULONG ImaskBegin;
    UCHAR NextBr, NextGr, NextFr;
    USHORT MiscMask;
    ULONG TempMask;
    ULONG FrMask = 0;
    UCHAR BrMask = 0;
    UCHAR GrMask = 0;
    PUCHAR Desc = UwContext->Descriptors;
    BOOLEAN SpillMaskOmitted = TRUE;
    USHORT i;

    DescIndex = State->DescBegin;

    FirstByte = Desc[DescIndex];

    if ((FirstByte & R2_MASK) == R2_PREFIX) {

        //
        // general prologue region header; need to process it first
        //

        DescIndex++;
        SecondByte = Desc[DescIndex++];
        MiscMask = ((FirstByte & 0x7) << 1) | ((SecondByte & 0x80) >> 7);
        GrSave = SecondByte & 0x7F;
        ReadLEB128(Desc, &DescIndex);    // advance the descriptor index

        if (GrSave < STATIC_REGISTER_SET_SIZE) {
            UW_DEBUG((1, "Invalid unwind descriptor!\n"));
        }

        UW_DEBUG((1, "Region R2: rmask=%x,grsave=%d,length=%d\n",
                  MiscMask, GrSave, State->RegionLen));

        Count = 0;
        for (Index = REG_PREDS; Index <= REG_RP; Index++) {
            if (MiscMask & 0x1) {
                if (!(State->IsTarget) ||
                    (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = GENERAL_REG;
                    UwContext->MiscRegs[Index].SaveOffset = GrSave+Count;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                Count++;
            }
            MiscMask = MiscMask >> 1;
        }
    }

    while (DescIndex <= State->DescEnd) {

        FirstByte = Desc[DescIndex++];

        if ( (FirstByte & P1_MASK) == P1_PREFIX) {

            BrMask = FirstByte & ~P1_MASK;
            State->MiscMask |= (BrMask << REG_BR_BASE);

            UW_DEBUG((1, "Prolog P1: brmask=%x\n", BrMask));

            for (Count = REG_BR_BASE;
                 Count < REG_BR_BASE+NUMBER_OF_PRESERVED_BR;
                 Count++)
            {
                if (BrMask & 0x1) {
                    UwContext->MiscRegs[Count].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Count].When = State->RegionLen;
                }
                BrMask = BrMask >> 1;
            }

        } else if ( (FirstByte & P2_MASK) == P2_PREFIX ) {

            SecondByte = Desc[DescIndex++];
            GrSave = SecondByte & 0x7F;
            BrMask = ((FirstByte & ~P2_MASK) << 1) | ((SecondByte & 0x80) >> 7);
            UW_DEBUG((1, "Prolog P2: brmask=%x reg base=%d\n", BrMask, GrSave));

            State->MiscMask |= (BrMask << REG_BR_BASE);

            for (Count = REG_BR_BASE;
                 Count < REG_BR_BASE+NUMBER_OF_PRESERVED_BR;
                 Count++)
            {
                if (BrMask & 0x1) {
                    UwContext->MiscRegs[Count].Where = GENERAL_REG;
                    UwContext->MiscRegs[Count].SaveOffset = GrSave++;
                }
                BrMask = BrMask >> 1;
            }

        } else if ( (FirstByte & P3_MASK) == P3_PREFIX ) {

            SecondByte = Desc[DescIndex++];
            RecType = ((SecondByte & 0x80) >> 7) | ((FirstByte & 0x7) << 1);
            Index = P3RecordTypeToRegisterIndex[RecType];

            if (RecType == RP_BR) 
            {
                UwContext->AlternateRp = SecondByte & 0x7F;
            } 
            else if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
            {
                UwContext->MiscRegs[Index].Where = GENERAL_REG;
                UwContext->MiscRegs[Index].SaveOffset = SecondByte & 0x7F;
                UwContext->MiscRegs[Index].When = 0;
                State->MiscMask |= MASK(Index,1);

                UW_DEBUG((1, "Prolog P3: type=%d reg=%d\n",
                          RecType, UwContext->MiscRegs[Index].SaveOffset));
            }

        } else if ( (FirstByte & P4_MASK) == P4_PREFIX ) {

            SpillMaskOmitted = FALSE;
            ImaskBegin = DescIndex;
            DescIndex += ((State->RegionLen+3) >> 2);

        } else if ( (FirstByte & P5_MASK) == P5_PREFIX ) {

            GrMask = (Desc[DescIndex] & 0xF0) >> 4;
            FrMask = ((ULONG)(Desc[DescIndex] & 0xF) << 16) |
                         ((ULONG)Desc[DescIndex+1] << 8) |
                         ((ULONG)Desc[DescIndex+2]);

            DescIndex += 3;    // increment the descriptor index

            State->GrMask |= GrMask;
            State->FrMask |= FrMask;

            UW_DEBUG((1, "Prolog P5: grmask = %x, frmask = %x\n",
                      State->GrMask, State->FrMask));

        } else if ( (FirstByte & P6_MASK) == P6_PREFIX ) {

            if (FirstByte & 0x10) {

                GrMask = FirstByte & 0xF;
                State->GrMask |= GrMask;

            } else {

                FrMask = FirstByte & 0xF;
                State->FrMask |= FrMask;

            }

            UW_DEBUG((1, "Prolog P6: is_gr = %d, mask = %x\n",
                      (FirstByte & 0x10) ? 1 : 0,
                      (FirstByte & 0x10) ? State->GrMask : State->FrMask));

        } else if ( (FirstByte & P7_MASK) == P7_PREFIX ) {

            RecType = FirstByte & ~P7_MASK;

            switch (RecType) {

            case PSP_SPREL:

                //
                // sp-relative location
                //

                Index = P7RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = SP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    if (!(State->MiscMask & MASK(Index,1))) {
                        UwContext->MiscRegs[Index].When = State->RegionLen;
                        State->MiscMask |= MASK(Index,1);
                    }
                }
                UW_DEBUG((1, "Prolog P7: type=%d spoff = %d\n", RecType, Offset));
                break;


            case RP_PSPREL:
            case PFS_PSPREL:
            case PREDS_PSPREL:
            case LC_PSPREL:
            case UNAT_PSPREL:
            case FPSR_PSPREL:

                //
                // psp-relative location
                //

                Index = P7RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                UW_DEBUG((1, "Prolog P7: type=%d pspoff= %d\n", RecType, Offset));
                break;

            case MEM_STACK_V:
            case RP_WHEN:
            case PFS_WHEN:
            case PREDS_WHEN:
            case LC_WHEN:
            case UNAT_WHEN:
            case FPSR_WHEN:

                //
                // Nevermind processing these descriptors because they
                // have been taken care of in phase 0
                //

                Offset = ReadLEB128(Desc, &DescIndex);
                break;

            case MEM_STACK_F:

                Offset = ReadLEB128(Desc, &DescIndex);
                FrameSize = ReadLEB128(Desc, &DescIndex);

                UW_DEBUG((1, "Prolog P7: type=%d Slot=%d FrameSize=%d\n",
                          RecType, Offset, FrameSize));
                break;

            case SPILL_BASE:

                State->SpillBase = ReadLEB128(Desc, &DescIndex);
                State->SpillPtr = State->SpillBase;
                UW_DEBUG((1, "Prolog P7: type=%d, spillbase=%d\n",
                          RecType, State->SpillBase));
                break;

            default:

                UW_DEBUG((1, "invalid unwind descriptors\n"));

            }

        } else if ( (FirstByte & P8_MASK) == P8_PREFIX ) {

            RecType = Desc[DescIndex++];

            switch (RecType) {

            case PSP_PSPREL:
                 VUW_DEBUG_PRINT("Unsupported Unwind Descriptor!\n");
                 break;

            case RP_SPREL:
            case PFS_SPREL:
            case PREDS_SPREL:
            case LC_SPREL:
            case UNAT_SPREL:
            case FPSR_SPREL:
            case BSP_SPREL:
            case BSPSTORE_SPREL:
            case RNAT_SPREL:
            case PRIUNAT_SPREL:

                //
                // sp-relative location
                //

                Index = P8RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = SP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    if (!(State->MiscMask & MASK(Index,1))) {
                        UwContext->MiscRegs[Index].When=State->RegionLen;
                        State->MiscMask |= MASK(Index,1);
                    }
                }
                UW_DEBUG((1, "Prolog P8: type=%d spoff= %d\n", RecType, Offset));
                break;

            case BSP_PSPREL:
            case BSPSTORE_PSPREL:
            case RNAT_PSPREL:
            case PRIUNAT_PSPREL:

                //
                // psp-relative location
                //

                Index = P8RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                UW_DEBUG((1, "Prolog P8: type=%d pspoff= %d\n", RecType, Offset));
                break;

            case BSP_WHEN:
            case BSPSTORE_WHEN:
            case RNAT_WHEN:
            case PRIUNAT_WHEN:

                //
                // Nevermind processing these descriptors because they
                // have been taken care of in phase 0
                //

                Offset = ReadLEB128(Desc, &DescIndex);
                break;

            default:

                UW_DEBUG((1, "Invalid record type for descriptor P8!\n"));

            }

        } else if ( (FirstByte & P9_MASK) == P9_PREFIX ) {

            DescIndex += 2;
            VUW_DEBUG_PRINT("Format P9 not supported yet!\n");

        } else if ( (FirstByte & P10_MASK) == P10_PREFIX ) {

            UCHAR Abi = Desc[DescIndex++];
            UCHAR Context = Desc[DescIndex++];

        } else {

            UW_DEBUG((1, "Invalid descriptor!\n"));

        }
    }

    GrMask = State->GrMask;
    FrMask = State->FrMask;
    BrMask = State->MiscMask >> REG_BR_BASE;

    if (!(GrMask | FrMask | BrMask)) {

        return;

    } else if (SpillMaskOmitted && !(State->IsTarget)) {

        //
        // When spillmask is omitted, floating point registers, general
        // registers, and then branch regisers are spilled in order.
        // They are not modified in the prologue region; therefore, there
        // is no need to restore their contents when the control ip is
        // in this prologue region.
        //

        // 1. floating point registers

        State->SpillPtr &= ~(SPILLSIZE_OF_FLOAT128_IN_DWORDS - 1);
        NextFr = NUMBER_OF_PRESERVED_FR - 1;
        while (FrMask & 0xFFFFF) {
            if (FrMask & 0x80000) {
                State->SpillPtr += SPILLSIZE_OF_FLOAT128_IN_DWORDS;
                UwContext->Float[NextFr].SaveOffset = State->SpillPtr;
            }
            FrMask = FrMask << 1;
            NextFr--;
        }

        // 2. branch registers

        NextBr = REG_BR_BASE + NUMBER_OF_PRESERVED_BR - 1;
        while (BrMask & 0x1F) {
            if (BrMask & 0x10) {
                if (UwContext->MiscRegs[NextBr].Where == PSP_RELATIVE) {
                    State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                    UwContext->MiscRegs[NextBr].SaveOffset = State->SpillPtr;
                }
            }
            BrMask = BrMask << 1;
            NextBr--;
        }

        // 3. general registers

        NextGr = NUMBER_OF_PRESERVED_GR - 1;
        while (GrMask & 0xF) {
            if (GrMask & 0x8) {
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                UwContext->Integer[NextGr].SaveOffset = State->SpillPtr;
            }
            GrMask = GrMask << 1;
            NextGr--;
        }

    } else if (SpillMaskOmitted && State->IsTarget) {

        State->GrMask = 0;
        State->FrMask = 0;
        State->MiscMask &= MASK(REG_BR_BASE, 1) - 1;

    } else if (SpillMaskOmitted == FALSE) {

        ULONG Length;

        if (State->IsTarget) {

            //
            // control ip is in the prologue region; clear the masks
            // and then process the imask to determine which preserved
            // Gr/Fr/Br have been saved and set the corresponding bits.
            //

            State->GrMask = 0;
            State->FrMask = 0;
            State->MiscMask &= MASK(REG_BR_BASE, 1) - 1;
            Length = UwContext->TargetSlot - State->RegionBegin;
        } else {
            Length = State->RegionLen;
        }

        NextGr = NUMBER_OF_PRESERVED_GR - 1;
        NextBr = NUMBER_OF_PRESERVED_BR - 1;
        NextFr = NUMBER_OF_PRESERVED_FR - 1;
        for (Count = 0; Count < Length; Count++) {

            if ((Count % 4) == 0) {
                FirstByte = Desc[ImaskBegin++];
            } else {
                FirstByte = FirstByte << 2;
            }

            switch (FirstByte & 0xC0) {

            case 0x40:                  // 0x01 - save next fr

                while ( !(FrMask & 0x80000) && (NextFr > 0) ) {
                    NextFr--;
                    FrMask = FrMask << 1;
                }

                UW_DEBUG((1, "spilled register FS%lx\n", (ULONG)NextFr));

                State->FrMask |= MASK(NextFr,1);
                UwContext->Float[NextFr].When = Count;
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                State->SpillPtr &= ~(SPILLSIZE_OF_FLOAT128_IN_DWORDS - 1);
                State->SpillPtr += SPILLSIZE_OF_FLOAT128_IN_DWORDS;
                UwContext->Float[NextFr].SaveOffset = State->SpillPtr;

                NextFr--;
                FrMask = FrMask << 1;
                break;

            case 0x80:                  // 0x10 - save next gr

                while ( !(GrMask & 0x8) && (NextGr > 0) ) {
                    NextGr--;
                    GrMask = GrMask << 1;
                }

                UW_DEBUG((1, "spilled register S%lx\n", (ULONG)NextGr));

                State->GrMask |= MASK(NextGr,1);
                UwContext->Integer[NextGr].When = Count;
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                UwContext->Integer[NextGr].SaveOffset = State->SpillPtr;

                NextGr--;
                GrMask = GrMask << 1;
                break;

            case 0xC0:                  // 0x11 - save next br

                while ( !(BrMask & 0x10) && (NextBr > 0) ) {
                    NextBr--;
                    BrMask = BrMask << 1;
                }

                UW_DEBUG((1, "spilled register BS%lx\n", (ULONG)NextBr));

                Index = REG_BR_BASE + NextBr;
                State->MiscMask |= MASK(Index,1);
                UwContext->MiscRegs[Index].When = Count;
                if (UwContext->MiscRegs[Index].Where == PSP_RELATIVE) {
                    State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                    UwContext->MiscRegs[Index].SaveOffset = State->SpillPtr;
                }

                NextBr--;
                BrMask = BrMask << 1;
                break;

            default:                    // 0x00 - save no register
                break;

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\walk.c ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    walk.c

Abstract:

    This function implements the stack walking api.

Author:

    Wesley Witt (wesw) 1-Oct-1993

Environment:

    User Mode

--*/

#include <private.h>
#include "globals.h"
#include "symbols.h"

#ifndef PAGE_SIZE
#if defined(_X86_) || defined(_AMD64_) || defined(ARM)
#define PAGE_SIZE 0x1000
#elif defined(_IA64_)
#define PAGE_SIZE 0x2000
#else
#error Unknown processor architecture
#endif
#endif

ULONG g_StackDebugMask;
ULONG g_StackDebugIo = SDB_CALLBACK_OUT;

BOOL
ReadMemoryRoutineLocal(
    HANDLE  hProcess,
    DWORD64 qwBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    );

LPVOID
FunctionTableAccessRoutineLocal(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

DWORD64
GetModuleBaseRoutineLocal(
    HANDLE  hProcess,
    DWORD64 ReturnAddress
    );

DWORD64
TranslateAddressRoutineLocal(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    );

void __cdecl
SdbOut(
    ULONG Mask,
    PSTR Format,
    ...
    )
{
    if (g_StackDebugMask & Mask) {
        char Text[256];
        char* Cur = Text;
        va_list Args;

        if (!(Mask & SDB_NO_PREFIX)) {
            CopyStrArray(Text, "SDB: ");
            Cur += 5;
        }
        
        va_start(Args, Format);
        _vsnprintf(Cur, sizeof(Text) - (Cur - Text) - 1, Format, Args);
        Text[sizeof(Text) - 1] = 0;

        switch(g_StackDebugIo) {
        case SDB_DEBUG_OUT:
            OutputDebugStringA(Text);
            break;
        case SDB_CALLBACK_OUT:
            _peprint(NULL, "%s", Text);
            break;
        }
    }
}
    
BOOL
ImagepReadMemoryThunk(
    HANDLE  hProcess,
    DWORD64 qwBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    PREAD_PROCESS_MEMORY_ROUTINE fnImagepUserReadMemory32;
    
    fnImagepUserReadMemory32 = tlsvar(ImagepUserReadMemory32);
    return fnImagepUserReadMemory32(
                        hProcess,
                        (DWORD)qwBaseAddress,
                        lpBuffer,
                        nSize,
                        lpNumberOfBytesRead
                        );
}

LPVOID
ImagepFunctionTableAccessThunk(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{
    PFUNCTION_TABLE_ACCESS_ROUTINE  fnImagepUserFunctionTableAccess32;
    
    fnImagepUserFunctionTableAccess32 = tlsvar(ImagepUserFunctionTableAccess32);
    return fnImagepUserFunctionTableAccess32(
                hProcess,
                (DWORD)AddrBase
                );
}

DWORD64
ImagepGetModuleBaseThunk(
    HANDLE  hProcess,
    DWORD64 ReturnAddress
    )
{
    PGET_MODULE_BASE_ROUTINE fnImagepUserGetModuleBase32;
    
    fnImagepUserGetModuleBase32 = tlsvar(ImagepUserGetModuleBase32);
    return (ULONG64)(LONG64)(LONG)fnImagepUserGetModuleBase32(
                hProcess,
                (DWORD)ReturnAddress
                );
}

DWORD64
ImagepTranslateAddressThunk(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    )
{
    return 0;
}

void
StackFrame32To64(
    LPSTACKFRAME StackFrame32,
    LPSTACKFRAME64 StackFrame64
    )
{
    Address32To64(&StackFrame32->AddrPC, &StackFrame64->AddrPC );
    Address32To64(&StackFrame32->AddrReturn, &StackFrame64->AddrReturn );
    Address32To64(&StackFrame32->AddrFrame, &StackFrame64->AddrFrame );
    Address32To64(&StackFrame32->AddrStack, &StackFrame64->AddrStack );
    StackFrame64->FuncTableEntry = StackFrame32->FuncTableEntry;
    StackFrame64->Far = StackFrame32->Far;
    StackFrame64->Virtual = StackFrame32->Virtual;
    StackFrame64->Params[0] = EXTEND64(StackFrame32->Params[0]);
    StackFrame64->Params[1] = EXTEND64(StackFrame32->Params[1]);
    StackFrame64->Params[2] = EXTEND64(StackFrame32->Params[2]);
    StackFrame64->Params[3] = EXTEND64(StackFrame32->Params[3]);
    StackFrame64->Reserved[0] = EXTEND64(StackFrame32->Reserved[0]);
    StackFrame64->Reserved[1] = EXTEND64(StackFrame32->Reserved[1]);
    StackFrame64->Reserved[2] = EXTEND64(StackFrame32->Reserved[2]);
    KdHelp32To64(&StackFrame32->KdHelp, &StackFrame64->KdHelp);
}

void
StackFrame64To32(
    LPSTACKFRAME64 StackFrame64,
    LPSTACKFRAME StackFrame32
    )
{
    Address64To32(&StackFrame64->AddrPC, &StackFrame32->AddrPC );
    Address64To32(&StackFrame64->AddrReturn, &StackFrame32->AddrReturn );
    Address64To32(&StackFrame64->AddrFrame, &StackFrame32->AddrFrame );
    Address64To32(&StackFrame64->AddrStack, &StackFrame32->AddrStack );
    StackFrame32->FuncTableEntry = StackFrame64->FuncTableEntry;
    StackFrame32->Far = StackFrame64->Far;
    StackFrame32->Virtual = StackFrame64->Virtual;
    StackFrame32->Params[0] = (ULONG)StackFrame64->Params[0];
    StackFrame32->Params[1] = (ULONG)StackFrame64->Params[1];
    StackFrame32->Params[2] = (ULONG)StackFrame64->Params[2];
    StackFrame32->Params[3] = (ULONG)StackFrame64->Params[3];
    StackFrame32->Reserved[0] = (ULONG)StackFrame64->Reserved[0];
    StackFrame32->Reserved[1] = (ULONG)StackFrame64->Reserved[1];
    StackFrame32->Reserved[2] = (ULONG)StackFrame64->Reserved[2];
}

BOOL
StackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                    StackFrame32,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE    ReadMemory32,
    PFUNCTION_TABLE_ACCESS_ROUTINE  FunctionTableAccess32,
    PGET_MODULE_BASE_ROUTINE        GetModuleBase32,
    PTRANSLATE_ADDRESS_ROUTINE      TranslateAddress32
    )
{
    BOOL rval;
    BOOL UseSym = FALSE;
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory;
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess;
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase;
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress;
    STACKFRAME64                      StackFrame;

    if (FunctionTableAccess32) {
        tlsvar(ImagepUserFunctionTableAccess32) = FunctionTableAccess32;
        FunctionTableAccess = ImagepFunctionTableAccessThunk;
    } else {
        FunctionTableAccess = FunctionTableAccessRoutineLocal;
        UseSym = TRUE;
    }


    if (GetModuleBase32) {
        tlsvar(ImagepUserGetModuleBase32) = GetModuleBase32;
        GetModuleBase = ImagepGetModuleBaseThunk;
    } else {
        GetModuleBase = GetModuleBaseRoutineLocal;
        UseSym = TRUE;
    }

    if (ReadMemory32) {
        tlsvar(ImagepUserReadMemory32) = ReadMemory32;
        ReadMemory = ImagepReadMemoryThunk;
    } else {
        ReadMemory = ReadMemoryRoutineLocal;
    }

    if (TranslateAddress32) {
        tlsvar(ImagepUserTranslateAddress32) = TranslateAddress32;
        TranslateAddress = ImagepTranslateAddressThunk;
    } else {
        TranslateAddress = TranslateAddressRoutineLocal;
    }

    if (UseSym) {
        //
        // We are using the code in symbols.c
        // hProcess better be a real valid process handle
        //

        //
        // Always call syminitialize.  It's a nop if process
        // is already loaded.
        //
        if (!SymInitialize( hProcess, NULL, FALSE )) {
            return FALSE;
        }

    }

    StackFrame32To64(StackFrame32, &StackFrame);

    switch (MachineType) {
        case IMAGE_FILE_MACHINE_I386:
            rval = WalkX86( hProcess,
                            hThread,
                            &StackFrame,
                            ContextRecord,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress,
                            0
                            );
            break;

        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AMD64:
        default:
            rval = FALSE;
            break;
    }
    if (rval) {
        StackFrame64To32(&StackFrame, StackFrame32);
    }

    return rval;
}


BOOL
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL rval;
    BOOL UseSym = FALSE;

    g.MachineType = MachineType;
    if (!FunctionTableAccess) {
        FunctionTableAccess = FunctionTableAccessRoutineLocal;
        UseSym = TRUE;
    }

    if (!GetModuleBase) {
        GetModuleBase = GetModuleBaseRoutineLocal;
        UseSym = TRUE;
    }

    if (!ReadMemory) {
        ReadMemory = ReadMemoryRoutineLocal;
    }

    if (!TranslateAddress) {
        TranslateAddress = TranslateAddressRoutineLocal;
    }

    if (UseSym) {
        //
        // We are using the code in symbols.c
        // hProcess better be a real valid process handle
        //

        //
        // Always call syminitialize.  It's a nop if process
        // is already loaded.
        //
        if (!SymInitialize( hProcess, NULL, FALSE )) {
            return FALSE;
        }

    }

    switch (MachineType) {
        case IMAGE_FILE_MACHINE_I386:
            rval = WalkX86( hProcess,
                            hThread,
                            StackFrame,
                            ContextRecord,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress,
                            WALK_FIX_FPO_EBP
                            );

            break;

        case IMAGE_FILE_MACHINE_IA64:
            rval = WalkIa64( hProcess,
                             StackFrame,
                             ContextRecord,
                             ReadMemory,
                             FunctionTableAccess,
                             GetModuleBase
                             );
            break;

        case IMAGE_FILE_MACHINE_AMD64:
            rval = WalkAmd64( hProcess,
                              StackFrame,
                              ContextRecord,
                              ReadMemory,
                              FunctionTableAccess,
                              GetModuleBase
                              );
            break;

        case IMAGE_FILE_MACHINE_ARM:
            rval = WalkArm( hProcess,
                            hThread,
                            StackFrame,
                            ContextRecord,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase
                            );
            break;

        default:
            rval = FALSE;
            break;
    }

    return rval;
}

BOOL
ReadMemoryRoutineLocal(
    HANDLE  hProcess,
    DWORD64 qwBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    // ReadProcessMemory will fail if any part of the
    // region to read does not have read access.  This
    // routine attempts to read the largest valid prefix
    // so it has to break up reads on page boundaries.

    BOOL Status = TRUE;
    SIZE_T TotalBytesRead = 0;
    SIZE_T Read;
    ULONG ReadSize;

    while (nSize > 0) {
        
        // Calculate bytes to read and don't let read cross
        // a page boundary.
        ReadSize = PAGE_SIZE - (ULONG)(qwBaseAddress & (PAGE_SIZE - 1));
        ReadSize = min(nSize, ReadSize);

        if (!ReadProcessMemory(hProcess, (PVOID)(ULONG_PTR)qwBaseAddress,
                               lpBuffer, ReadSize, &Read)) {
            if (TotalBytesRead == 0) {
                // If we haven't read anything indicate failure.
                Status = FALSE;
            }
            break;
        }

        TotalBytesRead += Read;
        qwBaseAddress += Read;
        lpBuffer = (PVOID)((PUCHAR)lpBuffer + Read);
        nSize -= (DWORD)Read;
    }

    *lpNumberOfBytesRead = (DWORD)TotalBytesRead;
    return Status;
}

LPVOID
FunctionTableAccessRoutineLocal(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{
    return SymFunctionTableAccess64(hProcess, AddrBase);
}

DWORD64
GetModuleBaseRoutineLocal(
    HANDLE  hProcess,
    DWORD64 ReturnAddress
    )
{
    IMAGEHLP_MODULE64 ModuleInfo = {0};
    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);

    if (SymGetModuleInfo64(hProcess, ReturnAddress, &ModuleInfo)) {
        return ModuleInfo.BaseOfImage;
    } else {
        return 0;
    }
}


DWORD64
TranslateAddressRoutineLocal(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 paddr
    )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\walkalp.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    walkalpha.c

Abstract:

    This file implements the ALPHA stack walking api.

Author:

    Wesley Witt (wesw) 1-Oct-1993

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "symbols.h"
#include "alphaops.h"
#include <stdlib.h>
#include <stddef.h>
#include <globals.h>
#include "fecache.hpp"

#ifdef __cplusplus
extern "C"
#endif

BOOL
WalkAlphaInit(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    );

BOOL
WalkAlphaNext(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    );

BOOL
WalkAlphaGetStackFrame(
    HANDLE                            hProcess,
    PULONG64                          ReturnAddress,
    PULONG64                          FramePointer,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    PKDHELP64                         KdHelp,
    BOOL                              Use64
    );

VOID
GetUnwindFunctionEntry(
    HANDLE                                hProcess,
    ULONG64                               ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64        ReadMemory,
    PGET_MODULE_BASE_ROUTINE64            GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64      GetFunctionEntry,
    BOOL                                  Use64,
    FeCacheEntry*                         FunctionEntry,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY UnwindFunctionEntry,
    PULONG                                StackAdjust,
    PULONG64                              FixedReturn
    );

#define ZERO 0x0                /* integer register 0 */
#define SP 0x1d                 /* integer register 29 */
#define RA 0x1f                 /* integer register 31 */
#define SAVED_FLOATING_MASK 0xfff00000 /* saved floating registers */
#define SAVED_INTEGER_MASK 0xf3ffff02 /* saved integer registers */
#define IS_FLOATING_SAVED(Register) ((SAVED_FLOATING_MASK >> Register) & 1L)
#define IS_INTEGER_SAVED(Register) ((SAVED_INTEGER_MASK >> Register) & 1L)

#define IS_HANDLER_DEFINED(FunctionEntry) \
    (RF_EXCEPTION_HANDLER(FunctionEntry) != 0)

BOOL
WalkAlpha(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
{
    BOOL rval;
    PALPHA_NT5_CONTEXT Context = (PALPHA_NT5_CONTEXT)ContextRecord;

    if (StackFrame->Virtual) {

        rval = WalkAlphaNext( hProcess,
                              StackFrame,
                              Context,
                              ReadMemory,
                              GetModuleBase,
                              GetFunctionEntry,
                              Use64
                            );

    } else {

        rval = WalkAlphaInit( hProcess,
                              StackFrame,
                              Context,
                              ReadMemory,
                              GetModuleBase,
                              GetFunctionEntry,
                              Use64
                            );

    }

    return rval;
}


ULONG64
VirtualUnwind (
    HANDLE                                  hProcess,
    ULONG64                                 ControlPc,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY   FunctionEntry,
    ULONG                                   StackAdjust,
    ULONG64                                 FixedReturn,
    PALPHA_NT5_CONTEXT                      Context,
    PREAD_PROCESS_MEMORY_ROUTINE64          ReadMemory
//    PKNONVOLATILE_CONTEXT_POINTERS          ContextPointers OPTIONAL
    )

/*++

Routine Description:

    This function virtually unwinds the specified function by executing its
    prologue code backwards. Given the current context and the instructions
    that preserve registers in the prologue, it is possible to recreate the
    nonvolatile context at the point the function was called.

    If the function is a leaf function, then the address where control left
    the previous frame is obtained from the context record. If the function
    is a nested function, but not an exception or interrupt frame, then the
    prologue code is executed backwards and the address where control left
    the previous frame is obtained from the updated context record.

    Otherwise, an exception or interrupt entry to the system is being unwound
    and a specially coded prologue restores the return address twice. Once
    from the fault instruction address and once from the saved return address
    register. The first restore is returned as the function value and the
    second restore is placed in the updated context record.

    During the unwind, the virtual and real frame pointers for the function
    are calculated and returned in the given frame pointers structure.

    If a context pointers record is specified, then the address where each
    register is restored from is recorded in the appropriate element of the
    context pointers record.

Arguments:

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    The address where control left the previous frame is returned as the
    function value.

Implementation Notes:

    N.B. "where control left" is not the "return address" of the call in the
    previous frame. For normal frames, NextPc points to the last instruction
    that completed in the previous frame (the JSR/BSR). The difference between
    NextPc and NextPc + 4 (return address) is important for correct behavior
    in boundary cases of exception addresses and scope tables.

    For exception and interrupt frames, NextPc is obtained from the trap frame
    contination address (Fir). For faults and synchronous traps, NextPc is both
    the last instruction to execute in the previous frame and the next
    instruction to execute if the function were to return. For asynchronous
    traps, NextPc is the continuation address. It is the responsibility of the
    compiler to insert TRAPB instructions to insure asynchronous traps do not
    occur outside the scope from the instruction(s) that caused them.

    N.B. in this and other files where RtlVirtualUnwind is used, the variable
    named NextPc is perhaps more accurately, LastPc - the last PC value in
    the previous frame, or CallPc - the address of the call instruction, or
    ControlPc - the address where control left the previous frame. Instead
    think of NextPc as the next PC to use in another call to virtual unwind.

    The Alpha version of virtual unwind is similar in design, but slightly
    more complex than the Mips version. This is because Alpha compilers
    are given more flexibility to optimize generated code and instruction
    sequences, including within procedure prologues. And also because of
    compiler design issues, the function must manage both virtual and real
    frame pointers.

Version Information:  This version was taken from exdspatch.c@v37 (Feb 1993)

--*/

{
    ALPHA_INSTRUCTION FollowingInstruction;
    ALPHA_INSTRUCTION Instruction;
    ULONGLONG         Address;
    ULONG             DecrementOffset;
    ULONG             DecrementRegister;
    PULONGLONG        FloatingRegister;
    ULONG             FrameSize;
    ULONG             Function;
    PULONGLONG        IntegerRegister;
    ULONG             Literal8;
    ULONGLONG         NextPc;
    LONG              Offset16;
    ULONG             Opcode;
    ULONG             Ra;
    ULONG             Rb;
    ULONG             Rc;
    BOOLEAN           RestoredRa;
    BOOLEAN           RestoredSp;
    DWORD             cb;
    PVOID             Prolog;


    //
    // perf hack: fill cache with prolog
    // skip it if this is a secondary function entry
    //

    if (FunctionEntry &&
        (ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) > ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) &&
        (ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) < ALPHA_RF_END_ADDRESS(FunctionEntry)) ) {

        cb = (ULONG)(ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) - ALPHA_RF_BEGIN_ADDRESS(FunctionEntry));

        //
        // If the function is a leaf it doesn't have a prolog, skip this
        // optimization.
        //

        if (cb != 0) {
            Prolog = (PVOID) MemAlloc( cb );
            if (!ReadMemory( hProcess,
                             ALPHA_RF_BEGIN_ADDRESS(FunctionEntry),
                             Prolog,
                             cb,
                             &cb )) {
                return 0;
            }
            MemFree(Prolog);
        }
    }

    //
    // Set the base address of the integer and floating register arrays within
    // the context record. Each set of 32 registers is known to be contiguous.
    //

    // assuming that quad values are together in context.

    IntegerRegister      = &Context->IntV0;
    FloatingRegister     = &Context->FltF0;

    //
    // Handle the epilogue case where the next instruction is a return.
    //
    // Exception handlers cannot be called if the ControlPc is within the
    // epilogue because exception handlers expect to operate with a current
    // stack frame. The value of SP is not current within the epilogue.
    //

    if (!ReadMemory(hProcess, ControlPc, &Instruction.Long, 4, &cb))  {
        return(0);
    }

    if (IS_RETURN_0001_INSTRUCTION(Instruction.Long)) {
        Rb = Instruction.Jump.Rb;
        NextPc = IntegerRegister[Rb] - 4;

        //
        // The instruction at the point where control left the specified
        // function is a return, so any saved registers have already been
        // restored, and the stack pointer has already been adjusted. The
        // stack does not need to be unwound in this case and the saved
        // return address register is returned as the function value.
        //
        // In fact, reverse execution of the prologue is not possible in
        // this case: the stack pointer has already been incremented and
        // so, for this frame, neither a valid stack pointer nor frame
        // pointer exists from which to begin reverse execution of the
        // prologue. In addition, the integrity of any data on the stack
        // below the stack pointer is never guaranteed (due to interrupts
        // and exceptions).
        //
        // The epilogue instruction sequence is:
        //
        // ==>  ret   zero, (Ra), 1     // return
        // or
        //
        //      mov   ra, Rx            // save return address
        //      ...
        // ==>  ret   zero, (Rx), 1     // return
        //

        return NextPc;
    }

    //
    // Handle the epilogue case where the next two instructions are a stack
    // frame deallocation and a return.
    //

    if (!ReadMemory(hProcess,(ControlPc+4),&FollowingInstruction.Long,4,&cb)) {
        return 0;
    }

    if (IS_RETURN_0001_INSTRUCTION(FollowingInstruction.Long)) {
        Rb = FollowingInstruction.Jump.Rb;
        NextPc = IntegerRegister[Rb] - 4;

        //
        // The second instruction following the point where control
        // left the specified function is a return. If the instruction
        // before the return is a stack increment instruction, then all
        // saved registers have already been restored except for SP.
        // The value of the stack pointer register cannot be recovered
        // through reverse execution of the prologue because in order
        // to begin reverse execution either the stack pointer or the
        // frame pointer (if any) must still be valid.
        //
        // Instead, the effect that the stack increment instruction
        // would have had on the context is manually applied to the
        // current context. This is forward execution of the epilogue
        // rather than reverse execution of the prologue.
        //
        // In an epilogue, as in a prologue, the stack pointer is always
        // adjusted with a single instruction: either an immediate-value
        // (lda) or a register-value (addq) add instruction.
        //

        Function = Instruction.OpReg.Function;
        Offset16 = Instruction.Memory.MemDisp;
        Opcode = Instruction.OpReg.Opcode;
        Ra = Instruction.OpReg.Ra;
        Rb = Instruction.OpReg.Rb;
        Rc = Instruction.OpReg.Rc;

        if ((Opcode == LDA_OP) && (Ra == SP_REG)) {

            //
            // Load Address instruction.
            //
            // Since the destination (Ra) register is SP, an immediate-
            // value stack deallocation operation is being performed. The
            // displacement value should be added to SP. The displacement
            // value is assumed to be positive. The amount of stack
            // deallocation possible using this instruction ranges from
            // 16 to 32752 (32768 - 16) bytes. The base register (Rb) is
            // usually SP, but may be another register.
            //
            // The epilogue instruction sequence is:
            //
            // ==>  lda   sp, +N(sp)        // deallocate stack frame
            //      ret   zero, (ra)        // return
            // or
            //
            // ==>  lda   sp, +N(Rx)        // restore SP and deallocate frame
            //      ret   zero, (ra)        // return
            //

            Context->IntSp = Offset16 + IntegerRegister[Rb];
            return NextPc;

        } else if ((Opcode == ARITH_OP) && (Function == ADDQ_FUNC) &&
                   (Rc == SP_REG) &&
                   (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT)) {

            //
            // Add Quadword instruction.
            //
            // Since both source operands are registers, and the
            // destination register is SP, a register-value stack
            // deallocation is being performed. The value of the two
            // source registers should be added and this is the new
            // value of SP. One of the source registers is usually SP,
            // but may be another register.
            //
            // The epilogue instruction sequence is:
            //
            //      ldiq  Rx, N             // set [large] frame size
            //      ...
            // ==>  addq  sp, Rx, sp        // deallocate stack frame
            //      ret   zero, (ra)        // return
            // or
            //
            // ==>  addq  Rx, Ry, sp        // restore SP and deallocate frame
            //      ret   zero, (ra)        // return
            //

            Context->IntSp = IntegerRegister[Ra] + IntegerRegister[Rb];
            return NextPc;
        }
    }

    //
    // By default set the frame pointers to the current value of SP.
    //
    // When a procedure is called, the value of SP before the stack
    // allocation instruction is the virtual frame pointer. When reverse
    // executing instructions in the prologue, the value of SP before the
    // stack allocation instruction is encountered is the real frame
    // pointer. This is the current value of SP unless the procedure uses
    // a frame pointer (e.g., FP_REG).
    //

    //
    // If the address where control left the specified function is beyond
    // the end of the prologue, then the control PC is considered to be
    // within the function and the control address is set to the end of
    // the prologue. Otherwise, the control PC is not considered to be
    // within the function (i.e., the prologue).
    //
    // N.B. PrologEndAddress is equal to BeginAddress for a leaf function.
    //
    // The low-order two bits of PrologEndAddress are reserved for the IEEE
    // exception mode and so must be masked out.
    //

    if ((ControlPc < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
        (ControlPc >= ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry))) {
        ControlPc = ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry);
    }

    //
    // Scan backward through the prologue to reload callee saved registers
    // that were stored or copied and to increment the stack pointer if it
    // was decremented.
    //

    DecrementRegister = ZERO_REG;
    NextPc = Context->IntRa - 4;
    RestoredRa = FALSE;
    RestoredSp = FALSE;
    while (ControlPc > ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) {

        //
        // Get instruction value, decode fields, case on opcode value, and
        // reverse register store and stack decrement operations.
        // N.B. The location of Opcode, Ra, Rb, and Rc is the same across
        // all opcode formats. The same is not true for Function.
        //

        ControlPc -= 4;
        if (!ReadMemory(hProcess, ControlPc, &Instruction.Long, 4, &cb)) {
             return 0;
        }
        Function = Instruction.OpReg.Function;
        Literal8 = Instruction.OpLit.Literal;
        Offset16 = Instruction.Memory.MemDisp;
        Opcode = Instruction.OpReg.Opcode;
        Ra = Instruction.OpReg.Ra;
        Rb = Instruction.OpReg.Rb;
        Rc = Instruction.OpReg.Rc;

        //
        // Compare against each instruction type that will affect the context
        // and that is allowed in a prologue. Any other instructions found
        // in the prologue will be ignored since they are assumed to have no
        // effect on the context.
        //

        switch (Opcode) {

        case STQ_OP :

            //
            // Store Quad instruction.
            //
            // If the base register is SP, then reload the source register
            // value from the value stored on the stack.
            //
            // The prologue instruction sequence is:
            //
            // ==>  stq   Rx, N(sp)         // save integer register Rx
            //

            if ((Rb == SP_REG) && (Ra != ZERO_REG)) {

                //
                // Reload the register by retrieving the value previously
                // stored on the stack.
                //

                Address = (Offset16 + Context->IntSp);
                if (!ReadMemory(hProcess, Address, &IntegerRegister[Ra], 8L, &cb)) {
                    return 0;
                }

                //
                // If the destination register is RA and this is the first
                // time that RA is being restored, then set the address of
                // where control left the previous frame. Otherwise, if this
                // is the second time RA is being restored, then the first
                // one was an interrupt or exception address and the return
                // PC should not have been biased by 4.
                //

                if (Ra == RA_REG) {
                    if (RestoredRa == FALSE) {
                        NextPc = Context->IntRa - 4;
                        RestoredRa = TRUE;

                    } else {
                        NextPc += 4;
                    }

                //
                // Otherwise, if the destination register is SP and this is
                // the first time that SP is being restored, then set the
                // establisher frame pointers.
                //

                } else if ((Ra == SP_REG) && (RestoredSp == FALSE)) {
                    RestoredSp = TRUE;
                }

                //
                // If a context pointer record is specified, then record
                // the address where the destination register contents
                // are stored.
                //

                //if (ContextPointers != (PKNONVOLATILE_CONTEXT_POINTERS) NULL) {
                //    ContextPointers->IntegerContext[Ra] = (PULONGLONG)Address;
                //}
            }
            break;

        case LDAH_OP :
            Offset16 <<= 16;

        case LDA_OP :

            //
            // Load Address High, Load Address instruction.
            //
            // There are several cases where the lda and/or ldah instructions
            // are used: one to decrement the stack pointer directly, and the
            // others to load immediate values into another register and that
            // register is then used to decrement the stack pointer.
            //
            // In the examples below, as a single instructions or as a pair,
            // a lda may be substituted for a ldah and visa-versa.
            //

            if (Ra == SP_REG) {
                if (Rb == SP_REG) {

                    //
                    // If both the destination (Ra) and base (Rb) registers
                    // are SP, then a standard stack allocation was performed
                    // and the negated displacement value is the stack frame
                    // size. The amount of stack allocation possible using
                    // the lda instruction ranges from 16 to 32768 bytes and
                    // the amount of stack allocation possible using the ldah
                    // instruction ranges from 65536 to 2GB in multiples of
                    // 65536 bytes. It is rare for the ldah instruction to be
                    // used in this manner.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  lda   sp, -N(sp)    // allocate stack frame
                    //

                    FrameSize = -Offset16;
                    goto StackAllocation;

                } else {

                    //
                    // The destination register is SP and the base register
                    // is not SP, so this instruction must be the second
                    // half of an instruction pair to allocate a large size
                    // (>32768 bytes) stack frame. Save the displacement value
                    // as the partial decrement value and postpone adjusting
                    // the value of SP until the first instruction of the pair
                    // is encountered.
                    //
                    // The prologue instruction sequence is:
                    //
                    //      ldah  Rx, -N(sp)    // prepare new SP (upper)
                    // ==>  lda   sp, sN(Rx)    // allocate stack frame
                    //

                    DecrementRegister = Rb;
                    DecrementOffset = Offset16;
                }

            } else if (Ra == DecrementRegister) {
                if (Rb == DecrementRegister) {

                    //
                    // Both the destination and base registers are the
                    // decrement register, so this instruction exists as the
                    // second half of a two instruction pair to load a
                    // 31-bit immediate value into the decrement register.
                    // Save the displacement value as the partial decrement
                    // value.
                    //
                    // The prologue instruction sequence is:
                    //
                    //      ldah  Rx, +N(zero)      // set frame size (upper)
                    // ==>  lda   Rx, sN(Rx)        // set frame size (+lower)
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    //

                    DecrementOffset += Offset16;

                } else if (Rb == ZERO_REG) {

                    //
                    // The destination register is the decrement register and
                    // the base register is zero, so this instruction exists
                    // to load an immediate value into the decrement register.
                    // The stack frame size is the new displacement value added
                    // to the previous displacement value, if any.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  lda   Rx, +N(zero)      // set frame size
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    // or
                    //
                    // ==>  ldah  Rx, +N(zero)      // set frame size (upper)
                    //      lda   Rx, sN(Rx)        // set frame size (+lower)
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    //

                    FrameSize = (Offset16 + DecrementOffset);
                    goto StackAllocation;

                } else if (Rb == SP_REG) {

                    //
                    // The destination (Ra) register is SP and the base (Rb)
                    // register is the decrement register, so a two
                    // instruction, large size (>32768 bytes) stack frame
                    // allocation was performed. Add the new displacement
                    // value to the previous displacement value. The negated
                    // displacement value is the stack frame size.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  ldah  Rx, -N(sp)    // prepare new SP (upper)
                    //      lda   sp, sN(Rx)    // allocate stack frame
                    //

                    FrameSize = -(Offset16 + (LONG)DecrementOffset);
                    goto StackAllocation;
                }
            }
            break;

        case ARITH_OP :

            if ((Function == ADDQ_FUNC) &&
                (Instruction.OpReg.RbvType != RBV_REGISTER_FORMAT)) {

                //
                // Add Quadword (immediate) instruction.
                //
                // If the first source register is zero, and the second
                // operand is a literal, and the destination register is
                // the decrement register, then the instruction exists
                // to load an unsigned immediate value less than 256 into
                // the decrement register. The immediate value is the stack
                // frame size.
                //
                // The prologue instruction sequence is:
                //
                // ==>  addq  zero, N, Rx       // set frame size
                //      ...
                //      subq  sp, Rx, sp        // allocate stack frame
                //

                if ((Ra == ZERO_REG) && (Rc == DecrementRegister)) {
                    FrameSize = Literal8;
                    goto StackAllocation;
                }

            } else if ((Function == SUBQ_FUNC) &&
                       (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT)) {

                //
                // Subtract Quadword (register) instruction.
                //
                // If both source operands are registers and the first
                // source (minuend) register and the destination
                // (difference) register are both SP, then a register value
                // stack allocation was performed and the second source
                // (subtrahend) register value will be added to SP when its
                // value is known. Until that time save the register number of
                // this decrement register.
                //
                // The prologue instruction sequence is:
                //
                //      ldiq  Rx, N             // set frame size
                //      ...
                // ==>  subq  sp, Rx, sp        // allocate stack frame
                //

                if ((Ra == SP_REG) && (Rc == SP_REG)) {
                    DecrementRegister = Rb;
                    DecrementOffset = 0;
                }
            }
            break;

        case BIT_OP :

            //
            // If the second operand is a register the bit set instruction
            // may be a register move instruction, otherwise if the second
            // operand is a literal, the bit set instruction may be a load
            // immediate value instruction.
            //

            if ((Function == BIS_FUNC) && (Rc != ZERO_REG)) {
                if (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT) {

                    //
                    // Bit Set (register move) instruction.
                    //
                    // If both source registers are the same register, or
                    // one of the source registers is zero, then this is a
                    // register move operation. Restore the value of the
                    // source register by copying the current destination
                    // register value back to the source register.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  bis   Rx, Rx, Ry        // copy register Rx
                    // or
                    //
                    // ==>  bis   Rx, zero, Ry      // copy register Rx
                    // or
                    //
                    // ==>  bis   zero, Rx, Ry      // copy register Rx
                    //

                    if (Ra == ZERO_REG) {

                        //
                        // Map the third case above to the first case.
                        //

                        Ra = Rb;

                    } else if (Rb == ZERO_REG) {

                        //
                        // Map the second case above to the first case.
                        //

                        Rb = Ra;
                    }

                    if ((Ra == Rb) && (Ra != ZERO_REG)) {
                        IntegerRegister[Ra] = IntegerRegister[Rc];


                        //
                        // If the destination register is RA and this is the
                        // first time that RA is being restored, then set the
                        // address of where control left the previous frame.
                        // Otherwise, if this is the second time RA is being
                        // restored, then the first one was an interrupt or
                        // exception address and the return PC should not
                        // have been biased by 4.
                        //

                        if (Ra == RA_REG) {
                            if (RestoredRa == FALSE) {
                                NextPc = Context->IntRa - 4;
                                RestoredRa = TRUE;

                            } else {
                                NextPc += 4;
                            }
                        }

                        //
                        // If the source register is SP and this is the first
                        // time SP is set, then this is a frame pointer set
                        // instruction. Reset the frame pointers to this new
                        // value of SP.
                        //

                        if ((Ra == SP_REG) && (RestoredSp == FALSE)) {
                            RestoredSp = TRUE;
                        }
                    }

                } else {

                    //
                    // Bit Set (load immediate) instruction.
                    //
                    // If the first source register is zero, and the second
                    // operand is a literal, and the destination register is
                    // the decrement register, then this instruction exists
                    // to load an unsigned immediate value less than 256 into
                    // the decrement register. The decrement register value is
                    // the stack frame size.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  bis   zero, N, Rx       // set frame size
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    //

                    if ((Ra == ZERO_REG) && (Rc == DecrementRegister)) {
                        FrameSize = Literal8;
StackAllocation:
                        //
                        // Add the frame size to SP to reverse the stack frame
                        // allocation, leave the real frame pointer as is, set
                        // the virtual frame pointer with the updated SP value,
                        // and clear the decrement register.
                        //

                        Context->IntSp += FrameSize;
                        DecrementRegister = ZERO_REG;
                    }
                }
            }
            break;

        case STT_OP :

            //
            // Store T-Floating (quadword integer) instruction.
            //
            // If the base register is SP, then reload the source register
            // value from the value stored on the stack.
            //
            // The prologue instruction sequence is:
            //
            // ==>  stt   Fx, N(sp)         // save floating register Fx
            //

            if ((Rb == SP_REG) && (Ra != FZERO_REG)) {

                //
                // Reload the register by retrieving the value previously
                // stored on the stack.
                //

                Address = (Offset16 + Context->IntSp);
                if (!ReadMemory(hProcess, Address, &FloatingRegister[Ra], 8L, &cb)) {
                    return 0;
                }

                //
                // If a context pointer record is specified, then record
                // the address where the destination register contents are
                // stored.
                //

                //if (ContextPointers != (PKNONVOLATILE_CONTEXT_POINTERS) NULL) {
                //    ContextPointers->FloatingContext[Ra] = (PULONGLONG)Address;
                //}
            }
            break;


        case STS_OP :

            //
            // Store T-Floating (dword integer) instruction.
            //
            // If the base register is SP, then reload the source register
            // value from the value stored on the stack.
            //
            // The prologue instruction sequence is:
            //
            // ==>  stt   Fx, N(sp)         // save floating register Fx
            //

            if ((Rb == SP_REG) && (Ra != FZERO_REG)) {

                //
                // Reload the register by retrieving the value previously
                // stored on the stack.
                //

                float f;

                Address = (Offset16 + Context->IntSp);
                if (!ReadMemory(hProcess, Address, &f, sizeof(float), &cb)) {
                    return 0;
                }

                //
                // value was stored as a float.  Do a conversion to a
                // double, since registers are Always read as doubles
                //
                FloatingRegister[Ra] = (ULONGLONG)(double)f;

                //
                // If a context pointer record is specified, then record
                // the address where the destination register contents are
                // stored.
                //

                //if (ContextPointers != (PKNONVOLATILE_CONTEXT_POINTERS) NULL) {
                //    ContextPointers->FloatingContext[Ra] = (PULONGLONG)Address;
                //}
            }
            break;

        case FPOP_OP :

            //
            // N.B. The floating operate function field is not the same as
            // the integer operate nor the jump function fields.
            //

            if (Instruction.FpOp.Function == CPYS_FUNC) {

                //
                // Copy Sign (floating-point move) instruction.
                //
                // If both source registers are the same register, then this is
                // a floating-point register move operation. Restore the value
                // of the source register by copying the current destination
                // register value to the source register.
                //
                // The prologue instruction sequence is:
                //
                // ==>  cpys  Fx, Fx, Fy        // copy floating register Fx
                //

                if ((Ra == Rb) && (Ra != FZERO_REG)) {
                    FloatingRegister[Ra] = FloatingRegister[Rc];
                }
            }

        default :
            break;
        }
    }

    if (StackAdjust) {
        // Check for exlicit stack adjust amount

        Context->IntSp += StackAdjust;
    }

    if (FixedReturn != 0) {
        NextPc = FixedReturn;
    }

    return NextPc;
}

BOOL
WalkAlphaGetStackFrame(
    HANDLE                            hProcess,
    PULONG64                          ReturnAddress,
    PULONG64                          FramePointer,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    PKDHELP64                         KdHelp,
    BOOL                              Use64
    )
{
    FeCacheEntry*                    CacheEntry;
    FeCacheEntry                     UnwindFunctionEntry;
    ULONG64                          NextPc = Context->IntRa;
    BOOL                             rval = TRUE;
    ULONG                            cb;
    ULONG                            StackAdjust;
    ULONG64                          FixedReturn;


    if (*ReturnAddress == 0) {
        return FALSE;
    }

    __try {
        FunctionEntryCache* Cache =
            GetFeCache(Use64 ?
                       IMAGE_FILE_MACHINE_ALPHA64 : IMAGE_FILE_MACHINE_ALPHA,
                       TRUE);
        if (Cache != NULL) {
            CacheEntry = Cache->Find(hProcess, *ReturnAddress, ReadMemory,
                                     GetModuleBase, GetFunctionEntry);
        } else {
            CacheEntry = NULL;
        }

        if (CacheEntry != NULL) {

            // Construct a function entry suitable for unwinding from ControlPc

            UnwindFunctionEntry.Address = 0;
            UnwindFunctionEntry.Process = 0;

            GetUnwindFunctionEntry( hProcess, *ReturnAddress, ReadMemory, GetModuleBase, GetFunctionEntry, Use64, CacheEntry,
                                    &UnwindFunctionEntry.Data.Axp64, &StackAdjust, &FixedReturn );
            FE_SET_DESC(&UnwindFunctionEntry, "from UnwindFunctionEntry");
            FE_ShowRuntimeFunctionAxp64((&UnwindFunctionEntry,
                                         "VirtualUnwind: unwind function entry"));
#if DBG
            if (tlsvar(DebugFunctionEntries)) {
                dbPrint("    FixedReturn      = %16.8I64x\n", FixedReturn );
                dbPrint("    StackAdjust      = %16x\n", StackAdjust );
            }
#endif

            NextPc = VirtualUnwind( hProcess, *ReturnAddress, &UnwindFunctionEntry.Data.Axp64, StackAdjust, FixedReturn, Context, ReadMemory);
#if DBG
            if (tlsvar(DebugFunctionEntries)) {
                dbPrint("NextPc = %.8I64x\n", NextPc );
            }
#endif
            if (!NextPc) {
                rval = FALSE;
            }

            //
            // The Ra value coming out of mainCRTStartup is set by some RTL
            // routines to be "1"; return out of mainCRTStartup is actually
            // done through Jump/Unwind, so this serves to cause an error if
            // someone actually does a return.  That's why we check here for
            // NextPc == 1 - this happens when in the frame for CRTStartup.
            //
            // We test for (0-4) and (1-4) because on ALPHA, the value returned by
            // VirtualUnwind is the value to be passed to the next call to
            // VirtualUnwind, which is NOT the same as the Ra - it's sometimes
            // decremented by four - this gives the faulting instruction -
            // in particular, we want the fault instruction so we can get the
            // correct scope in the case of an exception.
            //
            if ((NextPc == 1) || (NextPc == 4) || (NextPc == (0-4)) || (NextPc == (1-4)) ) {
                NextPc = 0;
            }
            if ( !NextPc || (NextPc == *ReturnAddress && *FramePointer == Context->IntSp) ) {
                rval = FALSE;
            }

            *ReturnAddress = NextPc;
            *FramePointer  = Context->IntSp;

        } else {

            if ( (NextPc == *ReturnAddress && *FramePointer == Context->IntSp) ||
                 (NextPc == 1) || (NextPc == 0) || (NextPc == (-4)) ) {
                rval = FALSE;
            }

            *ReturnAddress = Context->IntRa;
            *FramePointer  = Context->IntSp;

        }

    } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        rval = FALSE;
    }

    return rval;
}


BOOL
WalkAlphaInit(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
{
    ALPHA_NT5_CONTEXT  ContextSave;
    ULONG64            PcOffset;
    ULONG64            FrameOffset;
    DWORD              cb;
    ALPHA_KEXCEPTION_FRAME   ExceptionFrame;
    PALPHA_KEXCEPTION_FRAME  pef = &ExceptionFrame;
    DWORD              Result;

    if (StackFrame->AddrFrame.Offset) {
#if 0
        if (ReadMemory( hProcess,
                        StackFrame->AddrFrame.Offset,
                        &ExceptionFrame,
                        sizeof(ALPHA_KEXCEPTION_FRAME),
                        &cb )) {
            //
            // successfully read an exception frame from the stack
            //
            Context->IntSp  = StackFrame->AddrFrame.Offset;
            Context->Fir    = pef->SwapReturn;
            Context->IntRa  = pef->SwapReturn;
            Context->IntS0  = pef->IntS0;
            Context->IntS1  = pef->IntS1;
            Context->IntS2  = pef->IntS2;
            Context->IntS3  = pef->IntS3;
            Context->IntS4  = pef->IntS4;
            Context->IntS5  = pef->IntS5;
            Context->Psr    = pef->Psr;
        } else {
            return FALSE;
        }
#endif

    }

    ZeroMemory( StackFrame, FIELD_OFFSET( STACKFRAME64, KdHelp.ThCallbackBStore) );

    StackFrame->Virtual = TRUE;

    StackFrame->AddrPC.Offset       = Context->Fir;
    StackFrame->AddrPC.Mode         = AddrModeFlat;

    StackFrame->AddrFrame.Offset    = Context->IntSp;
    StackFrame->AddrFrame.Mode      = AddrModeFlat;

    ContextSave = *Context;
    PcOffset    = StackFrame->AddrPC.Offset;
    FrameOffset = StackFrame->AddrFrame.Offset;

    if (!WalkAlphaGetStackFrame( hProcess,
                        &PcOffset,
                        &FrameOffset,
                        &ContextSave,
                        ReadMemory,
                        GetModuleBase,
                        GetFunctionEntry,
                        &StackFrame->KdHelp,
                        Use64) ) {

        StackFrame->AddrReturn.Offset = Context->IntRa;

    } else {

        StackFrame->AddrReturn.Offset = PcOffset;
    }

    StackFrame->AddrReturn.Mode     = AddrModeFlat;

    //
    // get the arguments to the function
    //
    StackFrame->Params[0] = Context->IntA0;
    StackFrame->Params[1] = Context->IntA1;
    StackFrame->Params[2] = Context->IntA2;
    StackFrame->Params[3] = Context->IntA3;

    return TRUE;
}


BOOL
WalkAlphaNext(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
{
    DWORD              cb;
    ALPHA_NT5_CONTEXT  ContextSave;
    BOOL               rval = TRUE;
    ULONG64            Address;
    FunctionEntryCache* Cache;
    FeCacheEntry*      CacheEntry;
    ULONG64            SystemRangeStart;
    DWORD              dw;
    ULONG64            qw;


    if (!WalkAlphaGetStackFrame( hProcess,
                        &StackFrame->AddrPC.Offset,
                        &StackFrame->AddrFrame.Offset,
                        Context,
                        ReadMemory,
                        GetModuleBase,
                        GetFunctionEntry,
                        &StackFrame->KdHelp,
                        Use64) ) {

        rval = FALSE;

        //
        // If the frame could not be unwound or is terminal, see if
        // there is a callback frame:
        //

        if (g.AppVersion.Revision >= 4 && CALLBACK_STACK(StackFrame)) {

            if (g.AppVersion.Revision >= 6) {
                SystemRangeStart = SYSTEM_RANGE_START(StackFrame);
            } else {
                //
                // This might not really work right with old debuggers, but it keeps
                // us from looking off the end of the structure anyway.
                //
                SystemRangeStart = 0x80000000;
            }

           if (CALLBACK_STACK(StackFrame) >= SystemRangeStart) {

                //
                // it is the pointer to the stack frame that we want,
                // or -1.

                Address = CALLBACK_STACK(StackFrame);

            } else {

                //
                // if it is a positive integer, it is the offset to
                // the address in the thread.
                // Look up the pointer:
                //

                if (Use64) {
                    rval = ReadMemory(hProcess,
                                      (CALLBACK_THREAD(StackFrame) +
                                                     CALLBACK_STACK(StackFrame)),
                                      &Address,
                                      sizeof(ULONG64),
                                      &cb);
                } else {
                    rval = ReadMemory(hProcess,
                                      (CALLBACK_THREAD(StackFrame) +
                                                     CALLBACK_STACK(StackFrame)),
                                      &dw,
                                      sizeof(DWORD),
                                      &cb);
                    Address = (ULONG64)(LONG64)(LONG)dw;
                }

                if (!rval || Address == 0) {
                    Address = (ULONG64)-1;
                    CALLBACK_STACK(StackFrame) = (DWORD)-1;
                }

            }

            if ( (Address == (ULONG64)-1) ||
                 (Cache = GetFeCache(Use64 ?
                                     IMAGE_FILE_MACHINE_ALPHA64 :
                                     IMAGE_FILE_MACHINE_ALPHA,
                                     TRUE)) == NULL ||
                 (CacheEntry = Cache->Find(hProcess, CALLBACK_FUNC(StackFrame),
                                           ReadMemory, GetModuleBase,
                                           GetFunctionEntry)) == NULL ) {

                rval = FALSE;

            } else {

                if (Use64) {
                    ReadMemory(hProcess,
                               (Address + CALLBACK_NEXT(StackFrame)),
                               &CALLBACK_STACK(StackFrame),
                               sizeof(ULONG64),
                               &cb);
                    StackFrame->AddrPC.Offset = ALPHA_RF_PROLOG_END_ADDRESS(&CacheEntry->Data.Axp64);
                } else {
                    ReadMemory(hProcess,
                               (Address + CALLBACK_NEXT(StackFrame)),
                               &dw,
                               sizeof(DWORD),
                               &cb);
                    CALLBACK_STACK(StackFrame) = dw;
                    StackFrame->AddrPC.Offset = ALPHA_RF_PROLOG_END_ADDRESS((PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)&CacheEntry->Data.Axp64);
                }

                StackFrame->AddrFrame.Offset = Address;
                Context->IntSp = Address;

                rval = TRUE;
            }
        }
    }

    //
    // get the return address
    //
    ContextSave = *Context;
    StackFrame->AddrReturn.Offset = StackFrame->AddrPC.Offset;
    qw = 0;

    if (!WalkAlphaGetStackFrame( hProcess,
                        &StackFrame->AddrReturn.Offset,
                        &qw,
                        &ContextSave,
                        ReadMemory,
                        GetModuleBase,
                        GetFunctionEntry,
                        &StackFrame->KdHelp,
                        Use64) ) {

        StackFrame->AddrReturn.Offset = 0;

    }

    //
    // get the arguments to the function
    //
    StackFrame->Params[0] = ContextSave.IntA0;
    StackFrame->Params[1] = ContextSave.IntA1;
    StackFrame->Params[2] = ContextSave.IntA2;
    StackFrame->Params[3] = ContextSave.IntA3;

    return rval;
}


VOID
GetUnwindFunctionEntry(
    HANDLE                                hProcess,
    ULONG64                               ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64        ReadMemory,
    PGET_MODULE_BASE_ROUTINE64            GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64      GetFunctionEntry,
    BOOL                                  Use64,
    FeCacheEntry*                         CacheEntry,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY UnwindFunctionEntry,
    PULONG                                StackAdjust,
    PULONG64                              FixedReturn
    )
/*++

Routine Description:

    This function returns a function entry (RUNTIME_FUNCTION) suitable
    for unwinding from ControlPc. It encapsulates the handling of primary
    and secondary function entries so that this processing is not duplicated
    in VirtualUnwind and other similar functions.

Arguments:

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    UnwindFunctionEntry - Supplies the address of a function table entry which
        will be setup with appropriate fields for unwinding from ControlPc

Return Value:

    None.

--*/

{
    ULONG EntryType = 0;
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY SecondaryFunctionEntry = NULL;
    ULONG64 AlternateProlog;
    FeCacheEntry LocalCache;
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY FunctionEntry;
    FunctionEntryCache* Cache;
    FeCacheEntry* SecCache;

    *FixedReturn = 0;
    *StackAdjust = 0;

#if DBG
    if (ControlPc & 0x3) {
        dbPrint("GetUnwindFunctionEntry: invalid PC for unwinding (low bits set): %16.8I64x\n", ControlPc);
    }
#endif

    Cache = GetFeCache(Use64 ?
                       IMAGE_FILE_MACHINE_ALPHA64 : IMAGE_FILE_MACHINE_ALPHA,
                       TRUE);
    
    // CacheEntry should never be null, but if it is create one that
    // looks like a leaf entry for ControlPc

    if (Cache == NULL || CacheEntry == NULL) {
#if DBG
        dbPrint("\nGetUnwindFunctionEntry: Null function table entry for unwinding\n");
#endif
        UnwindFunctionEntry->BeginAddress     = ControlPc;
        UnwindFunctionEntry->EndAddress       = ControlPc+4;
        UnwindFunctionEntry->ExceptionHandler = 0;
        UnwindFunctionEntry->HandlerData      = 0;
        UnwindFunctionEntry->PrologEndAddress = ControlPc;
        return;
    }

    // Work off a local copy of the function entry passed in
    // as later function entry lookups may cause it to be
    // evicted from the cache, invalidating the pointer.
    LocalCache = *CacheEntry;
    CacheEntry = &LocalCache;
    FunctionEntry = &CacheEntry->Data.Axp64;

    //
    // Because of the secondary-to-primary function entry indirection applied by
    // Find() ControlPc may not be within the range described
    // by the supplied function entry. Call FindDirect()
    // to recover the actual (secondary) function entry.  If we don't get a
    // valid associated function entry then process the unwind with the one
    // supplied, trusting that the caller has supplied the given entry intentionally.
    //
    // A secondary function entry is a RUNTIME_FUNCTION entry where
    // PrologEndAddress is not in the range of BeginAddress to EndAddress.
    // There are three types of secondary function entries. They are
    // distinquished by the Entry Type field (2 bits):
    //
    // ALPHA_RF_NOT_CONTIGUOUS - discontiguous code
    // ALPHA_RF_ALT_ENT_PROLOG - alternate entry point prologue
    // ALPHA_RF_NULL_CONTEXT   - null-context code
    //

    if ((ControlPc <  ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
        (ControlPc >= ALPHA_RF_END_ADDRESS(FunctionEntry))) {

        // ControlPC is not in the range of the supplied function entry.
        // Get the actual function entry which is expected to be the
        // associated secondary function entry or a fixed return primary function.
#if DBG
        if (tlsvar(DebugFunctionEntries)) {
            dbPrint("\nGetUnwindFunctionEntry:LookupDirectFunctionEntry(ControlPc=%.8I64x,Use64=%d)\n", ControlPc, Use64 );
        }
#endif

        SecCache = Cache->
            FindDirect( hProcess, ControlPc, ReadMemory, GetModuleBase,
                        GetFunctionEntry );
        if (SecCache != NULL) {
            SecondaryFunctionEntry = &SecCache->Data.Axp64;
        } else {
            SecondaryFunctionEntry = NULL;
        }

        if (SecondaryFunctionEntry) {

            FE_ShowRuntimeFunctionAxp64((SecCache, "GetUnwindFunctionEntry: LookupDirectFunctionEntry"));

            // If this is a null-context tail region then unwind with a null-context-like descriptor

            if ((ControlPc >= ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry)-(ALPHA_RF_NULL_CONTEXT_COUNT(SecondaryFunctionEntry)*4)) &&
                (ControlPc <  ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                // Use the secondary function entry with PrologEndAddress = BeginAddress.
                // This ensures that the prologue is not reverse executed.

                UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
                UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
                UnwindFunctionEntry->ExceptionHandler = 0;
                UnwindFunctionEntry->HandlerData      = 0;
                UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
                return;
            }

            if ((SecondaryFunctionEntry->PrologEndAddress < ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) ||
                (SecondaryFunctionEntry->PrologEndAddress > ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                // Got a secondary function entry as expected. But if indirection doesn't point
                // to FunctionEntry then ignore it and use the caller supplied FunctionEntry.

                if (ALPHA_RF_PROLOG_END_ADDRESS(SecondaryFunctionEntry) != CacheEntry->Address) {
                    FE_ShowRuntimeFunctionAxp64((SecCache,
                                                 "GetUnwindFunctionEntry: unexpected secondary function entry from LookupDirectFunctionEntry"));
                    SecondaryFunctionEntry = NULL;
                }
            } else if (ALPHA_RF_IS_FIXED_RETURN(SecondaryFunctionEntry)) {
                // Got a fixed return entry. Switch to using the fixed return entry as the primary.

                    FunctionEntry = SecondaryFunctionEntry;
                    CacheEntry = SecCache;
                    SecondaryFunctionEntry = NULL;

            } else {

                // Got a primary function entry. Ignore it and use caller supplied FunctionEntry.
                FE_ShowRuntimeFunctionAxp64((SecCache,
                                             "GetUnwindFunctionEntry: unexpected primary function entry from LookupDirectFunctionEntry"));
                SecondaryFunctionEntry = NULL;
            }
#if DBG
        } else {
            ShowRuntimeFunctionAxp64(SecCache, "GetUnwindFunctionEntry: LookupDirectFunctionEntry returned NULL");
#endif
        }
    } else {

        // ControlPC is in the range of the supplied function entry.

        // If this is a null-context tail region then unwind with a null-context-like descriptor

        if ((ControlPc >= ALPHA_RF_END_ADDRESS(FunctionEntry)-(ALPHA_RF_NULL_CONTEXT_COUNT(FunctionEntry)*4)) &&
            (ControlPc <  ALPHA_RF_END_ADDRESS(FunctionEntry))) {

            // Use the secondary function entry with PrologEndAddress = BeginAddress.
            // This ensures that the prologue is not reverse executed.

            UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(FunctionEntry);
            UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(FunctionEntry);
            UnwindFunctionEntry->ExceptionHandler = 0;
            UnwindFunctionEntry->HandlerData      = 0;
            UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_BEGIN_ADDRESS(FunctionEntry);
            return;
        }

        // Check if it is a secondary function entry. This shouldn't happen because
        // LookupFunctionEntry is always supposed to return a primary function entry.
        // But if we get passed a secondary, then switch to it's primary. However note
        // that we've gone through this pass

        if ((FunctionEntry->PrologEndAddress < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
            (FunctionEntry->PrologEndAddress > ALPHA_RF_END_ADDRESS(FunctionEntry))) {
            SecondaryFunctionEntry = FunctionEntry;
            SecCache = Cache->ReadImage
                ( hProcess,
                  ALPHA_RF_PROLOG_END_ADDRESS(SecondaryFunctionEntry),
                  ReadMemory, GetModuleBase );
            if (SecCache != NULL) {
                SecondaryFunctionEntry = &SecCache->Data.Axp64;
            } else {
                SecondaryFunctionEntry = NULL;
            }
            FE_ShowRuntimeFunctionAxp64((SecCache,
                                         "GetUnwindFunctionEntry: received secondary function entry"));
        }
    }

    // FunctionEntry is now the primary function entry and if SecondaryFunctionEntry is
    // not NULL then it is the secondary function entry that contains the ControlPC. Setup a
    // copy of the FunctionEntry suitable for unwinding. By default use the supplied FunctionEntry.

    if (SecondaryFunctionEntry) {

        // Extract the secondary function entry type.

        EntryType = ALPHA_RF_ENTRY_TYPE(SecondaryFunctionEntry);

        if (EntryType == ALPHA_RF_NOT_CONTIGUOUS) {
            // The exception happened in the body of the procedure but in a non-contiguous
            // section of code. Regardless of what entry point was used, it is normally valid
            // to unwind using the primary entry point prologue. The only exception is when an
            // alternate prologue is specified However, there may be an
            // alternate prologue end addresss specified in which case unwind using this
            // block as though it were the primary.

            AlternateProlog = ALPHA_RF_ALT_PROLOG64(SecondaryFunctionEntry);

            if ((AlternateProlog >= ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) &&
                (AlternateProlog <  ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                // If the control PC is in the alternate prologue, use the secondary.
                // The control Pc is not in procedure context.

                if ((ControlPc >= ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) &&
                    (ControlPc <  ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                    UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
                    UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
                    UnwindFunctionEntry->ExceptionHandler = 0;
                    UnwindFunctionEntry->HandlerData      = 0;
                    UnwindFunctionEntry->PrologEndAddress = AlternateProlog;
                    return;
                }
            }

            // Fall out of the if statement to pick up the primary function entry below.
            // This code is in-procedure-context and subject to the primary's prologue
            // and exception handlers.

        } else if (EntryType == ALPHA_RF_ALT_ENT_PROLOG) {
            // Exception occured in an alternate entry point prologue.
            // Use the secondary function entry with a fixed-up PrologEndAddress.

            UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->ExceptionHandler = 0;
            UnwindFunctionEntry->HandlerData      = 0;
            UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_END_ADDRESS(UnwindFunctionEntry);

            // Check for an alternate prologue.

            AlternateProlog = ALPHA_RF_ALT_PROLOG64(SecondaryFunctionEntry);
            if (AlternateProlog >= UnwindFunctionEntry->BeginAddress &&
                AlternateProlog <  UnwindFunctionEntry->EndAddress ) {
                // The prologue is only part of the procedure
                UnwindFunctionEntry->PrologEndAddress = AlternateProlog;
            }

            return;

        } else if (EntryType == ALPHA_RF_NULL_CONTEXT) {

            // Exception occured in null-context code associated with a primary function.
            // Use the secondary function entry with a PrologEndAddress = BeginAddress.
            // There is no prologue for null-context code.

            *StackAdjust = ALPHA_RF_STACK_ADJUST(SecondaryFunctionEntry);
            UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->ExceptionHandler = 0;
            UnwindFunctionEntry->HandlerData      = 0;
            UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
            return;
        }
    }

    // FunctionEntry is only null if there was an error fetching it from a passed in
    // secondary function entry.

    if (FunctionEntry == NULL) {
#if DBG
        dbPrint("\nGetUnwindFunctionEntry: Error in FetchFunctionEntry\n");
#endif
        UnwindFunctionEntry->BeginAddress     = ControlPc;
        UnwindFunctionEntry->EndAddress       = ControlPc+4;
        UnwindFunctionEntry->ExceptionHandler = 0;
        UnwindFunctionEntry->HandlerData      = 0;
        UnwindFunctionEntry->PrologEndAddress = ControlPc;
        return;
    }

#if DBG
    if (ALPHA_RF_BEGIN_ADDRESS(FunctionEntry) >= ALPHA_RF_END_ADDRESS(FunctionEntry)) {
        ShowRuntimeFunctionAxp64(CacheEntry, "GetUnwindFunctionEntry: Warning - BeginAddress < EndAddress.");
    } else if (FunctionEntry->PrologEndAddress < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) {
        ShowRuntimeFunctionAxp64(CacheEntry, "GetUnwindFunctionEntry: Warning - PrologEndAddress < BeginAddress.");
    } else if (FunctionEntry->PrologEndAddress > ALPHA_RF_END_ADDRESS(FunctionEntry)) {
        ShowRuntimeFunctionAxp64(CacheEntry, "GetUnwindFunctionEntry: Warning - PrologEndAddress > EndAddress.");
    }
#endif

    // Use the primary function entry

    *UnwindFunctionEntry = *FunctionEntry;
    UnwindFunctionEntry->EndAddress = ALPHA_RF_END_ADDRESS(UnwindFunctionEntry);  // Remove null-context count

    // If the primary has a fixed return address, pull that out now.

    if (ALPHA_RF_IS_FIXED_RETURN(FunctionEntry)) {
        *FixedReturn = ALPHA_RF_FIXED_RETURN64(FunctionEntry);
        UnwindFunctionEntry->ExceptionHandler = 0;
        UnwindFunctionEntry->HandlerData      = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\vsym.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    vsym.c

Abstract:

    This function implements virtual symbols that can be added by the caller.

Author:

    Pat Styles (patst) 5-June-2001

Environment:

    User Mode

--*/

#include "private.h"
#include "symbols.h"
#include "globals.h"


int __cdecl
vsCompareAddrs(
    const void *one,
    const void *two
    )
{
    PVIRTUAL_SYMBOL vs1 = (PVIRTUAL_SYMBOL)one;
    PVIRTUAL_SYMBOL vs2 = (PVIRTUAL_SYMBOL)two;

    if (vs2->addr > vs1->addr)
        return -1;

    if (vs1->addr > vs2->addr)
        return 1;

    return 0;
}


BOOL
vsAddSymbol(
    PMODULE_ENTRY mi,
    PCSTR         name,
    DWORD64       addr,
    DWORD         size
    )
{
    PVIRTUAL_SYMBOL vs;
    DWORD           i;

    // look for another symbol at the same address

    vs = vsGetSymbol(mi, NULL, addr);
    if (vs) {
        SetLastError(ERROR_ALREADY_EXISTS);
        return false;
    }

    // look for an empty slot in the already existing list

    vs = vsBlankSymbol(mi);

    // not found: allow a new list or realloc to new size

    if (!vs) {
        i = mi->cvs + 1;
        if (!mi->vs) {
            assert(mi->cvs == 0);
            vs = (PVIRTUAL_SYMBOL)MemAlloc(sizeof(VIRTUAL_SYMBOL));

        } else {
            assert(mi->cvs);
            vs = (PVIRTUAL_SYMBOL)MemReAlloc(mi->vs, i * sizeof(VIRTUAL_SYMBOL));
        }

        if (!vs) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return false;
        }

        // reset the pointer and increment the count

        mi->vs = vs;
        vs = mi->vs + mi->cvs;
        mi->cvs++;
    }

    // copy in the new symbol

    CopyStrArray(vs->name, name);
    vs->addr = addr;
    vs->size = size;

    qsort(mi->vs, mi->cvs, sizeof(VIRTUAL_SYMBOL), vsCompareAddrs);

    mi->SymLoadError = SYMLOAD_OK;
    return true;
}


BOOL
vsMatchSymbol(
    PVIRTUAL_SYMBOL vs,
    PCSTR           name,
    DWORD64         addr
    )
{
    // Look for a mismatch in either name or addr.

    if (name && *name && strcmp(vs->name, name))
        return false;

    if (addr && vs->addr != addr)
        return false;

    // When passing a null name and addr, we are looking
    // for a blank entry.  Check if addr is zero.

    if (!name && !addr && vs->addr)
        return false;

    // hit!

    return true;
}


PVIRTUAL_SYMBOL
vsGetSymbol(
    PMODULE_ENTRY mi,
    PCSTR         name,
    DWORD64       addr
    )
{
    PVIRTUAL_SYMBOL vs;
    DWORD           i;

    for (vs = mi->vs, i = 0; i < mi->cvs; vs++, i++) {
        if (vsMatchSymbol(vs, name, addr))
            return vs;
    }

    return NULL;
}


BOOL
vsDeleteSymbol(
    PMODULE_ENTRY mi,
    PCSTR         name,
    DWORD64       addr
    )
{
    PVIRTUAL_SYMBOL vs;
    DWORD           i;

    // look for an empty slot in the already existing list

    vs = NULL;
    for (vs = mi->vs, i = 0; i < mi->cvs; vs++, i++) {
        if (vsMatchSymbol(vs, name, addr)) {
            vs->addr = 0;
            return true;
        }
    }

    SetLastError(ERROR_NOT_FOUND);
    return false;
}


BOOL
vsDumpSymbols(
    PMODULE_ENTRY mi
    )
    // for debugging...
{
    PVIRTUAL_SYMBOL vs;
    DWORD           i;

    if (!mi->vs)
        return false;

    for (vs = mi->vs, i = 0; i < mi->cvs; vs++, i++) {
        if (vs->addr)
            dtrace("%s %I64lx\n", vs->name, vs->addr);
    }

    return true;
}


BOOL
vsFillSymbolInfo(
    PSYMBOL_INFO    si,
    PMODULE_ENTRY   mi,
    PVIRTUAL_SYMBOL vs
    )
{
    DWORD dw;

    dw = si->MaxNameLen;
    ZeroMemory(si, sizeof(SYMBOL_INFO));
    si->MaxNameLen = dw;

    CopyString(si->Name, vs->name, si->MaxNameLen);
    si->ModBase = mi->BaseOfDll;
    si->Address = vs->addr;
    si->Size = vs->size;
    si->Flags = SYMFLAG_VIRTUAL;

    return true;
}


BOOL
vsGetSymbols(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY  mi,
    IN PCSTR          mask,
    IN DWORD64        addr,
    IN PROC           callback,
    IN PVOID          context,
    IN BOOL           use64,
    IN BOOL           unicode
    )
{
    PVIRTUAL_SYMBOL vs;
    DWORD           i;
    BOOL            fCase;
    BOOL            rc;

    if (!mi->vs)
        return callback ? true : false;

    fCase = option(SYMOPT_CASE_INSENSITIVE) ? false : true;

    for (vs = mi->vs, i = 0; i < mi->cvs; vs++, i++) {
        if (mask && *mask && strcmpre(vs->name, mask, fCase))
            continue;
        if (addr && (vs->addr != addr))
           continue;
        vsFillSymbolInfo(&mi->vssi, mi, vs);
        if (!callback)
            return true;
        rc = DoEnumCallback(pe, &mi->vssi, mi->vssi.Size, callback, context, use64, unicode);
        if (!rc) {
            mi->code = ERROR_CANCELLED;
            return false;
        }
    }

    return callback ? true : false;
}


PSYMBOL_INFO
vsFindSymbolByName(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    )
{
    if (!vsGetSymbols(pe, mi, SymName, 0, NULL, NULL, 0, 0))
        return NULL;

    if (!mi)
        mi = pe->ipmi;

    return &mi->vssi;
}


PSYMBOL_INFO
vsGetSymNextPrev(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    BOOL            direction
    )
{
    PVIRTUAL_SYMBOL vs;
    PVIRTUAL_SYMBOL vsprev;
    DWORD           i;

    // no entries, bail

    if (!mi->cvs)
        return NULL;

    // walk to the entry with a higher address

    vsprev = NULL;
    for (vs = mi->vs, i = 0; i < mi->cvs; vs++, i++) {
        if (vs->addr < addr)
            vsprev = vs;
        if (vs->addr > addr)
            break;
    }

    if (direction < 0)
        vs = vsprev;
    else if (i == mi->cvs)
        return NULL;

    if (!vs)
        return NULL;

    vsFillSymbolInfo(&mi->vssi, mi, vs);
    return &mi->vssi;
}


PSYMBOL_INFO
vsGetSymFromAddr(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    PDWORD64        disp
    )
{
    PVIRTUAL_SYMBOL vs;
    DWORD           i;

    // find the entry with a higher address

    for (vs = mi->vs, i = 0; i < mi->cvs; vs++, i++) {
        if (vs->addr > addr)
            break;
    }

    // no hit, bail

    if (!i)
        return NULL;

    // rewind back to the hit.
    // If the symbol has a size, make sure we're within the limits.

    vs--;
    if (vs->size &&  (vs->addr + vs->size) < addr)
        return NULL;

    // bullseye!

    vsFillSymbolInfo(&mi->vssi, mi, vs);
    if (disp)
        *disp = addr - mi->vssi.Address;
    return &mi->vssi;
}


PSYMBOL_ENTRY
vsGetSymEntryFromAddr(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    PDWORD64        disp
    )
{
    PSYMBOL_INFO si;

    si = vsGetSymFromAddr(mi, addr, disp);
    if (!si)
        return NULL;

    si2se(si, &mi->vsTmpSym);
    if (disp)
        *disp = addr - si->Address;
    return &mi->vsTmpSym;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\walkarm.c ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    walkarm.c

Abstract:

    This file implements the ARM stack walking api.

Author:

    Wesley Witt (wesw)  1-Oct-1993

    Glenn Hirschowitz   Jan-1995

    Janet Schneider     17-March-1997

    Robert Denkewalter  Jan-1999
        Added Thumb unwinder, modified WalkArm, added caching,
        split FunctionTableAccessOrTranslateAddress, added global hProcess, etc., 

Environment:

    User Mode

--*/

#define TARGET_ARM
#define _IMAGEHLP_SOURCE_
//#define _CROSS_PLATFORM_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "symbols.h"
#include "fecache.hpp"
#include "globals.h"

#include <arminst.h>

#define MODE_ARM        0
#define MODE_THUMB      1
#define REGISTER_SIZE   4

//
// XXX drewb - Need to provide a real implementation.
//

DWORD
WceTranslateAddress(HANDLE hpid,
                    HANDLE htid,
                    DWORD   addrIn,
                    DWORD   dwStackFrameAddr,
                    DWORD * pdwNewStackFrameAddr)
{
    *pdwNewStackFrameAddr = 0;
    return addrIn;
}

//
// Conspicuously absent from VC6's nt headers.
//
#define STRI_LR_SPU_MASK    0x073de000L // Load or Store of LR with stack update
#define STRI_LR_SPU_INSTR   0x052de000L // Store LR (with immediate offset, update SP)

#if DBG

// This is our local version of "assert."
#define TestAssumption(c, m) assert(c)

#else

#define TestAssumption(c, m)

#endif


// If the Thumb unwinder handles the unwind,
// it'll return UNWIND_HANDLED, so that the
// ARM unwinder will not bother...
#define UNWIND_NOT_HANDLED 0
#define UNWIND_HANDLED 1


// Face it:  Many of the routines in this module require these routines 
// and variables.  Further, WalkArm is the only way into this module.
// Just let WalkArm initialize these on every pass, and then we don't 
// have to keep passing them around.  Further, we can build nice wrappers
// around them to make them easier to use.
//
// XXX drewb - However, this isn't thread-safe and technically
// is broken.  It's not important enough to fix right now.
// A similar approach with putting the variables in TLS data would
// be a simple fix and would preserve the convenience.  It should
// probably be built into StackWalk64 itself so that it's available
// by default in all walkers.


static HANDLE UW_hProcess;
static HANDLE UW_hThread;

static PREAD_PROCESS_MEMORY_ROUTINE64 UW_ReadMemory;
static PFUNCTION_TABLE_ACCESS_ROUTINE64 UW_FunctionTableAccess;

// We do this enough to make a special routine for it.
static BOOL
LoadWordIntoRegister(ULONG StartAddr, LPDWORD pRegister)
{
    BOOL    rc;
    ULONG   cb;

    rc = UW_ReadMemory( UW_hProcess, (ULONG64)(LONG)StartAddr,
                        (LPVOID)pRegister, REGISTER_SIZE, &cb );
    if (!rc || (cb != REGISTER_SIZE)) {
        return FALSE;
    } else {
        return rc;
    }
}

static BOOL
ReadMemory(ULONG StartAddr, ULONG Size, LPVOID Buffer)
{
    BOOL    rc;
    ULONG   cb;

    rc = UW_ReadMemory( UW_hProcess, (ULONG64)(LONG)StartAddr,
                        (LPVOID)Buffer, Size, &cb );
    if (!rc || (cb != Size)) {
        return FALSE;
    } else {
        return rc;
    }
}


#define EXCINFO_NULL_HANDLER    0
// For ARM, prolog helpers have HandlerData == 1, not 2 as in MIPS
#define EXCINFO_PROLOG_HELPER   1
// For ARM, epilog helpers have HandlerData == 2, not 3 as in MIPS
#define EXCINFO_EPILOG_HELPER   2

#define IS_HELPER_FUNCTION(rfe)                                 \
(                                                               \
    (rfe)?                                                      \
    (                                                           \
        ((rfe)->ExceptionHandler==EXCINFO_NULL_HANDLER) &&      \
        (   ((rfe)->HandlerData==EXCINFO_PROLOG_HELPER) ||      \
            ((rfe)->HandlerData==EXCINFO_EPILOG_HELPER)         \
        )                                                       \
    ):                                                          \
    FALSE                                                       \
)

#define IS_PROLOG_HELPER_FUNCTION(rfe)                          \
(                                                               \
    (rfe)?                                                      \
    (                                                           \
        ((rfe)->ExceptionHandler==EXCINFO_NULL_HANDLER) &&      \
        ((rfe)->HandlerData==EXCINFO_PROLOG_HELPER)             \
    ):                                                          \
    FALSE                                                       \
)

#define IS_EPILOG_HELPER_FUNCTION(rfe)                          \
(                                                               \
    (rfe)?                                                      \
    (                                                           \
        ((rfe)->ExceptionHandler==EXCINFO_NULL_HANDLER) &&      \
        ((rfe)->HandlerData==EXCINFO_EPILOG_HELPER)             \
    ):                                                          \
    FALSE                                                       \
)

static int
ThumbVirtualUnwind (DWORD,PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY,
                    PARM_CONTEXT,DWORD*);


static BOOL
WalkArmGetStackFrame(
    LPDWORD                           ReturnAddress,
    LPDWORD                           FramePointer,
    PARM_CONTEXT                      Context,
    int *                             Mode
    );

static VOID
WalkArmDataProcess(
    ARMI    instr,
    PULONG  Register
    );

static BOOL 
WalkArmLoadI(
    ARMI                         instr,
    PULONG                       Register
    );

static BOOL
WalkArmLoadMultiple(
    PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    ARMI                            instr,
    PULONG                          Register
    );

static BOOL
CheckConditionCodes(
    ULONG CPSR,
    DWORD instr
    );

//
// The saved registers are the permanent general registers (ie. those
// that get restored in the epilog) R4-R11 R13-R15
//

#define SAVED_REGISTER_MASK 0x0000eff0 /* saved integer registers */
#define IS_REGISTER_SAVED(Register) ((SAVED_REGISTER_MASK >> Register) & 1L)


BOOL
WalkArm(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    static DWORD PrevFramePC;
    static ARM_CONTEXT SavedContext;
    BOOL rval;
    PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY Rfe;
    IMAGE_ARM_RUNTIME_FUNCTION_ENTRY LoopRFE;
    DWORD TempPc, TempFp;
    PARM_CONTEXT Context = (PARM_CONTEXT)ContextRecord;

    // Initialize the module's "global" variables and routines:
    UW_hProcess = hProcess;
    UW_hThread = hThread;
    UW_ReadMemory = ReadMemoryRoutine;
    UW_FunctionTableAccess = FunctionTableAccessRoutine;

    // This way of unwinding differs from the other, "old" ways of unwinding.
    // It removes duplicate code from WalkArmInit and WalkArmNext, and it saves
    // the previous stack frame so that each stack frame is unwound only once.

    rval = TRUE;

    do {

        Rfe = (PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY)
            UW_FunctionTableAccess( UW_hProcess, Context->Pc );
        if (Rfe) {
            LoopRFE = *Rfe;
        } else {
            ZeroMemory(&LoopRFE, sizeof(LoopRFE));
        }

        // If this is the first pass in the unwind,
        // fill in the SavedContext from the
        // Context passed in, and initialize the StackFrame fields
        if (!StackFrame->Virtual) {

            ZeroMemory(StackFrame, sizeof(*StackFrame));
            // Set Virtual so that next pass, we know we're not initializing
            StackFrame->Virtual = TRUE;

            StackFrame->AddrPC.Mode     = AddrModeFlat;
            StackFrame->AddrFrame.Mode  = AddrModeFlat;
            StackFrame->AddrReturn.Mode = AddrModeFlat;

            PrevFramePC = 0;
            SavedContext = *Context;
        } 

        // Use the context we saved from last time (or just initialized) 
        // to set the previous frame.
        *Context = SavedContext;
        
        DWORD dwNewSp = 0;

        StackFrame->AddrPC.Offset =
            WceTranslateAddress(UW_hProcess, UW_hThread,
                                Context->Pc, Context->Sp, &dwNewSp);
        if (dwNewSp) {
            Context->Sp = dwNewSp;
        }
        StackFrame->AddrFrame.Offset = Context->Sp;
        
        // PC == 0 means unwinding is finished.
        if ( StackFrame->AddrPC.Offset != 0x0 ) {
            
            int Mode;
            
            PrevFramePC = TempPc = SavedContext.Pc;
            TempFp = SavedContext.Sp;

            // We already have the frame we want to return, except for one
            // little detail.  We want the return address from this frame.
            // So, we unwind it.  This unwinding actually yields the
            // previous frame.  We don't want to duplicate this effort
            // next time, so we'll save the results.
            if (WalkArmGetStackFrame(&TempPc, &TempFp, &SavedContext, &Mode)) {

                SavedContext.Pc = TempPc;

                TestAssumption(TempFp == SavedContext.Sp, "FP wrong2");
                StackFrame->AddrReturn.Offset = SavedContext.Pc;

                StackFrame->Params[0] = SavedContext.R0;
                StackFrame->Params[1] = SavedContext.R1;
                StackFrame->Params[2] = SavedContext.R2;
                StackFrame->Params[3] = SavedContext.R3;
                
            } else {
                // No place to return to...
                StackFrame->AddrReturn.Offset = 0;

                // ...and the saved context probably has a bogus PC.
                SavedContext.Pc = 0;
                rval = FALSE;
            }
        } else {
            rval = FALSE;
        }
    } while (IS_HELPER_FUNCTION(&LoopRFE) && rval);

    if (rval) {
        StackFrame->FuncTableEntry =
            UW_FunctionTableAccess(UW_hProcess, StackFrame->AddrPC.Offset);
    }

    return rval;
}


static DWORD
ArmVirtualUnwind (
    DWORD                             ControlPc,
    PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    PARM_CONTEXT                      Context
    )

/*++

Routine Description:

    This function virtually unwinds the specfified function by executing its
    prologue code backwards (or its epilog forward).

    If the function is a leaf function, then the address where control left
    the previous frame is obtained from the context record. If the function
    is a nested function, but not an exception or interrupt frame, then the
    prologue code is executed backwards and the address where control left
    the previous frame is obtained from the updated context record.

    Otherwise, an exception or interrupt entry to the system is being unwound
    and a specially coded prologue restores the return address twice. Once
    from the fault instruction address and once from the saved return address
    register. The first restore is returned as the function value and the
    second restore is place in the updated context record.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    Context - Supplies the address of a context record.


Return Value:

    The address where control left the previous frame is returned as the
    function value.

--*/

{
    ULONG   Address;
    LONG    cb;
    DWORD   EpilogPc;
    BOOL    ExecutingEpilog;
    BOOL    IsFramePointer = FALSE;
    LONG    i,j;
    ARMI    instr, instr2;
    BOOL    PermanentsRestored = FALSE;
    ARMI    Prolog[50]; // The prolog will never be more than 10 instructions
    PULONG  Register;
    BOOL    bEpiWindAlready = FALSE;
    ARM_CONTEXT ContextBeforeEpiWind;

    //
    // NOTE:  When unwinding the call stack, we assume that all instructions
    // in the prolog have the condition code "Always execute."  This is not
    // necessarily true for the epilog.
    //

    if( !FunctionEntry ) {
        return 0;
    }

    Register = &Context->R0;

    if( FunctionEntry->PrologEndAddress - FunctionEntry->BeginAddress == 0 ) {

        //
        // No prolog, so just copy the link register into the PC and return.
        //

        goto CopyLrToPcAndExit;

    }

    //
    // First check to see if we are in the epilog.  If so, forward execution
    // through the end of the epilog is required.  Epilogs are composed of the
    // following:
    //
    // An ldmdb which uses the frame pointer, R11, as the base and updates
    // the PC.
    //
    // -or-
    //
    // A stack unlink (ADD R13, x) if necessary, followed by an ldmia which
    // updates the PC or a single mov instruction to copy the link register
    // to the PC
    //
    // -or-
    //
    // An ldmia which updates the link register, followed by a regular
    // branch instruction.  (This is an optimization when the last instruction
    // before a return is a call.)
    //
    // A routine may also have an empty epilog.  (The last instruction is to
    // branch to another routine, and it doesn't modify any permanent
    // registers.)  But, in this case, we would also have an empty prolog.
    //
    // If we are in an epilog, and the condition codes dictate that the
    // instructions should not be executed, treat this as not an epilog at all.
    //

    // backup the context before trying to execute the epilogue forward   
    ContextBeforeEpiWind = *Context;

    EpilogPc = ControlPc;

    if( EpilogPc >= FunctionEntry->PrologEndAddress ) {

        //
        // Check the condition code of the first instruction. If it won't be
        // executed, don't bother checking what type of instruction it is.
        //

        if(!ReadMemory(EpilogPc, 4L, (LPVOID)&instr ))
            return 0;

        ExecutingEpilog = CheckConditionCodes( Register[16],
                                               instr.instruction );

        while( ExecutingEpilog ) {

            if( !ReadMemory( EpilogPc, 4L, (LPVOID)&instr ))
                return 0;

            //
            // Test for these instructions:
            //
            //      ADD R13, X - stack unlink
            //
            //      MOV PC, LR - return
            //
            //      LDMIA or LDMDB including PC - update registers and return
            //      ( SP )   ( FP )
            //
            //      LDMIA including LR, followed by a branch
            //          Update registers and branch. (In our case, return.)
            //
            //      A branch preceded by an LDMIA including LR
            //          Copy the LR to the PC to get the call stack
            //

            if(( instr.instruction & ADD_SP_MASK ) == ADD_SP_INSTR ) {

                WalkArmDataProcess( instr, Register );

            } else if(( instr.instruction & MOV_PC_LR_MASK ) == MOV_PC_LR ) {

                WalkArmDataProcess( instr, Register );
                goto ExitReturnPc;

            } else if(( instr.instruction & LDM_PC_MASK ) == LDM_PC_INSTR ) {

                if( !WalkArmLoadMultiple( FunctionEntry,
                                          instr,
                                          Register )) {
                    return 0;
                }
                goto ExitReturnPc;

            } else if(( instr.instruction & LDM_LR_MASK ) == LDM_LR_INSTR ) {

                if( !ReadMemory( (ULONG)EpilogPc + 4, 4L, (LPVOID)&instr2))
                    return 0;

                if (((instr2.instruction & B_BL_MASK ) == B_INSTR) || ((instr2.instruction & BX_MASK ) == BX_INSTR)){

                    if( !WalkArmLoadMultiple( FunctionEntry,
                                              instr,
                                              Register )) {
                        return 0;
                    }
                    goto CopyLrToPcAndExit;

                } else {

                    ExecutingEpilog = FALSE;

                }

            } else if (((instr.instruction & B_BL_MASK ) == B_INSTR) || ((instr.instruction & BX_MASK ) == BX_INSTR)) {

                if( !ReadMemory( (ULONG)EpilogPc - 4, 4L,(LPVOID)&instr2))
                    return 0;

                if(( instr2.instruction & LDM_LR_MASK ) == LDM_LR_INSTR ) {

                    goto CopyLrToPcAndExit;

                }

            } else {

                ExecutingEpilog = FALSE;

            }
            EpilogPc += 4;
            bEpiWindAlready = TRUE;
        }

    }

    //
    // We were not in the epilog. Load in the prolog, and reverse execute it.
    //

    if (bEpiWindAlready) 
    {
        // if we have already winded some instructions that we
        // thought to be the epilog, we may have mess up with the context
        // restore the initial context
        *Context = ContextBeforeEpiWind;
    }
    cb = FunctionEntry->PrologEndAddress - FunctionEntry->BeginAddress;

    if( cb > sizeof( Prolog )) {
        assert( FALSE ); // The prolog should never be more than 10 instructions
        return 0;
    }

    if( !ReadMemory( FunctionEntry->BeginAddress, cb, (LPVOID)Prolog))
        return 0;

    //
    // Check to see if we're already in the prolog.
    //

    if( ControlPc < FunctionEntry->PrologEndAddress ) {

        cb -= (  FunctionEntry->PrologEndAddress - ControlPc );

    }

    //
    // Reverse execute starting with the last instruction in the prolog
    // that has been executed.
    //

    i = cb/4;

    i--;

    while( i >= 0 ) {

        if(( Prolog[i].instruction & DATA_PROC_MASK ) == DP_R11_INSTR ) {

            //
            // We have a frame pointer.
            //

            IsFramePointer = TRUE;

        } else if((( Prolog[i].instruction & SUB_SP_MASK ) == SUB_SP_INSTR) ||
                  (( Prolog[i].instruction & ADD_SP_MASK ) == ADD_SP_INSTR)
                 ) {

            //
            // This is a stack link.  Unlink the stack.
            //

            if(( Prolog[i].dataproc.bits != 0x1 ) &&
               ( Prolog[i].dpshi.rm == 0xc )) {

                //
                // Look for an LDR instruction above this one.
                //

                j = i - 1;

                while(( j >= 0 ) &&
                      (( Prolog[j].instruction & LDR_MASK ) != LDR_PC_INSTR )) {

                    j--;

                }

                if( j < 0 ) {

                    assert( FALSE );  // This should never happen
                    return 0;

                }

                //
                // Get the address of the ldr instruction + 8 + the offset
                //

                Address = (( j*4 + FunctionEntry->BeginAddress ) +
                             Prolog[j].ldr.offset  ) + 8;

                //
                // R12 is the value at that location.
                //

                if( !LoadWordIntoRegister(Address, &Register[12] ))
                    return 0;
            }

            //
            // Change the subtract to an add (or the add to a subtract)
            // and execute the instruction
            //

            if( Prolog[i].dataproc.opcode == OP_SUB ) {
                Prolog[i].dataproc.opcode = OP_ADD;
            } else {
                Prolog[i].dataproc.opcode = OP_SUB;
            }

            WalkArmDataProcess( Prolog[i], Register );

        } else if(( Prolog[i].instruction & STM_MASK ) == STM_INSTR ) {

            if( Prolog[i].ldm.reglist & 0x7ff0 ) { // Check for permanent regs

                //
                // This is the instruction that stored all of the permanent
                // registers.  Change the reglist to update R13 (SP) instead of
                // R12, and change the STMDB to an LDMDB of R11 or an LDMIA of
                // R13.
                // Note:  We are restoring R14 (LR) - so we'll need to copy
                // it to the PC at the end of this function.
                //

                if(( Prolog[i].ldm.reglist & 0x1000 ) &&
                  !( Prolog[i].ldm.reglist & 0x2000 )) {

                    Prolog[i].ldm.reglist &= 0xefff;    // Mask out R12
                    Prolog[i].ldm.reglist |= 0x2000;    // Add in R13 (SP)

                }

                if(( Prolog[i].ldm.reglist & 0x2000 ) || IsFramePointer ) {

                    Prolog[i].ldm.w = 0;    // Clear write-back bit.

                }

                Prolog[i].ldm.l = 1;    // Change to a load.

                if( IsFramePointer ) {

                    Prolog[i].ldm.u = 0;    // Decrement
                    Prolog[i].ldm.p = 1;    // Before
                    Prolog[i].ldm.rn = 0xb; // R11

                } else {

                    Prolog[i].ldm.u = 1;    // Increment
                    Prolog[i].ldm.p = 0;    // After
                    Prolog[i].ldm.rn = 0xd; // R13 (Stack pointer)

                }

                if( !WalkArmLoadMultiple( FunctionEntry,
                                          Prolog[i],
                                          Register )) {
                    return 0;
                }

                PermanentsRestored = TRUE;

            } else if( !PermanentsRestored ) {

                //
                // This is the instruction to load the arguments.  Reverse
                // execute this instruction only if the permanent registers
                // have not been restored.
                //

                Prolog[i].ldm.l = 1;    // Change to a load.
                Prolog[i].ldm.u = 1;    // Increment
                Prolog[i].ldm.p = 0;    // After

                if( !WalkArmLoadMultiple( FunctionEntry,
                                          Prolog[i],
                                          Register )) {
                    return 0;
                }

            }

        //
        // ajtuck 12/21/97 - added changes from Arm compiler team's unwind.c per jls
        //
        } else if ((Prolog[i].instruction & STRI_LR_SPU_MASK) == STRI_LR_SPU_INSTR) {
            // Store of the link register that updates the stack as a base
            // register must be reverse executed to restore LR and SP
            // to their values on entry. This type of prolog is generated
            // for finally funclets.
            Prolog[i].ldr.l = 1;    // Clange to a load.
            // Since we are updating the base register, we need to change
            // when the offset is added to reverse execute the store.
            if (Prolog[i].ldr.p == 1)
                Prolog[i].ldr.p = 0;
            else
                Prolog[i].ldr.p = 1;
            // And negate the offset
            if (Prolog[i].ldr.u == 1)
                Prolog[i].ldr.u = 0;
            else
                Prolog[i].ldr.u = 1;
            if (!WalkArmLoadI(Prolog[i], Register))
                return ControlPc;
 
            // NOTE: Code could be added above to execute the epilog which
            // in this case would be a load to the PC that updates SP as
            // the base register. Since the epilog will always be only one
            // instruction in this case it is not needed since reverse 
            // executing the prolog will have the same result.

        }

        i--;

    }

    //
    // Move the link register into the PC and return.
    //
CopyLrToPcAndExit:

    // To continue unwinding, put the Link Register into
    // the Program Counter slot and carry on; stopping
    // when the PC says 0x0.  However, the catch is that
    // for ARM the Link Register at the bottom of the
    // stack says 0x4, not 0x0 as we expect.
    // So, do a little dance to take an LR of 0x4
    // and turn it into a PC of 0x0 to stop the unwind.
    // -- stevea 10/7/99.
    if( Register[14] != 0x4 )
        Register[15] = Register[14];
    else
        Register[15] = 0x0;

ExitReturnPc:
    return Register[15];
}

BOOL
WalkArmGetStackFrame(
    LPDWORD                           ReturnAddress,
    LPDWORD                           FramePointer,
    PARM_CONTEXT                      Context,
    int *                             Mode
    )
{
    PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY Rfe;
    IMAGE_ARM_RUNTIME_FUNCTION_ENTRY PcFe;
    DWORD dwRa;

    if (Mode) {
        *Mode = MODE_ARM;
    }

    TestAssumption(*ReturnAddress == Context->Pc, "WAGSF:SF-Cxt mismatch!");

    Rfe = (PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY)
        UW_FunctionTableAccess(UW_hProcess, *ReturnAddress);
    if (!Rfe) {
        // For leaf functions, just return the Lr as the return Address.
        dwRa = Context->Pc = Context->Lr;
    } else {
        PcFe = *Rfe;
        if (ThumbVirtualUnwind (*ReturnAddress, &PcFe, Context,
                                &dwRa) == UNWIND_HANDLED) {
            // The thumb unwinder handled it.
            if (Mode) {
                *Mode = MODE_THUMB;
            }
        } else {
            // Now, let the ARM unwinder try it.
            dwRa = ArmVirtualUnwind( *ReturnAddress, &PcFe, Context );
        }
    }

    DWORD dwNewSp = 0;

    *ReturnAddress = WceTranslateAddress(UW_hProcess, UW_hThread,
                                         dwRa, Context->Sp, &dwNewSp);
    if (dwNewSp)
    {
        Context->Sp = dwNewSp;
    }

    *FramePointer  = Context->Sp;

    return TRUE;
}

static VOID
WalkArmDataProcess(
    ARMI    instr,
    PULONG  Register
    )

/*++

Routine Description:

    This function executes an ARM data processing instruction using the
    current register set. It automatically updates the destination register.

Arguments:

    instr      The ARM 32-bit instruction

    Register   Pointer to the ARM integer registers.

Return Value:

    None.

--*/

{
    ULONG Op1, Op2;
    ULONG Cflag = (Register[16] & 0x20000000L) == 0x20000000L; // CPSR
    ULONG shift;

    //
    // We are checking for all addressing modes and op codes, even though
    // the prolog and epilog don't use them all right now.  In the future,
    // more instructions and addressing modes may be added.
    //

    //
    // Figure out the addressing mode (there are 11 of them), and get the
    // operands.
    //

    Op1 = Register[ instr.dataproc.rn ];

    if( instr.dataproc.bits == 0x1 ) {

        //
        // Immediate addressing - Type 1
        //

        Op2 = _lrotr( instr.dpi.immediate,
                      instr.dpi.rotate * 2 );

    } else {

        //
        // Register addressing - start by getting the value of Rm.
        //

        Op2 = Register[ instr.dpshi.rm ];

        if( instr.dprre.bits == 0x6 ) {

            //
            // Rotate right with extended - Type 11
            //

            Op2 = ( Cflag << 31 ) | ( Op2 >> 1 );

        } else if( instr.dataproc.operand2 & 0x10 ) {

            //
            // Register shifts. Types 4, 6, 8, and 10
            //

            //
            // Get the shift value from the least-significant byte of the
            // shift register.
            //

            shift = Register[ instr.dpshr.rs ];

            shift &= 0xff;

            switch( instr.dpshr.bits ) {

                case 0x1: //  4 Logical shift left by register

                    if( shift >= 32 ) {

                        Op2 = 0;

                    } else {

                        Op2 = Op2 << shift;

                    }
                    break;

                case 0x3: //  6 Logical shift right by register

                    if( shift >= 32 ) {

                        Op2 = 0;

                    } else {

                        Op2 = Op2 >> shift;

                    }
                    break;

                case 0x5: //  8 Arithmetic shift right by register

                    if( shift >= 32 ) {

                        if( Op2 & 0x80000000 ) {

                            Op2 = 0xffffffff;

                        } else {

                            Op2 = 0;

                        }

                    } else {

                        Op2 = (LONG)Op2 >> shift;

                    }
                    break;

                case 0x7: // 10 Rotate right by register

                    if( !( shift == 0 ) && !(( shift & 0xf ) == 0 ) ) {

                        Op2 = _lrotl( Op2, shift );

                    }

                default:
                    break;

            }

        } else {

            //
            // Immediate shifts. Types 2, 3, 5, 7, and 9
            //

            //
            // Get the shift value from the instruction.
            //

            shift = instr.dpshi.shift;

            switch( instr.dpshi.bits ) {

                case 0x0: // 2,3 Register, Logical shift left by immediate

                    if( shift != 0 ) {

                        Op2 = Op2 << shift;

                    }
                    break;

                case 0x2: // 5 Logical shift right by immediate

                    if( shift == 0 ) {

                        Op2 = 0;

                    } else {

                        Op2 = Op2 >> shift;

                    }
                    break;

                case 0x4: // 7 Arithmetic shift right by immediate

                    if( shift == 0 ) {

                        Op2 = 0;

                    } else {

                        Op2 = (LONG)Op2 >> shift;

                    }
                    break;

                case 0x6: // 9 Rotate right by immediate

                    Op2 = _lrotl( Op2, shift );
                    break;

                default:
                    break;

            }

        }

    }

    //
    // Determine the result (the new PC), based on the opcode.
    //

    switch( instr.dataproc.opcode ) {

        case OP_AND:

            Register[ instr.dataproc.rd ] = Op1 & Op2;
            break;

        case OP_EOR:

            Register[ instr.dataproc.rd ] = Op1 ^ Op2;
            break;

        case OP_SUB:

            Register[ instr.dataproc.rd ] = Op1 - Op2;
            break;

        case OP_RSB:

            Register[ instr.dataproc.rd ] = Op2 - Op1;
            break;

        case OP_ADD:

            Register[ instr.dataproc.rd ] = Op1 + Op2;
            break;

        case OP_ADC:

            Register[ instr.dataproc.rd ] = (Op1 + Op2) + Cflag;
            break;

        case OP_SBC:

            Register[ instr.dataproc.rd ] = (Op1 - Op2) - ~Cflag;
            break;

        case OP_RSC:

            Register[ instr.dataproc.rd ] = (Op2 - Op1) - ~Cflag;
            break;

        case OP_ORR:

            Register[ instr.dataproc.rd ] = Op1 | Op2;
            break;

        case OP_MOV:

            Register[ instr.dataproc.rd ] = Op2;
            break;

        case OP_BIC:

            Register[ instr.dataproc.rd ] = Op1 & ~Op2;
            break;

        case OP_MVN:

            Register[ instr.dataproc.rd ] = ~Op2;
            break;

        case OP_TST:
        case OP_TEQ:
        case OP_CMP:
        case OP_CMN:
        default:

            //
            // These instructions do not have a destination register.
            // There is nothing to do.
            //

            break;

    }

}

static BOOL
WalkArmLoadMultiple(
    PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY   FunctionEntry,
    ARMI                            instr,
    PULONG                          Register
    )

/*++

Routine Description:

    This function executes an ARM load multiple instruction.

Arguments:

    FunctionEntry   Supplies the address of the function table entry for the
                    specified function.

    instr           The ARM 32-bit instruction

    Register        Pointer to the ARM integer registers.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

{
    ULONG cb;
    LONG i;
    ULONG RegList;
    PULONG Rn;

    //
    // Load multiple with the PC bit set.  We are currently checking for all
    // four addressing modes, even though decrement before and increment
    // after are the only modes currently used in the epilog and prolog.
    //

    //
    // Rn is the address at which to begin, and RegList is the bit map of which
    // registers to read.
    //

    Rn = (PULONG)(ULONG_PTR)Register[ instr.ldm.rn ];
    RegList = instr.ldm.reglist;

    if( instr.ldm.p ) {

        if( instr.ldm.u ) {

            //
            // Increment before
            //

            for( i = 0; i <= 15; i++ ) {

                if( RegList & 0x1 ) {

                    Rn++;

                    if(!LoadWordIntoRegister((ULONG)(ULONG_PTR)Rn,&Register[i])){
                        return FALSE;
                    }

                }

                RegList = RegList >> 1;

            }


        } else {

            //
            // Decrement before
            //

            for( i = 15; i >= 0; i-- ) {

                if( RegList & 0x8000 ) {

                    Rn--;

                    if( !LoadWordIntoRegister((ULONG)(ULONG_PTR)Rn,&Register[i])) {
                        return FALSE;
                    }

                }

                RegList = RegList << 1;

            }

        }

    } else {

        if( instr.ldm.u ) {

            //
            // Increment after
            //

            for( i = 0; i <= 15; i++ ) {

                if( RegList & 0x1 ) {

                    if( !LoadWordIntoRegister((ULONG)(ULONG_PTR)Rn,&Register[i])) {
                        return FALSE;
                    }

                    Rn++;

                }

                RegList = RegList >> 1;

            }


        } else {

            //
            // Decrement after
            //

            for( i = 15; i >= 0; i-- ) {

                if( RegList & 0x8000 ) {

                    if( !LoadWordIntoRegister((ULONG)(ULONG_PTR)Rn,&Register[i])) {
                        return FALSE;
                    }

                    Rn--;

                }

                RegList = RegList << 1;

            }

        }

    }

    if( instr.ldm.w ) {

        //
        // Update the base register.
        //

        Register[ instr.ldm.rn ] = (ULONG)(ULONG_PTR)Rn;

    }

    return TRUE;

}

static BOOL
WalkArmLoadI(
    ARMI                         instr, 
    PULONG                       Register
    )
/*++
Routine Description:
    This function executes an ARM load instruction with an immediat offset.

Arguments:
    instr           The ARM 32-bit instruction

    Register        Pointer to the ARM integer registers.

Return Value:
    TRUE if successful, FALSE otherwise.
--*/
{
    LONG offset;
    LONG size;
    PULONG Rn;
    DWORD cb;

    Rn = (PULONG)(ULONG_PTR)Register[instr.ldr.rn];
    offset = instr.ldr.offset;
    if (instr.ldr.u == 0)
        offset = -offset;
    if (instr.ldr.b == 0)
        size = 4;
    else
        size = 1;

    if (instr.ldm.p) { // add offset before transfer
        if( !ReadMemory( (ULONG)(ULONG_PTR)(Rn + offset), size, (LPVOID)&Register[instr.ldr.rd]))
            return FALSE;
        if (instr.ldr.w)
            Register[instr.ldr.rn] += offset;
    } else {
        if( !ReadMemory( (ULONG)(ULONG_PTR)Rn, size, (LPVOID)&Register[instr.ldr.rd]))
            return FALSE;
        if (instr.ldr.w)
            Register[instr.ldr.rn] += offset;
    }

    return TRUE;
}

static BOOL
CheckConditionCodes(
    ULONG CPSR,
    DWORD instr
    )
/*++

Routine Description:

    Checks the condition codes of the instruction and the values of the
    condition flags in the current program status register, and determines
    whether or not the instruction will be executed.

Arguments:

    CPSR    -   The value of the Current Program Status Register.
    instr   -   The instruction to analyze.

Return Value:

    TRUE if the instruction will be executed, FALSE otherwise.

--*/
{
    BOOL Execute = FALSE;
    BOOL Nset = (CPSR & 0x80000000L) == 0x80000000L;
    BOOL Zset = (CPSR & 0x40000000L) == 0x40000000L;
    BOOL Cset = (CPSR & 0x20000000L) == 0x20000000L;
    BOOL Vset = (CPSR & 0x10000000L) == 0x10000000L;

    instr &= COND_MASK;

    switch( instr ) {

        case COND_EQ:   // Z set

            if( Zset ) Execute = TRUE;
            break;

        case COND_NE:   // Z clear

            if( !Zset ) Execute = TRUE;
            break;

        case COND_CS:   // C set

            if( Cset ) Execute = TRUE;
            break;

        case COND_CC:   // C clear

            if( !Cset ) Execute = TRUE;
            break;

        case COND_MI:   // N set

            if( Nset ) Execute = TRUE;
            break;

        case COND_PL:   // N clear

            if( !Nset ) Execute = TRUE;
            break;

        case COND_VS:   // V set

            if( Vset ) Execute = TRUE;
            break;

        case COND_VC:   // V clear

            if( !Vset ) Execute = TRUE;
            break;

        case COND_HI:   // C set and Z clear

            if( Cset && !Zset ) Execute = TRUE;
            break;

        case COND_LS:   // C clear or Z set

            if( !Cset || Zset ) Execute = TRUE;
            break;

        case COND_GE:   // N == V

            if(( Nset && Vset ) || ( !Nset && !Vset )) Execute = TRUE;
            break;

        case COND_LT:   // N != V

            if(( Nset && !Vset ) || ( !Nset && Vset )) Execute = TRUE;
            break;

        case COND_GT:   // Z clear, and N == V

            if( !Zset &&
              (( Nset && Vset ) || ( !Nset && !Vset ))) Execute = TRUE;
            break;

        case COND_LE:   // Z set, and N != V

            if( Zset &&
              (( Nset && !Vset ) || ( !Nset && Vset ))) Execute = TRUE;
            break;

        case COND_AL:   // Always execute

            Execute = TRUE;
            break;

        default:
        case COND_NV:   // Never - undefined.

            assert( FALSE );
            break;

    }

    return Execute;
}


















/*
    THUMB!!!
*/

typedef struct _DcfInst {
    int InstNum;
    union {
        DWORD Auxil;
        DWORD Rd;
    };
    union {
        DWORD Aux2;
        DWORD Rs;
    };
} DcfInst;

typedef struct _DIList {
    DWORD Val,Mask;
    int InstNum;
    DWORD RdMask;
    int RdShift;
    DWORD RsMask;
    int RsShift;
} DIList;

DIList dilistThumb[] = {
#define DI_PUSH     0x02
#define DI_POP      0x03
    {0xB400,0xFE00,DI_PUSH,     0x00FF,0,0x0100,-8},    //PUSH
    {0xBC00,0xFE00,DI_POP,      0x00FF,0,0x0100,-8},    //POP

#define DI_DECSP    0x04
#define DI_INCSP    0x05
    {0xB080,0xFF80,DI_DECSP,    0x007F,2,0x0000,0},     //DecSP
    {0xB000,0xFF80,DI_INCSP,    0x007F,2,0x0000,0},     //IncSP

#define DI_MOVHI    0x08
#define DI_ADDHI    0x09
    {0x4600,0xFF00,DI_MOVHI,    0x0007,0,0x0078,-3},    //MovHiRegs
    {0x4400,0xFF00,DI_ADDHI,    0x0007,0,0x0078,-3},    //AddHiRegs

#define DI_BLPFX    0x10
#define DI_BL       0x11
    {0xF000,0xF800,DI_BLPFX,    0x07FF,12,0x0000,0},    //BL prefix
    {0xF800,0xF800,DI_BL,       0x07FF,1,0x0000,0},     //BL

#define DI_BX_TMB   0x20
    {0x4700,0xFF87,DI_BX_TMB,   0x0078,-3,0x0000,0},    //BX

#define DI_LDRPC    0x40
    {0x4800,0xF800,DI_LDRPC,    0x0700,-8,0x00FF,2},    //LDR pc

#define DI_NEG      0x80
    {0x4240,0xFFC0,DI_NEG,      0x0007,0,0x0038,-3},    //Neg Rx,Ry

    {0x0000,0x0000,0x00,        0x0000,0,0x0000,0}      //End of list
};

DIList dilistARM[] = {
#define DI_STMDB    0x102
#define DI_LDMIA    0x103
    {0xE92D0000,0xFFFF0000,DI_STMDB,    0x0000FFFF,0,0x00000000,0}, // STMDB
    {0xE8BD0000,0xFFFF0000,DI_LDMIA,    0x0000FFFF,0,0x00000000,0}, // LDMIA
#define DI_BX_ARM   0x120
    {0x012FFF10,0x0FFFFFF0,DI_BX_ARM,   0x0000000F,0,0x00000000,0}, // BX_ARM

    {0x00000000,0x00000000,0,           0x00000000,0,0x00000000,0}  // end of list
};




static int DecipherInstruction(DWORD inst, DcfInst *DI, int Mode)
{
    int i;
    DIList *dl = dilistThumb;

    assert(DI);
    if(!DI) return 0;
    memset(DI,0,sizeof(DcfInst));

    if(Mode==MODE_ARM) dl = dilistARM;

    for(i=0;dl[i].Mask!=0 && DI->InstNum==0; i++) {
        if((inst&dl[i].Mask)==dl[i].Val) {

            DI->InstNum = dl[i].InstNum;

            DI->Rd = (inst&dl[i].RdMask);
            if(DI->Rd && dl[i].RdShift) {
                if(dl[i].RdShift>0) DI->Rd <<= dl[i].RdShift;
                else if(dl[i].RdShift<0) DI->Rd >>= (-dl[i].RdShift);
            }

            DI->Rs = (inst&dl[i].RsMask);
            if(DI->Rs && dl[i].RsShift) {
                if(dl[i].RsShift>0) DI->Rs <<= dl[i].RsShift;
                else if(dl[i].RsShift<0) DI->Rs >>= (-dl[i].RsShift);
            }

            // Special case to handle MovHiRegs and AddHiRegs.
            if((DI->InstNum&~0x01)==8 ) {
                DI->Rd |= ((inst&0x0080)>>4);
            }
        }
    }

    if(Mode==MODE_ARM) return 4;
    return 2;       // Instructions are 2 bytes long.
}

#if 0 
static DWORD
ComputeCallAddress(DWORD RetAddr, int Mode)
{
    DWORD instr;
    DcfInst di;

    // If the caller is ARM mode, then the call address
    // is always 4 less than the return address.
    if(RetAddr&0x01) return RetAddr-4;


    if(!ReadMemory(&instr,RetAddr,2)) return RetAddr;

    DcfInst(instr,&di,Mode);
    if(di.InstNum==BL_TMB)
#endif

enum
{
    PushOp,     // Also used for Pop operations.
    AdjSpOp,
    MovOp
};  // Used for operation field below

typedef struct _OpEntry {
    struct _OpEntry *next;
    struct _OpEntry *prev;
    int Operation;

    int RegNumber;  // Used for Push/Pop
    int SpAdj;      // Used for AdjSpOp, and PushOp.

    int Rd;         // Used for MovOp
    int Rs;         // Used for MovOp

    ULONG Address;  // Instruction address that generated this OpEntry
} OpEntry;


typedef struct _OpList {
    OpEntry *head;
    OpEntry *tail;
} OpList;


static OpEntry*
MakeNewOpEntry
    (
    int Operation,
    OpEntry* prev,
    ULONG Address
    )
{
    ULONG size = sizeof(OpEntry);

    OpEntry *oe = (OpEntry*)MemAlloc(size);
    if(!oe) return NULL;

    memset(oe,0,sizeof(OpEntry));
    oe->prev = prev;
    oe->Operation = Operation;
    oe->Address = Address;

    return oe;
}

static void
FreeOpList(OpList* ol)
{
    OpEntry *oe;
    OpEntry *next;
    if(!ol)return;

    for(oe=ol->head;oe;oe=next){
        next = oe->next;
        memset(oe,0xCA,sizeof(OpEntry));
        MemFree(oe);
    }
    ol->head = ol->tail = NULL;
}


static void
BuildOnePushPopOp
    (
    OpList* pOL,
    int RegNum,
    ULONG Address
    )
{
    if(pOL->head == NULL) {
        OpEntry* Entry = MakeNewOpEntry(PushOp,NULL,Address);
        if (!Entry) {
            return;
        }
        pOL->head = pOL->tail = Entry;
    } else {
        OpEntry* Entry = MakeNewOpEntry(PushOp,pOL->tail,Address);
        if (!Entry) {
            return;
        }
        pOL->tail->next = Entry;
        pOL->tail = pOL->tail->next;
    }
    pOL->tail->RegNumber = RegNum;
    pOL->tail->SpAdj = REGISTER_SIZE;
}

// PushLR is only for use by Thumb PUSH op, and should be 0
// for ARM STMDB op.
static int
BuildPushOp
    (
    OpList* pOL,
    DWORD PushList,
    DWORD PushLR,
    ULONG Address
    )
{
    int RegNum;
    int cop = 0;

    if(PushList==0 && PushLR==0) return 0;

    DWORD RegMask = 0x8000;
    if(PushLR){ BuildOnePushPopOp(pOL,14,Address); cop++; }

    for(RegNum=15;RegNum>=0;RegNum--) {
        if(PushList&RegMask) { BuildOnePushPopOp(pOL,RegNum,Address); cop++; }
        RegMask = RegMask>>1;
    }
    return cop;
}

// PopPC is only for use by Thumb Pop op, and should be 0
// for ARM LDMIA op.
static int
BuildPopOp
    (
    OpList* pOL,
    DWORD PopList,
    DWORD PopPC,
    ULONG Address
    )
{
    int RegNum;
    int cop = 0;

    if(PopList==0 && PopPC==0) return 0;

    for(RegNum=0;PopList;RegNum++) {
        if(PopList&1) { BuildOnePushPopOp(pOL,RegNum,Address); cop++; }
        PopList = PopList>>1;
    }
    if(PopPC) { BuildOnePushPopOp(pOL,15,Address); cop++; }

    return cop;
}



static int
BuildAdjSpOp
    (
    OpList *pOL,
    int Val,
    ULONG Address
    )
{
    if(Val==0) return 0;

    if(pOL->head == NULL) {
        OpEntry* Entry = MakeNewOpEntry(AdjSpOp,NULL,Address);
        if (!Entry) {
            return 0;
        }
        pOL->head = pOL->tail = Entry;
    } else {
        // Don't try to compress this by combining adjacent AdjSpOp's.
        // Each actual instruction must yield at least one OpEntry
        // for use when we unwind the epilog.
        OpEntry* Entry = MakeNewOpEntry(AdjSpOp,pOL->tail,Address);
        if (!Entry) {
            return 0;
        }
        pOL->tail->next = Entry;
        pOL->tail = pOL->tail->next;
    }

    pOL->tail->SpAdj = Val;

    return 1;
}

static int
BuildMovOp(OpList *pOL, int Rd, int Rs, ULONG Address)
{
    if(pOL->head == NULL) {
        OpEntry* Entry = MakeNewOpEntry(MovOp,NULL,Address);
        if (!Entry) {
            return 0;
        }
        pOL->head = pOL->tail = Entry;
    } else {
        OpEntry* Entry = MakeNewOpEntry(MovOp,pOL->tail,Address);
        if (!Entry) {
            return 0;
        }
        pOL->tail->next = Entry;
        pOL->tail = pOL->tail->next;
    }
    pOL->tail->Rd = Rd;
    pOL->tail->Rs = Rs;

    return 1;
}


static BOOL
BuildOps
    (
    ULONG SectionStart,
    ULONG SectionLen,
    PULONG CxtRegs,
    int Mode,
    OpList *pOL,
    LONG* cOps
    )
{

    BOOL rc; ULONG cb;

    ULONG   Pc;
    ULONG   PcTemp;
    ULONG   InstAddr;
    DWORD   ThisInstruction;
    BOOL    Continue;

    ULONG   Ra;
    BOOL    InHelper = FALSE;

    DcfInst di;
    int len;
    long spadj;

    PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY HelperFE;
    ULONG HelperStart;
    ULONG HelperLen;
    ULONG HelperEnd;

    ULONG Register[16];

    ULONG DummyReg[16];
    BOOL DummyInit[16];

    ULONG SectionEnd = SectionStart + SectionLen;

    int i;

    OpEntry *pOE;

    pOL->head = pOL->tail = NULL;

    for(i=0;i<16;i++){
        Register[i] = CxtRegs[i];
        DummyInit[i]=FALSE; 
        DummyReg[i]=0xBADDC0DE;
    }

    *cOps = 0;

    Pc = SectionStart;
    Continue = TRUE;
    while(Continue || (InHelper && (Pc <= HelperEnd))) {
    
        InstAddr = Pc;
        ReadMemory(Pc,4,&ThisInstruction);

        len = DecipherInstruction(ThisInstruction,&di,Mode);
        Pc += len;
        if(((Pc >= SectionEnd) && !InHelper) ||
           (InHelper && (Pc > HelperEnd)))
        {
            Continue = FALSE;   // This will be our last pass.
        }

        switch(di.InstNum) {

            case DI_STMDB:
            case DI_PUSH:
                *cOps += BuildPushOp(pOL,di.Auxil,di.Aux2,InstAddr);
                break;

            case DI_LDMIA:
            case DI_POP:
                *cOps += BuildPopOp(pOL,di.Auxil,di.Aux2,InstAddr);
                break;

            case DI_DECSP:
            case DI_INCSP:
                *cOps += BuildAdjSpOp(pOL,di.Auxil,InstAddr);
                break;

            case DI_MOVHI:
                // The ops we care about are 
                // MOV Rx,SP / MOV SP,Rx    FramePointer saves
                // MOV Rx,LR                Used in epilog helpers
                if ((di.Rd != 15) && ((di.Rs == 13) || (di.Rd == 13) || (di.Rs == 14)))
                {
                    // epilogue helpers move LR to R3 and BX to R3 to return.
                    if (DummyInit[di.Rs])
                    {
                        DummyReg[di.Rd] = DummyReg[di.Rs];
                        DummyInit[di.Rd] = TRUE;
                    }
                    *cOps += BuildMovOp(pOL,di.Rd,di.Rs,InstAddr);
                }
                break;


            case DI_LDRPC:
                {
                    // the offset for the ldr instruction is always
                    // pc + 4 (InstAddr is pc here).
                    DWORD Addr = InstAddr+4+di.Aux2;
                    // Also need to ensure that the data is 4-byte aligned
                    // so mask off the last bits (we sometimes get 2-byte
                    // aligned offsets in retail builds of the OS).
                    Addr &= ~(0x3);
                    if(!LoadWordIntoRegister(Addr, &DummyReg[di.Rd])) return FALSE;
                    DummyInit[di.Rd] = TRUE;
                    break;
                }

            case DI_NEG:
                assert(DummyInit[di.Rs]);
                DummyReg[di.Rd] = (~DummyReg[di.Rs])+1;
                DummyInit[di.Rd] = DummyInit[di.Rs];
                break;

            case DI_ADDHI:
                assert(di.Rd==13);  // Used only to make big changes to SP.

                // Better have the source register initialized with an
                // immediate.
                if (!DummyInit[di.Rs])
                {
                    // we're probably walking the epilogue forward and the
                    // value we need is already in the real register
                    DummyReg[di.Rs] = Register[di.Rs];
                    DummyInit[di.Rs] = TRUE;
                }
                
                spadj = (long)(DummyReg[di.Rs]);

                if(spadj<0) spadj = -spadj;

                *cOps += BuildAdjSpOp(pOL,spadj,InstAddr);

                break;

            case DI_BLPFX:
                // Sign extend the Auxil:
                if(di.Auxil & 0x00400000) di.Auxil |= 0xFF800000;
                DummyReg[14] = Pc + 2 + (int)(di.Auxil);
                DummyInit[14] = TRUE;
                break;

            case DI_BL:
                {
                    // This can happen if there is an epilog/prolog helper
                    // function for this particular unwind.
                    // use some local value to verify that it is indeed an
                    // epilog/prolog helper before messing up the global
                    // data
                    DWORD TempPc = Pc;
                    DWORD TempRa;
                    DWORD DummyReg14 = DummyReg[14];
                    if(DummyInit[14]==FALSE)
                    {
                        // Didn't catch the first instruction of the two
                        // instruction BL.  That means that it's likely
                        // we're attempting to forward execute an epilog.
                        // The heuristic used to find the beginning
                        // of the epilog doesn't always do exactly the
                        // right thing, so the address indicated as the
                        // beginning of the epilog really isn't, and in
                        // this case ended up grabbing the last half of
                        // a BL pair.  To get around this, just NOP it.
                        // -- stevea 3/21/2000
                        break;
                    }

                    // Compute the return address.
                    TempRa = TempPc | 1; // Pc already points to next instruction.

                    // Sign extend the Auxil:
                    if(di.Auxil & 0x00001000) di.Auxil |= 0xFFFFE000;

                    // Generate the BL target
                    TempPc = DummyReg14 + (int)(di.Auxil);
                    DummyReg14 = TempRa;

                    // Examine the target of this branch:
                    HelperFE = (PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY)
                        UW_FunctionTableAccess(UW_hProcess, TempPc);
                    if (HelperFE)
                    {
                        // Make sure that this is a prologue/epilogue helper.
                        if (IS_HELPER_FUNCTION(HelperFE))
                        {
                            // just continue with the next instruction
                            break;
                        }

                        // Actually is a prologue/epilogue helper
                        Pc = TempPc;
                        Ra = TempRa;
                        DummyReg[14] = DummyReg14;

                        HelperStart = HelperFE->BeginAddress & ~0x01;
                        HelperEnd = HelperFE->EndAddress & ~0x01;
                        HelperLen = HelperEnd - HelperStart;

                        InHelper = TRUE;
                    }

                    break;
                }

            case DI_BX_ARM:
                // If we're unwinding, and we're working our way 
                // through a helper, then when we get to this 
                // instruction, we just slip neatly back to the main body:
                if(InHelper) {
                    assert((di.Rd==14) || (di.Rd==3));  // BX LR is the only way out of a prologue helper.
                                                        // BX r3 is the only way out of an epilogue helper.
                    assert(DummyInit[di.Rd]);

                    InHelper = FALSE;
                    
                    if(DummyInit[di.Rd] && (DummyReg[di.Rd] & 0x1)) {   // returning to thumb code...
                        Pc = DummyReg[di.Rd] & ~0x01;
                        Mode = MODE_THUMB;
                        assert(Pc>SectionStart && Pc<=SectionEnd);
                    } else {    // returning to ARM code?  This is wrong.
                        assert(FALSE);
                        return FALSE;
                    }
                } else {
                    // We've encountered this instruction, but not in a helper.
                    // We must have started out inside a helper, and somehow
                    // got this far.  OK, we're done unwinding.
                    Continue = FALSE;
                }
                break;

            case DI_BX_TMB:
                if(di.Auxil==15) {  // BX PC
                    Pc = (Pc+2)&~0x03;
                    Mode = MODE_ARM;    // Now, we're in ARM mode, because PC is always even.
                } else {
                    ULONG NewPc;
                    Mode = (Register[di.Auxil] &0x01)?MODE_THUMB:MODE_ARM;
                    if(Mode==MODE_THUMB)
                        NewPc = Register[di.Auxil] & ~0x01;
                    else
                        NewPc = Register[di.Auxil] & ~0x03;
                }
                break;


            default:
                break;
        }   // end of switch statement
    }   // end of while(Pc<EndAddress) loop.
    return TRUE;
}

#define NEED_MORE_EPILOG    -1
#define DOESNT_MATCH        0
#define DOES_MATCH          1
static BOOL PrologMatchesCandidateEpilog(OpList*,OpList*,int,ULONG*);


// TODO: This function currently treats a prologue/epilogue helper function as if it has
// TODO: its own stack frame when the PC is inside the helper.  This doesn't work very
// TODO: well because the frame below it has special knowledge of the helper as well,
// TODO: so we end up unwinding the helper anywhere (fractions included) between 0 and
// TODO: times.  It should really treat the helper as part of its calling frame and
// TODO: unwind everything exactly once.
static int
ThumbVirtualUnwind (
    DWORD                               ControlPc,
    PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY       FunctionEntry,
    PARM_CONTEXT                            Context,
    DWORD*                              ReturnAddress
    )

/*++

Routine Description:

    This function virtually unwinds the specfified function by executing its
    prologue code backwards (or its epilog forward).

    If the function is a leaf function, then the address where control left
    the previous frame is obtained from the context record. If the function
    is a nested function, but not an exception or interrupt frame, then the
    prologue code is executed backwards and the address where control left
    the previous frame is obtained from the updated context record.

    Otherwise, an exception or interrupt entry to the system is being unwound
    and a specially coded prologue restores the return address twice. Once
    from the fault instruction address and once from the saved return address
    register. The first restore is returned as the function value and the
    second restore is place in the updated context record.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    Context - Supplies the address of a context record.


Return Value:

    The address where control left the previous frame is returned as the
    function value.

--*/

{
    ULONG       Address;
    ULONG       FunctionStart;

    OpEntry*    pOE;
    BYTE*       Prolog;
    ULONG       PrologStart,PrologLen,PrologEnd;
    OpList      PrologOL = {NULL,NULL};
    LONG        PrologOpCount = 0;
    
    BYTE*       Epilog;
    ULONG       EpilogStart,EpilogLen,MaxEpilogLen,EpilogEnd;
    BOOL        FoundEpilogEnd = FALSE;

    int         ReturnRegisterIndex = 14;

    DWORD       EpilogPc;
    LONG        i,j,Sp;
    ARMI        instr, instr2;
    PULONG      Register = &Context->R0;
    LONG        StackSize = 0;
    ULONG       FramePointer = 0;

    ULONG       DummyReg[16];
    BOOL        DummyRegInit[16];

    BOOL rc; LONG cb;

    enum {
        StartingInProlog,
        StartingInFunctionBody,
        StartingInEpilog,
        StartingInPrologHelper,
        StartingInEpilogHelper,
        StartingInCallThunk,
        StartingInLongBranchThunk
    } StartingPlace = StartingInFunctionBody;   // default assumption.


    // Default:  return the value that will terminate unwind.
    *ReturnAddress = 0;

    if( !FunctionEntry ) return UNWIND_NOT_HANDLED;

    // If not a Thumb function, don't handle it here.
    if(!(FunctionEntry->BeginAddress&0x01)) return UNWIND_NOT_HANDLED;

    // Inside of a thumb function, so the PC will have the
    // 16-bit mode set.  Clear that out for our purposes here.
    ControlPc &= ~0x1;

    PrologStart = FunctionStart = FunctionEntry->BeginAddress & ~0x01;
    PrologEnd = FunctionEntry->PrologEndAddress & ~0x01;
    PrologLen = PrologEnd-PrologStart;

    // Look at Exception Info to see if we're in a helper.
    if(FunctionEntry->ExceptionHandler == EXCINFO_NULL_HANDLER) {
        switch ((int)FunctionEntry->HandlerData) {
            case EXCINFO_PROLOG_HELPER:
                StartingPlace = StartingInPrologHelper;
                break;
            case EXCINFO_EPILOG_HELPER:
                StartingPlace = StartingInEpilogHelper;
                break;
        }
    }


    switch(StartingPlace) {

        case StartingInFunctionBody:
            
            FoundEpilogEnd = FALSE;

            if(ControlPc==PrologStart) {
                // Haven't done anything yet, just copy LR to PC and return:
                goto ThumbUnwindExit;
            } 
            
            if(PrologStart==PrologEnd) {
                // No prolog.  Just copy LR to PC and return.
                goto ThumbUnwindExit;
            }

            if(ControlPc>PrologStart && ControlPc<=PrologEnd) {
                StartingPlace = StartingInProlog;
            }
            break;

        case StartingInPrologHelper:
            // If we're in a prolog helper, then the whole function is a prolog!
            PrologEnd = FunctionEntry->EndAddress & ~0x1;
            PrologLen = PrologEnd-PrologStart;
            break;

        case StartingInEpilogHelper:
            // If we're in an epilog helper, then the whole function is an epilog!
            FoundEpilogEnd = TRUE;
            EpilogStart = FunctionEntry->BeginAddress & ~0x01;
            EpilogEnd = FunctionEntry->EndAddress & ~0x01;
            EpilogLen = EpilogEnd-EpilogStart;
            break;
    }

    if((StartingPlace != StartingInProlog) && (StartingPlace != StartingInPrologHelper))
    {
        DWORD inst;
        DcfInst di;

        // First, let's see if we're in the epilog...
        // We'll know that we are, because the epilog is the only place where
        // we find a set of instructions that undoes the action of the prolog,
        // and then does a MOV PC,Rx, or BX Rx.

        // If we don't know where the end of the epilog is yet, find a candidate.
        if(FoundEpilogEnd==FALSE) {

            // The epilog can be a few instructions longer than the prolog.  That
            // limits our search distance:
            MaxEpilogLen = PrologLen+4;

            // Find a MOV PC,Rx or BX Rx within that distance, or we're not in the 
            // epilog.

            for(EpilogPc=ControlPc;EpilogPc<ControlPc+MaxEpilogLen&&FoundEpilogEnd==FALSE;) {

                if(!ReadMemory(EpilogPc,4,(LPVOID)&inst)) return UNWIND_HANDLED;
                
                EpilogPc += DecipherInstruction(inst,&di,MODE_THUMB);
                
                if(di.InstNum==DI_MOVHI && di.Rd==15){
                    FoundEpilogEnd = TRUE;
                    EpilogEnd = EpilogPc;
                    EpilogStart = EpilogPc-MaxEpilogLen;
                    ReturnRegisterIndex = di.Rs;
                } else if(di.InstNum==DI_BX_TMB){
                    FoundEpilogEnd = TRUE;
                    EpilogEnd = EpilogPc;
                    EpilogStart = EpilogPc-MaxEpilogLen;
                    ReturnRegisterIndex = di.Rd;
                }
            }   // end of loop through instructions
        }

        // Either we started in an Epilog Helper, or we found a candidate for the 
        // end of the Epilog.
        if(FoundEpilogEnd==TRUE) {

            LONG EpilogOpCount;
            OpList EpilogOL = {NULL,NULL};
            int Mode = MODE_THUMB;

            if (StartingPlace == StartingInEpilogHelper)
            {
                // we skipped the part above where we find the return address register, so
                // find it here.  The return for an epilogue helper is an ARM instruction.
                if(ReadMemory(EpilogEnd-4,4, (LPVOID)&inst) &&
                   (DecipherInstruction(inst, &di, MODE_ARM) == 4) &&
                   di.InstNum == DI_BX_ARM)
                {
                    // The epilogue doesn't always return via LR
                    ReturnRegisterIndex = di.Rd;
                }
                else
                {
                    // Unexpected helper; terminate the walk
                    Register[ReturnRegisterIndex] = 0x4;
                    goto ThumbUnwindExit;
                }

                // If we're inside the epilog helper we can imply that we're unwinding the top
                // frame where it is valid to use the T-bit to determine the mode from which
                // we should start to disassemble
                if (!(Context->Psr & 0x20))
                {
                    Mode = MODE_ARM;
                }
            }

            // If we are in the epilog, then we've found the end.  Let's build the ops for the 
            // epilog, so that we can compare it to the prolog.
            BuildOps(ControlPc,EpilogEnd-ControlPc,Register,Mode,&EpilogOL,&EpilogOpCount);

            // Extract total stack size from ops, and fill the stack cache.
            for(pOE=EpilogOL.tail;pOE;pOE=pOE->prev) {
                StackSize += pOE->SpAdj;
            }

            // Forward execute the rest of the epilog
            for(pOE=EpilogOL.head;pOE;pOE=pOE->next) {
                switch(pOE->Operation) {
                case MovOp:
                    Register[pOE->Rd] = Register[pOE->Rs];
                    break;
                case AdjSpOp:
                    Register[13] += pOE->SpAdj;
                    break;
                case PushOp:
                    LoadWordIntoRegister(Register[13],&Register[pOE->RegNumber]);
                    Register[13] += pOE->SpAdj;
                    break;
                }
            }

            FreeOpList(&EpilogOL);

            goto ThumbUnwindExit;
        }
    }
    
    // If we've started inside the function body, move the PC to the end of the prolog.
    if(ControlPc > PrologEnd) ControlPc = PrologEnd;

    // We're in the prolog.  Because of the use of prolog helpers,
    // we cannot merely execute backwards.  We need to step forward
    // through the prolog, accumulating information about what has been
    // done, and then undo that.
    BuildOps(PrologStart,ControlPc-PrologStart,Register,MODE_THUMB,&PrologOL,&PrologOpCount);

    // Extract total stack size from ops, and fill the stack cache.
    FramePointer = Register[13];
    for(pOE=PrologOL.head;pOE;pOE=pOE->next) {
        StackSize += pOE->SpAdj;
        if(pOE->Operation==MovOp && pOE->Rs==13)
            FramePointer = Register[pOE->Rd];
    }

    // At this point, we've got an exact description of the prolog's action.  
    // Let's undo it.
    for(pOE = PrologOL.tail; pOE; pOE=pOE->prev) {
        switch(pOE->Operation) {
            case MovOp:
                Register[pOE->Rs] = Register[pOE->Rd];
                break;
            case AdjSpOp:
                Register[13] += pOE->SpAdj;
                break;
            case PushOp:
                LoadWordIntoRegister(Register[13],&Register[pOE->RegNumber]);
                Register[13] += pOE->SpAdj;
                break;
        }
    }
    
    FreeOpList(&PrologOL);

ThumbUnwindExit:

    // Now, whatever's left in Register[14] is our return address:
    // To continue unwinding, put the Link Register into
    // the Program Counter slot and carry on; stopping
    // when the PC says 0x0.  However, the catch is that
    // for THUMB the Link Register at the bottom of the
    // stack says 0x4, not 0x0 as we expect.
    // So, do a little dance to take an LR of 0x4
    // and turn it into a PC of 0x0 to stop the unwind.
    // -- stevea 2/23/00.
    if( Register[ReturnRegisterIndex] != 0x4 )
        Register[15] = Register[ReturnRegisterIndex];
    else
        Register[15] = 0x0;

    *ReturnAddress = Register[15];
    return UNWIND_HANDLED;
}


static int
PrologMatchesCandidateEpilog
    (
    OpList* PrologOL,
    OpList* EpilogOL,
    int     ReturnRegister,
    PULONG  EpilogStart
    )
{
    int Matches = DOES_MATCH;
    OpEntry* pPOE=(OpEntry*)MemAlloc(sizeof(OpEntry));
    OpEntry* pEOE=(OpEntry*)MemAlloc(sizeof(OpEntry));

    // We aren't allowed to damage the OpLists we get, so copy
    // the entries like this.
    if(PrologOL->head) memcpy(pPOE,PrologOL->head,sizeof(OpEntry));
    else { MemFree(pPOE); pPOE = NULL; }

    if(EpilogOL->tail) memcpy(pEOE,EpilogOL->tail,sizeof(OpEntry));
    else { MemFree(pEOE); pEOE = NULL; }

    while(pPOE && Matches == TRUE) {
        if(pEOE==NULL) return NEED_MORE_EPILOG;

        // Keep track of the actual start of the epilog.
        *EpilogStart = pEOE->Address;

        switch(pPOE->Operation) {
            case PushOp:
                switch (pPOE->RegNumber) {
                    case 0:case 1:case 2:case 3:
                        // the epilog will just adjsp to pop these registers.
                        if(pEOE->Operation!=AdjSpOp)    Matches = DOESNT_MATCH;
                        if(pEOE->SpAdj<4)               Matches = DOESNT_MATCH;
                        pEOE->SpAdj-=4; pPOE->SpAdj-=4;
                        break;
                    case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:
                        // The epilog must pop these saved regs back into their original location.
                        if(pEOE->Operation!=PushOp)             Matches = DOESNT_MATCH;
                        if(pEOE->RegNumber!=pPOE->RegNumber)    Matches = DOESNT_MATCH;
                        pEOE->SpAdj-=4; pPOE->SpAdj-=4;
                        break;
                    case 14:
                        // The epilog must pop the saved LR into the register it will use to 
                        // return.  We found the index of this register when we searched for the
                        // end of the epilog...
                        if(pEOE->Operation!=PushOp)         Matches = DOESNT_MATCH;
                        if(pEOE->RegNumber!=ReturnRegister) Matches = DOESNT_MATCH;
                        pEOE->SpAdj-=4; pPOE->SpAdj-=4;
                        break;
                }
                break;
            case AdjSpOp:
                if(pEOE->Operation!=AdjSpOp)    Matches = DOESNT_MATCH;
                // The addspspi's and subspspi's could be mixed in with 
                // pop's and push's, so just do it this way.
                if(pEOE->SpAdj >= pPOE->SpAdj) {
                    pEOE->SpAdj -= pPOE->SpAdj;
                    pPOE->SpAdj = 0;
                } else {
                    pPOE->SpAdj -= pEOE->SpAdj;
                    pEOE->SpAdj = 0;
                }
                break;

            case MovOp:
                if(pEOE->Operation!=MovOp)  Matches = DOESNT_MATCH;
                if(pEOE->Rs != pPOE->Rd)    Matches = DOESNT_MATCH;
                if(pEOE->Rd != pPOE->Rs)    Matches = DOESNT_MATCH;
                break;
        }

        // If we're comparing a bunch of pushes to addspspi, then only
        // move on to the previous epilog instruction when we've pushed
        // enough registers to account for the addspspi.
        if(pEOE->SpAdj<=0) {
            if(pEOE->prev) memcpy(pEOE,pEOE->prev,sizeof(OpEntry));
            else {  MemFree(pEOE);  pEOE = NULL; }
        }
        if(pPOE->SpAdj<=0) {
            if(pPOE->next) memcpy(pPOE,pPOE->next,sizeof(OpEntry));
            else {  MemFree(pPOE);  pPOE = NULL; }
        }
    }

    if(!Matches) *EpilogStart = 0L;

    if(pEOE) MemFree(pEOE);
    if(pPOE) MemFree(pPOE);

    return Matches;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\walkamd64.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    walkamd64.c

Abstract:

    This file implements the AMD64 stack walking api.

Author:

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "symbols.h"
#include <stdlib.h>
#include <globals.h>

#define WDB(Args) SdbOut Args

//
// Lookup table providing the number of slots used by each unwind code.
// 

UCHAR RtlpUnwindOpSlotTableAmd64[] = {
    1,          // UWOP_PUSH_NONVOL
    2,          // UWOP_ALLOC_LARGE (or 3, special cased in lookup code)
    1,          // UWOP_ALLOC_SMALL
    1,          // UWOP_SET_FPREG
    2,          // UWOP_SAVE_NONVOL
    3,          // UWOP_SAVE_NONVOL_FAR
    2,          // UWOP_SAVE_XMM
    3,          // UWOP_SAVE_XMM_FAR
    2,          // UWOP_SAVE_XMM128
    3,          // UWOP_SAVE_XMM128_FAR
    1           // UWOP_PUSH_MACHFRAME
};

BOOL
WalkAmd64Init(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PAMD64_CONTEXT                    Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
WalkAmd64Next(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PAMD64_CONTEXT                    Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
UnwindStackFrameAmd64(
    HANDLE                            Process,
    PULONG64                          ReturnAddress,
    PULONG64                          StackPointer,
    PULONG64                          FramePointer,
    PAMD64_CONTEXT                    Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );


PAMD64_UNWIND_INFO
ReadUnwindInfoAmd64(ULONG64 ImageBase, ULONG Offset,
                    BOOL ReadCodes, HANDLE Process,
                    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
                    PVOID StaticBuffer, ULONG StaticBufferSize)
{
    ULONG Done;
    ULONG UnwindInfoSize;
    PAMD64_UNWIND_INFO UnwindInfo;
    PVOID SymInfo = NULL;
    ULONG SymInfoSize;
    ULONG64 MemOffset = ImageBase + Offset;

    // Static buffer should at least be large enough to read the
    // basic structure.
    if (StaticBufferSize < sizeof(*UnwindInfo)) {
        return NULL;
    }
    UnwindInfo = (PAMD64_UNWIND_INFO)StaticBuffer;

    // First read just the basic structure since the information
    // is needed to compute the complete size.
    if (!ReadMemory(Process, MemOffset,
                    UnwindInfo, sizeof(*UnwindInfo), &Done) ||
        Done != sizeof(*UnwindInfo)) {
        WDB((1, "Unable to read unwind info at %I64X\n", MemOffset));

        SymInfo = GetUnwindInfoFromSymbols(Process, ImageBase, Offset,
                                           &SymInfoSize);
        if (!SymInfo || SymInfoSize < sizeof(*UnwindInfo)) {
            WDB((1, "Unable to get symbol unwind info at %I64X:%X\n",
                 ImageBase, Offset));
            return NULL;
        }

        memcpy(UnwindInfo, SymInfo, sizeof(*UnwindInfo));
    }

    if (!ReadCodes) {
        return UnwindInfo;
    }

    // Compute the size of all the data.
    UnwindInfoSize = sizeof(*UnwindInfo) +
        (UnwindInfo->CountOfCodes - 1) * sizeof(AMD64_UNWIND_CODE);
    // An extra alignment code and pointer may be added on to handle
    // the chained info case where the chain pointer is just
    // beyond the end of the normal code array.
    if ((UnwindInfo->Flags & AMD64_UNW_FLAG_CHAININFO) != 0) {
        if ((UnwindInfo->CountOfCodes & 1) != 0) {
            UnwindInfoSize += sizeof(AMD64_UNWIND_CODE);
        }
        UnwindInfoSize += sizeof(ULONG64);
    }
    
    if (UnwindInfoSize > 0xffff) {
        // Too large to be valid data, assume it's garbage.
        WDB((1, "Invalid unwind info at %I64X\n", MemOffset));
        return NULL;
    }
    
    if (SymInfo && UnwindInfoSize > SymInfoSize) {
        WDB((1, "Insufficient unwind info in symbols for %I64X:%X\n",
             ImageBase, Offset));
        return NULL;
    }
    
    if (UnwindInfoSize > StaticBufferSize) {
        UnwindInfo = (PAMD64_UNWIND_INFO)MemAlloc(UnwindInfoSize);
        if (UnwindInfo == NULL) {
            WDB((1, "Unable to allocate memory for unwind info\n"));
            return NULL;
        }
    }

    // Now read all the data.
    if (SymInfo) {
        memcpy(UnwindInfo, SymInfo, UnwindInfoSize);
    } else if (!ReadMemory(Process, MemOffset, UnwindInfo, UnwindInfoSize,
                           &Done) ||
               Done != UnwindInfoSize) {
        if ((PVOID)UnwindInfo != StaticBuffer) {
            MemFree(UnwindInfo);
        }

        WDB((1, "Unable to read unwind info at %I64X\n", MemOffset));
        return NULL;
    }

    return UnwindInfo;
}

//
// ****** temp - defin elsewhere ******
//

#define SIZE64_PREFIX 0x48
#define ADD_IMM8_OP 0x83
#define ADD_IMM32_OP 0x81
#define JMP_IMM8_OP 0xeb
#define JMP_IMM32_OP 0xe9
#define LEA_OP 0x8d
#define POP_OP 0x58
#define RET_OP 0xc3

BOOLEAN
RtlpUnwindPrologueAmd64 (
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc,
    IN ULONG64 FrameBase,
    IN _PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    IN OUT PAMD64_CONTEXT ContextRecord,
    IN HANDLE Process,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    )

/*++

Routine Description:

    This function processes unwind codes and reverses the state change
    effects of a prologue. If the specified unwind information contains
    chained unwind information, then that prologue is unwound recursively.
    As the prologue is unwound state changes are recorded in the specified
    context structure and optionally in the specified context pointers
    structures.

Arguments:

    ImageBase - Supplies the base address of the image that contains the
        function being unwound.

    ControlPc - Supplies the address where control left the specified
        function.

    FrameBase - Supplies the base of the stack frame subject function stack
         frame.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

--*/

{

    ULONG64 FloatingAddress;
    PAMD64_M128 FloatingRegister;
    ULONG FrameOffset;
    ULONG Index;
    ULONG64 IntegerAddress;
    PULONG64 IntegerRegister;
    BOOLEAN MachineFrame;
    ULONG OpInfo;
    ULONG PrologOffset;
    PULONG64 RegisterAddress;
    ULONG64 ReturnAddress;
    ULONG64 StackAddress;
    PAMD64_UNWIND_CODE UnwindCode;
    ULONG64 UnwindInfoBuffer[32];
    PAMD64_UNWIND_INFO UnwindInfo;
    ULONG Done;
    ULONG UnwindOp;

    //
    // Process the unwind codes.
    //

    FloatingRegister = &ContextRecord->Xmm0;
    IntegerRegister = &ContextRecord->Rax;
    Index = 0;
    MachineFrame = FALSE;
    PrologOffset = (ULONG)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));

    WDB((1, "Prol: RIP %I64X, 0x%X bytes in function at %I64X\n",
         ControlPc, PrologOffset, FunctionEntry->BeginAddress + ImageBase));
    WDB((1, "Prol: Read unwind info at %I64X\n",
         FunctionEntry->UnwindInfoAddress + ImageBase));

    UnwindInfo =
        ReadUnwindInfoAmd64(ImageBase, FunctionEntry->UnwindInfoAddress,
                            TRUE, Process, ReadMemory, UnwindInfoBuffer,
                            sizeof(UnwindInfoBuffer));
    if (UnwindInfo == NULL) {
        WDB((1, "Prol: Unable to read unwind info\n"));
        return FALSE;
    }

    WDB((1, "  Unwind info has 0x%X codes\n", UnwindInfo->CountOfCodes));
    
    while (Index < UnwindInfo->CountOfCodes) {

        WDB((1, "  %02X: Code %X offs %03X, RSP %I64X\n",
             Index, UnwindInfo->UnwindCode[Index].UnwindOp,
             UnwindInfo->UnwindCode[Index].CodeOffset,
             ContextRecord->Rsp));
        
        //
        // If the prologue offset is greater than the next unwind code offset,
        // then simulate the effect of the unwind code.
        //

        UnwindOp = UnwindInfo->UnwindCode[Index].UnwindOp;
        OpInfo = UnwindInfo->UnwindCode[Index].OpInfo;
        if (PrologOffset >= UnwindInfo->UnwindCode[Index].CodeOffset) {
            switch (UnwindOp) {

                //
                // Push nonvolatile integer register.
                //
                // The operation information is the register number of the
                // register than was pushed.
                //

            case AMD64_UWOP_PUSH_NONVOL:
                IntegerAddress = ContextRecord->Rsp;
                if (!ReadMemory(Process, IntegerAddress,
                                &IntegerRegister[OpInfo], sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }

                ContextRecord->Rsp += 8;
                break;

                //
                // Allocate a large sized area on the stack.
                //
                // The operation information determines if the size is
                // 16- or 32-bits.
                //

            case AMD64_UWOP_ALLOC_LARGE:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset;
                if (OpInfo != 0) {
                    Index += 1;
                    FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                } else {
                    // The 16-bit form is scaled.
                    FrameOffset *= 8;
                }

                ContextRecord->Rsp += FrameOffset;
                break;

                //
                // Allocate a small sized area on the stack.
                //
                // The operation information is the size of the unscaled
                // allocation size (8 is the scale factor) minus 8.
                //

            case AMD64_UWOP_ALLOC_SMALL:
                ContextRecord->Rsp += (OpInfo * 8) + 8;
                break;

                //
                // Establish the the frame pointer register.
                //
                // The operation information is not used.
                //

            case AMD64_UWOP_SET_FPREG:
                ContextRecord->Rsp = IntegerRegister[UnwindInfo->FrameRegister];
                ContextRecord->Rsp -= UnwindInfo->FrameOffset * 16;
                break;

                //
                // Save nonvolatile integer register on the stack using a
                // 16-bit displacment.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_NONVOL:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 8;
                IntegerAddress = FrameBase + FrameOffset;
                if (!ReadMemory(Process, IntegerAddress,
                                &IntegerRegister[OpInfo], sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                break;

                //
                // Save nonvolatile integer register on the stack using a
                // 32-bit displacment.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_NONVOL_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                IntegerAddress = FrameBase + FrameOffset;
                if (!ReadMemory(Process, IntegerAddress,
                                &IntegerRegister[OpInfo], sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                break;

                //
                // Save a nonvolatile XMM(64) register on the stack using a
                // 16-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 8;
                FloatingAddress = FrameBase + FrameOffset;
                FloatingRegister[OpInfo].High = 0;
                if (!ReadMemory(Process, FloatingAddress,
                                &FloatingRegister[OpInfo].Low, sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                break;

                //
                // Save a nonvolatile XMM(64) register on the stack using a
                // 32-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                FloatingAddress = FrameBase + FrameOffset;
                FloatingRegister[OpInfo].High = 0;
                if (!ReadMemory(Process, FloatingAddress,
                                &FloatingRegister[OpInfo].Low, sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                break;

                //
                // Save a nonvolatile XMM(128) register on the stack using a
                // 16-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM128:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 16;
                FloatingAddress = FrameBase + FrameOffset;
                if (!ReadMemory(Process, FloatingAddress,
                                &FloatingRegister[OpInfo], sizeof(AMD64_M128),
                                &Done) ||
                    Done != sizeof(AMD64_M128)) {
                    goto Fail;
                }
                break;

                //
                // Save a nonvolatile XMM(128) register on the stack using a
                // 32-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM128_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                FloatingAddress = FrameBase + FrameOffset;
                if (!ReadMemory(Process, FloatingAddress,
                                &FloatingRegister[OpInfo], sizeof(AMD64_M128),
                                &Done) ||
                    Done != sizeof(AMD64_M128)) {
                    goto Fail;
                }
                break;

                //
                // Push a machine frame on the stack.
                //
                // The operation information determines whether the machine
                // frame contains an error code or not.
                //

            case AMD64_UWOP_PUSH_MACHFRAME:
                MachineFrame = TRUE;
                ReturnAddress = ContextRecord->Rsp;
                StackAddress = ContextRecord->Rsp + (3 * 8);
                if (OpInfo != 0) {
                    ReturnAddress += 8;
                    StackAddress +=  8;
                }

                if (!ReadMemory(Process, ReturnAddress,
                                &ContextRecord->Rip, sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                if (!ReadMemory(Process, StackAddress,
                                &ContextRecord->Rsp, sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                break;

                //
                // Unused codes.
                //

            default:
                break;
            }

            Index += 1;
        
        } else {

            //
            // Skip this unwind operation by advancing the slot index by the
            // number of slots consumed by this operation.
            //

            Index += RtlpUnwindOpSlotTableAmd64[UnwindOp];

            //
            // Special case any unwind operations that can consume a variable
            // number of slots.
            // 

            switch (UnwindOp) {

                //
                // A non-zero operation information indicates that an
                // additional slot is consumed.
                //

            case AMD64_UWOP_ALLOC_LARGE:
                if (OpInfo != 0) {
                    Index += 1;
                }

                break;

                //
                // No other special cases.
                //

            default:
                break;
            }
        }
    }

    //
    // If chained unwind information is specified, then recursively unwind
    // the chained information. Otherwise, determine the return address if
    // a machine frame was not encountered during the scan of the unwind
    // codes.
    //

    if ((UnwindInfo->Flags & AMD64_UNW_FLAG_CHAININFO) != 0) {
        Index = UnwindInfo->CountOfCodes;
        if ((Index & 1) != 0) {
            Index += 1;
        }

        ULONG64 ChainEntryAddr =
            *(PULONG64)(&UnwindInfo->UnwindCode[Index]) + ImageBase;

        if (UnwindInfo != (PAMD64_UNWIND_INFO)UnwindInfoBuffer) {
            MemFree(UnwindInfo);
        }

        _IMAGE_RUNTIME_FUNCTION_ENTRY ChainEntry;

        WDB((1, "  Chain to entry at %I64X\n", ChainEntryAddr));
        
        if (!ReadMemory(Process, ChainEntryAddr,
                        &ChainEntry, sizeof(ChainEntry), &Done) ||
            Done != sizeof(ChainEntry)) {
            WDB((1, "  Unable to read entry\n"));
            return FALSE;
        }

        return RtlpUnwindPrologueAmd64(ImageBase,
                                       ControlPc,
                                       FrameBase,
                                       &ChainEntry,
                                       ContextRecord,
                                       Process,
                                       ReadMemory);

    } else {
        if (UnwindInfo != (PAMD64_UNWIND_INFO)UnwindInfoBuffer) {
            MemFree(UnwindInfo);
        }

        if (MachineFrame == FALSE) {
            if (!ReadMemory(Process, ContextRecord->Rsp,
                            &ContextRecord->Rip, sizeof(ULONG64),
                            &Done) ||
                Done != sizeof(ULONG64)) {
                return FALSE;
            }
            ContextRecord->Rsp += 8;
        }

        WDB((1, "Prol: Returning with RIP %I64X, RSP %I64X\n",
             ContextRecord->Rip, ContextRecord->Rsp));
        return TRUE;
    }

 Fail:
    if (UnwindInfo != (PAMD64_UNWIND_INFO)UnwindInfoBuffer) {
        MemFree(UnwindInfo);
    }
    WDB((1, "Prol: Unwind failed\n"));
    return FALSE;
}

BOOLEAN
RtlVirtualUnwindAmd64 (
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc,
    IN _PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    IN OUT PAMD64_CONTEXT ContextRecord,
    OUT PULONG64 EstablisherFrame,
    IN HANDLE Process,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    )

/*++

Routine Description:

    This function virtually unwinds the specified function by executing its
    prologue code backward or its epilogue code forward.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    ImageBase - Supplies the base address of the image that contains the
        function being unwound.

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    EstablisherFrame - Supplies a pointer to a variable that receives the
        the establisher frame pointer value.

--*/

{

    ULONG64 BranchTarget;
    LONG Displacement;
    ULONG FrameRegister;
    ULONG Index;
    LOGICAL InEpilogue;
    PULONG64 IntegerRegister;
    PUCHAR NextByte;
    ULONG PrologOffset;
    ULONG RegisterNumber;
    PAMD64_UNWIND_INFO UnwindInfo;
    ULONG64 UnwindInfoBuffer[8];
    ULONG Done;
    UCHAR InstrBuffer[32];
    ULONG InstrBytes;
    ULONG Bytes;
    ULONG UnwindFrameReg;

    //
    // If the specified function does not use a frame pointer, then the
    // establisher frame is the contents of the stack pointer. This may
    // not actually be the real establisher frame if control left the
    // function from within the prologue. In this case the establisher
    // frame may be not required since control has not actually entered
    // the function and prologue entries cannot refer to the establisher
    // frame before it has been established, i.e., if it has not been
    // established, then no save unwind codes should be encountered during
    // the unwind operation.
    //
    // If the specified function uses a frame pointer and control left the
    // function outside of the prologue or the unwind information contains
    // a chained information structure, then the establisher frame is the
    // contents of the frame pointer.
    //
    // If the specified function uses a frame pointer and control left the
    // function from within the prologue, then the set frame pointer unwind
    // code must be looked up in the unwind codes to detetermine if the
    // contents of the stack pointer or the contents of the frame pointer
    // should be used for the establisher frame. This may not atually be
    // the real establisher frame. In this case the establisher frame may
    // not be required since control has not actually entered the function
    // and prologue entries cannot refer to the establisher frame before it
    // has been established, i.e., if it has not been established, then no
    // save unwind codes should be encountered during the unwind operation.
    //
    // N.B. The correctness of these assumptions is based on the ordering of
    //      unwind codes.
    //

    UnwindInfo =
        ReadUnwindInfoAmd64(ImageBase, FunctionEntry->UnwindInfoAddress,
                            FALSE, Process, ReadMemory, UnwindInfoBuffer,
                            sizeof(UnwindInfoBuffer));
    if (UnwindInfo == NULL) {
        return FALSE;
    }

    PrologOffset = (ULONG)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));
    UnwindFrameReg = UnwindInfo->FrameRegister;
    if (UnwindFrameReg == 0) {
        *EstablisherFrame = ContextRecord->Rsp;

    } else if ((PrologOffset >= UnwindInfo->SizeOfProlog) ||
               ((UnwindInfo->Flags & AMD64_UNW_FLAG_CHAININFO) != 0)) {
        *EstablisherFrame = (&ContextRecord->Rax)[UnwindFrameReg];
        *EstablisherFrame -= UnwindInfo->FrameOffset * 16;

    } else {

        // Read all the data.
        UnwindInfo = ReadUnwindInfoAmd64(ImageBase,
                                         FunctionEntry->UnwindInfoAddress,
                                         TRUE, Process, ReadMemory,
                                         UnwindInfoBuffer,
                                         sizeof(UnwindInfoBuffer));
        if (UnwindInfo == NULL) {
            return FALSE;
        }

        Index = 0;
        while (Index < UnwindInfo->CountOfCodes) {
            if (UnwindInfo->UnwindCode[Index].UnwindOp == AMD64_UWOP_SET_FPREG) {
                break;
            }

            Index += 1;
        }

        if (PrologOffset >= UnwindInfo->UnwindCode[Index].CodeOffset) {
            *EstablisherFrame = (&ContextRecord->Rax)[UnwindFrameReg];
            *EstablisherFrame -= UnwindInfo->FrameOffset * 16;

        } else {
            *EstablisherFrame = ContextRecord->Rsp;
        }

        if (UnwindInfo != (PAMD64_UNWIND_INFO)UnwindInfoBuffer) {
            MemFree(UnwindInfo);
        }
    }

    if (!ReadMemory(Process, ControlPc, InstrBuffer, sizeof(InstrBuffer),
                    &InstrBytes)) {
        WDB((1, "Unable to read instruction stream at %I64X\n", ControlPc));
        return FALSE;
    }

    //
    // Check for epilogue.
    //
    // If the point at which control left the specified function is in an
    // epilogue, then emulate the execution of the epilogue forward and
    // return no exception handler.
    //

    IntegerRegister = &ContextRecord->Rax;
    NextByte = InstrBuffer;
    Bytes = InstrBytes;

    //
    // Check for one of:
    //
    //   add rsp, imm8
    //       or
    //   add rsp, imm32
    //       or
    //   lea rsp, -disp8[fp]
    //       or
    //   lea rsp, -disp32[fp]
    //

    if (Bytes >= 4 &&
        (NextByte[0] == SIZE64_PREFIX) &&
        (NextByte[1] == ADD_IMM8_OP) &&
        (NextByte[2] == 0xc4)) {

        //
        // add rsp, imm8.
        //

        NextByte += 4;
        Bytes -= 4;

    } else if (Bytes >= 7 &&
               (NextByte[0] == SIZE64_PREFIX) &&
               (NextByte[1] == ADD_IMM32_OP) &&
               (NextByte[2] == 0xc4)) {

        //
        // add rsp, imm32.
        //

        NextByte += 7;
        Bytes -= 7;

    } else if (Bytes >= 4 &&
               ((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
               (NextByte[1] == LEA_OP)) {

        FrameRegister = ((NextByte[0] & 0x7) << 3) | (NextByte[2] & 0x7);
        if ((FrameRegister != 0) &&
            (FrameRegister == UnwindFrameReg)) {
            if ((NextByte[2] & 0xf8) == 0x60) {

                //
                // lea rsp, disp8[fp].
                //

                NextByte += 4;
                Bytes -= 4;

            } else if (Bytes >= 7 &&
                       (NextByte[2] &0xf8) == 0xa0) {

                //
                // lea rsp, disp32[fp].
                //

                NextByte += 7;
                Bytes -= 7;
            }
        }
    }

    //
    // Check for any number of:
    //
    //   pop nonvolatile-integer-register[0..15].
    //

    while (TRUE) {
        if (Bytes >= 1 &&
            (NextByte[0] & 0xf8) == POP_OP) {
            NextByte += 1;
            Bytes -= 1;

        } else if (Bytes >= 2 &&
                   ((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
                   ((NextByte[1] & 0xf8) == POP_OP)) {

            NextByte += 2;
            Bytes -= 2;

        } else {
            break;
        }
    }

    //
    // If the next instruction is a return, then control is currently in
    // an epilogue and execution of the epilogue should be emulated.
    // Otherwise, execution is not in an epilogue and the prologue should
    // be unwound.
    //

    InEpilogue = FALSE;
    if (Bytes >= 1 &&
        NextByte[0] == RET_OP) {
        
        //
        // A return is an unambiguous indication of an epilogue
        //

        InEpilogue = TRUE;

    } else if ((Bytes >= 2 && NextByte[0] == JMP_IMM8_OP) ||
               (Bytes >= 5 && NextByte[0] == JMP_IMM32_OP)) {

        //
        // An unconditional branch to a target that is equal to the start of
        // or outside of this routine is logically a call to another function.
        // 

        BranchTarget = (ULONG64)(NextByte - InstrBuffer) + ControlPc - ImageBase;
        if (NextByte[0] == JMP_IMM8_OP) {
            BranchTarget += 2 + (CHAR)NextByte[1];
        } else {
            BranchTarget += 5 + *((LONG UNALIGNED *)&NextByte[1]);
        }

        //
        // Now determine whether the branch target refers to code within this
        // function.  If not then it is an epilogue indicator.
        //

        if (BranchTarget <= FunctionEntry->BeginAddress ||
            BranchTarget > FunctionEntry->EndAddress) {

            InEpilogue = TRUE;
        }
    }

    if (InEpilogue != FALSE) {
        NextByte = InstrBuffer;
        Bytes = InstrBytes;

        //
        // Emulate one of (if any):
        //
        //   add rsp, imm8
        //       or
        //   add rsp, imm32
        //       or
        //   lea rsp, disp8[frame-register]
        //       or
        //   lea rsp, disp32[frame-register]
        //

        if (Bytes >= 4 &&
            NextByte[1] == ADD_IMM8_OP) {

            //
            // add rsp, imm8.
            //

            ContextRecord->Rsp += (CHAR)NextByte[3];
            NextByte += 4;
            Bytes -= 4;

        } else if (Bytes >= 7 &&
                   NextByte[1] == ADD_IMM32_OP) {

            //
            // add rsp, imm32.
            //

            Displacement = NextByte[3] | (NextByte[4] << 8);
            Displacement |= (NextByte[5] << 16) | (NextByte[6] << 24);
            ContextRecord->Rsp += Displacement;
            NextByte += 7;
            Bytes -= 7;

        } else if (Bytes >= 4 &&
                   NextByte[1] == LEA_OP) {
            if ((NextByte[2] & 0xf8) == 0x60) {

                //
                // lea rsp, disp8[frame-register].
                //

                ContextRecord->Rsp = IntegerRegister[FrameRegister];
                ContextRecord->Rsp += (CHAR)NextByte[3];
                NextByte += 4;
                Bytes -= 4;

            } else if (Bytes >= 7 &&
                       (NextByte[2] & 0xf8) == 0xa0) {

                //
                // lea rsp, disp32[frame-register].
                //

                Displacement = NextByte[3] | (NextByte[4] << 8);
                Displacement |= (NextByte[5] << 16) | (NextByte[6] << 24);
                ContextRecord->Rsp = IntegerRegister[FrameRegister];
                ContextRecord->Rsp += Displacement;
                NextByte += 7;
                Bytes -= 7;
            }
        }

        //
        // Emulate any number of (if any):
        //
        //   pop nonvolatile-integer-register.
        //

        while (TRUE) {
            if (Bytes >= 1 &&
                (NextByte[0] & 0xf8) == POP_OP) {

                //
                // pop nonvolatile-integer-register[0..7]
                //

                RegisterNumber = NextByte[0] & 0x7;
                if (!ReadMemory(Process, ContextRecord->Rsp,
                                &IntegerRegister[RegisterNumber],
                                sizeof(ULONG64), &Done) ||
                    Done != sizeof(ULONG64)) {
                    WDB((1, "Unable to read stack at %I64X\n",
                         ContextRecord->Rsp));
                    return FALSE;
                }
                ContextRecord->Rsp += 8;
                NextByte += 1;
                Bytes -= 1;

            } else if (Bytes >= 2 &&
                       (NextByte[0] & 0xf8) == SIZE64_PREFIX &&
                       (NextByte[1] & 0xf8) == POP_OP) {

                //
                // pop nonvolatile-integer-register[8..15]
                //

                RegisterNumber = ((NextByte[0] & 1) << 3) | (NextByte[1] & 0x7);
                if (!ReadMemory(Process, ContextRecord->Rsp,
                                &IntegerRegister[RegisterNumber],
                                sizeof(ULONG64), &Done) ||
                    Done != sizeof(ULONG64)) {
                    WDB((1, "Unable to read stack at %I64X\n",
                         ContextRecord->Rsp));
                    return FALSE;
                }
                ContextRecord->Rsp += 8;
                NextByte += 2;
                Bytes -= 2;

            } else {
                break;
            }
        }

        //
        // Emulate return and return null exception handler.
        //
        // Note: this instruction might in fact be a jmp, however
        //       we want to emulate a return regardless.
        //

        if (!ReadMemory(Process, ContextRecord->Rsp,
                        &ContextRecord->Rip, sizeof(ULONG64),
                        &Done) ||
            Done != sizeof(ULONG64)) {
            WDB((1, "Unable to read stack at %I64X\n",
                 ContextRecord->Rsp));
            return FALSE;
        }
        ContextRecord->Rsp += 8;
        return TRUE;
    }

    //
    // Control left the specified function outside an epilogue. Unwind the
    // subject function and any chained unwind information.
    //

    return RtlpUnwindPrologueAmd64(ImageBase,
                                   ControlPc,
                                   *EstablisherFrame,
                                   FunctionEntry,
                                   ContextRecord,
                                   Process,
                                   ReadMemory);
}



BOOL
WalkAmd64(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    BOOL rval;
    PAMD64_CONTEXT Context = (PAMD64_CONTEXT)ContextRecord;

    WDB((2, "WalkAmd64  in: PC %I64X, SP %I64X, FP %I64X, RA %I64X\n",
         StackFrame->AddrPC.Offset,
         StackFrame->AddrStack.Offset,
         StackFrame->AddrFrame.Offset,
         StackFrame->AddrReturn.Offset));

    if (StackFrame->Virtual) {

        rval = WalkAmd64Next( Process,
                              StackFrame,
                              Context,
                              ReadMemory,
                              FunctionTableAccess,
                              GetModuleBase
                              );

    } else {

        rval = WalkAmd64Init( Process,
                              StackFrame,
                              Context,
                              ReadMemory,
                              FunctionTableAccess,
                              GetModuleBase
                              );

    }

    WDB((2, "WalkAmd64 out: succ %d, PC %I64X, SP %I64X, FP %I64X, RA %I64X\n",
         rval,
         StackFrame->AddrPC.Offset,
         StackFrame->AddrStack.Offset,
         StackFrame->AddrFrame.Offset,
         StackFrame->AddrReturn.Offset));

    return rval;
}

BOOL
UnwindStackFrameAmd64(
    IN     HANDLE                            Process,
    IN OUT PULONG64                          ReturnAddress,
    IN OUT PULONG64                          StackPointer,
    IN OUT PULONG64                          FramePointer,
    IN     PAMD64_CONTEXT                    Context,        // Context members could be modified.
    IN     PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    IN     PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    IN     PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    _PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry;
    ULONG64 RetAddr;
    BOOL Succ = TRUE;

    FunctionEntry = (_PIMAGE_RUNTIME_FUNCTION_ENTRY)
        FunctionTableAccess( Process, *ReturnAddress );
    if (FunctionEntry != NULL) {

        ULONG64 ImageBase;
        // Initialized to quiet a PREfix warning.
        ULONG64 EstablisherFrame = 0;

        //
        // The return value coming out of mainCRTStartup is set by some
        // run-time routine to be 0; this serves to cause an error if someone
        // actually does a return from the mainCRTStartup frame.
        //

        ImageBase = GetModuleBase(Process, *ReturnAddress);
        if (!RtlVirtualUnwindAmd64(ImageBase, *ReturnAddress, FunctionEntry,
                                   Context, &EstablisherFrame,
                                   Process, ReadMemory) ||
            Context->Rip == 0 ||
            (Context->Rip == *ReturnAddress &&
             EstablisherFrame == *FramePointer)) {
            Succ = FALSE;
        }

        *ReturnAddress = Context->Rip;
        *StackPointer = Context->Rsp;
        // The frame pointer is an artificial value set
        // to a pointer below the return address.  This
        // matches an RBP-chain style of frame while
        // also allowing easy access to the return
        // address and homed arguments above it.
        *FramePointer = Context->Rsp - 2 * sizeof(ULONG64);

    } else {

        ULONG Done;
        
        // If there's no function entry for a function
        // we assume that it's a leaf and that ESP points
        // directly to the return address.  There's no
        // stored frame pointer so we actually need to
        // set a virtual frame pointer deeper in the stack
        // so that arguments can correctly be read at
        // two ULONG64's up from it.
        *FramePointer = Context->Rsp - 8;
        *StackPointer = Context->Rsp + 8;
        Succ = ReadMemory(Process, Context->Rsp,
                          ReturnAddress, sizeof(*ReturnAddress), &Done) &&
            Done == sizeof(*ReturnAddress);

        // Update the context values to what they should be in
        // the caller.
        if (Succ) {
            Context->Rsp += 8;
            Context->Rip = *ReturnAddress;
        }
    }

    if (Succ) {
        ULONG64 CallOffset;
        _PIMAGE_RUNTIME_FUNCTION_ENTRY CallFunc;

        //
        // Calls of __declspec(noreturn) functions may not have any
        // code after them to return to since the compiler knows
        // that the function will not return.  This can confuse
        // stack traces because the return address will lie outside
        // of the function's address range and FPO data will not
        // be looked up correctly.  Check and see if the return
        // address falls outside of the calling function and, if so,
        // adjust the return address back by one byte.  It'd be
        // better to adjust it back to the call itself so that
        // the return address points to valid code but
        // backing up in X86 assembly is more or less impossible.
        //

        CallOffset = *ReturnAddress - 1;
        CallFunc = (_PIMAGE_RUNTIME_FUNCTION_ENTRY)
            FunctionTableAccess(Process, CallOffset);
        if (CallFunc != NULL) {
            _IMAGE_RUNTIME_FUNCTION_ENTRY SaveCallFunc = *CallFunc;
            _PIMAGE_RUNTIME_FUNCTION_ENTRY RetFunc =
                (_PIMAGE_RUNTIME_FUNCTION_ENTRY)
                FunctionTableAccess(Process, *ReturnAddress);
            if (RetFunc == NULL ||
                memcmp(&SaveCallFunc, RetFunc, sizeof(SaveCallFunc))) {
                *ReturnAddress = CallOffset;
            }
        }
    }

    return Succ;
}

BOOL
ReadFrameArgsAmd64(
    LPADDRESS64 FrameOffset,
    HANDLE Process,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    PULONG64 Args
    )
{
    ULONG Done;

    if (!ReadMemory(Process, FrameOffset->Offset + 2 * sizeof(ULONG64),
                    Args, 4 * sizeof(ULONG64), &Done)) {
        Done = 0;
    }

    ZeroMemory((PUCHAR)Args + Done, 4 * sizeof(ULONG64) - Done);

    return Done > 0;
}

BOOL
WalkAmd64Init(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PAMD64_CONTEXT                    Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    AMD64_CONTEXT ContextSave;
    DWORD64 PcOffset;
    DWORD64 StackOffset;
    DWORD64 FrameOffset;

    ZeroMemory( &StackFrame->AddrBStore, sizeof(StackFrame->AddrBStore) );
    StackFrame->FuncTableEntry = NULL;
    ZeroMemory( StackFrame->Params, sizeof(StackFrame->Params) );
    StackFrame->Far = FALSE;
    StackFrame->Virtual = TRUE;
    ZeroMemory( StackFrame->Reserved, sizeof(StackFrame->Reserved) );

    if (!StackFrame->AddrPC.Offset) {
        StackFrame->AddrPC.Offset = Context->Rip;
        StackFrame->AddrPC.Mode   = AddrModeFlat;
    }

    if (!StackFrame->AddrStack.Offset) {
        StackFrame->AddrStack.Offset = Context->Rsp;
        StackFrame->AddrStack.Mode   = AddrModeFlat;
    }

    if (!StackFrame->AddrFrame.Offset) {
        StackFrame->AddrFrame.Offset = Context->Rbp;
        StackFrame->AddrFrame.Mode   = AddrModeFlat;
    }

    if ((StackFrame->AddrPC.Mode != AddrModeFlat) ||
        (StackFrame->AddrStack.Mode != AddrModeFlat) ||
        (StackFrame->AddrFrame.Mode != AddrModeFlat)) {
        return FALSE;
    }

    PcOffset = StackFrame->AddrPC.Offset;
    StackOffset = StackFrame->AddrStack.Offset;
    FrameOffset = StackFrame->AddrFrame.Offset;

    ContextSave = *Context;
    ContextSave.Rip = PcOffset;
    ContextSave.Rsp = StackOffset;
    ContextSave.Rbp = FrameOffset;
    
    if (!UnwindStackFrameAmd64( Process,
                                &PcOffset,
                                &StackOffset,
                                &FrameOffset,
                                &ContextSave,
                                ReadMemory,
                                FunctionTableAccess,
                                GetModuleBase)) {
        return FALSE;
    }

    StackFrame->AddrReturn.Offset = PcOffset;
    StackFrame->AddrReturn.Mode = AddrModeFlat;

    StackFrame->AddrFrame.Offset = FrameOffset;
    ReadFrameArgsAmd64(&StackFrame->AddrFrame, Process,
                       ReadMemory, StackFrame->Params);

    return TRUE;
}


BOOL
WalkAmd64Next(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PAMD64_CONTEXT                    Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    DWORD Done;
    BOOL Succ = TRUE;
    DWORD64 StackAddress;
    _PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry;

    if (!UnwindStackFrameAmd64( Process,
                                &StackFrame->AddrPC.Offset,
                                &StackFrame->AddrStack.Offset,
                                &StackFrame->AddrFrame.Offset,
                                Context,
                                ReadMemory,
                                FunctionTableAccess,
                                GetModuleBase)) {
        Succ = FALSE;

        //
        // If the frame could not be unwound or is terminal, see if
        // there is a callback frame:
        //

        if (g.AppVersion.Revision >= 4 && CALLBACK_STACK(StackFrame)) {
            DWORD64 ImageBase;

            if (CALLBACK_STACK(StackFrame) & 0x80000000) {

                //
                // it is the pointer to the stack frame that we want
                //

                StackAddress = CALLBACK_STACK(StackFrame);

            } else {

                //
                // if it is a positive integer, it is the offset to
                // the address in the thread.
                // Look up the pointer:
                //

                Succ = ReadMemory(Process,
                                  (CALLBACK_THREAD(StackFrame) +
                                   CALLBACK_STACK(StackFrame)),
                                  &StackAddress,
                                  sizeof(StackAddress),
                                  &Done);
                if (!Succ || Done != sizeof(StackAddress) ||
                    StackAddress == 0) {
                    StackAddress = (DWORD64)-1;
                    CALLBACK_STACK(StackFrame) = (DWORD)-1;
                }
            }

            if ((StackAddress == (DWORD64)-1) ||
                (!(FunctionEntry = (_PIMAGE_RUNTIME_FUNCTION_ENTRY)
                   FunctionTableAccess(Process, CALLBACK_FUNC(StackFrame))) ||
                 !(ImageBase = GetModuleBase(Process,
                                             CALLBACK_FUNC(StackFrame))))) {

                Succ = FALSE;

            } else {

                if (!ReadMemory(Process,
                                (StackAddress + CALLBACK_NEXT(StackFrame)),
                                &CALLBACK_STACK(StackFrame),
                                sizeof(DWORD64),
                                &Done) ||
                    Done != sizeof(DWORD64)) {
                    Succ = FALSE;
                } else {
                    StackFrame->AddrPC.Offset =
                        ImageBase + FunctionEntry->BeginAddress;
                    StackFrame->AddrStack.Offset = StackAddress;
                    Context->Rsp = StackAddress;

                    Succ = TRUE;
                }
            }
        }
    }

    if (Succ) {
        AMD64_CONTEXT ContextSave;
        ULONG64 StackOffset = 0;
        ULONG64 FrameOffset = 0;

        //
        // Get the return address.
        //
        ContextSave = *Context;
        StackFrame->AddrReturn.Offset = StackFrame->AddrPC.Offset;

        if (!UnwindStackFrameAmd64( Process,
                                    &StackFrame->AddrReturn.Offset,
                                    &StackOffset,
                                    &FrameOffset,
                                    &ContextSave,
                                    ReadMemory,
                                    FunctionTableAccess,
                                    GetModuleBase)) {
            StackFrame->AddrReturn.Offset = 0;
        }

        StackFrame->AddrFrame.Offset = FrameOffset;
        ReadFrameArgsAmd64(&StackFrame->AddrFrame, Process, ReadMemory,
                           StackFrame->Params);
    }

    return Succ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\walki64.c ===
/*++

Copyright (c) 1996  Intel Corporation
Copyright (c) 1993  Microsoft Corporation

Module Name:

    walki64.c

Abstract:

    This file implements the IA64 stack walking api.

Author:

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#define _IA64REG_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#include "ia64inst.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "symbols.h"
#include <stdlib.h>
#include <globals.h>

BOOL
WalkIa64Init(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
WalkIa64Next(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
GetStackFrameIa64(
    HANDLE                            hProcess,
    PULONG64                          ReturnAddress,
    PULONG64                          FramePointer,
    PULONG64                          BStorePointer,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    UINT                              iContext
    );

#define CALLBACK_STACK(f)  (f->KdHelp.ThCallbackStack)
#define CALLBACK_BSTORE(f) (f->KdHelp.ThCallbackBStore)
#define CALLBACK_NEXT(f)   (f->KdHelp.NextCallback)
#define CALLBACK_FUNC(f)   (f->KdHelp.KiCallUserMode)
#define CALLBACK_THREAD(f) (f->KdHelp.Thread)



BOOL
WalkIa64(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    BOOL rval;
    PIA64_CONTEXT Context = (PIA64_CONTEXT)ContextRecord;

    if (StackFrame->Virtual) {

        rval = WalkIa64Next( hProcess,
                             StackFrame,
                             Context,
                             ReadMemory,
                             FunctionTableAccess,
                             GetModuleBase
                           );

    } else {

        rval = WalkIa64Init( hProcess,
                             StackFrame,
                             Context,
                             ReadMemory,
                             FunctionTableAccess,
                             GetModuleBase
                           );

    } // iff

    return rval;

} // WalkIa64()

size_t 
Vwndia64InitFixupTable(UINT iContext);

BOOL 
Vwndia64IsFixupIp(UINT iContext, ULONGLONG Ip);

UINT 
Vwndia64NewContext();

BOOL
Vwndia64ValidateContext(UINT* iContextPtr);

void
Vwndia64ReportFailure(UINT iContext, LPCSTR szFormat, ...);

ULONGLONG
VirtualUnwindIa64 (
    HANDLE hProcess,
    ULONGLONG ImageBase,
    DWORD64 ControlPc,
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    PIA64_CONTEXT ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    UINT iContext
    );

BOOL
GetStackFrameIa64(
    IN     HANDLE                            hProcess,
    IN OUT PULONG64                          ReturnAddress,
    IN OUT PULONG64                          FramePointer,
    IN OUT PULONG64                          BStorePointer,
    IN     PIA64_CONTEXT                     Context,        // Context members could be modified.
    IN     PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    IN     PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    IN     PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    IN     UINT                              iContext
    )
{
    ULONGLONG                          ImageBase;
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY rf;
    ULONG64                            dwRa = (ULONG64)Context->BrRp;
    BOOL                               rval = TRUE;

    rf = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY) FunctionTableAccess( hProcess, *ReturnAddress );

    if (rf) {
        //
        // The Rp value coming out of mainCRTStartup is set by some run-time
        // routine to be 0; this serves to cause an error if someone actually
        // does a return from the mainCRTStartup frame.
        //

        ImageBase = GetModuleBase(hProcess, *ReturnAddress);
        dwRa = (ULONG64)VirtualUnwindIa64( hProcess, ImageBase, 
                                           *ReturnAddress, rf, Context, 
                                           ReadMemory, iContext);
        if (!dwRa) {
            rval = FALSE;
        }

        if ((dwRa == *ReturnAddress) &&
// TF-CHKCHK 10/20/99: (*FramePointer == Context->IntSp) &&
               (*BStorePointer == Context->RsBSP)) {
            rval = FALSE;
        }

        *ReturnAddress = dwRa;
        *FramePointer  = Context->IntSp;
        *BStorePointer = Context->RsBSP;

    } else {

        SHORT BsFrameSize;
        SHORT TempFrameSize;

        if (dwRa == *ReturnAddress)
        {
            if (dwRa) 
            {
                Vwndia64ReportFailure(iContext, 
                                     "Can't find runtime function entry info "
                                        "for %08x`%08x, "
                                        "results might be unreliable!\n",
                                     (ULONG)(*ReturnAddress >> 32), 
                                     (ULONG)(*ReturnAddress));
            }
     
            if ((*FramePointer  == Context->IntSp) &&
               (*BStorePointer == Context->RsBSP)) 
            {
                rval = FALSE;
            }
        }

        *ReturnAddress = Context->BrRp;
        *FramePointer  = Context->IntSp;
        *BStorePointer = Context->RsBSP;
        Context->StIFS = Context->RsPFS;
        BsFrameSize = (SHORT)(Context->StIFS >> IA64_PFS_SIZE_SHIFT) & IA64_PFS_SIZE_MASK;
        TempFrameSize = BsFrameSize - (SHORT)((Context->RsBSP >> 3) & IA64_NAT_BITS_PER_RNAT_REG);
        while (TempFrameSize > 0) {
            BsFrameSize++;
            TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
        }
        Context->RsBSPSTORE = ( Context->RsBSP -= (BsFrameSize * sizeof(ULONGLONG)) );
    }

    //
    // The next code intend to fix stack unwind for __declspec(noreturn) 
    // function calls (like KeBugCheck) where the return address points to 
    // another (next) function. So changing the ReturnAddress to point to 
    // calling instruction.
    //
    if (!Vwndia64IsFixupIp(iContext, *ReturnAddress))
    { 
        ULONG64 CallerAddress  = (*ReturnAddress) - 0x10;
        PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY rfFix = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)
            FunctionTableAccess(hProcess, CallerAddress);

        if (rfFix) {
            IMAGE_IA64_RUNTIME_FUNCTION_ENTRY rfFixVal = *rfFix;
            rf = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)
                FunctionTableAccess(hProcess, *ReturnAddress);
            if (
                !(
                    rf && 
                    (rfFixVal.BeginAddress == rf->BeginAddress) &&
                    (rfFixVal.EndAddress == rf->EndAddress) &&
                    (rfFixVal.UnwindInfoAddress == rf->UnwindInfoAddress)
                )
            ){
                *ReturnAddress = CallerAddress;
            } 
        } 
    } 

    return rval;
}

BOOL
ReadFunctionArgumentsFromContext( 
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    HANDLE        hProcess, 
    PIA64_CONTEXT pContext, 
    DWORD64       Params[]   // WARNING - no runtime size check. 4 entries are assumed...
    )
{
    BOOL        result;
    ULONG       index;
    DWORD       cb;
    ULONGLONG   rsBSP;
   
//  ASSERT( ReadMemory );
//  ASSERT( hProcess && (hProcess != INVALID_HANDLE_VALUE) );
    if ( !pContext || !Params  )    {
       return FALSE;
    }

//
// IA64 Notes [for the curious reader...]:
//
//   The register backing store is organized as a stack in memory that grows 
//   from lower to higher addresses.
//   The Backing Store Pointer (BSP) register contains the address of the first
//   (lowest) memory location reserved for the current frame. This corresponds
//   to the location at which the GR32 register of the current frame will be spilled.
//   The BSPSTORE register contains the address at which the new RSE spill will 
//   occur.
//   The BSP load pointer - address register which corresponds to the next RSE
//   fill operation - is not architectually visible.
//
//   The RSE spills/fills the NaT bits corresponding to the stacked registers. 
//   The NaT bits for the stacked registers are spilled/filled in groups of 63
//   corresponding to 63 consecutive physical stacked registers. When the RSE spills
//   a register to the backing store, the corresponding NaT bit is copied to the RNAT
//   register (RSE NaT collection register).
//   When BSPSTORE[8:3] bits are all one, RSE stores RNAT to the backing store. Meaning
//   that every 63 register values stored to the backing store are followed by a stored
//   RNAT. Note RNAT[63] bit is always written as zero.
//   
//   This explains the following code:
//

    // 
    // Check for spilled NaT collection register mixed w/ arguments.
    //
    rsBSP = pContext->RsBSP;
    index = (ULONG)(rsBSP & 0x1F8) >> 3; 
    if (index > 59) {

        DWORD i, j;
        DWORD64 localParams[5];

        //
        // Read in memory, 4 arguments + 1 NaT collection register.
        // 
        result = ReadMemory ( hProcess, rsBSP, localParams, sizeof(localParams), &cb );
        if (result) {
            j = 0;
            for (i = 0; i < DIMA(localParams) ; i++, index++) {
                if (index != 63) {
                    Params[j++] = localParams[i];
                }
            }
        }

    } else {

        //
        // We do not have the NaT collection register mixed w/ function arguments.
        // Read the 4 arguments from backing store memory.
        //
        result = ReadMemory ( hProcess, rsBSP, Params, 4 * sizeof(Params[0]), &cb );
    }

    return( result );

} // ReadFunctionArgumentsFromContext()


#define WALKI64_SAVE_IFS(sf)      ((sf).Reserved[0])
#define WALKI64_CONTEXT_INDEX(sf) ((sf).Reserved[2])

BOOL
WalkIa64Init(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    IA64_KSWITCH_FRAME SwitchFrame;
    IA64_CONTEXT       ContextSave;
    DWORD64           PcOffset;
    DWORD64           StackOffset;
    DWORD64           FrameOffset;
    DWORD             cb;
    BOOL              result;


    UINT iContext = (UINT)
        (WALKI64_CONTEXT_INDEX(*StackFrame) = Vwndia64NewContext());

    ZeroMemory( StackFrame, FIELD_OFFSET( STACKFRAME64, KdHelp ) );
// TF-XXXXXX:   ZeroMemory( StackFrame, sizeof(*StackFrame) );

    StackFrame->Virtual = TRUE;

    if (!StackFrame->AddrPC.Offset) 
    {
        StackFrame->AddrPC.Offset = Ia64InsertIPSlotNumber(
                                        (Context->StIIP & ~(ULONGLONG)0xf), 
                                        ((Context->StIPSR >> PSR_RI) & 0x3));
        StackFrame->AddrPC.Mode   = AddrModeFlat;
    }

    if (!StackFrame->AddrStack.Offset)
    {
        StackFrame->AddrStack.Offset = Context->IntSp;
        StackFrame->AddrStack.Mode   = AddrModeFlat;
    }

    if (!StackFrame->AddrFrame.Offset)
    {
        if (StackFrame->AddrBStore.Offset)
        {
            StackFrame->AddrFrame = StackFrame->AddrBStore;
        }
        else 
        {
            StackFrame->AddrFrame.Offset = Context->RsBSP;
            StackFrame->AddrFrame.Mode   = AddrModeFlat;
        } 
    }
    StackFrame->AddrBStore = StackFrame->AddrFrame;

    if ((StackFrame->AddrPC.Mode != AddrModeFlat) ||
        (StackFrame->AddrStack.Mode != AddrModeFlat) ||
        (StackFrame->AddrFrame.Mode != AddrModeFlat) ||
        (StackFrame->AddrBStore.Mode != AddrModeFlat))
    {
        return FALSE;
    }

    WALKI64_SAVE_IFS(*StackFrame) = Context->StIFS;
    WALKI64_CONTEXT_INDEX(*StackFrame) = iContext;

    ContextSave = *Context;
    PcOffset    = StackFrame->AddrPC.Offset;
    StackOffset = StackFrame->AddrStack.Offset;
    FrameOffset = StackFrame->AddrFrame.Offset;

    if (!GetStackFrameIa64( hProcess,
                        &PcOffset,
                        &StackOffset,
                        &FrameOffset,
                        &ContextSave,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase,
                        iContext) ) 
    {

        StackFrame->AddrReturn.Offset = Context->BrRp;

    } else {

        StackFrame->AddrReturn.Offset = PcOffset;
    }

    StackFrame->AddrReturn.Mode     = AddrModeFlat;

    result = ReadFunctionArgumentsFromContext( ReadMemory, 
                                               hProcess, 
                                               Context, 
                                               StackFrame->Params 
                                             );
    if ( !result ) {
        StackFrame->Params[0] =
        StackFrame->Params[1] =
        StackFrame->Params[2] =
        StackFrame->Params[3] = 0;
    }

    return TRUE;
}


BOOL
WalkIa64Next(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    DWORD           cb;
    IA64_CONTEXT    ContextSave;
    BOOL            rval = TRUE;
    BOOL            result;
    DWORD64         StackAddress;
    DWORD64         BStoreAddress;
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY rf;
    DWORD64         fp  = (DWORD64)0;
    DWORD64         bsp = (DWORD64)0;

    UINT iContext = (UINT)WALKI64_CONTEXT_INDEX(*StackFrame);
    if (!Vwndia64ValidateContext(&iContext)) 
    {
        WALKI64_CONTEXT_INDEX(*StackFrame) = iContext;
    }

    if (!GetStackFrameIa64( hProcess,
                        &StackFrame->AddrPC.Offset,
                        &StackFrame->AddrStack.Offset,
                        &StackFrame->AddrFrame.Offset,
                        Context,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase,
                        iContext) ) 
    {

        rval = FALSE;

        //
        // If the frame could not be unwound or is terminal, see if
        // there is a callback frame:
        //

        if (g.AppVersion.Revision >= 4 && CALLBACK_STACK(StackFrame)) {
            DWORD64 imageBase;

            if (CALLBACK_STACK(StackFrame) & 0x80000000) {

                //
                // it is the pointer to the stack frame that we want
                //

                StackAddress = CALLBACK_STACK(StackFrame);

            } else {

                //
                // if it is a positive integer, it is the offset to
                // the address in the thread.
                // Look up the pointer:
                //

                rval = ReadMemory(hProcess,
                                  (CALLBACK_THREAD(StackFrame) +
                                                 CALLBACK_STACK(StackFrame)),
                                  &StackAddress,
                                  sizeof(DWORD64),
                                  &cb);

                if (!rval || StackAddress == 0) {
                    StackAddress = (DWORD64)-1;
                    CALLBACK_STACK(StackFrame) = (DWORD)-1;
                }

            }

            if ( (StackAddress == (DWORD64)-1) ||
                ( !(rf = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)
                     FunctionTableAccess(hProcess, CALLBACK_FUNC(StackFrame))) || !( imageBase = GetModuleBase(hProcess, CALLBACK_FUNC(StackFrame)) ) ) ) {

                rval = FALSE;

            } else {

                ReadMemory(hProcess,
                           (StackAddress + CALLBACK_NEXT(StackFrame)),
                           &CALLBACK_STACK(StackFrame),
                           sizeof(DWORD64),
                           &cb);

                StackFrame->AddrPC.Offset = imageBase + rf->BeginAddress; 
                StackFrame->AddrStack.Offset = StackAddress;
                Context->IntSp = StackAddress;
                WALKI64_SAVE_IFS(*StackFrame) = 0;

                rval = TRUE;
            }

        }
    } else {
        WALKI64_SAVE_IFS(*StackFrame) = Context->StIFS;
    }

    StackFrame->AddrBStore = StackFrame->AddrFrame;

    //
    // get the return address
    //
    ContextSave = *Context;
    StackFrame->AddrReturn.Offset = StackFrame->AddrPC.Offset;

    if (!GetStackFrameIa64( hProcess,
                        &StackFrame->AddrReturn.Offset,
                        &fp,
                        &bsp,
                        &ContextSave,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase, iContext) ) 
    {

// rval = FALSE;
        StackFrame->AddrReturn.Offset = 0;

    }

    result = ReadFunctionArgumentsFromContext( ReadMemory, 
                                               hProcess, 
                                               Context, 
                                               StackFrame->Params 
                                             );
    if ( !result ) {
        StackFrame->Params[0] =
        StackFrame->Params[1] =
        StackFrame->Params[2] =
        StackFrame->Params[3] = 0;
    }

    return rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\walkx86.c ===
/*++

Copyright (c) 1993-2002  Microsoft Corporation

Module Name:

    walkx86.c

Abstract:

    This file implements the Intel x86 stack walking api.  This api allows for
    the presence of "real mode" stack frames.  This means that you can trace
    into WOW code.

Author:

    Wesley Witt (wesw) 1-Oct-1993

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <objbase.h>
#include <wx86dll.h>
#include <symbols.h>
#include <globals.h>
#include "dia2.h"

#define WDB(Args) SdbOut Args


#define SAVE_EBP(f)        (f->Reserved[0])
#define IS_EBP_SAVED(f)    (f->Reserved[0] && ((f->Reserved[0] >> 32) != 0xEB))
#define TRAP_TSS(f)        (f->Reserved[1])
#define TRAP_EDITED(f)     (f->Reserved[1])
#define SAVE_TRAP(f)       (f->Reserved[2])
#define CALLBACK_STACK(f)  (f->KdHelp.ThCallbackStack)
#define CALLBACK_NEXT(f)   (f->KdHelp.NextCallback)
#define CALLBACK_FUNC(f)   (f->KdHelp.KiCallUserMode)
#define CALLBACK_THREAD(f) (f->KdHelp.Thread)
#define CALLBACK_FP(f)     (f->KdHelp.FramePointer)
#define CALLBACK_DISPATCHER(f) (f->KdHelp.KeUserCallbackDispatcher)
#define SYSTEM_RANGE_START(f) (f->KdHelp.SystemRangeStart)

#define STACK_SIZE         (sizeof(DWORD))
#define FRAME_SIZE         (STACK_SIZE * 2)

#define STACK_SIZE16       (sizeof(WORD))
#define FRAME_SIZE16       (STACK_SIZE16 * 2)
#define FRAME_SIZE1632     (STACK_SIZE16 * 3)

#define MAX_STACK_SEARCH   64   // in STACK_SIZE units
#define MAX_JMP_CHAIN      64   // in STACK_SIZE units
#define MAX_CALL           7    // in bytes
#define MIN_CALL           2    // in bytes
#define MAX_FUNC_PROLOGUE  64   // in bytes

#define PUSHBP             0x55
#define MOVBPSP            0xEC8B

ULONG g_vc7fpo = 1;

#define DoMemoryRead(addr,buf,sz,br) \
    ReadMemoryInternal( Process, Thread, addr, buf, sz, \
                        br, ReadMemory, TranslateAddress, FALSE )

#define DoMemoryReadAll(addr,buf,sz) \
    ReadMemoryInternal( Process, Thread, addr, buf, sz, \
                        NULL, ReadMemory, TranslateAddress, TRUE )


BOOL
WalkX86Init(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PX86_CONTEXT                      ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

BOOL
WalkX86Next(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PX86_CONTEXT                      ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

BOOL
ReadMemoryInternal(
    HANDLE                          Process,
    HANDLE                          Thread,
    LPADDRESS64                     lpBaseAddress,
    LPVOID                          lpBuffer,
    DWORD                           nSize,
    LPDWORD                         lpNumberOfBytesRead,
    PREAD_PROCESS_MEMORY_ROUTINE64  ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64    TranslateAddress,
    BOOL                            MustReadAll
    );

BOOL
IsFarCall(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    BOOL                              *Ok,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

BOOL
ReadTrapFrame(
    HANDLE                            Process,
    DWORD64                           TrapFrameAddress,
    PX86_KTRAP_FRAME                  TrapFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    );

BOOL
TaskGate2TrapFrame(
    HANDLE                            Process,
    USHORT                            TaskRegister,
    PX86_KTRAP_FRAME                  TrapFrame,
    PULONG64                          off,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    );

DWORD64
SearchForReturnAddress(
    HANDLE                            Process,
    DWORD64                           uoffStack,
    DWORD64                           funcAddr,
    DWORD                             funcSize,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    BOOL                              AcceptUnreadableCallSite
    );

//----------------------------------------------------------------------------
//
// DIA IDiaStackWalkFrame implementation.
//
//----------------------------------------------------------------------------

class X86WalkFrame : public IDiaStackWalkFrame
{
public:
    X86WalkFrame(HANDLE Process,
                 X86_CONTEXT* Context,
                 PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
                 PGET_MODULE_BASE_ROUTINE64 GetModuleBase,
                 PFPO_DATA PreviousFpo)
    {
        m_Process = Process;
        m_Context = Context;
        m_ReadMemory = ReadMemory;
        m_GetModuleBase = GetModuleBase;
        m_Locals = 0;
        m_Params = 0;
        m_VirtFrame = Context->Ebp;
        m_PreviousFpo = PreviousFpo;
        m_EbpSet = FALSE;
    }

    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDiaStackWalkFrame.
    STDMETHOD(get_registerValue)(DWORD reg, ULONGLONG* pValue);
    STDMETHOD(put_registerValue)(DWORD reg, ULONGLONG value);
    STDMETHOD(readMemory)(ULONGLONG va, DWORD cbData,
                          DWORD* pcbData, BYTE* data);
    STDMETHOD(searchForReturnAddress)(IDiaFrameData* frame,
                                      ULONGLONG* pResult);
    STDMETHOD(searchForReturnAddressStart)(IDiaFrameData* frame,
                                           ULONGLONG startAddress,
                                           ULONGLONG* pResult);

    BOOL WasEbpSet(void)
    {
        return m_EbpSet;
    }

private:
    HANDLE m_Process;
    X86_CONTEXT* m_Context;
    PREAD_PROCESS_MEMORY_ROUTINE64 m_ReadMemory;
    PGET_MODULE_BASE_ROUTINE64 m_GetModuleBase;
    ULONGLONG m_Locals;
    ULONGLONG m_Params;
    ULONGLONG m_VirtFrame;
    PFPO_DATA m_PreviousFpo;
    BOOL m_EbpSet;
};

STDMETHODIMP
X86WalkFrame::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;

    *Interface = NULL;
    Status = E_NOINTERFACE;

    if (IsEqualIID(InterfaceId, IID_IDiaStackWalkFrame)) {
        *Interface = (IDiaStackWalkFrame*)this;
        Status = S_OK;
    }

    return Status;
}

STDMETHODIMP_(ULONG)
X86WalkFrame::AddRef(
    THIS
    )
{
    // Stack allocated, no refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
X86WalkFrame::Release(
    THIS
    )
{
    // Stack allocated, no refcount.
    return 0;
}

STDMETHODIMP
X86WalkFrame::get_registerValue( DWORD reg, ULONGLONG* pVal )
{
    switch( reg ) {
        // debug registers
    case CV_REG_DR0:
        *pVal = m_Context->Dr0;
        break;
    case CV_REG_DR1:
        *pVal = m_Context->Dr1;
        break;
    case CV_REG_DR2:
        *pVal = m_Context->Dr2;
        break;
    case CV_REG_DR3:
        *pVal = m_Context->Dr3;
        break;
    case CV_REG_DR6:
        *pVal = m_Context->Dr6;
        break;
    case CV_REG_DR7:
        *pVal = m_Context->Dr7;
        break;

        // segment registers
    case CV_REG_GS:
        *pVal = m_Context->SegGs;
        break;
    case CV_REG_FS:
        *pVal = m_Context->SegFs;
        break;
    case CV_REG_ES:
        *pVal = m_Context->SegEs;
        break;
    case CV_REG_DS:
        *pVal = m_Context->SegDs;
        break;

        // integer registers
    case CV_REG_EDI:
        *pVal = m_Context->Edi;
        break;
    case CV_REG_ESI:
        *pVal = m_Context->Esi;
        break;
    case CV_REG_EBX:
        *pVal = m_Context->Ebx;
        break;
    case CV_REG_EDX:
        *pVal = m_Context->Edx;
        break;
    case CV_REG_ECX:
        *pVal = m_Context->Ecx;
        break;
    case CV_REG_EAX:
        *pVal = m_Context->Eax;
        break;

        // control registers
    case CV_REG_EBP:
        *pVal = m_Context->Ebp;
        break;
    case CV_REG_EIP:
        *pVal = m_Context->Eip;
        break;
    case CV_REG_CS:
        *pVal = m_Context->SegCs;
        break;
    case CV_REG_EFLAGS:
        *pVal = m_Context->EFlags;
        break;
    case CV_REG_ESP:
        *pVal = m_Context->Esp;
        break;
    case CV_REG_SS:
        *pVal = m_Context->SegSs;
        break;

    case CV_ALLREG_LOCALS:
        *pVal = m_Locals;
        break;
    case CV_ALLREG_PARAMS:
        *pVal = m_Params;
        break;
    case CV_ALLREG_VFRAME:
        *pVal = m_VirtFrame;
        break;

    default:
        *pVal = 0;
        return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP
X86WalkFrame::put_registerValue( DWORD reg, ULONGLONG LongVal )
{
    ULONG val = (ULONG)LongVal;

    switch( reg ) {
        // debug registers
    case CV_REG_DR0:
        m_Context->Dr0 = val;
        break;
    case CV_REG_DR1:
        m_Context->Dr1 = val;
        break;
    case CV_REG_DR2:
        m_Context->Dr2 = val;
        break;
    case CV_REG_DR3:
        m_Context->Dr3 = val;
        break;
    case CV_REG_DR6:
        m_Context->Dr6 = val;
        break;
    case CV_REG_DR7:
        m_Context->Dr7 = val;
        break;

        // segment registers
    case CV_REG_GS:
        m_Context->SegGs = val;
        break;
    case CV_REG_FS:
        m_Context->SegFs = val;
        break;
    case CV_REG_ES:
        m_Context->SegEs = val;
        break;
    case CV_REG_DS:
        m_Context->SegDs = val;
        break;

        // integer registers
    case CV_REG_EDI:
        m_Context->Edi = val;
        break;
    case CV_REG_ESI:
        m_Context->Esi = val;
        break;
    case CV_REG_EBX:
        m_Context->Ebx = val;
        break;
    case CV_REG_EDX:
        m_Context->Edx = val;
        break;
    case CV_REG_ECX:
        m_Context->Ecx = val;
        break;
    case CV_REG_EAX:
        m_Context->Eax = val;
        break;

        // control registers
    case CV_REG_EBP:
        m_Context->Ebp = val;
        m_EbpSet = TRUE;
        break;
    case CV_REG_EIP:
        m_Context->Eip = val;
        break;
    case CV_REG_CS:
        m_Context->SegCs = val;
        break;
    case CV_REG_EFLAGS:
        m_Context->EFlags = val;
        break;
    case CV_REG_ESP:
        m_Context->Esp = val;
        break;
    case CV_REG_SS:
        m_Context->SegSs = val;
        break;

    case CV_ALLREG_LOCALS:
        m_Locals = val;
        break;
    case CV_ALLREG_PARAMS:
        m_Params = val;
        break;
    case CV_ALLREG_VFRAME:
        m_VirtFrame = val;
        break;

    default:
        return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP
X86WalkFrame::readMemory(ULONGLONG va, DWORD cbData,
                         DWORD* pcbData, BYTE* data)
{
    return m_ReadMemory( m_Process, va, data, cbData, pcbData ) != 0 ?
        S_OK : E_FAIL;
}

STDMETHODIMP
X86WalkFrame::searchForReturnAddress(IDiaFrameData* frame,
                                     ULONGLONG* pResult)
{
    HRESULT Status;
    DWORD LenLocals, LenRegs;

    if ((Status = frame->get_lengthLocals(&LenLocals)) != S_OK ||
        (Status = frame->get_lengthSavedRegisters(&LenRegs)) != S_OK) {
        return Status;
    }

    return searchForReturnAddressStart(frame,
                                       EXTEND64(m_Context->Esp +
                                                LenLocals + LenRegs),
                                       pResult);
}

STDMETHODIMP
X86WalkFrame::searchForReturnAddressStart(IDiaFrameData* DiaFrame,
                                          ULONGLONG StartAddress,
                                          ULONGLONG* Result)
{
    HRESULT Status;
    BOOL HasSeh, IsFuncStart;
    IDiaFrameData* OrigFrame = DiaFrame;
    IDiaFrameData* NextFrame;

    DWORD LenLocals, LenRegs, LenParams = 0;

    if (m_PreviousFpo &&
        m_PreviousFpo->cbFrame != FRAME_TRAP &&
        m_PreviousFpo->cbFrame != FRAME_TSS) {
        //
        // if the previous frame had an fpo record, we can account
        // for its parameters
        //
        LenParams = m_PreviousFpo->cdwParams * STACK_SIZE;
    }

    if ((Status = DiaFrame->get_lengthLocals(&LenLocals)) != S_OK ||
        (Status = DiaFrame->get_lengthSavedRegisters(&LenRegs)) != S_OK ||
        (Status = DiaFrame->get_systemExceptionHandling(&HasSeh)) != S_OK ||
        (Status = DiaFrame->get_functionStart(&IsFuncStart)) != S_OK) {
        return Status;
    }

    if ((!HasSeh || IsFuncStart) &&
        m_Context->Esp + LenLocals + LenRegs + LenParams >
        (ULONG) StartAddress) {
        StartAddress =
            EXTEND64(m_Context->Esp + LenLocals + LenRegs + LenParams);
    }

    //
    // This frame data may be a subsidiary descriptor.  Move up
    // the parent chain to the true function start.
    //

    while (DiaFrame->get_functionParent(&NextFrame) == S_OK) {
        if (DiaFrame != OrigFrame) {
            DiaFrame->Release();
        }
        DiaFrame = NextFrame;
    }

    ULONGLONG FuncStart;
    DWORD LenFunc;

    if ((Status = DiaFrame->get_virtualAddress(&FuncStart)) == S_OK) {
        Status = DiaFrame->get_lengthBlock(&LenFunc);
    }

    if (DiaFrame != OrigFrame) {
        DiaFrame->Release();
    }

    if (Status != S_OK) {
        return Status;
    }

    *Result = SearchForReturnAddress(m_Process,
                                     StartAddress,
                                     FuncStart,
                                     LenFunc,
                                     m_ReadMemory,
                                     m_GetModuleBase,
                                     TRUE);
    return *Result != 0 ? S_OK : E_FAIL;
}

//----------------------------------------------------------------------------
//
// Walk functions.
//
//----------------------------------------------------------------------------

BOOL
WalkX86(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress,
    DWORD                             flags
    )
{
    BOOL rval;

    WDB((2, "WalkX86  in: PC %X, SP %X, FP %X, RA %X\n",
         (ULONG)StackFrame->AddrPC.Offset,
         (ULONG)StackFrame->AddrStack.Offset,
         (ULONG)StackFrame->AddrFrame.Offset,
         (ULONG)StackFrame->AddrReturn.Offset));

    if (StackFrame->Virtual) {

        rval = WalkX86Next( Process,
                            Thread,
                            StackFrame,
                            (PX86_CONTEXT)ContextRecord,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress
                          );

    } else {

        rval = WalkX86Init( Process,
                            Thread,
                            StackFrame,
                            (PX86_CONTEXT)ContextRecord,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress
                          );

    }

    WDB((2, "WalkX86 out: PC %X, SP %X, FP %X, RA %X\n",
         (ULONG)StackFrame->AddrPC.Offset,
         (ULONG)StackFrame->AddrStack.Offset,
         (ULONG)StackFrame->AddrFrame.Offset,
         (ULONG)StackFrame->AddrReturn.Offset));

    // This hack fixes the fpo stack when ebp wasn't used.
    // Don't put this fix into StackWalk() or it will break MSDEV.
#if 0
    if (rval && (flags & WALK_FIX_FPO_EBP)) {
            PFPO_DATA   pFpo = (PFPO_DATA)StackFrame->FuncTableEntry;
        if (pFpo && !pFpo->fUseBP) {
                StackFrame->AddrFrame.Offset += 4;
            }
    }
#endif

    return rval;
}

BOOL
ReadMemoryInternal(
    HANDLE                          Process,
    HANDLE                          Thread,
    LPADDRESS64                     lpBaseAddress,
    LPVOID                          lpBuffer,
    DWORD                           nSize,
    LPDWORD                         lpNumberOfBytesRead,
    PREAD_PROCESS_MEMORY_ROUTINE64  ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64    TranslateAddress,
    BOOL                            MustReadAll
    )
{
    ADDRESS64 addr;
    DWORD LocalBytesRead = 0;
    BOOL Succ;

    addr = *lpBaseAddress;
    if (addr.Mode != AddrModeFlat) {
        TranslateAddress( Process, Thread, &addr );
    }
    Succ = ReadMemory( Process,
                       addr.Offset,
                       lpBuffer,
                       nSize,
                       &LocalBytesRead
                       );
    if (lpNumberOfBytesRead) {
        *lpNumberOfBytesRead = LocalBytesRead;
    }
    return (Succ && MustReadAll) ? (LocalBytesRead == nSize) : Succ;
}

DWORD64
SearchForReturnAddress(
    HANDLE                            Process,
    DWORD64                           uoffStack,
    DWORD64                           funcAddr,
    DWORD                             funcSize,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    BOOL                              AcceptUnreadableCallSite
    )
{
    DWORD64        uoffRet;
    DWORD64        uoffBestGuess = 0;
    DWORD          cdwIndex;
    DWORD          cdwIndexMax;
    INT            cbIndex;
    INT            cbLimit;
    DWORD          cBytes;
    DWORD          cJmpChain = 0;
    DWORD64        uoffT;
    DWORD          cb;
    BYTE           jmpBuffer[ sizeof(WORD) + sizeof(DWORD) ];
    LPWORD         lpwJmp = (LPWORD)&jmpBuffer[0];
    BYTE           code[MAX_CALL];
    DWORD          stack [ MAX_STACK_SEARCH ];
    BOPINSTR BopInstr;

    WDB((1, "      SearchForReturnAddress: start %X\n", (ULONG)uoffStack));

    //
    // this function is necessary for 4 reasons:
    //
    //      1) random compiler bugs where regs are saved on the
    //         stack but the fpo data does not account for them
    //
    //      2) inline asm code that does a push
    //
    //      3) any random code that does a push and it isn't
    //         accounted for in the fpo data
    //
    //      4) non-void non-fpo functions
    //         *** This case is not neccessary when the compiler
    //          emits FPO records for non-FPO funtions.  Unfortunately
    //          only the NT group uses this feature.
    //

    if (!ReadMemory(Process,
                    uoffStack,
                    stack,
                    sizeof(stack),
                    &cb)) {
        WDB((1, "        can't read stack\n"));
        return 0;
    }


    cdwIndexMax = cb / STACK_SIZE;

    if ( !cdwIndexMax ) {
        WDB((1, "        can't read stack\n"));
        return 0;
    }

    for ( cdwIndex=0; cdwIndex<cdwIndexMax; cdwIndex++,uoffStack+=STACK_SIZE ) {

        uoffRet = (DWORD64)(LONG64)(LONG)stack[cdwIndex];

        //
        // Don't try looking for Code in the first 64K of an NT app.
        //
        if ( uoffRet < 0x00010000 ) {
            continue;
        }

        //
        // if it isn't part of any known address space it must be bogus
        //

        if (GetModuleBase( Process, uoffRet ) == 0) {
            continue;
        }

        //
        // Check for a BOP instruction.
        //
        if (ReadMemory(Process,
                       uoffRet - sizeof(BOPINSTR),
                       &BopInstr,
                       sizeof(BOPINSTR),
                       &cb)) {

            if (cb == sizeof(BOPINSTR) &&
                BopInstr.Instr1 == 0xc4 && BopInstr.Instr2 == 0xc4) {
                WDB((1, "        BOP, use %X\n", (ULONG)uoffStack));
                return uoffStack;
            }
        }

        //
        // Read the maximum number of bytes a call could be from the istream
        //
        cBytes = MAX_CALL;
        if (!ReadMemory(Process,
                        uoffRet - cBytes,
                        code,
                        cBytes,
                        &cb)) {

            //
            // if page is not present, we will ALWAYS mess up by
            // continuing to search.  If alloca was used also, we
            // are toast.  Too Bad.
            //
            if (cdwIndex == 0 && AcceptUnreadableCallSite) {
                WDB((1, "        unreadable call site, use %X\n",
                     (ULONG)uoffStack));
                return uoffStack;
            } else {
                continue;
            }
        }



        //
        // With 32bit code that isn't FAR:32 we don't have to worry about
        // intersegment calls.  Check here to see if we had a call within
        // segment.  If it is we can later check it's full diplacement if
        // necessary and see if it calls the FPO function.  We will also have
        // to check for thunks and see if maybe it called a JMP indirect which
        // called the FPO function. We will fail to find the caller if it was
        // a case of tail recursion where one function doesn't actually call
        // another but rather jumps to it.  This will only happen when a
        // function who's parameter list is void calls another function who's
        // parameter list is void and the call is made as the last statement
        // in the first function.  If the call to the first function was an
        // 0xE8 call we will fail to find it here because it didn't call the
        // FPO function but rather the FPO functions caller.  If we don't get
        // specific about our 0xE8 checks we will potentially see things that
        // look like return addresses but aren't.
        //

        if (( cBytes >= 5 ) && ( code[ 2 ] == 0xE8 )) {

            // We do math on 32 bit so we can ignore carry, and then sign extended
            uoffT = EXTEND64((DWORD)uoffRet + *( (UNALIGNED DWORD *) &code[3] ));

            //
            // See if it calls the function directly, or into the function
            //
            if (( uoffT >= funcAddr) && ( uoffT < (funcAddr + funcSize) ) ) {
                WDB((1, "        found function, use %X\n", (ULONG)uoffStack));
                return uoffStack;
            }


            while ( cJmpChain < MAX_JMP_CHAIN ) {

                if (!ReadMemory(Process,
                                uoffT,
                                jmpBuffer,
                                sizeof(jmpBuffer),
                                &cb)) {
                    break;
                }

                if (cb != sizeof(jmpBuffer)) {
                    break;
                }

                //
                // Now we are going to check if it is a call to a JMP, that may
                // jump to the function
                //
                // If it is a relative JMP then calculate the destination
                // and save it in uoffT.  If it is an indirect JMP then read
                // the destination from where the JMP is inderecting through.
                //
                if ( *(LPBYTE)lpwJmp == 0xE9 ) {

                    // We do math on 32 bit so we can ignore carry, and then
                    // sign extended
                    uoffT = EXTEND64 ((ULONG)uoffT +
                            *(UNALIGNED DWORD *)( jmpBuffer + sizeof(BYTE) ) + 5);

                } else if ( *lpwJmp == 0x25FF ) {

                    if ((!ReadMemory(Process,
                                     EXTEND64 (
                                         *(UNALIGNED DWORD *)
                                         ((LPBYTE)lpwJmp+sizeof(WORD))),
                                     &uoffT,
                                     sizeof(DWORD),
                                     &cb)) || (cb != sizeof(DWORD))) {
                        uoffT = 0;
                        break;
                    }
                    uoffT = EXTEND64(uoffT);

                } else {
                    break;
                }

                //
                // If the destination is to the FPO function then we have
                // found the return address and thus the vEBP
                //
                if ( uoffT == funcAddr ) {
                    WDB((1, "        exact function, use %X\n",
                         (ULONG)uoffStack));
                    return uoffStack;
                }

                cJmpChain++;
            }

            //
            // We cache away the first 0xE8 call or 0xE9 jmp that we find in
            // the event we cant find anything else that looks like a return
            // address.  This is meant to protect us in the tail recursion case.
            //
            if ( !uoffBestGuess ) {
                uoffBestGuess = uoffStack;
            }
        }


        //
        // Now loop backward through the bytes read checking for a multi
        // byte call type from Grp5.  If we find an 0xFF then we need to
        // check the byte after that to make sure that the nnn bits of
        // the mod/rm byte tell us that it is a call.  It it is a call
        // then we will assume that this one called us because we can
        // no longer accurately determine for sure whether this did
        // in fact call the FPO function.  Since 0xFF calls are a guess
        // as well we will not check them if we already have an earlier guess.
        // It is more likely that the first 0xE8 called the function than
        // something higher up the stack that might be an 0xFF call.
        //
        if ( !uoffBestGuess && cBytes >= MIN_CALL ) {

            cbLimit = MAX_CALL - (INT)cBytes;

            for (cbIndex = MAX_CALL - MIN_CALL;
                 cbIndex >= cbLimit;  //MAX_CALL - (INT)cBytes;
                 cbIndex--) {

                if ( ( code [ cbIndex ] == 0xFF ) &&
                    ( ( code [ cbIndex + 1 ] & 0x30 ) == 0x10 )){

                    WDB((1, "        found call, use %X\n", (ULONG)uoffStack));
                    return uoffStack;

                }
            }
        }
    }

    //
    // we found nothing that was 100% definite so we'll return the best guess
    //
    WDB((1, "        best guess is %X\n", (ULONG)uoffBestGuess));
    return uoffBestGuess;
}

#define MRM_MOD(Mrm)   (((Mrm) >> 6) & 3)
#define MRM_REGOP(Mrm) (((Mrm) >> 3) & 7)
#define MRM_RM(Mrm)    (((Mrm) >> 0) & 7)

#define SIB_SCALE(Sib) (((Sib) >> 6) & 3)
#define SIB_INDEX(Sib) (((Sib) >> 3) & 7)
#define SIB_BASE(Sib)  (((Sib) >> 0) & 7)

DWORD
ModRmLen(BYTE ModRm)
{
    BYTE Mod, Rm;

    Mod = MRM_MOD(ModRm);
    Rm = MRM_RM(ModRm);
    switch(Mod)
    {
    case 0:
        if (Rm == 4)
        {
            return 1;
        }
        else if (Rm == 5)
        {
            return 4;
        }
        break;
    case 1:
        return 1 + (Rm == 4 ? 1 : 0);
    case 2:
        return 4 + (Rm == 4 ? 1 : 0);
    }

    // No extra bytes.
    return 0;
}

BOOL
GetEspRelModRm(BYTE* CodeMrm, ULONG Esp, PULONG EspRel)
{
    BYTE Mrm, Sib;

    Mrm = CodeMrm[0];

    if (MRM_MOD(Mrm) == 3)
    {
        // Register-only form.  Only handle
        // the case of an ESP reference.
        if (MRM_RM(Mrm) == 4)
        {
            *EspRel = Esp;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    // Look for any ESP-relative R/M.
    if (MRM_RM(Mrm) != 4)
    {
        return FALSE;
    }

    Sib = CodeMrm[1];

    // Only simple displacements from ESP are supported.
    if (SIB_INDEX(Sib) != 4 ||
        SIB_BASE(Sib) != 4)
    {
        return FALSE;
    }

    switch(MRM_MOD(Mrm))
    {
    case 0:
        // [esp]
        *EspRel = Esp;
        break;
    case 1:
        // disp8[esp]
        *EspRel = Esp + (signed char)CodeMrm[2];
        break;
    case 2:
        // disp32[esp]
        *EspRel = Esp + *(ULONG UNALIGNED *)&CodeMrm[2];
        break;
    default:
        // Should never get here, MOD == 3 is handled above.
        return FALSE;
    }

    return TRUE;
}

DWORD64
SearchForFramePointer(
    HANDLE                            Process,
    DWORD64                           RegSaveAddr,
    DWORD64                           RetEspAddr,
    DWORD                             NumRegs,
    DWORD64                           FuncAddr,
    DWORD                             FuncSize,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    BYTE Code[MAX_FUNC_PROLOGUE];
    DWORD CodeLen;
    DWORD i;
    DWORD Depth;
    DWORD64 DefAddr;
    DWORD Esp = (ULONG)RetEspAddr;
    BOOL EspValid = TRUE;
    BYTE Mrm;

    WDB((1, "      SearchForFramePointer: regs %X, ret ESP %X, numregs %d\n",
         (ULONG)RegSaveAddr, (ULONG)RetEspAddr, NumRegs));

    // RetEspAddr is the first address beyond the end of
    // the frame, so it hopefully is the address of the return
    // address for the call.  We don't really care about that
    // and are more interested in what the first push slot might
    // be, which is directly beneath the return address.
    RetEspAddr -= STACK_SIZE;

    //
    // The compiler does not push registers in a consistent
    // order and FPO information only indicates the total
    // number of registers pushed, not their order.  This
    // function searches the stack locations where registers
    // are stored and tries to find which one is EBP.
    // It searches the function code for pushes and
    // tries to use that information to help the stack
    // analysis.
    //
    // If this routine fails it just returns the base
    // of the register save area.  If the routine pushes
    // no registers, return the first possible push slot.
    //

    DefAddr = NumRegs ? RegSaveAddr : RetEspAddr;

    // Read the beginning of the function for code analysis.
    if (sizeof(Code) < FuncSize)
    {
        CodeLen = sizeof(Code);
    }
    else
    {
        CodeLen = FuncSize;
    }
    if (!ReadMemory(Process, FuncAddr, Code, CodeLen, &CodeLen))
    {
        WDB((1, "        unable to read code, use %X\n", (ULONG)DefAddr));
        return DefAddr;
    }

    // Scan the code for normal prologue operations like
    // sub esp, push reg and mov reg.  This code only
    // handles a very limited set of instructions.

    Depth = 0;
    for (i = 0; i < CodeLen; i++)
    {
        WDB((4, "        %08X: Opcode %02X - ",
             (ULONG)FuncAddr + i, Code[i]));

        if (Code[i] == 0x83 && i + 3 <= CodeLen && Code[i + 1] == 0xec)
        {
            // sub esp, signed imm8
            Esp -= (signed char)Code[i + 2];
            WDB((4 | SDB_NO_PREFIX, "sub esp,0x%x, ESP %X (%s)\n",
                 (signed char)Code[i + 2], Esp,
                 EspValid ? "valid" : "invalid"));
            // Loop increment adds one.
            i += 2;
        }
        else if (Code[i] == 0x81 && i + 6 <= CodeLen && Code[i + 1] == 0xec)
        {
            // sub esp, imm32
            Esp -= *(ULONG UNALIGNED *)&Code[i + 2];
            WDB((4 | SDB_NO_PREFIX, "sub esp,0x%x, ESP %X (%s)\n",
                 *(ULONG UNALIGNED *)&Code[i + 2], Esp,
                 EspValid ? "valid" : "invalid"));
            // Loop increment adds one.
            i += 5;
        }
        else if (Code[i] == 0x89 && i + 2 <= CodeLen)
        {
            // mov r/m32, reg32
            Mrm = Code[i + 1];
            switch(MRM_REGOP(Mrm))
            {
            case 5:
                if (GetEspRelModRm(Code + 1, Esp, &Esp))
                {
                    // mov [esp+offs], ebp
                    WDB((4 | SDB_NO_PREFIX, "mov [%X],ebp\n", Esp));
                    WDB((1, "        moved ebp to stack at %X\n", Esp));
                    return EXTEND64(Esp);
                }
                break;
            }

            WDB((4 | SDB_NO_PREFIX, "mov r/m32,reg32, skipped\n"));
            i += ModRmLen(Mrm) + 1;
        }
        else if (Code[i] == 0x8b && i + 2 <= CodeLen)
        {
            // mov reg32, r/m32
            Mrm = Code[i + 1];
            if (MRM_REGOP(Mrm) == 4)
            {
                // ESP was modified in a way we can't emulate.
                WDB((4 | SDB_NO_PREFIX, "ESP lost\n"));
                EspValid = FALSE;
            }
            else
            {
                WDB((4 | SDB_NO_PREFIX, "mov reg32,r/m32, skipped\n"));
            }

            i += ModRmLen(Mrm) + 1;
        }
        else if (Code[i] == 0x8d && i + 2 <= CodeLen)
        {
            // lea reg32, r/m32
            Mrm = Code[i + 1];
            switch(MRM_REGOP(Mrm))
            {
            case 4:
                if (GetEspRelModRm(Code + 1, Esp, &Esp))
                {
                    WDB((4 | SDB_NO_PREFIX, "lea esp,[%X]\n", Esp));
                }
                else
                {
                    // ESP was modified in a way we can't emulate.
                    WDB((4 | SDB_NO_PREFIX, "ESP lost\n"));
                    EspValid = FALSE;
                }
                break;
            default:
                WDB((4 | SDB_NO_PREFIX, "lea reg32,r/m32, skipped\n"));
                break;
            }

            i += ModRmLen(Mrm) + 1;
        }
        else if (Code[i] >= 0x50 && Code[i] <= 0x57)
        {
            // push rd
            Esp -= STACK_SIZE;
            WDB((4 | SDB_NO_PREFIX, "push <reg>, ESP %X (%s)\n", Esp,
                 EspValid ? "valid" : "invalid"));

            if (Code[i] == 0x55)
            {
                // push ebp
                // Found it.  If we trust the ESP we've
                // been tracking just return it.
                // Otherwise, if it's the first instruction
                // of the routine then we should return the
                // frame address, otherwise return the
                // proper location in the register store area.
                // If there is no register store area then
                // just return the default address.
                if (EspValid)
                {
                    WDB((1, "        push ebp at esp %X\n", Esp));
                    return EXTEND64(Esp);
                }
                else if (!NumRegs)
                {
                    WDB((1, "        found ebp but no regarea, return %X\n",
                         (ULONG)DefAddr));
                    return DefAddr;
                }
                else
                {
                    RegSaveAddr += (NumRegs - Depth - 1) * STACK_SIZE;
                    WDB((1, "        guess ebp at %X\n", (ULONG)RegSaveAddr));
                    return RegSaveAddr;
                }
            }

            Depth++;
        }
        else
        {
            // Unhandled code, fail.
            WDB((4 | SDB_NO_PREFIX, "unknown\n"));
            WDB((1, "        unknown code sequence %02X at %X\n",
                 Code[i], (ULONG)FuncAddr + i));
            return DefAddr;
        }
    }

    // Didn't find a push ebp, fail.
    WDB((1, "        no ebp, use %X\n", (ULONG)DefAddr));
    return DefAddr;
}


BOOL
GetFpoFrameBase(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PFPO_DATA                         pFpoData,
    PFPO_DATA                         PreviousFpoData,
    BOOL                              fFirstFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    DWORD          Addr32;
    X86_KTRAP_FRAME    TrapFrame;
    DWORD64        OldFrameAddr;
    DWORD64        FrameAddr;
    DWORD64        StackAddr;
    DWORD64        ModuleBase;
    DWORD64        FuncAddr;
    DWORD          cb;
    DWORD64        StoredEbp;

    //
    // calculate the address of the beginning of the function
    //
    ModuleBase = GetModuleBase( Process, StackFrame->AddrPC.Offset );
    if (!ModuleBase) {
        return FALSE;
    }

    FuncAddr = ModuleBase+pFpoData->ulOffStart;

    WDB((1, "    GetFpoFrameBase: PC %X, Func %X, first %d, FPO %p [%d,%d,%d]\n",
         (ULONG)StackFrame->AddrPC.Offset, (ULONG)FuncAddr,
         fFirstFrame, pFpoData, pFpoData->cdwParams, pFpoData->cdwLocals,
         pFpoData->cbRegs));

    //
    // If this isn't the first/current frame then we can add back the count
    // bytes of locals and register pushed before beginning to search for
    // EBP.  If we are beyond prolog we can add back the count bytes of locals
    // and registers pushed as well.  If it is the first frame and EIP is
    // greater than the address of the function then the SUB for locals has
    // been done so we can add them back before beginning the search.  If we
    // are right on the function then we will need to start our search at ESP.
    //

    if ( !fFirstFrame ) {

        OldFrameAddr = StackFrame->AddrFrame.Offset;
        FrameAddr = 0;

        //
        // if this is a non-fpo or trap frame, get the frame base now:
        //

        if (pFpoData->cbFrame != FRAME_FPO) {

            if (!PreviousFpoData || PreviousFpoData->cbFrame == FRAME_NONFPO) {

                //
                // previous frame base is ebp and points to this frame's ebp
                //
                if (!ReadMemory(Process,
                                OldFrameAddr,
                                &Addr32,
                                sizeof(DWORD),
                                &cb) ||
                    cb != sizeof(DWORD)) {
                    FrameAddr = 0;
                } else {
                    FrameAddr = (DWORD64)(LONG64)(LONG)Addr32;
                }
            }

            //
            // if that didn't work, try for a saved ebp
            //
            if (!FrameAddr && IS_EBP_SAVED(StackFrame) &&
                (OldFrameAddr <= SAVE_EBP(StackFrame))) {

                FrameAddr = SAVE_EBP(StackFrame);
                WDB((1, "      non-FPO using %X\n", (ULONG)FrameAddr));

            }

            //
            // this is not an FPO frame, so the saved EBP can only have come
            // from this or a lower frame.
            //

            SAVE_EBP(StackFrame) = 0;
        }

        //
        // still no frame base - either this frame is fpo, or we couldn't
        // follow the ebp chain.
        //

        if (FrameAddr == 0) {
            FrameAddr = OldFrameAddr;

            //
            // skip over return address from prev frame
            //
            FrameAddr += FRAME_SIZE;

            //
            // skip over this frame's locals and saved regs
            //
            FrameAddr += ( pFpoData->cdwLocals * STACK_SIZE );
            FrameAddr += ( pFpoData->cbRegs * STACK_SIZE );

            if (PreviousFpoData) {
                //
                // if the previous frame had an fpo record, we can account
                // for its parameters
                //
                FrameAddr += PreviousFpoData->cdwParams * STACK_SIZE;

            }
        }

        //
        // if this is an FPO frame
        // and the previous frame was non-fpo,
        // and this frame passed the inherited ebp to the previous frame,
        //  save its ebp
        //
        // (if this frame used ebp, SAVE_EBP will be set after verifying
        // the frame base)
        //
        if (pFpoData->cbFrame == FRAME_FPO &&
            (!PreviousFpoData || PreviousFpoData->cbFrame == FRAME_NONFPO) &&
            !pFpoData->fUseBP) {

            SAVE_EBP(StackFrame) = 0;

            if (ReadMemory(Process,
                           OldFrameAddr,
                           &Addr32,
                           sizeof(DWORD),
                           &cb) &&
                cb == sizeof(DWORD)) {

                SAVE_EBP(StackFrame) = (DWORD64)(LONG64)(LONG)Addr32;
                WDB((1, "      pass-through FP %X\n", Addr32));
            } else {
                WDB((1, "      clear ebp\n"));
            }
        }


    } else {

        OldFrameAddr = StackFrame->AddrFrame.Offset;
        if (pFpoData->cbFrame == FRAME_FPO && !pFpoData->fUseBP) {
            //
            // this frame didn't use EBP, so it actually belongs
            // to a non-FPO frame further up the stack.  Stash
            // it in the save area for the next frame.
            //
            SAVE_EBP(StackFrame) = StackFrame->AddrFrame.Offset;
            WDB((1, "      first non-ebp save %X\n", (ULONG)SAVE_EBP(StackFrame)));
        }

        if (pFpoData->cbFrame == FRAME_TRAP ||
            pFpoData->cbFrame == FRAME_TSS) {

            FrameAddr = StackFrame->AddrFrame.Offset;

        } else if (StackFrame->AddrPC.Offset == FuncAddr) {

            FrameAddr = StackFrame->AddrStack.Offset;

        } else if (StackFrame->AddrPC.Offset >= FuncAddr+pFpoData->cbProlog) {

            FrameAddr = StackFrame->AddrStack.Offset +
                        ( pFpoData->cdwLocals * STACK_SIZE ) +
                        ( pFpoData->cbRegs * STACK_SIZE );

        } else {

            FrameAddr = StackFrame->AddrStack.Offset +
                        ( pFpoData->cdwLocals * STACK_SIZE );

        }

    }


    if (pFpoData->cbFrame == FRAME_TRAP) {

        //
        // read a kernel mode trap frame from the stack
        //

        if (!ReadTrapFrame( Process,
                            FrameAddr,
                            &TrapFrame,
                            ReadMemory )) {
            return FALSE;
        }

        SAVE_TRAP(StackFrame) = FrameAddr;
        TRAP_EDITED(StackFrame) = TrapFrame.SegCs & X86_FRAME_EDITED;

        StackFrame->AddrReturn.Offset = (DWORD64)(LONG64)(LONG)(TrapFrame.Eip);
        StackFrame->AddrReturn.Mode = AddrModeFlat;
        StackFrame->AddrReturn.Segment = 0;

        return TRUE;
    }

    if (pFpoData->cbFrame == FRAME_TSS) {

        //
        // translate a tss to a kernel mode trap frame
        //

        StackAddr = FrameAddr;

        if (!TaskGate2TrapFrame( Process, X86_KGDT_TSS, &TrapFrame,
                                 &StackAddr, ReadMemory )) {
            return FALSE;
        }

        TRAP_TSS(StackFrame) = X86_KGDT_TSS;
        SAVE_TRAP(StackFrame) = StackAddr;

        StackFrame->AddrReturn.Offset = (DWORD64)(LONG64)(LONG)(TrapFrame.Eip);
        StackFrame->AddrReturn.Mode = AddrModeFlat;
        StackFrame->AddrReturn.Segment = 0;

        return TRUE;
    }

    if ((pFpoData->cbFrame != FRAME_FPO) &&
        (pFpoData->cbFrame != FRAME_NONFPO) ) {
        //
        // we either have a compiler or linker problem, or possibly
        // just simple data corruption.
        //
        return FALSE;
    }

    //
    // go look for a return address.  this is done because, even though
    // we have subtracted all that we can from the frame pointer it is
    // possible that there is other unknown data on the stack.  by
    // searching for the return address we are able to find the base of
    // the fpo frame.
    //
    FrameAddr = SearchForReturnAddress( Process,
                                        FrameAddr,
                                        FuncAddr,
                                        pFpoData->cbProcSize,
                                        ReadMemory,
                                        GetModuleBase,
                                        PreviousFpoData != NULL
                                        );
    if (!FrameAddr) {
        return FALSE;
    }

    if (pFpoData->fUseBP && pFpoData->cbFrame == FRAME_FPO) {

        //
        // this function used ebp as a general purpose register, but
        // before doing so it saved ebp on the stack.
        //
        // we must retrieve this ebp and save it for possible later
        // use if we encounter a non-fpo frame
        //

        if (fFirstFrame && StackFrame->AddrPC.Offset < FuncAddr+pFpoData->cbProlog) {

            SAVE_EBP(StackFrame) = OldFrameAddr;
            WDB((1, "      first use save FP %X\n", (ULONG)OldFrameAddr));

        } else {

            SAVE_EBP(StackFrame) = 0;

            // FPO information doesn't indicate which of the saved
            // registers is EBP and the compiler doesn't push in a
            // consistent way.  Scan the register slots of the
            // stack for something that looks OK.
            StackAddr = FrameAddr -
                ( ( pFpoData->cbRegs + pFpoData->cdwLocals ) * STACK_SIZE );
            StackAddr = SearchForFramePointer( Process,
                                               StackAddr,
                                               FrameAddr,
                                               pFpoData->cbRegs,
                                               FuncAddr,
                                               pFpoData->cbProcSize,
                                               ReadMemory
                                               );
            if (StackAddr &&
                ReadMemory(Process,
                           StackAddr,
                           &Addr32,
                           sizeof(DWORD),
                           &cb) &&
                cb == sizeof(DWORD)) {

                SAVE_EBP(StackFrame) = (DWORD64)(LONG64)(LONG)Addr32;
                WDB((1, "      use search save %X from %X\n", Addr32,
                     (ULONG)StackAddr));
            } else {
                WDB((1, "      use clear ebp\n"));
            }
        }
    }

    //
    // subtract the size for an ebp register if one had
    // been pushed.  this is done because the frames that
    // are virtualized need to appear as close to a real frame
    // as possible.
    //

    StackFrame->AddrFrame.Offset = FrameAddr - STACK_SIZE;

    return TRUE;
}


BOOL
ReadTrapFrame(
    HANDLE                            Process,
    DWORD64                           TrapFrameAddress,
    PX86_KTRAP_FRAME                  TrapFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    DWORD cb;

    if (!ReadMemory(Process,
                    TrapFrameAddress,
                    TrapFrame,
                    sizeof(*TrapFrame),
                    &cb)) {
        return FALSE;
    }

    if (cb < sizeof(*TrapFrame)) {
        if (cb < sizeof(*TrapFrame) - 20) {
            //
            // shorter then the smallest possible frame type
            //
            return FALSE;
        }

        if ((TrapFrame->SegCs & 1) &&  cb < sizeof(*TrapFrame) - 16 ) {
            //
            // too small for inter-ring frame
            //
            return FALSE;
        }

        if (TrapFrame->EFlags & X86_EFLAGS_V86_MASK) {
            //
            // too small for V86 frame
            //
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
GetSelector(
    HANDLE                            Process,
    USHORT                            Processor,
    PX86_DESCRIPTOR_TABLE_ENTRY       pDescriptorTableEntry,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    ULONG_PTR   Address;
    PVOID       TableBase;
    USHORT      TableLimit;
    ULONG       Index;
    X86_LDT_ENTRY   Descriptor;
    ULONG       bytesread;


    //
    // Fetch the address and limit of the GDT
    //
    Address = (ULONG_PTR)&(((PX86_KSPECIAL_REGISTERS)0)->Gdtr.Base);
    ReadMemory( Process, Address, &TableBase, sizeof(TableBase), (LPDWORD)-1  );
    Address = (ULONG_PTR)&(((PX86_KSPECIAL_REGISTERS)0)->Gdtr.Limit);
    ReadMemory( Process, Address, &TableLimit, sizeof(TableLimit),  (LPDWORD)-1  );

    //
    // Find out whether this is a GDT or LDT selector
    //
    if (pDescriptorTableEntry->Selector & 0x4) {

        //
        // This is an LDT selector, so we reload the TableBase and TableLimit
        // with the LDT's Base & Limit by loading the descriptor for the
        // LDT selector.
        //

        if (!ReadMemory(Process,
                        (ULONG64)TableBase+X86_KGDT_LDT,
                        &Descriptor,
                        sizeof(Descriptor),
                        &bytesread)) {
            return FALSE;
        }

        TableBase = (PVOID)(DWORD_PTR)((ULONG)Descriptor.BaseLow +    // Sundown: zero-extension from ULONG to PVOID.
                    ((ULONG)Descriptor.HighWord.Bits.BaseMid << 16) +
                    ((ULONG)Descriptor.HighWord.Bytes.BaseHi << 24));

        TableLimit = Descriptor.LimitLow;  // LDT can't be > 64k

        if(Descriptor.HighWord.Bits.Granularity) {

            //
            //  I suppose it's possible, to have an
            //  LDT with page granularity.
            //
            TableLimit <<= X86_PAGE_SHIFT;
        }
    }

    Index = (USHORT)(pDescriptorTableEntry->Selector) & ~0x7;
                                                    // Irrelevant bits
    //
    // Check to make sure that the selector is within the table bounds
    //
    if (Index >= TableLimit) {

        //
        // Selector is out of table's bounds
        //

        return FALSE;
    }

    if (!ReadMemory(Process,
                    (ULONG64)TableBase+Index,
                    &(pDescriptorTableEntry->Descriptor),
                    sizeof(pDescriptorTableEntry->Descriptor),
                    &bytesread)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
TaskGate2TrapFrame(
    HANDLE                            Process,
    USHORT                            TaskRegister,
    PX86_KTRAP_FRAME                  TrapFrame,
    PULONG64                          off,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    X86_DESCRIPTOR_TABLE_ENTRY desc;
    ULONG                    bytesread;
    struct  {
        ULONG   r1[8];
        ULONG   Eip;
        ULONG   EFlags;
        ULONG   Eax;
        ULONG   Ecx;
        ULONG   Edx;
        ULONG   Ebx;
        ULONG   Esp;
        ULONG   Ebp;
        ULONG   Esi;
        ULONG   Edi;
        ULONG   Es;
        ULONG   Cs;
        ULONG   Ss;
        ULONG   Ds;
        ULONG   Fs;
        ULONG   Gs;
    } TaskState;


    //
    // Get the task register
    //

    desc.Selector = TaskRegister;
    if (!GetSelector(Process, 0, &desc, ReadMemory)) {
        return FALSE;
    }

    if (desc.Descriptor.HighWord.Bits.Type != 9  &&
        desc.Descriptor.HighWord.Bits.Type != 0xb) {
        //
        // not a 32bit task descriptor
        //
        return FALSE;
    }

    //
    // Read in Task State Segment
    //

    *off = ((ULONG)desc.Descriptor.BaseLow +
           ((ULONG)desc.Descriptor.HighWord.Bytes.BaseMid << 16) +
           ((ULONG)desc.Descriptor.HighWord.Bytes.BaseHi  << 24) );

    if (!ReadMemory(Process,
                    EXTEND64(*off),
                    &TaskState,
                    sizeof(TaskState),
                    &bytesread)) {
        return FALSE;
    }

    //
    // Move fields from Task State Segment to TrapFrame
    //

    ZeroMemory( TrapFrame, sizeof(*TrapFrame) );

    TrapFrame->Eip    = TaskState.Eip;
    TrapFrame->EFlags = TaskState.EFlags;
    TrapFrame->Eax    = TaskState.Eax;
    TrapFrame->Ecx    = TaskState.Ecx;
    TrapFrame->Edx    = TaskState.Edx;
    TrapFrame->Ebx    = TaskState.Ebx;
    TrapFrame->Ebp    = TaskState.Ebp;
    TrapFrame->Esi    = TaskState.Esi;
    TrapFrame->Edi    = TaskState.Edi;
    TrapFrame->SegEs  = TaskState.Es;
    TrapFrame->SegCs  = TaskState.Cs;
    TrapFrame->SegDs  = TaskState.Ds;
    TrapFrame->SegFs  = TaskState.Fs;
    TrapFrame->SegGs  = TaskState.Gs;
    TrapFrame->HardwareEsp = TaskState.Esp;
    TrapFrame->HardwareSegSs = TaskState.Ss;

    return TRUE;
}

BOOL
ProcessTrapFrame(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PFPO_DATA                         pFpoData,
    PFPO_DATA                         PreviousFpoData,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess
    )
{
    X86_KTRAP_FRAME TrapFrame;
    DWORD64         StackAddr;

    if (PreviousFpoData->cbFrame == FRAME_TSS) {
        StackAddr = SAVE_TRAP(StackFrame);
        TaskGate2TrapFrame( Process, X86_KGDT_TSS, &TrapFrame, &StackAddr, ReadMemory );
    } else {
        if (!ReadTrapFrame( Process,
                            SAVE_TRAP(StackFrame),
                            &TrapFrame,
                            ReadMemory)) {
            SAVE_TRAP(StackFrame) = 0;
            return FALSE;
        }
    }

    pFpoData = (PFPO_DATA)
               FunctionTableAccess(Process,
                                   (DWORD64)(LONG64)(LONG)TrapFrame.Eip);
#if 0
    // Remove this check since we are not using pFpoData anyway
    if (!pFpoData) {
        StackFrame->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.Ebp;
        SAVE_EBP(StackFrame) = 0;
    } else
#endif //0
    {
        if ((TrapFrame.SegCs & X86_MODE_MASK) ||
            (TrapFrame.EFlags & X86_EFLAGS_V86_MASK)) {
            //
            // User-mode frame, real value of Esp is in HardwareEsp
            //
            StackFrame->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)(TrapFrame.HardwareEsp - STACK_SIZE);
            StackFrame->AddrStack.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.HardwareEsp;

        } else {
            //
            // We ignore if Esp has been edited for now, and we will print a
            // separate line indicating this later.
            //
            // Calculate kernel Esp
            //

            if (PreviousFpoData->cbFrame == FRAME_TRAP) {
                //
                // plain trap frame
                //
                if ((TrapFrame.SegCs & X86_FRAME_EDITED) == 0) {
                    StackFrame->AddrStack.Offset = EXTEND64(TrapFrame.TempEsp);
                } else {
                    StackFrame->AddrStack.Offset = EXTEND64(SAVE_TRAP(StackFrame))+
                        FIELD_OFFSET(X86_KTRAP_FRAME, HardwareEsp);
                }
            } else {
                //
                // tss converted to trap frame
                //
                StackFrame->AddrStack.Offset = EXTEND64(TrapFrame.HardwareEsp);
            }
        }
    }

    StackFrame->AddrFrame.Offset = EXTEND64(TrapFrame.Ebp);
    StackFrame->AddrPC.Offset = EXTEND64(TrapFrame.Eip);

    SAVE_TRAP(StackFrame) = 0;
    StackFrame->FuncTableEntry = pFpoData;

    return TRUE;
}

BOOL
IsFarCall(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    BOOL                              *Ok,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL       fFar = FALSE;
    ULONG      cb;
    ADDRESS64  Addr;

    *Ok = TRUE;

    if (StackFrame->AddrFrame.Mode == AddrModeFlat) {
        DWORD      dwStk[ 3 ];
        //
        // If we are working with 32 bit offset stack pointers, we
        //      will say that the return address if far if the address
        //      treated as a FAR pointer makes any sense,  if not then
        //      it must be a near return
        //

        if (StackFrame->AddrFrame.Offset &&
            DoMemoryReadAll( &StackFrame->AddrFrame, dwStk, sizeof(dwStk) )) {
            //
            //  See if segment makes sense
            //

            Addr.Offset   = (DWORD64)(LONG64)(LONG)(dwStk[1]);
            Addr.Segment  = (WORD)dwStk[2];
            Addr.Mode = AddrModeFlat;

            if (TranslateAddress( Process, Thread, &Addr ) && Addr.Offset) {
                fFar = TRUE;
            }
        } else {
            *Ok = FALSE;
        }
    } else {
        WORD       wStk[ 3 ];
        //
        // For 16 bit (i.e. windows WOW code) we do the following tests
        //      to check to see if an address is a far return value.
        //
        //      1.  if the saved BP register is odd then it is a far
        //              return values
        //      2.  if the address treated as a far return value makes sense
        //              then it is a far return value
        //      3.  else it is a near return value
        //

        if (StackFrame->AddrFrame.Offset &&
            DoMemoryReadAll( &StackFrame->AddrFrame, wStk, 6 )) {

            if ( wStk[0] & 0x0001 ) {
                fFar = TRUE;
            } else {

                //
                //  See if segment makes sense
                //

                Addr.Offset   = wStk[1];
                Addr.Segment  = wStk[2];
                Addr.Mode = AddrModeFlat;

                if (TranslateAddress( Process, Thread, &Addr  ) && Addr.Offset) {
                    fFar = TRUE;
                }
            }
        } else {
            *Ok = FALSE;
        }
    }
    return fFar;
}


BOOL
SetNonOff32FrameAddress(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL    fFar;
    WORD    Stk[ 3 ];
    ULONG   cb;
    BOOL    Ok;

    fFar = IsFarCall( Process, Thread, StackFrame, &Ok, ReadMemory, TranslateAddress );

    if (!Ok) {
        return FALSE;
    }

    if (!DoMemoryReadAll( &StackFrame->AddrFrame, Stk, (DWORD)(fFar ? FRAME_SIZE1632 : FRAME_SIZE16) )) {
        return FALSE;
    }

    if (IS_EBP_SAVED(StackFrame) && (SAVE_EBP(StackFrame) > 0)) {
        StackFrame->AddrFrame.Offset = SAVE_EBP(StackFrame) & 0xffff;
        StackFrame->AddrPC.Offset = Stk[1];
        if (fFar) {
            StackFrame->AddrPC.Segment = Stk[2];
        }
        SAVE_EBP(StackFrame) = 0;
    } else {
        if (Stk[1] == 0) {
            return FALSE;
        } else {
            StackFrame->AddrFrame.Offset = Stk[0];
            StackFrame->AddrFrame.Offset &= 0xFFFFFFFE;
            StackFrame->AddrPC.Offset = Stk[1];
            if (fFar) {
                StackFrame->AddrPC.Segment = Stk[2];
            }
        }
    }

    return TRUE;
}

VOID
X86ReadFunctionParameters(
    HANDLE Process,
    ULONG64 Offset,
    LPSTACKFRAME64 Frame,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    )
{
    DWORD Params[4];
    DWORD Done;

    if (!ReadMemory(Process, Offset, Params, sizeof(Params), &Done)) {
        Done = 0;
    }

    if (Done < sizeof(Params)) {
        ZeroMemory((PUCHAR)Params + Done, sizeof(Params) - Done);
    }

    Frame->Params[0] = (DWORD64)(LONG64)(LONG)(Params[0]);
    Frame->Params[1] = (DWORD64)(LONG64)(LONG)(Params[1]);
    Frame->Params[2] = (DWORD64)(LONG64)(LONG)(Params[2]);
    Frame->Params[3] = (DWORD64)(LONG64)(LONG)(Params[3]);
}

VOID
GetFunctionParameters(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL                Ok;
    ADDRESS64           ParmsAddr;

    ParmsAddr = StackFrame->AddrFrame;

    //
    // calculate the frame size
    //
    if (StackFrame->AddrPC.Mode == AddrModeFlat) {

        ParmsAddr.Offset += FRAME_SIZE;

    } else
    if ( IsFarCall( Process, Thread, StackFrame, &Ok,
                    ReadMemory, TranslateAddress ) ) {

        StackFrame->Far = TRUE;
        ParmsAddr.Offset += FRAME_SIZE1632;

    } else {

        StackFrame->Far = FALSE;
        ParmsAddr.Offset += STACK_SIZE;

    }

    //
    // read the memory
    //

    if (ParmsAddr.Mode != AddrModeFlat) {
        TranslateAddress( Process, Thread, &ParmsAddr );
    }

    X86ReadFunctionParameters(Process, ParmsAddr.Offset, StackFrame,
                              ReadMemory);
}

VOID
GetReturnAddress(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess
    )
{
    ULONG               cb;
    DWORD               stack[1];


    if (SAVE_TRAP(StackFrame)) {
        //
        // if a trap frame was encountered then
        // the return address was already calculated
        //
        return;
    }

    WDB((1, "    GetReturnAddress: SP %X, FP %X\n",
         (ULONG)StackFrame->AddrStack.Offset,
         (ULONG)StackFrame->AddrFrame.Offset));

    if (StackFrame->AddrPC.Mode == AddrModeFlat) {

        ULONG64 CallOffset;
        PFPO_DATA CallFpo;
        ADDRESS64 FrameRet;
        FPO_DATA SaveCallFpo;
        PFPO_DATA RetFpo;

        //
        // read the frame from the process's memory
        //
        FrameRet = StackFrame->AddrFrame;
        FrameRet.Offset += STACK_SIZE;
        FrameRet.Offset = EXTEND64(FrameRet.Offset);
        if (!DoMemoryRead( &FrameRet, stack, STACK_SIZE, &cb ) ||
            cb < STACK_SIZE) {
            //
            // if we could not read the memory then set
            // the return address to zero so that the stack trace
            // will terminate
            //

            stack[0] = 0;

        }

        StackFrame->AddrReturn.Offset = (DWORD64)(LONG64)(LONG)(stack[0]);
        WDB((1, "    read %X\n", stack[0]));

        //
        // Calls of __declspec(noreturn) functions may not have any
        // code after them to return to since the compiler knows
        // that the function will not return.  This can confuse
        // stack traces because the return address will lie outside
        // of the function's address range and FPO data will not
        // be looked up correctly.  Check and see if the return
        // address falls outside of the calling function and, if so,
        // adjust the return address back by one byte.  It'd be
        // better to adjust it back to the call itself so that
        // the return address points to valid code but
        // backing up in X86 assembly is more or less impossible.
        //

        CallOffset = StackFrame->AddrReturn.Offset - 1;
        CallFpo = (PFPO_DATA)FunctionTableAccess(Process, CallOffset);
        if (CallFpo != NULL) {
            SaveCallFpo = *CallFpo;
        }
        RetFpo = (PFPO_DATA)
            FunctionTableAccess(Process, StackFrame->AddrReturn.Offset);
        if (CallFpo != NULL) {
            if (RetFpo == NULL ||
                memcmp(&SaveCallFpo, RetFpo, sizeof(SaveCallFpo))) {
                StackFrame->AddrReturn.Offset = CallOffset;
            }
        } else if (RetFpo != NULL) {
            StackFrame->AddrReturn.Offset = CallOffset;
        }

    } else {

        StackFrame->AddrReturn.Offset = StackFrame->AddrPC.Offset;
        StackFrame->AddrReturn.Segment = StackFrame->AddrPC.Segment;

    }
}

BOOL
WalkX86_Fpo_Fpo(
    HANDLE                            Process,
    HANDLE                            Thread,
    PFPO_DATA                         pFpoData,
    PFPO_DATA                         PreviousFpoData,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL rval;

    WDB((1, "  WalkFF:\n"));

    rval = GetFpoFrameBase( Process,
                            StackFrame,
                            pFpoData,
                            PreviousFpoData,
                            FALSE,
                            ReadMemory,
                            GetModuleBase );

    StackFrame->FuncTableEntry = pFpoData;

    return rval;
}

BOOL
WalkX86_Fpo_NonFpo(
    HANDLE                            Process,
    HANDLE                            Thread,
    PFPO_DATA                         pFpoData,
    PFPO_DATA                         PreviousFpoData,
    LPSTACKFRAME64                    StackFrame,
    PX86_CONTEXT                      ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    DWORD       stack[FRAME_SIZE+STACK_SIZE];
    DWORD       cb;
    DWORD64     FrameAddr;
    DWORD64     FuncAddr;
    DWORD       FuncSize;
    BOOL        AcceptUnreadableCallsite = FALSE;

    WDB((1, "  WalkFN:\n"));

    //
    // if the previous frame was an SEH frame then we must
    // retrieve the "real" frame pointer for this frame.
    // the SEH function pushed the frame pointer last.
    //

    if (PreviousFpoData->fHasSEH) {

        if (DoMemoryReadAll( &StackFrame->AddrFrame, stack, FRAME_SIZE+STACK_SIZE )) {

            StackFrame->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)(stack[2]);
            StackFrame->AddrStack.Offset = (DWORD64)(LONG64)(LONG)(stack[2]);
            WalkX86Init(Process,
                        Thread,
                        StackFrame,
                        ContextRecord,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase,
                        TranslateAddress);

            return TRUE;
        }
    }

    //
    // If a prior frame has stored this frame's EBP, just use it.
    // Do sanity check if the saved ebp looks like a valid ebp for current stack
    //

    if (IS_EBP_SAVED(StackFrame) &&
        (StackFrame->AddrFrame.Offset <= SAVE_EBP(StackFrame)) &&
        (StackFrame->AddrFrame.Offset + 0x4000 >= SAVE_EBP(StackFrame))) {

        StackFrame->AddrFrame.Offset = SAVE_EBP(StackFrame);
        FrameAddr = StackFrame->AddrFrame.Offset + 4;
        AcceptUnreadableCallsite = TRUE;
        WDB((1, "    use %X\n", (ULONG)FrameAddr));

    } else {

        //
        // Skip past the FPO frame base and parameters.
        //
        StackFrame->AddrFrame.Offset +=
            (FRAME_SIZE + (PreviousFpoData->cdwParams * 4));

        //
        // Now this is pointing to the bottom of the non-FPO frame.
        // If the frame has an fpo record, use it:
        //

        if (pFpoData) {
            FrameAddr = StackFrame->AddrFrame.Offset +
                            4* (pFpoData->cbRegs + pFpoData->cdwLocals);
            AcceptUnreadableCallsite = TRUE;
        } else {
            //
            // We don't know if the non-fpo frame has any locals, but
            // skip past the EBP anyway.
            //
            FrameAddr = StackFrame->AddrFrame.Offset + 4;
        }

        WDB((1, "    compute %X\n", (ULONG)FrameAddr));
    }

    //
    // at this point we may not be sitting at the base of the frame
    // so we now search for the return address and then subtract the
    // size of the frame pointer and use that address as the new base.
    //

    if (pFpoData) {
        FuncAddr = GetModuleBase(Process,StackFrame->AddrPC.Offset) + pFpoData->ulOffStart;
        FuncSize = pFpoData->cbProcSize;

    } else {
        FuncAddr = StackFrame->AddrPC.Offset - MAX_CALL;
        FuncSize = MAX_CALL;
    }



    FrameAddr = SearchForReturnAddress( Process,
                                        FrameAddr,
                                        FuncAddr,
                                        FuncSize,
                                        ReadMemory,
                                        GetModuleBase,
                                        AcceptUnreadableCallsite
                                        );
    if (FrameAddr) {
        StackFrame->AddrFrame.Offset = FrameAddr - STACK_SIZE;
    }

    if (!DoMemoryReadAll( &StackFrame->AddrFrame, stack, FRAME_SIZE )) {
        //
        // a failure means that we likely have a bad address.
        // returning zero will terminate that stack trace.
        //
        stack[0] = 0;
    }

    SAVE_EBP(StackFrame) = (DWORD64)(LONG64)(LONG)(stack[0]);
    WDB((1, "    save %X\n", stack[0]));

    StackFrame->FuncTableEntry = pFpoData;

    return TRUE;
}

BOOL
WalkX86_NonFpo_Fpo(
    HANDLE                            Process,
    HANDLE                            Thread,
    PFPO_DATA                         pFpoData,
    PFPO_DATA                         PreviousFpoData,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL           rval;

    WDB((1, "  WalkNF:\n"));

    rval = GetFpoFrameBase( Process,
                            StackFrame,
                            pFpoData,
                            PreviousFpoData,
                            FALSE,
                            ReadMemory,
                            GetModuleBase );

    StackFrame->FuncTableEntry = pFpoData;

    return rval;
}

BOOL
WalkX86_NonFpo_NonFpo(
    HANDLE                            Process,
    HANDLE                            Thread,
    PFPO_DATA                         pFpoData,
    PFPO_DATA                         PreviousFpoData,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    DWORD       stack[FRAME_SIZE*4];
    DWORD       cb;

    WDB((1, "  WalkNN:\n"));

    //
    // a previous function in the call stack was a fpo function that used ebp as
    // a general purpose register.  ul contains the ebp value that was good  before
    // that function executed.  it is that ebp that we want, not what was just read
    // from the stack.  what was just read from the stack is totally bogus.
    //
    if (IS_EBP_SAVED(StackFrame) &&
        (StackFrame->AddrFrame.Offset <= SAVE_EBP(StackFrame))) {

        StackFrame->AddrFrame.Offset = SAVE_EBP(StackFrame);
        SAVE_EBP(StackFrame) = 0;

    } else {

        //
        // read the first dword off the stack
        //
        if (!DoMemoryReadAll( &StackFrame->AddrFrame, stack, STACK_SIZE )) {
            return FALSE;
        }

        StackFrame->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)(stack[0]);
    }

    StackFrame->FuncTableEntry = pFpoData;

    return TRUE;
}

BOOL
X86ApplyFrameData(
    HANDLE Process,
    LPSTACKFRAME64 StackFrame,
    PX86_CONTEXT ContextRecord,
    PFPO_DATA PreviousFpoData,
    BOOL FirstFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    PGET_MODULE_BASE_ROUTINE64 GetModuleBase
    )
{
    IDiaFrameData* DiaFrame;
    BOOL Succ = FALSE;

    // If we can get VC7-style frame data just execute
    // the frame data program to unwind the stack.
    // If weren't given a context record we cannot use
    // the new VC7 unwind information as we have nowhere
    // to save intermediate context values.
    if (StackFrame->AddrPC.Mode != AddrModeFlat ||
        !g_vc7fpo ||
        !ContextRecord ||
        !diaGetFrameData(Process, StackFrame->AddrPC.Offset, &DiaFrame))
    {
        return FALSE;
    }

    if (FirstFrame)
    {
        ContextRecord->Ebp = (ULONG)StackFrame->AddrFrame.Offset;
        ContextRecord->Esp = (ULONG)StackFrame->AddrStack.Offset;
        ContextRecord->Eip = (ULONG)StackFrame->AddrPC.Offset;
    }

    WDB((1, "  Applying frame data program for PC %X SP %X FP %X\n",
         ContextRecord->Eip, ContextRecord->Esp, ContextRecord->Ebp));

    //
    // execute() does not currently work when the PC is
    // within the function prologue.  This should only
    // happen on calls from WalkX86Init, in which case the
    // normal failure path here where the non-frame-data
    // code will be executed is correct as that will handle
    // normal prologue code.
    //

    X86WalkFrame WalkFrame(Process, ContextRecord,
                           ReadMemory, GetModuleBase,
                           PreviousFpoData);
    Succ = DiaFrame->execute(&WalkFrame) == S_OK;

    if (Succ) {
        WDB((1, "  Result PC %X SP %X FP %X\n",
             ContextRecord->Eip, ContextRecord->Esp, ContextRecord->Ebp));

        StackFrame->AddrStack.Mode = AddrModeFlat;
        StackFrame->AddrStack.Offset = EXTEND64(ContextRecord->Esp);
        StackFrame->AddrFrame.Mode = AddrModeFlat;
        // The frame value we want to return is the frame value
        // used for the function that was just unwound, not
        // the current value of EBP.  After the unwind the current
        // value of EBP is the caller's EBP, not the callee's
        // frame.  Instead we always set the callee's frame to
        // the offset beyond where the return address would be
        // as that's where the frame will be in a normal non-FPO
        // function and where we fake it as being for FPO functions.
        //
        // Separately, we save the true EBP away for future frame use.
        // According to VinitD there's a compiler case where it
        // doesn't generate proper unwind instructions for restoring
        // EBP, so there are some times where EBP is not restored
        // to a good value after the execute and we have to fall
        // back on searching.  If EBP wasn't set during the execute
        // we do not save its value.
        StackFrame->AddrFrame.Offset =
            StackFrame->AddrStack.Offset - FRAME_SIZE;
        StackFrame->AddrReturn.Offset = EXTEND64(ContextRecord->Eip);
        // XXX drewb - This is causing some failures in the regression
        // tests so don't enable it until we fully understand it.
#if 0
        if (WalkFrame.WasEbpSet()) {
            SAVE_EBP(StackFrame) = EXTEND64(ContextRecord->Ebp);
        } else {
            WDB((1, "  * EBP not recovered\n"));
        }
#else
        SAVE_EBP(StackFrame) = EXTEND64(ContextRecord->Ebp);
#endif

        // Caller may need to allocate this to allow alternate stackwalk with dbghelp code
        StackFrame->FuncTableEntry = NULL;

        X86ReadFunctionParameters(Process, StackFrame->AddrStack.Offset,
                                  StackFrame, ReadMemory);

    } else {
        WDB((1, "  Apply failed\n"));
    }

    DiaFrame->Release();
    return Succ;
}

VOID
X86UpdateContextFromFrame(
    HANDLE Process,
    LPSTACKFRAME64 StackFrame,
    PX86_CONTEXT ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    )
{
    ULONG Ebp;
    ULONG Done;

    if (StackFrame->AddrPC.Mode != AddrModeFlat ||
        !ContextRecord) {
        return;
    }

    ContextRecord->Esp = (ULONG)StackFrame->AddrFrame.Offset + FRAME_SIZE;
    ContextRecord->Eip = (ULONG)StackFrame->AddrReturn.Offset;

    if (IS_EBP_SAVED(StackFrame)) {
        ContextRecord->Ebp = (ULONG)SAVE_EBP(StackFrame);
    } else {

        if (ReadMemory(Process, StackFrame->AddrFrame.Offset,
                       &Ebp, sizeof(Ebp), &Done) &&
            Done == sizeof(Ebp)) {
            ContextRecord->Ebp = Ebp;
        }
    }
    if (StackFrame->FuncTableEntry) {

        if (!IS_EBP_SAVED(StackFrame)) {
            // Don't change Ebp
            SAVE_EBP(StackFrame) = ((ULONG) StackFrame->AddrFrame.Offset + STACK_SIZE) +
                0xEB00000000; // Add this tag to top 32 bits for marking this as a frame value
                              // rather than FPO saved EBP
        }
    }
}

BOOL
WalkX86Next(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PX86_CONTEXT                      ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    PFPO_DATA      pFpoData = NULL;
    PFPO_DATA      PrevFpoData = NULL;
    FPO_DATA       PrevFpoBuffer;
    BOOL           rVal = TRUE;
    DWORD64        Address;
    DWORD          cb;
    DWORD64        ThisPC;
    DWORD64        ModuleBase;
    DWORD64        SystemRangeStart;

    WDB((1, "WalkNext: PC %X, SP %X, FP %X\n",
         (ULONG)StackFrame->AddrReturn.Offset,
         (ULONG)StackFrame->AddrStack.Offset,
         (ULONG)StackFrame->AddrFrame.Offset));

    StackFrame->AddrStack.Offset = EXTEND64(StackFrame->AddrStack.Offset);
    StackFrame->AddrFrame.Offset = EXTEND64(StackFrame->AddrFrame.Offset);

    // FunctionTableAccess often returns pointers to static
    // data that gets overwritten on every call.  Preserve
    // the data of any previous FPO record for the duration
    // of this routine so that FunctionTableAccess calls can
    // be made without destroying previous FPO data.
    if (StackFrame->FuncTableEntry) {
        PrevFpoBuffer = *(PFPO_DATA)StackFrame->FuncTableEntry;
        PrevFpoData = &PrevFpoBuffer;
    }

    if (g.AppVersion.Revision >= 6) {
        SystemRangeStart = EXTEND64(SYSTEM_RANGE_START(StackFrame));
    } else {
        //
        // This might not really work right with old debuggers, but it keeps
        // us from looking off the end of the structure anyway.
        //
        SystemRangeStart = 0xFFFFFFFF80000000;
    }


    ThisPC = StackFrame->AddrPC.Offset;

    //
    // the previous frame's return address is this frame's pc
    //
    StackFrame->AddrPC = StackFrame->AddrReturn;

    if (StackFrame->AddrPC.Mode != AddrModeFlat) {
        //
        // the call stack is from either WOW or a DOS app
        //
        SetNonOff32FrameAddress( Process,
                                 Thread,
                                 StackFrame,
                                 ReadMemory,
                                 FunctionTableAccess,
                                 GetModuleBase,
                                 TranslateAddress
                               );
        goto exit;
    }

    //
    // if the last frame was the usermode callback dispatcher,
    // switch over to the kernel stack:
    //

    ModuleBase = GetModuleBase(Process, ThisPC);

    if ((g.AppVersion.Revision >= 4) &&
        (CALLBACK_STACK(StackFrame) != 0) &&
        (pFpoData = PrevFpoData) &&
        (CALLBACK_DISPATCHER(StackFrame) ==
         ModuleBase + PrevFpoData->ulOffStart) )  {

      NextCallback:

        rVal = FALSE;

        //
        // find callout frame
        //

        if (EXTEND64(CALLBACK_STACK(StackFrame)) >= SystemRangeStart) {

            //
            // it is the pointer to the stack frame that we want,
            // or -1.

            Address = EXTEND64(CALLBACK_STACK(StackFrame));

        } else {

            //
            // if it is below SystemRangeStart, it is the offset to
            // the address in the thread.
            // Look up the pointer:
            //

            rVal = ReadMemory(Process,
                              (CALLBACK_THREAD(StackFrame) +
                                 CALLBACK_STACK(StackFrame)),
                              &Address,
                              sizeof(DWORD),
                              &cb);

            Address = EXTEND64(Address);

            if (!rVal || cb != sizeof(DWORD) || Address == 0) {
                Address = 0xffffffff;
                CALLBACK_STACK(StackFrame) = 0xffffffff;
            }

        }

        if ((Address == 0xffffffff) ||
            !(pFpoData = (PFPO_DATA)
              FunctionTableAccess( Process, CALLBACK_FUNC(StackFrame))) ) {

            rVal = FALSE;

        } else {

            StackFrame->FuncTableEntry = pFpoData;

            StackFrame->AddrPC.Offset = CALLBACK_FUNC(StackFrame) +
                                                    pFpoData->cbProlog;

            StackFrame->AddrStack.Offset = Address;

            if (!ReadMemory(Process,
                            Address + CALLBACK_FP(StackFrame),
                            &StackFrame->AddrFrame.Offset,
                            sizeof(DWORD),
                            &cb) ||
                cb != sizeof(DWORD)) {
                return FALSE;
            }

            StackFrame->AddrFrame.Offset =
                EXTEND64(StackFrame->AddrFrame.Offset);

            if (!ReadMemory(Process,
                            Address + CALLBACK_NEXT(StackFrame),
                            &CALLBACK_STACK(StackFrame),
                            sizeof(DWORD),
                            &cb) ||
                cb != sizeof(DWORD))
            {
                return FALSE;
            }

            SAVE_TRAP(StackFrame) = 0;

            rVal = WalkX86Init(
                Process,
                Thread,
                StackFrame,
                ContextRecord,
                ReadMemory,
                FunctionTableAccess,
                GetModuleBase,
                TranslateAddress
                );

        }

        return rVal;

    }

    //
    // if there is a trap frame then handle it
    //
    if (SAVE_TRAP(StackFrame)) {
        rVal = ProcessTrapFrame(
            Process,
            StackFrame,
            pFpoData,
            PrevFpoData,
            ReadMemory,
            FunctionTableAccess
            );
        if (!rVal) {
            return rVal;
        }
        rVal = WalkX86Init(
            Process,
            Thread,
            StackFrame,
            ContextRecord,
            ReadMemory,
            FunctionTableAccess,
            GetModuleBase,
            TranslateAddress
            );
        return rVal;
    }

    //
    // if the PC address is zero then we're at the end of the stack
    //
    //if (GetModuleBase(Process, StackFrame->AddrPC.Offset) == 0)

    if (StackFrame->AddrPC.Offset < 65536) {

        //
        // if we ran out of stack, check to see if there is
        // a callback stack chain
        //
        if (g.AppVersion.Revision >= 4 && CALLBACK_STACK(StackFrame) != 0) {
            goto NextCallback;
        }

        return FALSE;
    }

    //
    // If the frame, pc and return address are all identical, then we are
    // at the top of the idle loop
    //

    if ((StackFrame->AddrPC.Offset == StackFrame->AddrReturn.Offset) &&
        (StackFrame->AddrPC.Offset == StackFrame->AddrFrame.Offset))
    {
        return FALSE;
    }

    if (X86ApplyFrameData(Process, StackFrame, ContextRecord,
                          PrevFpoData, FALSE,
                          ReadMemory, GetModuleBase)) {
        // copy FPO_DATA to allow alternating between dbghelp and DIA stackwalk
        StackFrame->FuncTableEntry = FunctionTableAccess(Process, StackFrame->AddrPC.Offset);
        return TRUE;
    }

    //
    // check to see if the current frame is an fpo frame
    //
    pFpoData = (PFPO_DATA) FunctionTableAccess(Process, StackFrame->AddrPC.Offset);


    if (pFpoData && pFpoData->cbFrame != FRAME_NONFPO) {
        if (PrevFpoData && PrevFpoData->cbFrame != FRAME_NONFPO) {

            rVal = WalkX86_Fpo_Fpo( Process,
                                    Thread,
                                    pFpoData,
                                    PrevFpoData,
                                    StackFrame,
                                    ReadMemory,
                                    FunctionTableAccess,
                                    GetModuleBase,
                                    TranslateAddress
                                    );

        } else {

            rVal = WalkX86_NonFpo_Fpo( Process,
                                       Thread,
                                       pFpoData,
                                       PrevFpoData,
                                       StackFrame,
                                       ReadMemory,
                                       FunctionTableAccess,
                                       GetModuleBase,
                                       TranslateAddress
                                       );

        }
    } else {
        if (PrevFpoData && PrevFpoData->cbFrame != FRAME_NONFPO) {

            rVal = WalkX86_Fpo_NonFpo( Process,
                                       Thread,
                                       pFpoData,
                                       PrevFpoData,
                                       StackFrame,
                                       ContextRecord,
                                       ReadMemory,
                                       FunctionTableAccess,
                                       GetModuleBase,
                                       TranslateAddress
                                       );

        } else {

            rVal = WalkX86_NonFpo_NonFpo( Process,
                                          Thread,
                                          pFpoData,
                                          PrevFpoData,
                                          StackFrame,
                                          ReadMemory,
                                          FunctionTableAccess,
                                          GetModuleBase,
                                          TranslateAddress
                                          );

        }
    }

exit:
    StackFrame->AddrFrame.Mode = StackFrame->AddrPC.Mode;
    StackFrame->AddrReturn.Mode = StackFrame->AddrPC.Mode;

    GetFunctionParameters( Process, Thread, StackFrame,
                           ReadMemory, GetModuleBase, TranslateAddress );

    GetReturnAddress( Process, Thread, StackFrame,
                      ReadMemory, GetModuleBase, TranslateAddress,
                      FunctionTableAccess );

    X86UpdateContextFromFrame(Process, StackFrame, ContextRecord, ReadMemory);

    return rVal;
}

BOOL
WalkX86Init(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PX86_CONTEXT                      ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    UCHAR               code[3];
    DWORD               stack[FRAME_SIZE*4];
    PFPO_DATA           pFpoData = NULL;
    ULONG               cb;
    ULONG64             ModBase;

    StackFrame->Virtual = TRUE;
    StackFrame->Reserved[0] =
    StackFrame->Reserved[1] =
    StackFrame->Reserved[2] = 0;
    StackFrame->AddrReturn = StackFrame->AddrPC;

    if (StackFrame->AddrPC.Mode != AddrModeFlat) {
        goto exit;
    }

    WDB((1, "WalkInit: PC %X, SP %X, FP %X\n",
         (ULONG)StackFrame->AddrPC.Offset, (ULONG)StackFrame->AddrStack.Offset,
         (ULONG)StackFrame->AddrFrame.Offset));

    if (X86ApplyFrameData(Process, StackFrame, ContextRecord, NULL, TRUE,
                          ReadMemory, GetModuleBase)) {
        // copy FPO_DATA to allow alternating between dbghelp and DIA stackwalk
        StackFrame->FuncTableEntry = FunctionTableAccess(Process, StackFrame->AddrPC.Offset);
        return TRUE;
    }

    StackFrame->FuncTableEntry = pFpoData = (PFPO_DATA)
        FunctionTableAccess(Process, StackFrame->AddrPC.Offset);

    if (pFpoData && pFpoData->cbFrame != FRAME_NONFPO) {

        GetFpoFrameBase( Process,
                         StackFrame,
                         pFpoData,
                         pFpoData,
                         TRUE,
                         ReadMemory,
                         GetModuleBase );
        goto exit;

    } else if (!pFpoData &&
               ((ModBase = GetModuleBase(Process, StackFrame->AddrPC.Offset)) == 0 ||
                 ModBase == MM_SHARED_USER_DATA_VA)) {

        //
        // We have no FPO data and the current IP isn't in
        // any known module or the module is debuggers' madeup
        // "shareduserdata" module.  We'll assume this is a call
        // to a bad address, so we expect that the return
        // address should be the first DWORD on the stack.
        //

        if (DoMemoryReadAll( &StackFrame->AddrStack, stack, STACK_SIZE ) &&
            GetModuleBase(Process, EXTEND64(stack[0]))) {

            // The first DWORD is a code address.  We probably
            // found a call to a bad location.
            SAVE_EBP(StackFrame) = StackFrame->AddrFrame.Offset;
            StackFrame->AddrFrame.Offset =
                StackFrame->AddrStack.Offset - STACK_SIZE;
            goto exit;
        }
    }

    //
    // We couldn't figure out anything about the code at
    // the current IP so we just assume it's a traditional
    // EBP-framed routine.
    //
    // First check whether eip is in the function prolog
    //
    memset(code, 0xcc, sizeof(code));
    if (!DoMemoryRead( &StackFrame->AddrPC, code, 3, &cb )) {
        //
        // Assume a call to a bad address if the memory read fails.
        //
        code[0] = PUSHBP;
    }

    if ((code[0] == PUSHBP) || (*(LPWORD)&code[0] == MOVBPSP)) {
        SAVE_EBP(StackFrame) = StackFrame->AddrFrame.Offset;
        StackFrame->AddrFrame.Offset = StackFrame->AddrStack.Offset;
        if (StackFrame->AddrPC.Mode != AddrModeFlat) {
            StackFrame->AddrFrame.Offset &= 0xffff;
        }
        if (code[0] == PUSHBP) {
            if (StackFrame->AddrPC.Mode == AddrModeFlat) {
                StackFrame->AddrFrame.Offset -= STACK_SIZE;
            } else {
                StackFrame->AddrFrame.Offset -= STACK_SIZE16;
            }
        }
    } else {
        //
        // We're not in a prologue so assume we're in the middle
        // of an EBP-framed function.  Read the first dword off
        // the stack at EBP and assume that it's the pushed EBP.
        //
        if (DoMemoryReadAll( &StackFrame->AddrFrame, stack, STACK_SIZE )) {
            SAVE_EBP(StackFrame) = EXTEND64(stack[0]);
        }

        if (StackFrame->AddrPC.Mode != AddrModeFlat) {
            StackFrame->AddrFrame.Offset &= 0x0000FFFF;
        }
    }

exit:
    StackFrame->AddrFrame.Mode = StackFrame->AddrPC.Mode;

    GetFunctionParameters( Process, Thread, StackFrame,
                           ReadMemory, GetModuleBase, TranslateAddress );

    GetReturnAddress( Process, Thread, StackFrame,
                      ReadMemory, GetModuleBase, TranslateAddress,
                      FunctionTableAccess );

    X86UpdateContextFromFrame(Process, StackFrame, ContextRecord, ReadMemory);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\_qsort.c ===
#define NEW_QSORT_NAME dbg_qsort

#include "_qsort.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\whackdbg.c ===
#include <windows.h>
#include <stdio.h>

int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hMappedFile;
    HANDLE hFile;
    int i;
    PIMAGE_SECTION_HEADER ImageSectHdr;
    PIMAGE_FILE_HEADER ImageHdr;

    if (argc <= 1) {
        puts("Usage: whackdbg <object>\n"
             "\twhere <object> is an obj that contains CV .debug$? sections that s/b zero'd out\n");
        return 1;
    }

    argv++;
    while (--argc) {
        hFile = CreateFile(
                    *argv,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hFile == INVALID_HANDLE_VALUE )
            goto clean0;

        hMappedFile = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        0,
                        NULL
                        );
        if ( !hMappedFile ) {
            goto clean1;
        }

        ImageHdr = (PIMAGE_FILE_HEADER) MapViewOfFile( hMappedFile, FILE_MAP_WRITE, 0, 0, 0 );

        CloseHandle(hMappedFile);

        // We're going to do very minimal testing here.  Basically if it starts with
        // a i386 or alpha machine signature, we'll assume it's an object and party on
        // it...

        if ((ImageHdr->Machine != IMAGE_FILE_MACHINE_I386) &&
            (ImageHdr->Machine != IMAGE_FILE_MACHINE_ALPHA))
        {
            goto clean2;
        }

        ImageSectHdr = (PIMAGE_SECTION_HEADER)((ULONG)ImageHdr + IMAGE_SIZEOF_FILE_HEADER);
        for (i=0;i < ImageHdr->NumberOfSections; i++) {
            if ((strcmp(ImageSectHdr->Name, ".debug$T") == 0) ||
                (strcmp(ImageSectHdr->Name, ".debug$S") == 0) ||
                (strcmp(ImageSectHdr->Name, ".debug$P") == 0)
               )
            {
                ImageSectHdr->SizeOfRawData = 0;
            }
            ImageSectHdr++;
        }

        FlushViewOfFile((PUCHAR)ImageHdr, 0);
clean2:
        UnmapViewOfFile((PUCHAR)ImageHdr);
clean1:
        CloseHandle(hFile);
clean0:
        argv++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\wppfmt.h ===
// The main Formatting routine, normally used by Binplace and TracePDB
// Takes a PDB and creates guid.tmf files from it, all in TraceFormatFilePath
//
DWORD
BinplaceWppFmt(
              LPTSTR PdbFileName,
              LPTSTR TraceFormatFilePath,
              LPSTR szRSDSDllToLoad,
              BOOL  TraceVerbose
              ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\wppfmt.c ===
//  WppFmt.c
// This module contains the routines used by BinPlace to copy out the trace format information used 
// by software tracing. It creates "guid".tmf files 
// The pre-processor TraceWpp creates annotation records in the PDB with the first string bwinfg the text
// "TMF:" we find these annotation records and extract the complete record. The first record
// after "TMF:" contains the guid and friendly name. This GUID is used to create the filename.
// Currently the remainder of the records are copied to the file, a possible future change is to turn the
// file into a pointer file.
// Based on PDB sample code from VC folks, with names kept the same.
#ifdef __cplusplus
extern "C"{
#endif


//#define UNICODE
//#define _UNICODE

#define FUNCNAME_MAX_SIZE 256

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <dbghelp.h>
#include <cvinfo.h>
#define PDB_LIBRARY
#include <pdb.h>
#include <strsafe.h>

    typedef LONG    CB;     // count of bytes
    typedef CHAR *      ST;
    typedef SYMTYPE*    PSYM;
    typedef SYMTYPE UNALIGNED * PSYMUNALIGNED;
    typedef BYTE*       PB;     // pointer to some bytes

    FILE* TraceFileP = NULL;                        // Current File
    CHAR lastguid[MAX_PATH];                        // The last file we processed
    CHAR TraceFile[MAX_PATH];                       // The current full file spec.
    CHAR TraceFileExt[] = ".tmf" ;                  // Extension used by Trace Files
    CHAR TraceControlExt[] = ".tmc" ;               // Extension used by Trace Control Files
    BOOL TracePathChecked = FALSE ;                 // if we have ascertained the trace Path exists.
    CHAR Fname[MAX_PATH] ;
    CHAR Mname[MAX_PATH] ;

#define GUIDTEXTLENGTH  32+4                    // Guid takes 32 chars plus 4 -'s

#define MAXLINE MAX_PATH + 256
    CHAR Line[MAXLINE] ;
    CHAR Line2[MAXLINE] ;
    CHAR FirstLine[MAXLINE] ;
    CHAR SecondLine[MAXLINE] ;

    BOOL fVerbose = FALSE ;

    typedef BOOL ( __cdecl *PPDBOPEN )(
                                      LNGNM_CONST char *,
                                      LNGNM_CONST char *,
                                      SIG,
                                      EC *,
                                      char [cbErrMax],
                                      PDB **
                                      );

    typedef BOOL ( __cdecl *PPDBCLOSE ) (
                                        PDB* ppdb
                                        );

    typedef BOOL ( __cdecl *PPDBOPENDBI ) (
                                          PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi
                                          );

    typedef BOOL ( __cdecl *PDBICLOSE ) (
                                        DBI* pdbi
                                        );

    typedef BOOL ( __cdecl *PMODQUERYSYMBOLS ) (
                                               Mod* pmod, BYTE* pbSym, long* pcb
                                               );

    typedef BOOL ( __cdecl *PDBIQUERYNEXTMOD ) (
                                               DBI* pdbi, Mod* pmod, Mod** ppmodNext
                                               );

    static PPDBOPEN    pPDBOpen = NULL;
    static PPDBCLOSE   pPDBClose = NULL;
    static PPDBOPENDBI pPDBOpenDBI = NULL;
    static PDBICLOSE   pDBIClose = NULL;
    static PMODQUERYSYMBOLS pModQuerySymbols = NULL;
    static PDBIQUERYNEXTMOD pDBIQueryNextMod = NULL;

    static BOOL RSDSLibLoaded = FALSE;

// Return the number of bytes the symbol record occupies.
#define MDALIGNTYPE_	DWORD

    __inline CB cbAlign_(CB cb) {
        return((cb + sizeof(MDALIGNTYPE_) - 1)) & ~(sizeof(MDALIGNTYPE_) - 1);}

// Return the number of bytes in an ST

    __inline CB cbForSt(ST st) { return *(PB)st + 1;}

    CB cbForSym(PSYMUNALIGNED psym)
    {
        CB cb = psym->reclen + sizeof(psym->reclen); 
        // procrefs also have a hidden length preceeded name following the record
        if ((psym->rectyp == S_PROCREF) || (psym->rectyp == S_LPROCREF))
            cb += cbAlign_(cbForSt((ST)(psym + cb)));
        return cb;
    }

// Return a pointer to the byte just past the end of the symbol record.

    PSYM pbEndSym(PSYM psym) { return(PSYM)((CHAR *)psym + cbForSym(psym));}

    CHAR * SymBuffer   = 0;
    int    SymBufferSize = 0;

    BOOL ensureBufferSizeAtLeast(int size)
    {
        if (size > SymBufferSize) {
            LocalFree(SymBuffer);
            SymBufferSize = 0;
            size = (size + 0xFFFF) & ~0xFFFF;
            SymBuffer = LocalAlloc(LMEM_FIXED, size );
            if (!SymBuffer) {
                fprintf(stderr,"%s : error BNP0000: WPPFMT alloc of %d bytes failed\n",Fname, size);
                return FALSE;
            }
            SymBufferSize = size;
        }
        return TRUE;
    }


    void dumpSymbol(PSYM psym,
                    PSTR PdbFileName,
                    PSTR TraceFormatFilePath) 
    {
        static char FuncName[FUNCNAME_MAX_SIZE +1] = "Unknown";
        static char Fmode[8] = "w" ;
        HRESULT hRtrn ;

        if (psym->rectyp == S_GPROC32 || psym->rectyp == S_LPROC32) {
            PROCSYM32* p = (PROCSYM32*)psym;
            int n = p->name[0];
            if (n > FUNCNAME_MAX_SIZE) {
                FuncName[0] = 0 ;    // ignore too long, Illegal, name.
            } else {
                memcpy(FuncName, p->name + 1, n);
                FuncName[n] = 0; 
            }
            return;
        }
        //
        // The following is a complete crock to let us handle some V7 PDB changes
        // This code will have qbe changed by DIA but this lets users get work done
#define S_GPROC32_V7 0x110f
#define S_LPROC32_V7 0x1110
        if (psym->rectyp == (S_GPROC32_V7) || psym->rectyp == (S_LPROC32_V7)) {
            PROCSYM32* p = (PROCSYM32*)psym;
            strncpy(FuncName,p->name, 256);     // Note name is null terminated, not length!!!
            return;
        }
        // End of V7 PDB crock

        if (psym->rectyp == S_ANNOTATION) {
            ANNOTATIONSYM* aRec = (ANNOTATIONSYM*) psym;
            UCHAR * Aline = aRec->rgsz;
            int   cnt = aRec->csz, i; 
            CHAR* Ext;

            if ( cnt < 2 ) {
                return;
            }
            if ( strcmp(Aline, "TMF:") == 0 ) {
                Ext = TraceFileExt;
            } else if ( strcmp(Aline, "TMC:") == 0 ) {
                Ext = TraceControlExt;
            } else {
                return;
            }
            // skip tmf
            Aline += strlen(Aline) + 1; 
            // now Aline points to guid, is it the same as before?
            if ( (TraceFileP != stdout) && strncmp(Aline, lastguid, GUIDTEXTLENGTH) != 0) {
                // the guid has changed, we need to change the file
                if (TraceFileP) {
                    fclose(TraceFileP);    // Close the last one
                    TraceFileP = NULL ;
                }

                if (GUIDTEXTLENGTH < sizeof(lastguid) ) {
                    strncpy(lastguid, Aline, GUIDTEXTLENGTH);
                } else {
                    fprintf(stderr,"%s : error BNP0000: WPPFMT GUID buffer too small \n",Fname);
                    return;                   // then game over
                }

                if (StringCchPrintf(TraceFile,MAX_PATH,"%s\\%s%s",TraceFormatFilePath,lastguid,Ext) == STRSAFE_E_INSUFFICIENT_BUFFER ) {
                    fprintf(stderr,"%s : error BNP0000: WPPFMT File + Path too long %s\n",Fname, TraceFile);
                    return;                   // then game over.
                }

                if (!TracePathChecked) {
                    if (!MakeSureDirectoryPathExists(TraceFile)) {    // Make the directory if we need to
                        fprintf(stderr,"%s : error BNP0000: WPPFMT Failed to make path %s\n",Fname, TraceFile);
                        return;
                    } else {
                        TracePathChecked = TRUE ;
                    }
                }
                // In this case we have to deal with situation where we come across the same GUID but its
                // from a different PDB. This can validly happen when say a library is trace enabled and 
                // included with multiple components, they each have part of the trace information, though
                // now it belongs to the PDB of the calling process.
                // So we have the PDB name in the first line, and the date on the second and the logic is
                // If PDB names do not match then APPEND
                // If PDB names and date match then APPEND
                // If name matches but date does not then Overwrite.
                //
                hRtrn = StringCchPrintf(Fmode, 7, "w");    // Assume its to be overwritten
                if ((TraceFileP = fopen(TraceFile,"r")) != NULL ) {
                    // Hmm it already exists, is it an old one or must we add to it.
                    if (_fgetts(Line, MAXLINE, TraceFileP)) {           // Get the First line
                        if (strncmp(Line,FirstLine,MAXLINE) == 0) {              // Is it us?
                            if (_fgetts(Line2, MAXLINE, TraceFileP)) {  // Get the second line
                                if (strncmp(Line2,SecondLine,MAXLINE) == 0) {    // Really us for this build?
                                    hRtrn = StringCchPrintf(Fmode, 7, "a");     // Yes Append
                                }
                            } 
                        } else {
                           hRtrn = StringCchPrintf(Fmode, 7, "a");     // Not us, most likely a library so Append
                        }
                    }
                    fclose (TraceFileP);
                    TraceFileP = NULL ;
                }

                TraceFileP = fopen(TraceFile, Fmode);

                if (!TraceFileP) {
                    if (fVerbose) { 
                        fprintf(stderr,"%s : warning BNP0000: WPPFMT Failed to open %s (0x%0X)\n",Fname, TraceFile,GetLastError());
                    }
                    return;
                }
                if (fVerbose) {
                    fprintf(stdout,"%s : info BNP0000: WPPFMT generating %s for %s\n", 
                            Fname, TraceFile, PdbFileName);
                }
                if (!(strcmp(Fmode,"w"))) {
                    // First time around comment on what we are doing.
                    fprintf(TraceFileP,"%s",FirstLine);  // Note the name of the PDB etc.
                    fprintf(TraceFileP,"%s",SecondLine);
                    fprintf(TraceFileP,"%s\n",Aline);    // Guid and friendly name
                } else {
                    fprintf(TraceFileP,"%s",FirstLine);
                    fprintf(TraceFileP,"%s",SecondLine);
                }
            }
            // process the annotation which is a series of null terminated strings.
            cnt -= 2; Aline += strlen(Aline) + 1; 
            for (i = 0; i < cnt; ++i) {
                if (i == 0) {
                    fprintf(TraceFileP, "%s FUNC=%s\n", Aline, FuncName);
                } else {
                    fprintf(TraceFileP,"%s\n", Aline);
                }
                Aline += strlen(Aline) + 1;
            }
        }
    }

    DWORD
    BinplaceWppFmt(
                  LPSTR PdbFileName,
                  LPSTR TraceFormatFilePath,
                  LPSTR szRSDSDllToLoad,
                  BOOL  TraceVerbose
                  )
    {
        PDB *pPdb;
        DBI *pDbi;
        HANDLE hPdb ;

        UCHAR szErr[cbErrMax];
        EC    errorCode;
        Mod*  pMod;
        DWORD Status ;
        BOOL rc;

        fVerbose = TraceVerbose ;

        Line[0] = Line2[0] = FirstLine[0] = SecondLine[0] = 0 ;  // Initiallise to be careful of changes.

        // get name of the caller
        if ((Status = GetModuleFileName(NULL, Mname, MAX_PATH)) == 0) {
           fprintf(stderr,"UNKNOWN : error BNP0000: WPPFMT GetModuleFileName Failed %08X\n",GetLastError());
           return(FALSE);
        }
        _splitpath(Mname, NULL, NULL, Fname, NULL);

#ifdef _WIN64
        rc = FALSE;
#else
        __try
        {
            if (hPdb = CreateFile(PdbFileName,
                                  GENERIC_READ,
                                  0,NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL)) {
                FILETIME ftime ;
                SYSTEMTIME stime ;
                if (GetFileTime(hPdb,NULL,NULL,&ftime)) {
                    if ( FileTimeToSystemTime(&ftime,&stime) ) {
                        if (StringCchPrintf(FirstLine,MAXLINE,"//PDB:  %s\n",PdbFileName) == STRSAFE_E_INSUFFICIENT_BUFFER ) { // Ok deal with being too long, but we have a NULL
                            FirstLine[MAXLINE-2] = '\n' ; // But make sure we have a newline
                        }
                        if (StringCchPrintf(SecondLine,MAXLINE,"//PDB:  Last Updated :%d-%d-%d:%d:%d:%d:%d (UTC) [%s]\n",
                                  stime.wYear,stime.wMonth,stime.wDay,
                                  stime.wHour,stime.wMinute,stime.wSecond,stime.wMilliseconds,
                                  Fname) == STRSAFE_E_INSUFFICIENT_BUFFER ) { // Ok deal with being too long, but we have a NULL
                            SecondLine[MAXLINE-2] = '\n' ; // But make sure we have a newline
                        }

                    }
                }
                CloseHandle(hPdb);
            } else {
                // Let the failure case be dealt with by PDBOpen
            }


            rc=PDBOpen(PdbFileName, pdbRead, 0, &errorCode, szErr, &pPdb);
            if ((rc != 0) && (errorCode == 0)) {   // ignore bad return as we are replacing this anyway
                rc = 0 ;
            }
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            rc=FALSE;
        }
#endif
        if ( !rc ) {

            // Try the one that works with RSDS 
            if ( szRSDSDllToLoad != NULL ) {

                HMODULE hDll;
                if ( !RSDSLibLoaded ) {
                    hDll = LoadLibrary( szRSDSDllToLoad );
                    if (hDll != NULL) {
                        RSDSLibLoaded = TRUE;
                        pPDBOpen = ( PPDBOPEN ) GetProcAddress( hDll, "PDBOpen" );
                        if (pPDBOpen == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed PDBOpen\n",Fname);
                            return(FALSE);
                        }
                        pPDBClose = ( PPDBCLOSE ) GetProcAddress( hDll, "PDBClose" );
                        if (pPDBClose == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed PDBOClose\n",Fname);
                            return(FALSE);
                        }
                        pPDBOpenDBI = ( PPDBOPENDBI ) GetProcAddress( hDll, "PDBOpenDBI" );
                        if (pPDBOpenDBI == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed PDBOpenDBI\n",Fname);
                            return(FALSE);
                        }
                        pDBIClose = ( PDBICLOSE ) GetProcAddress( hDll, "DBIClose" );
                        if (pDBIClose == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed DBICLOSE\n",Fname);
                            return(FALSE);
                        }

                        pDBIQueryNextMod = ( PDBIQUERYNEXTMOD ) GetProcAddress( hDll, "DBIQueryNextMod" );
                        if (pDBIQueryNextMod == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed DBIQueryNextMod\n",Fname);
                            return(FALSE);
                        }

                        pModQuerySymbols = ( PMODQUERYSYMBOLS ) GetProcAddress( hDll, "ModQuerySymbols" );
                        if (pModQuerySymbols == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed ModQuerySymbols\n",Fname);
                            return(FALSE);
                        }

                    } else {
                        fprintf(stderr,"%s : error BNP0000: WPPFMT Failed to load library %s (0x%08X)\n",Fname, szRSDSDllToLoad,GetLastError());
                        return(FALSE);
                    }
                }
            }

            if (RSDSLibLoaded) {
                __try
                {
                    rc = pPDBOpen(PdbFileName, pdbRead, 0, &errorCode, szErr, &pPdb);
                }
                __except (EXCEPTION_EXECUTE_HANDLER )
                {
                    rc=FALSE;
                }
            }
        }

        if (!rc) {
            fprintf(stderr,"%s : warning BNP0000: WPPFMT PDBOpen failed, code %d, error %s\n",
                    Fname, errorCode, szErr);
            goto fail1;
        }

        if (RSDSLibLoaded) {
            rc = pPDBOpenDBI(pPdb, pdbRead, "<target>.exe", &pDbi);
        } else {
            rc = PDBOpenDBI(pPdb, pdbRead, "<target>.exe", &pDbi);
        }
        if (!rc) {
            fprintf(stderr,"%s : warning BNP0000: WPPFMT PDBOpenDBI failed\n",Fname);
            goto fail2;
        }

        if (RSDSLibLoaded) {
            for (pMod = 0; pDBIQueryNextMod(pDbi, pMod, &pMod) && pMod; ) {
                CB cbSyms;

                if (  pModQuerySymbols(pMod, 0, &cbSyms) 
                      && ensureBufferSizeAtLeast(cbSyms) 
                      && pModQuerySymbols(pMod, SymBuffer, &cbSyms) ) {
                    PSYM psymEnd = (PSYM)(SymBuffer + cbSyms);
                    PSYM psym    = (PSYM)(SymBuffer + sizeof(ULONG));

                    for (; psym < psymEnd; psym = pbEndSym(psym))
                        dumpSymbol(psym,PdbFileName,TraceFormatFilePath);
                } else {
                    fprintf(stderr,"%s : warning BNP0000: WPPFMT ModQuerySymbols failed pMod = %p cbSyms = %d\n",
                            Fname, pMod, cbSyms);
                    break;
                }
            }
        } else {
            for (pMod = 0; DBIQueryNextMod(pDbi, pMod, &pMod) && pMod; ) {
                CB cbSyms;

                if (  ModQuerySymbols(pMod, 0, &cbSyms) 
                      && ensureBufferSizeAtLeast(cbSyms) 
                      && ModQuerySymbols(pMod, SymBuffer, &cbSyms) ) {
                    PSYM psymEnd = (PSYM)(SymBuffer + cbSyms);
                    PSYM psym    = (PSYM)(SymBuffer + sizeof(ULONG));

                    for (; psym < psymEnd; psym = pbEndSym(psym))
                        dumpSymbol(psym,PdbFileName,TraceFormatFilePath);
                } else {
                    fprintf(stderr,"%s : warning BNP0000: WPPFMT ModQuerySymbols failed pMod = %p cbSyms = %d\n",
                            Fname, pMod, cbSyms);
                    break;
                }
            }
        }

        if (RSDSLibLoaded) {
            pDBIClose(pDbi);
        } else {
            DBIClose(pDbi);
        }
        fail2:   
        if (RSDSLibLoaded) {
            pPDBClose(pPdb);
        } else {
            PDBClose(pPdb);
        }
        fail1:
        if (TraceFileP) {
            fclose(TraceFileP);    // Close the last one
            TraceFileP = NULL ;
        }
        return errorCode;
    }
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\amd64\chksum.asm ===
title  "Compute Checksum"
;/*++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   chksum.asm
;
; Abstract:
;
;   This module implements a fucntion to compute the checksum of a buffer.
;
; Author:
;
;   David N. Cutler (davec) 25-Jan-2001
;
; Environment:
;
;   Any mode.
;
; Revision History:
;
;--*/

include ksamd64.inc

        subttl  "Checksum"
;++
;
; USHORT
; ChkSum(
;   IN ULONG cksum,
;   IN PUSHORT buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;   This function computes the checksum of the specified buffer.
;
; Arguments:
;
;   cksum (ecx) - Suppiles the initial checksum value.
;
;   buf (rdx) - Supplies a pointer to the buffer that is checksumed.
;
;   len (r8d) - Supplies the of the buffer in words.
;
; Return Value:
;
;    The computed checksum is returned as the function value.
;
;--

        LEAF_ENTRY ChkSum, _TEXT$00

        mov     eax, ecx                ; set initial checksum value
        mov     ecx, r8d                ; set length of buffer in words
        shl     ecx, 1                  ; convert to length in bytes
        jz      cks80                   ; if z, no words to checksum

;
; Compute checksum in cascading order of block size until 128 byte blocks
; are all that is left, then loop on 128-byte blocks.
;

        test    rdx, 02h                ; check if source dword aligned
        jz      short cks10             ; if z, source is dword aligned
        xor     r8, r8                  ; get initial word for alignment
        mov     r8w, [rdx]              ;
        add     eax, r8d                ; update partial checkcum
        adc     eax, 0                  ; add carry
        add     rdx, 2                  ; update source address
        sub     ecx, 2                  ; reduce length in bytes
cks10:  mov     r8d, ecx                ; isolate residual bytes
        and     r8d, 07h                ;
        sub     ecx, r8d                ; subtract residual bytes
        jz      cks60                   ; if z, no 8-byte blocks
        test    ecx, 08h                ; test if initial 8-byte block
        jz      short cks20             ; if z, no initial 8-byte block
        add     eax, [rdx]              ; compute 8-byte checksum
        adc     eax, 4[rdx]             ;
        adc     eax, 0                  ; add carry
        add     rdx, 8                  ; update source address
        sub     ecx, 8                  ; reduce length of checksum
        jz      cks60                   ; if z, end of 8-byte blocks
cks20:  test    ecx, 010h               ; test if initial 16-byte block
        jz      short cks30             ; if z, no initial 16-byte block
        add     eax, [rdx]              ; compute 16-byte checksum
        adc     eax, 4[rdx]             ;
        adc     eax, 8[rdx]             ;
        adc     eax, 12[rdx]            ;
        adc     eax, 0                  ; add carry
        add     rdx, 16                 ; update source address
        sub     ecx, 16                 ; reduce length of checksum
        jz      cks60                   ; if z, end of 8-byte blocks
cks30:  test    ecx, 020h               ; test if initial 32-byte block
        jz      short cks40             ; if z set, no initial 32-byte block
        add     eax, [rdx]              ; compute 32-byte checksum
        adc     eax, 4[rdx]             ;
        adc     eax, 8[rdx]             ;
        adc     eax, 12[rdx]            ;
        adc     eax, 16[rdx]            ;
        adc     eax, 20[rdx]            ;
        adc     eax, 24[rdx]            ;
        adc     eax, 28[rdx]            ;
        adc     eax, 0                  ; add carry
        add     rdx, 32                 ; update source address
        sub     ecx, 32                 ; reduce length of checksum
        jz      cks60                   ; if z, end of 8-byte blocks
cks40:  test    ecx, 040h               ; test if initial 64-byte block
        jz      cks50                   ; if z, no initial 64-byte block
        add     eax, [rdx]              ; compute 64-byte checksum
        adc     eax, 4[rdx]             ;
        adc     eax, 8[rdx]             ;
        adc     eax, 12[rdx]            ;
        adc     eax, 16[rdx]            ;
        adc     eax, 20[rdx]            ;
        adc     eax, 24[rdx]            ;
        adc     eax, 28[rdx]            ;
        adc     eax, 32[rdx]            ;
        adc     eax, 36[rdx]            ;
        adc     eax, 40[rdx]            ;
        adc     eax, 44[rdx]            ;
        adc     eax, 48[rdx]            ;
        adc     eax, 52[rdx]            ;
        adc     eax, 56[rdx]            ;
        adc     eax, 60[rdx]            ;
        adc     eax, 0                  ; add carry
        add     rdx, 64                 ; update source address
        sub     ecx, 64                 ; reduce length of checksum
        jz      cks60                   ; if z, end of 8-byte blocks
cks50:  add     eax, [rdx]              ; compute 128-byte checksum
        adc     eax, 4[rdx]             ;
        adc     eax, 8[rdx]             ;
        adc     eax, 12[rdx]            ;
        adc     eax, 16[rdx]            ;
        adc     eax, 20[rdx]            ;
        adc     eax, 24[rdx]            ;
        adc     eax, 28[rdx]            ;
        adc     eax, 32[rdx]            ;
        adc     eax, 36[rdx]            ;
        adc     eax, 40[rdx]            ;
        adc     eax, 44[rdx]            ;
        adc     eax, 48[rdx]            ;
        adc     eax, 52[rdx]            ;
        adc     eax, 56[rdx]            ;
        adc     eax, 60[rdx]            ;
        adc     eax, 64[rdx]            ;
        adc     eax, 68[rdx]            ;
        adc     eax, 72[rdx]            ;
        adc     eax, 76[rdx]            ;
        adc     eax, 80[rdx]            ;
        adc     eax, 84[rdx]            ;
        adc     eax, 88[rdx]            ;
        adc     eax, 92[rdx]            ;
        adc     eax, 96[rdx]            ;
        adc     eax, 100[rdx]           ;
        adc     eax, 104[rdx]           ;
        adc     eax, 108[rdx]           ;
        adc     eax, 112[rdx]           ;
        adc     eax, 116[rdx]           ;
        adc     eax, 120[rdx]           ;
        adc     eax, 124[rdx]           ;
        adc     eax, 0                  ; add carry
        add     rdx, 128                ; update source address
        sub     ecx, 128                ; reduce length of checksum
        jnz     short cks50             ; if nz, not end of 8-byte blocks

;
; Compute checksum on 2-byte blocks.
;

cks60:  test    r8d, r8d                ; check if any 2-byte blocks
        jz      short cks80             ; if z, no 2-byte blocks
        xor     ecx, ecx                ; clear entire register
cks70:  mov     cx, [rdx]               ; load 2-byte block
        add     eax, ecx                ; compute 2-byte checksum
        adc     eax, 0                  ;
        add     rdx, 2                  ; update source address
        sub     r8d, 2                  ; reduce length of checksum
        jnz     short cks70             ; if nz, more 2-bytes blocks

;
; Fold 32-but checksum into 16-bits
;

cks80:  mov     edx, eax                ; copy checksum value
        shr     edx, 16                 ; isolate high order bits
        and     eax, 0ffffh             ; isolate low order bits
        add     eax, edx                ; sum high and low order bits
        mov     edx, eax                ; isolate possible carry
        shr     edx, 16                 ;
        add     eax, edx                ; add carry
        and     eax, 0ffffh             ; clear possible carry bit
        ret                             ;

        LEAF_END ChkSum, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\binplace\binplace.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>
#include <crt\io.h>
#include <share.h>
#include <time.h>
#include <setupapi.h>
#include "splitsymx.h"
#include <string.h>
#include "wppfmt.h"
#include <VerifyFinalImage.h>
#include <GetNextArg.h>
#include <strsafe.h>

#ifndef MOVEFILE_CREATE_HARDLINK
    #define MOVEFILE_CREATE_HARDLINK  0x00000010
#endif

#define BINPLACE_ERR 77
#define BINPLACE_OK 0


// begin from PlaceFileMatch.c
#define BINPLACE_FULL_MAX_PATH 4096 // keep in sync with value in PlaceFileMatch.c
BOOL
PlaceFileMatch(
    IN     LPCSTR FullFileName,
    IN OUT LPSTR  PlaceFileEntry,   // May be modified by env. var expansion
    OUT    LPSTR  PlaceFileClass,   // assumed CHAR[BINPLACE_MAX_FULL_PATH]
    OUT    LPSTR *PlaceFileNewName);
// end

BOOL fUpDriver;
BOOL fBypassSplitSymX;
BOOL fUsage;
BOOL fVerbose;
BOOL fSymChecking;
BOOL fTestMode;
BOOL fSplitSymbols;
BOOL fPatheticOS;
BOOL fKeepAttributes;
BOOL fDigitalSign;
BOOL fHardLinks;
BOOL fIgnoreHardLinks;
BOOL fDontLog;
BOOL fPlaceWin95SymFile;
BOOL fNoClassInSymbolsDir;
BOOL fMakeErrorOnDumpCopy;
BOOL fDontExit;
BOOL fForcePlace;
BOOL fSignCode;
BOOL fVerifyLc;
BOOL fWppFmt;
BOOL fCheckDelayload;
BOOL fChangeAsmsToRetailForSymbols;
BOOL fSrcControl;
BOOL fDbgControl;
BOOL fLogPdbPaths;

HINSTANCE hSetupApi;
HINSTANCE hLcManager;
PVLCA     pVerifyLocConstraintA; // PVLCA defined in VerifyFinalImage.h

BOOL (WINAPI * pSetupGetIntField) (IN PINFCONTEXT Context, IN DWORD FieldIndex, OUT PINT IntegerValue);
BOOL (WINAPI * pSetupFindFirstLineA) (IN HINF InfHandle, IN PCSTR Section, IN PCSTR Key, OPTIONAL OUT PINFCONTEXT Context );
BOOL (WINAPI * pSetupGetStringFieldA) (IN PINFCONTEXT Context, IN DWORD FieldIndex, OUT PSTR ReturnBuffer, OPTIONAL IN DWORD ReturnBufferSize, OUT PDWORD RequiredSize);
HINF (WINAPI * pSetupOpenInfFileA) ( IN PCSTR FileName, IN PCSTR InfClass, OPTIONAL IN DWORD InfStyle, OUT PUINT ErrorLine OPTIONAL );
HINF (WINAPI * pSetupOpenMasterInf) (VOID);

ULONG SplitFlags = 0;

LPSTR CurrentImageName;
LPSTR PlaceFileName;
LPSTR PlaceRootName;
LPSTR ExcludeFileName;
LPSTR DumpOverride          = NULL;
LPSTR NormalPlaceSubdir;
LPSTR CommandScriptName;
LPSTR SymbolFilePath        = NULL;
LPSTR DestinationPath       = NULL;
LPSTR PrivateSymbolFilePath = NULL;
LPSTR BinplaceLcDir;
LPSTR LcFilePart;
LPSTR szRSDSDllToLoad;
LPSTR gNewFileName;
LPSTR gPrivatePdbFullPath=NULL;
LPSTR gPublicPdbFullPath=NULL;
HINF LayoutInf;

FILE *PlaceFile;
FILE *LogFile;
FILE *CommandScriptFile;
CHAR* gDelayLoadModule;
CHAR* gDelayLoadHandler;
CHAR gFullFileName[MAX_PATH+1];
CHAR gDestinationFile[MAX_PATH+1];

UCHAR SetupFilePath[ MAX_PATH+1 ];
UCHAR DebugFilePath[ MAX_PATH+1 ];
UCHAR PlaceFilePath[ MAX_PATH+1 ];
UCHAR ExcludeFilePath[ MAX_PATH+1 ];
UCHAR DefaultSymbolFilePath[ MAX_PATH+1 ];
UCHAR szAltPlaceRoot[ MAX_PATH+1 ];
UCHAR LcFullFileName[ MAX_PATH+1 ];
UCHAR szExtraInfo[4096];
UCHAR TraceFormatFilePath[ MAX_PATH+1 ] ;
UCHAR LastPdbName[ MAX_PATH+1 ] ;
UCHAR TraceDir[ MAX_PATH+1 ] ;

#define DEFAULT_PLACE_FILE    "\\tools\\placefil.txt"
#define DEFAULT_NTROOT        "\\nt"
#define DEFAULT_NTDRIVE       "c:"
#define DEFAULT_DUMP          "dump"
#define DEFAULT_LCDIR         "LcINF"
#define DEFAULT_EXCLUDE_FILE  "\\tools\\symbad.txt"
#define DEFAULT_TRACEDIR      "TraceFormat"
#define DEFAULT_DELAYLOADDIR  "delayload"

typedef struct _CLASS_TABLE {
    LPSTR ClassName;
    LPSTR ClassLocation;
} CLASS_TABLE, *PCLASS_TABLE;

BOOL
PlaceTheFile();

BOOL BinplaceGetSourcePdbName(LPTSTR SourceFileName, DWORD BufferSize, CHAR* SourcePdbName, DWORD* PdbSig);
//BOOL FileExists(LPTSTR Filename);

BOOL StripCVSymbolPath (LPSTR DestinationFile); // in StripCVSymbolPath.c

// concat 3 paths together handling the case where the second may be relative to the first
// or may be absolute
BOOL ConcatPaths( LPTSTR pszDest, size_t cbDest, LPCTSTR Root, LPCTSTR Symbols, LPCTSTR Ext);

typedef
BOOL
(WINAPI *PCREATEHARDLINKA)(
                          LPCSTR lpFileName,
                          LPCSTR lpExistingFileName,
                          LPSECURITY_ATTRIBUTES lpSecurityAttributes
                          );

PCREATEHARDLINKA pCreateHardLinkA;

// Symbol checking
#define MAX_SYM_ERR         500

BOOL
CheckSymbols( // in CheckSymbols.c
            LPSTR SourceFileName,
            LPSTR TmpPath,
            LPSTR ExcludeFileName,
            BOOL  SymbolFlag,
            LPSTR ErrMsg,
            size_t ErrMsgLen
            );

BOOL
CopyTheFile(
           LPSTR SourceFileName,
           LPSTR SourceFilePart,
           LPSTR DestinationSubdir,
           LPSTR DestinationFilePart
           );

BOOL
BinplaceCopyPdb (
                LPSTR DestinationFile,
                LPSTR SourceFileName,       // Used for redist case
                BOOL  CopyFromSourceOnly,
                BOOL  StripPrivate
                );

BOOL
SourceIsNewer( // in SourceIsNewer.c
             IN LPSTR SourceFile,
             IN LPSTR TargetFile,
             IN BOOL  fIsWin9x);

/* This is no longer used
__inline BOOL
 SearchOneDirectory(
                  IN  LPSTR Directory,
                  IN  LPSTR FileToFind,
                  IN  LPSTR SourceFullName,
                  IN  LPSTR SourceFilePart,
                  OUT PBOOL FoundInTree
                  )
{
    //
    // This was way too slow. Just say we didn't find the file.
    //
    *FoundInTree = FALSE;
    return(TRUE);
}
*/

BOOL SignWithIDWKey(IN  LPCSTR  FileName, IN BOOL fVerbose); // in SignWithIDWKey.c


CLASS_TABLE CommonClassTable[] = {
    {"retail",  "."},
    {"system",  "system32"},
    {"system16","system"},
    {"windows", "."},
    {"drivers", "system32\\drivers"},
    {"drvetc",  "system32\\drivers\\etc"},
    {"config",  "system32\\config"},
    {NULL,NULL}
};

CLASS_TABLE i386SpecificClassTable[] = {
    {"hal","system32"},
    {"printer","system32\\spool\\drivers\\w32x86"},
    {"prtprocs","system32\\spool\\prtprocs\\w32x86"},
    {NULL,NULL}
};

CLASS_TABLE Amd64SpecificClassTable[] = {
    {"hal",".."},
    {"printer","system32\\spool\\drivers\\w32amd64"},
    {"prtprocs","system32\\spool\\prtprocs\\w32amd64"},
    {NULL,NULL}
};

CLASS_TABLE ia64SpecificClassTable[] = {
    {"hal",".."},
    {"printer","system32\\spool\\drivers\\w32ia64"},
    {"prtprocs","system32\\spool\\prtprocs\\w32ia64"},
    {NULL,NULL}
    };



DWORD GetAndLogNextArg(         OUT TCHAR* Buffer,   // local wrapper for GetNextArg()
                                IN  DWORD  BufferSize,
                       OPTIONAL OUT DWORD* RequiredSize);
BOOL  PrintMessageLogBuffer(FILE* fLogHandle);      // write the buffer to fLogHandle
BOOL  FreeMessageLogBuffer(void);                   // free global arg buffer

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    BOOL gOnlyCopyArchiveFiles = FALSE;
    BOOL fBypassSplitSymX  = FALSE;

    char c, *p, *OverrideFlags, *s, **newargv=NULL;
    LPSTR LcFileName  = NULL;

    int i, n;
    BOOL NoPrivateSplit = FALSE;
    OSVERSIONINFO VersionInformation;
    LPTSTR platform;

    FILE * MsgLogFile;
    CHAR * MsgLogFileName;
    HANDLE hMutex;

    CHAR   ArgBuffer[MAX_PATH+1];
    DWORD  ArgSize = sizeof(ArgBuffer);
    DWORD  ArgSizeNeeded;

    CHAR* PlaceFileNameBuffer = NULL;
    CHAR* PlaceRootNameBuffer = NULL;
    CHAR  CommonTempBuffer[MAX_PATH+1];
    CHAR* CommonTempPtr;

    gNewFileName    = NULL;
    ImageCheck.Argv = NULL;

    fLogPdbPaths       = FALSE;
    gPrivatePdbFullPath= (CHAR*)malloc(sizeof(CHAR)*(MAX_PATH+1));
    gPublicPdbFullPath = (CHAR*)malloc(sizeof(CHAR)*(MAX_PATH+1));

    if (gPrivatePdbFullPath==NULL||gPublicPdbFullPath==NULL) {
        fprintf( stderr, "BINPLACE : error BNP0273: out of memory\n");
        exit(BINPLACE_ERR);
    }

    //
    // Win 95 can't compare file times very well, this hack neuters the SourceIsNewer function
    // on Win 95
    //
    VersionInformation.dwOSVersionInfoSize = sizeof( VersionInformation );
    if (GetVersionEx( &VersionInformation ) && VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        fPatheticOS = TRUE;
    }

    envp;
    fUpDriver = FALSE;
    fUsage = FALSE;
    fVerbose = FALSE;
    fSymChecking = FALSE;
    fTestMode = FALSE;
    fSplitSymbols = FALSE;
    fKeepAttributes = FALSE;
    fDigitalSign = FALSE;
    fHardLinks = FALSE;
    fIgnoreHardLinks = FALSE;
    fDontExit = FALSE;
    fForcePlace = FALSE;
    fSignCode = FALSE;
    fVerifyLc = FALSE;
    fWppFmt = FALSE ;
    fSrcControl = FALSE;
    fDbgControl = FALSE;
    NormalPlaceSubdir = NULL;
    pVerifyLocConstraintA = NULL;

    if (argc < 2) {
        goto showUsage;
    }

    if ( (szRSDSDllToLoad = (LPSTR) malloc((MAX_PATH+1) * sizeof(CHAR))) == NULL ) {
        fprintf( stderr, "BINPLACE : error BNP0322: Out of memory\n");
        exit(BINPLACE_ERR);
    }

    StringCbCopy( szRSDSDllToLoad, (MAX_PATH+1) * sizeof(CHAR), "mspdb70.dll");

    setvbuf(stderr, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    if (!(PlaceFileName = getenv( "BINPLACE_PLACEFILE" )) &&
        !(PlaceFileName = getenv( "BINPLACE_PLACEFILE_DEFAULT" ))) {
        if ((PlaceFileName = getenv("_NTDRIVE")) == NULL) {
            PlaceFileName = DEFAULT_NTDRIVE;
        }
        StringCbCopy((PCHAR) PlaceFilePath, sizeof(PlaceFilePath), PlaceFileName);
        if ((PlaceFileName = getenv("_NTROOT")) == NULL) {
            PlaceFileName = DEFAULT_NTROOT;
        }
        StringCbCat((PCHAR) PlaceFilePath, sizeof(PlaceFilePath), PlaceFileName);
        StringCbCat((PCHAR) PlaceFilePath, sizeof(PlaceFilePath), DEFAULT_PLACE_FILE);
        PlaceFileName = (PCHAR) PlaceFilePath;
    }

    if (!(ExcludeFileName = getenv( "BINPLACE_EXCLUDE_FILE" ))) {
        if ((ExcludeFileName = getenv("_NTDRIVE")) == NULL) {
            ExcludeFileName = DEFAULT_NTDRIVE;
        }
        StringCbCopy((PCHAR) ExcludeFilePath, sizeof(ExcludeFilePath), ExcludeFileName);
        if ((ExcludeFileName = getenv("_NTROOT")) == NULL) {
            ExcludeFileName = DEFAULT_NTROOT;
        }
        StringCbCat((PCHAR) ExcludeFilePath, sizeof(ExcludeFilePath), ExcludeFileName);
        StringCbCat((PCHAR) ExcludeFilePath, sizeof(ExcludeFilePath), DEFAULT_EXCLUDE_FILE);
        ExcludeFileName = (PCHAR) ExcludeFilePath;
    }

    if (!(BinplaceLcDir = getenv( "BINPLACE_LCDIR" ))) {
        BinplaceLcDir = DEFAULT_LCDIR;
    }

    if ( getenv("NT_SIGNCODE") != NULL ) {
        fSignCode=TRUE;
    }

    //
    // Support Cross compile as well
    //

#if defined(_AMD64_)
    ImageCheck.Machine = IMAGE_FILE_MACHINE_AMD64;
    PlaceRootName = getenv( "_NTAMD64TREE" );
#elif defined(_IA64_)
    ImageCheck.Machine = IMAGE_FILE_MACHINE_IA64;
    PlaceRootName = getenv( "_NTIA64TREE" );
#else // defined(_X86_)
    if ((platform = getenv("AMD64")) != NULL) {
        ImageCheck.Machine = IMAGE_FILE_MACHINE_AMD64;
        PlaceRootName = getenv( "_NTAMD64TREE" );
    } else if ((platform = getenv("IA64")) != NULL) {
        ImageCheck.Machine = IMAGE_FILE_MACHINE_IA64;
        PlaceRootName = getenv( "_NTIA64TREE" );
    } else {
        ImageCheck.Machine = IMAGE_FILE_MACHINE_I386;
        PlaceRootName = getenv( "_NT386TREE" );
        if (!PlaceRootName)
            PlaceRootName = getenv( "_NTx86TREE" );
    }
#endif


    CurrentImageName = NULL;

    OverrideFlags = getenv( "BINPLACE_OVERRIDE_FLAGS" );
    if (OverrideFlags != NULL) {
        s = OverrideFlags;
        n = 0;
        while (*s) {
            while (*s && *s <= ' ')
                s += 1;
            if (*s) {
                n += 1;
                while (*s > ' ')
                    s += 1;

                if (*s)
                    *s++ = '\0';
            }
        }

        if (n) {
            newargv = malloc( (argc + n + 1) * sizeof( char * ) );
            memcpy( &newargv[n], argv, argc * sizeof( char * ) );
            argv = newargv;
            argv[ 0 ] = argv[ n ];
            argc += n;
            s = OverrideFlags;
            for (i=1; i<=n; i++) {
                while (*s && *s <= ' ')
                    s += 1;
                argv[ i ] = s;
                while (*s++)
                    ;
            }

            __argv = argv; // required for GetNextArg()
            __argc = argc;
        }
    }


    // skip past exe name and don't log it
    GetNextArg(CommonTempBuffer, sizeof(CommonTempBuffer), NULL);

    while ( (ArgSizeNeeded = GetAndLogNextArg(ArgBuffer, ArgSize, NULL)) != 0 ) {

        p = ArgBuffer;
        if (*p == '/' || *p == '-') {
            if (_stricmp(p + 1, "ChangeAsmsToRetailForSymbols") == 0) {
                fChangeAsmsToRetailForSymbols = TRUE;
            } else {
              while (c = *++p)
                switch (toupper( c )) {
                    case '?':
                        fUsage = TRUE;
                        break;

                    case 'A':
                        SplitFlags |= SPLITSYM_EXTRACT_ALL;
                        break;

                    case 'B':
                        CommonTempPtr = (CHAR*)realloc(NormalPlaceSubdir, GetNextArgSize()*sizeof(CHAR));

                        if (CommonTempPtr==NULL) {
                            exit(BINPLACE_ERR);
                        }

                        NormalPlaceSubdir = CommonTempPtr;
                        GetAndLogNextArg(NormalPlaceSubdir, _msize(NormalPlaceSubdir), NULL);
                        break;

                    case 'C':
                        if (*(p+1) == 'I' || *(p+1) == 'i') {
                            char *q;

                            GetAndLogNextArg(CommonTempBuffer, sizeof(CommonTempBuffer), NULL);
                            p = CommonTempBuffer;
                            ImageCheck.RC = atoi(p);
                            if (!ImageCheck.RC) {
                                fprintf( stderr, "BINPLACE : error BNP0000: Invalid return code for -CI option\n");
                                fUsage = TRUE;
                            }
                            while (*p++ != ',');
                            q = p;
                            ImageCheck.Argc = 0;
                            while (*p != '\0')
                                if (*p++ == ',') ImageCheck.Argc++;
                            // last option plus extra args for Image file and Argv NULL
                            ImageCheck.Argc += 3;
                            ImageCheck.Argv = malloc( ImageCheck.Argc * sizeof( void * ) );
                            for ( i = 0; i <= ImageCheck.Argc - 3; i++) {
                                ImageCheck.Argv[i] = q;
                                while (*q != ',' && *q != '\0') q++;
                                *q++ = '\0';
                            }
                            p--;
                            ImageCheck.Argv[ImageCheck.Argc-1] = NULL;
                        } else {
                            fDigitalSign = TRUE;
                        }
                        break;

                    case 'D':
                        if (*(p+1) == 'L' || *(p+1) == 'l')
                        {
                            GetAndLogNextArg(CommonTempBuffer, sizeof(CommonTempBuffer), NULL);
                            p = CommonTempBuffer;
                            gDelayLoadModule = p;

                            while (*p != ',')
                            {
                                p++;
                            }
                            *p = '\0';
                            p++;
                            gDelayLoadHandler = p;

                            while (*p != '\0')
                            {
                                p++;
                            }
                            p--;

                            if (gDelayLoadModule[0] == '\0' ||
                                gDelayLoadHandler[0] == '\0')
                            {
                                fprintf(stderr, "BINPLACE : error BNP0000: Invalid switch for -dl option\n");
                                fUsage = TRUE;
                            }
                            else
                            {
                                fCheckDelayload = TRUE;
                            }
                        }
                        else
                        {
                            CommonTempPtr = (CHAR*)realloc(DumpOverride,GetNextArgSize()*sizeof(CHAR));

                            if (CommonTempPtr==NULL) {
                                exit(BINPLACE_ERR);
                            }

                            DumpOverride = CommonTempPtr;
                            GetAndLogNextArg(DumpOverride, _msize(DumpOverride), NULL);
                        }
                        break;

                    case 'E':
                        fDontExit = TRUE;
                        break;

                    case 'F':
                        fForcePlace = TRUE;
                        break;

                    case 'G':
                        CommonTempPtr = (CHAR*)realloc(LcFileName,GetNextArgSize()*sizeof(CHAR));

                        if (CommonTempPtr==NULL) {
                            exit(BINPLACE_ERR);
                        }
                        LcFileName = CommonTempPtr;
                        GetAndLogNextArg(LcFileName, _msize(LcFileName), NULL);
                        break;

                    case 'H':
                        if ((VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
                            (VersionInformation.dwMajorVersion < 5) ||
                            (pCreateHardLinkA = (PCREATEHARDLINKA)GetProcAddress( GetModuleHandle( "KERNEL32" ),
                                                                                  "CreateHardLinkA"
                                                                                )
                            ) == NULL
                           ) {
                            fprintf( stderr, "BINPLACE: Hard links not supported.  Defaulting to CopyFile\n" );
                            fHardLinks = FALSE;
                        } else {
                            fHardLinks = TRUE;
                        }

                        break;

                    case 'J':
                        fSymChecking = TRUE;
                        break;

                    case 'K':
                        fKeepAttributes = TRUE;
                        break;

                    case 'L':
                        break;

                    case 'M':
                        fMakeErrorOnDumpCopy = TRUE;
                        break;

                    case 'N':
                        CommonTempPtr = (CHAR*)realloc(PrivateSymbolFilePath,GetNextArgSize()*sizeof(CHAR));

                        if (CommonTempPtr==NULL) {
                            exit(BINPLACE_ERR);
                        }

                        PrivateSymbolFilePath = CommonTempPtr;
                        GetAndLogNextArg(PrivateSymbolFilePath, _msize(PrivateSymbolFilePath), NULL);
                        break;

                    case 'O':
                        if (PlaceRootName != NULL) {
                            StringCbCopy(szAltPlaceRoot, sizeof(szAltPlaceRoot), PlaceRootName);
                            StringCbCat( szAltPlaceRoot, sizeof(szAltPlaceRoot), "\\");
                            // concat next arg to the end of szAltPlaceRoot
                            GetAndLogNextArg( &szAltPlaceRoot[strlen(szAltPlaceRoot)],
                                        (sizeof(szAltPlaceRoot)/sizeof(CHAR)) - strlen(szAltPlaceRoot),
                                        NULL);
                            PlaceRootName = szAltPlaceRoot;
                        }
                        break;

                    case 'P':
                        CommonTempPtr = (CHAR*)realloc(PlaceFileNameBuffer,GetNextArgSize()*sizeof(CHAR));

                        if (CommonTempPtr==NULL) {
                            exit(BINPLACE_ERR);
                        }

                        PlaceFileNameBuffer = CommonTempPtr;
                        GetAndLogNextArg(PlaceFileNameBuffer, _msize(PlaceFileNameBuffer), NULL);
                        PlaceFileName = PlaceFileNameBuffer;
                        break;

                    case 'Q':
                        fDontLog = TRUE;
                        break;

                    case 'R':
                        CommonTempPtr = (CHAR*)realloc(PlaceRootNameBuffer,GetNextArgSize()*sizeof(CHAR));

                        if (CommonTempPtr==NULL) {
                            exit(BINPLACE_ERR);
                        }

                        PlaceRootNameBuffer = CommonTempPtr;
                        GetAndLogNextArg(PlaceRootNameBuffer, _msize(PlaceRootNameBuffer), NULL);
                        PlaceRootName = PlaceRootNameBuffer;
                        break;

                    case 'S':
                        CommonTempPtr = (CHAR*)realloc(SymbolFilePath,GetNextArgSize()*sizeof(CHAR));

                        if (CommonTempPtr==NULL) {
                            exit(BINPLACE_ERR);
                        }

                        SymbolFilePath = CommonTempPtr;
                        GetAndLogNextArg(SymbolFilePath, _msize(SymbolFilePath), NULL);

                        fSplitSymbols = TRUE;
                        fIgnoreHardLinks = TRUE;
                        break;

                    case 'T':
                        fTestMode = TRUE;
                        break;

                    case 'U':
                        fBypassSplitSymX = TRUE;
                        fUpDriver = TRUE;
                        break;

                    case 'V':
                        fVerbose = TRUE;
                        break;

                    case 'W':
                        fPlaceWin95SymFile = TRUE;
                        break;

                    case 'X':
                        SplitFlags |= SPLITSYM_REMOVE_PRIVATE;
                        break;

                    case 'Y':
                        fNoClassInSymbolsDir = TRUE;
                        break;

                    case 'Z':
                        NoPrivateSplit = TRUE;
                        break;

                    case ':':   // Simple (== crude) escape mechanism as all the letters are used
                                // -:XXX can add extra options if need be
                                // For now just handle TMF, Trace Message Format processing of PDB's
                        if ((strlen(p) >= 3) && ((toupper(*(p+1)) == 'T') && (toupper(*(p+2)) == 'M') && (toupper(*(p+3))) == 'F')) {
                            LPSTR tfile ;
                            // If the RUNWPP operation ran this option will be automatically added
                            p += 3 ; // Gobble up the TMF
                            fBypassSplitSymX = TRUE; // SplitSymbolsX() causes problems when used with -:TMF
                            fWppFmt = TRUE ;      // Need to package up the Software Tracing Formats
                            strncpy(TraceDir,DEFAULT_TRACEDIR,MAX_PATH) ;  //Append to PrivateSymbolsPath
                                                                           //If no default override.
                            tfile = getenv("TRACE_FORMAT_PATH");           //Has Path been overriden?
                            if (tfile != NULL) {
                                StringCbPrintfA(TraceFormatFilePath, sizeof(TraceFormatFilePath), "%s", tfile);
                                if (fVerbose) {
                                    fprintf( stdout, "BINPLACE : warning BNP0000: Trace Formats file path set to %s\n", TraceFormatFilePath ) ;
                                }
                            } else {
                                TraceFormatFilePath[0] = '\0' ;
                            }

                        } else if ((strlen(p) >= 3) && ((toupper(*(p+1)) == 'S') && (toupper(*(p+2)) == 'R') && (toupper(*(p+3))) == 'C')) {
                            // This is the option for turning on creating a cvdump for the pdb for
                            // source control.
                            p += 3;
                            fSrcControl=TRUE;

                        } else if ((strlen(p) >= 3) && ((toupper(*(p+1)) == 'R') && (toupper(*(p+2)) == 'E') && (toupper(*(p+3))) == 'N')) {
                            // cmdline file renaming
                            p += 3;
                            CommonTempPtr = (CHAR*)realloc(gNewFileName,GetNextArgSize()*sizeof(CHAR));

                            if (CommonTempPtr==NULL) {
                                exit(BINPLACE_ERR);
                            }

                            gNewFileName = CommonTempPtr;
                            GetAndLogNextArg(gNewFileName, _msize(gNewFileName), NULL);

                        } else if ((strlen(p) >= 3) && ((toupper(*(p+1)) == 'D') && (toupper(*(p+2)) == 'B') && (toupper(*(p+3))) == 'G')) {
                            // This is the option for turning on creating a cvdump for the pdb for
                            // source control.
                            p += 3;
                            fDbgControl=TRUE;
                        } else if ((strlen(p) >= 3) && ((toupper(*(p+1)) == 'A') && (toupper(*(p+2)) == 'R') && (toupper(*(p+3))) == 'C')) {
                            // only binplace the file if the ARCHIVE attribute is set
                            p += 3;
                            gOnlyCopyArchiveFiles=TRUE;
                        } else if ((strlen(p) == 5) && ((toupper(*(p+1)) == 'D') &&
                                                        (toupper(*(p+2)) == 'E') &&
                                                        (toupper(*(p+3)) == 'S') &&
                                                        (toupper(*(p+4)) == 'T'))) {
                            p += 4;
                            CommonTempPtr = (CHAR*)realloc(DestinationPath,GetNextArgSize()*sizeof(CHAR));

                            if (CommonTempPtr==NULL) {
                                exit(BINPLACE_ERR);
                            }

                            DestinationPath = CommonTempPtr;
                            GetAndLogNextArg(DestinationPath, _msize(DestinationPath), NULL);
                        } else if ((strlen(p) == 7) && ((toupper(*(p+1)) == 'L') &&
                                                        (toupper(*(p+2)) == 'O') &&
                                                        (toupper(*(p+3)) == 'G') &&
                                                        (toupper(*(p+4)) == 'P') &&
                                                        (toupper(*(p+5)) == 'D') &&
                                                        (toupper(*(p+6)) == 'B'))) {

                            fLogPdbPaths = TRUE;
                            p+=6;
                        }
                        break;


                    default:
                        fprintf( stderr, "BINPLACE : error BNP0000: Invalid switch - /%c\n", c );
                        fUsage = TRUE;
                        break;
                }
            }

            if ( fUsage ) {
                showUsage:
                fputs(
                     "usage: binplace [switches] image-names... \n"
                     "where: [-?] display this message\n"
                     "       [-a] Used with -s, extract all symbols\n"
                     "       [-b subdir] put file in subdirectory of normal place\n"
                     "       [-c] digitally sign image with IDW key\n"
                     "       [-d dump-override]\n"
                     "       [-:DBG] Don't binplace DBG files.  If -j is present, don't binplace \n"
                     "               binaries that point to DBG files.\n"
                     "       [-:DEST <class>] Don't bother with placefil.txt - just put the\n"
                     "               file(s) in the destination specified\n"
                     "       [-e] don't exit if a file in list could not be binplaced\n"
                     "       [-f] force placement by disregarding file timestamps\n"
                     "       [-g lc-file] verify image with localization constraint file\n"
                     "       [-h] modifies behavior to use hard links instead of CopyFile.\n"
                     "            (ignored if -s is present)\n"
                     "       [-j] verify proper symbols exist before copying\n"
                     "       [-k] keep attributes (don't turn off archive)\n"
                     "       [-:LOGPDB] include PDB paths in binplace.log\n"
                     "       [-m] binplace files to dump (generates an error also)\n"
                     "       [-n <Path>] Used with -x - Private pdb symbol path\n"
                     "       [-o place-root-subdir] alternate project subdirectory\n"
                     "       [-p place-file]\n"
                     "       [-q] suppress writing to log file %BINPLACE_LOG%\n"
                     "       [-r place-root]\n"
                     "       [-s Symbol file path] split symbols from image files\n"
                     "       [-:SRC] Process the PDB for source indexing\n"
                     "       [-t] test mode\n"
                     "       [-:TMF] Process the PDB for Trace Format files\n"
                     "       [-u] UP driver\n"
                     "       [-v] verbose output\n"
                     "       [-w] copy the Win95 Sym file to the symbols tree\n"
                     "       [-x] Used with -s, delete private symbolic when splitting\n"
                     "       [-y] Used with -s, don't create class subdirs in the symbols tree\n"
                     "       [-z] ignore -x if present\n"
                     "       [-ci <rc,app,-arg0,-argv1,-argn>]\n"
                     "            rc=application error return code,\n"
                     "            app=application used to check images,\n"
                     "            -arg0..-argn=application options\n"
                     "       [-dl <modulename,delay-load handler>] (run dlcheck on this file)\n"
                     "\n"
                     "BINPLACE looks for the following environment variable names:\n"
                     "   BINPLACE_EXCLUDE_FILE - full path name to symbad.txt\n"
                     "   BINPLACE_OVERRIDE_FLAGS - may contain additional switches\n"
                     "   BINPLACE_PLACEFILE - default value for -p flag\n"
                     "   _NT386TREE - default value for -r flag on x86 platform\n"
                     "   _NTAMD64TREE - default value for -r flag on AMD64 platform\n"
                     "   _NTIA64TREE - default value for -r flag on IA64 platform\n"
                     "   TRACE_FORMAT_PATH - set the path for Trace Format Files\n"
                     "\n"
                     ,stderr
                     );

                exit(BINPLACE_ERR);
            }

        } else {
            WIN32_FIND_DATA FindData;
            HANDLE h;

            gPrivatePdbFullPath[0]= '\0';
            gPublicPdbFullPath[0] = '\0';

            if (!PlaceRootName) {
                // If there's no root, just exit.
                exit(BINPLACE_OK);
            }

            //
            // Workaround for bogus setargv: ignore directories
            //
            if (NoPrivateSplit) {
                SplitFlags &= ~SPLITSYM_REMOVE_PRIVATE;
            }

            h = FindFirstFile(p,&FindData);
            if (h != INVALID_HANDLE_VALUE) {
                FindClose(h);
                if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    if ( fVerbose ) {
                        fprintf(stdout,"BINPLACE : warning BNP0000: ignoring directory %s\n",p);
                    }
                    continue;
                }

                if (gOnlyCopyArchiveFiles) {
                    if (! (FindData.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) ) {
                        if ( fVerbose ) {
                            fprintf(stdout,"BINPLACE : warning BNP1009: ignoring file without archive attribute %s\n",p);
                        }
                        continue;
                    }
                }

            }

            CurrentImageName = p;

            // If this is a dbg, don't binplace it
            if ( fDbgControl && (strlen(p) > 4)  &&
                 (strcmp(p+strlen(p)-4, ".dbg")== 0 ) ) {
               fprintf(stderr, "BINPLACE : warning BNP0000: Dbg files not allowed. Use dbgtopdb.exe to remove %s.\n",p);
               // exit(BINPLACE_ERR);
            }

            //
            // If the master place file has not been opened, open
            // it up.
            //

            if ( !PlaceFile && !DestinationPath) {
                PlaceFile = fopen(PlaceFileName, "rt");
                if (!PlaceFile) {
                    fprintf(stderr,"BINPLACE : fatal error BNP0000: fopen of placefile %s failed %d\n",PlaceFileName,GetLastError());
                    exit(BINPLACE_ERR);
                }
            }

            //
            // Check for bogus -g lc-file switch
            //
            if ( LcFileName != NULL ) {
                h = FindFirstFile(LcFileName, &FindData);
                if (h == INVALID_HANDLE_VALUE ||
                    (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    if (fVerbose ) {
                        fprintf(stdout,"BINPLACE : warning BNP0000: invalid file %s. Ignoring -G switch.\n", LcFileName);
                    }
                    LcFileName = NULL;
                }
                if (h != INVALID_HANDLE_VALUE) {
                    FindClose(h);
                }
            }
            if ( LcFileName != NULL ) {
                DWORD cb = GetFullPathName(LcFileName,MAX_PATH+1,LcFullFileName,&LcFilePart);
                if (!cb || cb > MAX_PATH+1) {
                    fprintf(stderr,"BINPLACE : fatal error BNP0000: GetFullPathName %s failed %d\n",LcFileName, GetLastError());
                    exit(BINPLACE_ERR);
                }

                hLcManager = LoadLibraryA("lcman.DLL");
                if (hLcManager != NULL) {
                    (VOID *) pVerifyLocConstraintA = GetProcAddress(hLcManager, "VerifyLocConstraintA");
                }
                if (pVerifyLocConstraintA != NULL) {
                    fVerifyLc = TRUE;
                } else {
                    fprintf(stdout,"BINPLACE : warning BNP0000: Unable to bind to the necessary LCMAN.DLL functions... Ignoring -G switch\n");
                }
            }

            if (PlaceRootName == NULL) {
                fprintf(stderr,"BINPLACE : fatal error BNP0000: Place Root not defined - exiting.\n");
                exit(BINPLACE_ERR);
            }

            // If the SymbolFilePath has not been set, make a default value.
            if (!SymbolFilePath) {
                StringCbCopy(DefaultSymbolFilePath, sizeof(DefaultSymbolFilePath), PlaceRootName);
                StringCbCat( DefaultSymbolFilePath, sizeof(DefaultSymbolFilePath), "\\symbols");
                SymbolFilePath = DefaultSymbolFilePath;
            }

            if ( !PlaceTheFile() ) {
                if (fDontExit) {
                    fprintf(stderr,"BINPLACE : error BNP0000: Unable to place file %s.\n",CurrentImageName);
                } else {
                    fprintf(stderr,"BINPLACE : fatal error BNP0000: Unable to place file %s - exiting.\n",CurrentImageName);
                    exit(BINPLACE_ERR);
                }
            } else {
            }
        }
    }

    if ( (MsgLogFileName = getenv("BINPLACE_MESSAGE_LOG")) != NULL) {
        if (!MakeSureDirectoryPathExists(MsgLogFileName)) {
            fprintf(stderr,"BINPLACE : error BNP0108: Unable to make directory to \"%s\"\n", MsgLogFileName);
        } else {
            hMutex = CreateMutex(NULL, FALSE, "WRITE_BINPLACE_MESSAGE_LOG");
            if (hMutex != NULL) {
                if ( WaitForSingleObject(hMutex, INFINITE) != WAIT_FAILED ) {
                    MsgLogFile = fopen(MsgLogFileName, "a");
                    if ( !MsgLogFile ) {
                        fprintf(stderr,"BINPLACE : error BNP0109: fopen of log file %s failed %d\n", MsgLogFileName,GetLastError());
                    } else {
                        setvbuf(MsgLogFile, NULL, _IONBF, 0);
                        PrintMessageLogBuffer(MsgLogFile);
                        fclose(MsgLogFile);
                    }
                    ReleaseMutex(hMutex);
                    CloseHandle(hMutex);
                } else {
                    fprintf(stderr,"BINPLACE : error BNP0997: failed to acquire mutex (error code 0x%x)\n", GetLastError());
                }
            } // hMutex != NULL
        }
    } // getenv("BINPLACE_MESSAGE_LOG")

    FreeMessageLogBuffer();

#define SafeFree(a) if (a!=NULL) { free(a); a=NULL; }
    SafeFree(NormalPlaceSubdir);
    SafeFree(DestinationPath);
    SafeFree(gNewFileName);
    SafeFree(PrivateSymbolFilePath);
    SafeFree(LcFileName);
    SafeFree(PlaceRootNameBuffer);
    SafeFree(PlaceFileNameBuffer);
    SafeFree(DumpOverride);
    SafeFree(szRSDSDllToLoad);
    SafeFree(ImageCheck.Argv);
    SafeFree(newargv);

    if (SymbolFilePath != DefaultSymbolFilePath) {
        SafeFree(SymbolFilePath);
    }

    if (PlaceFile)
        fclose(PlaceFile);

    exit(BINPLACE_OK);
    return BINPLACE_OK;
}

CHAR PlaceFileDir[  BINPLACE_FULL_MAX_PATH];
CHAR PlaceFileClass[BINPLACE_FULL_MAX_PATH];
CHAR PlaceFileEntry[BINPLACE_FULL_MAX_PATH];

BOOL
PlaceTheFile()
{
    CHAR FullFileName[MAX_PATH+1];
    LPSTR PlaceFileNewName;
    LPSTR FilePart;
    LPSTR Separator;
    LPSTR PlaceFileClassPart;
    DWORD cb;
    int cfield;
    PCLASS_TABLE ClassTablePointer;
    BOOLEAN ClassMatch;
    BOOL    fCopyResult;
    LPSTR Extension;
    BOOL PutInDump;
    BOOL PutInDebug = FALSE;
    BOOL PutInLcDir = FALSE;


    cb = GetFullPathName(CurrentImageName,MAX_PATH+1,FullFileName,&FilePart);

    if (!cb || cb > MAX_PATH+1) {
        fprintf(stderr,"BINPLACE : fatal error BNP0000: GetFullPathName failed %d\n",GetLastError());
        return FALSE;
    }

    if (!fDontLog) {
        StringCbCopy(gFullFileName,sizeof(gFullFileName),FullFileName);
    }

    if (fVerbose) {
        fprintf(stdout,"BINPLACE : warning BNP0000: Looking at file %s\n",FilePart);
    }

    Extension = strrchr(FilePart,'.');

    if (Extension) {
        if (!_stricmp(Extension,".DBG")) {
            PutInDebug = TRUE;
        }
        else if (!_stricmp(Extension,".LC")) {
            PutInLcDir = TRUE;
        }
    }

    if (!DumpOverride) {
        if (DestinationPath) {
            StringCbCopy(PlaceFileClass, sizeof(PlaceFileClass), DestinationPath);
            if (gNewFileName!=NULL) {
                PlaceFileNewName=gNewFileName;
            } else {
                PlaceFileNewName=NULL;
            }
            goto DoTheWork;
        }
        if (fseek(PlaceFile,0,SEEK_SET)) {
            fprintf(stderr,"BINPLACE : fatal error BNP0000: fseek(PlaceFile,0,SEEK_SET) failed %d\n",GetLastError());
            return FALSE;
        }

        while (fgets(PlaceFileEntry,sizeof(PlaceFileDir),PlaceFile)) {

            PlaceFileClass[0] = '\0';

            if( PlaceFileMatch( FullFileName,     // IN
                                PlaceFileEntry,   // INOUT
                                PlaceFileClass,   // OUT, assumed CHAR[BINPLACE_MAX_FULL_PATH]
                                &PlaceFileNewName // OUT
                               )) {

DoTheWork:
                //
                // now that we have the file and class, search the
                // class tables for the directory.
                //

                Separator = PlaceFileClass - 1;
                while (Separator) {

                    PlaceFileClassPart = Separator+1;
                    Separator = strchr(PlaceFileClassPart,':');
                    if (Separator) {
                        *Separator = '\0';
                    }

                    //
                    // If the class is "retail" and we're in Setup mode,
                    // handle this file specially. Setup mode is used to
                    // incrementally binplace files into an existing installation.
                    //
                    SetupFilePath[0] = '\0';

                    PlaceFileDir[0]='\0';
                    ClassMatch = FALSE;
                    ClassTablePointer = &CommonClassTable[0];
                    while (ClassTablePointer->ClassName) {
                        if (!_stricmp(ClassTablePointer->ClassName,PlaceFileClassPart)) {
                            StringCbCopy(PlaceFileDir,sizeof(PlaceFileDir),ClassTablePointer->ClassLocation);
                            ClassMatch = TRUE;

                            //
                            // If the class is a driver and a UP driver is
                            // specified, then put the driver in the UP
                            // subdirectory.
                            //
                            // Do the same for retail. We assume the -u switch is passed
                            // only when actually needed.
                            //
                            if (fUpDriver
                                && (   !_stricmp(PlaceFileClass,"drivers")
                                       || !_stricmp(PlaceFileClass,"retail"))) {
                                StringCbCat(PlaceFileDir,sizeof(PlaceFileDir),"\\up");
                            }
                            break;
                        }

                        ClassTablePointer++;
                    }

                    if (!ClassMatch) {
                        //
                        // Search Specific classes
                        //
                        // We need to support cross compiling here.
                        LPTSTR platform;

#if   defined(_AMD64_)
                        ClassTablePointer = &Amd64SpecificClassTable[0];
#elif defined(_IA64_)
                        ClassTablePointer = &ia64SpecificClassTable[0];
#else // defined(_X86_)
                        ClassTablePointer = &i386SpecificClassTable[0];
                        if ((platform = getenv("AMD64")) != NULL) {
                            ClassTablePointer = &Amd64SpecificClassTable[0];
                        } else if ((platform = getenv("IA64")) != NULL) {
                            ClassTablePointer = &ia64SpecificClassTable[0];
                        }
#endif
                        while (ClassTablePointer->ClassName) {

                            if (!_stricmp(ClassTablePointer->ClassName,PlaceFileClassPart)) {
                                StringCbCopy(PlaceFileDir,sizeof(PlaceFileDir),ClassTablePointer->ClassLocation);
                                ClassMatch = TRUE;
                                break;
                            }

                            ClassTablePointer++;
                        }
                    }

                    if (!ClassMatch) {

                        char * asterisk;

                        //
                        // Still not found in class table. Use the class as the
                        // directory
                        //

                        if ( fVerbose ) {
                            fprintf(stderr,"BINPLACE : warning BNP0000: Class %s Not found in Class Tables\n",PlaceFileClassPart);
                        }
                        if ( asterisk = strchr( PlaceFileClassPart, '*')) {
                            //
                            // Expand * to platform
                            //
                            LPTSTR platform;
                            ULONG PlatformSize;
                            LPTSTR PlatformPath;

#if   defined(_AMD64_)
                            PlatformSize = 5;
                            PlatformPath = TEXT("amd64");
#elif defined(_IA64_)
                            PlatformSize = 4;
                            PlatformPath = TEXT("ia64");
#else // defined(_X86_)
                            PlatformSize = 4;
                            PlatformPath = TEXT("i386");
                            if ((platform = getenv("IA64")) != NULL) {
                                PlatformPath = TEXT("ia64");
                            } else if ((platform = getenv("AMD64")) != NULL) {
                                PlatformSize = 5;
                                PlatformPath = TEXT("amd64");
                            }
#endif
                            *asterisk = '\0';
                            StringCbCopy(PlaceFileDir, sizeof(PlaceFileDir), PlaceFileClassPart);
                            *asterisk = '*';
                            StringCbCat( PlaceFileDir, sizeof(PlaceFileDir), PlatformPath);
                            StringCbCat( PlaceFileDir, sizeof(PlaceFileDir), asterisk + 1);

                        } else {
                            StringCbCopy(PlaceFileDir, sizeof(PlaceFileDir), PlaceFileClassPart);
                        }
                    }

                    if (SetupFilePath[0] == '\0') {
                        StringCbCopy(SetupFilePath, sizeof(SetupFilePath), PlaceFileDir);
                        StringCbCat( SetupFilePath, sizeof(SetupFilePath), "\\");
                        StringCbCat( SetupFilePath, sizeof(SetupFilePath), FilePart);
                    }

                    if (NormalPlaceSubdir) {
                        StringCbCat(PlaceFileDir, sizeof(PlaceFileDir), "\\");
                        StringCbCat(PlaceFileDir, sizeof(PlaceFileDir), NormalPlaceSubdir);
                    }

                    fCopyResult = CopyTheFile(FullFileName,FilePart,PlaceFileDir,PlaceFileNewName);
                    if (!fCopyResult) {
                        break;
                    }
                    if ( !fDontLog ) {
                        int len = 0;
                        LPSTR  LogFileName = NULL;
                        HANDLE hMutex;
                        time_t Time;
                        FILE  *fSlmIni;
                        UCHAR  szProject[MAX_PATH];
                        UCHAR  szSlmServer[MAX_PATH];
                        UCHAR  szEnlistment[MAX_PATH];
                        UCHAR  szSlmDir[MAX_PATH];
                        UCHAR *szTime="";
                        UCHAR  szFullDestName[MAX_PATH+1];
                        LPSTR  szDestFile;

                        // Get some other interesting info.
                        fSlmIni = fopen("slm.ini", "r");
                        if (fSlmIni) {
                            fgets(szProject, sizeof(szProject), fSlmIni);
                            fgets(szSlmServer, sizeof(szSlmServer), fSlmIni);
                            fgets(szEnlistment, sizeof(szEnlistment), fSlmIni);
                            fgets(szSlmDir, sizeof(szSlmDir), fSlmIni);
                            // Get rid of the trailing newlines
                            szProject[strlen(szProject)-1] = '\0';
                            szSlmServer[strlen(szSlmServer)-1] = '\0';
                            szSlmDir[strlen(szSlmDir)-1] = '\0';
                            fclose(fSlmIni);
                        } else {
                            szSlmServer[0] = '\0';
                            szProject[0] = '\0';
                            szSlmDir[0] = '\0';
                        }
                        Time = time(NULL);
                        szTime = ctime(&Time);

                        // Remove the built-in CR / NewLine
                        szTime[ strlen(szTime) - 1 ] = '\0';

                        StringCbPrintfA(szExtraInfo, sizeof(szExtraInfo),
                                "%s\t%s\t%s\t%s",
                                szSlmServer,
                                szProject,
                                szSlmDir,
                                szTime);

                        // Generate full path to destination
                        szFullDestName[0] = '\0';
                        GetFullPathName( gDestinationFile, MAX_PATH + 1, szFullDestName, &szDestFile );

                        if ((LogFileName = getenv("BINPLACE_LOG")) != NULL) {
                            if (!MakeSureDirectoryPathExists(LogFileName)) {
                                fprintf(stderr,"BINPLACE : error BNP0000: Unable to make directory to \"%s\"\n", LogFileName);
                            }

                            hMutex = CreateMutex(NULL, FALSE, "WRITE_BINPLACE_LOG");

                            if (hMutex != NULL) {
                                if ( WaitForSingleObject(hMutex, INFINITE) != WAIT_FAILED ) {
                                    LogFile = fopen(LogFileName, "a");
                                    if ( !LogFile ) {
                                        fprintf(stderr,"BINPLACE : error BNP0110: fopen of log file %s failed %d\n", LogFileName,GetLastError());
                                    } else {
                                        setvbuf(LogFile, NULL, _IONBF, 0);

                                        if ( fLogPdbPaths ) {
                                            len = fprintf(LogFile,"%s\t%s\t%s\t%s\t%s\n",gFullFileName,szExtraInfo,szFullDestName,gPublicPdbFullPath,gPrivatePdbFullPath);
                                        } else {
                                            len = fprintf(LogFile,"%s\t%s\t%s\n",gFullFileName,szExtraInfo,szFullDestName);
                                        }

                                        if ( len < 0 ) {
                                            fprintf(stderr,"BINPLACE : error BNP0000: write to log file %s failed %d\n", LogFileName, GetLastError());
                                        }
                                        fclose(LogFile);
                                    }
                                    ReleaseMutex(hMutex);
                                    CloseHandle(hMutex);
                                } else {
                                    fprintf(stderr,"BINPLACE : error BNP0970: failed to acquire mutex (error code 0x%x)\n", GetLastError());
                                }
                            } // hMutex != NULL
                        }
                    }
                }

                return(fCopyResult);
            }
        }
    }

    if (fMakeErrorOnDumpCopy) {
        fprintf(stderr, "BINPLACE : error BNP0000: File '%s' is not listed in '%s'. Copying to dump.\n", FullFileName, PlaceFileName);
        return CopyTheFile(
                   FullFileName,
                   FilePart,
                   PutInDebug ? "Symbols" : (PutInLcDir ? BinplaceLcDir : (DumpOverride ? DumpOverride : DEFAULT_DUMP)),
                   NULL
                   );
    } else {
        return TRUE;
    }
}

BOOL
CopyTheFile(
           LPSTR SourceFileName,
           LPSTR SourceFilePart,
           LPSTR DestinationSubdir,
           LPSTR DestinationFilePart
           )
{
    CHAR DestinationFile[MAX_PATH+1];
    CHAR TmpDestinationFile[MAX_PATH+1];
    CHAR TmpDestinationDir[MAX_PATH+1];
    CHAR DestinationLcFile[MAX_PATH+1];
    char Drive[_MAX_DRIVE];
    char Dir[_MAX_DIR];
    char Ext[_MAX_EXT];
    char Name[_MAX_FNAME];
    char TmpName[_MAX_FNAME];
    char TmpPath[_MAX_PATH+1];
    char FileSystemType[8];
    char DriveRoot[4];
    CHAR *TmpSymbolFilePath;
    DWORD dwFileSystemFlags;
    DWORD dwMaxCompLength;
    CHAR ErrMsg[MAX_SYM_ERR];   // Symbol checking error message
    BOOL fBinplaceLc;
    ULONG SymbolFlag;
    BOOL fRetail;

    if ( !PlaceRootName ) {
        fprintf(stderr,"BINPLACE : warning BNP0000: PlaceRoot is not specified\n");
        return FALSE;
    }

    if (fCheckDelayload && !_stricmp(SourceFilePart, gDelayLoadModule))
    {
        StringCbCopy(TmpDestinationFile, sizeof(TmpDestinationFile),  PlaceRootName);
        StringCbCat( TmpDestinationFile, sizeof(TmpDestinationFile), "\\");
        StringCbCat( TmpDestinationFile, sizeof(TmpDestinationFile), DEFAULT_DELAYLOADDIR);
        StringCbCat( TmpDestinationFile, sizeof(TmpDestinationFile), "\\");
        StringCbCat( TmpDestinationFile, sizeof(TmpDestinationFile), SourceFilePart);
        StringCbCat( TmpDestinationFile, sizeof(TmpDestinationFile), ".ini");

        if (!MakeSureDirectoryPathExists(TmpDestinationFile))
        {
            fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n", TmpDestinationFile, GetLastError());
        }
        else
        {
            WritePrivateProfileString("Default", "DelayLoadHandler", gDelayLoadHandler, TmpDestinationFile);

            StringCbCopy(TmpDestinationDir, sizeof(TmpDestinationDir), ".\\"); //default to "retail"

            if ((*DestinationSubdir != '.') && (*(DestinationSubdir+1) != '\0'))
            {
                StringCbCopy(TmpDestinationDir,sizeof(TmpDestinationDir), DestinationSubdir);
                StringCbCat( TmpDestinationDir,sizeof(TmpDestinationDir), "\\");
            }
            WritePrivateProfileString("Default", "DestinationDir", TmpDestinationDir, TmpDestinationFile);
        }
    }

    //
    // We also neuter SourceIsNewer on FAT partitions since they have a 2 second
    // file time granularity
    //
    _splitpath(SourceFileName, DriveRoot, Dir, NULL, NULL);
    StringCbCat(DriveRoot, sizeof(DriveRoot), "\\");
    GetVolumeInformation(DriveRoot, NULL, 0, NULL, &dwMaxCompLength, &dwFileSystemFlags, FileSystemType, 7);
    if (lstrcmpi(FileSystemType, "FAT") == 0 || lstrcmpi(FileSystemType, "FAT32") == 0)
        fPatheticOS = TRUE;

    StringCbCopy(DestinationFile, sizeof(DestinationFile), PlaceRootName);
    StringCbCat( DestinationFile, sizeof(DestinationFile), "\\");
    StringCbCat( DestinationFile, sizeof(DestinationFile), DestinationSubdir);
    StringCbCat( DestinationFile, sizeof(DestinationFile), "\\");

    StringCbCopy(TmpDestinationDir, sizeof(TmpDestinationDir), DestinationFile);


    if (!MakeSureDirectoryPathExists(DestinationFile)) {
        fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n",
                DestinationFile, GetLastError()
               );
    }

    if (DestinationFilePart) {
        StringCbCat(DestinationFile, sizeof(DestinationFile), DestinationFilePart);
    } else {
        StringCbCat(DestinationFile, sizeof(DestinationFile), SourceFilePart);
    }

    if ((fVerbose || fTestMode)) {
        fprintf(stdout,"BINPLACE : warning BNP0000: place %s in %s\n",SourceFileName,DestinationFile);
    }

//    SymbolFlag = IGNORE_IF_SPLIT;
    fRetail = (*DestinationSubdir == '.') && (*(DestinationSubdir+1) == '\0');
    if ( fForcePlace||SourceIsNewer(SourceFileName,DestinationFile,fPatheticOS) ) {
        fprintf(stdout, "binplace %s\n", SourceFileName);
        if (!VerifyFinalImage(SourceFileName, fRetail, fVerifyLc, LcFullFileName, pVerifyLocConstraintA, &fBinplaceLc) )
            return FALSE;

        // Verify Symbols
        if ( fSymChecking && !fSignCode) {
            _splitpath(SourceFileName,Drive, Dir, Name, Ext );
            StringCbCopy(TmpName, sizeof(TmpName), Name);
            StringCbCat( TmpName, sizeof(TmpName), Ext);
            StringCbCopy(TmpPath, sizeof(TmpPath), Drive);
            StringCbCat( TmpPath, sizeof(TmpPath), Dir);

            if (!CheckSymbols( SourceFileName,
                               TmpPath,
                               ExcludeFileName,
                               fDbgControl,
                               ErrMsg,
                               sizeof(ErrMsg)
                             ) ) {
                    fprintf(stderr,"BINPLACE : error BNP0000: %s",ErrMsg);
                    return FALSE;
            }
        }
    }

    // Store the destination globally so we can access it for output to the log file
    StringCbCopy( gDestinationFile, sizeof(gDestinationFile), DestinationFile );

    if (!fTestMode) {
        //
        // In Setup mode, copy the file only if it's newer than
        // the one that's already there.
        //
        if ( fForcePlace||SourceIsNewer(SourceFileName,DestinationFile,fPatheticOS) ) {
            if (fVerbose) {
                fprintf(stdout,"BINPLACE : warning BNP0000: copy %s to %s\n",SourceFileName,DestinationFile);
            }
        } else {
            return(TRUE);
        }

        SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);

        if (!fIgnoreHardLinks && fHardLinks) {
            if ((*pCreateHardLinkA)(SourceFileName, DestinationFile, NULL)) {
                if (!fKeepAttributes)
                    SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);
                return(TRUE);
            }
        }

        if ( !CopyFile(SourceFileName,DestinationFile, FALSE)) {
            fprintf(stderr,"BINPLACE : warning BNP0000: CopyFile(%s,%s) failed %d\n",SourceFileName,DestinationFile,GetLastError());

            return FALSE;
        }

        if (!fKeepAttributes)
            SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);

        if (!fNoClassInSymbolsDir) {
            StringCbCopy(TmpDestinationDir, sizeof(TmpDestinationDir), SymbolFilePath);
            if ((DestinationSubdir[0] == '.') && (DestinationSubdir[1] == '\0')) {
                StringCbCat(TmpDestinationDir, sizeof(TmpDestinationDir),"\\retail");
            } else {
                char * pSubdir;
                char * pTmp;
                StringCbCat(TmpDestinationDir, sizeof(TmpDestinationDir), "\\");

                pSubdir = DestinationSubdir;
                if (pSubdir[0] == '.' && pSubdir[1] == '\\')
                {
                    pSubdir += 2;
                }
                //
                // Put the root dir only on the path
                // Optionally change asms to retail.
                //
                pTmp = strchr(pSubdir, '\\');
                if (pTmp) {
                    const static char asms[] = "asms\\";
                    if (fChangeAsmsToRetailForSymbols
                        && _strnicmp(pSubdir, asms, sizeof(asms) - 1) ==0) {
                        //
                        StringCbCopy(TmpDestinationFile, sizeof(TmpDestinationFile), "retail");
                        StringCbCat( TmpDestinationDir,  sizeof(TmpDestinationDir), TmpDestinationFile);
                    } else {
                        StringCbCopy(TmpDestinationFile, sizeof(TmpDestinationFile), pSubdir);
                        TmpDestinationFile[pTmp - pSubdir] = '\0';
                        StringCbCat(TmpDestinationDir, sizeof(TmpDestinationDir), TmpDestinationFile);
                    }
                } else {
                    StringCbCat(TmpDestinationDir, sizeof(TmpDestinationDir), pSubdir);
                }
            }
            TmpSymbolFilePath = TmpDestinationDir;
        } else {
            TmpSymbolFilePath = SymbolFilePath;
        }

        if (fSplitSymbols && !fBypassSplitSymX) {
            // temp var for getting PDB path from SplitSymbolsX()
            CHAR   TempFullPublicPdbPath[MAX_PATH]="";
            LPSTR* tmp = NULL;

            _splitpath(SourceFileName, Drive, Dir, NULL, Ext);
            _makepath(DebugFilePath, Drive, Dir, NULL, NULL);
            SplitFlags |= SPLITSYM_SYMBOLPATH_IS_SRC;

            if ( SplitSymbolsX( DestinationFile, TmpSymbolFilePath, (PCHAR) DebugFilePath, sizeof(DebugFilePath),
                                SplitFlags, szRSDSDllToLoad, TempFullPublicPdbPath, sizeof(TempFullPublicPdbPath) )) {

                if (fVerbose)
                    fprintf( stdout, "BINPLACE : warning BNP0000: Symbols stripped from %s into %s\n", DestinationFile, DebugFilePath);

                if (fLogPdbPaths) {
                    if ( GetFullPathName(TempFullPublicPdbPath, MAX_PATH+1, gPublicPdbFullPath, tmp) > (MAX_PATH+1) ) {
                        gPublicPdbFullPath[0] = '\0';
                    }
                }

            } else {
                if (fVerbose)
                    fprintf( stdout, "BINPLACE : warning BNP0000: No symbols to strip from %s\n", DestinationFile);

                if ( ! ConcatPaths(DebugFilePath, sizeof(DebugFilePath), PlaceRootName, TmpSymbolFilePath, &Ext[1]) ) {
                    fprintf(stderr, "BINPLACE : error BNP1532: Unable to create public symbol file path.\n");
                    return(FALSE);
                } else {
                    if (fVerbose) {
                        fprintf( stdout, "BINPLACE : warning BNP1536: Public symbols being copied to %s.\n", DebugFilePath);
                    }
                }

                BinplaceCopyPdb(DebugFilePath, SourceFileName, TRUE, SplitFlags & SPLITSYM_REMOVE_PRIVATE);
            }

            if ((SplitFlags & SPLITSYM_REMOVE_PRIVATE) && (PrivateSymbolFilePath != NULL)) {
                CHAR Dir1[_MAX_PATH];
                CHAR Dir2[_MAX_PATH];
                _splitpath(DebugFilePath, Drive, Dir, NULL, NULL);
                _makepath(Dir1, Drive, Dir, NULL, NULL);
                StringCbCopy(Dir2, sizeof(Dir2), PrivateSymbolFilePath);
                StringCbCat( Dir2, sizeof(Dir2), Dir1+strlen(SymbolFilePath));
                MakeSureDirectoryPathExists(Dir2);
                BinplaceCopyPdb(Dir2, SourceFileName, TRUE, FALSE);
            }

        } else {
            BinplaceCopyPdb(DestinationFile, SourceFileName, FALSE, fSplitSymbols ? (SplitFlags & SPLITSYM_REMOVE_PRIVATE) : FALSE);
        }

        //
        // trace formatting
        //
        if (fWppFmt) {
            CHAR    PdbName[MAX_PATH+1];
            DWORD   PdbSig;


            if ( BinplaceGetSourcePdbName(SourceFileName, sizeof(PdbName), PdbName, &PdbSig) ) {
                if (strcmp(PdbName,LastPdbName) != 0) { // Have we just processed this PDB?

                    if (fVerbose) {
                        fprintf( stdout, "BINPLACE : warning BNP0000: Trace Formats being built from %s\n", PdbName );
                    }

                    if (TraceFormatFilePath[0] == '\0') {
                        if (PrivateSymbolFilePath != NULL) {
                            StringCbPrintfA(TraceFormatFilePath,sizeof(TraceFormatFilePath),"%s\\%s",PrivateSymbolFilePath,TraceDir);
                        } else {
                            strncpy(TraceFormatFilePath, TraceDir, MAX_PATH) ;
                        }

                        if (fVerbose) {
                            fprintf( stdout, "BINPLACE : warning BNP0000: Trace Formats file path set to %s\n", TraceFormatFilePath );
                        }
                    }

                    BinplaceWppFmt(PdbName, TraceFormatFilePath, szRSDSDllToLoad, fVerbose);

                    // because files are frequently copied to multiple places, the PDB is also placed
                    // several times, there is no point in us processing it more than once.
                    strncpy(LastPdbName,PdbName,MAX_PATH);

                } else {
                    if (fVerbose) {
                        fprintf( stdout, "BINPLACE : warning BNP0000: Trace Formats skipping %s (same as last)\n", PdbName );
                    }
                }
            }
        }

        StripCVSymbolPath(DestinationFile);

        if (fPlaceWin95SymFile) {
            char DestSymPath[_MAX_PATH];
            char DestSymDir[_MAX_PATH];
            char SrcSymPath[_MAX_PATH];

            _splitpath(CurrentImageName, Drive, Dir, Name, Ext);
            _makepath(SrcSymPath, Drive, Dir, Name, ".sym");

            if (!_access(SrcSymPath, 0)) {
                if (fSplitSymbols) {
                    StringCbCopy(DestSymPath, sizeof(DestSymPath), TmpSymbolFilePath);
                    StringCbCat( DestSymPath, sizeof(DestSymPath), "\\");
                    StringCbCat( DestSymPath, sizeof(DestSymPath), Ext[0] == '.' ? &Ext[1] : Ext);
                    StringCbCat( DestSymPath, sizeof(DestSymPath), "\\");
                    StringCbCat( DestSymPath, sizeof(DestSymPath), Name);
                    StringCbCat( DestSymPath, sizeof(DestSymPath), ".sym");
                } else {
                    _splitpath(DestinationFile, Drive, Dir, NULL, NULL);
                    _makepath(DestSymPath, Drive, Dir, Name, ".sym");
                }

                SetFileAttributes(DestSymPath, FILE_ATTRIBUTE_NORMAL);

                if ( fForcePlace||SourceIsNewer(SrcSymPath, SourceFileName,fPatheticOS) ) {
                    // Only binplace the .sym file if it was built AFTER the image itself.

                    // Make sure to create the destination path in case it is not there already.
                    StringCbCopy(DestSymDir, sizeof(DestSymDir), TmpSymbolFilePath);
                    StringCbCat( DestSymDir, sizeof(DestSymDir), "\\");
                    StringCbCat( DestSymDir, sizeof(DestSymDir), Ext[0] == '.' ? &Ext[1] : Ext);
                    StringCbCat( DestSymDir, sizeof(DestSymDir), "\\");
                    MakeSureDirectoryPathExists(DestSymDir);

                    if (!CopyFile(SrcSymPath, DestSymPath, FALSE)) {
                        fprintf(stderr,"BINPLACE : warning BNP0000: CopyFile(%s,%s) failed %d\n", SrcSymPath, DestSymPath ,GetLastError());
                    }
                }

                if (!fKeepAttributes)
                    SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);
            } else {
                if (fVerbose) {
                    fprintf( stdout, "BINPLACE : warning BNP0000: Unable to locate \"%s\" for \"%s\"\n", SrcSymPath, CurrentImageName );
                }
            }

        }

        if (fDigitalSign) {
            SignWithIDWKey( DestinationFile, fVerbose );
        }

        if (fBinplaceLc) {
            StringCbCopy(DestinationLcFile, sizeof(DestinationLcFile), PlaceRootName);
            StringCbCat( DestinationLcFile, sizeof(DestinationLcFile), "\\");
            StringCbCat( DestinationLcFile, sizeof(DestinationLcFile), BinplaceLcDir);
            StringCbCat( DestinationLcFile, sizeof(DestinationLcFile), "\\");
            StringCbCat( DestinationLcFile, sizeof(DestinationLcFile), DestinationSubdir);
            StringCbCat( DestinationLcFile, sizeof(DestinationLcFile), "\\");

            if (!MakeSureDirectoryPathExists(DestinationLcFile)) {
                fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n",
                        DestinationLcFile, GetLastError()
                       );
            }

            StringCbCat(DestinationLcFile, sizeof(DestinationLcFile), LcFilePart);

            if (!CopyFile(LcFullFileName, DestinationLcFile, FALSE)) {
               fprintf(stderr,"BINPLACE : warning BNP0000: CopyFile(%s,%s) failed %d\n",
                       LcFullFileName,DestinationLcFile,GetLastError());
            }
        }
    }

    return TRUE;
}

BOOL
BinplaceCopyPdb (
                LPSTR DestinationFile,
                LPSTR SourceFileName,
                BOOL CopyFromSourceOnly,
                BOOL StripPrivate
                )
{
    LOADED_IMAGE LoadedImage;
    DWORD DirCnt;
    IMAGE_DEBUG_DIRECTORY UNALIGNED *DebugDirs, *CvDebugDir;

    if (MapAndLoad(
                   CopyFromSourceOnly ? SourceFileName : DestinationFile,
                   NULL,
                   &LoadedImage,
                   FALSE,
                   CopyFromSourceOnly ? TRUE : FALSE) == FALSE) {
        return (FALSE);
    }

    DebugDirs = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData(
                                                                  LoadedImage.MappedAddress,
                                                                  FALSE,
                                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                                  &DirCnt
                                                                  );

    if (!DebugDirectoryIsUseful(DebugDirs, DirCnt)) {
        UnMapAndLoad(&LoadedImage);
        return(FALSE);
    }

    DirCnt /= sizeof(IMAGE_DEBUG_DIRECTORY);
    CvDebugDir = NULL;

    while (DirCnt) {
        DirCnt--;
        if (DebugDirs[DirCnt].Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
            CvDebugDir = &DebugDirs[DirCnt];
            break;
        }
    }

    if (!CvDebugDir) {
        // Didn't find any CV debug dir.  Bail.
        UnMapAndLoad(&LoadedImage);
        return(FALSE);
    }

    if (CvDebugDir->PointerToRawData != 0) {

        PCVDD pDebugDir;
        ULONG mysize;

        pDebugDir = (PCVDD) (CvDebugDir->PointerToRawData + (PCHAR)LoadedImage.MappedAddress);

        if (pDebugDir->dwSig == '01BN' ) {
            mysize=sizeof(NB10IH);
        } else {
            mysize=sizeof(RSDSIH);
        }

        if (pDebugDir->dwSig == '01BN' || pDebugDir->dwSig == 'SDSR' ) {
            // Got a PDB.  The name immediately follows the signature.
            LPSTR szMyDllToLoad;
            CHAR PdbName[sizeof(((PRSDSI)(0))->szPdb)];
            CHAR NewPdbName[sizeof(((PRSDSI)(0))->szPdb)];
            CHAR Drive[_MAX_DRIVE];
            CHAR Dir[_MAX_DIR];
            CHAR Filename[_MAX_FNAME];
            CHAR FileExt[_MAX_EXT];

            if (pDebugDir->dwSig == '01BN') {
                szMyDllToLoad=NULL;
            } else {
                szMyDllToLoad=szRSDSDllToLoad;
            }

            ZeroMemory(PdbName, sizeof(PdbName));
            memcpy(PdbName, ((PCHAR)pDebugDir) + mysize, __min(CvDebugDir->SizeOfData - mysize, sizeof(PdbName)));
            _splitpath(PdbName, NULL, NULL, Filename, FileExt);

            // Calculate the destination name
            _splitpath(DestinationFile, Drive, Dir, NULL, NULL);
            _makepath(NewPdbName, Drive, Dir, Filename, FileExt);

            // Then the source name.  First we try in the same dir as the image itself
            _splitpath(SourceFileName, Drive, Dir, NULL, NULL);
            _makepath(PdbName, Drive, Dir, Filename, FileExt);

            if ((fVerbose || fTestMode)) {
                fprintf(stdout,"BINPLACE : warning BNP0000: place %s in %s\n", PdbName, NewPdbName);
            }

            if (!MakeSureDirectoryPathExists(NewPdbName)) {
                fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n",
                        NewPdbName, GetLastError());
            }


            SetFileAttributes(NewPdbName,FILE_ATTRIBUTE_NORMAL);

            if (fLogPdbPaths) {
                LPTSTR *tmp=NULL;
                // when stripping privates, we get the public pdb path, otherwise we get the private pdb path
                if ( StripPrivate ) {
                    // use GetFullPathName to normalize path
                    if ( GetFullPathName(NewPdbName, MAX_PATH+1, gPublicPdbFullPath, tmp) > (MAX_PATH+1) ) {
                        gPublicPdbFullPath[0] = '\0';
                        fprintf(stderr,"BINPLACE : warning BNP1697: Unable to log PDB public path\n");
                    }
                } else {
                    // use GetFullPathName to normalize path
                    if ( GetFullPathName(NewPdbName, MAX_PATH+1, gPrivatePdbFullPath, tmp) > (MAX_PATH+1) ) {
                        gPrivatePdbFullPath[0] = '\0';
                        fprintf(stderr,"BINPLACE : warning BNP1691: Unable to log PDB private path\n");
                    }
                }
            }

            if ( !CopyPdbX(PdbName, NewPdbName, StripPrivate, szMyDllToLoad)) {
                if ((fVerbose || fTestMode)) {
                    fprintf(stderr,"BINPLACE : warning BNP0000: Unable to copy (%s,%s) %d\n", PdbName, NewPdbName, GetLastError());
                }

                // The file is not in the same dir as the image - try the path listed in the image
                ZeroMemory(PdbName, sizeof(PdbName));
                memcpy(PdbName, ((PCHAR)pDebugDir) + mysize, __min(CvDebugDir->SizeOfData - mysize, sizeof(PdbName)));

                if ((fVerbose || fTestMode)) {
                    fprintf(stdout,"BINPLACE : warning BNP0000: place %s in %s\n", PdbName, NewPdbName);
                }

                if ( !CopyPdbX(PdbName, NewPdbName, StripPrivate, szMyDllToLoad)) {
                    if (fLogPdbPaths) {
                        if ( StripPrivate ) {
                            gPublicPdbFullPath[0] = '\0';
                            fprintf(stderr,"BINPLACE : warning BNP1697: Unable to log PDB public path (%s)\n", NewPdbName);
                        } else {
                            gPrivatePdbFullPath[0] = '\0';
                            fprintf(stderr,"BINPLACE : warning BNP1697: Unable to log PDB private path (%s)\n", NewPdbName);
                        }
                    }
                    // fprintf(stderr,"BINPLACE : warning BNP0000: CopyPdb(%s,%s) failed %d\n", PdbName, NewPdbName, GetLastError());
                }
            }

            if (!fKeepAttributes)
                SetFileAttributes(NewPdbName, FILE_ATTRIBUTE_NORMAL);

            if (fSrcControl && !StripPrivate) {
                CHAR CvdumpName[sizeof(((PRSDSI)(0))->szPdb)]; // [_MAX_PATH + _MAX_FNAME];
                UINT i;
                LONG pos;
                CHAR buf[_MAX_PATH*3];

                // Find the start of "symbols.pri" in NewPdbName
                pos=-1;
                i=0;
                while ( (i < strlen(NewPdbName) - strlen("symbols.pri"))  && pos== -1) {
                    if (_strnicmp( NewPdbName+i, "symbols.pri", strlen("symbols.pri") ) == 0 ) {
                        pos=i;
                    } else {
                        i++;
                    }
                }

                if ( pos >= 0 ) {
                    StringCbCopy(CvdumpName, sizeof(CvdumpName), NewPdbName);
                    CvdumpName[i]='\0';
                    StringCbCat(CvdumpName, sizeof(CvdumpName), "cvdump.pri" );
                    StringCbCat(CvdumpName, sizeof(CvdumpName), NewPdbName + pos + strlen("symbols.pri") );
                    StringCbCat(CvdumpName, sizeof(CvdumpName), ".dmp");

                    // Get the Directory name and create it
                    if ( MakeSureDirectoryPathExists(CvdumpName) ) {
                        StringCbPrintfA(buf, sizeof(buf), "cvdump -sf %s > %s", NewPdbName, CvdumpName);
                        // Spawn off cvdump.exe - this is a security risk since we don't specifically specify the path
                        //                        to cvdump.exe.  However, we can't guarentee that it exists nor that
                        //                        if we find it dynamically that the correct one will be used so I'm not
                        //                        certain that we can do this any differently.
                        system(buf);
                    } else {
                        fprintf( stdout, "BINPLACE : error BNP0000: Cannot create directory for the file %s\n", CvdumpName);
                    }
                }
            }
        }
        UnMapAndLoad(&LoadedImage);
        return(TRUE);
    }

    UnMapAndLoad(&LoadedImage);
    return(FALSE);
}

//
// Finds the name of the source PDB using the CV data from the source binary. Returns the name and the
// PDB Sig.
//
BOOL BinplaceGetSourcePdbName(LPTSTR SourceFileName, DWORD BufferSize, CHAR* SourcePdbName, DWORD* PdbSig) {
    BOOL                             Return = FALSE;
    LOADED_IMAGE                     LoadedImage;
    DWORD                            DirCnt;
    IMAGE_DEBUG_DIRECTORY UNALIGNED *DebugDirs,
                                    *CvDebugDir;

    if (MapAndLoad(SourceFileName,
                   NULL,
                   &LoadedImage,
                   FALSE,
                   TRUE) == FALSE) {
        return (FALSE);
    }

    DebugDirs = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData(LoadedImage.MappedAddress,
                                                                  FALSE,
                                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                                  &DirCnt);

    if (!DebugDirectoryIsUseful(DebugDirs, DirCnt)) {
        UnMapAndLoad(&LoadedImage);
        return(FALSE);
    }

    DirCnt /= sizeof(IMAGE_DEBUG_DIRECTORY);
    CvDebugDir = NULL;

    while (DirCnt) {
        DirCnt--;
        if (DebugDirs[DirCnt].Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
            CvDebugDir = &DebugDirs[DirCnt];
            break;
        }
    }

    if (!CvDebugDir) {
        // Didn't find any CV debug dir.  Bail.
        UnMapAndLoad(&LoadedImage);
        return(FALSE);
    }

    if (CvDebugDir->PointerToRawData != 0) {

        PCVDD pDebugDir;
        ULONG mysize;

        pDebugDir = (PCVDD) (CvDebugDir->PointerToRawData + (PCHAR)LoadedImage.MappedAddress);

        *PdbSig = pDebugDir->dwSig;

        if (pDebugDir->dwSig == '01BN' ) {
            mysize=sizeof(NB10IH);
        } else {
            mysize=sizeof(RSDSIH);
        }

        if (pDebugDir->dwSig == '01BN' || pDebugDir->dwSig == 'SDSR' ) {
            // Got a PDB.  The name immediately follows the signature.
            LPSTR szMyDllToLoad;
            CHAR PdbName[sizeof(((PRSDSI)(0))->szPdb)];
            CHAR NewPdbName[sizeof(((PRSDSI)(0))->szPdb)];
            CHAR Drive[_MAX_DRIVE];
            CHAR Dir[_MAX_DIR];
            CHAR Filename[_MAX_FNAME];
            CHAR FileExt[_MAX_EXT];

            ZeroMemory(PdbName, sizeof(PdbName));
            StringCbCopy(PdbName, sizeof(PdbName), ((PCHAR)pDebugDir) + mysize);

            _splitpath(PdbName, NULL, NULL, Filename, FileExt);
            // Then the source name.  First we try in the same dir as the image itself
            _splitpath(SourceFileName, Drive, Dir, NULL, NULL);
            _makepath(SourcePdbName, Drive, Dir, Filename, FileExt);

            //
            // Handle the case where the PDB doesn't exist in the given location
            // by checking for it in the same directory as the binary!
            //

            // make sure the file exists and is readable
            if ( _access(SourcePdbName, 4) != 0 ) {
                // The file is not in the same dir as the image - try the path listed in the image
                memcpy(SourcePdbName, ((PCHAR)pDebugDir) + mysize, __min(CvDebugDir->SizeOfData - mysize, BufferSize));

                // make sure the file exists and is readable
                if ( _access(SourcePdbName, 4) == 0 ) {
                    Return = TRUE;
                }
            } else {
                Return = TRUE;
            }
        }

        UnMapAndLoad(&LoadedImage);
        return(TRUE);
    }

    UnMapAndLoad(&LoadedImage);
    return(FALSE);
}

// shared globals for InitMessageBufferWithCwd(), GetAndLogNextArg() and PrintMessageLogBuffer()
static CHAR * MessageLogBuffer= NULL;
static BOOL   MessageLogError = FALSE;

// puts CWD into MessageLogBuffer
BOOL InitMessageBufferWithCwd(void) {
    BOOL    fRetVal = FALSE;

    if ( GetCurrentDirectory(_msize(MessageLogBuffer)/sizeof(TCHAR), MessageLogBuffer) == 0 ) {
        // use GetLastError() to find the specifics- all I care about here is
        // whether we succeeded or not.
        fRetVal = FALSE;
    } else {
        if (StringCbCat(MessageLogBuffer, _msize(MessageLogBuffer), " ") != S_OK) {
            fRetVal = FALSE;
        } else {
            fRetVal = TRUE;
        }
    }

    return(fRetVal);
}

// Calls GetNextArg and logs the result
DWORD GetAndLogNextArg(OUT TCHAR* Buffer, IN DWORD BufferSize, OPTIONAL OUT DWORD* RequiredSize) {
    DWORD TempValue = GetNextArg(Buffer, BufferSize, RequiredSize);
    CHAR* TempBuffer;

    if (MessageLogBuffer == NULL) {

        MessageLogBuffer = (CHAR*)malloc(sizeof(CHAR)*1024); // initial size

        // make sure we have memory
        if ( MessageLogBuffer == NULL ) {
            MessageLogError = TRUE;
            fprintf(stderr,"BINPLACE : warning BNP1771: Unable log command line.");

        // stick CWD into buffer
        } else if ( ! InitMessageBufferWithCwd() ) {
            MessageLogError = TRUE;
            fprintf(stderr,"BINPLACE : warning BNP1771: Unable log command line.");

        // add this arg to the buffer
        } else if ( StringCbCat(MessageLogBuffer, _msize(MessageLogBuffer), Buffer) != S_OK||
                    StringCbCat(MessageLogBuffer, _msize(MessageLogBuffer), " ")    != S_OK) {
            MessageLogError = TRUE;
            fprintf(stderr,"BINPLACE : warning BNP1771: Unable log command line.");
        }

    } else {
        if (_msize(MessageLogBuffer) < strlen(MessageLogBuffer) + strlen(Buffer) + 2) {
            TempBuffer = (CHAR*)realloc(MessageLogBuffer, _msize(MessageLogBuffer) + 1024);
            if (TempBuffer == NULL) {
                MessageLogError = TRUE;
                fprintf(stderr,"BINPLACE : warning BNP1779: Unable log command line.");
            } else {
                MessageLogBuffer = TempBuffer;
                if (StringCbCat(MessageLogBuffer, _msize(MessageLogBuffer), Buffer) != S_OK) {
                    MessageLogError = TRUE;
                    fprintf(stderr,"BINPLACE : warning BNP1783: Unable log command line.");
                }
                if (StringCbCat(MessageLogBuffer, _msize(MessageLogBuffer), " ") != S_OK) {
                    MessageLogError = TRUE;
                    fprintf(stderr,"BINPLACE : warning BNP1783: Unable log command line.");
                }
            }
        } else {
            if (StringCbCat(MessageLogBuffer, _msize(MessageLogBuffer), Buffer) != S_OK) {
                MessageLogError = TRUE;
                fprintf(stderr,"BINPLACE : warning BNP1783: Unable log command line.");
            }
            if (StringCbCat(MessageLogBuffer, _msize(MessageLogBuffer), " ") != S_OK) {
                MessageLogError = TRUE;
                fprintf(stderr,"BINPLACE : warning BNP1783: Unable log command line.");
            }
        }
    }

    return(TempValue);
}

// writes LogBuffer to supplied handle
BOOL PrintMessageLogBuffer(FILE* fLogHandle) {
    BOOL bRetVal = TRUE;

    if (fLogHandle != NULL) {
        if (MessageLogError) {
            // ';' denotes the beginning of a comment in the binplace message log
            // write what we can of the command line and note that it might not be valid
            // also, write the line as a comment to avoid accicental execution of it.
            fprintf(fLogHandle, "; ERROR: Possible bad command line follows\n");
            fprintf(fLogHandle, "; %s\n", MessageLogBuffer);
        } else {
            fprintf(fLogHandle, "%s\n", MessageLogBuffer);
        }

    }
    return(bRetVal);
}

BOOL FreeMessageLogBuffer(void) {
    if (MessageLogBuffer != NULL) {
        free(MessageLogBuffer);
        MessageLogBuffer = NULL;
    }
    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
//
// Local replacement for GetFullPathName that correctly handles lpFileName when
// it begins with '\'
//
DWORD PrivateGetFullPathName(LPCTSTR lpFilename, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart) {
    DWORD Return = 0;
    CHAR* ch;

    //
    // GetFullPath flounders when referring to the root of the drive, so use
    // a private version that handles it
    //
    if ( lpFilename[0] == '\\' ) {

        //  handle network paths
        if ( lpFilename[1] == '\\' ) {
            if ( StringCchCopy(lpBuffer, nBufferLength, lpFilename)!=S_OK ) {
                Return = 0;
            } else {
                // fill in the return data
                ch = strrchr(lpBuffer, '\\');
                ch++;
                lpFilePart = (LPTSTR*)ch;
                Return = strlen(lpBuffer);
            }

        } else {
            Return = GetCurrentDirectory(nBufferLength, lpBuffer);

            // truncate everything after drive name
            if ( (Return!=0) &&  (Return <= MAX_PATH+1)) {
                ch = strchr(lpBuffer, '\\');
                if (ch!=NULL) {
                    *ch = '\0';
                }

                // push in the filename
                if ( StringCchCat(lpBuffer, nBufferLength, lpFilename)!=S_OK ) {
                    Return = 0;
                } else {
                    // fill in the return data
                    ch = strrchr(lpBuffer, '\\');
                    ch++;
                    lpFilePart = (LPTSTR*)ch;
                    Return = strlen(lpBuffer);
                }
            } else {
                // return the needed size
            }
        }
    } else {
        //
        // Not refering to drive root, just call the API
        //
        Return = GetFullPathName(lpFilename, nBufferLength, lpBuffer, lpFilePart);
    }

    return(Return);
}

//////////////////////////////////////////////////////////////////////////////////////////////
// concat 3 paths together handling the case where the second may be relative to the first
// or may be absolute
BOOL ConcatPaths( LPTSTR pszDest, size_t cbDest, LPCTSTR Root, LPCTSTR Symbols, LPCTSTR Ext) {
    CHAR*   TempPath = malloc(sizeof(TCHAR) * cbDest);
    LPTSTR Scratch;

    if (TempPath == NULL) {
        return(FALSE);
    }

    if (Symbols[1] == ':') { // symbols contains a drive spec
            if ( StringCbCopy(TempPath, cbDest, Symbols) != S_OK ) {
                free(TempPath);
                return(FALSE);
            }
    } else if (Symbols[0] == '\\') { // symbols contains a root path or UNC path

        if ( Symbols[1] == '\\' ) { // UNC path
            if ( StringCbCopy(TempPath, cbDest, Symbols) != S_OK ) {
                free(TempPath);
                return(FALSE);
            }
        } else {  // path from drive root
            CHAR drive[_MAX_DRIVE];
            CHAR dir[  _MAX_DIR];
            CHAR file[ _MAX_FNAME];
            CHAR ext[  _MAX_EXT];

            _splitpath(Root, drive, dir, file, ext);

            if ( StringCbCopy(TempPath, cbDest, drive) != S_OK ) {
                free(TempPath);
                return(FALSE);
            }
            if ( StringCbCat(TempPath, cbDest, Symbols) != S_OK ) {
                free(TempPath);
                return(FALSE);
            }
        }

    } else {
        if ( StringCbCopy(TempPath, cbDest, Root) != S_OK ) {
            free(TempPath);
            return(FALSE);
        }

        if ( TempPath[strlen(TempPath)] != '\\' ) {
            if ( StringCbCat(TempPath, cbDest, "\\") != S_OK ) {
                free(TempPath);
                return(FALSE);
            }
        }

        if ( StringCbCat(TempPath, cbDest, Symbols) != S_OK ) {
            free(TempPath);
            return(FALSE);
        }
    }

    if ( TempPath[strlen(TempPath)] != '\\' && Ext[0] != '\\' ) {
        if ( StringCbCat(TempPath, cbDest, "\\") != S_OK ) {
            free(TempPath);
            return(FALSE);
        }
    }

    if ( StringCbCat(TempPath, cbDest, Ext) != S_OK ) {
        free(TempPath);
        return(FALSE);
    }

    // final string needs to end in '\\'
    if ( StringCbCat(TempPath, cbDest, "\\") != S_OK ) {
        free(TempPath);
        return(FALSE);
    }

    // return size doesn't include final \0, so don't use '<='
    if ( PrivateGetFullPathName(TempPath, cbDest, pszDest, &Scratch) < cbDest ) {
        free(TempPath);
        return(TRUE);
    } else {
        free(TempPath);
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\binplace\getnextarg.h ===
#include <windows.h>
#include <tchar.h>

// loads the next argument into Buffer
DWORD GetNextArg(OUT TCHAR* Buffer, IN DWORD BufferSize, OPTIONAL OUT DWORD* RequiredSize);

// returns the size (in char count) required to hold the next argument (** including \0 **)
DWORD GetNextArgSize(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\binplace\getnextarg.c ===
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <GetNextArg.h>
#include <strsafe.h>

extern BOOL fVerbose; // linked in from binplace.c

// structure for recording current state of
// an argument vector
typedef struct _ARG_INFO {
    TCHAR**     ArgV;
    INT         MaxArgC;
    INT         NextArgC;
} ARG_INFO;

// global variables for same
static ARG_INFO     RespFileArgs;
static ARG_INFO     CmdLineArgs;

// flag to let us know if we're currently in a response
// file or not.  Initially, we're not so init to FALSE
static BOOL         fInRespFile = FALSE;

// flag to let us know if this is the first call to GetNextArg()
static BOOL         fFirstCall  = TRUE;

// CRT global used by _setargv()
_CRTIMP extern char *_acmdln;

// struct for __getmainargs()
typedef struct { int newmode; } _startupinfo;

// decl for _getmainargs() - expands _acmdln to (__argc, __argv)
_CRTIMP int __cdecl __getmainargs (int *pargc, char ***pargv, char ***penvp, int dowildcard, _startupinfo * startinfo);

// local functions
DWORD CopyArgIntoBuffer(TCHAR* Dst, TCHAR* Src, INT DstSize);

/* ------------------------------------------------------------------------------------------------
    GetNextArgSize : returns the size required to hold the next argument
    ** SEE ASSUMPTIONS AND LIMITATIONS REGARDING GetNextArg() BELOW **
------------------------------------------------------------------------------------------------ */
DWORD GetNextArgSize(void) {

    TCHAR  TempBuffer[1];             // minimal buffer to pass to GetNextArg
    DWORD  dwNextRequiredSize = 0;    // return value
    DWORD  dwTempValue;               // temp DWORD for GetNextArg() return value

    // instead of mimicing GetNextArg, we'll just call it then rollback the correct globals
    dwTempValue = GetNextArg(TempBuffer, 1, &dwNextRequiredSize);

    // roll back the relevent global
    if (fInRespFile) {
        RespFileArgs.NextArgC--;
    } else {
        CmdLineArgs.NextArgC--;
    }

    return(dwNextRequiredSize);
}

/* ------------------------------------------------------------------------------------------------
    GetNextArg : returns next argument in array including opening and expending reponse files
                 given on the command line

    Buffer is the buffer to copy the next argument into
    BufferSize is the size of Buffer in characters
    RequiredSize, if not NULL, is set to the actual size required for the parameter (inluding '\0').
        This is useful for determining whether a return value of 0 is an error or end of arguments.

    Return value is the number of characters copied including \0.
        if return value is 0 and RequiredSize is non-zero, an error occurred - check GetLastError()
        if return value is 0 and RequiredSize is zero, no more arguments are available

    Assumptions: the calling program does not modify _acmdln, __argv, __argc
                 the calling program ignores main's (int, char**)

    Limitations: does not work with UNICODE response files (not tested when built w/ -D_UNICODE)
                 response files may not include response files
                 literal parameter beginning with '@' is returned if:
                    - parameter is found in a response file --OR--
                    - the named file cannot be opened       --OR--
                    - the named file won't fit in memory
                 environment strings in repsonse file are not expanded
------------------------------------------------------------------------------------------------ */
DWORD GetNextArg(OUT TCHAR* Buffer, IN DWORD BufferSize, OPTIONAL OUT DWORD* RequiredSize) {
    DWORD   dwReturnValue; // value to return

    HANDLE* RespFile;      // for reading in a new response file
    TCHAR*  TempBuffer;
    TCHAR*  pTchar;
    TCHAR*  pBeginBuffer;
    DWORD   dwSize;

    // first-call initialization
    if (fFirstCall) {
        CmdLineArgs.ArgV      = __argv; // set to initial __argv
        CmdLineArgs.MaxArgC   = __argc; // set to initial __argc
        CmdLineArgs.NextArgC  = 0;      // no args used yet

        RespFileArgs.ArgV     = NULL;
        RespFileArgs.MaxArgC  = 0;
        RespFileArgs.NextArgC = -1;

        fFirstCall = FALSE;
    }

    // buffer cannot be null
    if (Buffer == NULL) {

        SetLastError(ERROR_INVALID_PARAMETER);
        dwReturnValue = 0;

        if (fVerbose)
            fprintf(stderr,"BINPLACE : warning GNA0113: Passed NULL buffer\n");

    } else {

        // handle getting next arg when reading a response file
        if (fInRespFile) {

            // was the previous arg the last one from the file
            if (RespFileArgs.NextArgC >= RespFileArgs.MaxArgC) {

                if (fVerbose)
                    fprintf(stderr,"BINPLACE : warning GNA0127: Response file finished\n");

                // yes, so clear the flag and skip to reading the next value from the cmdline
                fInRespFile = FALSE;
                goto UseArgV;

            } else {

                // fill in the required size
                if (RequiredSize != NULL) {
                    *RequiredSize = _tcsclen(RespFileArgs.ArgV[RespFileArgs.NextArgC])+1;
                }

                // no, so fill in Buffer and advanced NextArgC
                dwReturnValue = CopyArgIntoBuffer(Buffer, RespFileArgs.ArgV[RespFileArgs.NextArgC++], BufferSize);

            }

        // handle getting next cmdline arg
        } else {
UseArgV:
            // was the previous arg the last one?       
            if (CmdLineArgs.NextArgC >= CmdLineArgs.MaxArgC) {

                // yes, so set safe return values
                if (RequiredSize != NULL) {
                    *RequiredSize = 0;
                }

                Buffer[0]     = TEXT('\0');
                dwReturnValue = 0;

                if (fVerbose)
                    fprintf(stderr,"BINPLACE : warning GNA0127: Command line finished\n");

            } else {
                // no, so ge the next arg

                // is the next arg a response file?
                if (CmdLineArgs.ArgV[CmdLineArgs.NextArgC][0] == '@') {

                    // yes, try to open it
                    RespFile=CreateFile((CmdLineArgs.ArgV[CmdLineArgs.NextArgC]+1), // don't include '@'
                                        GENERIC_READ,  0,                        NULL,
                                        OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN,(HANDLE)NULL);

                    if (RespFile != INVALID_HANDLE_VALUE) {

                        if (fVerbose)
                            fprintf(stderr,"BINPLACE : warning GNA0174: Using response file: %s \n",(CmdLineArgs.ArgV[CmdLineArgs.NextArgC]+1));

                        // advance CmdLineArgs.NextArgC so we don't try to load the file again as
                        // soon as it's finished
                        CmdLineArgs.NextArgC++;

                        // file opened - get the size required to load it into memory
                        dwSize=GetFileSize(RespFile,NULL);

                        // try to get enough memory to load the file
                        TempBuffer = (TCHAR*)malloc(sizeof(TCHAR)*(dwSize+1));

                        if (TempBuffer != NULL) {

                            // store a pointer to the start of the buffer
                            pBeginBuffer = TempBuffer; 

                            // zero the memory then load the file
                            ZeroMemory(TempBuffer, _msize(TempBuffer));
                            ReadFile(RespFile,TempBuffer, _msize(TempBuffer),&dwSize,NULL);

                            // ensure NULL termination
                            TempBuffer[dwSize]='\0';

                            // map \r and \n to spaces because _setargv won't do it for us
                            while (pTchar=strchr(TempBuffer,'\r')) {

                                *pTchar = ' ';
                                pTchar++;

                                if (*pTchar == '\n') {
                                    *pTchar = ' ';
                                }

                            }

                            // setargv dislikes odd leading characters, so step past them
                            while ( ( (!isprint(TempBuffer[0])) ||
                                      ( isspace(TempBuffer[0])) ) &&
                                    (   TempBuffer[0] != 0      ) ) {
                                TempBuffer++;
                            }

                            // how to handle this case? response file existed but contained no data??
                            if (_tcsclen(TempBuffer) > 0) {
                                // required for call to getmainargs()
                                _startupinfo SInfo = {0};
                                CHAR**       Unused;

                                // _setargv() expects _acmdln to point to the string to convert
                                _acmdln = TempBuffer;

                                // actually convert the string
                                if ( __getmainargs(&RespFileArgs.MaxArgC, &RespFileArgs.ArgV, &Unused, 1, &SInfo) < 0 ) {
                                    if (fVerbose) 
                                        fprintf(stderr,"BINPLACE : warning GNA0230: Failed to get args from response file- skipping it\n");
                                    goto UseArgV;
                                }

                                // clean up temp resources
                                free(pBeginBuffer);
                                CloseHandle(RespFile);

                                // init the global structure
                                RespFileArgs.NextArgC = 0;
                                fInRespFile = TRUE;

                                // fill in the required size
                                if (RequiredSize != NULL) {
                                    *RequiredSize = _tcsclen(RespFileArgs.ArgV[RespFileArgs.NextArgC])+1;
                                }

                                // fill in Buffer
                                dwReturnValue = CopyArgIntoBuffer(Buffer, RespFileArgs.ArgV[RespFileArgs.NextArgC++], BufferSize);

                            } else { // file contains no parameters

                                if (fVerbose)
                                    fprintf(stderr,"BINPLACE : warning GNA0253: Empty response file- ignoring\n");

                                // clean up temp resources
                                free(pBeginBuffer);
                                CloseHandle(RespFile);

// Instead of returning the literal filename, skip over the file and just return the next arg
                                goto UseArgV;
//                                // fill in the required size
//                                if (RequiredSize != NULL) {
//                                    *RequiredSize = _tcsclen(CmdLineArgs.ArgV[CmdLineArgs.NextArgC-1])+1;
//                                }
//
//                                // fill in Buffer and advanced NextArgC
//                                dwReturnValue = CopyArgIntoBuffer(Buffer, CmdLineArgs.ArgV[CmdLineArgs.NextArgC-1], BufferSize);
                            }
                                
                        } else { // not enough memory to load the file- not sure what the best way to handle this is

                            if (fVerbose) 
                                fprintf(stderr,"BINPLACE : warning GNA0272: Out of memory\n");

                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);

                            if (RequiredSize != NULL) {
                                *RequiredSize = 1; // set to non-zero value
                            }

                            Buffer[0]     = TEXT('\0');
                            dwReturnValue = 0;

                        }

                    } else { // it *looked* like a response file, but couldn't be opened, so return it literally

                        if (fVerbose) 
                            fprintf(stderr,"BINPLACE : warning GNA0277: Can't open response file %s\n",(CmdLineArgs.ArgV[CmdLineArgs.NextArgC]+1));

                        // fill in the required size
                        if (RequiredSize != NULL) {
                            *RequiredSize = _tcsclen(CmdLineArgs.ArgV[CmdLineArgs.NextArgC])+1;
                        }

                        // fill in Buffer and advanced NextArgC
                        dwReturnValue = CopyArgIntoBuffer(Buffer, CmdLineArgs.ArgV[CmdLineArgs.NextArgC++], BufferSize);

                    } // if (RespFile != INVALID_HANDLE_VALUE) {} else {

                } else { // if (CmdLineArgs.ArgV[CmdLineArgs.NextArgC][0] == '@') {
                         // not a response file

                    if (fVerbose) 
                        fprintf(stderr,"BINPLACE : warning GNA0293: Not a response file (%s)\n",CmdLineArgs.ArgV[CmdLineArgs.NextArgC]);

                    // fill in the required size
                    if (RequiredSize != NULL) {
                        *RequiredSize = _tcsclen(CmdLineArgs.ArgV[CmdLineArgs.NextArgC])+1;
                    }

                    // no, so fill in Buffer and advanced NextArgC
                    dwReturnValue = CopyArgIntoBuffer(Buffer, CmdLineArgs.ArgV[CmdLineArgs.NextArgC++], BufferSize);

                } // if (CmdLineArgs.ArgV[CmdLineArgs.NextArgC][0] == '@') {} else {

            } // if (CmdLineArgs.NextArgC >= CmdLineArgs.MaxArgC) {} else {

        } // if (fInRespFile) {} else {

    } // if (Buffer == NULL) {} else {

    return(dwReturnValue);
}


/* ------------------------------------------------------------------------------------------------
    CopyArgIntoBuffer : does a simple copy with some error checking
------------------------------------------------------------------------------------------------ */
DWORD CopyArgIntoBuffer(TCHAR* Dst, TCHAR* Src, INT DstSize) {
    HRESULT hrCopyReturn = StringCchCopy(Dst, DstSize, Src);

    // if the buffer was too small, set a memory error
    if (HRESULT_CODE(hrCopyReturn) == ERROR_INSUFFICIENT_BUFFER) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    // return actual characters copied to Dst + \0
    return(_tcsclen(Dst)+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\binplace\checksymbols.c ===
#include <private.h>
#include <errno.h>
#include <strsafe.h>

//
// Invokes symchk.exe to validate symbols
//
BOOL CheckSymbols(LPSTR SourceFileName,
                  LPSTR TmpPath,
                  LPSTR ExcludeFileName,
                  BOOL  DbgControl,
                  // ErrMsg is MAX_SYM_ERR * sizeof(CHAR) in length
                  LPSTR ErrMsg,
                  size_t ErrMsgLen) {

    BOOL   bReturn  = TRUE;
    DWORD  dwReturn;
    
    FILE  *pfErrors;

    INT    iReturn;

    TCHAR  szBuf[ MAX_PATH*4 ];
    TCHAR  szTempPath[MAX_PATH+1];
    TCHAR  szTempFileName[MAX_PATH+1];
    TCHAR *pChar;

    UINT   uiReturn;

    //
    // Find the temp dir
    //
    dwReturn = GetTempPath(MAX_PATH+1, szTempPath);

    if (dwReturn == 0) {
        // GetTempPath failed, just use the current directory.
        StringCbCopy(szTempPath,sizeof(szTempPath),".");
    }

    //
    // Get a temp file to pipe output to
    //
    uiReturn= GetTempFileName(szTempPath, "BNP", 0, szTempFileName);

    if (uiReturn == 0) {
        StringCbCopy(ErrMsg, ErrMsgLen, "Unable to get temporary file name");
        return(FALSE);
    }

    //
    // Build the command line
    //
    StringCbPrintfA(szBuf,
                    sizeof(szBuf),
                    "symchk.exe %s /s %s /f ",
                    SourceFileName,
                    TmpPath);

    // Optional flags
    if ( DbgControl ) {
        StringCbCat( szBuf, sizeof(szBuf), " /t");
    }

    if ( ExcludeFileName != NULL ) {
        StringCbCat( szBuf, sizeof(szBuf), " /e ");
        StringCbCat( szBuf, sizeof(szBuf), ExcludeFileName );
    }

    // Redirect the output to a file
    StringCbCat( szBuf, sizeof(szBuf), " > ");
    StringCbCat( szBuf, sizeof(szBuf), szTempFileName);

    // From Oct 2001 MSDN:
    //  You must explicitly flush (using fflush or _flushall) or close any stream before calling system
    // It doesn't specify if stdin, stderr, and stdout are included here, so call it just to
    // be safe.
    _flushall();

    //
    // Spawn off symchk.exe - this is a security risk since we don't specifically specify the path
    //                        to symchk.exe.  However, we can't guarentee that it exists nor that
    //                        if we find it dynamically that the correct one will be used so I'm not
    //                        certain that we can do this any differently.
    //
    iReturn = system(szBuf);

    // Check for Error line in the output file
    if (iReturn != 0) {
        bReturn = FALSE;

        // symchk error return value
        if (iReturn == 1) {
            // open the error file
            pfErrors = fopen(szTempFileName, "r");

            // if the file couldn't be opened
            if (pfErrors == NULL) {
                StringCbCopy(ErrMsg, ErrMsgLen, "Can't open symchk error file");

            // parse the error file
            } else {
                if ( fgets( ErrMsg, ErrMsgLen, pfErrors ) == NULL) {
                    if ( feof(pfErrors) || ferror(pfErrors) ) {
                        StringCbCopy(ErrMsg, ErrMsgLen, "Can't read symchk error file");
                    } else {
                        StringCbCopy(ErrMsg, ErrMsgLen, "Unexpected error");
                    }
                } else if ( (pChar = strchr(ErrMsg,'\n')) != NULL ) {
                    // remove \n
                    pChar = '\0';
                    // message is too short to be meaningful
                    if (strlen(ErrMsg) <= 8) {
                        StringCbCopy(ErrMsg, ErrMsgLen, "Unknown Error");
                    }
                }
                fclose(pfErrors);
            }

        // system defined errors
        } else if (errno == E2BIG  ||
                   errno == ENOENT ||
                   errno == ENOMEM) {

            pChar = strerror(errno);
            StringCbCopy(ErrMsg, ErrMsgLen, pChar);

        // system defined errors intentionally ignored
        } else if (errno == ENOEXEC) {
            // If we return FALSE, binplace is going to start returning up the call stack, so just print
            // our own error message and pretend everything is fine by returning TRUE.
                        fprintf(stderr,"BINPLACE : error BNP2404: Unable to call symchk.exe, not checking symbols.\n");
            bReturn = TRUE;

        // unknown error
        } else {
            StringCbPrintfA(ErrMsg, ErrMsgLen, "Unexpected error. SymChk returned 0x%x.",iReturn);
        }
    }

    // cleanup the temp file and return
    if ( DeleteFile(szTempFileName) == 0 ) {
        fprintf(stderr,"BINPLACE : warning BNP2440: Unable to delete temp file \"%s\". Error 0x%x\n.",
                szTempFileName, GetLastError());
    }

    return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\i386\chksum.asm ===
title  "Compute Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    chksum.asm
;
; Abstract:
;
;    This module implements a fucntion to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--*/

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

        .code

;++
;
; USHORT
; ChkSum(
;   IN ULONG cksum,
;   IN PUSHORT buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;
; Arguments:
;
;    cksum - Suppiles the initial checksum value.
;
;    buf - Supplies a pointer to the buffer that is checksumed.
;
;    len - Supplies the of the buffer in words.
;
; Return Value:
;
;    The computed checksum is returned as the function value.
;
;--

cksum   equ     8                       ; stack offset to initial checksum
buf     equ     12                      ; stack offset to source address
len     equ     16                      ; stack offset to length in words

cPublicProc ChkSum,3

	push	esi                     ; save nonvolatile register
        mov     ecx,[esp + len]         ; get length in words
        mov     esi,[esp + buf]         ; get source address
        mov     eax,[esp + cksum]       ; get initial checksum
        shl     ecx,1                   ; convert to length in bytes
        jz      cks80                   ; if z set, no words to checksum

;
; Compute checksum in cascading order of block size until 128 byte blocks
; are all that is left, then loop on 128-bute blocks.
;

        test    esi,02h                 ; check if source dword aligned
        jz      short cks10             ; if z set, source is dword aligned
        sub     edx,edx                 ; get initial word for alignment
        mov     dx,[esi + 0]            ;
        add     eax,edx                 ; update partial checkcum
        adc     eax,0                   ; add carry
        add     esi,2                   ; update source address
        sub     ecx,2                   ; reduce length in bytes
cks10:  mov     edx,ecx                 ; isolate residual bytes
        and     edx,07h                 ;
        sub     ecx,edx                 ; subtract residual bytes
        jz      cks60                   ; if z set, no 8-byte blocks
        test    ecx,08h                 ; test if initial 8-byte block
        jz      short cks20             ; if z set, no initial 8-byte block
        add     eax,[esi + 0]           ; compute 8-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,0                   ; add carry
        add     esi,8                   ; update source address
        sub     ecx,8                   ; reduce length of checksum
        jz      cks60                   ; if z set, end of 8-byte blocks
cks20:  test    ecx,010h                ; test if initial 16-byte block
        jz      short cks30             ; if z set, no initial 16-byte block
        add     eax,[esi + 0]           ; compute 16-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,0                   ; add carry
        add     esi,16                  ; update source address
        sub     ecx,16                  ; reduce length of checksum
        jz      cks60                   ; if z set, end of 8-byte blocks
cks30:  test    ecx,020h                ; test if initial 32-byte block
        jz      short cks40             ; if z set, no initial 32-byte block
        add     eax,[esi + 0]           ; compute 32-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,[esi + 16]          ;
        adc     eax,[esi + 20]          ;
        adc     eax,[esi + 24]          ;
        adc     eax,[esi + 28]          ;
        adc     eax,0                   ; add carry
        add     esi,32                  ; update source address
        sub     ecx,32                  ; reduce length of checksum
        jz      cks60                   ; if z set, end of 8-byte blocks
cks40:  test    ecx,040h                ; test if initial 64-byte block
        jz      cks50                   ; if z set, no initial 64-byte block
        add     eax,[esi + 0]           ; compute 64-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,[esi + 16]          ;
        adc     eax,[esi + 20]          ;
        adc     eax,[esi + 24]          ;
        adc     eax,[esi + 28]          ;
        adc     eax,[esi + 32]          ;
        adc     eax,[esi + 36]          ;
        adc     eax,[esi + 40]          ;
        adc     eax,[esi + 44]          ;
        adc     eax,[esi + 48]          ;
        adc     eax,[esi + 52]          ;
        adc     eax,[esi + 56]          ;
        adc     eax,[esi + 60]          ;
        adc     eax,0                   ; add carry
        add     esi,64                  ; update source address
        sub     ecx,64                  ; reduce length of checksum
        jz      short cks60             ; if z set, end of 8-byte blocks
cks50:  add     eax,[esi + 0]           ; compute 64-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,[esi + 16]          ;
        adc     eax,[esi + 20]          ;
        adc     eax,[esi + 24]          ;
        adc     eax,[esi + 28]          ;
        adc     eax,[esi + 32]          ;
        adc     eax,[esi + 36]          ;
        adc     eax,[esi + 40]          ;
        adc     eax,[esi + 44]          ;
        adc     eax,[esi + 48]          ;
        adc     eax,[esi + 52]          ;
        adc     eax,[esi + 56]          ;
        adc     eax,[esi + 60]          ;
        adc     eax,[esi + 64]          ;
        adc     eax,[esi + 68]          ;
        adc     eax,[esi + 72]          ;
        adc     eax,[esi + 76]          ;
        adc     eax,[esi + 80]          ;
        adc     eax,[esi + 84]          ;
        adc     eax,[esi + 88]          ;
        adc     eax,[esi + 92]          ;
        adc     eax,[esi + 96]          ;
        adc     eax,[esi + 100]         ;
        adc     eax,[esi + 104]         ;
        adc     eax,[esi + 108]         ;
        adc     eax,[esi + 112]         ;
        adc     eax,[esi + 116]         ;
        adc     eax,[esi + 120]         ;
        adc     eax,[esi + 124]         ;
        adc     eax,0                   ; add carry
        add     esi,128                 ; update source address
        sub     ecx,128                 ; reduce length of checksum
        jnz     short cks50             ; if z clear, not end of 8-byte blocks

;
; Compute checksum on 2-byte blocks.
;

cks60:  test    edx,edx                 ; check if any 2-byte blocks
        jz      short cks80             ; if z set, no 2-byte blocks
cks70:  sub     ecx,ecx                 ; load 2-byte block
        mov     cx,[esi + 0]            ;
        add     eax,ecx                 ; compue 2-byte checksum
        adc     eax,0                   ;
        add     esi,2                   ; update source address
        sub     edx,2                   ; reduce length of checksum
        jnz     short cks70             ; if z clear, more 2-bytes blocks

;
; Fold 32-but checksum into 16-bits
;

cks80:  mov     edx,eax                 ; copy checksum value
        shr     edx,16                  ; isolate high order bits
        and     eax,0ffffh              ; isolate low order bits
        add     eax,edx                 ; sum high and low order bits
        mov     edx,eax                 ; isolate possible carry
        shr     edx,16                  ;
        add     eax,edx                 ; add carry
        and     eax,0ffffh              ; clear possible carry bit
	pop     esi                     ; restore nonvolatile register
        stdRET  ChkSum

stdENDP ChkSum

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\binplace\signwithidwkey.c ===
#include <private.h>
#include "rsa.h"
#include "md5.h"
#include <strsafe.h>

//////////////////////////////////////////////////////////////////////
//                                                                  //
//  Digital Signature Stuff                                         //
//                                                                  //
//////////////////////////////////////////////////////////////////////

LPBSAFE_PUB_KEY         PUB;
LPBSAFE_PRV_KEY         PRV;

unsigned char pubmodulus[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x3d, 0x3a, 0x5e, 0xbd, 0x72, 0x43, 0x3e, 0xc9,
    0x4d, 0xbb, 0xc1, 0x1e, 0x4a, 0xba, 0x5f, 0xcb,
    0x3e, 0x88, 0x20, 0x87, 0xef, 0xf5, 0xc1, 0xe2,
    0xd7, 0xb7, 0x6b, 0x9a, 0xf2, 0x52, 0x45, 0x95,
    0xce, 0x63, 0x65, 0x6b, 0x58, 0x3a, 0xfe, 0xef,
    0x7c, 0xe7, 0xbf, 0xfe, 0x3d, 0xf6, 0x5c, 0x7d,
    0x6c, 0x5e, 0x06, 0x09, 0x1a, 0xf5, 0x61, 0xbb,
    0x20, 0x93, 0x09, 0x5f, 0x05, 0x6d, 0xea, 0x87,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char prvmodulus[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x3d, 0x3a, 0x5e, 0xbd,
    0x72, 0x43, 0x3e, 0xc9, 0x4d, 0xbb, 0xc1, 0x1e,
    0x4a, 0xba, 0x5f, 0xcb, 0x3e, 0x88, 0x20, 0x87,
    0xef, 0xf5, 0xc1, 0xe2, 0xd7, 0xb7, 0x6b, 0x9a,
    0xf2, 0x52, 0x45, 0x95, 0xce, 0x63, 0x65, 0x6b,
    0x58, 0x3a, 0xfe, 0xef, 0x7c, 0xe7, 0xbf, 0xfe,
    0x3d, 0xf6, 0x5c, 0x7d, 0x6c, 0x5e, 0x06, 0x09,
    0x1a, 0xf5, 0x61, 0xbb, 0x20, 0x93, 0x09, 0x5f,
    0x05, 0x6d, 0xea, 0x87, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xbd, 0x29, 0x20,
    0x57, 0xd2, 0x3b, 0xf1, 0x07, 0xfa, 0xdf, 0xc1,
    0x16, 0x31, 0xe4, 0x95, 0xea, 0xc1, 0x2a, 0x46,
    0x2b, 0xad, 0x88, 0x57, 0x55, 0xf0, 0x57, 0x58,
    0xc6, 0x6f, 0x95, 0xeb, 0x00, 0x00, 0x00, 0x00,
    0x83, 0xdd, 0x9d, 0xd0, 0x03, 0xb1, 0x5a, 0x9b,
    0x9e, 0xb4, 0x63, 0x02, 0x43, 0x3e, 0xdf, 0xb0,
    0x52, 0x83, 0x5f, 0x6a, 0x03, 0xe7, 0xd6, 0x78,
    0x45, 0x83, 0x6a, 0x5b, 0xc4, 0xcb, 0xb1, 0x93,
    0x00, 0x00, 0x00, 0x00, 0x65, 0x9d, 0x43, 0xe8,
    0x48, 0x17, 0xcd, 0x29, 0x7e, 0xb9, 0x26, 0x5c,
    0x79, 0x66, 0x58, 0x61, 0x72, 0x86, 0x6a, 0xa3,
    0x63, 0xad, 0x63, 0xb8, 0xe1, 0x80, 0x4c, 0x0f,
    0x36, 0x7d, 0xd9, 0xa6, 0x00, 0x00, 0x00, 0x00,
    0x75, 0x3f, 0xef, 0x5a, 0x01, 0x5f, 0xf6, 0x0e,
    0xd7, 0xcd, 0x59, 0x1c, 0xc6, 0xec, 0xde, 0xf3,
    0x5a, 0x03, 0x09, 0xff, 0xf5, 0x23, 0xcc, 0x90,
    0x27, 0x1d, 0xaa, 0x29, 0x60, 0xde, 0x05, 0x6e,
    0x00, 0x00, 0x00, 0x00, 0xc0, 0x17, 0x0e, 0x57,
    0xf8, 0x9e, 0xd9, 0x5c, 0xf5, 0xb9, 0x3a, 0xfc,
    0x0e, 0xe2, 0x33, 0x27, 0x59, 0x1d, 0xd0, 0x97,
    0x4a, 0xb1, 0xb1, 0x1f, 0xc3, 0x37, 0xd1, 0xd6,
    0xe6, 0x9b, 0x35, 0xab, 0x00, 0x00, 0x00, 0x00,
    0x87, 0xa7, 0x19, 0x32, 0xda, 0x11, 0x87, 0x55,
    0x58, 0x00, 0x16, 0x16, 0x25, 0x65, 0x68, 0xf8,
    0x24, 0x3e, 0xe6, 0xfa, 0xe9, 0x67, 0x49, 0x94,
    0xcf, 0x92, 0xcc, 0x33, 0x99, 0xe8, 0x08, 0x60,
    0x17, 0x9a, 0x12, 0x9f, 0x24, 0xdd, 0xb1, 0x24,
    0x99, 0xc7, 0x3a, 0xb8, 0x0a, 0x7b, 0x0d, 0xdd,
    0x35, 0x07, 0x79, 0x17, 0x0b, 0x51, 0x9b, 0xb3,
    0xc7, 0x10, 0x01, 0x13, 0xe7, 0x3f, 0xf3, 0x5f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00
};

BOOL initkey(void)
{
    DWORD       bits;

    PUB = (LPBSAFE_PUB_KEY)pubmodulus;

    PUB->magic = RSA1;
    PUB->keylen = 0x48;
    PUB->bitlen = 0x0200;
    PUB->datalen = 0x3f;
    PUB->pubexp = 0xc0887b5b;

    PRV = (LPBSAFE_PRV_KEY)prvmodulus;
    PRV->magic = RSA2;
    PRV->keylen = 0x48;
    PRV->bitlen = 0x0200;
    PRV->datalen = 0x3f;
    PRV->pubexp = 0xc0887b5b;

    bits = PRV->bitlen;

    return TRUE;
}


BOOL SignWithIDWKey(IN  LPCSTR  FileName,
                    IN  BOOL    fVerbose) {

    HANDLE  hFile;
    HANDLE  hMapping;
    PUCHAR  pMap;
    HANDLE  hSigFile;
    DWORD   Size;
    MD5_CTX HashState;
    BYTE    SigHash[ 0x48 ];
    BYTE    Signature[ 0x48 ];
    CHAR    SigFilePath[ MAX_PATH ];
    PSTR    pszDot;

    BOOL    Return = FALSE;

    if (!initkey()) {
        return( FALSE );
    }

    hFile = CreateFile( FileName, GENERIC_READ,
                        FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, 0, NULL );

    if (hFile != INVALID_HANDLE_VALUE) {
        hMapping = CreateFileMapping(   hFile,
                                        NULL,
                                        PAGE_READONLY,
                                        0, 0, NULL );

        if (hMapping) {
            pMap = MapViewOfFileEx( hMapping,
                                    FILE_MAP_READ,
                                    0, 0, 0, NULL );

            if (pMap) {
                Size = GetFileSize( hFile, NULL );

                MD5Init( &HashState );

                MD5Update( &HashState, pMap, Size );

                MD5Final( &HashState );

                memset(SigHash, 0xff, 0x40);

                SigHash[0x40-1] = 0;
                SigHash[0x40-2] = 1;
                SigHash[16] = 0;

                memcpy(SigHash, HashState.digest, 16);

                //
                // Encrypt the signature data
                //

                BSafeDecPrivate(PRV, SigHash, Signature );;

                //
                // Create and store it in a .sig file
                //

                StringCbCopy( SigFilePath, sizeof(SigFilePath), FileName );

                pszDot = strrchr( SigFilePath, '.' );

                if (!pszDot) {
                    pszDot = SigFilePath + strlen( SigFilePath );
                }

                StringCbCopy( pszDot,
                             sizeof(SigFilePath) - strlen(pszDot),
                             ".sig");

                hSigFile = CreateFile( SigFilePath, GENERIC_WRITE,
                                       0, NULL,
                                       CREATE_ALWAYS, 0, NULL );

                if (hSigFile != INVALID_HANDLE_VALUE) {
                    WriteFile(  hSigFile,
                                Signature,
                                sizeof( Signature ),
                                &Size, NULL );

                    CloseHandle( hSigFile );

                    Return = TRUE ;

                    if (fVerbose)
                        fprintf( stdout, "BINPLACE : warning BNP0000: Signature file generated in %s\n", SigFilePath);

                } else {
                    fprintf( stderr, "BINPLACE : error BNP0000: Unable to create file %s, %d\n",
                             SigFilePath, GetLastError() );
                }

                UnmapViewOfFile( pMap );

            } else {
                fprintf(stderr, "BINPLACE : error BNP0000: unable to map view, %d\n", GetLastError());
            }

            CloseHandle( hMapping );

        } else {
            fprintf(stderr, "BINPLACE : error BNP0000: CreateFileMapping of %s failed, %d\n",
                    FileName, GetLastError() );

        }

        CloseHandle( hFile );
    } else {
        fprintf( stderr, "BINPLACE : error BNP0000: could not open %s, %d\n",
                 FileName, GetLastError() );
    }

    return( Return );
}

BOOL                            // Keep as BOOL for the future (used by rsa code)
GenRandom (ULONG huid, BYTE *pbBuffer, size_t dwLength)
{
    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\binplace\placefilematch.c ===
#include <windows.h>
#include <stdlib.h>
#include <strsafe.h>

#define BINPLACE_MAX_FULL_PATH 4096 // must match value in binplace.c
extern BOOL fVerbose;               // imported from binplace.c
BOOL
PlaceFileMatch(
    IN LPCSTR FullFileName,
    IN OUT LPSTR PlaceFileEntry, // May be modified by env. var expansion
    OUT LPSTR  PlaceFileClass,  // assumed CHAR[BINPLACE_MAX_FULL_PATH]
    OUT LPSTR  *PlaceFileNewName
    )
// Returns TRUE if the filename matches the placefile entry.
// On TRUE return, PlaceFileNewName points to location within
// PlaceFileEntry.  On FALSE return, PlaceFileClass and PlaceFileNewName are undefined.
{
    const CHAR *pchEntryOrig; // Point to current parse pos of PlaceFileEntry
    
    CHAR szEntryExp[BINPLACE_MAX_FULL_PATH]; // Holds fileEntry after environment expansion
    PCHAR pchEntryExp, pchEntryExpEnd; // Point to current pos and end of EntryExp
    PCHAR pchVarStart; // Points into EntryExp: where an env. expansion should start replacing

    LPCSTR pszEnvVar;

    const CHAR *pchEntryFnEnd; // Stores the end of the filename
    const CHAR *pchFn; // Stores the current position within the filename
    PCHAR pch;
    PCHAR pchClass; // Current position within PlaceFileClass

    // Check for early-exit opportunities
    if(
            !PlaceFileEntry   || 
            !FullFileName     ||
            !PlaceFileClass   ||
            PlaceFileEntry[0]==';' || // It is a full-line comment
            PlaceFileEntry[0]=='\0'   // Blank line
    ) {
        return FALSE;
    }

    // ***
    // *** Expand any environment variables in PlaceFileEntry (result goes back into PlaceFileEntry)
    // ***

    pchEntryExp = szEntryExp;
    pchEntryExpEnd = pchEntryExp + (sizeof(szEntryExp)/sizeof(szEntryExp[0])) - 1;
    pchVarStart = NULL; // Indicates that I haven't passed the starting % of an env. var.

    // Skip over leading whitespace
    for(
        pchEntryOrig = PlaceFileEntry;
        *pchEntryOrig==' ' || *pchEntryOrig=='\t';
        pchEntryOrig++
    )
    {}

    // StrCopy with environment variable replacement
    while(*pchEntryOrig && pchEntryExp<pchEntryExpEnd) {
        if(*pchEntryOrig == '%') {
            if(pchVarStart) { // If this is a closing %
		*pchEntryExp = 0; // Make sure the env. var. is null-terminated

                // pchVarStart points to first %
                if(pszEnvVar = getenv(pchVarStart + 1)) { // If the env. var is valid
                    // Copy it over
                    StringCchCopyEx(
                        pchVarStart, // Start where the first % was copied to
                        pchEntryExpEnd - pchVarStart, // Remaining = end - curPos
                        pszEnvVar,
                        &pchEntryExp,
                        NULL, // Don't need chars remaining
                        0 // No special flags
                    );
                }
                else // Environment variable not defined
                {
                    pchEntryExp = pchVarStart; // Back up to opening %
                    // This effectively expands the undefined variable to ""
                }
                pchVarStart = NULL; // Reset to "unstarted"
                pchEntryOrig++; // Skip past %
                continue;
            } else {
                // This is an opening % - remember it, then continue copying in case
                // they never close it.
                pchVarStart = pchEntryExp;
            }
        }
        *pchEntryExp++ = *pchEntryOrig++; // Unless we "continue", we copy the next char.
    }

    // NULL terminate expanded string
    *pchEntryExp = 0;

    // Copy result back
    StringCchCopy(PlaceFileEntry, BINPLACE_MAX_FULL_PATH, szEntryExp);

    // Chop off comment, if any
    if(pch = strchr(PlaceFileEntry,';'))
        *pch = 0;

    // Chop off newline, if any
    if(pch = strchr(PlaceFileEntry,'\n'))
        *pch = 0;

    // PlaceFileEntry now:
    // - Has no leading whitespace
    // - Has no comments (;)
    // - All environment variables (%VARNAME%) have been expanded.
    // - May have been truncated if the environment variables were really long!

    // ***
    // *** Determine if this is a match
    // ***

    // Scan for end of filename (next whitespace OR !)
    for(
        pchEntryOrig = PlaceFileEntry;
        *pchEntryOrig!=0 && *pchEntryOrig!=' ' && *pchEntryOrig!='\t' && *pchEntryOrig!='!';
        pchEntryOrig++
    )
    {}

    if(*pchEntryOrig!=' ' && *pchEntryOrig!='\t') { // No class name specified
        return FALSE;
    }

    pchEntryFnEnd = pchEntryOrig; // Save end of filename for later

    pchFn = FullFileName + strlen(FullFileName);

    // Scan backwards over filename and path
    while(pchEntryOrig>PlaceFileEntry && pchFn > FullFileName)
    {
        pchEntryOrig--;
        pchFn--;

        if('*' == *pchEntryOrig) { // Wildcard for this portion
            if(*(pchEntryOrig+1)!='\\' && *(pchEntryOrig+1)!='/') { // Invalid: "dir\*abc\filename"
                // This also catches the invalid "dir\*" (wildcard invalid for filename).
                if (fVerbose) {
                    fprintf( stdout, "BINPLACE : warning BNP0000: No wildcard in filename or mixed wildcard/text in class name: \"%s\"\n", PlaceFileEntry ) ;
                }
                return FALSE;
            }

            pchEntryOrig--; // Skip over the *

            if(
                pchEntryOrig <= PlaceFileEntry || // Can't start with wildcard ("*\dir\filename").
                ('\\'!=*pchEntryOrig && '/'!=*pchEntryOrig) // No partial wildcard ("dir\abc*\filename").
            ) {
                if (fVerbose) {
                    fprintf( stdout, "BINPLACE : warning BNP0000: No wildcard at start of path or mixed wildcard/text in class name: \"%s\"\n", PlaceFileEntry ) ;
                }
                return FALSE;
            }

            while(pchFn > FullFileName && *pchFn != '\\' && *pchFn != '/') // Skip wildcarded directory name
                pchFn--;

            // Both pchFn and pchEntryOrig are now on a slash.
        } else {
            if(toupper(*pchFn) != toupper(*pchEntryOrig)) {
                if( // Mismatch ok only on forward/backward slashes.
                    !(*pchFn == '/' || *pchFn == '\\') ||
                    !(*pchEntryOrig == '/' || *pchEntryOrig == '\\')
                )
                {
                    return FALSE; // Names don't match - exit
                }
            }
        }
    }
    
    // Did we match?  Conditions to be met:
    // pchEntryOrig==PlaceFileEntry (match pattern completely consumed)
    // pchFn==FullFileName (full file name completely consumed, perverse case) OR *pchFn==slash (normal case).
    if(
        pchEntryOrig != PlaceFileEntry ||
        (pchFn != FullFileName && *(pchFn-1) !='/' && *(pchFn-1) != '\\')
    )
    {
        return FALSE;
    }
    
    // ***
    // *** Its a match.  Set output variables accordingly.
    // ***

    // Skip to next whitespace (to skip over NewName, if present).
    for(
        pchEntryOrig = pchEntryFnEnd; // This is 1 past the end of the filename (saved previously)
        *pchEntryOrig!=0 && *pchEntryOrig!=' ' && *pchEntryOrig!='\t';
        pchEntryOrig++
    )
    {}

    // Skip over whitespace before the class name
    for(
        ; // Already set
        *pchEntryOrig==' ' || *pchEntryOrig=='\t';
        pchEntryOrig++
    )
    {}

    // pchEntryOrig is now at the start of the class name. Copy till an invalid char is reached.
    pchClass = PlaceFileClass;
    while(*pchEntryOrig!=0 && *pchEntryOrig!=' ' && *pchEntryOrig!='\t' && *pchEntryOrig!='!') {
        *pchClass++ = *pchEntryOrig++;
    }
    *pchClass = 0; // NULL terminate

    if(pchClass == PlaceFileClass) { // No class name specified!
        if (fVerbose) {
            fprintf( stdout, "BINPLACE : warning BNP0000: No class name in entry \"%s\"\n", PlaceFileEntry ) ;
        }
        return FALSE;
    }

    if (PlaceFileNewName != NULL) {
        *PlaceFileNewName = strchr(PlaceFileEntry,'!');
        if(*PlaceFileNewName) {
            *(*PlaceFileNewName)++ = 0; // Set the '!' to NULL, and skip past it to the Newname.
        }
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\binplace\sourceisnewer.c ===
#include <private.h>

BOOL FileExists(IN  LPCSTR FileName,
                OUT PWIN32_FIND_DATA FindData) {

    UINT OldMode;
    BOOL Found;
    HANDLE FindHandle;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,FindData);
    if (FindHandle == INVALID_HANDLE_VALUE) {
        Found = FALSE;
    } else {
        FindClose(FindHandle);
        Found = TRUE;
    }

    SetErrorMode(OldMode);
    return(Found);
}
 

BOOL SourceIsNewer(IN LPSTR SourceFile,
                   IN LPSTR TargetFile,
                   IN BOOL  fIsWin9x) {
    BOOL Newer;
    WIN32_FIND_DATA TargetInfo;
    WIN32_FIND_DATA SourceInfo;

    if ( FileExists(TargetFile,&TargetInfo) && FileExists(SourceFile,&SourceInfo) ) {
        Newer = !fIsWin9x
                ? (CompareFileTime(&SourceInfo.ftLastWriteTime,&TargetInfo.ftLastWriteTime) > 0)
                : (CompareFileTime(&SourceInfo.ftLastWriteTime,&TargetInfo.ftLastWriteTime) >= 0);

    } else {
        Newer = TRUE;
    }

    return(Newer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\binplace\verifyfinalimage.h ===
typedef HRESULT (WINAPI *PVLCA)(IN PCSTR FileName, IN PCSTR LcFileName);

struct {
    WORD  Machine;
    int   RC;
    CHAR  **Argv;
    int   Argc;
} ImageCheck;
 
BOOL VerifyFinalImage(IN  PCHAR  FileName,
                      IN  BOOL   fRetail,
					  IN  BOOL   fVerifyLc,
					  IN  UCHAR* LcFileName,
					  IN  PVLCA  pVLCAFunction,
                      OUT PBOOL  BinplaceLc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\binplace\stripcvsymbolpath.c ===
#include <private.h>
#include <strsafe.h>

BOOL
StripCVSymbolPath (
    LPSTR DestinationFile
    )
{
    LOADED_IMAGE LoadedImage;
    DWORD DirCnt;
    IMAGE_DEBUG_DIRECTORY UNALIGNED *DebugDirs, *CvDebugDir;
    PVOID pData;
    ULONG mysize;
    BOOL rc = FALSE;

    if (MapAndLoad(
                   DestinationFile,
                   NULL,
                   &LoadedImage,
                   FALSE,
                   FALSE) == FALSE) {
        return (FALSE);
    }

    __try {

        pData = ImageDirectoryEntryToData(LoadedImage.MappedAddress,
                                          FALSE,
                                          IMAGE_DIRECTORY_ENTRY_SECURITY,
                                          &DirCnt
                                          );

        if (pData || DirCnt) {
            __leave;        // Signed - can't change it
        }

        pData = ImageDirectoryEntryToData(LoadedImage.MappedAddress,
                                          FALSE,
                                          IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                          &DirCnt
                                          );

        if (pData) {
            // COR header found - see if it's strong signed
            if (((IMAGE_COR20_HEADER *)pData)->Flags & COMIMAGE_FLAGS_STRONGNAMESIGNED) {
                __leave;    // Strong name signed - can't change it.
            }
        }

        pData = ImageDirectoryEntryToData(LoadedImage.MappedAddress,
                                          FALSE,
                                          IMAGE_DIRECTORY_ENTRY_DEBUG,
                                          &DirCnt
                                          );

        if (!DebugDirectoryIsUseful(pData, DirCnt)) {
            __leave;    // No debug data to change.
        }

        DebugDirs = (IMAGE_DEBUG_DIRECTORY UNALIGNED *)pData;
        DirCnt /= sizeof(IMAGE_DEBUG_DIRECTORY);
        CvDebugDir = NULL;

        while (DirCnt) {
            DirCnt--;
            if (DebugDirs[DirCnt].Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
                CvDebugDir = &DebugDirs[DirCnt];
                break;
            }
        }

        if (!CvDebugDir) {
            __leave;    // No CV debug data.
        }

        if (CvDebugDir->PointerToRawData != 0) {

            PCVDD pDebugDir;

            pDebugDir = (PCVDD) (CvDebugDir->PointerToRawData + (PCHAR)LoadedImage.MappedAddress);

            if (pDebugDir->dwSig == '01BN' || pDebugDir->dwSig == 'SDSR' ) {
                // Got a PDB.  The name immediately follows the signature.
                LPSTR szMyDllToLoad;
                CHAR PdbName[sizeof(((PRSDSI)(0))->szPdb)];
                CHAR Filename[_MAX_FNAME];
                CHAR FileExt[_MAX_EXT];
                if (pDebugDir->dwSig == '01BN' ) {
                    mysize=sizeof(NB10IH);
                } else {
                    mysize=sizeof(RSDSIH);
                }

                if (mysize < CvDebugDir->SizeOfData) { // make sure there's enough space to work with
                    ZeroMemory(PdbName, sizeof(PdbName));
                    memcpy(PdbName, ((PCHAR)pDebugDir) + mysize, __min(CvDebugDir->SizeOfData - mysize, sizeof(PdbName) - 1));

                    _splitpath(PdbName, NULL, NULL, Filename, FileExt);

                    ZeroMemory(  ((char *)pDebugDir) + mysize, CvDebugDir->SizeOfData - mysize); // zero the old record
                    StringCbCopy(((char *)pDebugDir) + mysize, CvDebugDir->SizeOfData - mysize, Filename);
                    StringCbCat( ((char *)pDebugDir) + mysize, CvDebugDir->SizeOfData - mysize, FileExt );
                    CvDebugDir->SizeOfData = mysize + strlen( ((char *)pDebugDir) + mysize) + 1;
                } else {
                    __leave;
                }
            }
            rc = TRUE;
        }
    } __finally {
        UnMapAndLoad(&LoadedImage);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\binplace\verifyfinalimage.c ===
#include <private.h>
#include <VerifyFinalImage.h>
#include <process.h>

BOOL VerifyLc(PCHAR  FileName,
		      UCHAR* LcFullFileName,   // added to move to seperate file
			  PVLCA  pVerifyFunction,  // added to move to seperate file
              BOOL   fRetail) {

    HRESULT hr = (*pVerifyFunction)(FileName, LcFullFileName);

    if (FAILED(hr)) {
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MATCH)) {
            fprintf(stderr,
                "BINPLACE : %s BNP0000: resource conflicts with localization constraint \"%s\"\n",
                fRetail ? "error" : "warning",
                FileName);
        }
        else {
            fprintf(stderr,
                "BINPLACE : %s BNP0000: VerifyLc %s failed 0x%lX\n",
                fRetail ? "error" : "warning", FileName, hr);
        }
        return FALSE;
    }

    return TRUE;
}

typedef DWORD (WINAPI *PFNGVS)(LPSTR, LPDWORD);

BOOL VerifyFinalImage(IN  PCHAR  FileName,
                      IN  BOOL   fRetail,
					  IN  BOOL   fVerifyLc,      // added to move to seperate file
					  IN  UCHAR* LcFileName,     // added to move to seperate file
					  IN  PVLCA  pVLCAFunction,  // added to move to seperate file
                      OUT PBOOL  BinplaceLc) {

    HINSTANCE 		hVersion;
    PFNGVS    		pfnGetFileVersionInfoSize;
    DWORD     		dwSize;
    DWORD     		dwReturn;
    BOOL      		fRC  	= TRUE,
              		rc   	= TRUE,
              		tlb  	= FALSE;
    LOADED_IMAGE 	LoadedImage;
    OSVERSIONINFO 	VersionInfo;

    LoadedImage.hFile = INVALID_HANDLE_VALUE;

    *BinplaceLc = FALSE;

    if (fVerifyLc) {
        if (!VerifyLc(FileName, LcFileName, pVLCAFunction, fRetail)) {
            fRC = fRetail ? FALSE : TRUE;
            goto End1;
        }
        *BinplaceLc = TRUE;
    }

    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx ( &VersionInfo );
    if ( VersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT )
        return( TRUE );     // Not NT - can't load Win64 binaries
    if ( VersionInfo.dwMajorVersion < 5  )
        return ( TRUE );    // Prior to Win2K - can't load Win64 binaries

    rc = MapAndLoad(FileName, NULL, &LoadedImage, FALSE, TRUE);

    if (!rc) {
        // Not a binary.  See if it's one of the other types we care about (like typelibs)

        CHAR szExt[_MAX_EXT];

        _splitpath(FileName, NULL, NULL, NULL, szExt);

        // The only non-binary images that need version resources are .tlb's

        if (_stricmp(szExt, ".tlb")) {
            return(TRUE);
        }

        tlb=TRUE;
    }

    hVersion = LoadLibraryA("VERSION.DLL");
    if (hVersion == NULL) {
        goto End1;
    }

    pfnGetFileVersionInfoSize = (PFNGVS) GetProcAddress(hVersion, "GetFileVersionInfoSizeA");
    if (pfnGetFileVersionInfoSize == NULL) {
        goto End2;
    }

    if ((dwReturn = pfnGetFileVersionInfoSize(FileName, &dwSize)) == 0) {

        if ( !tlb && (LoadedImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) &&
             (LoadedImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64) &&
             (LoadedImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_IA64) ) {
             goto End2;
        }

        if (fRetail) {
            fprintf(stderr,
                "BINPLACE : %s BNP0000: no version resource detected for \"%s\"\n",
                "error",
                FileName);
            fRC = FALSE;
        } else {
            fRC = TRUE;
        }
    }

End2:
    FreeLibrary(hVersion);
End1:

    if (ImageCheck.Argv != NULL &&
        (LoadedImage.hFile != INVALID_HANDLE_VALUE ||
        MapAndLoad(FileName, NULL, &LoadedImage, FALSE, TRUE) == TRUE)) {
        if ((LoadedImage.FileHeader->FileHeader.Machine == ImageCheck.Machine)) {
             int RC;

             ImageCheck.Argv[ImageCheck.Argc-2] = FileName;
             RC = (int)_spawnvp(P_WAIT, ImageCheck.Argv[0], (const char * const *) ImageCheck.Argv);
             if (RC == -1 || RC == 128) {
                 fprintf(stderr,
                 "BINPLACE : error BNP0000: Cannot execute (%s). Make sure it (or it's DLL's) exists or verify binplace /CI option.\n", ImageCheck.Argv[0]);
                 fRC = FALSE;
             } else if (RC == 1) {
                 fprintf(stderr,
                 "BINPLACE : error BNP0000: ImageCheck (%s) failed.\n", ImageCheck.Argv[0]);
                 fRC = FALSE;
             } else if (RC == ImageCheck.RC) {
                 fprintf(stderr,
                 "BINPLACE : error BNP0000: Image checker (%s) detected errors in %s.\n", ImageCheck.Argv[0], FileName);
                 fRC = FALSE;
             }
        }
    }

    if (LoadedImage.hFile != INVALID_HANDLE_VALUE)
        UnMapAndLoad(&LoadedImage);

    return fRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\dbghelp\makefile.inc ===
$(O)\dbghelp.res: ..\dbghelp.rc

..\debug.c ..\undname.c: $(SDK_INC_PATH)\ntverp.h

$(O)\pdbghelp.def : ..\imagehlp.src
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc..\imagehlp.src > $@
$(CPPXX: =
)
-DPRIVATE=
<<NOKEEP

$(O)\pdbghelp.lib : $(O)\pdbghelp.def $(IMPLIB_DEPEND)
    -lib -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\pdbghelp.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\ia64\chksum.s ===
#include "ksia64.h"

        LEAF_ENTRY (ChkSum)

        alloc    t22 = ar.pfs, 3, 0, 0, 0
        mov      t10 = 0xffff
        zxt4     a2 = a2
        ;;

        cmp4.eq  pt0 = zero, a2
        zxt4     a0 = a0
(pt0)   br.cond.spnt cs20

cs10:
        ld2      t0 = [a1], 2
        add      a2 = -1, a2
        ;;
        add      a0 = t0, a0
        ;;

        cmp4.ne  pt1 = zero, a2
        extr.u   t1 = a0, 16, 16
        and      t2 = a0, t10
        ;;

        add      a0 = t1, t2
        nop.f    0
(pt1)   br.cond.sptk cs10
        ;;
        
cs20:
  
        nop.m    0
        extr.u   t1 = a0, 16, 16
        ;;
        add      a0 = t1, a0
        ;;

        nop.m    0
        and      v0 = a0, t10
        br.ret.sptk brp

        LEAF_EXIT (ChkSum)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\imagehlp\makefile.inc ===
$(O)\imagehlp.res: ..\imagehlp.rc

..\debug.c ..\undname.c: $(SDK_INC_PATH)\ntverp.h

$(O)\pimagehlp.def : ..\imagehlp.src
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc..\imagehlp.src > $@
$(CPPXX: =
)
-DPRIVATE=
<<NOKEEP

$(O)\pimagehlp.lib : $(O)\pimagehlp.def $(IMPLIB_DEPEND)
    -lib -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\pimagehlp.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\symstress\makefile.inc ===
$(O)\symstress.res: ..\symstress.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\kdbgctrl\kdbgctrl.cpp ===
//----------------------------------------------------------------------------
//
// Controls the current kernel debugger.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <cmnutil.hpp>

PSTR g_AppName;

void DECLSPEC_NORETURN
ShowUsage(void)
{
    printf("Usage: %s <options>\n", g_AppName);
    printf("Options:\n");
    printf("  -c     - Check kernel debugger enable\n");
    printf("  -ca    - Check kernel debugger auto-enable\n");
    printf("  -cdb   - Check kernel DbgPrint buffer size\n");
    printf("  -cu    - Check kernel debugger user exception handling\n");
    printf("  -cx    - Check kernel debugger enable and exit with status\n");
    printf("  -d     - Disable kernel debugger\n");
    printf("  -da    - Disable kernel debugger auto-enable\n");
    printf("  -du    - Disable kernel debugger user exception handling\n");
    printf("  -e     - Enable kernel debugger\n");
    printf("  -ea    - Enable kernel debugger auto-enable\n");
    printf("  -eu    - Enable kernel debugger user exception handling\n");
    printf("  -sdb # - Set kernel DbgPrint buffer size\n");
    exit(1);
}

void
QueryKdInfo(BOOL Exit)
{
    NTSTATUS NtStatus;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo;
            
    NtStatus =
        NtQuerySystemInformation(SystemKernelDebuggerInformation,
                                 &KdInfo, sizeof(KdInfo), NULL);
    if (Exit)
    {
        if (!NT_SUCCESS(NtStatus))
        {
            exit((int)NtStatus);
        }
        else
        {
            exit(KdInfo.KernelDebuggerEnabled ?
                 (int)DBG_EXCEPTION_HANDLED : (int)DBG_CONTINUE);
        }
    }
    else if (!NT_SUCCESS(NtStatus))
    {
        HRESULT Status = HRESULT_FROM_NT(NtStatus);
        printf("Unable to check kernel debugger status, %s\n    %s\n",
               FormatStatusCode(Status), FormatStatus(Status));
    }
    else
    {
        printf("Kernel debugger is %s\n",
               KdInfo.KernelDebuggerEnabled ? "enabled" : "disabled");
    }
}

void
SdcSimpleCall(SYSDBG_COMMAND Command, PSTR Success, PSTR Failure)
{
    NTSTATUS NtStatus;
    
    NtStatus = NtSystemDebugControl(Command, NULL, 0, NULL, 0, NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        HRESULT Status = HRESULT_FROM_NT(NtStatus);
        printf("%s, %s\n    %s\n",
               Failure, FormatStatusCode(Status), FormatStatus(Status));
    }
    else
    {
        printf("%s\n", Success);
    }
}

void
SdcOutputBool(SYSDBG_COMMAND Command,
              PSTR Name)
{
    NTSTATUS NtStatus;
    ULONG Value = 0;
    
    NtStatus = NtSystemDebugControl(Command, NULL, 0,
                                    &Value, sizeof(BOOLEAN),
                                    NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        HRESULT Status = HRESULT_FROM_NT(NtStatus);
        printf("Unable to get %s, %s\n    %s\n",
               Name, FormatStatusCode(Status), FormatStatus(Status));
    }
    else
    {
        printf("%s: %s\n", Name, Value ? "true" : "false");
    }
}

void
SdcSetBool(SYSDBG_COMMAND Command, BOOL Value,
           PSTR Name)
{
    NTSTATUS NtStatus;

    // Force value to canonical form.
    Value = Value ? TRUE : FALSE;

    NtStatus = NtSystemDebugControl(Command, &Value, sizeof(BOOLEAN),
                                    NULL, 0, NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        HRESULT Status = HRESULT_FROM_NT(NtStatus);
        printf("Unable to set %s, %s\n    %s\n",
               Name, FormatStatusCode(Status), FormatStatus(Status));
    }
    else
    {
        printf("%s set to: %s\n", Name, Value ? "true" : "false");
    }
}

void
SdcOutputUlong(SYSDBG_COMMAND Command,
               PSTR Name)
{
    NTSTATUS NtStatus;
    ULONG Value;
    
    NtStatus = NtSystemDebugControl(Command, NULL, 0,
                                    &Value, sizeof(Value),
                                    NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        HRESULT Status = HRESULT_FROM_NT(NtStatus);
        printf("Unable to get %s, %s\n    %s\n",
               Name, FormatStatusCode(Status), FormatStatus(Status));
    }
    else
    {
        printf("%s: 0x%x\n", Name, Value);
    }
}

void
SdcSetUlong(SYSDBG_COMMAND Command, ULONG Value,
            PSTR Name)
{
    NTSTATUS NtStatus;

    NtStatus = NtSystemDebugControl(Command, &Value, sizeof(Value),
                                    NULL, 0, NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        HRESULT Status = HRESULT_FROM_NT(NtStatus);
        printf("Unable to set %s, %s\n    %s\n",
               Name, FormatStatusCode(Status), FormatStatus(Status));
    }
    else
    {
        printf("%s set to: 0x%x\n", Name, Value);
    }
}

int __cdecl
main(int Argc, char** Argv)
{
    BOOL Usage = FALSE;
    HRESULT Status;

    g_AppName = *Argv;

    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        printf("Unable to enable debug privilege, %s\n    %s\n",
               FormatStatusCode(Status), FormatStatus(Status));
        return 1;
    }
    
    while (--Argc > 0 && !Usage)
    {
        Argv++;

        if (!strcmp(*Argv, "-?"))
        {
            Usage = TRUE;
        }
        else if (!strcmp(*Argv, "-c") ||
                 !strcmp(*Argv, "-cx"))
        {
            QueryKdInfo(Argv[0][2] == 'x');
        }
        else if (!strcmp(*Argv, "-ca"))
        {
            SdcOutputBool(SysDbgGetAutoKdEnable,
                          "Kernel debugger auto-enable");
        }
        else if (!strcmp(*Argv, "-cdb"))
        {
            SdcOutputUlong(SysDbgGetPrintBufferSize,
                          "Kernel DbgPrint buffer size");
        }
        else if (!strcmp(*Argv, "-cu"))
        {
            SdcOutputBool(SysDbgGetKdUmExceptionEnable,
                          "Kernel debugger user exception enable");
        }
        else if (!strcmp(*Argv, "-d"))
        {
            SdcSimpleCall(SysDbgDisableKernelDebugger,
                          "Kernel debugger disabled",
                          "Unable to disable kernel debugger");
        }
        else if (!strcmp(*Argv, "-da"))
        {
            SdcSetBool(SysDbgSetAutoKdEnable, FALSE,
                       "Kernel debugger auto-enable");
        }
        else if (!strcmp(*Argv, "-du"))
        {
            SdcSetBool(SysDbgSetKdUmExceptionEnable, FALSE,
                       "Kernel debugger user exception enable");
        }
        else if (!strcmp(*Argv, "-e"))
        {
            SdcSimpleCall(SysDbgEnableKernelDebugger,
                          "Kernel debugger enabled",
                          "Unable to enable kernel debugger");
        }
        else if (!strcmp(*Argv, "-ea"))
        {
            SdcSetBool(SysDbgSetAutoKdEnable, TRUE,
                       "Kernel debugger auto-enable");
        }
        else if (!strcmp(*Argv, "-eu"))
        {
            SdcSetBool(SysDbgSetKdUmExceptionEnable, TRUE,
                       "Kernel debugger user exception enable");
        }
        else if (!strcmp(*Argv, "-sdb"))
        {
            if (Argc < 2)
            {
                Usage = TRUE;
                break;
            }

            Argc--;
            Argv++;
            SdcSetUlong(SysDbgSetPrintBufferSize, strtoul(*Argv, NULL, 0),
                        "Kernel DbgPrint buffer size");
        }
        else
        {
            Usage = TRUE;
        }
    }

    if (Usage)
    {
        ShowUsage();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\gen.h ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    gen.c

Abstract:

    Generic routines that work on all operating systems.

Author:

    Matthew D Hendel (math) 20-Oct-1999

Revision History:

--*/

#pragma once

#define KBYTE (1024)
#define ARRAY_COUNT(_array) (sizeof (_array) / sizeof ((_array)[0]))

#define MAX_DYNAMIC_FUNCTION_TABLE 256

#define WIN32_LAST_STATUS() \
    (GetLastError() ? HRESULT_FROM_WIN32(GetLastError()) : E_FAIL)

ULONG FORCEINLINE
FileTimeToTimeDate(LPFILETIME FileTime)
{
    ULARGE_INTEGER LargeTime;
    
    LargeTime.LowPart = FileTime->dwLowDateTime;
    LargeTime.HighPart = FileTime->dwHighDateTime;
    // Convert to seconds and from base year 1601 to base year 1970.
    return (ULONG)(LargeTime.QuadPart / 10000000 - 11644473600);
}

ULONG FORCEINLINE
FileTimeToSeconds(LPFILETIME FileTime)
{
    ULARGE_INTEGER LargeTime;
    
    LargeTime.LowPart = FileTime->dwLowDateTime;
    LargeTime.HighPart = FileTime->dwHighDateTime;
    // Convert to seconds.
    return (ULONG)(LargeTime.QuadPart / 10000000);
}

ULONG64 FORCEINLINE
GenGetPointer(IN PMINIDUMP_STATE Dump,
              IN PVOID Data)
{
    if (Dump->PtrSize == 8) {
        return *(PULONG64)Data;
    } else {
        return *(PLONG)Data;
    }
}

void FORCEINLINE
GenSetPointer(IN PMINIDUMP_STATE Dump,
              IN PVOID Data,
              IN ULONG64 Val)
{
    if (Dump->PtrSize == 8) {
        *(PULONG64)Data = Val;
    } else {
        *(PULONG)Data = (ULONG)Val;
    }
}

LPVOID
AllocMemory(
    IN PMINIDUMP_STATE Dump,
    IN ULONG Size
    );

VOID
FreeMemory(
    IN PMINIDUMP_STATE Dump,
    IN LPVOID Memory
    );

void
GenAccumulateStatus(
    IN PMINIDUMP_STATE Dump,
    IN ULONG Status
    );

struct _INTERNAL_THREAD;
struct _INTERNAL_PROCESS;
struct _INTERNAL_MODULE;
struct _INTERNAL_FUNCTION_TABLE;

BOOL
GenExecuteIncludeThreadCallback(
    IN PMINIDUMP_STATE Dump,
    IN ULONG ThreadId,
    OUT PULONG WriteFlags
    );

BOOL
GenExecuteIncludeModuleCallback(
    IN PMINIDUMP_STATE Dump,
    IN ULONG64 BaseOfImage,
    OUT PULONG WriteFlags
    );

HRESULT
GenGetDataContributors(
    IN PMINIDUMP_STATE Dump,
    IN OUT PINTERNAL_PROCESS Process,
    IN PINTERNAL_MODULE Module
    );

HRESULT
GenGetThreadInstructionWindow(
    IN PMINIDUMP_STATE Dump,
    IN struct _INTERNAL_PROCESS* Process,
    IN struct _INTERNAL_THREAD* Thread
    );

HRESULT
GenGetProcessInfo(
    IN PMINIDUMP_STATE Dump,
    OUT struct _INTERNAL_PROCESS ** ProcessRet
    );

VOID
GenFreeProcessObject(
    IN PMINIDUMP_STATE Dump,
    IN struct _INTERNAL_PROCESS * Process
    );

HRESULT
GenAddMemoryBlock(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN MEMBLOCK_TYPE Type,
    IN ULONG64 Start,
    IN ULONG Size
    );

void
GenRemoveMemoryRange(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN ULONG64 Start,
    IN ULONG Size
    );

HRESULT
GenAddPebMemory(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process
    );

HRESULT
GenAddTebMemory(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN PINTERNAL_THREAD Thread
    );

HRESULT
GenWriteHandleData(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo
    );

ULONG GenProcArchToImageMachine(ULONG ProcArch);

//
// Routines reimplemented for portability.
//

PIMAGE_NT_HEADERS
GenImageNtHeader(
    IN PVOID Base,
    OUT OPTIONAL PIMAGE_NT_HEADERS64 Generic
    );

PVOID
GenImageDirectoryEntryToData(
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

LPWSTR
GenStrCopyNW(
    OUT LPWSTR lpString1,
    IN LPCWSTR lpString2,
    IN int iMaxLength
    );

size_t
GenStrLengthW(
    const wchar_t * wcs
    );

int
GenStrCompareW(
    IN LPCWSTR String1,
    IN LPCWSTR String2
    );


void
GenExRecord32ToMd(PEXCEPTION_RECORD32 Rec32,
                  PMINIDUMP_EXCEPTION RecMd);
inline void
GenExRecord64ToMd(PEXCEPTION_RECORD64 Rec64,
                  PMINIDUMP_EXCEPTION RecMd)
{
    // Structures are the same.
    memcpy(RecMd, Rec64, sizeof(*RecMd));
}

//
// Stolen from NTRTL to avoid having to include it here.
//

#ifndef InitializeListHead
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#endif
    

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#ifndef InsertTailList
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#endif

//
//  VOID
//  InsertListAfter(
//      PLIST_ENTRY ListEntry,
//      PLIST_ENTRY InsertEntry
//      );
//

#ifndef InsertListAfter
#define InsertListAfter(ListEntry,InsertEntry) {\
    (InsertEntry)->Flink = (ListEntry)->Flink;\
    (InsertEntry)->Blink = (ListEntry);\
    (ListEntry)->Flink->Blink = (InsertEntry);\
    (ListEntry)->Flink = (InsertEntry);\
    }
#endif

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#ifndef RemoveEntryList
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
}
#endif

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#ifndef IsListEmpty
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#endif

//
// Undefine ASSERT so we do not get RtlAssert().
//

#ifdef ASSERT
#undef ASSERT
#endif

#if DBG

#define ASSERT(_x)\
    if (!(_x)){\
        OutputDebugString ("ASSERT Failed");\
        DebugBreak ();\
    }

#else

#define ASSERT(_x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\gen.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    gen.c

Abstract:

    Generic routines for minidump that work on both NT and Win9x.

Author:

    Matthew D Hendel (math) 10-Sep-1999

Revision History:

--*/

#include "pch.cpp"

#include <limits.h>

//
// For FPO frames on x86 we access bytes outside of the ESP - StackBase range.
// This variable determines how many extra bytes we need to add for this
// case.
//

#define X86_STACK_FRAME_EXTRA_FPO_BYTES 4

#define REASONABLE_NB11_RECORD_SIZE (10 * KBYTE)
#define REASONABLE_MISC_RECORD_SIZE (10 * KBYTE)

class GenMiniDumpProviderCallbacks : public MiniDumpProviderCallbacks
{
public:
    GenMiniDumpProviderCallbacks(
        IN PMINIDUMP_STATE Dump,
        IN PINTERNAL_PROCESS Process
        )
    {
        m_Dump = Dump;
        m_Process = Process;
        m_MemType = MEMBLOCK_OTHER;
        m_SaveMemType = MEMBLOCK_OTHER;
    }
    
    virtual HRESULT EnumMemory(ULONG64 Offset, ULONG Size)
    {
        return GenAddMemoryBlock(m_Dump, m_Process, m_MemType, Offset, Size);
    }

    void PushMemType(MEMBLOCK_TYPE Type)
    {
        m_SaveMemType = m_MemType;
        m_MemType = Type;
    }
    void PopMemType(void)
    {
        m_MemType = m_SaveMemType;
    }
    
    PMINIDUMP_STATE m_Dump;
    PINTERNAL_PROCESS m_Process;
    MEMBLOCK_TYPE m_MemType, m_SaveMemType;
};

LPVOID
AllocMemory(
    IN PMINIDUMP_STATE Dump,
    IN ULONG Size
    )
{
    LPVOID Mem = Dump->AllocProv->Alloc(Size);
    if (!Mem) {
        // Handle marking the no-memory state for all allocations.
        GenAccumulateStatus(Dump, MDSTATUS_OUT_OF_MEMORY);
    }
    return Mem;
}

VOID
FreeMemory(
    IN PMINIDUMP_STATE Dump,
    IN LPVOID Memory
    )
{
    Dump->AllocProv->Free(Memory);
}

PVOID
ReAllocMemory(
    IN PMINIDUMP_STATE Dump,
    IN LPVOID Memory,
    IN ULONG Size
    )
{
    LPVOID Mem = Dump->AllocProv->Realloc(Memory, Size);
    if (!Mem) {
        // Handle marking the no-memory state for all allocations.
        GenAccumulateStatus(Dump, MDSTATUS_OUT_OF_MEMORY);
    }
    return Mem;
}

void
GenAccumulateStatus(
    IN PMINIDUMP_STATE Dump,
    IN ULONG Status
    )
{
    // This is a function to make it easy to debug failures
    // by setting a breakpoint here.
    Dump->AccumStatus |= Status;
}


VOID
GenGetDefaultWriteFlags(
    IN PMINIDUMP_STATE Dump,
    OUT PULONG ModuleWriteFlags,
    OUT PULONG ThreadWriteFlags
    )
{
    *ModuleWriteFlags = ModuleWriteModule | ModuleWriteMiscRecord |
        ModuleWriteCvRecord;
    if (Dump->DumpType & MiniDumpWithDataSegs) {
        *ModuleWriteFlags |= ModuleWriteDataSeg;
    }
    
    *ThreadWriteFlags = ThreadWriteThread | ThreadWriteContext;
    if (!(Dump->DumpType & MiniDumpWithFullMemory)) {
        *ThreadWriteFlags |= ThreadWriteStack | ThreadWriteInstructionWindow;
        if (Dump->BackingStore) {
            *ThreadWriteFlags |= ThreadWriteBackingStore;
        }
    }
    if (Dump->DumpType & MiniDumpWithProcessThreadData) {
        *ThreadWriteFlags |= ThreadWriteThreadData;
    }
}

BOOL
GenExecuteIncludeThreadCallback(
    IN PMINIDUMP_STATE Dump,
    IN ULONG ThreadId,
    OUT PULONG WriteFlags
    )
{
    BOOL Succ;
    MINIDUMP_CALLBACK_INPUT CallbackInput;
    MINIDUMP_CALLBACK_OUTPUT CallbackOutput;


    // Initialize the default write flags.
    GenGetDefaultWriteFlags(Dump, &CallbackOutput.ModuleWriteFlags,
                            WriteFlags);

    //
    // If there are no callbacks to call, then we are done.
    //

    if ( Dump->CallbackRoutine == NULL ) {
        return TRUE;
    }

    CallbackInput.ProcessHandle = Dump->ProcessHandle;
    CallbackInput.ProcessId = Dump->ProcessId;
    CallbackInput.CallbackType = IncludeThreadCallback;

    CallbackInput.IncludeThread.ThreadId = ThreadId;

    CallbackOutput.ThreadWriteFlags = *WriteFlags;

    Succ = Dump->CallbackRoutine (Dump->CallbackParam,
                                  &CallbackInput,
                                  &CallbackOutput);

    //
    // If the callback returned FALSE, quit now.
    //

    if ( !Succ ) {
        return FALSE;
    }

    // Limit the flags that can be added.
    *WriteFlags &= CallbackOutput.ThreadWriteFlags;

    return TRUE;
}

BOOL
GenExecuteIncludeModuleCallback(
    IN PMINIDUMP_STATE Dump,
    IN ULONG64 BaseOfImage,
    OUT PULONG WriteFlags
    )
{
    BOOL Succ;
    MINIDUMP_CALLBACK_INPUT CallbackInput;
    MINIDUMP_CALLBACK_OUTPUT CallbackOutput;


    // Initialize the default write flags.
    GenGetDefaultWriteFlags(Dump, WriteFlags,
                            &CallbackOutput.ThreadWriteFlags);

    //
    // If there are no callbacks to call, then we are done.
    //

    if ( Dump->CallbackRoutine == NULL ) {
        return TRUE;
    }

    CallbackInput.ProcessHandle = Dump->ProcessHandle;
    CallbackInput.ProcessId = Dump->ProcessId;
    CallbackInput.CallbackType = IncludeModuleCallback;

    CallbackInput.IncludeModule.BaseOfImage = BaseOfImage;

    CallbackOutput.ModuleWriteFlags = *WriteFlags;

    Succ = Dump->CallbackRoutine (Dump->CallbackParam,
                                  &CallbackInput,
                                  &CallbackOutput);

    //
    // If the callback returned FALSE, quit now.
    //

    if ( !Succ ) {
        return FALSE;
    }

    // Limit the flags that can be added.
    *WriteFlags = (*WriteFlags | ModuleReferencedByMemory) &
        CallbackOutput.ModuleWriteFlags;

    return TRUE;
}


HRESULT
GenGetDebugRecord(
    IN PMINIDUMP_STATE Dump,
    IN PVOID Base,
    IN ULONG MappedSize,
    IN ULONG DebugRecordType,
    IN ULONG DebugRecordMaxSize,
    OUT PVOID * DebugInfo,
    OUT ULONG * SizeOfDebugInfo
    )
{
    ULONG i;
    ULONG Size;
    ULONG NumberOfDebugDirectories;
    IMAGE_DEBUG_DIRECTORY UNALIGNED* DebugDirectories;


    Size = 0;

    //
    // Find the debug directory and copy the memory into the buffer.
    // Assumes the call to this function is wrapped in a try/except.
    //

    DebugDirectories = (IMAGE_DEBUG_DIRECTORY UNALIGNED *)
        GenImageDirectoryEntryToData (Base,
                                      FALSE,
                                      IMAGE_DIRECTORY_ENTRY_DEBUG,
                                      &Size);

    //
    // Check that we got a valid record.
    //

    if (DebugDirectories &&
        ((Size % sizeof (IMAGE_DEBUG_DIRECTORY)) == 0) &&
        (ULONG_PTR)DebugDirectories - (ULONG_PTR)Base + Size <= MappedSize)
    {
        NumberOfDebugDirectories = Size / sizeof (IMAGE_DEBUG_DIRECTORY);

        for (i = 0 ; i < NumberOfDebugDirectories; i++)
        {
            //
            // We should check if it's a NB10 or something record.
            //

            if ((DebugDirectories[ i ].Type == DebugRecordType) &&
                (DebugDirectories[ i ].SizeOfData < DebugRecordMaxSize))
            {
                if (DebugDirectories[i].PointerToRawData +
                    DebugDirectories[i].SizeOfData > MappedSize)
                {
                    return E_INVALIDARG;
                }
                
                Size = DebugDirectories [ i ].SizeOfData;
                PVOID NewInfo = AllocMemory(Dump, Size);
                if (!NewInfo)
                {
                    return E_OUTOFMEMORY;
                }

                CopyMemory(NewInfo,
                           ((PBYTE) Base) +
                           DebugDirectories [ i ].PointerToRawData,
                           Size);

                *DebugInfo = NewInfo;
                *SizeOfDebugInfo = Size;
                return S_OK;
            }
        }
    }

    return E_INVALIDARG;
}


HRESULT
GenAddDataSection(IN PMINIDUMP_STATE Dump,
                  IN PINTERNAL_PROCESS Process,
                  IN PINTERNAL_MODULE Module,
                  IN PIMAGE_SECTION_HEADER Section)
{
    HRESULT Status = S_OK;
    
    if ( (Section->Characteristics & IMAGE_SCN_MEM_WRITE) &&
         (Section->Characteristics & IMAGE_SCN_MEM_READ) &&
         ( (Section->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) ||
           (Section->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA) )) {

        Status = GenAddMemoryBlock(Dump, Process, MEMBLOCK_DATA_SEG,
                                   Section->VirtualAddress +
                                   Module->BaseOfImage,
                                   Section->Misc.VirtualSize);
        
#if 0
        if (Status == S_OK) {   
            printf ("Section: %8.8s Addr: %0I64x Size: %08x Raw Size: %08x\n",
                    Section->Name,
                    Section->VirtualAddress + Module->BaseOfImage,
                    Section->Misc.VirtualSize,
                    Section->SizeOfRawData);
        }
#endif
    }

    return Status;
}

HRESULT
GenGetDataContributors(
    IN PMINIDUMP_STATE Dump,
    IN OUT PINTERNAL_PROCESS Process,
    IN PINTERNAL_MODULE Module
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;
    HRESULT Status;
    PVOID MappedBase;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG MappedSize;
    UCHAR HeaderBuffer[512];
    PVOID HeaderBase;
    GenMiniDumpProviderCallbacks Callbacks(Dump, Process);

    // See if the provider wants to handle this.
    Callbacks.PushMemType(MEMBLOCK_DATA_SEG);
    if (Dump->SysProv->
        EnumImageDataSections(Process->ProcessHandle, Module->FullPath,
                              Module->BaseOfImage, &Callbacks) == S_OK) {
        // Provider did everything.
        return S_OK;
    }
    
    if ((Status = Dump->SysProv->
         OpenMapping(Module->FullPath, &MappedSize, NULL, 0,
                     &MappedBase)) != S_OK) {
        
        MappedBase = NULL;

        // If we can't map the file try and read the image
        // data from the process.
        if ((Status = Dump->SysProv->
             ReadAllVirtual(Dump->ProcessHandle,
                            Module->BaseOfImage,
                            HeaderBuffer,
                            sizeof(HeaderBuffer))) != S_OK) {
            GenAccumulateStatus(Dump, MDSTATUS_UNABLE_TO_READ_MEMORY);
            return Status;
        }

        HeaderBase = HeaderBuffer;
        
    } else {

        HeaderBase = MappedBase;
    }

    NtHeaders = GenImageNtHeader(HeaderBase, NULL);
    if (!NtHeaders) {
        
        Status = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
        
    } else {

        HRESULT OneStatus;

        Status = S_OK;
        NtSection = IMAGE_FIRST_SECTION ( NtHeaders );
        
        if (MappedBase) {
        
            __try {
        
                for (i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++) {
                    if ((OneStatus =
                         GenAddDataSection(Dump, Process, Module,
                                           &NtSection[i])) != S_OK) {
                        Status = OneStatus;
                    }
                }
        
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                Status = HRESULT_FROM_NT(GetExceptionCode());
            }

        } else {

            ULONG64 SectionOffs;
            IMAGE_SECTION_HEADER SectionBuffer;

            SectionOffs = Module->BaseOfImage +
                ((ULONG_PTR)NtSection - (ULONG_PTR)HeaderBase);
                
            for (i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++) {
                if ((OneStatus = Dump->SysProv->
                     ReadAllVirtual(Dump->ProcessHandle,
                                    SectionOffs,
                                    &SectionBuffer,
                                    sizeof(SectionBuffer))) != S_OK) {
                    Status = OneStatus;
                } else if ((OneStatus =
                            GenAddDataSection(Dump, Process, Module,
                                              &SectionBuffer)) != S_OK) {
                    Status = OneStatus;
                }

                SectionOffs += sizeof(SectionBuffer);
            }
        }
    }

    if (MappedBase) {
        Dump->SysProv->CloseMapping(MappedBase);
    }
    return Status;
}


HRESULT
GenAllocateThreadObject(
    IN PMINIDUMP_STATE Dump,
    IN struct _INTERNAL_PROCESS* Process,
    IN ULONG ThreadId,
    IN ULONG WriteFlags,
    PINTERNAL_THREAD* ThreadRet
    )

/*++

Routine Description:

    Allocate and initialize an INTERNAL_THREAD structure.

Return Values:

    S_OK on success.

    S_FALSE if the thread can't be opened.
    
    Errors on failure.

--*/

{
    HRESULT Status;
    PINTERNAL_THREAD Thread;
    ULONG64 StackEnd;
    ULONG64 StackLimit;
    ULONG64 StoreLimit;
    ULONG64 StoreCurrent;

    Thread = (PINTERNAL_THREAD)
        AllocMemory ( Dump, sizeof (INTERNAL_THREAD) + Dump->ContextSize );
    if (Thread == NULL) {
        return E_OUTOFMEMORY;
    }

    *ThreadRet = Thread;
    
    Thread->ThreadId = ThreadId;
    Status = Dump->SysProv->
        OpenThread(THREAD_ALL_ACCESS,
                   FALSE,
                   Thread->ThreadId,
                   &Thread->ThreadHandle);
    if (Status != S_OK) {
        // The thread may have exited before we got around
        // to trying to open it.  If the open fails with
        // a not-found code return an alternate success to
        // indicate that it's not a critical failure.
        if (Status == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) ||
            Status == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
            Status == HRESULT_FROM_NT(STATUS_INVALID_CID)) {
            Status = S_FALSE;
        } else if (SUCCEEDED(Status)) {
            Status = E_FAIL;
        }
        if (FAILED(Status)) {
            GenAccumulateStatus(Dump, MDSTATUS_CALL_FAILED);
        }
        goto Exit;
    }

    // If the current thread is dumping itself we can't
    // suspend.  We can also assume the suspend count must
    // be zero since the thread is running.
    if (Thread->ThreadId == Dump->SysProv->GetCurrentThreadId()) {
        Thread->SuspendCount = 0;
    } else {
        Thread->SuspendCount = Dump->SysProv->
            SuspendThread ( Thread->ThreadHandle );
    }
    Thread->WriteFlags = WriteFlags;

    //
    // Add this if we ever need it
    //

    Thread->PriorityClass = 0;
    Thread->Priority = 0;

    //
    // Initialize the thread context.
    //

    Thread->ContextBuffer = Thread + 1;
    Status = Dump->SysProv->
        GetThreadContext (Thread->ThreadHandle,
                          Thread->ContextBuffer,
                          Dump->ContextSize,
                          &Thread->CurrentPc,
                          &StackEnd,
                          &StoreCurrent);
    if ( Status != S_OK ) {
        GenAccumulateStatus(Dump, MDSTATUS_CALL_FAILED);
        goto Exit;
    }

    if (Dump->CpuType == IMAGE_FILE_MACHINE_I386) {

        //
        // Note: for FPO frames on x86 we access bytes outside of the
        // ESP - StackBase range. Add a couple of bytes extra here so we
        // don't fail these cases.
        //

        StackEnd -= X86_STACK_FRAME_EXTRA_FPO_BYTES;
    }
    
    if ((Status = Dump->SysProv->
         GetThreadInfo(Dump->ProcessHandle,
                       Thread->ThreadHandle,
                       &Thread->Teb,
                       &Thread->SizeOfTeb,
                       &Thread->StackBase,
                       &StackLimit,
                       &Thread->BackingStoreBase,
                       &StoreLimit)) != S_OK) {
        goto Exit;
    }

    //
    // If the stack pointer (SP) is within the range of the stack
    // region (as allocated by the OS), only take memory from
    // the stack region up to the SP. Otherwise, assume the program
    // has blown it's SP -- purposefully, or not -- and copy
    // the entire stack as known by the OS.
    //

    if (Dump->BackingStore) {
        Thread->BackingStoreSize =
            (ULONG)(StoreCurrent - Thread->BackingStoreBase);
    } else {
        Thread->BackingStoreSize = 0;
    }

    if (StackLimit <= StackEnd && StackEnd < Thread->StackBase) {
        Thread->StackEnd = StackEnd;
    } else {
        Thread->StackEnd = StackLimit;
    }

    if ((ULONG)(Thread->StackBase - Thread->StackEnd) >
        Process->MaxStackOrStoreSize) {
        Process->MaxStackOrStoreSize =
            (ULONG)(Thread->StackBase - Thread->StackEnd);
    }
    if (Thread->BackingStoreSize > Process->MaxStackOrStoreSize) {
        Process->MaxStackOrStoreSize = Thread->BackingStoreSize;
    }
    
Exit:

    if ( Status != S_OK ) {
        FreeMemory ( Dump, Thread );
    }

    return Status;
}

VOID
GenFreeThreadObject(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_THREAD Thread
    )
{
    if (Thread->SuspendCount != -1 &&
        Thread->ThreadId != Dump->SysProv->GetCurrentThreadId()) {
        Dump->SysProv->ResumeThread (Thread->ThreadHandle);
        Thread->SuspendCount = -1;
    }
    Dump->SysProv->CloseThread(Thread->ThreadHandle);
    Thread->ThreadHandle = NULL;
    FreeMemory ( Dump, Thread );
    Thread = NULL;
}

HRESULT
GenGetThreadInstructionWindow(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN PINTERNAL_THREAD Thread
    )
{
    PVOID MemBuf;
    ULONG64 InstrStart;
    ULONG InstrSize;
    ULONG BytesRead;
    HRESULT Status = E_FAIL;

    if (!Dump->InstructionWindowSize) {
        return S_OK;
    }
    
    //
    // Store a window of the instruction stream around
    // the current program counter.  This allows some
    // instruction context to be given even when images
    // can't be mapped.  It also allows instruction
    // context to be given for generated code where
    // no image contains the necessary instructions.
    //

    InstrStart = Thread->CurrentPc - Dump->InstructionWindowSize / 2;
    InstrSize = Dump->InstructionWindowSize;
        
    MemBuf = AllocMemory(Dump, InstrSize);
    if (!MemBuf) {
        return E_OUTOFMEMORY;
    }

    for (;;) {
        // If we can read the instructions through the
        // current program counter we'll say that's
        // good enough.
        if (Dump->SysProv->
            ReadVirtual(Dump->ProcessHandle,
                        InstrStart,
                        MemBuf,
                        InstrSize,
                        &BytesRead) == S_OK &&
            InstrStart + BytesRead >
            Thread->CurrentPc) {
            Status = GenAddMemoryBlock(Dump, Process, MEMBLOCK_INSTR_WINDOW,
                                       InstrStart, BytesRead);
            break;
        }

        // We couldn't read up to the program counter.
        // If the start address is on the previous page
        // move it up to the same page.
        if ((InstrStart & ~((ULONG64)Dump->PageSize - 1)) !=
            (Thread->CurrentPc & ~((ULONG64)Dump->PageSize - 1))) {
            ULONG Fraction = Dump->PageSize -
                (ULONG)InstrStart & (Dump->PageSize - 1);
            InstrSize -= Fraction;
            InstrStart += Fraction;
        } else {
            // The start and PC were on the same page so
            // we just can't read memory.  There may have been
            // a jump to a bad address or something, so this
            // doesn't constitute an unexpected failure.
            break;
        }
    }
    
    FreeMemory(Dump, MemBuf);
    return Status;
}

PWSTR
GenGetPathTail(
    IN PWSTR Path
    )
{
    PWSTR Scan = Path + GenStrLengthW(Path);
    while (Scan > Path) {
        Scan--;
        if (*Scan == '\\' ||
            *Scan == '/' ||
            *Scan == ':') {
            return Scan + 1;
        }
    }
    return Path;
}

HRESULT
GenAllocateModuleObject(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN PWSTR FullPathW,
    IN ULONG64 BaseOfModule,
    IN ULONG WriteFlags,
    OUT PINTERNAL_MODULE* ModuleRet
    )

/*++

Routine Description:

    Given the full-path to the module and the base of the module, create and
    initialize an INTERNAL_MODULE object, and return it.

--*/

{
    HRESULT Status;
    PVOID MappedBase;
    ULONG MappedSize;
    PIMAGE_NT_HEADERS NtHeaders;
    PINTERNAL_MODULE Module;
    ULONG Chars;

    ASSERT (FullPathW);
    ASSERT (BaseOfModule);

    Module = (PINTERNAL_MODULE)
        AllocMemory ( Dump, sizeof (INTERNAL_MODULE) );
    if (Module == NULL) {
        return E_OUTOFMEMORY;
    }
    
    //
    // Get the version information for the module.
    //

    if ((Status = Dump->SysProv->
         GetImageVersionInfo(Dump->ProcessHandle, FullPathW, BaseOfModule,
                             &Module->VersionInfo)) != S_OK) {
        ZeroMemory(&Module->VersionInfo, sizeof(Module->VersionInfo));
    }

    if ((Status = Dump->SysProv->
         OpenMapping(FullPathW, &MappedSize,
                     Module->FullPath, ARRAY_COUNT(Module->FullPath),
                     &MappedBase)) != S_OK) {
        
        MappedBase = NULL;

        // Some providers can't map but still have image
        // information.  Try that.
        if ((Status = Dump->SysProv->
             GetImageHeaderInfo(Dump->ProcessHandle,
                                FullPathW,
                                BaseOfModule,
                                &Module->SizeOfImage,
                                &Module->CheckSum,
                                &Module->TimeDateStamp)) != S_OK) {
            GenAccumulateStatus(Dump, MDSTATUS_CALL_FAILED);
            FreeMemory(Dump, Module);
            return Status;
        }

        // No long path name is available so just use
        // the incoming path.
        GenStrCopyNW(Module->FullPath, FullPathW,
                     ARRAY_COUNT(Module->FullPath));
    }

    if (IsFlagSet(Dump->DumpType, MiniDumpFilterModulePaths)) {
        Module->SavePath = GenGetPathTail(Module->FullPath);
    } else {
        Module->SavePath = Module->FullPath;
    }

    Module->BaseOfImage = BaseOfModule;
    Module->WriteFlags = WriteFlags;

    Module->CvRecord = NULL;
    Module->SizeOfCvRecord = 0;
    Module->MiscRecord = NULL;
    Module->SizeOfMiscRecord = 0;
    
    if (MappedBase) {

        IMAGE_NT_HEADERS64 Hdr64;
        
        NtHeaders = GenImageNtHeader ( MappedBase, &Hdr64 );
        if (!NtHeaders) {
            GenAccumulateStatus(Dump, MDSTATUS_CALL_FAILED);
            FreeMemory(Dump, Module);
            return HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
        }
        
        __try {
        
            //
            // Cull information from the image header.
            //
            
            Module->SizeOfImage = Hdr64.OptionalHeader.SizeOfImage;
            Module->CheckSum = Hdr64.OptionalHeader.CheckSum;
            Module->TimeDateStamp = Hdr64.FileHeader.TimeDateStamp;

            //
            // Get the CV record from the debug directory.
            //

            if (IsFlagSet(Module->WriteFlags, ModuleWriteCvRecord)) {
                GenGetDebugRecord(Dump,
                                  MappedBase,
                                  MappedSize,
                                  IMAGE_DEBUG_TYPE_CODEVIEW,
                                  REASONABLE_NB11_RECORD_SIZE,
                                  &Module->CvRecord,
                                  &Module->SizeOfCvRecord);
            }

            //
            // Get the MISC record from the debug directory.
            //

            if (IsFlagSet(Module->WriteFlags, ModuleWriteMiscRecord)) {
                GenGetDebugRecord(Dump,
                                  MappedBase,
                                  MappedSize,
                                  IMAGE_DEBUG_TYPE_MISC,
                                  REASONABLE_MISC_RECORD_SIZE,
                                  &Module->MiscRecord,
                                  &Module->SizeOfMiscRecord);
            }

            Status = S_OK;
            
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            Status = HRESULT_FROM_NT(GetExceptionCode());
        }

        Dump->SysProv->CloseMapping(MappedBase);

        if (Status != S_OK) {
            GenAccumulateStatus(Dump, MDSTATUS_CALL_FAILED);
            FreeMemory(Dump, Module);
            return Status;
        }
    } else {

        ULONG RecordLen;
        
        //
        // See if the provider can retrieve debug records.
        //

        RecordLen = 0;
        if (IsFlagSet(Module->WriteFlags, ModuleWriteCvRecord) &&
            Dump->SysProv->
            GetImageDebugRecord(Process->ProcessHandle,
                                Module->FullPath,
                                Module->BaseOfImage,
                                IMAGE_DEBUG_TYPE_CODEVIEW,
                                NULL,
                                &RecordLen) == S_OK &&
            RecordLen <= REASONABLE_NB11_RECORD_SIZE &&
            (Module->CvRecord = AllocMemory(Dump, RecordLen))) {

            Module->SizeOfCvRecord = RecordLen;
            if (Dump->SysProv->
                GetImageDebugRecord(Process->ProcessHandle,
                                    Module->FullPath,
                                    Module->BaseOfImage,
                                    IMAGE_DEBUG_TYPE_CODEVIEW,
                                    Module->CvRecord,
                                    &Module->SizeOfCvRecord) != S_OK) {
                FreeMemory(Dump, Module->CvRecord);
                Module->CvRecord = NULL;
                Module->SizeOfCvRecord = 0;
            }
        }

        RecordLen = 0;
        if (IsFlagSet(Module->WriteFlags, ModuleWriteMiscRecord) &&
            Dump->SysProv->
            GetImageDebugRecord(Process->ProcessHandle,
                                Module->FullPath,
                                Module->BaseOfImage,
                                IMAGE_DEBUG_TYPE_CODEVIEW,
                                NULL,
                                &RecordLen) == S_OK &&
            RecordLen <= REASONABLE_MISC_RECORD_SIZE &&
            (Module->MiscRecord = AllocMemory(Dump, RecordLen))) {

            Module->SizeOfMiscRecord = RecordLen;
            if (Dump->SysProv->
                GetImageDebugRecord(Process->ProcessHandle,
                                    Module->FullPath,
                                    Module->BaseOfImage,
                                    IMAGE_DEBUG_TYPE_MISC,
                                    Module->MiscRecord,
                                    &Module->SizeOfMiscRecord) != S_OK) {
                FreeMemory(Dump, Module->MiscRecord);
                Module->MiscRecord = NULL;
                Module->SizeOfMiscRecord = 0;
            }
        }
    }

    *ModuleRet = Module;
    return S_OK;
}

VOID
GenFreeModuleObject(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_MODULE Module
    )
{
    FreeMemory ( Dump, Module->CvRecord );
    Module->CvRecord = NULL;

    FreeMemory ( Dump, Module->MiscRecord );
    Module->MiscRecord = NULL;

    FreeMemory ( Dump, Module );
    Module = NULL;
}

HRESULT
GenAllocateUnloadedModuleObject(
    IN PMINIDUMP_STATE Dump,
    IN PWSTR Path,
    IN ULONG64 BaseOfModule,
    IN ULONG SizeOfModule,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp,
    OUT PINTERNAL_UNLOADED_MODULE* ModuleRet
    )
{
    PINTERNAL_UNLOADED_MODULE Module;

    Module = (PINTERNAL_UNLOADED_MODULE)
        AllocMemory ( Dump, sizeof (*Module) );
    if (Module == NULL) {
        return E_OUTOFMEMORY;
    }
    
    GenStrCopyNW(Module->Path, Path, ARRAY_COUNT(Module->Path));

    Module->BaseOfImage = BaseOfModule;
    Module->SizeOfImage = SizeOfModule;
    Module->CheckSum = CheckSum;
    Module->TimeDateStamp = TimeDateStamp;

    *ModuleRet = Module;
    return S_OK;
}

VOID
GenFreeUnloadedModuleObject(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_UNLOADED_MODULE Module
    )
{
    FreeMemory ( Dump, Module );
    Module = NULL;
}

HRESULT
GenAllocateFunctionTableObject(
    IN PMINIDUMP_STATE Dump,
    IN ULONG64 MinAddress,
    IN ULONG64 MaxAddress,
    IN ULONG64 BaseAddress,
    IN ULONG EntryCount,
    IN PVOID RawTable,
    OUT PINTERNAL_FUNCTION_TABLE* TableRet
    )
{
    PINTERNAL_FUNCTION_TABLE Table;

    Table = (PINTERNAL_FUNCTION_TABLE)
        AllocMemory(Dump, sizeof(INTERNAL_FUNCTION_TABLE) +
                    Dump->FuncTableSize);
    if (!Table) {
        return E_OUTOFMEMORY;
    }
    Table->RawEntries =
        AllocMemory(Dump, Dump->FuncTableEntrySize * EntryCount);
    if (!Table->RawEntries) {
        FreeMemory(Dump, Table);
        return E_OUTOFMEMORY;
    }

    Table->MinimumAddress = MinAddress;
    Table->MaximumAddress = MaxAddress;
    Table->BaseAddress = BaseAddress;
    Table->EntryCount = EntryCount;
    Table->RawTable = (Table + 1);
    memcpy(Table->RawTable, RawTable, Dump->FuncTableSize);

    *TableRet = Table;
    return S_OK;
}

VOID
GenFreeFunctionTableObject(
    IN PMINIDUMP_STATE Dump,
    IN struct _INTERNAL_FUNCTION_TABLE* Table
    )
{
    if (Table->RawEntries) {
        FreeMemory(Dump, Table->RawEntries);
    }

    FreeMemory(Dump, Table);
}

HRESULT
GenAllocateProcessObject(
    IN PMINIDUMP_STATE Dump,
    OUT PINTERNAL_PROCESS* ProcessRet
    )
{
    HRESULT Status;
    PINTERNAL_PROCESS Process;
    FILETIME Create, Exit, User, Kernel;

    Process = (PINTERNAL_PROCESS)
        AllocMemory ( Dump, sizeof (INTERNAL_PROCESS) );
    if (!Process) {
        return E_OUTOFMEMORY;
    }

    Process->ProcessId = Dump->ProcessId;
    Process->ProcessHandle = Dump->ProcessHandle;
    Process->NumberOfThreads = 0;
    Process->NumberOfModules = 0;
    Process->NumberOfFunctionTables = 0;
    InitializeListHead (&Process->ThreadList);
    InitializeListHead (&Process->ModuleList);
    InitializeListHead (&Process->UnloadedModuleList);
    InitializeListHead (&Process->FunctionTableList);
    InitializeListHead (&Process->MemoryBlocks);

    if ((Status = Dump->SysProv->
         GetPeb(Dump->ProcessHandle,
                &Process->Peb, &Process->SizeOfPeb)) != S_OK) {
        // Failure is only critical if the dump needs
        // to include PEB memory.
        if (Dump->DumpType & MiniDumpWithProcessThreadData) {
            FreeMemory(Dump, Process);
            return Status;
        } else {
            Process->Peb = 0;
            Process->SizeOfPeb = 0;
        }
    }

    // Win9x doesn't support GetProcessTimes so failures
    // here are possible.
    if (Dump->SysProv->
        GetProcessTimes(Dump->ProcessHandle,
                        &Create, &User, &Kernel) == S_OK) {
        Process->TimesValid = TRUE;
        Process->CreateTime = FileTimeToTimeDate(&Create);
        Process->UserTime = FileTimeToSeconds(&User);
        Process->KernelTime = FileTimeToSeconds(&Kernel);
    }

    *ProcessRet = Process;
    return S_OK;
}

VOID
GenFreeProcessObject(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process
    )
{
    PINTERNAL_MODULE Module;
    PINTERNAL_UNLOADED_MODULE UnlModule;
    PINTERNAL_THREAD Thread;
    PINTERNAL_FUNCTION_TABLE Table;
    PVA_RANGE Range;
    PLIST_ENTRY Entry;

    Thread = NULL;
    Module = NULL;

    Entry = Process->ModuleList.Flink;
    while ( Entry != &Process->ModuleList ) {

        Module = CONTAINING_RECORD (Entry, INTERNAL_MODULE, ModulesLink);
        Entry = Entry->Flink;

        GenFreeModuleObject ( Dump, Module );
    }

    Entry = Process->UnloadedModuleList.Flink;
    while ( Entry != &Process->UnloadedModuleList ) {

        UnlModule = CONTAINING_RECORD (Entry, INTERNAL_UNLOADED_MODULE,
                                       ModulesLink);
        Entry = Entry->Flink;

        GenFreeUnloadedModuleObject ( Dump, UnlModule );
    }

    Entry = Process->ThreadList.Flink;
    while ( Entry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (Entry, INTERNAL_THREAD, ThreadsLink);
        Entry = Entry->Flink;

        GenFreeThreadObject ( Dump, Thread );
    }

    Entry = Process->FunctionTableList.Flink;
    while ( Entry != &Process->FunctionTableList ) {

        Table = CONTAINING_RECORD (Entry, INTERNAL_FUNCTION_TABLE, TableLink);
        Entry = Entry->Flink;

        GenFreeFunctionTableObject ( Dump, Table );
    }

    Entry = Process->MemoryBlocks.Flink;
    while (Entry != &Process->MemoryBlocks) {
        Range = CONTAINING_RECORD(Entry, VA_RANGE, NextLink);
        Entry = Entry->Flink;
        FreeMemory(Dump, Range);
    }

    FreeMemory ( Dump, Process );
    Process = NULL;
}

HRESULT
GenIncludeUnwindInfoMemory(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN PINTERNAL_FUNCTION_TABLE Table
    )
{
    HRESULT Status;
    ULONG i;
    
    if (Dump->DumpType & MiniDumpWithFullMemory) {
        // Memory will be included by default.
        return S_OK;
    }
    
    for (i = 0; i < Table->EntryCount; i++) {

        ULONG64 Start;
        ULONG Size;

        if ((Status = Dump->SysProv->
             EnumFunctionTableEntryMemory(Table->BaseAddress,
                                          Table->RawEntries,
                                          i,
                                          &Start,
                                          &Size)) != S_OK) {
            return Status;
        }

        if ((Status = GenAddMemoryBlock(Dump, Process, MEMBLOCK_UNWIND_INFO,
                                        Start, Size)) != S_OK) {
            return Status;
        }
    }

    return S_OK;
}

void
GenRemoveMemoryBlock(
    IN PINTERNAL_PROCESS Process,
    IN PVA_RANGE Block
    )
{
    RemoveEntryList(&Block->NextLink);
    Process->NumberOfMemoryBlocks--;
    Process->SizeOfMemoryBlocks -= Block->Size;
}

HRESULT
GenAddMemoryBlock(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN MEMBLOCK_TYPE Type,
    IN ULONG64 Start,
    IN ULONG Size
    )
{
    ULONG64 End;
    PLIST_ENTRY ScanEntry;
    PVA_RANGE Scan;
    ULONG64 ScanEnd;
    PVA_RANGE New = NULL;
    SIZE_T Done;
    UCHAR Byte;

    // Do not use Size after this to avoid ULONG overflows.
    End = Start + Size;
    if (End < Start) {
        End = (ULONG64)-1;
    }
    
    if (Start == End) {
        // Nothing to add.
        return S_OK;
    }

    if ((End - Start) > ULONG_MAX - Process->SizeOfMemoryBlocks) {
        // Overflow.
        GenAccumulateStatus(Dump, MDSTATUS_INTERNAL_ERROR);
        return E_INVALIDARG;
    }

    //
    // First trim the range down to memory that can actually
    // be accessed.
    //

    while (Start < End) {
        if (Dump->SysProv->
            ReadAllVirtual(Dump->ProcessHandle,
                           Start, &Byte, sizeof(Byte)) == S_OK) {
            break;
        }

        // Move up to the next page.
        Start = (Start + Dump->PageSize) & ~((ULONG64)Dump->PageSize - 1);
        if (!Start) {
            // Wrapped around.
            return S_OK;
        }
    }

    if (Start >= End) {
        // No valid memory.
        return S_OK;
    }

    ScanEnd = (Start + Dump->PageSize) & ~((ULONG64)Dump->PageSize - 1);
    for (;;) {
        if (ScanEnd >= End) {
            break;
        }

        if (Dump->SysProv->
            ReadAllVirtual(Dump->ProcessHandle,
                           ScanEnd, &Byte, sizeof(Byte)) != S_OK) {
            End = ScanEnd;
            break;
        }

        // Move up to the next page.
        ScanEnd = (ScanEnd + Dump->PageSize) & ~((ULONG64)Dump->PageSize - 1);
        if (!ScanEnd) {
            ScanEnd--;
            break;
        }
    }

    //
    // When adding memory to the list of memory to be saved
    // we want to avoid overlaps and also coalesce adjacent regions
    // so that the list has the largest possible non-adjacent
    // blocks.  In order to accomplish this we make a pass over
    // the list and merge all listed blocks that overlap or abut the
    // incoming range with the incoming range, then remove the
    // merged entries from the list.  After this pass we have
    // a region which is guaranteed not to overlap or abut anything in
    // the list.
    //

    ScanEntry = Process->MemoryBlocks.Flink;
    while (ScanEntry != &Process->MemoryBlocks) {
        Scan = CONTAINING_RECORD(ScanEntry, VA_RANGE, NextLink);
        ScanEnd = Scan->Start + Scan->Size;
        ScanEntry = Scan->NextLink.Flink;
        
        if (Scan->Start > End || ScanEnd < Start) {
            // No overlap or adjacency.
            continue;
        }

        //
        // Compute the union of the incoming range and
        // the scan block, then remove the scan block.
        //

        if (Scan->Start < Start) {
            Start = Scan->Start;
        }
        if (ScanEnd > End) {
            End = ScanEnd;
        }

        // We've lost the specific type.  This is not a problem
        // right now but if specific types must be preserved
        // all the way through in the future it will be necessary
        // to avoid merging.
        Type = MEMBLOCK_MERGED;

        GenRemoveMemoryBlock(Process, Scan);

        if (!New) {
            // Save memory for reuse.
            New = Scan;
        } else {
            FreeMemory(Dump, Scan);
        }
    }

    if (!New) {
        New = (PVA_RANGE)AllocMemory(Dump, sizeof(*New));
        if (!New) {
            return E_OUTOFMEMORY;
        }
    }

    New->Start = Start;
    // Overflow is extremely unlikely, so don't do anything
    // fancy to handle it.
    if (End - Start > ULONG_MAX) {
        New->Size = ULONG_MAX;
    } else {
        New->Size = (ULONG)(End - Start);
    }
    New->Type = Type;
    InsertTailList(&Process->MemoryBlocks, &New->NextLink);
    Process->NumberOfMemoryBlocks++;
    Process->SizeOfMemoryBlocks += New->Size;

    return S_OK;
}

void
GenRemoveMemoryRange(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN ULONG64 Start,
    IN ULONG Size
    )
{
    ULONG64 End = Start + Size;
    PLIST_ENTRY ScanEntry;
    PVA_RANGE Scan;
    ULONG64 ScanEnd;

 Restart:
    ScanEntry = Process->MemoryBlocks.Flink;
    while (ScanEntry != &Process->MemoryBlocks) {
        Scan = CONTAINING_RECORD(ScanEntry, VA_RANGE, NextLink);
        ScanEnd = Scan->Start + Scan->Size;
        ScanEntry = Scan->NextLink.Flink;
        
        if (Scan->Start >= End || ScanEnd <= Start) {
            // No overlap.
            continue;
        }

        if (Scan->Start < Start) {
            // Trim block to non-overlapping pre-Start section.
            Scan->Size = (ULONG)(Start - Scan->Start);
            if (ScanEnd > End) {
                // There's also a non-overlapping section post-End.
                // We need to add a new block.
                GenAddMemoryBlock(Dump, Process, Scan->Type,
                                  End, (ULONG)(ScanEnd - End));
                // The list has changed so restart.
                goto Restart;
            }
        } else if (ScanEnd > End) {
            // Trim block to non-overlapping post-End section.
            Scan->Start = End;
            Scan->Size = (ULONG)(ScanEnd - End);
        } else {
            // Scan is completely contained.
            GenRemoveMemoryBlock(Process, Scan);
            FreeMemory(Dump, Scan);
        }
    }
}

HRESULT
GenAddPebMemory(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process
    )
{
    HRESULT Status = S_OK, Check;
    GenMiniDumpProviderCallbacks Callbacks(Dump, Process);

    Callbacks.PushMemType(MEMBLOCK_PEB);

    // Accumulate error status but do not stop processing
    // for errors.
    if ((Check = GenAddMemoryBlock(Dump, Process, MEMBLOCK_PEB,
                                   Process->Peb,
                                   Process->SizeOfPeb)) != S_OK) {
        Status = Check;
    }
    if (!(Dump->DumpType & MiniDumpWithoutOptionalData) &&
        (Check = Dump->SysProv->
         EnumPebMemory(Process->ProcessHandle,
                       Process->Peb, Process->SizeOfPeb,
                       &Callbacks)) != S_OK) {
        Status = Check;
    }

    Callbacks.PopMemType();

    return Status;
}

HRESULT
GenAddTebMemory(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN PINTERNAL_THREAD Thread
    )
{
    HRESULT Status = S_OK, Check;
    GenMiniDumpProviderCallbacks Callbacks(Dump, Process);

    Callbacks.PushMemType(MEMBLOCK_TEB);
    
    // Accumulate error status but do not stop processing
    // for errors.
    if ((Check = GenAddMemoryBlock(Dump, Process, MEMBLOCK_TEB,
                                   Thread->Teb, Thread->SizeOfTeb)) != S_OK) {
        Status = Check;
    }
    if (!(Dump->DumpType & MiniDumpWithoutOptionalData) &&
        (Check = Dump->SysProv->
         EnumTebMemory(Process->ProcessHandle, Thread->ThreadHandle,
                       Thread->Teb, Thread->SizeOfTeb,
                       &Callbacks)) != S_OK) {
        Status = Check;
    }

    Callbacks.PopMemType();

    return Status;
}

HRESULT
GenScanAddressSpace(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process
    )
{
    HRESULT Status;
    ULONG ProtectMask = 0, TypeMask = 0;
    ULONG64 Offset, Size;
    ULONG Protect, State, Type;

    if (Dump->DumpType & MiniDumpWithPrivateReadWriteMemory) {
        ProtectMask |= PAGE_READWRITE;
        TypeMask |= MEM_PRIVATE;
    }

    if (!ProtectMask || !TypeMask) {
        // Nothing to scan for.
        return S_OK;
    }

    Status = S_OK;

    Offset = 0;
    for (;;) {
        if (Dump->SysProv->
            QueryVirtual(Dump->ProcessHandle, Offset, &Offset, &Size,
                         &Protect, &State, &Type) != S_OK) {
            break;
        }

        ULONG64 ScanOffset = Offset;
        Offset += Size;
        
        if (State == MEM_COMMIT &&
            (Protect & ProtectMask) &&
            (Type & TypeMask)) {
            
            while (Size > 0) {
                ULONG BlockSize;
                HRESULT OneStatus;

                if (Size > ULONG_MAX / 2) {
                    BlockSize = ULONG_MAX / 2;
                } else {
                    BlockSize = (ULONG)Size;
                }
                
                if ((OneStatus =
                     GenAddMemoryBlock(Dump,
                                       Process,
                                       MEMBLOCK_PRIVATE_RW,
                                       ScanOffset,
                                       BlockSize)) != S_OK) {
                    Status = OneStatus;
                }

                ScanOffset += BlockSize;
                Size -= BlockSize;
            }
        }
    }
    
    return Status;
}

BOOL
GenAppendStrW(
    IN OUT PWSTR* Str,
    IN OUT PULONG Chars,
    IN PCWSTR Append
    )
{
    if (!Append) {
        return FALSE;
    }
    
    while (*Chars > 1 && *Append) {
        **Str = *Append++;
        (*Str)++;
        (*Chars)--;
    }
    if (!*Chars) {
        return FALSE;
    }
    **Str = 0;
    return TRUE;
}

PWSTR
GenIToAW(
    IN ULONG Val,
    IN ULONG FieldChars,
    IN WCHAR FillChar,
    IN PWSTR Buf,
    IN ULONG BufChars
    )
{
    PWSTR Store = Buf + (BufChars - 1);
    *Store-- = 0;

    if (Val == 0) {
        *Store-- = L'0';
    } else {
        while (Val) {
            if (Store < Buf) {
                return NULL;
            }
            
            *Store-- = (WCHAR)(Val % 10) + L'0';
            Val /= 10;
        }
    }

    PWSTR FieldStart = Buf + (BufChars - 1) - FieldChars;
    while (Store >= FieldStart) {
        *Store-- = FillChar;
    }
    return Store + 1;
}

class GenCorDataAccessServices : public ICorDataAccessServices
{
public:
    GenCorDataAccessServices(IN PMINIDUMP_STATE Dump,
                             IN PINTERNAL_PROCESS Process)
    {
        m_Dump = Dump;
        m_Process = Process;
    }

    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        )
    {
        *Interface = NULL;
        return E_NOINTERFACE;
    }
    STDMETHOD_(ULONG, AddRef)(
        THIS
        )
    {
        return 1;
    }
    STDMETHOD_(ULONG, Release)(
        THIS
        )
    {
        return 0;
    }

    // ICorDataAccessServices.
    virtual HRESULT STDMETHODCALLTYPE GetMachineType( 
        /* [out] */ ULONG32 *machine);
    virtual HRESULT STDMETHODCALLTYPE GetPointerSize( 
        /* [out] */ ULONG32 *size);
    virtual HRESULT STDMETHODCALLTYPE GetImageBase( 
        /* [string][in] */ LPCWSTR name,
        /* [out] */ CORDATA_ADDRESS *base);
    virtual HRESULT STDMETHODCALLTYPE ReadVirtual( 
        /* [in] */ CORDATA_ADDRESS address,
        /* [length_is][size_is][out] */ PBYTE buffer,
        /* [in] */ ULONG32 request,
        /* [optional][out] */ ULONG32 *done);
    virtual HRESULT STDMETHODCALLTYPE WriteVirtual( 
        /* [in] */ CORDATA_ADDRESS address,
        /* [size_is][in] */ PBYTE buffer,
        /* [in] */ ULONG32 request,
        /* [optional][out] */ ULONG32 *done);
    virtual HRESULT STDMETHODCALLTYPE GetTlsValue(
        /* [in] */ ULONG32 index,
        /* [out] */ CORDATA_ADDRESS* value);
    virtual HRESULT STDMETHODCALLTYPE SetTlsValue(
        /* [in] */ ULONG32 index,
        /* [in] */ CORDATA_ADDRESS value);
    virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadId(
        /* [out] */ ULONG32* threadId);
    virtual HRESULT STDMETHODCALLTYPE GetThreadContext(
        /* [in] */ ULONG32 threadId,
        /* [in] */ ULONG32 contextFlags,
        /* [in] */ ULONG32 contextSize,
        /* [out, size_is(contextSize)] */ PBYTE context);
    virtual HRESULT STDMETHODCALLTYPE SetThreadContext(
        /* [in] */ ULONG32 threadId,
        /* [in] */ ULONG32 contextSize,
        /* [in, size_is(contextSize)] */ PBYTE context);

    PMINIDUMP_STATE m_Dump;
    PINTERNAL_PROCESS m_Process;
};

HRESULT STDMETHODCALLTYPE
GenCorDataAccessServices::GetMachineType( 
    /* [out] */ ULONG32 *machine
    )
{
    *machine = m_Dump->CpuType;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
GenCorDataAccessServices::GetPointerSize( 
    /* [out] */ ULONG32 *size
    )
{
    *size = m_Dump->PtrSize;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
GenCorDataAccessServices::GetImageBase( 
    /* [string][in] */ LPCWSTR name,
    /* [out] */ CORDATA_ADDRESS *base
    )
{
    if ((!GenStrCompareW(name, L"mscoree.dll") &&
         !GenStrCompareW(m_Process->CorDllType, L"ee")) ||
        (!GenStrCompareW(name, L"mscorwks.dll") &&
         !GenStrCompareW(m_Process->CorDllType, L"wks")) ||
        (!GenStrCompareW(name, L"mscorsvr.dll") &&
         !GenStrCompareW(m_Process->CorDllType, L"svr"))) {
        *base = m_Process->CorDllBase;
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT STDMETHODCALLTYPE
GenCorDataAccessServices::ReadVirtual( 
    /* [in] */ CORDATA_ADDRESS address,
    /* [length_is][size_is][out] */ PBYTE buffer,
    /* [in] */ ULONG32 request,
    /* [optional][out] */ ULONG32 *done
    )
{
    return m_Dump->SysProv->
        ReadVirtual(m_Process->ProcessHandle,
                    address, buffer, request, (PULONG)done);
}

HRESULT STDMETHODCALLTYPE
GenCorDataAccessServices::WriteVirtual( 
    /* [in] */ CORDATA_ADDRESS address,
    /* [size_is][in] */ PBYTE buffer,
    /* [in] */ ULONG32 request,
    /* [optional][out] */ ULONG32 *done)
{
    // No modification supported.
    return E_UNEXPECTED;
}

HRESULT STDMETHODCALLTYPE
GenCorDataAccessServices::GetTlsValue(
    /* [in] */ ULONG32 index,
    /* [out] */ CORDATA_ADDRESS* value
    )
{
    // Not needed for minidump.
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
GenCorDataAccessServices::SetTlsValue(
    /* [in] */ ULONG32 index,
    /* [in] */ CORDATA_ADDRESS value)
{
    // No modification supported.
    return E_UNEXPECTED;
}

HRESULT STDMETHODCALLTYPE
GenCorDataAccessServices::GetCurrentThreadId(
    /* [out] */ ULONG32* threadId)
{
    // Not needed for minidump.
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
GenCorDataAccessServices::GetThreadContext(
    /* [in] */ ULONG32 threadId,
    /* [in] */ ULONG32 contextFlags,
    /* [in] */ ULONG32 contextSize,
    /* [out, size_is(contextSize)] */ PBYTE context
    )
{
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY Entry;

    Entry = m_Process->ThreadList.Flink;
    while (Entry != &m_Process->ThreadList) {

        Thread = CONTAINING_RECORD(Entry,
                                   INTERNAL_THREAD,
                                   ThreadsLink);
        Entry = Entry->Flink;

        if (Thread->ThreadId == threadId) {
            ULONG64 Ignored;
            
            return m_Dump->SysProv->
                GetThreadContext(Thread->ThreadHandle,
                                 context, contextSize,
                                 &Ignored, &Ignored, &Ignored);
        }
    }

    return E_NOINTERFACE;
}

HRESULT STDMETHODCALLTYPE
GenCorDataAccessServices::SetThreadContext(
    /* [in] */ ULONG32 threadId,
    /* [in] */ ULONG32 contextSize,
    /* [in, size_is(contextSize)] */ PBYTE context)
{
    // No modification supported.
    return E_UNEXPECTED;
}

class GenCorDataEnumMemoryRegions : public ICorDataEnumMemoryRegions
{
public:
    GenCorDataEnumMemoryRegions(IN PMINIDUMP_STATE Dump,
                                IN PINTERNAL_PROCESS Process)
    {
        m_Dump = Dump;
        m_Process = Process;
    }

    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        )
    {
        *Interface = NULL;
        return E_NOINTERFACE;
    }
    STDMETHOD_(ULONG, AddRef)(
        THIS
        )
    {
        return 1;
    }
    STDMETHOD_(ULONG, Release)(
        THIS
        )
    {
        return 0;
    }

    // ICorDataEnumMemoryRegions.
    HRESULT STDMETHODCALLTYPE EnumMemoryRegion(
        /* [in] */ CORDATA_ADDRESS address,
        /* [in] */ ULONG32 size
        )
    {
        return GenAddMemoryBlock(m_Dump, m_Process, MEMBLOCK_COR,
                                 address, size);
    }

private:
    PMINIDUMP_STATE m_Dump;
    PINTERNAL_PROCESS m_Process;
};

HRESULT
GenTryGetCorMemory(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN PWSTR CorDebugDllPath,
    OUT PBOOL Loaded
    )
{
    HRESULT Status;
    GenCorDataAccessServices Services(Dump, Process);
    GenCorDataEnumMemoryRegions EnumMem(Dump, Process);
    ICorDataAccess* Access;

    *Loaded = FALSE;
        
    if ((Status = Dump->SysProv->
         GetCorDataAccess(CorDebugDllPath, &Services, &Access)) != S_OK) {
        return Status;
    }

    *Loaded = TRUE;
    
    Status = Access->EnumMemoryRegions(&EnumMem, DAC_ENUM_MEM_DEFAULT);
    
    Dump->SysProv->ReleaseCorDataAccess(Access);
    return Status;
}

HRESULT
GenGetCorMemory(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process
    )
{
    HRESULT Status;

    // Do not enable COR memory gathering for .NET Server
    // as it's not stable yet.
#ifdef GET_COR_MEMORY
    if (!Process->CorDllType) {
        // COR is not loaded.
        return S_OK;
    }
    if (Dump->DumpType & (MiniDumpWithFullMemory |
                          MiniDumpWithPrivateReadWriteMemory)) {
        // All COR memory should already be included.
        return S_OK;
    }

    WCHAR CorDebugDllPath[MAX_PATH + 1];
    WCHAR NumStr[16];
    PWSTR DllPathEnd, End;
    ULONG Chars;
    BOOL Loaded;

    GenStrCopyNW(CorDebugDllPath, Process->CorDllPath,
                 ARRAY_COUNT(CorDebugDllPath));
    DllPathEnd = GenGetPathTail(CorDebugDllPath);

    //
    // First try to load with the basic name.
    //

    End = DllPathEnd;
    *End = 0;
    Chars = (ULONG)(ARRAY_COUNT(CorDebugDllPath) - (End - CorDebugDllPath));
    if (!GenAppendStrW(&End, &Chars, L"mscordacwks.dll")) {
        return E_INVALIDARG;
    }

    if ((Status = GenTryGetCorMemory(Dump, Process, CorDebugDllPath,
                                     &Loaded)) == S_OK ||
        Loaded)
    {
        return Status;
    }

    //
    // That didn't work, so try with the full name.
    //

#if defined(_X86_)
    PWSTR HostCpu = L"x86";
#elif defined(_IA64_)
    PWSTR HostCpu = L"IA64";
#elif defined(_AMD64_)
    PWSTR HostCpu = L"AMD64";
#elif defined(_ARM_)
    PWSTR HostCpu = L"ARM";
#else
#error Unknown processor.
#endif

    if (!GenAppendStrW(&End, &Chars, L"mscordac") ||
        !GenAppendStrW(&End, &Chars, Process->CorDllType) ||
        !GenAppendStrW(&End, &Chars, L"_") ||
        !GenAppendStrW(&End, &Chars, HostCpu) ||
        !GenAppendStrW(&End, &Chars, L"_") ||
        !GenAppendStrW(&End, &Chars, Dump->CpuTypeName) ||
        !GenAppendStrW(&End, &Chars, L"_") ||
        !GenAppendStrW(&End, &Chars,
                       GenIToAW(Process->CorDllVer.dwFileVersionMS >> 16,
                                0, 0, NumStr, ARRAY_COUNT(NumStr))) ||
        !GenAppendStrW(&End, &Chars, L".") ||
        !GenAppendStrW(&End, &Chars,
                       GenIToAW(Process->CorDllVer.dwFileVersionMS & 0xffff,
                                0, 0, NumStr, ARRAY_COUNT(NumStr))) ||
        !GenAppendStrW(&End, &Chars, L".") ||
        !GenAppendStrW(&End, &Chars,
                       GenIToAW(Process->CorDllVer.dwFileVersionLS >> 16,
                                0, 0, NumStr, ARRAY_COUNT(NumStr))) ||
        !GenAppendStrW(&End, &Chars, L".") ||
        !GenAppendStrW(&End, &Chars,
                       GenIToAW(Process->CorDllVer.dwFileVersionLS & 0xffff,
                                2, L'0', NumStr, ARRAY_COUNT(NumStr))) ||
        ((Process->CorDllVer.dwFileFlags & VS_FF_DEBUG) &&
         !GenAppendStrW(&End, &Chars,
                        (Process->CorDllVer.dwFileFlags & VS_FF_SPECIALBUILD) ?
                        L".dbg" : L".chk")) ||
        !GenAppendStrW(&End, &Chars, L".dll")) {
        return E_INVALIDARG;
    }

    return GenTryGetCorMemory(Dump, Process, CorDebugDllPath, &Loaded);
#else
    return S_OK;
#endif
}

HRESULT
GenGetProcessInfo(
    IN PMINIDUMP_STATE Dump,
    OUT PINTERNAL_PROCESS * ProcessRet
    )
{
    HRESULT Status;
    BOOL EnumStarted = FALSE;
    PINTERNAL_PROCESS Process;
    WCHAR UnicodePath[MAX_PATH + 10];

    if ((Status = GenAllocateProcessObject(Dump, &Process)) != S_OK) {
        return Status;
    }

    if ((Status = Dump->SysProv->StartProcessEnum(Dump->ProcessHandle,
                                                  Dump->ProcessId)) != S_OK) {
        goto Exit;
    }

    EnumStarted = TRUE;
    
    //
    // Walk thread list, suspending all threads and getting thread info.
    //

    for (;;) {

        PINTERNAL_THREAD Thread;
        ULONG ThreadId;
        
        Status = Dump->SysProv->EnumThreads(&ThreadId);
        if (Status == S_FALSE) {
            break;
        } else if (Status != S_OK) {
            goto Exit;
        }

        ULONG WriteFlags;

        if (!GenExecuteIncludeThreadCallback(Dump,
                                             ThreadId,
                                             &WriteFlags) ||
            IsFlagClear(WriteFlags, ThreadWriteThread)) {
            continue;
        }

        Status = GenAllocateThreadObject(Dump,
                                         Process,
                                         ThreadId,
                                         WriteFlags,
                                         &Thread);
        if (FAILED(Status)) {
            goto Exit;
        }

        // If Status is S_FALSE it means that the thread
        // couldn't be opened and probably exited before
        // we got to it.  Just continue on.
        if (Status == S_OK) {
            Process->NumberOfThreads++;
            InsertTailList(&Process->ThreadList, &Thread->ThreadsLink);
        }
    }

    //
    // Walk module list, getting module information.
    //

    for (;;) {
        
        PINTERNAL_MODULE Module;
        ULONG64 ModuleBase;
        
        Status = Dump->SysProv->EnumModules(&ModuleBase,
                                            UnicodePath,
                                            ARRAY_COUNT(UnicodePath));
        if (Status == S_FALSE) {
            break;
        } else if (Status != S_OK) {
            goto Exit;
        }

        PWSTR ModPathTail;
        BOOL IsCor = FALSE;

        ModPathTail = GenGetPathTail(UnicodePath);
        if (!GenStrCompareW(ModPathTail, L"mscoree.dll") &&
            !Process->CorDllType) {
            IsCor = TRUE;
            Process->CorDllType = L"ee";
        } else if (!GenStrCompareW(ModPathTail, L"mscorwks.dll")) {
            IsCor = TRUE;
            Process->CorDllType = L"wks";
        } else if (!GenStrCompareW(ModPathTail, L"mscorsvr.dll")) {
            IsCor = TRUE;
            Process->CorDllType = L"svr";
        }

        if (IsCor) {
            Process->CorDllBase = ModuleBase;
            GenStrCopyNW(Process->CorDllPath, UnicodePath,
                         ARRAY_COUNT(Process->CorDllPath));
        }
        
        ULONG WriteFlags;

        if (!GenExecuteIncludeModuleCallback(Dump,
                                             ModuleBase,
                                             &WriteFlags) ||
            IsFlagClear(WriteFlags, ModuleWriteModule)) {

            // If this is the COR DLL module we need to get
            // its version information for later use.  The
            // callback has dropped it from the enumeration
            // so do it right now before the module is forgotten.
            if (IsCor &&
                (Status = Dump->SysProv->
                 GetImageVersionInfo(Dump->ProcessHandle,
                                     UnicodePath,
                                     ModuleBase,
                                     &Process->CorDllVer)) != S_OK) {
                // If we can't get the version just forget
                // that this process has the COR loaded.
                // The dump will probably be useless but
                // there's a tiny chance it won't.
                Process->CorDllType = NULL;
            }

            continue;
        }
        
        if ((Status =
             GenAllocateModuleObject(Dump,
                                     Process,
                                     UnicodePath,
                                     ModuleBase,
                                     WriteFlags,
                                     &Module)) != S_OK) {
            goto Exit;
        }

        if (IsCor) {
            Process->CorDllVer = Module->VersionInfo;
        }
        
        Process->NumberOfModules++;
        InsertTailList (&Process->ModuleList, &Module->ModulesLink);
    }

    //
    // Walk function table list.  The function table list
    // is important but not absolutely critical so failures
    // here are not fatal.
    //

    for (;;) {

        PINTERNAL_FUNCTION_TABLE Table;
        ULONG64 MinAddr, MaxAddr, BaseAddr;
        ULONG EntryCount;
        ULONG64 RawTable[(MAX_DYNAMIC_FUNCTION_TABLE + sizeof(ULONG64) - 1) /
                         sizeof(ULONG64)];
        PVOID RawEntryHandle;

        Status = Dump->SysProv->
            EnumFunctionTables(&MinAddr,
                               &MaxAddr,
                               &BaseAddr,
                               &EntryCount,
                               RawTable,
                               Dump->FuncTableSize,
                               &RawEntryHandle);
        if (Status != S_OK) {
            break;
        }
                               
        if (GenAllocateFunctionTableObject(Dump,
                                           MinAddr,
                                           MaxAddr,
                                           BaseAddr,
                                           EntryCount,
                                           RawTable,
                                           &Table) == S_OK) {

            if (Dump->SysProv->
                EnumFunctionTableEntries(RawTable,
                                         Dump->FuncTableSize,
                                         RawEntryHandle,
                                         Table->RawEntries,
                                         EntryCount *
                                         Dump->FuncTableEntrySize) != S_OK) {
                GenFreeFunctionTableObject(Dump, Table);
            } else {
                GenIncludeUnwindInfoMemory(Dump, Process, Table);
                Process->NumberOfFunctionTables++;
                InsertTailList(&Process->FunctionTableList,
                               &Table->TableLink);
            }
        }
        
    }
    
    //
    // Walk unloaded module list.  The unloaded module
    // list is not critical information so failures here
    // are not fatal.
    //
    
    if (Dump->DumpType & MiniDumpWithUnloadedModules) {

        PINTERNAL_UNLOADED_MODULE UnlModule;
        ULONG64 ModuleBase;
        ULONG Size;
        ULONG CheckSum;
        ULONG TimeDateStamp;

        while (Dump->SysProv->
               EnumUnloadedModules(UnicodePath,
                                   ARRAY_COUNT(UnicodePath),
                                   &ModuleBase,
                                   &Size,
                                   &CheckSum,
                                   &TimeDateStamp) == S_OK) {
            if (GenAllocateUnloadedModuleObject(Dump,
                                                UnicodePath,
                                                ModuleBase,
                                                Size,
                                                CheckSum,
                                                TimeDateStamp,
                                                &UnlModule) == S_OK) {
                Process->NumberOfUnloadedModules++;
                InsertHeadList(&Process->UnloadedModuleList,
                               &UnlModule->ModulesLink);
            } else {
                break;
            }
        }
        
    }

    Status = S_OK;

Exit:

    if (EnumStarted) {
        Dump->SysProv->FinishProcessEnum();
    }

    if (Status == S_OK) {
        // We don't consider a failure here to be a critical
        // failure.  The dump won't contain all of the
        // requested information but it'll still have
        // the basic thread information, which could be
        // valuable on its own.
        GenScanAddressSpace(Dump, Process);
        GenGetCorMemory(Dump, Process);
    } else {
        GenFreeProcessObject(Dump, Process);
        Process = NULL;
    }

    *ProcessRet = Process;
    return Status;
}

HRESULT
GenWriteHandleData(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo
    )
{
    HRESULT Status;
    ULONG HandleCount;
    ULONG Hits;
    WCHAR TypeName[64];
    WCHAR ObjectName[MAX_PATH];
    PMINIDUMP_HANDLE_DESCRIPTOR Descs, Desc;
    ULONG32 Len;
    MINIDUMP_HANDLE_DATA_STREAM DataStream;
    RVA Rva = StreamInfo->RvaOfHandleData;

    if ((Status = Dump->SysProv->
         StartHandleEnum(Dump->ProcessHandle,
                         Dump->ProcessId,
                         &HandleCount)) != S_OK) {
        return Status;
    }

    if (!HandleCount) {
        Dump->SysProv->FinishHandleEnum();
        return S_OK;
    }
    
    Descs = (PMINIDUMP_HANDLE_DESCRIPTOR)
        AllocMemory(Dump, HandleCount * sizeof(*Desc));
    if (Descs == NULL) {
        Dump->SysProv->FinishHandleEnum();
        return E_OUTOFMEMORY;
    }
    
    Hits = 0;
    Desc = Descs;
    
    while (Hits < HandleCount &&
           Dump->SysProv->
           EnumHandles(&Desc->Handle,
                       (PULONG)&Desc->Attributes,
                       (PULONG)&Desc->GrantedAccess,
                       (PULONG)&Desc->HandleCount,
                       (PULONG)&Desc->PointerCount,
                       TypeName,
                       ARRAY_COUNT(TypeName),
                       ObjectName,
                       ARRAY_COUNT(ObjectName)) == S_OK) {

        // Successfully got a handle, so consider this a hit.
        Hits++;

        Desc->TypeNameRva = Rva;
        Len = GenStrLengthW(TypeName) * sizeof(WCHAR);
        
        if ((Status = Dump->OutProv->
             WriteAll(&Len, sizeof(Len))) != S_OK) {
            goto Exit;
        }
            
        Len += sizeof(WCHAR);
        if ((Status = Dump->OutProv->
             WriteAll(TypeName, Len)) != S_OK) {
            goto Exit;
        }
            
        Rva += Len + sizeof(Len);

        if (ObjectName[0]) {

            Desc->ObjectNameRva = Rva;
            Len = GenStrLengthW(ObjectName) * sizeof(WCHAR);
        
            if ((Status = Dump->OutProv->
                 WriteAll(&Len, sizeof(Len))) != S_OK) {
                goto Exit;
            }

            Len += sizeof(WCHAR);
            if ((Status = Dump->OutProv->
                 WriteAll(ObjectName, Len)) != S_OK) {
                goto Exit;
            }

            Rva += Len + sizeof(Len);
            
        } else {
            Desc->ObjectNameRva = 0;
        }

        Desc++;
    }

    DataStream.SizeOfHeader = sizeof(DataStream);
    DataStream.SizeOfDescriptor = sizeof(*Descs);
    DataStream.NumberOfDescriptors = (ULONG)(Desc - Descs);
    DataStream.Reserved = 0;

    StreamInfo->RvaOfHandleData = Rva;
    StreamInfo->SizeOfHandleData = sizeof(DataStream) +
        DataStream.NumberOfDescriptors * sizeof(*Descs);
    
    if ((Status = Dump->OutProv->
         WriteAll(&DataStream, sizeof(DataStream))) == S_OK) {
        Status = Dump->OutProv->
            WriteAll(Descs, DataStream.NumberOfDescriptors * sizeof(*Descs));
    }

 Exit:
    FreeMemory(Dump, Descs);
    Dump->SysProv->FinishHandleEnum();
    return Status;
}

ULONG
GenProcArchToImageMachine(ULONG ProcArch)
{
    switch(ProcArch) {
    case PROCESSOR_ARCHITECTURE_INTEL:
        return IMAGE_FILE_MACHINE_I386;
    case PROCESSOR_ARCHITECTURE_IA64:
        return IMAGE_FILE_MACHINE_IA64;
    case PROCESSOR_ARCHITECTURE_AMD64:
        return IMAGE_FILE_MACHINE_AMD64;
    case PROCESSOR_ARCHITECTURE_ARM:
        return IMAGE_FILE_MACHINE_ARM;
    case PROCESSOR_ARCHITECTURE_ALPHA:
        return IMAGE_FILE_MACHINE_ALPHA;
    case PROCESSOR_ARCHITECTURE_ALPHA64:
        return IMAGE_FILE_MACHINE_AXP64;
    default:
        return IMAGE_FILE_MACHINE_UNKNOWN;
    }
}

LPWSTR
GenStrCopyNW(
    OUT LPWSTR lpString1,
    IN LPCWSTR lpString2,
    IN int iMaxLength
    )
{
    wchar_t * cp = lpString1;

    if (iMaxLength > 0)
    {
        while( iMaxLength > 1 && (*cp++ = *lpString2++) )
            iMaxLength--;       /* Copy src over dst */
        if (cp > lpString1 && cp[-1]) {
            *cp = 0;
        }
    }

    return( lpString1 );
}

size_t
GenStrLengthW(
    const wchar_t * wcs
    )
{
    const wchar_t *eos = wcs;

    while( *eos++ )
        ;

    return( (size_t)(eos - wcs - 1) );
}

int
GenStrCompareW(
    IN LPCWSTR String1,
    IN LPCWSTR String2
    )
{
    while (*String1) {
        if (*String1 < *String2) {
            return -1;
        } else if (*String1 > *String2) {
            return 1;
        }

        String1++;
        String2++;
    }

    return *String2 ? 1 : 0;
}

C_ASSERT(sizeof(EXCEPTION_RECORD64) == sizeof(MINIDUMP_EXCEPTION));

void
GenExRecord32ToMd(PEXCEPTION_RECORD32 Rec32,
                  PMINIDUMP_EXCEPTION RecMd)
{
    ULONG i;

    RecMd->ExceptionCode    = Rec32->ExceptionCode;
    RecMd->ExceptionFlags   = Rec32->ExceptionFlags;
    RecMd->ExceptionRecord  = (LONG)Rec32->ExceptionRecord;
    RecMd->ExceptionAddress = (LONG)Rec32->ExceptionAddress;
    RecMd->NumberParameters = Rec32->NumberParameters;
    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++)
    {
        RecMd->ExceptionInformation[i] =
            (LONG)Rec32->ExceptionInformation[i];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\imagedir.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    imagedir.c

Abstract:

    For backwards compatability on Win9x platforms, the imagehlp ImageNtHeader
    etc. functions have been physically compiled into minidump.dll.

Author:

    Matthew D Hendel (math) 28-April-1999

Revision History:

--*/

#include "pch.cpp"

void
GenImageNtHdr32To64(PIMAGE_NT_HEADERS32 Hdr32,
                    PIMAGE_NT_HEADERS64 Hdr64)
{
#define CP(x) Hdr64->x = Hdr32->x
#define SE64(x) Hdr64->x = (ULONG64) (LONG64) (LONG) Hdr32->x
    ULONG i;

    CP(Signature);
    CP(FileHeader);
    CP(OptionalHeader.Magic);
    CP(OptionalHeader.MajorLinkerVersion);
    CP(OptionalHeader.MinorLinkerVersion);
    CP(OptionalHeader.SizeOfCode);
    CP(OptionalHeader.SizeOfInitializedData);
    CP(OptionalHeader.SizeOfUninitializedData);
    CP(OptionalHeader.AddressOfEntryPoint);
    CP(OptionalHeader.BaseOfCode);
    SE64(OptionalHeader.ImageBase);
    CP(OptionalHeader.SectionAlignment);
    CP(OptionalHeader.FileAlignment);
    CP(OptionalHeader.MajorOperatingSystemVersion);
    CP(OptionalHeader.MinorOperatingSystemVersion);
    CP(OptionalHeader.MajorImageVersion);
    CP(OptionalHeader.MinorImageVersion);
    CP(OptionalHeader.MajorSubsystemVersion);
    CP(OptionalHeader.MinorSubsystemVersion);
    CP(OptionalHeader.Win32VersionValue);
    CP(OptionalHeader.SizeOfImage);
    CP(OptionalHeader.SizeOfHeaders);
    CP(OptionalHeader.CheckSum);
    CP(OptionalHeader.Subsystem);
    CP(OptionalHeader.DllCharacteristics);
    // Sizes are not sign extended, just copied.
    CP(OptionalHeader.SizeOfStackReserve);
    CP(OptionalHeader.SizeOfStackCommit);
    CP(OptionalHeader.SizeOfHeapReserve);
    CP(OptionalHeader.SizeOfHeapCommit);
    CP(OptionalHeader.LoaderFlags);
    CP(OptionalHeader.NumberOfRvaAndSizes);
    for (i = 0; i < ARRAY_COUNT(Hdr32->OptionalHeader.DataDirectory); i++)
    {
        CP(OptionalHeader.DataDirectory[i]);
    }
#undef CP
#undef SE64
}

PIMAGE_NT_HEADERS
GenImageNtHeader(
    IN PVOID Base,
    OUT OPTIONAL PIMAGE_NT_HEADERS64 Generic
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Return Value:

    Returns the address of the NT Header.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders = NULL;

    if (Base != NULL && Base != (PVOID)-1) {
        __try {
            if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
                NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);

                if (NtHeaders->Signature != IMAGE_NT_SIGNATURE ||
                    (NtHeaders->OptionalHeader.Magic !=
                     IMAGE_NT_OPTIONAL_HDR32_MAGIC &&
                     NtHeaders->OptionalHeader.Magic !=
                     IMAGE_NT_OPTIONAL_HDR64_MAGIC)) {
                    NtHeaders = NULL;
                } else if (Generic) {
                    if (NtHeaders->OptionalHeader.Magic ==
                        IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                        GenImageNtHdr32To64((PIMAGE_NT_HEADERS32)NtHeaders,
                                            Generic);
                    } else {
                        memcpy(Generic, NtHeaders, sizeof(*Generic));
                    }
                }
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            NtHeaders = NULL;
        }
    }

    return NtHeaders;
}


PIMAGE_SECTION_HEADER
GenSectionTableFromVirtualAddress (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns a pointer to the
    section table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the pointer of the section entry containing the data.

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if ((ULONG)Address >= NtSection->VirtualAddress &&
            (ULONG)Address < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}


PVOID
GenAddressInSectionTable (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns the seek address
    of the data the Directory describes.

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = GenSectionTableFromVirtualAddress( NtHeaders,
                                                   Base,
                                                   Address
                                                 );
    if (NtSection != NULL) {
        return( ((PCHAR)Base + ((ULONG_PTR)Address - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
    else {
        return( NULL );
        }
}


PVOID
GenImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    PIMAGE_NT_HEADERS32 NtHeaders
    )
{
    ULONG DirectoryAddress;

    if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {
        return( NULL );
    }

    if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        return( NULL );
    }

    *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {
        return( (PVOID)((PCHAR)Base + DirectoryAddress) );
    }

    return( GenAddressInSectionTable((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));
}


PVOID
GenImageDirectoryEntryToData64 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    PIMAGE_NT_HEADERS64 NtHeaders
    )
{
    ULONG DirectoryAddress;

    if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {
        return( NULL );
    }

    if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        return( NULL );
    }

    *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {
        return( (PVOID)((PCHAR)Base + DirectoryAddress) );
    }

    return( GenAddressInSectionTable((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));
}


PVOID
GenImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    if ((ULONG_PTR)Base & 0x00000001) {
        Base = (PVOID)((ULONG_PTR)Base & ~0x00000001);
        MappedAsImage = FALSE;
        }

    NtHeaders = GenImageNtHeader(Base, NULL);

    if (!NtHeaders)
        return NULL;

    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return (GenImageDirectoryEntryToData32(Base,
                                               MappedAsImage,
                                               DirectoryEntry,
                                               Size,
                                               (PIMAGE_NT_HEADERS32)NtHeaders));
    } else if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return (GenImageDirectoryEntryToData64(Base,
                                               MappedAsImage,
                                               DirectoryEntry,
                                               Size,
                                               (PIMAGE_NT_HEADERS64)NtHeaders));
    } else {
        return (NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\removesym\removesym.c ===
#include <private.h>

WCHAR **SymbolNames;

typedef BOOL ( __cdecl *PPDBOPEN2W )(
    const wchar_t *,
    LNGNM_CONST char *,
    EC *,
    wchar_t *,
    size_t,
    PDB **
    );

typedef BOOL ( __cdecl *PPDBCLOSE ) (
    PDB* ppdb
    );

typedef BOOL (__cdecl *PPDBCOPYTOW2) (
    PDB *ppdb,
    const wchar_t *szTargetPdb,
    DWORD dwCopyFilter,
    PfnPDBCopyQueryCallback pfnCallBack,
    void * pvClientContext
    );

PPDBOPEN2W pPDBOpen2W;
PPDBCLOSE  pPDBClose;
PPDBCOPYTOW2 pPDBCopyToW2;
wchar_t NewPdbName[_MAX_FNAME];

CHAR SymbolName[2048];
WCHAR SymbolNameW[2048];
PWCHAR *SymbolsToRemove;
ULONG SymbolCount;

int
__cdecl
MyWcsCmp(const void*Ptr1, const void *Ptr2)
{
    wchar_t*String1 = *(wchar_t**)Ptr1;
    wchar_t*String2 = *(wchar_t**)Ptr2;

//    printf("String1: %p - %ws\nString2: %p - %ws\n%d\n", String1, String1, String2, String2, wcscmp(String1, String2));
    return (wcscmp(String1, String2));
}

__cdecl
MyWcsCmp2(const void*Ptr1, const void *Ptr2)
{
    wchar_t*String1 = (wchar_t*)Ptr1;
    wchar_t*String2 = *(wchar_t**)Ptr2;

//    printf("String1: %p - %ws\nString2: %p - %ws\n%d\n", String1, String1, String2, String2, wcscmp(String1, String2));
    return (wcscmp(String1, String2));
}


BOOL
LoadNamesFromSymbolFile(
    WCHAR *SymbolFileName
    )
{
    FILE *SymbolFile;
    ULONG i;

    SymbolFile = _wfopen(SymbolFileName, L"rt");
    if (!SymbolFile)
        return FALSE;

    SymbolCount = 0;
    while (fgets(SymbolName,sizeof(SymbolName),SymbolFile)) {
        SymbolCount++;
    }

    if (fseek(SymbolFile, 0, SEEK_SET)) {
        fclose(SymbolFile);
        return FALSE;
    }

    SymbolsToRemove = (PWCHAR *) malloc(SymbolCount * sizeof(PWCHAR));

    if (!SymbolsToRemove) {
        fclose(SymbolFile);
        return FALSE;
    }

    SymbolCount = 0;

    while (fgets(SymbolName,sizeof(SymbolName),SymbolFile)) {
        // Remove trailing spaces
        if (strlen(SymbolName)) {
            PCHAR SymPtr = SymbolName + strlen(SymbolName) - 1;
            while ((*SymPtr == ' ') || (*SymPtr == '\r') || (*SymPtr == '\n')) {
                *SymPtr = '\0';
                SymPtr--;
            }
        }

        if (MultiByteToWideChar(CP_ACP,
                                MB_PRECOMPOSED,
                                SymbolName,
                                -1,
                                SymbolNameW,
                                sizeof(SymbolNameW)/sizeof(SymbolNameW[0])) == 0) {
            fclose(SymbolFile);
            return FALSE;
        }

        SymbolsToRemove[SymbolCount] = malloc((wcslen(SymbolNameW) + 1) * sizeof(WCHAR));
        if (!SymbolsToRemove[SymbolCount]) {
            fclose(SymbolFile);
            return FALSE;
        }

        wcscpy(SymbolsToRemove[SymbolCount], SymbolNameW);
        SymbolCount++;
    }

    fclose(SymbolFile);

    qsort(&SymbolsToRemove[0], SymbolCount, sizeof(PWCHAR), MyWcsCmp);

    return TRUE;
}


BOOL PDBCALL PdbCopyFilterPublics (
    void *          pvClientContext,
    DWORD           dwFilterFlags,
    unsigned int    offPublic,
    unsigned int    sectPublic,
    unsigned int    grfPublic,
    const wchar_t * szPublic,
    wchar_t **      pszNewPublic
    ) {

    static size_t   cPubs = 0;
    static wchar_t  wszNewName[2048];

    if (SymbolCount > 1) {
        if (bsearch(szPublic, &SymbolsToRemove[0], SymbolCount, sizeof(PWCHAR), MyWcsCmp2)) {
            return FALSE;
        }
    } else {
        if (!wcscmp(szPublic, *SymbolsToRemove)) {
            return FALSE;
        }
    }

    return TRUE;

//    if ((cPubs++ % 16) == 0) {
//        if ((cPubs % 32) == 1) {
//            wcscpy(wszNewName, szPublic);
//            wcscat(wszNewName, L"_BobsYerUncle");
//            *pszNewPublic = wszNewName;
//        }
//        return TRUE;
//    }
//    else {
//        return FALSE;
//    }
}

PDBCOPYCALLBACK PDBCALL PdbCopyQueryCallback(void * pv, PCC pccQuery) {
    switch (pccQuery) {
    case pccFilterPublics:
        return (PDBCOPYCALLBACK) PdbCopyFilterPublics;
        break;
    default:
        return NULL;
    }
}

void Usage(void)
{
    _putws(L"Usage: removesym -d:<pdbdll path> -p:<pdbname> {-s:<symbol to remove> | -f:<file with symbols to remove>}");
}

const WCHAR szMsPdb60[] = L"\\mspdb60.dll";
const WCHAR szMsPdb70[] = L"\\mspdb70.dll";

int __cdecl wmain(int argc, wchar_t *argv[])
{
    WCHAR *szPdbName = NULL;
    WCHAR *szNewPdbName = NULL;
    WCHAR *pSymbolName = NULL;
    WCHAR *pSymbolFileName = NULL;
    HINSTANCE hmodMsPdb;
    BOOL rc;
    LONG ErrorCode;
    WCHAR ErrorString[1024];
    PDB * pSrcPdb;
    int i;
    WCHAR PdbDllName[_MAX_PATH] = {0};
    WCHAR *pPdbDllPath = NULL;
    WCHAR const *pPdbDllName = szMsPdb60;

    // Grab the arguments

    if (argc < 4) {
        Usage();
        return 1;
    }

    i = 1;

    while (i < argc)
    {
        if (argv[i][0] == L'-' || argv[i][0] == L'/') {
            if (argv[i][1] == L'p' && argv[i][2] == ':') {
                // Pdb Name
                szPdbName = &argv[i][3];
            } else
            if (argv[i][1] == L's' && argv[i][2] == ':') {
                // Single Symbol name
                pSymbolName = &argv[i][3];
            } else
            if (argv[i][1] == L'f' && argv[i][2] == ':') {
                // File with symbol names
                pSymbolFileName = &argv[i][3];
            } else
            if (argv[i][1] == L'd' && argv[i][2] == ':') {
                // Single Symbol name
                pPdbDllPath = &argv[i][3];
            } else {
                Usage();
                return 1;
            }
        }
        i++;
    }

    if (!szPdbName) {
        _putws(L"Pdb name missing");
        Usage();
        return 1;
    }

    if (!pSymbolName && !pSymbolFileName) {
        _putws(L"Symbol name or file missing");
        Usage();
        return 1;
    }

    if (pSymbolName && pSymbolFileName) {
        _putws(L"Symbol name and symbol file specified - only one allowed");
        Usage();
        return 1;
    }

    if (!pPdbDllPath) {
        _putws(L"Pdb DllPath not specified");
        Usage();
        return 1;
    }

    // If there's a symfile, load it

    if (pSymbolFileName) {
        rc = LoadNamesFromSymbolFile(pSymbolFileName);
        if (!rc) {
            _putws(L"Unable do load names from symbol file");
            exit(1);
        }
    } else {
        SymbolsToRemove = &pSymbolName;
        SymbolCount = 1;
    }

Retry:
    rc = FALSE;
    // Load mspdb60.dll and the necessar api's

    wcscpy(PdbDllName, pPdbDllPath);
    wcscat(PdbDllName, pPdbDllName);

    hmodMsPdb = LoadLibraryW(PdbDllName);

    if (!hmodMsPdb) {
        wprintf(L"Unable to loadlib %s\n", PdbDllName);
        goto Exit;
    }

    pPDBOpen2W = (PPDBOPEN2W) GetProcAddress(hmodMsPdb, "PDBOpen2W");
    if (!pPDBOpen2W) {
        wprintf(L"Unable to find PDBOpen2W in %s\n", PdbDllName);
        goto Exit;
    }
    pPDBClose = (PPDBCLOSE) GetProcAddress(hmodMsPdb, "PDBClose");
    if (!pPDBClose) {
        wprintf(L"Unable to find PDBClose in %s\n", PdbDllName);
        goto Exit;
    }
    pPDBCopyToW2 = (PPDBCOPYTOW2) GetProcAddress(hmodMsPdb, "PDBCopyToW2");
    if (!pPDBCopyToW2) {
        wprintf(L"Unable to find PDBCopyToW2 in %s\n", PdbDllName);
        goto Exit;
    }

    __try {
        rc = pPDBOpen2W(szPdbName, "r", &ErrorCode, ErrorString, sizeof(ErrorString) / sizeof(ErrorString[0]), &pSrcPdb);
        if (!rc) {
            wprintf(L"Unable to open pdb for changes with %s\n", PdbDllName);
            __leave;
        }

        szNewPdbName = _wtmpnam(NewPdbName);

        rc = pPDBCopyToW2(pSrcPdb, szNewPdbName, 1, PdbCopyQueryCallback, NULL);

        pPDBClose(pSrcPdb);

        if (!rc) {
            _putws(L"CopyTo operation failed");
            __leave;
        }

        rc = CopyFile(szNewPdbName, szPdbName, FALSE);
        if (!rc) {
            _putws(L"Unable to overwrite old pdb with new pdb");
        }

        DeleteFile(szNewPdbName);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          _putws(L"Exception occured in pdb api's");
          rc = FALSE;
    }

Exit:
    if (hmodMsPdb) {
        FreeLibrary(hmodMsPdb);
        hmodMsPdb = NULL;
    }

    if (!rc) {
        if (pPdbDllName == szMsPdb60) {
            pPdbDllName = szMsPdb70;
            goto Retry;
        }
    }
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\minidump.h ===
/*++ 

Copyright (c) 1990-2002  Microsoft Corporation

Module Name:

    minidump.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

    Contains debugging support routines that are redistributable.

Revision History:

--*/

#if _MSC_VER > 1020
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


#include <pshpack4.h>

#pragma warning(disable:4200) // Zero length array


#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef unsigned char UINT8;
typedef unsigned short UINT16;
typedef DWORD RVA;
typedef ULONG64 RVA64;

C_ASSERT (sizeof (UINT8) == 1);
C_ASSERT (sizeof (UINT16) == 2);

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR {
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64 {
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64 {
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER {
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to 
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY {
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING {
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE {

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,
    UnloadedModuleListStream    = 14,
    MiscInfoStream              = 15,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
// 
    
//
// CPU information is obtained from one of two places.
//
//  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
//     instruction. You must use the X86 portion of the union for X86
//     computers.
//
//  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
//     IsProcessorFeatureSupported().
//

typedef union _CPU_INFORMATION {

    //
    // X86 platforms use CPUID function to obtain processor information.
    //
    
    struct {

        //
        // CPUID Subfunction 0, register EAX (VendorId [0]),
        // EBX (VendorId [1]) and ECX (VendorId [2]).
        //
        
        ULONG32 VendorId [ 3 ];
        
        //
        // CPUID Subfunction 1, register EAX
        //
        
        ULONG32 VersionInformation;

        //
        // CPUID Subfunction 1, register EDX
        //
        
        ULONG32 FeatureInformation;
        

        //
        // CPUID, Subfunction 80000001, register EBX. This will only
        // be obtained if the vendor id is "AuthenticAMD".
        //
        
        ULONG32 AMDExtendedCpuFeatures;

    } X86CpuInfo;

    //
    // Non-x86 platforms use processor feature flags.
    //
    
    struct {

        ULONG64 ProcessorFeatures [ 2 ];
        
    } OtherCpuInfo;

} CPU_INFORMATION, *PCPU_INFORMATION;
        
typedef struct _MINIDUMP_SYSTEM_INFO {

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //
    
    UINT16 ProcessorArchitecture;
    UINT16 ProcessorLevel;
    UINT16 ProcessorRevision;

    union {
        UINT16 Reserved0;
        struct {
            UINT8 NumberOfProcessors;
            UINT8 ProductType;
        };
    };

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //
    
    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //
    
    RVA CSDVersionRva;

    union {
        ULONG32 Reserved1;
        struct {
            UINT16 SuiteMask;
            UINT16 Reserved2;
        };
    };

    CPU_INFORMATION Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this 
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT (sizeof ( ((LPPROCESS_INFORMATION)0)->dwThreadId ) == 4);

typedef struct _MINIDUMP_THREAD {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION  {
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM {
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;   


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST {
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST {
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST {
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;

typedef struct _MINIDUMP_EXCEPTION_INFORMATION64 {
    DWORD ThreadId;
    ULONG64 ExceptionRecord;
    ULONG64 ContextRecord;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION64, *PMINIDUMP_EXCEPTION_INFORMATION64;


//
// Support for capturing system handle state at the time of the dump.
//

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR {
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR {
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// The MINIDUMP_UNLOADED_MODULE contains information about a
// a specific module that was previously loaded but no
// longer is.  This can help with diagnosing problems where
// callers attempt to call code that is no longer loaded.
//

typedef struct _MINIDUMP_UNLOADED_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
} MINIDUMP_UNLOADED_MODULE, *PMINIDUMP_UNLOADED_MODULE;


//
// The minidump unloaded module list is a container for unloaded modules.
//

typedef struct _MINIDUMP_UNLOADED_MODULE_LIST {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
} MINIDUMP_UNLOADED_MODULE_LIST, *PMINIDUMP_UNLOADED_MODULE_LIST;


//
// The miscellaneous information stream contains a variety
// of small pieces of information.  A member is valid if
// it's within the available size and its corresponding
// bit is set.
//

#define MINIDUMP_MISC1_PROCESS_ID    0x00000001
#define MINIDUMP_MISC1_PROCESS_TIMES 0x00000002

typedef struct _MINIDUMP_MISC_INFO {
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
} MINIDUMP_MISC_INFO, *PMINIDUMP_MISC_INFO;


//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD {
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM {
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION {
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE {
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK {
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS {
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010,
    ThreadWriteThreadData        = 0x0020,
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK {
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord; 
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK {
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS {
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_CALLBACK_INPUT {
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union {
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT {
    union {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;

        
//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//
// On some operating systems a list of modules that were
// recently unloaded is kept in addition to the currently
// loaded module list.  This information can be saved in
// the dump if desired.
//
// Stack and backing store memory can be scanned for referenced
// pages in order to pick up data referenced by locals or other
// stack memory.  This can increase the size of a dump significantly.
//
// Module paths may contain undesired information such as user names
// or other important directory names so they can be stripped.  This
// option reduces the ability to locate the proper image later
// and should only be used in certain situations.
//
// Complete operating system per-process and per-thread information can
// be gathered and stored in the dump.
//
// The virtual address space can be scanned for various types
// of memory to be included in the dump.
//
// Code which is concerned with potentially private information
// getting into the minidump can set a flag that automatically
// modifies all existing and future flags to avoid placing
// unnecessary data in the dump.  Basic data, such as stack
// information, will still be included but optional data, such
// as indirect memory, will not.
//

typedef enum _MINIDUMP_TYPE {
    MiniDumpNormal                         = 0x0000,
    MiniDumpWithDataSegs                   = 0x0001,
    MiniDumpWithFullMemory                 = 0x0002,
    MiniDumpWithHandleData                 = 0x0004,
    MiniDumpFilterMemory                   = 0x0008,
    MiniDumpScanMemory                     = 0x0010,
    MiniDumpWithUnloadedModules            = 0x0020,
    MiniDumpWithIndirectlyReferencedMemory = 0x0040,
    MiniDumpFilterModulePaths              = 0x0080,
    MiniDumpWithProcessThreadData          = 0x0100,
    MiniDumpWithPrivateReadWriteMemory     = 0x0200,
    MiniDumpWithoutOptionalData            = 0x0400,
} MINIDUMP_TYPE;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI * MINIDUMP_CALLBACK_ROUTINE) (
    IN PVOID CallbackParam,
    IN CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
    IN OUT PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    );

typedef struct _MINIDUMP_CALLBACK_INFORMATION {
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );

BOOL
WINAPI
MiniDumpReadDumpStream(
    IN PVOID BaseOfDump,
    IN ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * StreamPointer, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    );

#include <poppack.h>

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\minidump.cpp ===
/*++

Copyright(c) 1999-2002 Microsoft Corporation

Module Name:

    minidump.c

Abstract:

    Minidump user-mode crashdump support.

Author:

    Matthew D Hendel (math) 20-Aug-1999

--*/


#include "pch.cpp"

#include <limits.h>
#include <dbgver.h>

PINTERNAL_MODULE
ModuleContainingAddress(
    IN PINTERNAL_PROCESS Process,
    IN ULONG64 Address
    )
{
    PINTERNAL_MODULE Module;
    PLIST_ENTRY ModuleEntry;

    ModuleEntry = Process->ModuleList.Flink;
    while ( ModuleEntry != &Process->ModuleList ) {

        Module = CONTAINING_RECORD (ModuleEntry, INTERNAL_MODULE,
                                    ModulesLink);
        ModuleEntry = ModuleEntry->Flink;

        if (Address >= Module->BaseOfImage &&
            Address < Module->BaseOfImage + Module->SizeOfImage) {
            return Module;
        }
    }

    return NULL;
}

VOID
ScanMemoryForModuleRefs(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN BOOL DoRead,
    IN ULONG64 Base,
    IN ULONG Size,
    IN PVOID MemBuffer,
    IN MEMBLOCK_TYPE TypeOfMemory,
    IN BOOL FilterContent
    )
{
    PVOID CurMem;
    ULONG64 CurPtr;
    ULONG Done;

    // We only want to scan certain kinds of memory.
    if (TypeOfMemory != MEMBLOCK_STACK &&
        TypeOfMemory != MEMBLOCK_STORE &&
        TypeOfMemory != MEMBLOCK_DATA_SEG &&
        TypeOfMemory != MEMBLOCK_INDIRECT)
    {
        return;
    }
    
    // If the base address is not pointer-size aligned
    // we can't easily assume that this is a meaningful
    // area of memory to scan for references.  Normal
    // stack and store addresses will always be pointer
    // size aligned so this should only reject invalid
    // addresses.
    if (!Base || !Size || (Base & (Dump->PtrSize - 1))) {
        return;
    }

    if (DoRead) {
        if (Dump->SysProv->
            ReadVirtual(Dump->ProcessHandle,
                        Base, MemBuffer, Size, &Done) != S_OK) {
            return;
        }
    } else {
        Done = Size;
    }

    CurMem = MemBuffer;
    Done /= Dump->PtrSize;
    while (Done-- > 0) {
        
        PINTERNAL_MODULE Module;
        BOOL InAny;

        CurPtr = GenGetPointer(Dump, CurMem);
        
        // An IA64 backing store can contain PFS values
        // that must be preserved in order to allow stack walking.
        // The high two bits of PFS are the privilege level, which
        // should always be 0y11 for user-mode code so we use this
        // as a marker to look for PFS entries.
        // There is also a NAT collection flush at every 0x1F8
        // offset.  These values cannot be filtered.
        if (Dump->CpuType == IMAGE_FILE_MACHINE_IA64 &&
            TypeOfMemory == MEMBLOCK_STORE) {
            if ((Base & 0x1f8) == 0x1f8 ||
                (CurPtr & 0xc000000000000000UI64) == 0xc000000000000000UI64) {
                goto Next;
            }
        }
        
        InAny = FALSE;

        if (Module = ModuleContainingAddress(Process, CurPtr)) {
            Module->WriteFlags |= ModuleReferencedByMemory;
            InAny = TRUE;
        }

        // If the current pointer is not a module reference
        // or an internal reference for a thread stack or store,
        // filter it.
        if (FilterContent && !InAny) {

            PINTERNAL_THREAD Thread;
            PLIST_ENTRY ThreadEntry;

            ThreadEntry = Process->ThreadList.Flink;
            while ( ThreadEntry != &Process->ThreadList ) {

                Thread = CONTAINING_RECORD (ThreadEntry, INTERNAL_THREAD,
                                            ThreadsLink);
                ThreadEntry = ThreadEntry->Flink;

                if ((CurPtr >= Thread->StackEnd &&
                     CurPtr < Thread->StackBase) ||
                    (CurPtr >= Thread->BackingStoreBase &&
                     CurPtr < Thread->BackingStoreBase +
                     Thread->BackingStoreSize)) {
                    InAny = TRUE;
                    break;
                }
            }

            if (!InAny) {
                GenSetPointer(Dump, CurMem, 0);
            }
        }

    Next:
        CurMem = (PUCHAR)CurMem + Dump->PtrSize;
        Base += Dump->PtrSize;
    }
}

HRESULT
WriteAtOffset(
    IN PMINIDUMP_STATE Dump,
    ULONG Offset,
    PVOID Buffer,
    ULONG BufferSize
    )
{
    HRESULT Status;

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, Offset, NULL)) == S_OK) {
        Status = Dump->OutProv->
            WriteAll(Buffer, BufferSize);
    }

    return Status;
}

HRESULT
WriteOther(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PVOID Buffer,
    IN ULONG SizeOfBuffer,
    OUT ULONG * BufferRva
    )
{
    HRESULT Status;
    ULONG Rva;

    ASSERT (Buffer != NULL);
    ASSERT (SizeOfBuffer != 0);

    //
    // If it's larger than we've allocated space for, fail.
    //

    Rva = StreamInfo->RvaForCurOther;

    if (Rva + SizeOfBuffer >
        StreamInfo->RvaOfOther + StreamInfo->SizeOfOther) {

        return E_INVALIDARG;
    }

    //
    // Set location to point at which we want to write and write.
    //

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, Rva, NULL)) == S_OK) {
        if ((Status = Dump->OutProv->
             WriteAll(Buffer, SizeOfBuffer)) == S_OK) {
            if (BufferRva) {
                *BufferRva = Rva;
            }
            StreamInfo->RvaForCurOther += SizeOfBuffer;
        }
    }

    return Status;
}

HRESULT
WriteMemory(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PVOID Buffer,
    IN ULONG64 StartOfRegion,
    IN ULONG SizeOfRegion,
    OUT ULONG * MemoryDataRva OPTIONAL
    )
{
    HRESULT Status;
    ULONG DataRva;
    ULONG ListRva;
    ULONG SizeOfMemoryDescriptor;
    MINIDUMP_MEMORY_DESCRIPTOR Descriptor;

    ASSERT ( StreamInfo != NULL );
    ASSERT ( Buffer != NULL );
    ASSERT ( StartOfRegion != 0 );
    ASSERT ( SizeOfRegion != 0 );

    //
    // Writing a memory entry is a little different. When a memory entry
    // is written we need a descriptor in the memory list describing the
    // memory written AND a variable-sized entry in the MEMORY_DATA region
    // with the actual data.
    //


    ListRva = StreamInfo->RvaForCurMemoryDescriptor;
    DataRva = StreamInfo->RvaForCurMemoryData;
    SizeOfMemoryDescriptor = sizeof (MINIDUMP_MEMORY_DESCRIPTOR);

    //
    // If we overflowed either the memory list or the memory data
    // regions, fail.
    //

    if ( ( ListRva + SizeOfMemoryDescriptor >
           StreamInfo->RvaOfMemoryDescriptors + StreamInfo->SizeOfMemoryDescriptors) ||
         ( DataRva + SizeOfRegion >
           StreamInfo->RvaOfMemoryData + StreamInfo->SizeOfMemoryData ) ) {

        return E_INVALIDARG;
    }

    //
    // First, write the data to the MEMORY_DATA region.
    //

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, DataRva, NULL)) != S_OK ||
        (Status = Dump->OutProv->
         WriteAll(Buffer, SizeOfRegion)) != S_OK) {
        return Status;
    }

    //
    // Then update the memory descriptor in the MEMORY_LIST region.
    //

    Descriptor.StartOfMemoryRange = StartOfRegion;
    Descriptor.Memory.DataSize = SizeOfRegion;
    Descriptor.Memory.Rva = DataRva;

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, ListRva, NULL)) != S_OK ||
        (Status = Dump->OutProv->
         WriteAll(&Descriptor, SizeOfMemoryDescriptor)) != S_OK) {
        return Status;
    }

    //
    // Update both the List Rva and the Data Rva and return the
    // the Data Rva.
    //

    StreamInfo->RvaForCurMemoryDescriptor += SizeOfMemoryDescriptor;
    StreamInfo->RvaForCurMemoryData += SizeOfRegion;

    if ( MemoryDataRva ) {
        *MemoryDataRva = DataRva;
    }

    return S_OK;
}

HRESULT
WriteMemoryFromProcess(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process,
    IN ULONG64 BaseOfRegion,
    IN ULONG SizeOfRegion,
    IN BOOL FilterContent,
    IN MEMBLOCK_TYPE TypeOfMemory,
    OUT ULONG * MemoryDataRva OPTIONAL
    )
{
    HRESULT Status;
    PVOID Buffer;

    Buffer = AllocMemory ( Dump, SizeOfRegion );
    if (!Buffer) {
        return E_OUTOFMEMORY;
    }

    if ((Status = Dump->SysProv->
         ReadAllVirtual(Dump->ProcessHandle, BaseOfRegion, Buffer,
                        SizeOfRegion)) == S_OK) {

        if (FilterContent) {
            ScanMemoryForModuleRefs(Dump, Process, FALSE, BaseOfRegion,
                                    SizeOfRegion, Buffer, TypeOfMemory,
                                    TRUE);
        }
            
        Status = WriteMemory (Dump,
                              StreamInfo,
                              Buffer,
                              BaseOfRegion,
                              SizeOfRegion,
                              MemoryDataRva);
        
    }

    FreeMemory(Dump, Buffer);
    return Status;
}

HRESULT
WriteThread(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN LPVOID ThreadData,
    IN ULONG SizeOfThreadData,
    OUT ULONG * ThreadDataRva OPTIONAL
    )
{
    HRESULT Status;
    ULONG Rva;

    ASSERT (StreamInfo);
    ASSERT (ThreadData);


    Rva = StreamInfo->RvaForCurThread;

    if ( Rva + SizeOfThreadData >
         StreamInfo->RvaOfThreadList + StreamInfo->SizeOfThreadList ) {

         return E_INVALIDARG;
    }

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, Rva, NULL)) != S_OK ||
        (Status = Dump->OutProv->
         WriteAll(ThreadData, SizeOfThreadData)) != S_OK) {
        return Status;
    }

    if ( ThreadDataRva ) {
        *ThreadDataRva = Rva;
    }
    StreamInfo->RvaForCurThread += SizeOfThreadData;

    return S_OK;
}

HRESULT
WriteStringToPool(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PWSTR String,
    OUT ULONG * StringRva
    )
{
    HRESULT Status;
    ULONG32 StringLen;
    ULONG SizeOfString;
    ULONG Rva;

    ASSERT (String);
    ASSERT (sizeof (ULONG32) == sizeof (MINIDUMP_STRING));


    StringLen = GenStrLengthW(String) * sizeof (WCHAR);
    SizeOfString = sizeof (MINIDUMP_STRING) + StringLen + sizeof (WCHAR);
    Rva = StreamInfo->RvaForCurString;

    if ( Rva + SizeOfString >
         StreamInfo->RvaOfStringPool + StreamInfo->SizeOfStringPool ) {

        return E_INVALIDARG;
    }

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, Rva, NULL)) != S_OK ||
        (Status = Dump->OutProv->
         WriteAll(&StringLen, sizeof(StringLen))) != S_OK) {
        return Status;
    }

    //
    // Include the trailing '\000'.
    //

    StringLen += sizeof (WCHAR);
    if ((Status = Dump->OutProv->
         WriteAll(String, StringLen)) != S_OK) {
        return Status;
    }

    if ( StringRva ) {
        *StringRva = Rva;
    }

    StreamInfo->RvaForCurString += SizeOfString;

    return S_OK;
}

HRESULT
WriteModule (
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PMINIDUMP_MODULE Module,
    OUT ULONG * ModuleRva
    )
{
    HRESULT Status;
    ULONG Rva;
    ULONG SizeOfModule;

    ASSERT (StreamInfo);
    ASSERT (Module);


    SizeOfModule = sizeof (MINIDUMP_MODULE);
    Rva = StreamInfo->RvaForCurModule;

    if ( Rva + SizeOfModule >
         StreamInfo->RvaOfModuleList + StreamInfo->SizeOfModuleList ) {

        return E_INVALIDARG;
    }

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, Rva, NULL)) != S_OK ||
        (Status = Dump->OutProv->
         WriteAll(Module, SizeOfModule)) != S_OK) {
        return Status;
    }

    if ( ModuleRva ) {
        *ModuleRva = Rva;
    }

    StreamInfo->RvaForCurModule += SizeOfModule;

    return S_OK;
}

HRESULT
WriteUnloadedModule (
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PMINIDUMP_UNLOADED_MODULE Module,
    OUT ULONG * ModuleRva
    )
{
    HRESULT Status;
    ULONG Rva;
    ULONG SizeOfModule;

    ASSERT (StreamInfo);
    ASSERT (Module);


    SizeOfModule = sizeof (*Module);
    Rva = StreamInfo->RvaForCurUnloadedModule;

    if ( Rva + SizeOfModule >
         StreamInfo->RvaOfUnloadedModuleList +
         StreamInfo->SizeOfUnloadedModuleList ) {

        return E_INVALIDARG;
    }

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, Rva, NULL)) != S_OK ||
        (Status = Dump->OutProv->
         WriteAll(Module, SizeOfModule)) != S_OK) {
        return Status;
    }

    if ( ModuleRva ) {
        *ModuleRva = Rva;
    }

    StreamInfo->RvaForCurUnloadedModule += SizeOfModule;

    return S_OK;
}

HRESULT
WriteThreadList(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    HRESULT Status;
    ULONG StackMemoryRva;
    ULONG StoreMemoryRva;
    ULONG ContextRva;
    MINIDUMP_THREAD_EX DumpThread;
    PINTERNAL_THREAD Thread;
    ULONG NumberOfThreads;
    PLIST_ENTRY Entry;

    ASSERT (Process);
    ASSERT (StreamInfo);

    //
    // Write the thread count.
    //

    NumberOfThreads = Process->NumberOfThreadsToWrite;

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, StreamInfo->RvaOfThreadList, NULL)) != S_OK ||
        (Status = Dump->OutProv->
         WriteAll(&NumberOfThreads, sizeof(NumberOfThreads))) != S_OK) {
        return Status;
    }

    StreamInfo->RvaForCurThread += sizeof(NumberOfThreads);

    //
    // Iterate over the thread list writing the description,
    // context and memory for each thread.
    //

    Entry = Process->ThreadList.Flink;
    while ( Entry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (Entry,
                                    INTERNAL_THREAD,
                                    ThreadsLink);
        Entry = Entry->Flink;


        //
        // Only write the threads that have been flagged to be written.
        //

        if (IsFlagClear (Thread->WriteFlags, ThreadWriteThread)) {
            continue;
        }

        //
        // Write the context if it was flagged to be written.
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteContext)) {

            //
            // Write the thread context to the OTHER stream.
            //

            if ((Status = WriteOther (Dump,
                                      StreamInfo,
                                      Thread->ContextBuffer,
                                      Dump->ContextSize,
                                      &ContextRva)) != S_OK) {
                return Status;
            }

        } else {

            ContextRva = 0;
        }


        //
        // Write the stack if it was flagged to be written.
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteStack)) {

            //
            // Write the stack memory data; write it directly from the image.
            //

            if ((Status =
                 WriteMemoryFromProcess(Dump,
                                        StreamInfo,
                                        Process,
                                        Thread->StackEnd,
                                        (ULONG) (Thread->StackBase -
                                                 Thread->StackEnd),
                                        IsFlagSet(Dump->DumpType,
                                                  MiniDumpFilterMemory),
                                        MEMBLOCK_STACK,
                                        &StackMemoryRva)) != S_OK) {
                return Status;
            }

        } else {

            StackMemoryRva = 0;
        }


        //
        // Write the backing store if it was flagged to be written.
        // A newly created thread's backing store may be empty
        // so handle the case of zero size.
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteBackingStore) &&
            Thread->BackingStoreSize) {

            //
            // Write the store memory data; write it directly from the image.
            //

            if ((Status =
                 WriteMemoryFromProcess(Dump,
                                        StreamInfo,
                                        Process,
                                        Thread->BackingStoreBase,
                                        Thread->BackingStoreSize,
                                        IsFlagSet(Dump->DumpType,
                                                  MiniDumpFilterMemory),
                                        MEMBLOCK_STORE,
                                        &StoreMemoryRva
                                        )) != S_OK) {
                return Status;
            }

        } else {

            StoreMemoryRva = 0;
        }

        //
        // Build the dump thread.
        //

        DumpThread.ThreadId = Thread->ThreadId;
        DumpThread.SuspendCount = Thread->SuspendCount;
        DumpThread.PriorityClass = Thread->PriorityClass;
        DumpThread.Priority = Thread->Priority;
        DumpThread.Teb = Thread->Teb;

        //
        // Stack offset and size.
        //

        DumpThread.Stack.StartOfMemoryRange = Thread->StackEnd;
        DumpThread.Stack.Memory.DataSize =
                    (ULONG) ( Thread->StackBase - Thread->StackEnd );
        DumpThread.Stack.Memory.Rva = StackMemoryRva;

        //
        // Backing store offset and size.
        //

        DumpThread.BackingStore.StartOfMemoryRange = Thread->BackingStoreBase;
        DumpThread.BackingStore.Memory.DataSize = Thread->BackingStoreSize;
        DumpThread.BackingStore.Memory.Rva = StoreMemoryRva;

        //
        // Context offset and size.
        //

        DumpThread.ThreadContext.DataSize = Dump->ContextSize;
        DumpThread.ThreadContext.Rva = ContextRva;


        //
        // Write the dump thread to the threads region.
        //

        if ((Status = WriteThread (Dump,
                                   StreamInfo,
                                   &DumpThread,
                                   StreamInfo->ThreadStructSize,
                                   NULL)) != S_OK) {
            return Status;
        }
    }

    return S_OK;
}

HRESULT
WriteModuleList(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    HRESULT Status;
    MINIDUMP_MODULE DumpModule;
    ULONG StringRva;
    ULONG CvRecordRva;
    ULONG MiscRecordRva;
    PLIST_ENTRY Entry;
    PINTERNAL_MODULE Module;
    ULONG32 NumberOfModules;

    ASSERT (Process);
    ASSERT (StreamInfo);

    NumberOfModules = Process->NumberOfModulesToWrite;

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, StreamInfo->RvaForCurModule, NULL)) != S_OK ||
        (Status = Dump->OutProv->
         WriteAll(&NumberOfModules, sizeof(NumberOfModules))) != S_OK) {
        return Status;
    }

    StreamInfo->RvaForCurModule += sizeof (NumberOfModules);

    //
    // Iterate through the module list writing the module name, module entry
    // and module debug info to the dump file.
    //

    Entry = Process->ModuleList.Flink;
    while ( Entry != &Process->ModuleList ) {

        Module = CONTAINING_RECORD (Entry,
                                    INTERNAL_MODULE,
                                    ModulesLink);
        Entry = Entry->Flink;

        //
        // If we are not to write information for this module, just continue.
        //

        if (IsFlagClear (Module->WriteFlags, ModuleWriteModule)) {
            continue;
        }

        //
        // Write module name.
        //

        if ((Status = WriteStringToPool (Dump,
                                         StreamInfo,
                                         Module->SavePath,
                                         &StringRva)) != S_OK) {
            return Status;
        }

        //
        // Write CvRecord for a module into the OTHER region.
        //

        if ( IsFlagSet (Module->WriteFlags, ModuleWriteCvRecord) &&
             Module->CvRecord != NULL && Module->SizeOfCvRecord != 0 ) {

            if ((Status = WriteOther (Dump,
                                      StreamInfo,
                                      Module->CvRecord,
                                      Module->SizeOfCvRecord,
                                      &CvRecordRva)) != S_OK) {
                return Status;
            }

        } else {

            CvRecordRva = 0;
        }

        if ( IsFlagSet (Module->WriteFlags, ModuleWriteMiscRecord) &&
             Module->MiscRecord != NULL && Module->SizeOfMiscRecord != 0 ) {

            if ((Status = WriteOther (Dump,
                                      StreamInfo,
                                      Module->MiscRecord,
                                      Module->SizeOfMiscRecord,
                                      &MiscRecordRva)) != S_OK) {
                return Status;
            }

        } else {

            MiscRecordRva = 0;
        }

        DumpModule.BaseOfImage = Module->BaseOfImage;
        DumpModule.SizeOfImage = Module->SizeOfImage;
        DumpModule.CheckSum = Module->CheckSum;
        DumpModule.TimeDateStamp = Module->TimeDateStamp;
        DumpModule.VersionInfo = Module->VersionInfo;
        DumpModule.CvRecord.Rva = CvRecordRva;
        DumpModule.CvRecord.DataSize = Module->SizeOfCvRecord;
        DumpModule.MiscRecord.Rva = MiscRecordRva;
        DumpModule.MiscRecord.DataSize = Module->SizeOfMiscRecord;
        DumpModule.ModuleNameRva = StringRva;
        DumpModule.Reserved0 = 0;
        DumpModule.Reserved1 = 0;

        //
        // Write the module entry itself.
        //

        if ((Status = WriteModule (Dump,
                                   StreamInfo,
                                   &DumpModule,
                                   NULL)) != S_OK) {
            return Status;
        }
    }

    return S_OK;
}

HRESULT
WriteUnloadedModuleList(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    HRESULT Status;
    MINIDUMP_UNLOADED_MODULE_LIST DumpModuleList;
    MINIDUMP_UNLOADED_MODULE DumpModule;
    ULONG StringRva;
    PLIST_ENTRY Entry;
    PINTERNAL_UNLOADED_MODULE Module;
    ULONG32 NumberOfModules;


    ASSERT (Process);
    ASSERT (StreamInfo);

    if (IsListEmpty(&Process->UnloadedModuleList)) {
        // Nothing to write.
        return S_OK;
    }
    
    NumberOfModules = Process->NumberOfUnloadedModules;

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, StreamInfo->RvaForCurUnloadedModule,
              NULL)) != S_OK) {
        return Status;
    }

    DumpModuleList.SizeOfHeader = sizeof(DumpModuleList);
    DumpModuleList.SizeOfEntry = sizeof(DumpModule);
    DumpModuleList.NumberOfEntries = NumberOfModules;
    
    if ((Status = Dump->OutProv->
         WriteAll(&DumpModuleList, sizeof(DumpModuleList))) != S_OK) {
        return Status;
    }

    StreamInfo->RvaForCurUnloadedModule += sizeof (DumpModuleList);

    //
    // Iterate through the module list writing the module name, module entry
    // and module debug info to the dump file.
    //

    Entry = Process->UnloadedModuleList.Flink;
    while ( Entry != &Process->UnloadedModuleList ) {

        Module = CONTAINING_RECORD (Entry,
                                    INTERNAL_UNLOADED_MODULE,
                                    ModulesLink);
        Entry = Entry->Flink;

        //
        // Write module name.
        //

        if ((Status = WriteStringToPool (Dump,
                                         StreamInfo,
                                         Module->Path,
                                         &StringRva)) != S_OK) {
            return Status;
        }

        DumpModule.BaseOfImage = Module->BaseOfImage;
        DumpModule.SizeOfImage = Module->SizeOfImage;
        DumpModule.CheckSum = Module->CheckSum;
        DumpModule.TimeDateStamp = Module->TimeDateStamp;
        DumpModule.ModuleNameRva = StringRva;

        //
        // Write the module entry itself.
        //

        if ((Status = WriteUnloadedModule(Dump,
                                          StreamInfo,
                                          &DumpModule,
                                          NULL)) != S_OK) {
            return Status;
        }
    }

    return S_OK;
}

#define FUNCTION_TABLE_ALIGNMENT 8

HRESULT
WriteFunctionTableList(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    HRESULT Status;
    MINIDUMP_FUNCTION_TABLE_STREAM TableStream;
    MINIDUMP_FUNCTION_TABLE_DESCRIPTOR DumpTable;
    PLIST_ENTRY Entry;
    PINTERNAL_FUNCTION_TABLE Table;
    RVA PrevRva, Rva;


    ASSERT (Process);
    ASSERT (StreamInfo);

    if (IsListEmpty(&Process->FunctionTableList)) {
        // Nothing to write.
        return S_OK;
    }
    
    Rva = StreamInfo->RvaOfFunctionTableList;
    
    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, Rva, NULL)) != S_OK) {
        return Status;
    }

    TableStream.SizeOfHeader = sizeof(TableStream);
    TableStream.SizeOfDescriptor = sizeof(DumpTable);
    TableStream.SizeOfNativeDescriptor = Dump->FuncTableSize;
    TableStream.SizeOfFunctionEntry = Dump->FuncTableEntrySize;
    TableStream.NumberOfDescriptors = Process->NumberOfFunctionTables;
    // Ensure that the actual descriptors are 8-byte aligned in
    // the overall file.
    Rva += sizeof(TableStream);
    PrevRva = Rva;
    Rva = (Rva + FUNCTION_TABLE_ALIGNMENT - 1) &
        ~(FUNCTION_TABLE_ALIGNMENT - 1);
    TableStream.SizeOfAlignPad = Rva - PrevRva;

    if ((Status = Dump->OutProv->
         WriteAll(&TableStream, sizeof(TableStream))) != S_OK) {
        return Status;
    }

    //
    // Iterate through the function table list
    // and write out the table data.
    //

    Entry = Process->FunctionTableList.Flink;
    while ( Entry != &Process->FunctionTableList ) {

        Table = CONTAINING_RECORD (Entry,
                                   INTERNAL_FUNCTION_TABLE,
                                   TableLink);
        Entry = Entry->Flink;

        // Move to aligned RVA.
        if ((Status = Dump->OutProv->
             Seek(FILE_BEGIN, Rva, NULL)) != S_OK) {
            return Status;
        }

        DumpTable.MinimumAddress = Table->MinimumAddress;
        DumpTable.MaximumAddress = Table->MaximumAddress;
        DumpTable.BaseAddress = Table->BaseAddress;
        DumpTable.EntryCount = Table->EntryCount;
        Rva += sizeof(DumpTable) + Dump->FuncTableSize +
            Dump->FuncTableEntrySize * Table->EntryCount;
        PrevRva = Rva;
        Rva = (Rva + FUNCTION_TABLE_ALIGNMENT - 1) &
            ~(FUNCTION_TABLE_ALIGNMENT - 1);
        DumpTable.SizeOfAlignPad = Rva - PrevRva;
        
        if ((Status = Dump->OutProv->
             WriteAll(&DumpTable, sizeof(DumpTable))) != S_OK ||
            (Status = Dump->OutProv->
             WriteAll(Table->RawTable, Dump->FuncTableSize)) != S_OK ||
            (Status = Dump->OutProv->
             WriteAll(Table->RawEntries,
                      Dump->FuncTableEntrySize * Table->EntryCount)) != S_OK) {
            return Status;
        }
    }

    return S_OK;
}

HRESULT
WriteMemoryBlocks(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    HRESULT Status;
    PLIST_ENTRY ScanEntry;
    PVA_RANGE Scan;

    ScanEntry = Process->MemoryBlocks.Flink;
    while (ScanEntry != &Process->MemoryBlocks) {
        Scan = CONTAINING_RECORD(ScanEntry, VA_RANGE, NextLink);
        ScanEntry = Scan->NextLink.Flink;
        
        if ((Status =
             WriteMemoryFromProcess(Dump,
                                    StreamInfo,
                                    Process,
                                    Scan->Start,
                                    Scan->Size,
                                    FALSE,
                                    Scan->Type,
                                    NULL)) != S_OK) {
            return Status;
        }
    }

    return S_OK;
}

HRESULT
CalculateSizeForThreads(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN OUT MINIDUMP_STREAM_INFO * StreamInfo
    )
{
    ULONG SizeOfContexts;
    ULONG SizeOfMemRegions;
    ULONG SizeOfThreads;
    ULONG SizeOfMemoryDescriptors;
    ULONG NumberOfThreads;
    ULONG NumberOfMemRegions;
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY Entry;

    ASSERT (Process);
    ASSERT (StreamInfo);


    NumberOfThreads = 0;
    NumberOfMemRegions = 0;
    SizeOfContexts = 0;
    SizeOfMemRegions = 0;

    // If no backing store information is written a normal
    // MINIDUMP_THREAD can be used, otherwise a MINIDUMP_THREAD_EX
    // is required.
    StreamInfo->ThreadStructSize = sizeof(MINIDUMP_THREAD);

    Entry = Process->ThreadList.Flink;
    while ( Entry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (Entry,
                                    INTERNAL_THREAD,
                                    ThreadsLink);
        Entry = Entry->Flink;


        //
        // Do we need to write any information for this thread at all?
        //

        if (IsFlagClear (Thread->WriteFlags, ThreadWriteThread)) {
            continue;
        }

        NumberOfThreads++;

        //
        // Write a context for this thread?
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteContext)) {
            SizeOfContexts += Dump->ContextSize;
        }

        //
        // Write a stack for this thread?
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteStack)) {
            NumberOfMemRegions++;
            SizeOfMemRegions += (ULONG) (Thread->StackBase - Thread->StackEnd);
        }
        
        //
        // Write the backing store for this thread?
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteBackingStore)) {
            // A newly created thread's backing store may be empty
            // so handle the case of zero size.
            if (Thread->BackingStoreSize) {
                NumberOfMemRegions++;
                SizeOfMemRegions += Thread->BackingStoreSize;
            }
            // We still need a THREAD_EX as this is a platform
            // which supports backing store.
            StreamInfo->ThreadStructSize = sizeof(MINIDUMP_THREAD_EX);
        }

        // Write an instruction window for this thread?
        if (IsFlagSet (Thread->WriteFlags, ThreadWriteInstructionWindow)) {
            GenGetThreadInstructionWindow(Dump, Process, Thread);
        }

        // Write thread data for this thread?
        if (IsFlagSet (Thread->WriteFlags, ThreadWriteThreadData) &&
            Thread->SizeOfTeb) {
            GenAddTebMemory(Dump, Process, Thread);
        }
    }

    Process->NumberOfThreadsToWrite = NumberOfThreads;
    
    //
    // Nobody should have allocated memory from the thread list region yet.
    //

    ASSERT (StreamInfo->SizeOfThreadList == 0);

    SizeOfThreads = NumberOfThreads * StreamInfo->ThreadStructSize;
    SizeOfMemoryDescriptors = NumberOfMemRegions *
        sizeof (MINIDUMP_MEMORY_DESCRIPTOR);

    StreamInfo->SizeOfThreadList += sizeof (ULONG32);
    StreamInfo->SizeOfThreadList += SizeOfThreads;

    StreamInfo->SizeOfOther += SizeOfContexts;
    StreamInfo->SizeOfMemoryData += SizeOfMemRegions;
    StreamInfo->SizeOfMemoryDescriptors += SizeOfMemoryDescriptors;

    return S_OK;
}

HRESULT
CalculateSizeForModules(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN OUT MINIDUMP_STREAM_INFO * StreamInfo
    )

/*++

Routine Description:

    Calculate amount of space needed in the string pool, the memory table and
    the module list table for module information.

Arguments:

    Process - Minidump process information.

    StreamInfo - The stream size information for this dump.

--*/

{
    ULONG NumberOfModules;
    ULONG SizeOfDebugInfo;
    ULONG SizeOfStringData;
    PINTERNAL_MODULE Module;
    PLIST_ENTRY Entry;

    ASSERT (Process);
    ASSERT (StreamInfo);


    NumberOfModules = 0;
    SizeOfDebugInfo = 0;
    SizeOfStringData = 0;

    Entry = Process->ModuleList.Flink;
    while ( Entry != &Process->ModuleList ) {

        Module = CONTAINING_RECORD (Entry, INTERNAL_MODULE, ModulesLink);
        Entry = Entry->Flink;

        if (IsFlagClear (Module->WriteFlags, ModuleWriteModule)) {
            continue;
        }

        NumberOfModules++;
        SizeOfStringData += (GenStrLengthW(Module->SavePath) + 1) * sizeof(WCHAR);
        SizeOfStringData += sizeof ( MINIDUMP_STRING );

        //
        // Add in the sizes of both the CV and MISC records.
        //

        if (IsFlagSet (Module->WriteFlags, ModuleWriteCvRecord)) {
            SizeOfDebugInfo += Module->SizeOfCvRecord;
        }
        
        if (IsFlagSet (Module->WriteFlags, ModuleWriteMiscRecord)) {
            SizeOfDebugInfo += Module->SizeOfMiscRecord;
        }

        //
        // Add the module data sections if requested.
        //

        if (IsFlagSet (Module->WriteFlags, ModuleWriteDataSeg)) {
            GenGetDataContributors(Dump, Process, Module);
        }
    }

    Process->NumberOfModulesToWrite = NumberOfModules;
    
    ASSERT (StreamInfo->SizeOfModuleList == 0);

    StreamInfo->SizeOfModuleList += sizeof (MINIDUMP_MODULE_LIST);
    StreamInfo->SizeOfModuleList += (NumberOfModules * sizeof (MINIDUMP_MODULE));

    StreamInfo->SizeOfStringPool += SizeOfStringData;
    StreamInfo->SizeOfOther += SizeOfDebugInfo;

    return S_OK;
}

HRESULT
CalculateSizeForUnloadedModules(
    IN PINTERNAL_PROCESS Process,
    IN OUT MINIDUMP_STREAM_INFO * StreamInfo
    )
{
    ULONG SizeOfStringData;
    PINTERNAL_UNLOADED_MODULE Module;
    PLIST_ENTRY Entry;

    ASSERT (Process);
    ASSERT (StreamInfo);


    SizeOfStringData = 0;

    Entry = Process->UnloadedModuleList.Flink;
    while ( Entry != &Process->UnloadedModuleList ) {

        Module = CONTAINING_RECORD (Entry, INTERNAL_UNLOADED_MODULE,
                                    ModulesLink);
        Entry = Entry->Flink;

        SizeOfStringData += (GenStrLengthW(Module->Path) + 1) * sizeof(WCHAR);
        SizeOfStringData += sizeof ( MINIDUMP_STRING );
    }

    ASSERT (StreamInfo->SizeOfUnloadedModuleList == 0);

    StreamInfo->SizeOfUnloadedModuleList +=
        sizeof (MINIDUMP_UNLOADED_MODULE_LIST);
    StreamInfo->SizeOfUnloadedModuleList +=
        (Process->NumberOfUnloadedModules * sizeof (MINIDUMP_UNLOADED_MODULE));

    StreamInfo->SizeOfStringPool += SizeOfStringData;

    return S_OK;
}

HRESULT
CalculateSizeForFunctionTables(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN OUT MINIDUMP_STREAM_INFO * StreamInfo
    )
{
    ULONG SizeOfTableData;
    PINTERNAL_FUNCTION_TABLE Table;
    PLIST_ENTRY Entry;

    ASSERT (Process);
    ASSERT (StreamInfo);


    SizeOfTableData = 0;

    Entry = Process->FunctionTableList.Flink;
    while ( Entry != &Process->FunctionTableList ) {

        Table = CONTAINING_RECORD (Entry, INTERNAL_FUNCTION_TABLE, TableLink);
        Entry = Entry->Flink;

        // Alignment space is required as the structures
        // in the stream must be properly aligned.
        SizeOfTableData += FUNCTION_TABLE_ALIGNMENT +
            sizeof(MINIDUMP_FUNCTION_TABLE_DESCRIPTOR) +
            Dump->FuncTableSize +
            Table->EntryCount * Dump->FuncTableEntrySize;
    }

    ASSERT (StreamInfo->SizeOfFunctionTableList == 0);

    StreamInfo->SizeOfFunctionTableList +=
        sizeof (MINIDUMP_FUNCTION_TABLE_STREAM) + SizeOfTableData;

    return S_OK;
}

HRESULT
WriteDirectoryEntry(
    IN PMINIDUMP_STATE Dump,
    IN ULONG StreamType,
    IN ULONG RvaOfDir,
    IN SIZE_T SizeOfDir
    )
{
    MINIDUMP_DIRECTORY Dir;

    //
    // Do not write empty streams.
    //

    if (SizeOfDir == 0) {
        return S_OK;
    }

    //
    // The maximum size of a directory is a ULONG.
    //

    if (SizeOfDir > _UI32_MAX) {
        return E_INVALIDARG;
    }

    Dir.StreamType = StreamType;
    Dir.Location.Rva = RvaOfDir;
    Dir.Location.DataSize = (ULONG) SizeOfDir;

    return Dump->OutProv->
        WriteAll(&Dir, sizeof(Dir));
}

VOID
ScanContextForModuleRefs(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN PINTERNAL_THREAD Thread
    )
{
    ULONG NumReg;
    PUCHAR Reg;
    PINTERNAL_MODULE Module;

    Reg = (PUCHAR)Thread->ContextBuffer + Dump->RegScanOffset;
    NumReg = Dump->RegScanCount;

    while (NumReg-- > 0) {
        ULONG64 CurPtr;

        CurPtr = GenGetPointer(Dump, Reg);
        Reg += Dump->PtrSize;
        if (Module = ModuleContainingAddress(Process, CurPtr)) {
            Module->WriteFlags |= ModuleReferencedByMemory;
        }
    }
}
    
HRESULT
FilterOrScanMemory(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN PVOID MemBuffer
    )
{
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY ThreadEntry;

    //
    // Scan the stack and backing store
    // memory for every thread.
    //
    
    ThreadEntry = Process->ThreadList.Flink;
    while ( ThreadEntry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (ThreadEntry, INTERNAL_THREAD, ThreadsLink);
        ThreadEntry = ThreadEntry->Flink;

        ScanContextForModuleRefs(Dump, Process, Thread);
        
        ScanMemoryForModuleRefs(Dump, Process, TRUE,
                                Thread->StackEnd,
                                (ULONG)(Thread->StackBase - Thread->StackEnd),
                                MemBuffer, MEMBLOCK_STACK, FALSE);
        ScanMemoryForModuleRefs(Dump, Process, TRUE,
                                Thread->BackingStoreBase,
                                Thread->BackingStoreSize,
                                MemBuffer, MEMBLOCK_STORE, FALSE);
    }

    return S_OK;
}

#define IND_CAPTURE_SIZE (Dump->PageSize / 4)
#define PRE_IND_CAPTURE_SIZE (IND_CAPTURE_SIZE / 4)

HRESULT
AddIndirectMemory(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN ULONG64 Base,
    IN ULONG Size,
    IN PVOID MemBuffer
    )
{
    HRESULT Status = S_OK;
    PVOID CurMem;
    ULONG Done;

    // If the base address is not pointer-size aligned
    // we can't easily assume that this is a meaningful
    // area of memory to scan for references.  Normal
    // stack and store addresses will always be pointer
    // size aligned so this should only reject invalid
    // addresses.
    if (!Base || !Size || (Base & (Dump->PtrSize - 1))) {
        return S_OK;
    }

    if ((Status = Dump->SysProv->
         ReadVirtual(Dump->ProcessHandle,
                     Base, MemBuffer, Size, &Done)) != S_OK) {
        return Status;
    }

    CurMem = MemBuffer;
    Done /= Dump->PtrSize;
    while (Done-- > 0) {

        ULONG64 Start;
        HRESULT OneStatus;
        
        //
        // How much memory to save behind the pointer is an
        // interesting question.  The reference could be to
        // an arbitrary amount of data, so we want to save
        // a good chunk, but we don't want to end up saving
        // full memory.
        // Instead, pick an arbitrary size -- 1/4 of a page --
        // and save some before and after the pointer.
        //

        Start = GenGetPointer(Dump, CurMem);
        
        // If it's a pointer into an image assume doesn't
        // need to be stored via this mechanism as it's either
        // code, which will be mapped later; or data, which can
        // be saved with MiniDumpWithDataSegs.
        if (!ModuleContainingAddress(Process, Start)) {
            if (Start < PRE_IND_CAPTURE_SIZE) {
                Start = 0;
            } else {
                Start -= PRE_IND_CAPTURE_SIZE;
            }
            if ((OneStatus =
                 GenAddMemoryBlock(Dump, Process, MEMBLOCK_INDIRECT,
                                   Start, IND_CAPTURE_SIZE)) != S_OK) {
                Status = OneStatus;
            }
        }

        CurMem = (PUCHAR)CurMem + Dump->PtrSize;
    }

    return Status;
}

HRESULT
AddIndirectlyReferencedMemory(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    IN PVOID MemBuffer
    )
{
    HRESULT Status;
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY ThreadEntry;

    //
    // Scan the stack and backing store
    // memory for every thread.
    //
    
    ThreadEntry = Process->ThreadList.Flink;
    while ( ThreadEntry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (ThreadEntry, INTERNAL_THREAD, ThreadsLink);
        ThreadEntry = ThreadEntry->Flink;

        if ((Status =
             AddIndirectMemory(Dump,
                               Process,
                               Thread->StackEnd,
                               (ULONG)(Thread->StackBase - Thread->StackEnd),
                               MemBuffer)) != S_OK) {
            return Status;
        }
        if ((Status =
             AddIndirectMemory(Dump,
                               Process,
                               Thread->BackingStoreBase,
                               Thread->BackingStoreSize,
                               MemBuffer)) != S_OK) {
            return Status;
        }
    }

    return S_OK;
}

HRESULT
PostProcessInfo(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process
    )
{
    PVOID MemBuffer;
    HRESULT Status = S_OK;

    MemBuffer = AllocMemory(Dump, Process->MaxStackOrStoreSize);
    if (!MemBuffer) {
        return E_OUTOFMEMORY;
    }
    
    if (Dump->DumpType & (MiniDumpFilterMemory | MiniDumpScanMemory)) {
        Status = FilterOrScanMemory(Dump, Process, MemBuffer);
    }

    if (Status == S_OK &&
        (Dump->DumpType & MiniDumpWithIndirectlyReferencedMemory)) {
        // Indirect memory is not crucial to the dump so
        // ignore any failures.
        AddIndirectlyReferencedMemory(Dump, Process, MemBuffer);
    }

    FreeMemory(Dump, MemBuffer);
    return Status;
}

HRESULT
ExecuteCallbacks(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process
    )
{
    PINTERNAL_MODULE Module;
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY Entry;
    MINIDUMP_CALLBACK_INPUT CallbackInput;
    MINIDUMP_CALLBACK_OUTPUT CallbackOutput;


    ASSERT ( Process != NULL );

    Thread = NULL;
    Module = NULL;

    //
    // If there are no callbacks to call, then we are done.
    //

    if ( Dump->CallbackRoutine == NULL ) {
        return S_OK;
    }

    CallbackInput.ProcessHandle = Dump->ProcessHandle;
    CallbackInput.ProcessId = Dump->ProcessId;


    //
    // Call callbacks for each module.
    //

    CallbackInput.CallbackType = ModuleCallback;

    Entry = Process->ModuleList.Flink;
    while ( Entry != &Process->ModuleList ) {

        Module = CONTAINING_RECORD (Entry, INTERNAL_MODULE, ModulesLink);
        Entry = Entry->Flink;

        CallbackInput.Module.FullPath = Module->FullPath;
        CallbackInput.Module.BaseOfImage = Module->BaseOfImage;
        CallbackInput.Module.SizeOfImage = Module->SizeOfImage;
        CallbackInput.Module.CheckSum = Module->CheckSum;
        CallbackInput.Module.TimeDateStamp = Module->TimeDateStamp;
        CopyMemory (&CallbackInput.Module.VersionInfo,
                    &Module->VersionInfo,
                    sizeof (CallbackInput.Module.VersionInfo)
                    );
        CallbackInput.Module.CvRecord = Module->CvRecord;
        CallbackInput.Module.SizeOfCvRecord = Module->SizeOfCvRecord;
        CallbackInput.Module.MiscRecord = Module->MiscRecord;
        CallbackInput.Module.SizeOfMiscRecord = Module->SizeOfMiscRecord;

        CallbackOutput.ModuleWriteFlags = Module->WriteFlags;

        if (!Dump->CallbackRoutine (Dump->CallbackParam,
                                    &CallbackInput,
                                    &CallbackOutput)) {
            // If the callback returned FALSE, quit now.
            return E_ABORT;
        }

        // Don't turn on any flags that weren't originally set.
        Module->WriteFlags &= CallbackOutput.ModuleWriteFlags;
    }

    Module = NULL;

    //
    // Call callbacks for each thread.
    //

    if (Dump->BackingStore) {
        CallbackInput.CallbackType = ThreadExCallback;
    } else {
        CallbackInput.CallbackType = ThreadCallback;
    }

    Entry = Process->ThreadList.Flink;
    while ( Entry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (Entry, INTERNAL_THREAD, ThreadsLink);
        Entry = Entry->Flink;

        CallbackInput.ThreadEx.ThreadId = Thread->ThreadId;
        CallbackInput.ThreadEx.ThreadHandle = Thread->ThreadHandle;
        CallbackInput.ThreadEx.Context = *(PCONTEXT)Thread->ContextBuffer;
        CallbackInput.ThreadEx.SizeOfContext = Dump->ContextSize;
        CallbackInput.ThreadEx.StackBase = Thread->StackBase;
        CallbackInput.ThreadEx.StackEnd = Thread->StackEnd;
        CallbackInput.ThreadEx.BackingStoreBase = Thread->BackingStoreBase;
        CallbackInput.ThreadEx.BackingStoreEnd =
            Thread->BackingStoreBase + Thread->BackingStoreSize;

        CallbackOutput.ThreadWriteFlags = Thread->WriteFlags;

        if (!Dump->CallbackRoutine (Dump->CallbackParam,
                                    &CallbackInput,
                                    &CallbackOutput)) {
            // If the callback returned FALSE, quit now.
            return E_ABORT;
        }

        // Don't turn on any flags that weren't originally set.
        Thread->WriteFlags &= CallbackOutput.ThreadWriteFlags;
    }

    Thread = NULL;

    //
    // Call callbacks to include memory.
    //
    
    CallbackInput.CallbackType = MemoryCallback;

    for (;;) {

        CallbackOutput.MemoryBase = 0;
        CallbackOutput.MemorySize = 0;

        if (!Dump->CallbackRoutine (Dump->CallbackParam,
                                    &CallbackInput,
                                    &CallbackOutput) ||
            !CallbackOutput.MemorySize) {
            // If the callback returned FALSE there is no more memory.
            break;
        }

        GenAddMemoryBlock(Dump, Process, MEMBLOCK_MEM_CALLBACK,
                          CallbackOutput.MemoryBase,
                          CallbackOutput.MemorySize);
    }

    return S_OK;
}

HRESULT
WriteSystemInfo(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo
    )
{
    HRESULT Status;
    MINIDUMP_SYSTEM_INFO SystemInfo;
    WCHAR CSDVersionW [128];
    RVA StringRva;
    ULONG Length;

    StringRva = 0;

    //
    // First, get the CPU information.
    //

    if ((Status = Dump->SysProv->
         GetCpuInfo(&SystemInfo.ProcessorArchitecture,
                    &SystemInfo.ProcessorLevel,
                    &SystemInfo.ProcessorRevision,
                    &SystemInfo.NumberOfProcessors,
                    &SystemInfo.Cpu)) != S_OK) {
        return Status;
    }

    //
    // Next get OS Information.
    //

    SystemInfo.ProductType = (UCHAR)Dump->OsProductType;
    SystemInfo.MajorVersion = Dump->OsMajor;
    SystemInfo.MinorVersion = Dump->OsMinor;
    SystemInfo.BuildNumber = Dump->OsBuildNumber;
    SystemInfo.PlatformId = Dump->OsPlatformId;
    SystemInfo.SuiteMask = Dump->OsSuiteMask;
    SystemInfo.Reserved2 = 0;

    if ((Status = Dump->SysProv->
         GetOsCsdString(CSDVersionW, ARRAY_COUNT(CSDVersionW))) != S_OK) {
        return Status;
    }

    Length = (GenStrLengthW(CSDVersionW) + 1) * sizeof(WCHAR);

    if ( Length != StreamInfo->VersionStringLength ) {

        //
        // If this fails it means that since the OS lied to us about the
        // size of the string. Very bad, we should investigate.
        //

        ASSERT ( FALSE );
        return E_INVALIDARG;
    }

    if ((Status = WriteStringToPool (Dump,
                                     StreamInfo,
                                     CSDVersionW,
                                     &StringRva)) != S_OK) {
        return Status;
    }

    SystemInfo.CSDVersionRva = StringRva;

    ASSERT ( sizeof (SystemInfo) == StreamInfo->SizeOfSystemInfo );

    return WriteAtOffset (Dump,
                          StreamInfo->RvaOfSystemInfo,
                          &SystemInfo,
                          sizeof (SystemInfo));
}

HRESULT
CalculateSizeForSystemInfo(
    IN PMINIDUMP_STATE Dump,
    IN OUT MINIDUMP_STREAM_INFO * StreamInfo
    )
{
    HRESULT Status;
    WCHAR CSDVersionW [128];
    ULONG Length;

    if ((Status = Dump->SysProv->
         GetOsCsdString(CSDVersionW, ARRAY_COUNT(CSDVersionW))) != S_OK) {
        return Status;
    }
    
    Length = (GenStrLengthW(CSDVersionW) + 1) * sizeof(WCHAR);

    StreamInfo->SizeOfSystemInfo = sizeof (MINIDUMP_SYSTEM_INFO);
    StreamInfo->SizeOfStringPool += Length;
    StreamInfo->SizeOfStringPool += sizeof (MINIDUMP_STRING);
    StreamInfo->VersionStringLength = Length;

    return S_OK;
}

HRESULT
WriteMiscInfo(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    MINIDUMP_MISC_INFO MiscInfo;

    ZeroMemory(&MiscInfo, sizeof(MiscInfo));
    MiscInfo.SizeOfInfo = sizeof(MiscInfo);
    
    MiscInfo.Flags1 |= MINIDUMP_MISC1_PROCESS_ID;
    MiscInfo.ProcessId = Process->ProcessId;

    if (Process->TimesValid) {
        MiscInfo.Flags1 |= MINIDUMP_MISC1_PROCESS_TIMES;
        MiscInfo.ProcessCreateTime = Process->CreateTime;
        MiscInfo.ProcessUserTime = Process->UserTime;
        MiscInfo.ProcessKernelTime = Process->KernelTime;
    }
    
    return WriteAtOffset(Dump,
                         StreamInfo->RvaOfMiscInfo,
                         &MiscInfo,
                         sizeof(MiscInfo));
}

void
PostProcessMemoryBlocks(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process
    )
{
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY ThreadEntry;

    //
    // Remove any overlap with thread stacks and backing stores.
    //
    
    ThreadEntry = Process->ThreadList.Flink;
    while ( ThreadEntry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (ThreadEntry, INTERNAL_THREAD, ThreadsLink);
        ThreadEntry = ThreadEntry->Flink;

        GenRemoveMemoryRange(Dump, Process, 
                             Thread->StackEnd,
                             (ULONG)(Thread->StackBase - Thread->StackEnd));
        GenRemoveMemoryRange(Dump, Process,
                             Thread->BackingStoreBase,
                             Thread->BackingStoreSize);
    }
}

HRESULT
CalculateStreamInfo(
    IN PMINIDUMP_STATE Dump,
    IN PINTERNAL_PROCESS Process,
    OUT PMINIDUMP_STREAM_INFO StreamInfo,
    IN BOOL ExceptionPresent,
    IN PMINIDUMP_USER_STREAM UserStreamArray,
    IN ULONG UserStreamCount
    )
{
    ULONG i;
    HRESULT Status;
    ULONG NumberOfStreams;
    ULONG SizeOfDirectory;
    ULONG SizeOfUserStreams;


    ASSERT ( Process != NULL );
    ASSERT ( StreamInfo != NULL );


    ZeroMemory (StreamInfo, sizeof (*StreamInfo));

    if ( ExceptionPresent ) {
        NumberOfStreams = NUMBER_OF_STREAMS + UserStreamCount;
    } else {
        NumberOfStreams = NUMBER_OF_STREAMS + UserStreamCount - 1;
    }
    if (Dump->DumpType & MiniDumpWithHandleData) {
        NumberOfStreams++;
    }
    if (!IsListEmpty(&Process->UnloadedModuleList)) {
        NumberOfStreams++;
    }
    // Add a stream for dynamic function tables if some were found.
    if (!IsListEmpty(&Process->FunctionTableList)) {
        NumberOfStreams++;
    }

    SizeOfDirectory = sizeof (MINIDUMP_DIRECTORY) * NumberOfStreams;

    StreamInfo->NumberOfStreams = NumberOfStreams;

    StreamInfo->RvaOfHeader = 0;

    StreamInfo->SizeOfHeader = sizeof (MINIDUMP_HEADER);

    StreamInfo->RvaOfDirectory =
        StreamInfo->RvaOfHeader + StreamInfo->SizeOfHeader;

    StreamInfo->SizeOfDirectory = SizeOfDirectory;

    StreamInfo->RvaOfSystemInfo =
        StreamInfo->RvaOfDirectory + StreamInfo->SizeOfDirectory;

    if ((Status =
         CalculateSizeForSystemInfo(Dump, StreamInfo)) != S_OK) {
        return Status;
    }

    StreamInfo->RvaOfMiscInfo =
        StreamInfo->RvaOfSystemInfo + StreamInfo->SizeOfSystemInfo;
    
    StreamInfo->RvaOfException =
        StreamInfo->RvaOfMiscInfo + sizeof(MINIDUMP_MISC_INFO);

    //
    // If an exception is present, reserve enough space for the exception
    // and for the excepting thread's context in the Other stream.
    //

    if ( ExceptionPresent ) {
        StreamInfo->SizeOfException = sizeof (MINIDUMP_EXCEPTION_STREAM);
        StreamInfo->SizeOfOther += Dump->ContextSize;
    }

    StreamInfo->RvaOfThreadList =
        StreamInfo->RvaOfException + StreamInfo->SizeOfException;
    StreamInfo->RvaForCurThread = StreamInfo->RvaOfThreadList;

    if ((Status =
         CalculateSizeForThreads(Dump, Process, StreamInfo)) != S_OK) {
        return Status;
    }

    if ((Status =
         CalculateSizeForModules(Dump, Process, StreamInfo)) != S_OK) {
        return Status;
    }

    if (!IsListEmpty(&Process->UnloadedModuleList)) {
        if ((Status =
             CalculateSizeForUnloadedModules(Process, StreamInfo)) != S_OK) {
            return Status;
        }
    }

    if (!IsListEmpty(&Process->FunctionTableList)) {
        if ((Status = CalculateSizeForFunctionTables(Dump, Process,
                                                     StreamInfo)) != S_OK) {
            return Status;
        }
    }

    if ((Dump->DumpType & MiniDumpWithProcessThreadData) &&
        Process->SizeOfPeb) {
        GenAddPebMemory(Dump, Process);
    }
        
    PostProcessMemoryBlocks(Dump, Process);
    
    // Add in any extra memory blocks.
    StreamInfo->SizeOfMemoryData += Process->SizeOfMemoryBlocks;
    StreamInfo->SizeOfMemoryDescriptors += Process->NumberOfMemoryBlocks *
        sizeof(MINIDUMP_MEMORY_DESCRIPTOR);

    StreamInfo->RvaOfModuleList =
            StreamInfo->RvaOfThreadList + StreamInfo->SizeOfThreadList;
    StreamInfo->RvaForCurModule = StreamInfo->RvaOfModuleList;

    StreamInfo->RvaOfUnloadedModuleList =
            StreamInfo->RvaOfModuleList + StreamInfo->SizeOfModuleList;
    StreamInfo->RvaForCurUnloadedModule = StreamInfo->RvaOfUnloadedModuleList;

    // If there aren't any function tables the size will be zero
    // and the RVA will just end up being the RVA after
    // the module list.
    StreamInfo->RvaOfFunctionTableList =
        StreamInfo->RvaOfUnloadedModuleList +
        StreamInfo->SizeOfUnloadedModuleList;

    
    StreamInfo->RvaOfStringPool =
        StreamInfo->RvaOfFunctionTableList +
        StreamInfo->SizeOfFunctionTableList;
    StreamInfo->RvaForCurString = StreamInfo->RvaOfStringPool;
    StreamInfo->RvaOfOther =
            StreamInfo->RvaOfStringPool + StreamInfo->SizeOfStringPool;
    StreamInfo->RvaForCurOther = StreamInfo->RvaOfOther;


    SizeOfUserStreams = 0;

    for (i = 0; i < UserStreamCount; i++) {

        SizeOfUserStreams += (ULONG) UserStreamArray[i].BufferSize;
    }

    StreamInfo->RvaOfUserStreams =
            StreamInfo->RvaOfOther + StreamInfo->SizeOfOther;
    StreamInfo->SizeOfUserStreams = SizeOfUserStreams;


    //
    // Minidumps with full memory must put the raw memory
    // data at the end of the dump so that it's easy to
    // avoid mapping it when the dump is mapped.  There's
    // no problem with putting the memory data at the end
    // of the dump in all the other cases so just always
    // put the memory data at the end of the dump.
    //
    // One other benefit of having the raw data at the end
    // is that we can safely assume that everything except
    // the raw memory data will fit in the first 4GB of
    // the file so we don't need to use 64-bit file offsets
    // for everything.
    //
    // In the full memory case no other memory should have
    // been saved so far as stacks, data segs and so on
    // will automatically be included in the full memory
    // information.  If something was saved it'll throw off
    // the dump writing as full memory descriptors are generated
    // on the fly at write time rather than being precached.
    // If other descriptors and memory blocks have been written
    // out everything will be wrong.
    // Full-memory descriptors are also 64-bit and do not
    // match the 32-bit descriptors written elsewhere.
    //

    if ((Dump->DumpType & MiniDumpWithFullMemory) &&
        (StreamInfo->SizeOfMemoryDescriptors > 0 ||
         StreamInfo->SizeOfMemoryData > 0)) {
        return E_INVALIDARG;
    }
    
    StreamInfo->SizeOfMemoryDescriptors +=
        (Dump->DumpType & MiniDumpWithFullMemory) ?
        sizeof (MINIDUMP_MEMORY64_LIST) : sizeof (MINIDUMP_MEMORY_LIST);
    StreamInfo->RvaOfMemoryDescriptors =
        StreamInfo->RvaOfUserStreams + StreamInfo->SizeOfUserStreams;
    StreamInfo->RvaForCurMemoryDescriptor =
        StreamInfo->RvaOfMemoryDescriptors;

    StreamInfo->RvaOfMemoryData =
        StreamInfo->RvaOfMemoryDescriptors +
        StreamInfo->SizeOfMemoryDescriptors;
    StreamInfo->RvaForCurMemoryData = StreamInfo->RvaOfMemoryData;

    //
    // Handle data cannot easily be sized beforehand so it's
    // also streamed in at write time.  In a partial dump
    // it'll come after the memory data.  In a full dump
    // it'll come before it.
    //

    StreamInfo->RvaOfHandleData = StreamInfo->RvaOfMemoryData +
        StreamInfo->SizeOfMemoryData;
    
    return S_OK;
}

HRESULT
WriteHeader(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo
    )
{
    HRESULT Status;
    MINIDUMP_HEADER Header;

    Header.Signature = MINIDUMP_SIGNATURE;
    // Encode an implementation-specific version into the high word
    // of the version to make it clear what version of the code
    // was used to generate a dump.
    Header.Version =
        (MINIDUMP_VERSION & 0xffff) |
        ((VER_PRODUCTMAJORVERSION & 0xf) << 28) |
        ((VER_PRODUCTMINORVERSION & 0xf) << 24) |
        ((VER_PRODUCTBUILD & 0xff) << 16);
    Header.NumberOfStreams = StreamInfo->NumberOfStreams;
    Header.StreamDirectoryRva = StreamInfo->RvaOfDirectory;
    // If there were any partial failures during the
    // dump generation set the checksum to indicate that.
    // The checksum field was never used before so
    // we're stealing it for a somewhat related purpose.
    Header.CheckSum = Dump->AccumStatus;
    Header.Flags = Dump->DumpType;

    //
    // Store the time of dump generation.
    //

    if ((Status = Dump->SysProv->
         GetCurrentTimeDate((PULONG)&Header.TimeDateStamp)) != S_OK) {
        return Status;
    }
    
    ASSERT (sizeof (Header) == StreamInfo->SizeOfHeader);

    return WriteAtOffset (Dump,
                          StreamInfo->RvaOfHeader,
                          &Header,
                          sizeof (Header));
}

HRESULT
WriteDirectoryTable(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process,
    IN PMINIDUMP_USER_STREAM UserStreamArray,
    IN ULONG UserStreamCount
    )
{
    HRESULT Status;
    ULONG i;
    ULONG Offset;

    if ((Status =
         WriteDirectoryEntry (Dump,
                              StreamInfo->ThreadStructSize ==
                              sizeof(MINIDUMP_THREAD_EX) ?
                              ThreadExListStream : ThreadListStream,
                              StreamInfo->RvaOfThreadList,
                              StreamInfo->SizeOfThreadList)) != S_OK) {
        return Status;
    }

    if ((Status =
         WriteDirectoryEntry (Dump,
                              ModuleListStream,
                              StreamInfo->RvaOfModuleList,
                              StreamInfo->SizeOfModuleList)) != S_OK) {
        return Status;
    }

    if (!IsListEmpty(&Process->UnloadedModuleList)) {
        if ((Status =
             WriteDirectoryEntry (Dump,
                                  UnloadedModuleListStream,
                                  StreamInfo->RvaOfUnloadedModuleList,
                                  StreamInfo->SizeOfUnloadedModuleList)) != S_OK) {
            return Status;
        }
    }

    if (!IsListEmpty(&Process->FunctionTableList)) {
        if ((Status =
             WriteDirectoryEntry (Dump,
                                  FunctionTableStream,
                                  StreamInfo->RvaOfFunctionTableList,
                                  StreamInfo->SizeOfFunctionTableList)) != S_OK) {
            return Status;
        }
    }

    if ((Status =
         WriteDirectoryEntry (Dump,
                              (Dump->DumpType & MiniDumpWithFullMemory) ?
                              Memory64ListStream : MemoryListStream,
                              StreamInfo->RvaOfMemoryDescriptors,
                              StreamInfo->SizeOfMemoryDescriptors)) != S_OK) {
        return Status;
    }

    //
    // Write exception directory entry.
    //

    if ((Status =
         WriteDirectoryEntry (Dump,
                              ExceptionStream,
                              StreamInfo->RvaOfException,
                              StreamInfo->SizeOfException)) != S_OK) {
        return Status;
    }

    //
    // Write system info entry.
    //

    if ((Status =
         WriteDirectoryEntry (Dump,
                              SystemInfoStream,
                              StreamInfo->RvaOfSystemInfo,
                              StreamInfo->SizeOfSystemInfo)) != S_OK) {
        return Status;
    }

    //
    // Write misc info entry.
    //

    if ((Status =
         WriteDirectoryEntry(Dump,
                             MiscInfoStream,
                             StreamInfo->RvaOfMiscInfo,
                             sizeof(MINIDUMP_MISC_INFO))) != S_OK) {
        return Status;
    }

    if ((Dump->DumpType & MiniDumpWithHandleData) &&
        StreamInfo->SizeOfHandleData) {
        
        //
        // Write handle data entry.  If no handle data
        // was recovered we don't write an entry and
        // just let another unused stream get auto-created.
        //

        if ((Status =
             WriteDirectoryEntry (Dump,
                                  HandleDataStream,
                                  StreamInfo->RvaOfHandleData,
                                  StreamInfo->SizeOfHandleData)) != S_OK) {
            return Status;
        }
    }
    
    Offset = StreamInfo->RvaOfUserStreams;

    for (i = 0; i < UserStreamCount; i++) {

        if ((Status =
             WriteDirectoryEntry (Dump,
                                  UserStreamArray[i].Type,
                                  Offset,
                                  UserStreamArray [i].BufferSize)) != S_OK) {
            return Status;
        }

        Offset += UserStreamArray[i].BufferSize;
    }

    return S_OK;
}

HRESULT
WriteException(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN CONST PEXCEPTION_INFO ExceptionInfo
    )
{
    HRESULT Status;
    ULONG i;
    ULONG ContextRva;
    MINIDUMP_EXCEPTION_STREAM ExceptionStream;


    if (ExceptionInfo == NULL ) {
        return S_OK;
    }

    if ((Status = WriteOther (Dump,
                              StreamInfo,
                              ExceptionInfo->ContextRecord,
                              Dump->ContextSize,
                              &ContextRva)) != S_OK) {
        return Status;
    }

    ZeroMemory (&ExceptionStream, sizeof (ExceptionStream));

    ExceptionStream.ThreadId = ExceptionInfo->ThreadId;
    ExceptionStream.ExceptionRecord = ExceptionInfo->ExceptionRecord;
    ExceptionStream.ThreadContext.DataSize = Dump->ContextSize;
    ExceptionStream.ThreadContext.Rva = ContextRva;

    return WriteAtOffset(Dump,
                         StreamInfo->RvaOfException,
                         &ExceptionStream,
                         StreamInfo->SizeOfException);
}


HRESULT
WriteUserStreams(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PMINIDUMP_USER_STREAM UserStreamArray,
    IN ULONG UserStreamCount
    )
{
    HRESULT Status;
    ULONG i;
    ULONG Offset;

    Offset = StreamInfo->RvaOfUserStreams;

    for (i = 0; i < UserStreamCount; i++) {

        if ((Status = WriteAtOffset(Dump,
                                    Offset,
                                    UserStreamArray[i].Buffer,
                                    UserStreamArray[i].BufferSize)) != S_OK) {
            return Status;
        }

        Offset += UserStreamArray[ i ].BufferSize;
    }

    return S_OK;
}

HRESULT
WriteMemoryListHeader(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo
    )
{
    HRESULT Status;
    ULONG Size;
    ULONG Count;
    MINIDUMP_MEMORY_LIST MemoryList;

    ASSERT ( StreamInfo->RvaOfMemoryDescriptors ==
             StreamInfo->RvaForCurMemoryDescriptor );

    Size = StreamInfo->SizeOfMemoryDescriptors;
    Size -= sizeof (MINIDUMP_MEMORY_LIST);
    ASSERT ( (Size % sizeof (MINIDUMP_MEMORY_DESCRIPTOR)) == 0);
    Count = Size / sizeof (MINIDUMP_MEMORY_DESCRIPTOR);

    MemoryList.NumberOfMemoryRanges = Count;

    if ((Status = WriteAtOffset (Dump,
                                 StreamInfo->RvaOfMemoryDescriptors,
                                 &MemoryList,
                                 sizeof (MemoryList))) != S_OK) {
        return Status;
    }

    StreamInfo->RvaForCurMemoryDescriptor += sizeof (MemoryList);
    
    return S_OK;
}

#define FULL_MEMORY_BUFFER 65536

HRESULT
WriteFullMemory(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo
    )
{
    PVOID Buffer;
    HRESULT Status;
    ULONG64 Offset;
    ULONG64 Size;
    ULONG Protect, State, Type;
    MINIDUMP_MEMORY64_LIST List;
    MINIDUMP_MEMORY_DESCRIPTOR64 Desc;
    ULONG64 SeekOffset;

    //
    // Pick up the current offset for the RVA as
    // variable data may have been written in previously.
    //

    if ((Status = Dump->OutProv->
         Seek(FILE_CURRENT, 0, &SeekOffset)) != S_OK) {
        return Status;
    }

    StreamInfo->RvaOfMemoryDescriptors = (ULONG)SeekOffset;
    
    Buffer = AllocMemory(Dump, FULL_MEMORY_BUFFER);
    if (Buffer == NULL) {
        return E_OUTOFMEMORY;
    }

    //
    // First pass: count and write descriptors.
    // Only accessible, available memory is saved.
    //

    // Write placeholder list header.
    ZeroMemory(&List, sizeof(List));
    if ((Status = Dump->OutProv->
         WriteAll(&List, sizeof(List))) != S_OK) {
        goto Exit;
    }
    
    Offset = 0;
    for (;;) {
        if (Dump->SysProv->
            QueryVirtual(Dump->ProcessHandle, Offset, &Offset, &Size,
                         &Protect, &State, &Type) != S_OK) {
            break;
        }

        if (((Protect & PAGE_GUARD) ||
             (Protect & PAGE_NOACCESS) ||
             (State & MEM_FREE) ||
             (State & MEM_RESERVE))) {
            Offset += Size;
            continue;
        }

        // The size of a stream is a ULONG32 so we can't store
        // any more than that.
        if (List.NumberOfMemoryRanges ==
            (_UI32_MAX - sizeof(MINIDUMP_MEMORY64_LIST)) / sizeof(Desc)) {
            goto Exit;
        }

        List.NumberOfMemoryRanges++;
        
        Desc.StartOfMemoryRange = Offset;
        Desc.DataSize = Size;
        if ((Status = Dump->OutProv->
             WriteAll(&Desc, sizeof(Desc))) != S_OK) {
            goto Exit;
        }

        Offset += Size;
    }

    StreamInfo->SizeOfMemoryDescriptors +=
        (ULONG)List.NumberOfMemoryRanges * sizeof(Desc);
    List.BaseRva = (RVA64)StreamInfo->RvaOfMemoryDescriptors +
        StreamInfo->SizeOfMemoryDescriptors;
    
    //
    // Second pass: write memory contents.
    //

    Offset = 0;
    for (;;) {
        ULONG64 ChunkOffset;
        ULONG ChunkSize;

        if (Dump->SysProv->
            QueryVirtual(Dump->ProcessHandle, Offset, &Offset, &Size,
                         &Protect, &State, &Type) != S_OK) {
            break;
        }

        if (((Protect & PAGE_GUARD) ||
             (Protect & PAGE_NOACCESS) ||
             (State & MEM_FREE) ||
             (State & MEM_RESERVE))) {
            Offset += Size;
            continue;
        }

        ChunkOffset = Offset;
        Offset += Size;
        
        while (Size > 0) {
            if (Size > FULL_MEMORY_BUFFER) {
                ChunkSize = FULL_MEMORY_BUFFER;
            } else {
                ChunkSize = (ULONG)Size;
            }

            if ((Status = Dump->SysProv->
                 ReadAllVirtual(Dump->ProcessHandle,
                                ChunkOffset, Buffer, ChunkSize)) != S_OK) {
                goto Exit;
            }
            if ((Status = Dump->OutProv->
                 WriteAll(Buffer, ChunkSize)) != S_OK) {
                goto Exit;
            }
            
            ChunkOffset += ChunkSize;
            Size -= ChunkSize;
        }
    }

    // Write correct list header.
    Status = WriteAtOffset(Dump, StreamInfo->RvaOfMemoryDescriptors,
                           &List, sizeof(List));
    
 Exit:
    FreeMemory(Dump, Buffer);
    return Status;
}

HRESULT
WriteDumpData(
    IN PMINIDUMP_STATE Dump,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process,
    IN CONST PEXCEPTION_INFO ExceptionInfo,
    IN CONST PMINIDUMP_USER_STREAM UserStreamArray,
    IN ULONG UserStreamCount
    )
{
    HRESULT Status;

    if ((Status = WriteHeader ( Dump, StreamInfo )) != S_OK) {
        return Status;
    }

    if ((Status = WriteSystemInfo ( Dump, StreamInfo )) != S_OK) {
        return Status;
    }

    if ((Status = WriteMiscInfo(Dump, StreamInfo, Process)) != S_OK) {
        return Status;
    }

    //
    // Optionally, write the exception to the file.
    //

    if ((Status = WriteException ( Dump, StreamInfo, ExceptionInfo )) != S_OK) {
        return Status;
    }

    if (!(Dump->DumpType & MiniDumpWithFullMemory)) {
        //
        // WriteMemoryList initializes the memory list header (count).
        // The actual writing of the entries is done by WriteThreadList
        // and WriteModuleList.
        //

        if ((Status = WriteMemoryListHeader ( Dump, StreamInfo )) != S_OK) {
            return Status;
        }

        if ((Status = WriteMemoryBlocks(Dump, StreamInfo, Process)) != S_OK) {
            return Status;
        }
    }

    //
    // Write the threads list. This will also write the contexts, and
    // stacks for each thread.
    //

    if ((Status = WriteThreadList ( Dump, StreamInfo, Process )) != S_OK) {
        return Status;
    }

    //
    // Write the module list. This will also write the debug information and
    // module name to the file.
    //

    if ((Status = WriteModuleList ( Dump, StreamInfo, Process )) != S_OK) {
        return Status;
    }

    //
    // Write the unloaded module list.
    //

    if ((Status = WriteUnloadedModuleList ( Dump, StreamInfo, Process )) != S_OK) {
        return Status;
    }

    //
    // Write the function table list.
    //

    if ((Status = WriteFunctionTableList ( Dump, StreamInfo, Process )) != S_OK) {
        return Status;
    }


    if ((Status = WriteUserStreams ( Dump,
                                     StreamInfo,
                                     UserStreamArray,
                                     UserStreamCount)) != S_OK) {
        return Status;
    }


    // Put the file pointer at the end of the dump so
    // we can accumulate write-streamed data.
    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, StreamInfo->RvaOfHandleData, NULL)) != S_OK) {
        return Status;
    }
    
    if (Dump->DumpType & MiniDumpWithHandleData) {
        if ((Status =
             GenWriteHandleData(Dump, StreamInfo)) != S_OK) {
            return Status;
        }
    }

    if (Dump->DumpType & MiniDumpWithFullMemory) {
        if ((Status = WriteFullMemory(Dump, StreamInfo)) != S_OK) {
            return Status;
        }
    }

    if ((Status = Dump->OutProv->
         Seek(FILE_BEGIN, StreamInfo->RvaOfDirectory, NULL)) != S_OK) {
        return Status;
    }

    return WriteDirectoryTable ( Dump,
                                 StreamInfo,
                                 Process,
                                 UserStreamArray,
                                 UserStreamCount);
}


HRESULT
MarshalExceptionPointers(
    IN PMINIDUMP_STATE Dump,
    IN CONST _MINIDUMP_EXCEPTION_INFORMATION64* ExceptionParam,
    IN OUT PEXCEPTION_INFO ExceptionInfo
    )
{
    HRESULT Status;

    if (Dump->ExRecordSize == sizeof(EXCEPTION_RECORD32)) {

        EXCEPTION_RECORD32 Record;

        if ((Status = Dump->SysProv->
             ReadAllVirtual(Dump->ProcessHandle,
                            ExceptionParam->ExceptionRecord,
                            &Record,
                            sizeof(Record))) != S_OK) {
            return Status;
        }

        GenExRecord32ToMd(&Record, &ExceptionInfo->ExceptionRecord);

    } else {
        
        EXCEPTION_RECORD64 Record;

        if ((Status = Dump->SysProv->
             ReadAllVirtual(Dump->ProcessHandle,
                            ExceptionParam->ExceptionRecord,
                            &Record,
                            sizeof(Record))) != S_OK) {
            return Status;
        }

        GenExRecord64ToMd(&Record, &ExceptionInfo->ExceptionRecord);
    }
    
    if ((Status = Dump->SysProv->
         ReadAllVirtual(Dump->ProcessHandle,
                        ExceptionParam->ContextRecord,
                        ExceptionInfo->ContextRecord,
                        Dump->ContextSize)) != S_OK) {
        return Status;
    }

    return S_OK;
}

HRESULT
GetExceptionInfo(
    IN PMINIDUMP_STATE Dump,
    IN CONST struct _MINIDUMP_EXCEPTION_INFORMATION64* ExceptionParam,
    OUT PEXCEPTION_INFO * ExceptionInfoBuffer
    )
{
    HRESULT Status;
    PEXCEPTION_INFO ExceptionInfo;
    ULONG Size;

    if ( ExceptionParam == NULL ) {
        *ExceptionInfoBuffer = NULL;
        return S_OK;
    }

    if (Dump->ExRecordSize != sizeof(EXCEPTION_RECORD32) &&
        Dump->ExRecordSize != sizeof(EXCEPTION_RECORD64)) {
        return E_INVALIDARG;
    }
    
    Size = sizeof(*ExceptionInfo);
    if (ExceptionParam->ClientPointers) {
        Size += Dump->ContextSize;
    }
    
    ExceptionInfo = (PEXCEPTION_INFO)AllocMemory(Dump, Size);
    if ( ExceptionInfo == NULL ) {
        return E_OUTOFMEMORY;
    }

    if ( !ExceptionParam->ClientPointers ) {

        if (Dump->ExRecordSize == sizeof(EXCEPTION_RECORD32)) {
            GenExRecord32ToMd((PEXCEPTION_RECORD32)
                              ExceptionParam->ExceptionRecord,
                              &ExceptionInfo->ExceptionRecord);
        } else {
            GenExRecord64ToMd((PEXCEPTION_RECORD64)
                              ExceptionParam->ExceptionRecord,
                              &ExceptionInfo->ExceptionRecord);
        }

        ExceptionInfo->ContextRecord =
            (PVOID)ExceptionParam->ContextRecord;

        Status = S_OK;

    } else {

        ExceptionInfo->ContextRecord = (PVOID)(ExceptionInfo + 1);
        Status = MarshalExceptionPointers(Dump,
                                          ExceptionParam,
                                          ExceptionInfo);
    }

    ExceptionInfo->ThreadId = ExceptionParam->ThreadId;

    if ( Status != S_OK ) {
        FreeMemory(Dump, ExceptionInfo);
    } else {

        //
        // We've seen some cases where the exception record has
        // a bogus number of parameters, causing stack corruption here.
        // We could fail such cases but in the spirit of try to
        // allow dumps to generated as often as possible we just
        // limit the number to the maximum.
        //
    if (ExceptionInfo->ExceptionRecord.NumberParameters >
        EXCEPTION_MAXIMUM_PARAMETERS) {
        ExceptionInfo->ExceptionRecord.NumberParameters =
            EXCEPTION_MAXIMUM_PARAMETERS;
    }
    
        *ExceptionInfoBuffer = ExceptionInfo;
    }

    return Status;
}

VOID
FreeExceptionInfo(
    IN PMINIDUMP_STATE Dump,
    IN PEXCEPTION_INFO ExceptionInfo
    )
{
    if ( ExceptionInfo ) {
        FreeMemory(Dump, ExceptionInfo);
    }
}


HRESULT
GetSystemType(
    IN OUT PMINIDUMP_STATE Dump
    )
{
    HRESULT Status;

    if ((Status = Dump->SysProv->
         GetCpuType(&Dump->CpuType,
                    &Dump->BackingStore)) != S_OK) {
        return Status;
    }
    
    switch(Dump->CpuType) {
    case IMAGE_FILE_MACHINE_I386:
        Dump->CpuTypeName = L"x86";
        break;
    case IMAGE_FILE_MACHINE_IA64:
        Dump->CpuTypeName = L"IA64";
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        Dump->CpuTypeName = L"AMD64";
        break;
    case IMAGE_FILE_MACHINE_ARM:
        Dump->CpuTypeName = L"ARM";
        break;
    default:
        return E_INVALIDARG;
    }
    
    if ((Status = Dump->SysProv->
         GetOsInfo(&Dump->OsPlatformId,
                   &Dump->OsMajor,
                   &Dump->OsMinor,
                   &Dump->OsBuildNumber,
                   &Dump->OsProductType,
                   &Dump->OsSuiteMask)) != S_OK) {
        return Status;
    }
    
    Dump->SysProv->
        GetContextSizes(&Dump->ContextSize,
                        &Dump->RegScanOffset,
                        &Dump->RegScanCount);
    Dump->SysProv->
        GetPointerSize(&Dump->PtrSize);
    Dump->SysProv->
        GetPageSize(&Dump->PageSize);
    Dump->SysProv->
        GetFunctionTableSizes(&Dump->FuncTableSize,
                              &Dump->FuncTableEntrySize);
    Dump->SysProv->
        GetInstructionWindowSize(&Dump->InstructionWindowSize);

    if (Dump->FuncTableSize > MAX_DYNAMIC_FUNCTION_TABLE) {
        return E_INVALIDARG;
    }

    Dump->ExRecordSize = Dump->PtrSize == 8 ?
        sizeof(EXCEPTION_RECORD64) : sizeof(EXCEPTION_RECORD32);

    if (Dump->RegScanCount == -1) {
        // Default reg scan.
        switch(Dump->CpuType) {
        case IMAGE_FILE_MACHINE_I386:
            Dump->RegScanOffset = 0x9c;
            Dump->RegScanCount = 11;
            break;
        case IMAGE_FILE_MACHINE_IA64:
            Dump->RegScanOffset = 0x878;
            Dump->RegScanCount = 41;
            break;
        case IMAGE_FILE_MACHINE_AMD64:
            Dump->RegScanOffset = 0x78;
            Dump->RegScanCount = 17;
            break;
        case IMAGE_FILE_MACHINE_ARM:
            Dump->RegScanOffset = 4;
            Dump->RegScanCount = 16;
            break;
        default:
            return E_INVALIDARG;
        }
    }

    if (Dump->InstructionWindowSize == -1) {
        // Default window.
        switch(Dump->CpuType) {
        case IMAGE_FILE_MACHINE_I386:
            Dump->InstructionWindowSize = 256;
            break;
        case IMAGE_FILE_MACHINE_IA64:
            Dump->InstructionWindowSize = 768;
            break;
        case IMAGE_FILE_MACHINE_AMD64:
            Dump->InstructionWindowSize = 256;
            break;
        case IMAGE_FILE_MACHINE_ARM:
            Dump->InstructionWindowSize = 512;
            break;
        default:
            return E_INVALIDARG;
        }
    }
    
    return S_OK;
}

HRESULT
WINAPI
MiniDumpProvideDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN MiniDumpSystemProvider* SysProv,
    IN MiniDumpOutputProvider* OutProv,
    IN MiniDumpAllocationProvider* AllocProv,
    IN ULONG DumpType,
    IN CONST struct _MINIDUMP_EXCEPTION_INFORMATION64* ExceptionParam, OPTIONAL
    IN CONST struct _MINIDUMP_USER_STREAM_INFORMATION* UserStreamParam, OPTIONAL
    IN CONST struct _MINIDUMP_CALLBACK_INFORMATION* CallbackParam OPTIONAL
    )
{
    HRESULT Status;
    PINTERNAL_PROCESS Process;
    MINIDUMP_STREAM_INFO StreamInfo;
    PEXCEPTION_INFO ExceptionInfo;
    PMINIDUMP_USER_STREAM UserStreamArray;
    ULONG UserStreamCount;
    MINIDUMP_STATE Dump;


    if ((DumpType & ~(MiniDumpNormal |
                      MiniDumpWithDataSegs |
                      MiniDumpWithFullMemory |
                      MiniDumpWithHandleData |
                      MiniDumpFilterMemory |
                      MiniDumpScanMemory |
                      MiniDumpWithUnloadedModules |
                      MiniDumpWithIndirectlyReferencedMemory |
                      MiniDumpFilterModulePaths |
                      MiniDumpWithProcessThreadData |
                      MiniDumpWithPrivateReadWriteMemory |
                      MiniDumpWithoutOptionalData))) {

        return E_INVALIDARG;
    }

    // Modify flags that are affected by dropping optional data.
    if (DumpType & MiniDumpWithoutOptionalData) {
        DumpType &= ~(MiniDumpWithFullMemory |
                      MiniDumpWithIndirectlyReferencedMemory |
                      MiniDumpWithPrivateReadWriteMemory);
    }
    
    // Full memory by definition includes data segments,
    // so turn off data segments if full memory is requested.
    if (DumpType & MiniDumpWithFullMemory) {
        DumpType &= ~(MiniDumpWithDataSegs |
                      MiniDumpFilterMemory |
                      MiniDumpScanMemory |
                      MiniDumpWithIndirectlyReferencedMemory |
                      MiniDumpWithProcessThreadData |
                      MiniDumpWithPrivateReadWriteMemory);
    }
    
    // Fail immediately if stream-oriented data is requested but the
    // output provider can't handle streamed output.
    if ((DumpType & (MiniDumpWithHandleData |
                     MiniDumpWithFullMemory)) &&
        OutProv->SupportsStreaming() != S_OK) {
        return E_INVALIDARG;
    }

    //
    // Initialization
    //

    Process = NULL;
    UserStreamArray = NULL;
    UserStreamCount = 0;

    Dump.ProcessHandle = hProcess;
    Dump.ProcessId = ProcessId;
    Dump.SysProv = SysProv;
    Dump.OutProv = OutProv;
    Dump.AllocProv = AllocProv;
    Dump.DumpType = DumpType,
    Dump.AccumStatus = 0;

    if ( CallbackParam ) {
        Dump.CallbackRoutine = CallbackParam->CallbackRoutine;
        Dump.CallbackParam = CallbackParam->CallbackParam;
    } else {
        Dump.CallbackRoutine = NULL;
        Dump.CallbackParam = NULL;
    }

    if ((Status = GetSystemType(&Dump)) != S_OK) {
        return Status;
    }
    
    //
    // Marshal exception pointers into our process space if necessary.
    //

    if ((Status = GetExceptionInfo(&Dump,
                                   ExceptionParam,
                                   &ExceptionInfo)) != S_OK) {
        goto Exit;
    }

    if ( UserStreamParam ) {
        UserStreamArray = UserStreamParam->UserStreamArray;
        UserStreamCount = UserStreamParam->UserStreamCount;
    }

    //
    // Gather information about the process we are dumping.
    //

    if ((Status = GenGetProcessInfo(&Dump, &Process)) != S_OK) {
        goto Exit;
    }

    //
    // Process gathered information.
    //

    if ((Status = PostProcessInfo(&Dump, Process)) != S_OK) {
        goto Exit;
    }
    
    //
    // Execute user callbacks to filter out unwanted data.
    //

    if ((Status = ExecuteCallbacks(&Dump, Process)) != S_OK) {
        goto Exit;
    }

    //
    // Pass 1: Fill in the StreamInfo structure.
    //

    if ((Status =
         CalculateStreamInfo(&Dump,
                             Process,
                             &StreamInfo,
                             ( ExceptionInfo != NULL ) ? TRUE : FALSE,
                             UserStreamArray,
                             UserStreamCount)) != S_OK) {
        goto Exit;
    }

    //
    // Pass 2: Write the minidump data to disk.
    //

    if (DumpType & (MiniDumpWithHandleData |
                    MiniDumpWithFullMemory)) {
        // We don't know how big the output will be.
        if ((Status = OutProv->Start(0)) != S_OK) {
            goto Exit;
        }
    } else {
        // Pass in the size of the dump.
        if ((Status = OutProv->Start(StreamInfo.RvaOfHandleData)) != S_OK) {
            goto Exit;
        }
    }

    Status = WriteDumpData(&Dump,
                           &StreamInfo,
                           Process,
                           ExceptionInfo,
                           UserStreamArray,
                           UserStreamCount);

    OutProv->Finish();
    
Exit:

    //
    // Free up any memory marshalled for the exception pointers.
    //

    FreeExceptionInfo ( &Dump, ExceptionInfo );

    //
    // Free the process objects.
    //

    if ( Process ) {
        GenFreeProcessObject ( &Dump, Process );
    }

    return Status;
}

BOOL
UseDbgHelp(void)
{
#if !defined (_DBGHELP_SOURCE_)

    OSVERSIONINFO OsVer;
    
    //
    // Bind to dbghelp imports.
    //
    // We can only use the dbghelp imports if the dbghelp on
    // the system is of recent vintage and therefore has a good
    // chance of including all the latest minidump code.  Currently
    // Windows Server (5.01 >= build 3620) has the latest minidump
    // code so its dbghelp can be used.  If minidump.lib has major
    // feature additions this check will need to be revised.
    //
    
    OsVer.dwOSVersionInfoSize = sizeof(OsVer);
    if (GetVersionEx(&OsVer) &&
        OsVer.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        (OsVer.dwMajorVersion > 5 ||
         (OsVer.dwMajorVersion == 5 &&
          OsVer.dwMinorVersion >= 2)) &&
        OsVer.dwBuildNumber >= 3620) {
        return TRUE;
    }

#endif

    return FALSE;
}

BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    )
{
    HRESULT Status;
    MiniDumpSystemProvider* SysProv = NULL;
    MiniDumpOutputProvider* OutProv = NULL;
    MiniDumpAllocationProvider* AllocProv = NULL;
    MINIDUMP_EXCEPTION_INFORMATION64 ExInfoBuffer;
    PMINIDUMP_EXCEPTION_INFORMATION64 ExInfo;


    // Attempt to use the system's copy of the code in
    // dbghelp.  If any of this process fails just continue
    // on with the local code.
    if (UseDbgHelp()) {
        
        HINSTANCE Dll = LoadLibrary("dbghelp.dll");
        if (Dll) {

            MINI_DUMP_WRITE_DUMP Fn = (MINI_DUMP_WRITE_DUMP)
                GetProcAddress(Dll, "MiniDumpWriteDump");
            if (Fn) {
                BOOL Succ = Fn(hProcess, ProcessId, hFile, DumpType,
                               ExceptionParam, UserStreamParam, CallbackParam);
                FreeLibrary(Dll);
                return Succ;
            }

            FreeLibrary(Dll);
        }
    }
    
    if ((Status =
         MiniDumpCreateLiveSystemProvider(&SysProv)) != S_OK ||
        (Status =
         MiniDumpCreateFileOutputProvider(hFile, &OutProv)) != S_OK ||
        (Status =
         MiniDumpCreateLiveAllocationProvider(&AllocProv)) != S_OK) {
        goto Exit;
    }

    if (ExceptionParam) {
        ExInfo = &ExInfoBuffer;
        ExInfo->ThreadId = ExceptionParam->ThreadId;
        ExInfo->ClientPointers = ExceptionParam->ClientPointers;
        if (ExInfo->ClientPointers) {
            EXCEPTION_POINTERS ClientPointers;
            if ((Status = SysProv->
                 ReadAllVirtual(hProcess,
                                (LONG_PTR)ExceptionParam->ExceptionPointers,
                                &ClientPointers,
                                sizeof(ClientPointers))) != S_OK) {
                goto Exit;
            }
            ExInfo->ExceptionRecord =
                (LONG_PTR)ClientPointers.ExceptionRecord;
            ExInfo->ContextRecord =
                (LONG_PTR)ClientPointers.ContextRecord;
        } else {
            ExInfo->ExceptionRecord =
                (LONG_PTR)ExceptionParam->ExceptionPointers->ExceptionRecord;
            ExInfo->ContextRecord =
                (LONG_PTR)ExceptionParam->ExceptionPointers->ContextRecord;
        }
    } else {
        ExInfo = NULL;
    }
    
    Status = MiniDumpProvideDump(hProcess, ProcessId,
                                 SysProv, OutProv, AllocProv,
                                 DumpType, ExInfo,
                                 UserStreamParam, CallbackParam);
    
Exit:

    if (SysProv) {
        SysProv->Release();
    }
    if (OutProv) {
        OutProv->Release();
    }
    if (AllocProv) {
        AllocProv->Release();
    }
    
    if (Status == S_OK) {
        return TRUE;
    } else {
        SetLastError(Status);
        return FALSE;
    }
}

BOOL
WINAPI
MiniDumpReadDumpStream(
    IN PVOID Base,
    ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * Stream, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    )
{
    ULONG i;
    BOOL Found;
    PMINIDUMP_DIRECTORY Dirs;
    PMINIDUMP_HEADER Header;

    // Attempt to use the system's copy of the code in
    // dbghelp.  If any of this process fails just continue
    // on with the local code.
    if (UseDbgHelp()) {
        
        HINSTANCE Dll = LoadLibrary("dbghelp.dll");
        if (Dll) {

            MINI_DUMP_READ_DUMP_STREAM Fn = (MINI_DUMP_READ_DUMP_STREAM)
                GetProcAddress(Dll, "MiniDumpReadDumpStream");
            if (Fn) {
                BOOL Succ = Fn(Base, StreamNumber,
                               Dir, Stream, StreamSize);
                FreeLibrary(Dll);
                return Succ;
            }

            FreeLibrary(Dll);
        }
    }

    //
    // Initialization
    //

    Found = FALSE;
    Header = (PMINIDUMP_HEADER) Base;

    if ( Header->Signature != MINIDUMP_SIGNATURE ||
         (Header->Version & 0xffff) != MINIDUMP_VERSION ) {

        //
        // Invalid Minidump file.
        //

        return FALSE;
    }

    Dirs = (PMINIDUMP_DIRECTORY) RVA_TO_ADDR (Header, Header->StreamDirectoryRva);

    for (i = 0; i < Header->NumberOfStreams; i++) {
        if (Dirs [i].StreamType == StreamNumber) {
            Found = TRUE;
            break;
        }
    }

    if ( !Found ) {
        return FALSE;
    }

    if ( Dir ) {
        *Dir = &Dirs [i];
    }

    if ( Stream ) {
        *Stream = RVA_TO_ADDR (Base, Dirs [i].Location.Rva);
    }

    if ( StreamSize ) {
        *StreamSize = Dirs[i].Location.DataSize;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\pch.cpp ===
//----------------------------------------------------------------------------
//
// Precompiled header.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#ifndef _WIN32_WCE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winver.h>
#include <tlhelp32.h>

#include <wcecompat.h>
#include <uminiprov.hpp>

typedef ULONG32 mdToken;
typedef mdToken mdMethodDef;
#include <cordac.h>

#ifndef _WIN32_WCE
#define _IMAGEHLP_SOURCE_
#include <dbghelp.h>
#else
#include "minidump.h"
#endif

#include "mdump.h"
#include "gen.h"
#include "prov.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\nt4p.h ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    nt4p.h

Abstract:

    NT 4.0 specific headers. The structures and defines in this header were
    stolen from the relevant places in the NT4 header files so certian
    NtXXXX calls will continue to work when called from NT > version 4.

Author:

    Matthew D Hendel (math) 10-Sept-1999

Revision History:


--*/

#pragma once

//
// From ntdef.h
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
typedef LONG NTSTATUS;

typedef struct _NT4_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} NT4_UNICODE_STRING;
typedef NT4_UNICODE_STRING *PNT4_UNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

//
// Valid values for the Attributes field
//

#define NT4_OBJ_INHERIT             0x00000002L
#define NT4_OBJ_PERMANENT           0x00000010L
#define NT4_OBJ_EXCLUSIVE           0x00000020L
#define NT4_OBJ_CASE_INSENSITIVE    0x00000040L
#define NT4_OBJ_OPENIF              0x00000080L
#define NT4_OBJ_OPENLINK            0x00000100L
#define NT4_OBJ_VALID_ATTRIBUTES    0x000001F2L

//
// Object Attributes structure
//

typedef struct _NT4_OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PNT4_UNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} NT4_OBJECT_ATTRIBUTES;
typedef NT4_OBJECT_ATTRIBUTES *PNT4_OBJECT_ATTRIBUTES;

//++
//
// VOID
// InitializeObjectAttributes(
//     OUT PNT4_OBJECT_ATTRIBUTES p,
//     IN PNT4_UNICODE_STRING n,
//     IN ULONG a,
//     IN HANDLE r,
//     IN PSECURITY_DESCRIPTOR s
//     )
//
//--

#define Nt4InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( NT4_OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

//
// From ntpsapi.h
//

typedef struct _NT4_CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} NT4_CLIENT_ID;
typedef NT4_CLIENT_ID *PNT4_CLIENT_ID;


//
// From ntkeapi.h
//

typedef LONG NT4_KPRIORITY;
typedef ULONG NT4_KAFFINITY;

//
// From ntpsapi.h
//

//
// System Information Classes.
//

typedef enum _NT4_SYSTEM_INFORMATION_CLASS {
    Nt4SystemBasicInformation,
    Nt4SystemProcessorInformation,             // obsolete...delete
    Nt4SystemPerformanceInformation,
    Nt4SystemTimeOfDayInformation,
    Nt4SystemPathInformation,
    Nt4SystemProcessInformation,
    Nt4SystemCallCountInformation,
    Nt4SystemDeviceInformation,
    Nt4SystemProcessorPerformanceInformation,
    Nt4SystemFlagsInformation,
    Nt4SystemCallTimeInformation,
    Nt4SystemModuleInformation,
    Nt4SystemLocksInformation,
    Nt4SystemStackTraceInformation,
    Nt4SystemPagedPoolInformation,
    Nt4SystemNonPagedPoolInformation,
    Nt4SystemHandleInformation,
    Nt4SystemObjectInformation,
    Nt4SystemPageFileInformation,
    Nt4SystemVdmInstemulInformation,
    Nt4SystemVdmBopInformation,
    Nt4SystemFileCacheInformation,
    Nt4SystemPoolTagInformation,
    Nt4SystemInterruptInformation,
    Nt4SystemDpcBehaviorInformation,
    Nt4SystemFullMemoryInformation,
    Nt4SystemLoadGdiDriverInformation,
    Nt4SystemUnloadGdiDriverInformation,
    Nt4SystemTimeAdjustmentInformation,
    Nt4SystemSummaryMemoryInformation,
    Nt4SystemNextEventIdInformation,
    Nt4SystemEventIdsInformation,
    Nt4SystemCrashDumpInformation,
    Nt4SystemExceptionInformation,
    Nt4SystemCrashDumpStateInformation,
    Nt4SystemKernelDebuggerInformation,
    Nt4SystemContextSwitchInformation,
    Nt4SystemRegistryQuotaInformation,
    Nt4SystemExtendServiceTableInformation,
    Nt4SystemPrioritySeperation,
    Nt4SystemPlugPlayBusInformation,
    Nt4SystemDockInformation,
    NT4SystemPowerInformation,
    Nt4SystemProcessorSpeedInformation,
    Nt4SystemCurrentTimeZoneInformation,
    Nt4SystemLookasideInformation
} NT4_SYSTEM_INFORMATION_CLASS;

typedef struct _NT4_SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    NT4_UNICODE_STRING ImageName;
    NT4_KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SpareUl2;
    ULONG SpareUl3;
    ULONG PeakVirtualSize;
    ULONG VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    ULONG QuotaPeakPagedPoolUsage;
    ULONG QuotaPagedPoolUsage;
    ULONG QuotaPeakNonPagedPoolUsage;
    ULONG QuotaNonPagedPoolUsage;
    ULONG PagefileUsage;
    ULONG PeakPagefileUsage;
    ULONG PrivatePageCount;
} NT4_SYSTEM_PROCESS_INFORMATION, *PNT4_SYSTEM_PROCESS_INFORMATION;

typedef struct _NT4_SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    NT4_CLIENT_ID ClientId;
    NT4_KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} NT4_SYSTEM_THREAD_INFORMATION, *PNT4_SYSTEM_THREAD_INFORMATION;

typedef enum _NT4_PROCESSINFOCLASS {
    Nt4ProcessBasicInformation,
    Nt4ProcessQuotaLimits,
    Nt4ProcessIoCounters,
    Nt4ProcessVmCounters,
    Nt4ProcessTimes,
    Nt4ProcessBasePriority,
    Nt4ProcessRaisePriority,
    Nt4ProcessDebugPort,
    Nt4ProcessExceptionPort,
    Nt4ProcessAccessToken,
    Nt4ProcessLdtInformation,
    Nt4ProcessLdtSize,
    Nt4ProcessDefaultHardErrorMode,
    Nt4ProcessIoPortHandlers,          // Note: this is kernel mode only
    Nt4ProcessPooledUsageAndLimits,
    Nt4ProcessWorkingSetWatch,
    Nt4ProcessUserModeIOPL,
    Nt4ProcessEnableAlignmentFaultFixup,
    Nt4ProcessPriorityClass,
    Nt4ProcessWx86Information,
    Nt4ProcessHandleCount,
    Nt4ProcessAffinityMask,
    Nt4ProcessPriorityBoost,
    MaxNt4ProcessInfoClass
} NT4_PROCESSINFOCLASS;


//
// From ntpsapi.h
//

//
// Process Environment Block
//

typedef struct _NT4_PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
} NT4_PEB_LDR_DATA, *PNT4_PEB_LDR_DATA;

#define NT4_GDI_HANDLE_BUFFER_SIZE      34

typedef struct _NT4_PEB_FREE_BLOCK {
    struct _PEB_FREE_BLOCK *Next;
    ULONG Size;
} NT4_PEB_FREE_BLOCK, *PNT4_PEB_FREE_BLOCK;

#if 0
typedef struct _NT4_CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} NT4_CLIENT_ID;
typedef NT4_CLIENT_ID *PNT4_CLIENT_ID;
#endif


typedef struct _NT4_PEB {
    BOOLEAN InheritedAddressSpace;      // These four fields cannot change unless the
    BOOLEAN ReadImageFileExecOptions;   //
    BOOLEAN BeingDebugged;              //
    BOOLEAN SpareBool;                  //
    HANDLE Mutant;                      // INITIAL_PEB structure is also updated.

    PVOID ImageBaseAddress;
    PNT4_PEB_LDR_DATA Ldr;
    struct _RTL_USER_PROCESS_PARAMETERS *ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PVOID FastPebLock;
    PVOID FastPebLockRoutine;
    PVOID FastPebUnlockRoutine;
    ULONG EnvironmentUpdateCount;
    PVOID KernelCallbackTable;
    HANDLE EventLogSection;
    PVOID EventLog;
    PNT4_PEB_FREE_BLOCK FreeList;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];         // relates to TLS_MINIMUM_AVAILABLE
    PVOID ReadOnlySharedMemoryBase;
    PVOID ReadOnlySharedMemoryHeap;
    PVOID *ReadOnlyStaticServerData;
    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    //
    // Useful information for LdrpInitialize
    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    //
    // Passed up from MmCreatePeb from Session Manager registry key
    //

    LARGE_INTEGER CriticalSectionTimeout;
    ULONG HeapSegmentReserve;
    ULONG HeapSegmentCommit;
    ULONG HeapDeCommitTotalFreeThreshold;
    ULONG HeapDeCommitFreeBlockThreshold;

    //
    // Where heap manager keeps track of all heaps created for a process
    // Fields initialized by MmCreatePeb.  ProcessHeaps is initialized
    // to point to the first free byte after the PEB and MaximumNumberOfHeaps
    // is computed from the page size used to hold the PEB, less the fixed
    // size of this data structure.
    //

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID *ProcessHeaps;

    //
    //
    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    PVOID GdiDCAttributeList;
    PVOID LoaderLock;

    //
    // Following fields filled in by MmCreatePeb from system values and/or
    // image header.
    //

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    ULONG OSBuildNumber;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG ImageProcessAffinityMask;
    ULONG GdiHandleBuffer[NT4_GDI_HANDLE_BUFFER_SIZE];
} NT4_PEB, *PNT4_PEB;


//
// From ntldr.h
//

typedef struct _NT4_LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    NT4_UNICODE_STRING FullDllName;
    NT4_UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union {
        LIST_ENTRY HashLinks;
        struct {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    };
    ULONG   TimeDateStamp;
} NT4_LDR_DATA_TABLE_ENTRY, *PNT4_LDR_DATA_TABLE_ENTRY;


//
// From ntpsapi.h.
//

typedef struct _NT4_PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PNT4_PEB PebBaseAddress;
    NT4_KAFFINITY AffinityMask;
    NT4_KPRIORITY BasePriority;
    ULONG UniqueProcessId;
    ULONG InheritedFromUniqueProcessId;
} NT4_PROCESS_BASIC_INFORMATION;
typedef NT4_PROCESS_BASIC_INFORMATION *PNT4_PROCESS_BASIC_INFORMATION;


#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

typedef DWORD ACCESS_MASK;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\import.h ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    impl.h

Abstract:

    OS-specific thunks.

Author:

    Matthew D Hendel (math) 20-Sept-1999

Revision History:

--*/

#pragma once

//
// dbghelp routines
//

typedef
BOOL
(WINAPI * MINI_DUMP_READ_DUMP_STREAM) (
    IN PVOID Base,
    ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * Stream, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    );

typedef
BOOL
(WINAPI * MINI_DUMP_WRITE_DUMP) (
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );


//
// PSAPI APIs.
//

typedef
BOOL
(WINAPI *
ENUM_PROCESS_MODULES) (
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

typedef
DWORD
(WINAPI *
GET_MODULE_FILE_NAME_EX_W) (
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );


//
// NT APIs.
//

typedef 
NTSTATUS
(WINAPI *
NT_OPEN_THREAD) (
    PHANDLE ThreadHandle,
    ULONG Mask,
    PVOID Attributes,
    PVOID ClientId
    );

typedef
NTSTATUS
(WINAPI *
NT_QUERY_SYSTEM_INFORMATION) (
    IN INT SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef
NTSTATUS
(WINAPI *
NT_QUERY_INFORMATION_PROCESS) (
    IN HANDLE ProcessHandle,
    IN INT ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef
NTSTATUS
(WINAPI *
NT_QUERY_INFORMATION_THREAD) (
    IN HANDLE ThreadHandle,
    IN INT ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef
NTSTATUS
(WINAPI *
NT_QUERY_OBJECT) (
    IN HANDLE Handle,
    IN INT ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef
BOOLEAN
(NTAPI*
RTL_FREE_HEAP) (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

typedef
PLIST_ENTRY
(NTAPI* RTL_GET_FUNCTION_TABLE_LIST_HEAD) (
    VOID
    );

typedef
VOID
(NTAPI*
RTL_INIT_UNICODE_STRING) (
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

typedef
NTSTATUS
(NTAPI*
RTL_NT_PATH_NAME_TO_DOS_PATH_NAME) (
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Path,
    OUT    ULONG*                     Disposition OPTIONAL,
    IN OUT PWSTR*                     FilePart OPTIONAL
    );

typedef
PRTL_UNLOAD_EVENT_TRACE
(NTAPI* RTL_GET_UNLOAD_EVENT_TRACE) (
    VOID
    );


//
// Kernel32 APIs.
//

typedef
HANDLE
(WINAPI *
OPEN_THREAD) (
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    );

typedef
BOOL
(WINAPI *
THREAD32_FIRST) (
    HANDLE hSnapshot,
    PVOID ThreadEntry
    );

typedef
BOOL
(WINAPI *
THREAD32_NEXT) (
    HANDLE hSnapshot,
    PVOID ThreadEntry
    );

typedef
BOOL
(WINAPI *
MODULE32_FIRST) (
    HANDLE hSnapshot,
    PVOID Module
    );

typedef
BOOL
(WINAPI *
MODULE32_NEXT) (
    HANDLE hSnapshot,
    PVOID Module
    );

typedef
HANDLE
(WINAPI *
CREATE_TOOLHELP32_SNAPSHOT) (
    DWORD dwFlags,
    DWORD th32ProcessID
    );

typedef
DWORD
(WINAPI *
GET_LONG_PATH_NAME_A) (
    LPCSTR lpszShortPath,
    LPSTR lpszLongPath,
    DWORD cchBuffer
    );

typedef
DWORD
(WINAPI *
GET_LONG_PATH_NAME_W) (
    LPCWSTR lpszShortPath,
    LPWSTR lpszLongPath,
    DWORD cchBuffer
    );

typedef
BOOL
(WINAPI*
GET_PROCESS_TIMES) (
    IN HANDLE hProcess,
    OUT LPFILETIME lpCreationTime,
    OUT LPFILETIME lpExitTime,
    OUT LPFILETIME lpKernelTime,
    OUT LPFILETIME lpUserTime
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\mdump.h ===
/*++

Copyright(c) 1999-2002 Microsoft Corporation

Module Name:

    mdump.h

Abstract:

    Private header for minidump user-mode crashdump support.
    
Author:

    Matthew D Hendel (math) 20-Aug-1999

--*/


#pragma once

#define IsFlagSet(_var, _flag) ( ((_var) & (_flag)) != 0 )

#define IsFlagClear(_var, _flag) ( !IsFlagSet(_var, _flag) )


//
// StartOfStack gives the lowest address of the stack. SizeOfStack gives
// the size of the stack. Used together, they will give the memory region
// used by the stack.
//

#define StartOfStack(_thread) ((_thread)->StackEnd)

#define SizeOfStack(_thread) ((ULONG)((_thread)->StackBase - (_thread)->StackEnd)))


// Types of memory regions.
typedef enum
{
    MEMBLOCK_OTHER,
    MEMBLOCK_MERGED,
    MEMBLOCK_STACK,
    MEMBLOCK_STORE,
    MEMBLOCK_DATA_SEG,
    MEMBLOCK_UNWIND_INFO,
    MEMBLOCK_INSTR_WINDOW,
    MEMBLOCK_PEB,
    MEMBLOCK_TEB,
    MEMBLOCK_INDIRECT,
    MEMBLOCK_PRIVATE_RW,
    MEMBLOCK_COR,
    MEMBLOCK_MEM_CALLBACK,
} MEMBLOCK_TYPE;

//
// A VA_RANGE is a range of addresses that represents Size bytes beginning
// at Start.
//

typedef struct _VA_RANGE {
    ULONG64 Start;
    ULONG Size;
    MEMBLOCK_TYPE Type;
    LIST_ENTRY NextLink;
} VA_RANGE, *PVA_RANGE;


//
// INTERNAL_MODULE is the structure minidump uses internally to manage modules.
// A linked list of INTERNAL_MODULE structures are built up when
// GenGetProcessInfo is called.
//

typedef struct _INTERNAL_MODULE {

    //
    // File handle to the image.
    //
    
    HANDLE FileHandle;

    //
    // Base address, size, CheckSum, and TimeDateStamp for the image.
    //
    
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;

    //
    // Version information for the image.
    //
    
    VS_FIXEDFILEINFO VersionInfo;


    //
    // Buffer and size containing NB10 record for given module.
    //
    
    PVOID CvRecord;
    ULONG SizeOfCvRecord;

    //
    // Buffer and size of MISC debug record. We only get this with
    // images that have been split.
    //

    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;

    //
    // Full path to the image.
    //
    
    WCHAR FullPath [ MAX_PATH + 1];
    // Portion of full path to write in the module list.  This
    // allows paths to be filtered out for privacy reasons.
    PWSTR SavePath;

    //
    // What sections of the module does the client want written.
    //
    
    ULONG WriteFlags;
    
    //
    // Next image pointer.
    //

    LIST_ENTRY ModulesLink;

} INTERNAL_MODULE, *PINTERNAL_MODULE;


//
// INTERNAL_UNLOADED_MODULE is the structure minidump uses
// internally to manage unloaded modules.
// A linked list of INTERNAL_UNLOADED_MODULE structures are built up when
// GenGetProcessInfo is called.
//
//

typedef struct _INTERNAL_UNLOADED_MODULE {

    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;

    //
    // As much of the path to the image as can be recovered.
    //
    
    WCHAR Path[MAX_PATH + 1];

    //
    // Next image pointer.
    //

    LIST_ENTRY ModulesLink;

} INTERNAL_UNLOADED_MODULE, *PINTERNAL_UNLOADED_MODULE;



//
// INTERNAL_THREAD is the structure the minidump uses internally to
// manage threads. A list of INTERNAL_THREAD structures is built when
// GenGetProcessInfo is called.
//

typedef struct _INTERNAL_THREAD {

    //
    // The Win32 thread id of the thread an an open handle for the
    // thread.
    //
    
    ULONG ThreadId;
    HANDLE ThreadHandle;

    //
    // Suspend count, priority, priority class for the thread.
    //
    
    ULONG SuspendCount;
    ULONG PriorityClass;
    ULONG Priority;

    //
    // Thread TEB, Context and Size of Context.
    //
    
    ULONG64 Teb;
    ULONG SizeOfTeb;
    PVOID ContextBuffer;

    //
    // Current program counter.
    //

    ULONG64 CurrentPc;

    //
    // Stack variables. Remember, the stack grows down, so StackBase is
    // the highest stack address and StackEnd is the lowest.
    //
    
    ULONG64 StackBase;
    ULONG64 StackEnd;

    //
    // Backing store variables.
    //

    ULONG64 BackingStoreBase;
    ULONG BackingStoreSize;

    //
    // What sections of the module we should actually write to the file.
    //
    
    ULONG WriteFlags;
    
    //
    // Link to next thread.
    //
    
    LIST_ENTRY ThreadsLink;

} INTERNAL_THREAD, *PINTERNAL_THREAD;

//
// INTERNAL_FUNCTION_TABLE is the structure minidump uses
// internally to manage function tables.
// A linked list of INTERNAL_FUNCTION_TABLE structures is built up when
// GenGetProcessInfo is called.
//

typedef struct _INTERNAL_FUNCTION_TABLE {

    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG EntryCount;
    PVOID RawTable;
    PVOID RawEntries;

    LIST_ENTRY TableLink;

} INTERNAL_FUNCTION_TABLE, *PINTERNAL_FUNCTION_TABLE;


typedef struct _INTERNAL_PROCESS {

    //
    // The process id for the process.
    //

    ULONG ProcessId;

    //
    // Process data.
    //

    ULONG64 Peb;
    ULONG SizeOfPeb;

    //
    // Process run time information.
    //

    BOOL TimesValid;
    ULONG CreateTime;
    ULONG UserTime;
    ULONG KernelTime;

    //
    // An open handle to the process with read permissions.
    //
    
    HANDLE ProcessHandle;

    //
    // Number of threads for the process.
    //
    
    ULONG NumberOfThreads;
    ULONG NumberOfThreadsToWrite;
    ULONG MaxStackOrStoreSize;

    //
    // Number of modules for the process.
    //
    
    ULONG NumberOfModules;
    ULONG NumberOfModulesToWrite;

    //
    // Number of unloaded modules for the process.
    //
    
    ULONG NumberOfUnloadedModules;

    //
    // Number of function tables for the process.
    //
    
    ULONG NumberOfFunctionTables;

    //
    // Thread, module and function table lists for the process.
    //
    
    LIST_ENTRY ThreadList;
    LIST_ENTRY ModuleList;
    LIST_ENTRY UnloadedModuleList;
    LIST_ENTRY FunctionTableList;

    //
    // List of memory blocks to include for the process.
    //

    LIST_ENTRY MemoryBlocks;
    ULONG NumberOfMemoryBlocks;
    ULONG SizeOfMemoryBlocks;

    //
    // Indicates whether mscorwks, mscorsvr or mscoree is
    // present in the process.  These DLLs are used as an indicator
    // of whether the runtime is running in the process or not.
    //
    
    PWSTR CorDllType;
    ULONG64 CorDllBase;
    VS_FIXEDFILEINFO CorDllVer;
    WCHAR CorDllPath[MAX_PATH + 1];

} INTERNAL_PROCESS, *PINTERNAL_PROCESS;


//
// The visible streams are: (1) machine info, (2) exception, (3) thread list,
// (4) module list (5) memory list (6) misc info.
// We also add two extra for post-processing tools that want to add data later.
//

#define NUMBER_OF_STREAMS   (8)

//
// MINIDUMP_STREAM_INFO is the structure used by the minidump to manage
// it's internal data streams.
//

typedef struct _MINIDUMP_STREAM_INFO {

    //
    // How many streams we have.
    //
    
    ULONG NumberOfStreams;
    
    //
    // Reserved space for header.
    //
    
    ULONG RvaOfHeader;
    ULONG SizeOfHeader;

    //
    // Reserved space for directory.
    //

    ULONG RvaOfDirectory;
    ULONG SizeOfDirectory;

    //
    // Reserved space for system info.
    //

    ULONG RvaOfSystemInfo;
    ULONG SizeOfSystemInfo;
    ULONG VersionStringLength;

    //
    // Reserved space for misc info.
    //

    ULONG RvaOfMiscInfo;

    //
    // Reserved space for exception list.
    //
    
    ULONG RvaOfException;
    ULONG SizeOfException;

    //
    // Reserved space for thread list.
    //
    
    ULONG RvaOfThreadList;
    ULONG SizeOfThreadList;
    ULONG RvaForCurThread;
    ULONG ThreadStructSize;

    //
    // Reserved space for module list.
    //
    
    ULONG RvaOfModuleList;
    ULONG SizeOfModuleList;
    ULONG RvaForCurModule;

    //
    // Reserved space for unloaded module list.
    //
    
    ULONG RvaOfUnloadedModuleList;
    ULONG SizeOfUnloadedModuleList;
    ULONG RvaForCurUnloadedModule;

    //
    // Reserved space for function table list.
    //
    
    ULONG RvaOfFunctionTableList;
    ULONG SizeOfFunctionTableList;

    //
    // Reserved space for memory descriptors.
    //
    
    ULONG RvaOfMemoryDescriptors;
    ULONG SizeOfMemoryDescriptors;
    ULONG RvaForCurMemoryDescriptor;

    //
    // Reserved space for actual memory data.
    //
    
    ULONG RvaOfMemoryData;
    ULONG SizeOfMemoryData;
    ULONG RvaForCurMemoryData;

    //
    // Reserved space for strings.
    //
    
    ULONG RvaOfStringPool;
    ULONG SizeOfStringPool;
    ULONG RvaForCurString;

    //
    // Reserved space for other data like contexts, debug info records,
    // etc.
    //
    
    ULONG RvaOfOther;
    ULONG SizeOfOther;
    ULONG RvaForCurOther;

    //
    // Reserved space for user streams.
    //
    
    ULONG RvaOfUserStreams;
    ULONG SizeOfUserStreams;

    //
    // Reserved space for handle data.
    //

    ULONG RvaOfHandleData;
    ULONG SizeOfHandleData;

} MINIDUMP_STREAM_INFO, *PMINIDUMP_STREAM_INFO;


typedef struct _EXCEPTION_INFO {
    DWORD ThreadId;
    MINIDUMP_EXCEPTION ExceptionRecord;
    PVOID ContextRecord;
} EXCEPTION_INFO, *PEXCEPTION_INFO;

//
// Status flags for accumulated status.
//

// Ran out of memory during dump writing.
#define MDSTATUS_OUT_OF_MEMORY         0x00000001
// Process memory read failed during dump writing.
#define MDSTATUS_UNABLE_TO_READ_MEMORY 0x00000002
// OS routine failed during dump writing.
#define MDSTATUS_CALL_FAILED           0x00000004
// Unexpected internal failure during dump writing.
#define MDSTATUS_INTERNAL_ERROR        0x00000008

//
// Global state carried through a entire dump write operation.
//

typedef struct _MINIDUMP_STATE {
    //
    // Input values.
    //
    
    HANDLE ProcessHandle;
    DWORD ProcessId;
    MiniDumpSystemProvider* SysProv;
    MiniDumpOutputProvider* OutProv;
    MiniDumpAllocationProvider* AllocProv;
    ULONG DumpType;
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;

    //
    // Global state.
    //

    ULONG CpuType;
    PCWSTR CpuTypeName;
    BOOL BackingStore;
    ULONG OsPlatformId;
    ULONG OsMajor;
    ULONG OsMinor;
    ULONG OsServicePack;
    ULONG OsBuildNumber;
    USHORT OsProductType;
    USHORT OsSuiteMask;

    ULONG ContextSize;
    ULONG RegScanOffset;
    ULONG RegScanCount;
    ULONG ExRecordSize;
    ULONG PtrSize;
    ULONG PageSize;
    ULONG FuncTableSize;
    ULONG FuncTableEntrySize;
    ULONG InstructionWindowSize;

    ULONG AccumStatus;
} MINIDUMP_STATE, *PMINIDUMP_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\platform.h ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    platform.h

Abstract:

    Platform specific macros and functions.

Author:

    Matthew D Hendel (math) 28-Aug-1999

Revision History:

--*/

// Some processors use both a stack and a backing store.
// If a particular processor supports backing store add
// DUMP_BACKING_STORE.

#if defined (i386)

#define PROGRAM_COUNTER(_context)   ((LONG)(_context)->Eip)
#define STACK_POINTER(_context)     ((LONG)(_context)->Esp)
#define PAGE_SIZE                   4096
#define CPU_TYPE_NAME               L"x86"

//
// The CONTEXT_FULL definition on x86 doesn't really get all
// the registers. Use ALL_REGISTERS to get the compelte
// context.
//

#define ALL_REGISTERS   (CONTEXT_CONTROL    |\
                         CONTEXT_INTEGER    |\
                         CONTEXT_SEGMENTS   |\
                         CONTEXT_FLOATING_POINT |\
                         CONTEXT_DEBUG_REGISTERS    |\
                         CONTEXT_EXTENDED_REGISTERS)

//
// The following are flags specific to the CPUID instruction on x86 only.
//

#define CPUID_VENDOR_ID             (0)
#define CPUID_VERSION_FEATURES      (1)
#define CPUID_AMD_EXTENDED_FEATURES (0x80000001)

#elif defined(_AMD64_)

#define PROGRAM_COUNTER(_context)   ((_context)->Rip)
#define STACK_POINTER(_context)     ((_context)->Rsp)
#define PAGE_SIZE                   4096
#define CPU_TYPE_NAME               L"AMD64"

#define ALL_REGISTERS (CONTEXT_FULL | CONTEXT_SEGMENTS | CONTEXT_DEBUG_REGISTERS)

#elif defined (_IA64_)

#define PROGRAM_COUNTER(_context)   ((_context)->StIIP)
#define STACK_POINTER(_context)     ((_context)->IntSp)
#define PAGE_SIZE                   8192
#define ALL_REGISTERS               (CONTEXT_FULL | CONTEXT_DEBUG)
#define CPU_TYPE_NAME               L"IA64"

#define DUMP_BACKING_STORE
#if 1
// XXX drewb - The TEB bstore values don't seem to point to
// the actual base of the backing store.  Just
// assume it's contiguous with the stack.
#define BSTORE_BASE(_teb)           ((ULONG64)(_teb)->NtTib.StackBase)
#else
#define BSTORE_BASE(_teb)           ((ULONG64)(_teb)->DeallocationBStore)
#endif
#define BSTORE_LIMIT(_teb)           ((ULONG64)(_teb)->BStoreLimit)
// The BSP points to the bottom of the current frame's
// storage area.  We need to add on the size of the
// current frame to get the amount of memory that
// really needs to be stored.  When computing the
// size of the current frame space for NAT bits
// must be figured in properly based on the number
// of entries in the frame.  The NAT collection
// is spilled on every 63'rd spilled register to
// make each block an every 64 ULONG64s long.
// On NT the backing store base is always 9-bit aligned
// so we can tell when exactly the next NAT spill
// will occur by looking for when the 9-bit spill
// region will overflow.
__inline ULONG64
BSTORE_POINTER(CONTEXT* Context)
{
    ULONG64 Limit = Context->RsBSP;
    ULONG Count = (ULONG)(Context->StIFS & 0x7f);

    // Add in a ULONG64 for every register in the
    // current frame.  While doing so, check for
    // spill entries.
    while (Count-- > 0)
    {
        Limit += sizeof(ULONG64);
        if ((Limit & 0x1f8) == 0x1f8)
        {
            // Spill will be placed at this address so
            // account for it.
            Limit += sizeof(ULONG64);
        }
    }

    return Limit;
}

#elif defined (ARM)

#define PROGRAM_COUNTER(_context)   ((LONG)(_context)->Pc)
#define STACK_POINTER(_context)     ((LONG)(_context)->Sp)
#define PAGE_SIZE                   4096
#define CPU_TYPE_NAME               L"ARM"
#define ALL_REGISTERS               (CONTEXT_CONTROL | CONTEXT_INTEGER)

#else

#error ("unknown processor type")

#endif

#define AMD_VENDOR_ID_0     ('htuA')
#define AMD_VENDOR_ID_1     ('itne')
#define AMD_VENDOR_ID_2     ('DMAc')

#define INTEL_VENDOR_ID_0   ('uneG')
#define INTEL_VENDOR_ID_1   ('Ieni')
#define INTEL_VENDOR_ID_2   ('letn')
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\prov.hpp ===
/*++

Copyright(c) 1999-2002 Microsoft Corporation

--*/

#pragma once

#include "import.h"

#define NT_BUILD_WIN2K          2195
#define NT_BUILD_TH_MODULES     2469
#define NT_BUILD_XP             2600

class Win32LiveSystemProvider : public MiniDumpSystemProvider
{
public:
    Win32LiveSystemProvider(ULONG PlatformId, ULONG BuildNumber);
    ~Win32LiveSystemProvider(void);
    
    virtual HRESULT Initialize(void);

    virtual void Release(void);
    virtual HRESULT GetCurrentTimeDate(OUT PULONG TimeDate);
    virtual HRESULT GetCpuType(OUT PULONG Type,
                               OUT PBOOL BackingStore);
    virtual HRESULT GetCpuInfo(OUT PUSHORT Architecture,
                               OUT PUSHORT Level,
                               OUT PUSHORT Revision,
                               OUT PUCHAR NumberOfProcessors,
                               OUT PCPU_INFORMATION Info);
    virtual void GetContextSizes(OUT PULONG Size,
                                 OUT PULONG RegScanStart,
                                 OUT PULONG RegScanCount);
    virtual void GetPointerSize(OUT PULONG Size);
    virtual void GetPageSize(OUT PULONG Size);
    virtual void GetFunctionTableSizes(OUT PULONG TableSize,
                                       OUT PULONG EntrySize);
    virtual void GetInstructionWindowSize(OUT PULONG Size);
    virtual HRESULT GetOsInfo(OUT PULONG PlatformId,
                              OUT PULONG Major,
                              OUT PULONG Minor,
                              OUT PULONG BuildNumber,
                              OUT PUSHORT ProductType,
                              OUT PUSHORT SuiteMask);
    virtual HRESULT GetOsCsdString(OUT PWSTR Buffer,
                                   IN ULONG BufferChars);
    virtual HRESULT OpenMapping(IN PCWSTR FilePath,
                                OUT PULONG Size,
                                OUT PWSTR LongPath,
                                IN ULONG LongPathChars,
                                OUT PVOID* Mapping);
    virtual void    CloseMapping(PVOID Mapping);
    virtual HRESULT GetImageHeaderInfo(IN HANDLE Process,
                                       IN PCWSTR FilePath,
                                       IN ULONG64 ImageBase,
                                       OUT PULONG Size,
                                       OUT PULONG CheckSum,
                                       OUT PULONG TimeDateStamp);
    virtual HRESULT GetImageVersionInfo(IN HANDLE Process,
                                        IN PCWSTR FilePath,
                                        IN ULONG64 ImageBase,
                                        OUT VS_FIXEDFILEINFO* Info);
    virtual HRESULT GetImageDebugRecord(IN HANDLE Process,
                                        IN PCWSTR FilePath,
                                        IN ULONG64 ImageBase,
                                        IN ULONG RecordType,
                                        OUT OPTIONAL PVOID Data,
                                        IN OUT PULONG DataLen);
    virtual HRESULT EnumImageDataSections(IN HANDLE Process,
                                          IN PCWSTR FilePath,
                                          IN ULONG64 ImageBase,
                                          IN MiniDumpProviderCallbacks*
                                          Callback);
    virtual HRESULT OpenThread(IN ULONG DesiredAccess,
                               IN BOOL InheritHandle,
                               IN ULONG ThreadId,
                               OUT PHANDLE Handle);
    virtual void    CloseThread(IN HANDLE Handle);
    virtual ULONG   GetCurrentThreadId(void);
    virtual ULONG   SuspendThread(IN HANDLE Thread);
    virtual ULONG   ResumeThread(IN HANDLE Thread);
    virtual HRESULT GetThreadContext(IN HANDLE Thread,
                                     OUT PVOID Context,
                                     IN ULONG ContextSize,
                                     OUT PULONG64 CurrentPc,
                                     OUT PULONG64 CurrentStack,
                                     OUT PULONG64 CurrentStore);
    virtual HRESULT GetProcessTimes(IN HANDLE Process,
                                    OUT LPFILETIME Create,
                                    OUT LPFILETIME User,
                                    OUT LPFILETIME Kernel);
    virtual HRESULT ReadVirtual(IN HANDLE Process,
                                IN ULONG64 Offset,
                                OUT PVOID Buffer,
                                IN ULONG Request,
                                OUT PULONG Done);
    virtual HRESULT ReadAllVirtual(IN HANDLE Process,
                                   IN ULONG64 Offset,
                                   OUT PVOID Buffer,
                                   IN ULONG Request);
    virtual HRESULT QueryVirtual(IN HANDLE Process,
                                 IN ULONG64 Offset,
                                 OUT PULONG64 Base,
                                 OUT PULONG64 Size,
                                 OUT PULONG Protect,
                                 OUT PULONG State,
                                 OUT PULONG Type);
    virtual HRESULT StartProcessEnum(IN HANDLE Process,
                                     IN ULONG ProcessId);
    virtual HRESULT EnumThreads(OUT PULONG ThreadId);
    virtual HRESULT EnumModules(OUT PULONG64 Base,
                                OUT PWSTR Path,
                                IN ULONG PathChars);
    virtual HRESULT EnumFunctionTables(OUT PULONG64 MinAddress,
                                       OUT PULONG64 MaxAddress,
                                       OUT PULONG64 BaseAddress,
                                       OUT PULONG EntryCount,
                                       OUT PVOID RawTable,
                                       IN ULONG RawTableSize,
                                       OUT PVOID* RawEntryHandle);
    virtual HRESULT EnumFunctionTableEntries(IN PVOID RawTable,
                                             IN ULONG RawTableSize,
                                             IN PVOID RawEntryHandle,
                                             OUT PVOID RawEntries,
                                             IN ULONG RawEntriesSize);
    virtual HRESULT EnumFunctionTableEntryMemory(IN ULONG64 TableBase,
                                                 IN PVOID RawEntries,
                                                 IN ULONG Index,
                                                 OUT PULONG64 Start,
                                                 OUT PULONG Size);
    virtual HRESULT EnumUnloadedModules(OUT PWSTR Path,
                                        IN ULONG PathChars,
                                        OUT PULONG64 BaseOfModule,
                                        OUT PULONG SizeOfModule,
                                        OUT PULONG CheckSum,
                                        OUT PULONG TimeDateStamp);
    virtual void    FinishProcessEnum(void);
    virtual HRESULT StartHandleEnum(IN HANDLE Process,
                                    IN ULONG ProcessId,
                                    OUT PULONG Count);
    virtual HRESULT EnumHandles(OUT PULONG64 Handle,
                                OUT PULONG Attributes,
                                OUT PULONG GrantedAccess,
                                OUT PULONG HandleCount,
                                OUT PULONG PointerCount,
                                OUT PWSTR TypeName,
                                IN ULONG TypeNameChars,
                                OUT PWSTR ObjectName,
                                IN ULONG ObjectNameChars);
    virtual void    FinishHandleEnum(void);

    virtual HRESULT EnumPebMemory(IN HANDLE Process,
                                  IN ULONG64 PebOffset,
                                  IN ULONG PebSize,
                                  IN MiniDumpProviderCallbacks* Callback);
    virtual HRESULT EnumTebMemory(IN HANDLE Process,
                                  IN HANDLE Thread,
                                  IN ULONG64 TebOffset,
                                  IN ULONG TebSize,
                                  IN MiniDumpProviderCallbacks* Callback);

    virtual HRESULT GetCorDataAccess(IN PWSTR AccessDllName,
                                     IN struct ICorDataAccessServices*
                                     Services,
                                     OUT struct ICorDataAccess**
                                     Access);
    virtual void    ReleaseCorDataAccess(IN struct ICorDataAccess*
                                         Access);

protected:

    HRESULT ProcessThread32Next(IN HANDLE Snapshot,
                                IN ULONG ProcessId,
                                OUT THREADENTRY32* ThreadInfo);
    HRESULT ProcessThread32First(IN HANDLE Snapshot,
                                 IN ULONG dwProcessId,
                                 OUT THREADENTRY32* ThreadInfo);
    HRESULT TibGetThreadInfo(IN HANDLE Process,
                             IN ULONG64 TibBase,
                             OUT PULONG64 StackBase,
                             OUT PULONG64 StackLimit,
                             OUT PULONG64 StoreBase,
                             OUT PULONG64 StoreLimit);

    ULONG m_PlatformId;
    ULONG m_BuildNumber;
    
    HINSTANCE m_PsApi;
    ENUM_PROCESS_MODULES m_EnumProcessModules;
    GET_MODULE_FILE_NAME_EX_W m_GetModuleFileNameExW;
    
    HINSTANCE m_Kernel32;
    OPEN_THREAD m_OpenThread;
    THREAD32_FIRST m_Thread32First;
    THREAD32_NEXT m_Thread32Next;
    MODULE32_FIRST m_Module32First;
    MODULE32_NEXT m_Module32Next;
    MODULE32_FIRST m_Module32FirstW;
    MODULE32_NEXT m_Module32NextW;
    CREATE_TOOLHELP32_SNAPSHOT m_CreateToolhelp32Snapshot;
    GET_LONG_PATH_NAME_A m_GetLongPathNameA;
    GET_LONG_PATH_NAME_W m_GetLongPathNameW;
    GET_PROCESS_TIMES m_GetProcessTimes;

    HANDLE m_ProcessHandle;
    ULONG m_ProcessId;
    HANDLE m_ThSnap;
    BOOL m_AnsiModules;
    ULONG m_ThreadIndex;
    ULONG m_ModuleIndex;
    ULONG m_LastModuleId;

    HINSTANCE m_CorDll;
};

Win32LiveSystemProvider* NewNtWin32LiveSystemProvider(ULONG BuildNumber);
Win32LiveSystemProvider* NewWin9xWin32LiveSystemProvider(ULONG BuildNumber);
Win32LiveSystemProvider* NewWinCeWin32LiveSystemProvider(ULONG BuildNumber);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\prov_wce.cpp ===
/*++

Copyright(c) 1999-2002 Microsoft Corporation

--*/


#include "pch.cpp"

#include <time.h>

//----------------------------------------------------------------------------
//
// WinCeWin32LiveSystemProvider.
//
//----------------------------------------------------------------------------

class WinCeWin32LiveSystemProvider : public Win32LiveSystemProvider
{
public:
    WinCeWin32LiveSystemProvider(ULONG BuildNumber);
    ~WinCeWin32LiveSystemProvider(void);

    virtual void Release(void);
    virtual HRESULT GetCurrentTimeDate(OUT PULONG TimeDate);
    virtual HRESULT OpenThread(IN ULONG DesiredAccess,
                               IN BOOL InheritHandle,
                               IN ULONG ThreadId,
                               OUT PHANDLE Handle);
    virtual HRESULT GetTeb(IN HANDLE Thread,
                           OUT PULONG64 Offset,
                           OUT PULONG Size);
    virtual HRESULT GetThreadInfo(IN HANDLE Process,
                                  IN HANDLE Thread,
                                  OUT PULONG64 Teb,
                                  OUT PULONG SizeOfTeb,
                                  OUT PULONG64 StackBase,
                                  OUT PULONG64 StackLimit,
                                  OUT PULONG64 StoreBase,
                                  OUT PULONG64 StoreLimit);
    virtual HRESULT GetPeb(IN HANDLE Process,
                           OUT PULONG64 Offset,
                           OUT PULONG Size);
};

WinCeWin32LiveSystemProvider::WinCeWin32LiveSystemProvider(ULONG BuildNumber)
    : Win32LiveSystemProvider(VER_PLATFORM_WIN32_CE, BuildNumber)
{
}

WinCeWin32LiveSystemProvider::~WinCeWin32LiveSystemProvider(void)
{
}

void
WinCeWin32LiveSystemProvider::Release(void)
{
    delete this;
}

HRESULT
WinCeWin32LiveSystemProvider::GetCurrentTimeDate(OUT PULONG TimeDate)
{
    *TimeDate = (ULONG)time(NULL);
    return S_OK;
}

HRESULT
WinCeWin32LiveSystemProvider::OpenThread(IN ULONG DesiredAccess,
                                         IN BOOL InheritHandle,
                                         IN ULONG ThreadId,
                                         OUT PHANDLE Handle)
{
    if (m_OpenThread) {
        // OS supports regular Win32 OpenThread, so try it.
        *Handle = m_OpenThread(DesiredAccess, InheritHandle, ThreadId);
        if (*Handle) {
            return S_OK;
        }
    }

    // WinCE's "handles" and thread IDs are both just pointers
    // to the OS thread data.
    *Handle = (HANDLE)(ULONG_PTR)ThreadId;
    return S_OK;
}

HRESULT
WinCeWin32LiveSystemProvider::GetTeb(IN HANDLE Thread,
                                     OUT PULONG64 Offset,
                                     OUT PULONG Size)
{
    // WinCE doesn't have a TIB.
    *Offset = NULL;
    *Size = 0;
    return S_OK;
}

HRESULT
WinCeWin32LiveSystemProvider::GetThreadInfo(IN HANDLE Process,
                                            IN HANDLE Thread,
                                            OUT PULONG64 Teb,
                                            OUT PULONG SizeOfTeb,
                                            OUT PULONG64 StackBase,
                                            OUT PULONG64 StackLimit,
                                            OUT PULONG64 StoreBase,
                                            OUT PULONG64 StoreLimit)
{
    return E_NOTIMPL;
}

HRESULT
WinCeWin32LiveSystemProvider::GetPeb(IN HANDLE Process,
                                     OUT PULONG64 Offset,
                                     OUT PULONG Size)
{
    // WinCE doesn't have a PEB.
    *Offset = 0;
    *Size = 0;
    return S_OK;
}

Win32LiveSystemProvider*
NewWinCeWin32LiveSystemProvider(ULONG BuildNumber)
{
    return new WinCeWin32LiveSystemProvider(BuildNumber);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\sources.inc ===
INCLUDES = ..\..\dbg-common;..

USE_LIBCMT=1
NO_NTDLL=1

PRECOMPILED_INCLUDE = ..\pch.cpp

SOURCES=\
    ..\gen.cpp     \
    ..\imagedir.cpp\
    ..\minidump.cpp\
    ..\prov_unt.cpp\
    ..\prov_w32.cpp\
    ..\prov_w9x.cpp\
    ..\prov_wce.cpp\
    ..\minidump.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\prov_knt.cpp ===
/*++

Copyright(c) 1999-2002 Microsoft Corporation

--*/


#include "pch.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\prov_w9x.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Algorithm:

    Unfortunately, implementing OpenThread cannot be done in a simple
    manner. What follows is a very system dependent hack. If the structure
    of the TDB or the implementation of OpenProcess change very much, this
    function will break.

    To have any idea of what we are doing here, you should be familiar with
    Win9x internals. If you are not familiar with the Win9x source, consult
    the book "Windows 95 System Programming SECRETS" by Matt Pietrek. Things
    are not exactly the same for Win98 -- but pretty close.

    OpenThread is a very simple function. If we were compiled withing the
    Win9x source code base, the code would be simple:

    OpenThread:

            pObj = TidToTDB (dwThreadId);

            return AllocHandle (GetCurrentPdb(), pObj, Flags);

    Since we are not, the challenge is implementing the functions TidToTDB()
    and AllocHandle().

    Our approach is as follows:

        1) We reverse-engineer TidToTDB since it is simple. TidToTDB is just
           the thread-id xor'd with the Win9x Obfuscator.

        2) We search through the code of OpenProcess until we find the address
           of AllocHandle. We use this to allocate new handles in the
           process's handle database.

        3) OpenThread is then implemented in terms of the above primitives.

Author:

    Matthew D Hendel (math) 01-Sept-1999

--*/


#include "pch.cpp"

//
// Win9x support is x86-only.
//

#ifdef _X86_

typedef struct _MATCH_BUFFER {
    ULONG Offset;
    BYTE Byte;
} MATCH_BUFFER, *PMATCH_BUFFER;

typedef struct _OS_INFORMATION {
    PMATCH_BUFFER MatchBuffer;
    ULONG AllocHandleOffset;
} OS_INFORMATION, POS_INFORMATION;


/*++

Operating System:

    Win95

Description:

    This is the disasm of the OpenProcess routine on Win95. We attempt to
    match this routine and pull out the value for AllocHandle from the code
    for this routine. In this case, AllocHande is called by the third call in
    this function.

    The instructions marked by '*' are those we use for matching.

OpenProcess:

    * BFF9404C: FF 74 24 0C        push        dword ptr [esp+0Ch]
    * BFF94050: E8 2D 87 FE FF     call        BFF7C782
      BFF94055: 85 C0              test        eax,eax
      BFF94057: 75 04              jne         BFF9405D
      BFF94059: 33 C0              xor         eax,eax
      BFF9405B: EB 56              jmp         BFF940B3
      BFF9405D: 83 38 05           cmp         dword ptr [eax],5
      BFF94060: 74 0E              je          BFF94070
      BFF94062: 6A 57              push        57h
    * BFF94064: E8 BC 68 FE FF     call        BFF7A925
      BFF94069: B9 FF FF FF FF     mov         ecx,0FFFFFFFFh
      BFF9406E: EB 33              jmp         BFF940A3
      BFF94070: B9 00 00 00 00     mov         ecx,0
      BFF94075: 8B 54 24 04        mov         edx,dword ptr [esp+4]
      BFF94079: 83 7C 24 08 01     cmp         dword ptr [esp+8],1
      BFF9407E: 83 D1 FF           adc         ecx,0FFFFFFFFh
      BFF94081: 81 E2 BF FF 1F 00  and         edx,1FFFBFh
      BFF94087: 81 E1 00 00 00 80  and         ecx,80000000h
      BFF9408D: 0B CA              or          ecx,edx
      BFF9408F: 8B 15 7C C2 FB BF  mov         edx,dword ptr ds:[BFFBC27Ch]
      BFF94095: 80 C9 40           or          cl,40h
      BFF94098: 51                 push        ecx
      BFF94099: 50                 push        eax
      BFF9409A: FF 32              push        dword ptr [edx]
    * BFF9409C: E8 6E 76 FE FF     call        BFF7B70F
      BFF940A1: 8B C8              mov         ecx,eax
      BFF940A3: 8D 41 01           lea         eax,[ecx+1]
      BFF940A6: 83 F8 01           cmp         eax,1
      BFF940A9: B8 00 00 00 00     mov         eax,0
      BFF940AE: 83 D0 FF           adc         eax,0FFFFFFFFh
      BFF940B1: 23 C1              and         eax,ecx
      BFF940B3: C2 0C 00           ret         0Ch

--*/

MATCH_BUFFER Win95AllocHandleMatch [] = {

    //
    // ret 0x0C at offset 103
    //

    { 103, 0xC2 },
    { 104, 0x0C },
    { 105, 0x00 },

    //
    // push dword ptr [exp 0x0C] at offset 0
    //

    { 0, 0xFF },
    { 1, 0x74 },
    { 2, 0x24 },
    { 3, 0x0C },

    //
    // call at offset 4
    //

    { 4, 0xE8 },

    //
    // call     at offset 24
    //

    { 24, 0xE8 },

    //
    // call at offset 80
    //

    { 80, 0xE8 },

    //
    // End of match list.
    //

    { -1, -1 }
};


/*++

Operating system:

    Win98

Description:

    See comments above regarding OpenProcess.

OpenProcess:

    * BFF95C4D: FF 74 24 0C        push        dword ptr [esp+0Ch]
    * BFF95C51: E8 C9 8E FE FF     call        BFF7EB1F
      BFF95C56: 85 C0              test        eax,eax
      BFF95C58: 75 04              jne         BFF95C5E
      BFF95C5A: 33 C0              xor         eax,eax
      BFF95C5C: EB 53              jmp         BFF95CB1
      BFF95C5E: 80 38 06           cmp         byte ptr [eax],6
      BFF95C61: 74 0E              je          BFF95C71
      BFF95C63: 6A 57              push        57h
    * BFF95C65: E8 27 6D FE FF     call        BFF7C991
      BFF95C6A: B9 FF FF FF FF     mov         ecx,0FFFFFFFFh
      BFF95C6F: EB 30              jmp         BFF95CA1
      BFF95C71: B9 00 00 00 00     mov         ecx,0
      BFF95C76: 8B 54 24 04        mov         edx,dword ptr [esp+4]
      BFF95C7A: 83 7C 24 08 01     cmp         dword ptr [esp+8],1
      BFF95C7F: 83 D1 FF           adc         ecx,0FFFFFFFFh
      BFF95C82: 81 E2 FF 0F 1F 00  and         edx,1F0FFFh
      BFF95C88: 81 E1 00 00 00 80  and         ecx,80000000h
      BFF95C8E: 0B CA              or          ecx,edx
      BFF95C90: 8B 15 DC 9C FC BF  mov         edx,dword ptr ds:[BFFC9CDCh]
      BFF95C96: 51                 push        ecx
      BFF95C97: 50                 push        eax
      BFF95C98: FF 32              push        dword ptr [edx]
    * BFF95C9A: E8 5A 7E FE FF     call        BFF7DAF9
      BFF95C9F: 8B C8              mov         ecx,eax
      BFF95CA1: 8D 41 01           lea         eax,[ecx+1]
      BFF95CA4: 83 F8 01           cmp         eax,1
      BFF95CA7: B8 00 00 00 00     mov         eax,0
      BFF95CAC: 83 D0 FF           adc         eax,0FFFFFFFFh
      BFF95CAF: 23 C1              and         eax,ecx
    * BFF95CB1: C2 0C 00           ret         0Ch

--*/

MATCH_BUFFER Win98AllocHandleMatch [] = {

    //
    // ret 0x0C at offset 100
    //

    { 100, 0xC2 },
    { 101, 0x0C },
    { 102, 0x00 },

    //
    // push dword ptr [exp 0x0C] at offset 0
    //

    { 0, 0xFF },
    { 1, 0x74 },
    { 2, 0x24 },
    { 3, 0x0C },

    //
    // call at offset 4
    //

    { 4, 0xE8 },

    //
    // call     at offset 24
    //

    { 24, 0xE8 },

    //
    // call at offset 77
    //

    { 77, 0xE8 },

    //
    // End of match list.
    //

    { -1, -1 }
};


OS_INFORMATION SupportedSystems [] =
{
    { Win95AllocHandleMatch, 81 },
    { Win98AllocHandleMatch, 78 }
};

typedef
HANDLE
(__stdcall * ALLOC_HANDLE_ROUTINE) (
    PVOID Pdb,
    PVOID Obj,
    DWORD Flags
    );

//
// Global variables
//

ALLOC_HANDLE_ROUTINE WinpAllocHandle = NULL;
DWORD WinpObfuscator = 0;


#pragma warning (disable:4035)

//
// OffsetTib is NOT dependent on the OS. The compiler uses this value.
//

#define OffsetTib 0x18

_inline
PVOID
WinpGetCurrentTib(
    )
{
    __asm mov eax, fs:[OffsetTib]
}

#pragma warning (default:4035)


BOOL
WinpGetAllocHandleFromStream(
    IN PBYTE Buffer,
    IN PVOID BaseOfBuffer,
    IN PMATCH_BUFFER MatchBuffer,
    IN ULONG Offset,
    IN ULONG * Val
    )

/*++

Routine Description:

    Find the address of the AllocHandle routine. This is done by searching
    through the code of the OpenProcess routine, looking for the third
    call instruction in that function. The third call calls AllocHandle().

Arguments:

    Buffer - Buffer of instructions to search through.

    BaseOfBuffer - The base address of the buffer.

    MatchBuffer - The match buffer to compare against.

    Offset - The offset of call destination.

    Val - A buffer to return the value of AllocHandle.


Return Values:

    TRUE - Success.

    FALSE - Failure.

--*/


{
    UINT i;

    for (i = 0; MatchBuffer [i].Offset != -1; i++) {

        if (Buffer [MatchBuffer[i].Offset] != MatchBuffer[i].Byte) {
            return FALSE;
        }
    }

    //
    // This assumes that the call instruction is a near, relative call (E8).
    // If this is not the case, the calculation below is incorrect.
    //
    // The calculation gives us the destination relative to the next
    // instruction after the call.
    //

    *Val = (ULONG) BaseOfBuffer + Offset + *(PLONG) &Buffer [Offset] + 4;

    return TRUE;
}



ULONG
WinGetModuleSize(
    PVOID Base
    )

/*++

Routine Description:

    Get the SizeOfImage field given the base address of a module.

Return Values:

    SizeOfImage field of the specified module on success.

    NULL on failure.

--*/

{
    ULONG Size;
    PIMAGE_NT_HEADERS NtHeaders;

    NtHeaders = GenImageNtHeader ( Base, NULL );
    if ( NtHeaders ) {
        Size = NtHeaders->OptionalHeader.SizeOfImage;
    } else {
        Size = 0;
    }

    return Size;
}


BOOL
WinpInitAllocHandle (
    )

/*++

Routine Description:

    Initialize the global variable WxAllocHandle to the value of the Win9x
    internal routine, AllocHandle.

Arguments:

    None

Return Values:

    TRUE - If we were able to successfully obtain a pointer to AllocHandle.

    FALSE - Otherwise.

Comments:

    The client of this routine should verify that this handle is correct by
    calling WxCheckOpenThread() before blindly assuming the pointer is
    correct.

--*/

{
    ULONG i;
    BOOL Succ;
    PVOID OpenProcessPtr;
    ULONG Kernel32Base;
    ULONG Kernel32Size;
    ULONG AllocHandle;
    BYTE Buffer [ 200 ];

    if ( WinpAllocHandle ) {
        return TRUE;
    }

    Kernel32Base = (ULONG) GetModuleHandle ( "kernel32.dll" );
    ASSERT ( Kernel32Base );
    if (!Kernel32Base)
    {
        return FALSE;
    }

    Kernel32Size = WinGetModuleSize ( (PVOID) Kernel32Base );
    ASSERT ( Kernel32Size != 0 );

    OpenProcessPtr = GetProcAddress (
                            (HINSTANCE) Kernel32Base,
                            "OpenProcess"
                            );
    if (!OpenProcessPtr)
    {
        return FALSE;
    }


    //
    // Win9x thunks out functions when a debugger is present. To work around
    // this we undo the thunk when it looks like its been thunked.
    //

    if ( (ULONG) OpenProcessPtr < Kernel32Base ||
         (ULONG) OpenProcessPtr > Kernel32Base + Kernel32Size ) {

        OpenProcessPtr = (PVOID) *(PULONG)( (PBYTE)OpenProcessPtr + 1 );
    }

    if ( (ULONG) OpenProcessPtr < Kernel32Base ||
         (ULONG) OpenProcessPtr > Kernel32Base + Kernel32Size ) {

        return FALSE;
    }


    CopyMemory (Buffer, OpenProcessPtr, sizeof (Buffer));

    //
    // Check the buffer
    //

    for ( i = 0; i < ARRAY_COUNT (SupportedSystems); i++) {

        Succ = WinpGetAllocHandleFromStream (
                            Buffer,
                            OpenProcessPtr,
                            SupportedSystems[i].MatchBuffer,
                            SupportedSystems[i].AllocHandleOffset,
                            &AllocHandle
                            );

        if ( Succ ) {

            //
            // Verify WinpAllocHandle within range of Kernel32.
            //

            if (AllocHandle > Kernel32Base &&
                AllocHandle < Kernel32Base + Kernel32Size) {

                WinpAllocHandle = (ALLOC_HANDLE_ROUTINE) AllocHandle;
                break;
            }
        }
    }

    if ( !Succ ) {
        WinpAllocHandle = NULL;
    }

    return Succ;
}


//
// This value is basically FIELD_OFFSET (TDB, Tib). It is dependent on the
// specific version of the OS (95, 98).
//

#define WIN95_TDB_OFFSET    (0x10)
#define WIN98_TDB_OFFSET    (0x08)

DWORD
WinpGetObfuscator(
    IN BOOL Win95
    )

/*++

Routine Description:

    Get the Obfuscator DWORD.

Arguments:

    None.

Return Values:

    The Obfuscator or 0 on failure.

Comments:

    This routine depends on internal structures from the Win9x sources. If
    another major revision of windows changes many of these structures, this
    function may break.

--*/

{
    ULONG Tib;
    ULONG Type;
    ULONG Major;


    if (WinpObfuscator != 0) {
        return WinpObfuscator;
    }

    Tib = (DWORD)WinpGetCurrentTib ();

    if ( Win95 ) {

        WinpObfuscator = (GetCurrentThreadId () ^ (Tib - WIN95_TDB_OFFSET));

    } else {

        //
        // If a windows-based system that is not 95 or 98 comes along,
        // we should make sure the WINxx_TDB_OFFSET is correct.
        //

        WinpObfuscator = (GetCurrentThreadId () ^ (Tib - WIN98_TDB_OFFSET));
    }

    return WinpObfuscator;
}


LPVOID
WinpTidToTDB(
    IN BOOL Win95,
    IN DWORD ThreadId
    )
{
    return (PVOID) (ThreadId ^ WinpGetObfuscator (Win95));
}

LPVOID
WinpGetCurrentPdb(
    IN BOOL Win95
    )
{
    return (LPVOID) (GetCurrentProcessId () ^ WinpGetObfuscator (Win95));
}

HANDLE
WinpOpenThreadInternal(
    BOOL Win95,
    DWORD dwAccess,
    BOOL bInheritHandle,
    DWORD ThreadId
    )
{
    HANDLE hThread;
    PVOID ThreadObj;

    ASSERT (WinpAllocHandle);

    //
    // Convert the ThreadId to a Thread Object
    //

    ThreadObj = WinpTidToTDB (Win95, ThreadId);

    if (ThreadObj == NULL) {
        return NULL;
    }

    //
    // NB: we do not check that the handle really is a thread handle.
    // The type varies from version to version of the OS, so it is not
    // correct to check it.
    //

    __try {

        hThread = WinpAllocHandle (
                            WinpGetCurrentPdb (Win95),
                            ThreadObj,
                            dwAccess
                            );
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        hThread = NULL;
    }

    if (hThread == (HANDLE) (-1)) {
        hThread = NULL;
    }

    return hThread;
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
WINAPI
WinpCheckThread(
    PVOID unused
    )
{
    for (;;) {
    }

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif



BOOL
WinpCheckOpenThread(
    IN BOOL Win95
    )

/*++

Routine Description:

    Check that WxOpenThread actually works.

Return Values:

    TRUE - If WxOpenThread works properly.

    FALSE - Otherwise.

--*/

{

    BOOL Succ;
    HANDLE hThread1;
    HANDLE hThread2;
    DWORD ThreadId;
    CONTEXT Context1;
    CONTEXT Context2;
    LONG SuspendCount;


    SuspendCount = 0;
    hThread1 = NULL;
    hThread2 = NULL;


    hThread1 = CreateThread (NULL,
                      0,
                      WinpCheckThread,
                      0,
                      0,
                      &ThreadId
                      );

    if ( hThread1 == NULL ) {
        return FALSE;
    }

    hThread2 = WinpOpenThreadInternal (
                        Win95,
                        THREAD_ALL_ACCESS,
                        FALSE,
                        ThreadId
                        );

    if ( hThread2 == NULL ) {
        Succ = FALSE;
        goto Exit;
    }

    Succ = TRUE;
    __try {

        //
        // First we check that we can suspend the thread. If that is
        // successful, then get the context using the read thread
        // handle and the newly opened thread handle and check that
        // they are the same.
        //

        SuspendCount = SuspendThread ( hThread2 );

        if ( SuspendCount == -1 ) {
            Succ = FALSE;
            __leave;
        }

        Context1.ContextFlags = CONTEXT_FULL;
        Succ = GetThreadContext ( hThread2, &Context1 );

        if ( !Succ ) {
            __leave;
        }

        Context2.ContextFlags = CONTEXT_FULL;
        Succ = GetThreadContext ( hThread1, &Context2 );

        if ( !Succ ) {
            __leave;
        }

        if ( Context1.Eip != Context2.Eip ) {
            Succ = FALSE;
            __leave;
        }
    }

    __except ( EXCEPTION_EXECUTE_HANDLER ) {

        Succ = FALSE;
    }

Exit:

    if ( SuspendCount > 0 ) {
        ResumeThread ( hThread2 );
    }

    TerminateThread ( hThread1, 0xDEAD );

    if ( hThread1 ) {
        ::CloseHandle ( hThread1 );
    }

    if ( hThread2 ) {
        ::CloseHandle ( hThread2 );
    }

    return Succ;
}


BOOL
WinInitialize(
    IN BOOL Win95
    )
{
    if ( WinpAllocHandle == NULL ) {

        if (!WinpInitAllocHandle ()) {
            SetLastError (ERROR_NOT_SUPPORTED);
            return FALSE;
        }

        if (!WinpCheckOpenThread (Win95)) {
            SetLastError (ERROR_NOT_SUPPORTED);
            return FALSE;
        }
    }

    return TRUE;

}

VOID
WinFree(
    )
{
    WinpAllocHandle = NULL;
    WinpObfuscator = 0;

}

HANDLE
WINAPI
WinOpenThread(
    BOOL Win95,
    DWORD dwAccess,
    BOOL bInheritHandle,
    DWORD ThreadId
    )

/*++

Routine Description:

    Obtain a thread handle from a thread id on Win9x platform.x

Arguments:

    dwAccess - Thread access requested.

    bInheritHandle - ALWAYS IGNORED.

    ThreadId - The identifier of the thread for which a handle is to
            be returned.

Return Values:

    A handle to the open thread on success or NULL on failure.

--*/

{
    HANDLE Handle;

    //
    // It is necessary to call WinInitialize() before calling this function.
    // If this was not called, return failure.
    //

    if ( WinpAllocHandle == NULL ) {

        SetLastError ( ERROR_DLL_INIT_FAILED );
        return FALSE;
    }

    Handle = WinpOpenThreadInternal (
                    Win95,
                    dwAccess,
                    bInheritHandle,
                    ThreadId
                    );

    return Handle;
}

//----------------------------------------------------------------------------
//
// Win9xWin32LiveSystemProvider.
//
//----------------------------------------------------------------------------

class Win9xWin32LiveSystemProvider : public Win32LiveSystemProvider
{
public:
    Win9xWin32LiveSystemProvider(ULONG BuildNumber);
    ~Win9xWin32LiveSystemProvider(void);

    virtual void Release(void);
    virtual HRESULT OpenThread(IN ULONG DesiredAccess,
                               IN BOOL InheritHandle,
                               IN ULONG ThreadId,
                               OUT PHANDLE Handle);
    virtual HRESULT GetTeb(IN HANDLE Thread,
                           OUT PULONG64 Offset,
                           OUT PULONG Size);
    virtual HRESULT GetThreadInfo(IN HANDLE Process,
                                  IN HANDLE Thread,
                                  OUT PULONG64 Teb,
                                  OUT PULONG SizeOfTeb,
                                  OUT PULONG64 StackBase,
                                  OUT PULONG64 StackLimit,
                                  OUT PULONG64 StoreBase,
                                  OUT PULONG64 StoreLimit);
    virtual HRESULT GetPeb(IN HANDLE Process,
                           OUT PULONG64 Offset,
                           OUT PULONG Size);

protected:
    BOOL m_WinInit;
};

Win9xWin32LiveSystemProvider::Win9xWin32LiveSystemProvider(ULONG BuildNumber)
    : Win32LiveSystemProvider(VER_PLATFORM_WIN32_WINDOWS, BuildNumber)
{
    m_WinInit = FALSE;
}

Win9xWin32LiveSystemProvider::~Win9xWin32LiveSystemProvider(void)
{
    if (m_WinInit) {
        WinFree();
    }
}

void
Win9xWin32LiveSystemProvider::Release(void)
{
    delete this;
}

HRESULT
Win9xWin32LiveSystemProvider::OpenThread(IN ULONG DesiredAccess,
                                         IN BOOL InheritHandle,
                                         IN ULONG ThreadId,
                                         OUT PHANDLE Handle)
{
    BOOL Win95;
    
    if (m_OpenThread) {
        // OS supports regular Win32 OpenThread, so try it.
        *Handle = m_OpenThread(DesiredAccess, InheritHandle, ThreadId);
        if (*Handle) {
            return S_OK;
        }
    }

    Win95 = m_BuildNumber < 1998;
    
    if (!m_WinInit) {
        m_WinInit = WinInitialize(Win95);
        if (!m_WinInit) {
            return E_FAIL;
        }
    }

    *Handle = WinOpenThread(Win95, DesiredAccess, InheritHandle, ThreadId);
    return *Handle ? S_OK : E_FAIL;
}

HRESULT
Win9xWin32LiveSystemProvider::GetTeb(IN HANDLE Thread,
                                     OUT PULONG64 Offset,
                                     OUT PULONG Size)
{
    BOOL Succ;
    ULONG Addr;
    LDT_ENTRY Ldt;
    CONTEXT Context;

    Context.ContextFlags = CONTEXT_SEGMENTS;

    Succ = ::GetThreadContext (Thread, &Context);
    if ( !Succ ) {
        return WIN32_LAST_STATUS();
    }

    Succ = GetThreadSelectorEntry (Thread,
                                   Context.SegFs,
                                   &Ldt);
    if ( !Succ ) {
        return WIN32_LAST_STATUS();
    }

    Addr = (Ldt.HighWord.Bytes.BaseHi << 24) |
        (Ldt.HighWord.Bytes.BaseMid << 16) |
        (Ldt.BaseLow);

    *Offset = (LONG_PTR)Addr;
    *Size = sizeof(NT_TIB);
    return S_OK;
}

HRESULT
Win9xWin32LiveSystemProvider::GetThreadInfo(IN HANDLE Process,
                                            IN HANDLE Thread,
                                            OUT PULONG64 Teb,
                                            OUT PULONG SizeOfTeb,
                                            OUT PULONG64 StackBase,
                                            OUT PULONG64 StackLimit,
                                            OUT PULONG64 StoreBase,
                                            OUT PULONG64 StoreLimit)
{
    HRESULT Status;

    if ((Status = GetTeb(Thread, Teb, SizeOfTeb)) != S_OK) {
        return Status;
    }

    return TibGetThreadInfo(Process, *Teb,
                            StackBase, StackLimit,
                            StoreBase, StoreLimit);
}

HRESULT
Win9xWin32LiveSystemProvider::GetPeb(IN HANDLE Process,
                                     OUT PULONG64 Offset,
                                     OUT PULONG Size)
{
    // Win9x doesn't have a PEB.
    *Offset = 0;
    *Size = 0;
    return S_OK;
}

Win32LiveSystemProvider*
NewWin9xWin32LiveSystemProvider(ULONG BuildNumber)
{
    // Win9x keeps the build number in the low 16 bits.
    return new Win9xWin32LiveSystemProvider(BuildNumber & 0xffff);
}

#else // #ifdef _X86_

Win32LiveSystemProvider*
NewWin9xWin32LiveSystemProvider(ULONG BuildNumber)
{
    return NULL;
}

#endif // #ifdef _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\prov_w32.cpp ===
/*++

Copyright(c) 1999-2002 Microsoft Corporation

--*/


#include "pch.cpp"

#include "platform.h"

//----------------------------------------------------------------------------
//
// Win32LiveSystemProvider.
//
//----------------------------------------------------------------------------

Win32LiveSystemProvider::Win32LiveSystemProvider(ULONG PlatformId,
                                                 ULONG BuildNumber)
{
    m_PlatformId = PlatformId;
    m_BuildNumber = BuildNumber;
    
    m_PsApi = NULL;
    m_EnumProcessModules = NULL;
    m_GetModuleFileNameExW = NULL;
    
    m_Kernel32 = NULL;
    m_OpenThread = NULL;
    m_Thread32First = NULL;
    m_Thread32Next = NULL;
    m_Module32First = NULL;
    m_Module32Next = NULL;
    m_Module32FirstW = NULL;
    m_Module32NextW = NULL;
    m_CreateToolhelp32Snapshot = NULL;
    m_GetLongPathNameA = NULL;
    m_GetLongPathNameW = NULL;
    m_GetProcessTimes = NULL;
}

Win32LiveSystemProvider::~Win32LiveSystemProvider(void)
{
    if (m_PsApi) {
        FreeLibrary(m_PsApi);
    }
    if (m_Kernel32) {
        FreeLibrary(m_Kernel32);
    }
}

HRESULT
Win32LiveSystemProvider::Initialize(void)
{
    m_PsApi = LoadLibrary("psapi.dll");
    if (m_PsApi) {
        m_EnumProcessModules = (ENUM_PROCESS_MODULES)
            GetProcAddress(m_PsApi, "EnumProcessModules");
        m_GetModuleFileNameExW = (GET_MODULE_FILE_NAME_EX_W)
            GetProcAddress(m_PsApi, "GetModuleFileNameExW");
    }
    
    m_Kernel32 = LoadLibrary("kernel32.dll");
    if (m_Kernel32) {
        m_OpenThread = (OPEN_THREAD)
            GetProcAddress(m_Kernel32, "OpenThread");
        m_Thread32First = (THREAD32_FIRST)
            GetProcAddress(m_Kernel32, "Thread32First");
        m_Thread32Next = (THREAD32_NEXT)
            GetProcAddress(m_Kernel32, "Thread32Next");
        m_Module32First = (MODULE32_FIRST)
            GetProcAddress(m_Kernel32, "Module32First");
        m_Module32Next = (MODULE32_NEXT)
            GetProcAddress(m_Kernel32, "Module32Next");
        m_Module32FirstW = (MODULE32_FIRST)
            GetProcAddress(m_Kernel32, "Module32FirstW");
        m_Module32NextW = (MODULE32_NEXT)
            GetProcAddress(m_Kernel32, "Module32NextW");
        m_CreateToolhelp32Snapshot = (CREATE_TOOLHELP32_SNAPSHOT)
            GetProcAddress(m_Kernel32, "CreateToolhelp32Snapshot");
        m_GetLongPathNameA = (GET_LONG_PATH_NAME_A)
            GetProcAddress(m_Kernel32, "GetLongPathNameA");
        m_GetLongPathNameW = (GET_LONG_PATH_NAME_W)
            GetProcAddress(m_Kernel32, "GetLongPathNameW");
        m_GetProcessTimes = (GET_PROCESS_TIMES)
            GetProcAddress(m_Kernel32, "GetProcessTimes");
    }
    
    return S_OK;
}

void
Win32LiveSystemProvider::Release(void)
{
    delete this;
}

HRESULT
Win32LiveSystemProvider::GetCurrentTimeDate(OUT PULONG TimeDate)
{
    FILETIME FileTime;
       
    GetSystemTimeAsFileTime(&FileTime);
    *TimeDate = FileTimeToTimeDate(&FileTime);
    return S_OK;
}

HRESULT
Win32LiveSystemProvider::GetCpuType(OUT PULONG Type,
                                    OUT PBOOL BackingStore)
{
    SYSTEM_INFO SysInfo;
    
    GetSystemInfo(&SysInfo);
    *Type = GenProcArchToImageMachine(SysInfo.wProcessorArchitecture);
    if (*Type == IMAGE_FILE_MACHINE_UNKNOWN) {
        return E_INVALIDARG;
    }

#ifdef DUMP_BACKING_STORE
    *BackingStore = TRUE;
#else
    *BackingStore = FALSE;
#endif
    
    return S_OK;
}

#if defined(i386)

BOOL
X86CpuId(
    IN ULONG32 SubFunction,
    OUT PULONG32 EaxRegister, OPTIONAL
    OUT PULONG32 EbxRegister, OPTIONAL
    OUT PULONG32 EcxRegister, OPTIONAL
    OUT PULONG32 EdxRegister  OPTIONAL
    )
{
    BOOL Succ;
    ULONG32 _Eax;
    ULONG32 _Ebx;
    ULONG32 _Ecx;
    ULONG32 _Edx;

    __try {
        __asm {
            mov eax, SubFunction

            __emit 0x0F
            __emit 0xA2  ;; CPUID

            mov _Eax, eax
            mov _Ebx, ebx
            mov _Ecx, ecx
            mov _Edx, edx
        }

        if ( EaxRegister ) {
            *EaxRegister = _Eax;
        }

        if ( EbxRegister ) {
            *EbxRegister = _Ebx;
        }

        if ( EcxRegister ) {
            *EcxRegister = _Ecx;
        }

        if ( EdxRegister ) {
            *EdxRegister = _Edx;
        }

        Succ = TRUE;
    }

    __except ( EXCEPTION_EXECUTE_HANDLER ) {

        Succ = FALSE;
    }

    return Succ;
}

VOID
GetCpuInformation(
    PCPU_INFORMATION Cpu
    )
{
    BOOL Succ;

    //
    // Get the VendorID
    //

    Succ = X86CpuId ( CPUID_VENDOR_ID,
                      NULL,
                      &Cpu->X86CpuInfo.VendorId [0],
                      &Cpu->X86CpuInfo.VendorId [2],
                      &Cpu->X86CpuInfo.VendorId [1]
                      );

    if ( !Succ ) {

        //
        // CPUID is not supported on this processor.
        //

        ZeroMemory (&Cpu->X86CpuInfo, sizeof (Cpu->X86CpuInfo));
    }

    //
    // Get the feature information.
    //

    Succ = X86CpuId ( CPUID_VERSION_FEATURES,
                      &Cpu->X86CpuInfo.VersionInformation,
                      NULL,
                      NULL,
                      &Cpu->X86CpuInfo.FeatureInformation
                      );

    if ( !Succ ) {
        Cpu->X86CpuInfo.VersionInformation = 0;
        Cpu->X86CpuInfo.FeatureInformation = 0;
    }

    //
    // Get the AMD specific information if this is an AMD processor.
    //

    if ( Cpu->X86CpuInfo.VendorId [0] == AMD_VENDOR_ID_0 &&
         Cpu->X86CpuInfo.VendorId [1] == AMD_VENDOR_ID_1 &&
         Cpu->X86CpuInfo.VendorId [2] == AMD_VENDOR_ID_2 ) {

        Succ = X86CpuId ( CPUID_AMD_EXTENDED_FEATURES,
                          NULL,
                          NULL,
                          NULL,
                          &Cpu->X86CpuInfo.AMDExtendedCpuFeatures
                          );

        if ( !Succ ) {
            Cpu->X86CpuInfo.AMDExtendedCpuFeatures = 0;
        }
    }
}

#else // #if defined(i386)

VOID
GetCpuInformation(
    PCPU_INFORMATION Cpu
    )

/*++

Routine Description:

    Get CPU information for non-X86 platform using the
    IsProcessorFeaturePresent() API call.

Arguments:

    Cpu - A buffer where the processor feature information will be copied.
        Note: we copy the processor features as a set of bits or'd together.
        Also, we only allow for the first 128 processor feature flags.

Return Value:

    None.

--*/

{
    ULONG i;
    DWORD j;

    for (i = 0; i < ARRAY_COUNT (Cpu->OtherCpuInfo.ProcessorFeatures); i++) {

        Cpu->OtherCpuInfo.ProcessorFeatures[i] = 0;
        for (j = 0; j < 64; j++) {
            if (IsProcessorFeaturePresent ( j + i * 64 )) {
                Cpu->OtherCpuInfo.ProcessorFeatures[i] |= 1 << j;
            }
        }
    }
}

#endif // #if defined(i386)

HRESULT
Win32LiveSystemProvider::GetCpuInfo(OUT PUSHORT Architecture,
                                    OUT PUSHORT Level,
                                    OUT PUSHORT Revision,
                                    OUT PUCHAR NumberOfProcessors,
                                    OUT PCPU_INFORMATION Info)
{
    SYSTEM_INFO SysInfo;
    
    GetSystemInfo(&SysInfo);

    *Architecture = SysInfo.wProcessorArchitecture;
    *Level = SysInfo.wProcessorLevel;
    *Revision = SysInfo.wProcessorRevision;
    *NumberOfProcessors = (UCHAR)SysInfo.dwNumberOfProcessors;
    GetCpuInformation(Info);

    return S_OK;
}

void
Win32LiveSystemProvider::GetContextSizes(OUT PULONG Size,
                                         OUT PULONG RegScanOffset,
                                         OUT PULONG RegScanCount)
{
    *Size = sizeof(CONTEXT);
    
#ifdef _X86_
    // X86 has two sizes of context.
    switch(m_PlatformId) {
    case VER_PLATFORM_WIN32_NT:
        if (m_BuildNumber < NT_BUILD_WIN2K) {
            *Size = FIELD_OFFSET(CONTEXT, ExtendedRegisters);
        }
        break;
    case VER_PLATFORM_WIN32_WINDOWS:
        if (m_BuildNumber <= 1998) {
            *Size = FIELD_OFFSET(CONTEXT, ExtendedRegisters);
        }
        break;
    default:
        *Size = FIELD_OFFSET(CONTEXT, ExtendedRegisters);
        break;
    }
#endif

    // Default reg scan.
    *RegScanOffset = -1;
    *RegScanCount = -1;
}

void
Win32LiveSystemProvider::GetPointerSize(OUT PULONG Size)
{
    *Size = sizeof(PVOID);
}

void
Win32LiveSystemProvider::GetPageSize(OUT PULONG Size)
{
    *Size = PAGE_SIZE;
}

void
Win32LiveSystemProvider::GetFunctionTableSizes(OUT PULONG TableSize,
                                               OUT PULONG EntrySize)
{
#if defined(_IA64_) || defined(_AMD64_)
    *TableSize = sizeof(DYNAMIC_FUNCTION_TABLE);
    *EntrySize = sizeof(RUNTIME_FUNCTION);
#else
    *TableSize = 0;
    *EntrySize = 0;
#endif
}

void
Win32LiveSystemProvider::GetInstructionWindowSize(OUT PULONG Size)
{
    // Default window.
    *Size = -1;
}

HRESULT
Win32LiveSystemProvider::GetOsInfo(OUT PULONG PlatformId,
                                   OUT PULONG Major,
                                   OUT PULONG Minor,
                                   OUT PULONG BuildNumber,
                                   OUT PUSHORT ProductType,
                                   OUT PUSHORT SuiteMask)
{
    OSVERSIONINFOEXA OsInfo;

    // Try first with the EX struct.
    OsInfo.dwOSVersionInfoSize = sizeof(OsInfo);

    if (!GetVersionExA((LPOSVERSIONINFO)&OsInfo)) {
        // EX struct didn't work, try with the basic struct.
        ZeroMemory(&OsInfo, sizeof(OsInfo));
        OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        if (!GetVersionExA((LPOSVERSIONINFO)&OsInfo)) {
            return WIN32_LAST_STATUS();
        }
    }

    *PlatformId = OsInfo.dwPlatformId;
    *Major = OsInfo.dwMajorVersion;
    *Minor = OsInfo.dwMinorVersion;
    *BuildNumber = OsInfo.dwBuildNumber;
    *ProductType = OsInfo.wProductType;
    *SuiteMask = OsInfo.wSuiteMask;

    return S_OK;
}

HRESULT
Win32LiveSystemProvider::GetOsCsdString(OUT PWSTR Buffer,
                                        IN ULONG BufferChars)
{
    OSVERSIONINFOW OsInfoW;

    // Try first with the Unicode struct.
    OsInfoW.dwOSVersionInfoSize = sizeof(OsInfoW);
    if (GetVersionExW(&OsInfoW)) {
        // Got it.
        GenStrCopyNW(Buffer, OsInfoW.szCSDVersion, BufferChars);
        return S_OK;
    }
    
    OSVERSIONINFOA OsInfoA;
        
    // Unicode struct didn't work, try with the ANSI struct.
    OsInfoA.dwOSVersionInfoSize = sizeof(OsInfoA);
    if (!GetVersionExA(&OsInfoA)) {
        return WIN32_LAST_STATUS();
    }
        
    if (!MultiByteToWideChar(CP_ACP,
                             0,
                             OsInfoA.szCSDVersion,
                             -1,
                             Buffer,
                             BufferChars)) {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

HRESULT
Win32LiveSystemProvider::OpenMapping(IN PCWSTR FilePath,
                                     OUT PULONG Size,
                                     OUT PWSTR LongPath,
                                     IN ULONG LongPathChars,
                                     OUT PVOID* ViewRet)
{
    HRESULT Status;
    HANDLE File;
    HANDLE Mapping;
    PVOID View;
    DWORD Chars;

    //
    // The module may be loaded with a short name.  Open
    // the mapping with the name given, but also determine
    // the long name if possible.  This is done here as
    // the ANSI/Unicode issues are already being handled here.
    //

    File = CreateFileW(FilePath,
                       GENERIC_READ,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);
    if ( File == NULL || File == INVALID_HANDLE_VALUE ) {

        if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED) {

            // We're on an OS that doesn't support Unicode
            // file operations.  Convert to ANSI and see if
            // that helps.
            
            CHAR FilePathA [ MAX_PATH + 10 ];

            if (WideCharToMultiByte (CP_ACP,
                                     0,
                                     FilePath,
                                     -1,
                                     FilePathA,
                                     sizeof (FilePathA),
                                     0,
                                     0
                                     ) > 0) {

                File = CreateFileA(FilePathA,
                                   GENERIC_READ,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL);
                if (File != INVALID_HANDLE_VALUE) {
                    if (!m_GetLongPathNameA) {
                        Chars = 0;
                    } else {
                        Chars = m_GetLongPathNameA(FilePathA, FilePathA,
                                                   ARRAY_COUNT(FilePathA));
                    }
                    if (Chars == 0 || Chars >= ARRAY_COUNT(FilePathA) ||
                        MultiByteToWideChar(CP_ACP, 0, FilePathA, -1,
                                            LongPath, LongPathChars) == 0) {
                        // Couldn't get the long path, just use the
                        // given path.
                        GenStrCopyNW(LongPath, FilePath, LongPathChars);
                    }
                }
            }
        }

        if ( File == NULL || File == INVALID_HANDLE_VALUE ) {
            return WIN32_LAST_STATUS();
        }
    } else {
        if (!m_GetLongPathNameW) {
            Chars = 0;
        } else {
            Chars = m_GetLongPathNameW(FilePath, LongPath, LongPathChars);
        }
        if (Chars == 0 || Chars >= LongPathChars) {
            // Couldn't get the long path, just use the given path.
            GenStrCopyNW(LongPath, FilePath, LongPathChars);
        }
    }

    *Size = GetFileSize(File, NULL);
    if (*Size == -1) {
        ::CloseHandle( File );
        return WIN32_LAST_STATUS();
    }
    
    Mapping = CreateFileMapping(File,
                                NULL,
                                PAGE_READONLY,
                                0,
                                0,
                                NULL);
    if (!Mapping) {
        ::CloseHandle(File);
        return WIN32_LAST_STATUS();
    }

    View = MapViewOfFile(Mapping,
                         FILE_MAP_READ,
                         0,
                         0,
                         0);

    if (!View) {
        Status = WIN32_LAST_STATUS();
    } else {
        Status = S_OK;
    }

    ::CloseHandle(Mapping);
    ::CloseHandle(File);

    *ViewRet = View;
    return Status;
}
    
void
Win32LiveSystemProvider::CloseMapping(PVOID Mapping)
{
    UnmapViewOfFile(Mapping);
}

HRESULT
Win32LiveSystemProvider::GetImageHeaderInfo(IN HANDLE Process,
                                            IN PCWSTR FilePath,
                                            IN ULONG64 ImageBase,
                                            OUT PULONG Size,
                                            OUT PULONG CheckSum,
                                            OUT PULONG TimeDateStamp)
{
    UCHAR HeaderBuffer[512];
    PIMAGE_NT_HEADERS NtHeaders;
    IMAGE_NT_HEADERS64 Generic;
    SIZE_T Done;

    if (!ReadProcessMemory(Process, (PVOID)(ULONG_PTR)ImageBase,
                           HeaderBuffer, sizeof(HeaderBuffer), &Done)) {
        return WIN32_LAST_STATUS();
    }
    if (Done < sizeof(HeaderBuffer)) {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
        
    NtHeaders = GenImageNtHeader(HeaderBuffer, &Generic);
    if (!NtHeaders) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
    }

    *Size = Generic.OptionalHeader.SizeOfImage;
    *CheckSum = Generic.OptionalHeader.CheckSum;
    *TimeDateStamp = Generic.FileHeader.TimeDateStamp;

    return S_OK;
}

HRESULT
Win32LiveSystemProvider::GetImageVersionInfo(IN HANDLE Process,
                                             IN PCWSTR FilePath,
                                             IN ULONG64 ImageBase,
                                             OUT VS_FIXEDFILEINFO* Info)
{
    HRESULT Status;
    BOOL Succ;
    ULONG Unused;
    ULONG Size;
    UINT VerSize;
    PVOID VersionBlock;
    PVOID VersionData;
    CHAR FilePathA [ MAX_PATH + 10 ];
    BOOL UseAnsi = FALSE;

    //
    // Get the version information.
    //

    Size = GetFileVersionInfoSizeW (FilePath, &Unused);

    if (Size == 0 &&
        GetLastError() == ERROR_CALL_NOT_IMPLEMENTED) {

        // We're on an OS that doesn't support Unicode
        // file operations.  Convert to ANSI and see if
        // that helps.

        if (!WideCharToMultiByte(CP_ACP,
                                 0,
                                 FilePath,
                                 -1,
                                 FilePathA,
                                 sizeof (FilePathA),
                                 0,
                                 0
                                 )) {
            return WIN32_LAST_STATUS();
        }

        Size = GetFileVersionInfoSizeA(FilePathA, &Unused);
        UseAnsi = TRUE;
    }
    
    if (!Size) {
        return WIN32_LAST_STATUS();
    }
    
    VersionBlock = HeapAlloc(GetProcessHeap(), 0, Size);
    if (!VersionBlock) {
        return E_OUTOFMEMORY;
    }

    if (UseAnsi) {
        Succ = GetFileVersionInfoA(FilePathA,
                                   0,
                                   Size,
                                   VersionBlock);
    } else {
        Succ = GetFileVersionInfoW(FilePath,
                                   0,
                                   Size,
                                   VersionBlock);
    }

    if (Succ) {
        //
        // Get the VS_FIXEDFILEINFO from the image.
        //

        Succ = VerQueryValue(VersionBlock,
                             "\\",
                             &VersionData,
                             &VerSize);

        if ( Succ && (VerSize == sizeof (VS_FIXEDFILEINFO)) ) {
            CopyMemory(Info, VersionData, sizeof(*Info));
        } else {
            Succ = FALSE;
        }
    }

    if (Succ) {
        Status = S_OK;
    } else {
        Status = WIN32_LAST_STATUS();
    }
    
    HeapFree(GetProcessHeap(), 0, VersionBlock);
    return Status;
}

HRESULT
Win32LiveSystemProvider::GetImageDebugRecord(IN HANDLE Process,
                                             IN PCWSTR FilePath,
                                             IN ULONG64 ImageBase,
                                             IN ULONG RecordType,
                                             OUT OPTIONAL PVOID Data,
                                             IN OUT PULONG DataLen)
{
    // We can rely on the default processing.
    return E_NOINTERFACE;
}

HRESULT
Win32LiveSystemProvider::EnumImageDataSections(IN HANDLE Process,
                                               IN PCWSTR FilePath,
                                               IN ULONG64 ImageBase,
                                               IN MiniDumpProviderCallbacks*
                                               Callback)
{
    // We can rely on the default processing.
    return E_NOINTERFACE;
}

HRESULT
Win32LiveSystemProvider::OpenThread(IN ULONG DesiredAccess,
                                    IN BOOL InheritHandle,
                                    IN ULONG ThreadId,
                                    OUT PHANDLE Handle)
{
    if (!m_OpenThread) {
        return E_NOTIMPL;
    }

    *Handle = m_OpenThread(DesiredAccess, InheritHandle, ThreadId);
    return *Handle ? S_OK : WIN32_LAST_STATUS();
}

void
Win32LiveSystemProvider::CloseThread(IN HANDLE Handle)
{
    ::CloseHandle(Handle);
}

ULONG
Win32LiveSystemProvider::GetCurrentThreadId(void)
{
    return ::GetCurrentThreadId();
}

ULONG
Win32LiveSystemProvider::SuspendThread(IN HANDLE Thread)
{
    return ::SuspendThread(Thread);
}

ULONG
Win32LiveSystemProvider::ResumeThread(IN HANDLE Thread)
{
    return ::ResumeThread(Thread);
}

HRESULT
Win32LiveSystemProvider::GetThreadContext(IN HANDLE Thread,
                                          OUT PVOID Context,
                                          IN ULONG ContextSize,
                                          OUT PULONG64 CurrentPc,
                                          OUT PULONG64 CurrentStack,
                                          OUT PULONG64 CurrentStore)
{
    CONTEXT StackContext;
    BOOL Succ;

    if (ContextSize > sizeof(StackContext)) {
        return E_INVALIDARG;
    }
    
    // Always call GetThreadContext on the CONTEXT structure
    // on the stack as CONTEXTs have strict alignment requirements
    // and the raw buffer coming in may not obey them.
    StackContext.ContextFlags = ALL_REGISTERS;
    
    Succ = ::GetThreadContext(Thread, &StackContext);

    if (Succ) {
        
        memcpy(Context, &StackContext, ContextSize);
        *CurrentPc = PROGRAM_COUNTER(&StackContext);
        *CurrentStack = STACK_POINTER(&StackContext);
#ifdef DUMP_BACKING_STORE
        *CurrentStore = BSTORE_POINTER(&StackContext);
#endif

        return S_OK;
        
    } else {
        return WIN32_LAST_STATUS();
    }
}

HRESULT
Win32LiveSystemProvider::GetProcessTimes(IN HANDLE Process,
                                         OUT LPFILETIME Create,
                                         OUT LPFILETIME User,
                                         OUT LPFILETIME Kernel)
{
    if (!m_GetProcessTimes) {
        return E_NOTIMPL;
    }

    FILETIME Exit;
    
    if (!m_GetProcessTimes(Process, Create, &Exit, User, Kernel)) {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

HRESULT
Win32LiveSystemProvider::ReadVirtual(IN HANDLE Process,
                                     IN ULONG64 Offset,
                                     OUT PVOID Buffer,
                                     IN ULONG Request,
                                     OUT PULONG Done)
{
    // ReadProcessMemory will fail if any part of the
    // region to read does not have read access.  This
    // routine attempts to read the largest valid prefix
    // so it has to break up reads on page boundaries.

    HRESULT Status = S_OK;
    SIZE_T TotalBytesRead = 0;
    SIZE_T Read;
    ULONG ReadSize;

    while (Request > 0) {
        
        // Calculate bytes to read and don't let read cross
        // a page boundary.
        ReadSize = PAGE_SIZE - (ULONG)(Offset & (PAGE_SIZE - 1));
        ReadSize = min(Request, ReadSize);

        if (!ReadProcessMemory(Process, (PVOID)(ULONG_PTR)Offset,
                               Buffer, ReadSize, &Read)) {
            if (TotalBytesRead == 0) {
                // If we haven't read anything indicate failure.
                Status = WIN32_LAST_STATUS();
            }
            break;
        }

        TotalBytesRead += Read;
        Offset += Read;
        Buffer = (PVOID)((PUCHAR)Buffer + Read);
        Request -= (ULONG)Read;
    }

    *Done = (ULONG)TotalBytesRead;
    return Status;
}

HRESULT
Win32LiveSystemProvider::ReadAllVirtual(IN HANDLE Process,
                                        IN ULONG64 Offset,
                                        OUT PVOID Buffer,
                                        IN ULONG Request)
{
    HRESULT Status;
    ULONG Done;

    if ((Status = ReadVirtual(Process, Offset, Buffer, Request,
                              &Done)) != S_OK)
    {
        return Status;
    }
    if (Done != Request)
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
    return S_OK;
}

HRESULT
Win32LiveSystemProvider::QueryVirtual(IN HANDLE Process,
                                      IN ULONG64 Offset,
                                      OUT PULONG64 Base,
                                      OUT PULONG64 Size,
                                      OUT PULONG Protect,
                                      OUT PULONG State,
                                      OUT PULONG Type)
{
    MEMORY_BASIC_INFORMATION Info;
    
    if (!VirtualQueryEx(Process, (PVOID)(ULONG_PTR)Offset,
                        &Info, sizeof(Info))) {
        return WIN32_LAST_STATUS();
    }

    *Base = (LONG_PTR)Info.BaseAddress;
    *Size = Info.RegionSize;
    *Protect = Info.Protect;
    *State = Info.State;
    *Type = Info.Type;
    return S_OK;
}

HRESULT
Win32LiveSystemProvider::StartProcessEnum(IN HANDLE Process,
                                          IN ULONG ProcessId)
{
    ULONG SnapFlags;

    if (!m_CreateToolhelp32Snapshot) {
        return E_NOTIMPL;
    }
    
    //
    // Toolhelp on older NT builds uses an in-process enumeration
    // of modules so don't use it to keep everything out of process.
    // On other platforms it's the only option.
    //
    
    SnapFlags = TH32CS_SNAPTHREAD;
    if (m_PlatformId == VER_PLATFORM_WIN32_NT) {
        if (m_BuildNumber >= NT_BUILD_TH_MODULES) {
            m_AnsiModules = FALSE;
            SnapFlags |= TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32;
        }
    } else {
        m_AnsiModules = TRUE;
        SnapFlags |= TH32CS_SNAPMODULE;
    }
    
    m_ThSnap = m_CreateToolhelp32Snapshot(SnapFlags, ProcessId);
    if (m_ThSnap == INVALID_HANDLE_VALUE) {
        return WIN32_LAST_STATUS();
    }

    m_ProcessHandle = Process;
    m_ProcessId = ProcessId;
    m_ThreadIndex = 0;
    m_ModuleIndex = 0;
    return S_OK;
}

HRESULT
Win32LiveSystemProvider::EnumThreads(OUT PULONG ThreadId)
{
    HRESULT Status;
    THREADENTRY32 ThreadInfo;
    
    ThreadInfo.dwSize = sizeof(ThreadInfo);
    
    if (m_ThreadIndex == 0) {
        Status = ProcessThread32First(m_ThSnap, m_ProcessId, &ThreadInfo);
    } else {
        Status = ProcessThread32Next(m_ThSnap, m_ProcessId, &ThreadInfo);
    }

    if (Status == S_OK) {
        *ThreadId = ThreadInfo.th32ThreadID;
        m_ThreadIndex++;
        return S_OK;
    } else {
        return S_FALSE;
    }
}

HRESULT
Win32LiveSystemProvider::EnumModules(OUT PULONG64 Base,
                                     OUT PWSTR Path,
                                     IN ULONG PathChars)
{
    BOOL Succ;
    
    if (m_AnsiModules) {
        
        if (!m_Module32First || !m_Module32Next) {
            return E_NOTIMPL;
        }

        MODULEENTRY32 ModuleInfo;

        ModuleInfo.dwSize = sizeof(ModuleInfo);
        
        if (m_ModuleIndex == 0) {
            Succ = m_Module32First(m_ThSnap, &ModuleInfo);
        } else {
            // Win9x seems to require that this module ID be saved
            // between calls so stick it back in to keep Win9x happy.
            ModuleInfo.th32ModuleID = m_LastModuleId;
            Succ = m_Module32Next(m_ThSnap, &ModuleInfo);
        }

        if (Succ) {
            m_ModuleIndex++;
            *Base = (LONG_PTR)ModuleInfo.modBaseAddr;
            m_LastModuleId = ModuleInfo.th32ModuleID;
            if (!MultiByteToWideChar(CP_ACP,
                                     0,
                                     ModuleInfo.szExePath,
                                     -1,
                                     Path,
                                     PathChars)) {
                return WIN32_LAST_STATUS();
            }
            return S_OK;
        } else {
            return S_FALSE;
        }

    } else {
        
        if (!m_Module32FirstW || !m_Module32NextW) {
            return E_NOTIMPL;
        }

        MODULEENTRY32W ModuleInfo;

        ModuleInfo.dwSize = sizeof(ModuleInfo);
        
        if (m_ModuleIndex == 0) {
            Succ = m_Module32FirstW(m_ThSnap, &ModuleInfo);
        } else {
            Succ = m_Module32NextW(m_ThSnap, &ModuleInfo);
        }

        if (Succ) {
            m_ModuleIndex++;
            *Base = (LONG_PTR)ModuleInfo.modBaseAddr;
            
            //
            // The basic LdrQueryProcessModule API that toolhelp uses
            // always returns ANSI strings for module paths.  This
            // means that even if you use the wide toolhelp calls
            // you still lose Unicode information because the original
            // Unicode path was converted to ANSI and then back to Unicode.
            // To avoid this problem, always try and look up the true
            // Unicode path first.  This doesn't work for 32-bit modules
            // in WOW64, though, so if there's a failure just use the
            // incoming string.
            //
    
            if (!m_GetModuleFileNameExW ||
                !m_GetModuleFileNameExW(m_ProcessHandle,
                                        ModuleInfo.hModule,
                                        Path,
                                        PathChars)) {
                GenStrCopyNW(Path, ModuleInfo.szExePath, PathChars);
            }
            return S_OK;
        } else {
            return S_FALSE;
        }

    }
}

HRESULT
Win32LiveSystemProvider::EnumFunctionTables(OUT PULONG64 MinAddress,
                                            OUT PULONG64 MaxAddress,
                                            OUT PULONG64 BaseAddress,
                                            OUT PULONG EntryCount,
                                            OUT PVOID RawTable,
                                            IN ULONG RawTableSize,
                                            OUT PVOID* RawEntryHandle)
{
    // Basic Win32 doesn't have function tables.
    return S_FALSE;
}

HRESULT
Win32LiveSystemProvider::EnumFunctionTableEntries(IN PVOID RawTable,
                                                  IN ULONG RawTableSize,
                                                  IN PVOID RawEntryHandle,
                                                  OUT PVOID RawEntries,
                                                  IN ULONG RawEntriesSize)
{
    // Basic Win32 doesn't have function tables.
    return E_NOTIMPL;
}

HRESULT
Win32LiveSystemProvider::EnumFunctionTableEntryMemory(IN ULONG64 TableBase,
                                                      IN PVOID RawEntries,
                                                      IN ULONG Index,
                                                      OUT PULONG64 Start,
                                                      OUT PULONG Size)
{
    // Basic Win32 doesn't have function tables.
    return E_NOTIMPL;
}

HRESULT
Win32LiveSystemProvider::EnumUnloadedModules(OUT PWSTR Path,
                                             IN ULONG PathChars,
                                             OUT PULONG64 BaseOfModule,
                                             OUT PULONG SizeOfModule,
                                             OUT PULONG CheckSum,
                                             OUT PULONG TimeDateStamp)
{
    // Basic Win32 doesn't have unloaded modules.
    return S_FALSE;
}

void
Win32LiveSystemProvider::FinishProcessEnum(void)
{
    ::CloseHandle(m_ThSnap);
}

HRESULT
Win32LiveSystemProvider::StartHandleEnum(IN HANDLE Process,
                                         IN ULONG ProcessId,
                                         OUT PULONG Count)
{
    // Basic Win32 doesn't have handle data queries.
    *Count = 0;
    return S_OK;
}

HRESULT
Win32LiveSystemProvider::EnumHandles(OUT PULONG64 Handle,
                                     OUT PULONG Attributes,
                                     OUT PULONG GrantedAccess,
                                     OUT PULONG HandleCount,
                                     OUT PULONG PointerCount,
                                     OUT PWSTR TypeName,
                                     IN ULONG TypeNameChars,
                                     OUT PWSTR ObjectName,
                                     IN ULONG ObjectNameChars)
{
    // Basic Win32 doesn't have handle data queries.
    return S_FALSE;
}

void
Win32LiveSystemProvider::FinishHandleEnum(void)
{
    // Basic Win32 doesn't have handle data queries.
}

HRESULT
Win32LiveSystemProvider::EnumPebMemory(IN HANDLE Process,
                                       IN ULONG64 PebOffset,
                                       IN ULONG PebSize,
                                       IN MiniDumpProviderCallbacks* Callback)
{
    // Basic Win32 doesn't have a defined PEB.
    return S_OK;
}

HRESULT
Win32LiveSystemProvider::EnumTebMemory(IN HANDLE Process,
                                       IN HANDLE Thread,
                                       IN ULONG64 TebOffset,
                                       IN ULONG TebSize,
                                       IN MiniDumpProviderCallbacks* Callback)
{
    // Basic Win32 doesn't have a defined TEB beyond
    // the TIB.  The TIB can reference fiber data but
    // that's NT-specific.
    return S_OK;
}

HRESULT
Win32LiveSystemProvider::GetCorDataAccess(IN PWSTR AccessDllName,
                                          IN struct ICorDataAccessServices*
                                          Services,
                                          OUT struct ICorDataAccess**
                                          Access)
{
    HRESULT Status;
    
    m_CorDll = ::LoadLibraryW(AccessDllName);
    if (!m_CorDll) {
        char DllPathA[MAX_PATH];

        if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED ||
            !WideCharToMultiByte(CP_ACP, 0,
                                 AccessDllName, -1,
                                 DllPathA, sizeof(DllPathA),
                                 0, 0) ||
            !(m_CorDll = ::LoadLibraryA(DllPathA))) {
            return WIN32_LAST_STATUS();
        }
    }

    PFN_CreateCorDataAccess Entry = (PFN_CreateCorDataAccess)
        GetProcAddress(m_CorDll, "CreateCorDataAccess");
    if (!Entry)
    {
        Status = WIN32_LAST_STATUS();
        FreeLibrary(m_CorDll);
        return Status;
    }

    if ((Status = Entry(__uuidof(ICorDataAccess), Services,
                        (void**)Access)) != S_OK)
    {
        FreeLibrary(m_CorDll);
    }

    return Status;
}

void
Win32LiveSystemProvider::ReleaseCorDataAccess(IN struct ICorDataAccess*
                                              Access)
{
    Access->Release();
    ::FreeLibrary(m_CorDll);
}

HRESULT
Win32LiveSystemProvider::ProcessThread32Next(IN HANDLE Snapshot,
                                             IN ULONG ProcessId,
                                             OUT THREADENTRY32* ThreadInfo)
{
    BOOL Succ;

    if (!m_Thread32Next) {
        return E_NOTIMPL;
    }
    
    //
    // NB: Toolhelp says nothing about the order of the threads will be
    // returned in (i.e., if they are grouped by process or not). If they
    // are groupled by process -- which they emperically seem to be -- there
    // is a more efficient algorithm than simple brute force.
    //

    do {
        ThreadInfo->dwSize = sizeof (*ThreadInfo);
        Succ = m_Thread32Next(Snapshot, ThreadInfo);
    } while (Succ && ThreadInfo->th32OwnerProcessID != ProcessId);

    return Succ ? S_OK : WIN32_LAST_STATUS();
}

HRESULT
Win32LiveSystemProvider::ProcessThread32First(IN HANDLE Snapshot,
                                              IN ULONG ProcessId,
                                              OUT THREADENTRY32* ThreadInfo)
{
    HRESULT Status;
    BOOL Succ;

    if (!m_Thread32First) {
        return E_NOTIMPL;
    }
    
    ThreadInfo->dwSize = sizeof (*ThreadInfo);
    Succ = m_Thread32First(Snapshot, ThreadInfo);
    Status = Succ ? S_OK : WIN32_LAST_STATUS();
    if (Succ && ThreadInfo->th32OwnerProcessID != ProcessId) {
        Status = ProcessThread32Next (Snapshot, ProcessId, ThreadInfo);
    }

    return Status;
}

HRESULT
Win32LiveSystemProvider::TibGetThreadInfo(IN HANDLE Process,
                                          IN ULONG64 TibBase,
                                          OUT PULONG64 StackBase,
                                          OUT PULONG64 StackLimit,
                                          OUT PULONG64 StoreBase,
                                          OUT PULONG64 StoreLimit)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    TEB Teb;
    HRESULT Status;

#if defined (DUMP_BACKING_STORE)

    if ((Status = ReadAllVirtual(Process,
                                 TibBase,
                                 &Teb,
                                 sizeof(Teb))) != S_OK) {
        return Status;
    }

    *StoreBase = BSTORE_BASE(&Teb);
    *StoreLimit = BSTORE_LIMIT(&Teb);
    
#else
    
    if ((Status = ReadAllVirtual(Process,
                                 TibBase,
                                 &Teb,
                                 sizeof(Teb.NtTib))) != S_OK) {
        return Status;
    }

    *StoreBase = 0;
    *StoreLimit = 0;
    
#endif

    *StackBase = (LONG_PTR)Teb.NtTib.StackBase;
    *StackLimit = (LONG_PTR)Teb.NtTib.StackLimit;
    
    return S_OK;
#endif // #ifdef _WIN32_WCE
}

HRESULT
MiniDumpCreateLiveSystemProvider
    (OUT MiniDumpSystemProvider** Prov)
{
    HRESULT Status;
    OSVERSIONINFO OsInfo;
    Win32LiveSystemProvider* Obj;

    OsInfo.dwOSVersionInfoSize = sizeof(OsInfo);
    if (!GetVersionEx(&OsInfo)) {
        return WIN32_LAST_STATUS();
    }

    switch(OsInfo.dwPlatformId) {
    case VER_PLATFORM_WIN32_NT:
        Obj = NewNtWin32LiveSystemProvider(OsInfo.dwBuildNumber);
        break;
    case VER_PLATFORM_WIN32_WINDOWS:
        Obj = NewWin9xWin32LiveSystemProvider(OsInfo.dwBuildNumber);
        break;
    case VER_PLATFORM_WIN32_CE:
        Obj = NewWinCeWin32LiveSystemProvider(OsInfo.dwBuildNumber);
        break;
    default:
        return E_INVALIDARG;
    }
    if (!Obj) {
        return E_OUTOFMEMORY;
    }

    if ((Status = Obj->Initialize()) != S_OK) {
        Obj->Release();
        return Status;
    }
    
    *Prov = (MiniDumpSystemProvider*)Obj;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// Win32FileOutputProvider.
//
//----------------------------------------------------------------------------

class Win32FileOutputProvider
{
public:
    Win32FileOutputProvider(HANDLE Handle);
    virtual void Release(void);
    
    virtual HRESULT SupportsStreaming(void);
    virtual HRESULT Start(IN ULONG64 MaxSize);
    virtual HRESULT Seek(IN ULONG How,
                         IN LONG64 Amount,
                         OUT OPTIONAL PULONG64 NewOffset);
    virtual HRESULT WriteAll(IN PVOID Buffer,
                             IN ULONG Request);
    virtual void Finish(void);

protected:
    HANDLE m_Handle;
};

Win32FileOutputProvider::Win32FileOutputProvider(HANDLE Handle)
{
    m_Handle = Handle;
}

void
Win32FileOutputProvider::Release(void)
{
    delete this;
}

HRESULT
Win32FileOutputProvider::SupportsStreaming(void)
{
    return S_OK;
}

HRESULT
Win32FileOutputProvider::Start(IN ULONG64 MaxSize)
{
    // Nothing to do.
    return S_OK;
}

HRESULT
Win32FileOutputProvider::Seek(IN ULONG How,
                              IN LONG64 Amount,
                              OUT OPTIONAL PULONG64 NewOffset)
{
    ULONG Ret;
    LONG High;

    High = (LONG)(Amount >> 32);
    Ret = SetFilePointer(m_Handle, (LONG)Amount, &High, How);
    if (Ret == INVALID_SET_FILE_POINTER &&
        GetLastError()) {
        return WIN32_LAST_STATUS();
    }

    if (NewOffset) {
        *NewOffset = ((ULONG64)High << 32) | Ret;
    }

    return S_OK;
}

HRESULT
Win32FileOutputProvider::WriteAll(IN PVOID Buffer,
                                  IN ULONG Request)
{
    ULONG Done;
    
    if (!WriteFile(m_Handle, Buffer, Request, &Done, NULL)) {
        return WIN32_LAST_STATUS();
    }
    if (Done != Request) {
        return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }

    return S_OK;
}

void
Win32FileOutputProvider::Finish(void)
{
    // Nothing to do.
}

HRESULT
MiniDumpCreateFileOutputProvider
    (IN HANDLE FileHandle,
     OUT MiniDumpOutputProvider** Prov)
{
    Win32FileOutputProvider* Obj =
        new Win32FileOutputProvider(FileHandle);
    if (!Obj) {
        return E_OUTOFMEMORY;
    }
    
    *Prov = (MiniDumpOutputProvider*)Obj;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// Win32LiveAllocationProvider.
//
//----------------------------------------------------------------------------

class Win32LiveAllocationProvider : public MiniDumpAllocationProvider
{
public:
    virtual void Release(void);
    virtual PVOID Alloc(ULONG Size);
    virtual PVOID Realloc(PVOID Mem, ULONG NewSize);
    virtual void  Free(PVOID Mem);
};

void
Win32LiveAllocationProvider::Release(void)
{
    delete this;
}

PVOID
Win32LiveAllocationProvider::Alloc(ULONG Size)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size);
}

PVOID
Win32LiveAllocationProvider::Realloc(PVOID Mem, ULONG NewSize)
{
    return HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Mem, NewSize);
}

void
Win32LiveAllocationProvider::Free(PVOID Mem)
{
    if (Mem) {
        HeapFree(GetProcessHeap(), 0, Mem);
    }
}

HRESULT
MiniDumpCreateLiveAllocationProvider
    (OUT MiniDumpAllocationProvider** Prov)
{
    Win32LiveAllocationProvider* Obj =
        new Win32LiveAllocationProvider;
    if (!Obj) {
        return E_OUTOFMEMORY;
    }
    
    *Prov = (MiniDumpAllocationProvider*)Obj;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\minidump\prov_unt.cpp ===
/*++

Copyright(c) 1999-2002 Microsoft Corporation

--*/


#include "pch.cpp"

#include "platform.h"
#include "nt4p.h"

//----------------------------------------------------------------------------
//
// NtWin32LiveSystemProvider.
//
//----------------------------------------------------------------------------

class NtWin32LiveSystemProvider : public Win32LiveSystemProvider
{
public:
    NtWin32LiveSystemProvider(ULONG BuildNumber);
    ~NtWin32LiveSystemProvider(void);

    virtual HRESULT Initialize(void);
    
    virtual void Release(void);
    virtual HRESULT OpenThread(IN ULONG DesiredAccess,
                               IN BOOL InheritHandle,
                               IN ULONG ThreadId,
                               OUT PHANDLE Handle);
    virtual HRESULT GetTeb(IN HANDLE Thread,
                           OUT PULONG64 Offset,
                           OUT PULONG Size);
    virtual HRESULT GetThreadInfo(IN HANDLE Process,
                                  IN HANDLE Thread,
                                  OUT PULONG64 Teb,
                                  OUT PULONG SizeOfTeb,
                                  OUT PULONG64 StackBase,
                                  OUT PULONG64 StackLimit,
                                  OUT PULONG64 StoreBase,
                                  OUT PULONG64 StoreLimit);
    virtual HRESULT GetPeb(IN HANDLE Process,
                           OUT PULONG64 Offset,
                           OUT PULONG Size);
    virtual HRESULT StartProcessEnum(IN HANDLE Process,
                                     IN ULONG ProcessId);
    virtual HRESULT EnumModules(OUT PULONG64 Base,
                                OUT PWSTR Path,
                                IN ULONG PathChars);
    virtual HRESULT EnumFunctionTables(OUT PULONG64 MinAddress,
                                       OUT PULONG64 MaxAddress,
                                       OUT PULONG64 BaseAddress,
                                       OUT PULONG EntryCount,
                                       OUT PVOID RawTable,
                                       IN ULONG RawTableSize,
                                       OUT PVOID* RawEntryHandle);
    virtual HRESULT EnumFunctionTableEntries(IN PVOID RawTable,
                                             IN ULONG RawTableSize,
                                             IN PVOID RawEntryHandle,
                                             OUT PVOID RawEntries,
                                             IN ULONG RawEntriesSize);
    virtual HRESULT EnumFunctionTableEntryMemory(IN ULONG64 TableBase,
                                                 IN PVOID RawEntries,
                                                 IN ULONG Index,
                                                 OUT PULONG64 Start,
                                                 OUT PULONG Size);
    virtual HRESULT EnumUnloadedModules(OUT PWSTR Path,
                                        IN ULONG PathChars,
                                        OUT PULONG64 BaseOfModule,
                                        OUT PULONG SizeOfModule,
                                        OUT PULONG CheckSum,
                                        OUT PULONG TimeDateStamp);
    virtual void    FinishProcessEnum(void);
    virtual HRESULT StartHandleEnum(IN HANDLE Process,
                                    IN ULONG ProcessId,
                                    OUT PULONG Count);
    virtual HRESULT EnumHandles(OUT PULONG64 Handle,
                                OUT PULONG Attributes,
                                OUT PULONG GrantedAccess,
                                OUT PULONG HandleCount,
                                OUT PULONG PointerCount,
                                OUT PWSTR TypeName,
                                IN ULONG TypeNameChars,
                                OUT PWSTR ObjectName,
                                IN ULONG ObjectNameChars);
    virtual void    FinishHandleEnum(void);
    
    virtual HRESULT EnumPebMemory(IN HANDLE Process,
                                  IN ULONG64 PebOffset,
                                  IN ULONG PebSize,
                                  IN MiniDumpProviderCallbacks* Callback);
    virtual HRESULT EnumTebMemory(IN HANDLE Process,
                                  IN HANDLE Thread,
                                  IN ULONG64 TebOffset,
                                  IN ULONG TebSize,
                                  IN MiniDumpProviderCallbacks* Callback);

    void EnumUnicodeString(IN PUNICODE_STRING String,
                           IN MiniDumpProviderCallbacks* Callback)
    {
        if (String->Length > 0 && String->Buffer)
        {
            Callback->EnumMemory((LONG_PTR)String->Buffer, String->Length);
        }
    }

    void TranslateNtPathName(IN OUT PWSTR Path);
    
protected:
    HINSTANCE m_NtDll;
    NT_OPEN_THREAD m_NtOpenThread;
    NT_QUERY_SYSTEM_INFORMATION m_NtQuerySystemInformation;
    NT_QUERY_INFORMATION_PROCESS m_NtQueryInformationProcess;
    NT_QUERY_INFORMATION_THREAD m_NtQueryInformationThread;
    NT_QUERY_OBJECT m_NtQueryObject;
    RTL_FREE_HEAP m_RtlFreeHeap;
    RTL_GET_FUNCTION_TABLE_LIST_HEAD m_RtlGetFunctionTableListHead;
    RTL_GET_UNLOAD_EVENT_TRACE m_RtlGetUnloadEventTrace;

    PLIST_ENTRY m_FuncTableHead;
    PLIST_ENTRY m_FuncTable;
    PRTL_UNLOAD_EVENT_TRACE m_Unloads;
    PRTL_UNLOAD_EVENT_TRACE m_Unload;
    ULONG m_UnloadArraySize;
    ULONG m_NumUnloads;
    ULONG m_Handle;
};

NtWin32LiveSystemProvider::NtWin32LiveSystemProvider(ULONG BuildNumber)
    : Win32LiveSystemProvider(VER_PLATFORM_WIN32_NT, BuildNumber)
{
    m_NtDll = NULL;
    m_NtOpenThread = NULL;
    m_NtQuerySystemInformation = NULL;
    m_NtQueryInformationProcess = NULL;
    m_NtQueryInformationThread = NULL;
    m_NtQueryObject = NULL;
    m_RtlFreeHeap = NULL;
    m_RtlGetFunctionTableListHead = NULL;
    m_RtlGetUnloadEventTrace = NULL;

    m_Unloads = NULL;
}

NtWin32LiveSystemProvider::~NtWin32LiveSystemProvider(void)
{
    if (m_NtDll) {
        FreeLibrary(m_NtDll);
    }
    if (m_Unloads) {
        HeapFree(GetProcessHeap(), 0, m_Unloads);
    }
}

HRESULT
NtWin32LiveSystemProvider::Initialize(void)
{
    HRESULT Status;

    if ((Status = Win32LiveSystemProvider::Initialize()) != S_OK) {
        return Status;
    }
    
    m_NtDll = LoadLibrary("ntdll.dll");
    if (m_NtDll) {
        m_NtOpenThread = (NT_OPEN_THREAD)
            GetProcAddress(m_NtDll, "NtOpenThread");
        m_NtQuerySystemInformation = (NT_QUERY_SYSTEM_INFORMATION)
            GetProcAddress(m_NtDll, "NtQuerySystemInformation");
        m_NtQueryInformationProcess = (NT_QUERY_INFORMATION_PROCESS)
            GetProcAddress(m_NtDll, "NtQueryInformationProcess");
        m_NtQueryInformationThread = (NT_QUERY_INFORMATION_THREAD)
            GetProcAddress(m_NtDll, "NtQueryInformationThread");
        m_NtQueryObject = (NT_QUERY_OBJECT)
            GetProcAddress(m_NtDll, "NtQueryObject");
        m_RtlFreeHeap = (RTL_FREE_HEAP)
            GetProcAddress(m_NtDll, "RtlFreeHeap");
        m_RtlGetFunctionTableListHead = (RTL_GET_FUNCTION_TABLE_LIST_HEAD)
            GetProcAddress(m_NtDll, "RtlGetFunctionTableListHead");
        m_RtlGetUnloadEventTrace = (RTL_GET_UNLOAD_EVENT_TRACE)
            GetProcAddress(m_NtDll, "RtlGetUnloadEventTrace");
    }
    
    return S_OK;
}

void
NtWin32LiveSystemProvider::Release(void)
{
    delete this;
}

HRESULT
NtWin32LiveSystemProvider::OpenThread(IN ULONG DesiredAccess,
                                      IN BOOL InheritHandle,
                                      IN ULONG ThreadId,
                                      OUT PHANDLE Handle)
{
    if (m_OpenThread) {
        // OS supports regular Win32 OpenThread, so try it.
        *Handle = m_OpenThread(DesiredAccess, InheritHandle, ThreadId);
        if (*Handle) {
            return S_OK;
        }
    }
    
    if (!m_NtOpenThread) {
        return E_NOTIMPL;
    }

    NTSTATUS Status;
    NT4_OBJECT_ATTRIBUTES Obja;
    NT4_CLIENT_ID ClientId;

    ClientId.UniqueThread = (HANDLE)LongToHandle(ThreadId);
    ClientId.UniqueProcess = (HANDLE)NULL;

    Nt4InitializeObjectAttributes(&Obja,
                                  NULL,
                                  (InheritHandle ? NT4_OBJ_INHERIT : 0),
                                  NULL,
                                  NULL);

    Status = m_NtOpenThread(Handle,
                            (ACCESS_MASK)DesiredAccess,
                            (POBJECT_ATTRIBUTES)&Obja,
                            (PCLIENT_ID)&ClientId);
    if (!NT_SUCCESS(Status)) {
        return HRESULT_FROM_NT(Status);
    }

    return S_OK;
}

HRESULT
NtWin32LiveSystemProvider::GetTeb(IN HANDLE Thread,
                                  OUT PULONG64 Offset,
                                  OUT PULONG Size)
{
    if (!m_NtQueryInformationThread) {
        return E_NOTIMPL;
    }

    THREAD_BASIC_INFORMATION ThreadInformation;
    NTSTATUS NtStatus;

    NtStatus = m_NtQueryInformationThread(Thread,
                                          ThreadBasicInformation,
                                          &ThreadInformation,
                                          sizeof(ThreadInformation),
                                          NULL);
    if (NT_SUCCESS(NtStatus)) {
        // The TEB is a little smaller than a page but
        // save the entire page so that adjacent TEB
        // pages get coalesced into a single region.
        // As TEBs are normally adjacent this is a common case.
        *Offset = (LONG_PTR)ThreadInformation.TebBaseAddress;
        *Size = PAGE_SIZE;
        return S_OK;
    } else {
        *Offset = 0;
        *Size = 0;
        return HRESULT_FROM_NT(NtStatus);
    }
}

HRESULT
NtWin32LiveSystemProvider::GetThreadInfo(IN HANDLE Process,
                                         IN HANDLE Thread,
                                         OUT PULONG64 Teb,
                                         OUT PULONG SizeOfTeb,
                                         OUT PULONG64 StackBase,
                                         OUT PULONG64 StackLimit,
                                         OUT PULONG64 StoreBase,
                                         OUT PULONG64 StoreLimit)
{
    HRESULT Status;

    if ((Status = GetTeb(Thread, Teb, SizeOfTeb)) != S_OK) {
        return Status;
    }

    return TibGetThreadInfo(Process, *Teb,
                            StackBase, StackLimit,
                            StoreBase, StoreLimit);
}

HRESULT
NtWin32LiveSystemProvider::GetPeb(IN HANDLE Process,
                                  OUT PULONG64 Offset,
                                  OUT PULONG Size)
{
    if (!m_NtQueryInformationProcess) {
        return E_NOTIMPL;
    }
    
    PROCESS_BASIC_INFORMATION Information;
    NTSTATUS NtStatus;

    NtStatus = m_NtQueryInformationProcess(Process,
                                           ProcessBasicInformation,
                                           &Information,
                                           sizeof(Information),
                                           NULL);
    if (NT_SUCCESS(NtStatus)) {
        *Offset = (LONG_PTR)Information.PebBaseAddress;
        *Size = sizeof(PEB);
        return S_OK;
    } else {
        *Offset = 0;
        *Size = 0;
        return HRESULT_FROM_NT(NtStatus);
    }
}

HRESULT
NtWin32LiveSystemProvider::StartProcessEnum(IN HANDLE Process,
                                            IN ULONG ProcessId)
{
    HRESULT Status;
    SIZE_T Done;

    if ((Status = Win32LiveSystemProvider::
         StartProcessEnum(Process, ProcessId)) != S_OK) {
        return Status;
    }

    //
    // On systems that support dynamic function tables
    // ntdll exports a function called RtlGetFunctionTableListHead
    // to retrieve the head of a process's function table list.
    // Currently this is always a global LIST_ENTRY in ntdll
    // and so is at the same address in all processes since ntdll
    // is mapped at the same address in every process.  This
    // means we can call it in our process and get a pointer
    // that's valid in the process being dumped.
    //
    // We also use the presence of RGFTLH as a signal of
    // whether dynamic function tables are supported or not.
    //

    m_FuncTableHead = NULL;
    m_FuncTable = NULL;
    if (m_RtlGetFunctionTableListHead) {

        PLIST_ENTRY HeadAddr, HeadFirst;
        
        HeadAddr = m_RtlGetFunctionTableListHead();
        if (ReadProcessMemory(Process, HeadAddr,
                              &HeadFirst, sizeof(HeadFirst),
                              &Done) &&
            Done == sizeof(HeadFirst)) {
            m_FuncTableHead = HeadAddr;
            m_FuncTable = HeadFirst;
        }
    }

    //
    // On systems that support unload traces
    // ntdll exports a function called RtlGetUnloadEventTrace
    // to retrieve the base of an unload trace array.
    // Currently this is always a global in ntdll
    // and so is at the same address in all processes since ntdll
    // is mapped at the same address in every process.  This
    // means we can call it in our process and get a pointer
    // that's valid in the process being dumped.
    //
    // We also use the presence of RGUET as a signal of
    // whether unload traces are supported or not.
    //
    
    m_Unloads = NULL;
    m_Unload = NULL;
    m_NumUnloads = 0;
    m_UnloadArraySize = 0;
    if (m_RtlGetUnloadEventTrace) {
        
        PRTL_UNLOAD_EVENT_TRACE TraceAddr;
        ULONG Entries;

        TraceAddr = m_RtlGetUnloadEventTrace();
        
        // Currently there are always 16 entries.
        Entries = 16;
        m_UnloadArraySize = Entries;

        m_Unloads = (PRTL_UNLOAD_EVENT_TRACE)
            HeapAlloc(GetProcessHeap(), 0, sizeof(*TraceAddr) * Entries);
        if (m_Unloads &&
            ReadProcessMemory(Process, TraceAddr,
                              m_Unloads, sizeof(*TraceAddr) * Entries,
                              &Done) &&
            Done == sizeof(*TraceAddr) * Entries) {
            
            PRTL_UNLOAD_EVENT_TRACE Oldest;

            //
            // Find the true number of entries in use and sort.
            // The sequence numbers of the trace records increase with
            // time and we want to have the head of the list be the
            // most recent record, so sort by decreasing sequence number.
            // We know that the array is a circular buffer, so things
            // are already in order except there may be a transition
            // of sequence after the newest record.  Find that transition
            // and sorting becomes trivial.
            //

            Oldest = m_Unloads;
            for (ULONG i = 0; i < Entries; i++) {

                if (!m_Unloads[i].BaseAddress ||
                    !m_Unloads[i].SizeOfImage) {
                    // Unused entry, no need to continue.
                    Entries = i;
                    break;
                }

                if (m_Unloads[i].Sequence < Oldest->Sequence) {
                    Oldest = m_Unloads + i;
                }
            }

            m_Unload = Oldest;
            m_NumUnloads = Entries;
        }
    }

    return S_OK;
}

HRESULT
NtWin32LiveSystemProvider::EnumModules(OUT PULONG64 Base,
                                       OUT PWSTR Path,
                                       IN ULONG PathChars)
{
    HRESULT Status;
    
    if ((Status = Win32LiveSystemProvider::
         EnumModules(Base, Path, PathChars)) != S_OK)
    {
        return Status;
    }

    TranslateNtPathName(Path);
    return S_OK;
}

HRESULT
NtWin32LiveSystemProvider::EnumFunctionTables(OUT PULONG64 MinAddress,
                                              OUT PULONG64 MaxAddress,
                                              OUT PULONG64 BaseAddress,
                                              OUT PULONG EntryCount,
                                              OUT PVOID RawTable,
                                              IN ULONG RawTableSize,
                                              OUT PVOID* RawEntryHandle)
{

#if defined(_AMD64_) || defined(_IA64_)

    if (RawTableSize != sizeof(DYNAMIC_FUNCTION_TABLE)) {
        return E_INVALIDARG;
    }
    
 Restart:
    
    if (!m_FuncTable || m_FuncTable == m_FuncTableHead) {
        return S_FALSE;
    }

    PDYNAMIC_FUNCTION_TABLE TableAddr =
#ifdef _AMD64_
        CONTAINING_RECORD(m_FuncTable, DYNAMIC_FUNCTION_TABLE, ListEntry);
#else
        CONTAINING_RECORD(m_FuncTable, DYNAMIC_FUNCTION_TABLE, Links);
#endif
    PDYNAMIC_FUNCTION_TABLE Table = (PDYNAMIC_FUNCTION_TABLE)RawTable;
    SIZE_T Done;

    if (!ReadProcessMemory(m_ProcessHandle, TableAddr,
                           Table, sizeof(*Table), &Done)) {
        return WIN32_LAST_STATUS();
    }
    if (Done != sizeof(*Table)) {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

#ifdef _AMD64_
    m_FuncTable = Table->ListEntry.Flink;
#else
    m_FuncTable = Table->Links.Flink;
#endif
    
    *MinAddress = (LONG_PTR)Table->MinimumAddress;
    *MaxAddress = (LONG_PTR)Table->MaximumAddress;
    *BaseAddress = (LONG_PTR)Table->BaseAddress;
    *RawEntryHandle = NULL;

    //
    // AMD64 and IA64 support a type of function table
    // where the data is retrieved via a callback rather
    // than being is a plain data table.  In order to
    // get at the data from out-of-process the table
    // must have an out-of-process access DLL registered.
    //
        
    if (Table->Type == RF_CALLBACK) {

        WCHAR DllName[MAX_PATH];
        HMODULE OopDll;
        POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK OopCb;

        if (!m_RtlFreeHeap) {
            return E_NOTIMPL;
        }
        
        if (!Table->OutOfProcessCallbackDll) {
            // No out-of-process access is possible.
            goto Restart;
        }

        if (!ReadProcessMemory(m_ProcessHandle,
                               Table->OutOfProcessCallbackDll,
                               DllName, sizeof(DllName) - sizeof(WCHAR),
                               &Done)) {
            goto Restart;
        }

        DllName[Done / sizeof(WCHAR)] = 0;

        OopDll = LoadLibraryW(DllName);
        if (!OopDll) {
            goto Restart;
        }

        OopCb = (POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK)GetProcAddress
            (OopDll, OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME);
        if (OopCb == NULL) {
            FreeLibrary(OopDll);
            goto Restart;
        }

        if (!NT_SUCCESS(OopCb(m_ProcessHandle,
                              TableAddr,
                              EntryCount,
                              (PRUNTIME_FUNCTION*)RawEntryHandle))) {
            FreeLibrary(OopDll);
            goto Restart;
        }

        FreeLibrary(OopDll);
    } else {
        *EntryCount = Table->EntryCount;
    }

    return S_OK;

#else
    
    return S_FALSE;

#endif
}

HRESULT
NtWin32LiveSystemProvider::EnumFunctionTableEntries(IN PVOID RawTable,
                                                    IN ULONG RawTableSize,
                                                    IN PVOID RawEntryHandle,
                                                    OUT PVOID RawEntries,
                                                    IN ULONG RawEntriesSize)
{
#if defined(_AMD64_) || defined(_IA64_)

    if (RawTableSize != sizeof(DYNAMIC_FUNCTION_TABLE)) {
        return E_INVALIDARG;
    }
    
    PDYNAMIC_FUNCTION_TABLE Table = (PDYNAMIC_FUNCTION_TABLE)RawTable;

    if (Table->Type == RF_CALLBACK) {
        memcpy(RawEntries, RawEntryHandle, RawEntriesSize);
        m_RtlFreeHeap(RtlProcessHeap(), 0, RawEntryHandle);
    } else {
        SIZE_T Done;
        
        if (!ReadProcessMemory(m_ProcessHandle,
                               Table->FunctionTable,
                               RawEntries,
                               RawEntriesSize,
                               &Done)) {
            return WIN32_LAST_STATUS();
        }
        if (Done != RawEntriesSize) {
            return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
        }
    }

    return S_OK;

#else

    return E_NOTIMPL;
    
#endif
}

HRESULT
NtWin32LiveSystemProvider::EnumFunctionTableEntryMemory(IN ULONG64 TableBase,
                                                        IN PVOID RawEntries,
                                                        IN ULONG Index,
                                                        OUT PULONG64 Start,
                                                        OUT PULONG Size)
{
#if defined(_IA64_) || defined(_AMD64_)
    UNWIND_INFO Info;
    PRUNTIME_FUNCTION FuncEnt = (PRUNTIME_FUNCTION)RawEntries + Index;
    SIZE_T Done;
#endif
                
#if defined(_IA64_)

    *Start = TableBase + FuncEnt->UnwindInfoAddress;
    if (!ReadProcessMemory(m_ProcessHandle, (PVOID)(ULONG_PTR)*Start,
                           &Info, sizeof(Info), &Done)) {
        return WIN32_LAST_STATUS();
    }
    if (Done != sizeof(Info)) {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
    *Size = sizeof(Info) + Info.DataLength * sizeof(ULONG64);
        
#elif defined(_AMD64_)

    *Start = TableBase + FuncEnt->UnwindData;
    if (!ReadProcessMemory(m_ProcessHandle, (PVOID)(ULONG_PTR)*Start,
                           &Info, sizeof(Info), &Done)) {
        return WIN32_LAST_STATUS();
    }
    if (Done != sizeof(Info)) {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
    *Size = sizeof(Info) + (Info.CountOfCodes - 1) * sizeof(UNWIND_CODE);
    // An extra alignment code and pointer may be added on to handle
    // the chained info case where the chain pointer is just
    // beyond the end of the normal code array.
    if ((Info.Flags & UNW_FLAG_CHAININFO) != 0) {
        if ((Info.CountOfCodes & 1) != 0) {
            (*Size) += sizeof(UNWIND_CODE);
        }
        (*Size) += sizeof(ULONG64);
    }
        
#endif

#if defined(_IA64_) || defined(_AMD64_)
    return S_OK;
#else
    return E_NOTIMPL;
#endif
}

HRESULT
NtWin32LiveSystemProvider::EnumUnloadedModules(OUT PWSTR Path,
                                               IN ULONG PathChars,
                                               OUT PULONG64 BaseOfModule,
                                               OUT PULONG SizeOfModule,
                                               OUT PULONG CheckSum,
                                               OUT PULONG TimeDateStamp)
{
    if (m_NumUnloads == 0) {
        return S_FALSE;
    }

    GenStrCopyNW(Path, m_Unload->ImageName, PathChars);
    *BaseOfModule = (LONG_PTR)m_Unload->BaseAddress;
    *SizeOfModule = (ULONG)m_Unload->SizeOfImage;
    *CheckSum = m_Unload->CheckSum;
    *TimeDateStamp = m_Unload->TimeDateStamp;

    if (m_Unload == m_Unloads + (m_UnloadArraySize - 1)) {
        m_Unload = m_Unloads;
    } else {
        m_Unload++;
    }
    m_NumUnloads--;

    return S_OK;
}

void
NtWin32LiveSystemProvider::FinishProcessEnum(void)
{
    if (m_Unloads) {
        HeapFree(GetProcessHeap(), 0, m_Unloads);
        m_Unloads = NULL;
    }
    Win32LiveSystemProvider::FinishProcessEnum();
}

HRESULT
NtWin32LiveSystemProvider::StartHandleEnum(IN HANDLE Process,
                                           IN ULONG ProcessId,
                                           OUT PULONG Count)
{
    NTSTATUS NtStatus;
    
    if (!m_NtQueryInformationProcess ||
        !m_NtQueryObject) {
        return E_NOTIMPL;
    }
        
    NtStatus = m_NtQueryInformationProcess(Process,
                                           ProcessHandleCount,
                                           Count,
                                           sizeof(*Count),
                                           NULL);
    if (!NT_SUCCESS(NtStatus)) {
        return HRESULT_FROM_NT(NtStatus);
    }

    m_ProcessHandle = Process ;
    m_Handle = 4;
    return S_OK;
}

HRESULT
NtWin32LiveSystemProvider::EnumHandles(OUT PULONG64 Handle,
                                       OUT PULONG Attributes,
                                       OUT PULONG GrantedAccess,
                                       OUT PULONG HandleCount,
                                       OUT PULONG PointerCount,
                                       OUT PWSTR TypeName,
                                       IN ULONG TypeNameChars,
                                       OUT PWSTR ObjectName,
                                       IN ULONG ObjectNameChars)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    NTSTATUS NtStatus;
    ULONG64 Buffer[1024 / sizeof(ULONG64)];
    POBJECT_TYPE_INFORMATION TypeInfo =
        (POBJECT_TYPE_INFORMATION)Buffer;
    POBJECT_NAME_INFORMATION NameInfo =
        (POBJECT_NAME_INFORMATION)Buffer;
    OBJECT_BASIC_INFORMATION BasicInfo;
    HANDLE Dup;
    ULONG Len;

    for (;;) {
        
        if (m_Handle >= (1 << 24)) {
            return S_FALSE;
        }
    
        if (::DuplicateHandle(m_ProcessHandle, UlongToHandle(m_Handle),
                              GetCurrentProcess(), &Dup,
                              0, FALSE, DUPLICATE_SAME_ACCESS)) {

            // If we can't get the basic info and type there isn't much
            // point in writing anything out so skip the handle.
            if (NT_SUCCESS(m_NtQueryObject(Dup, ObjectBasicInformation,
                                           &BasicInfo, sizeof(BasicInfo),
                                           NULL)) &&
                NT_SUCCESS(m_NtQueryObject(Dup, ObjectTypeInformation,
                                           TypeInfo, sizeof(Buffer), NULL))) {
                break;
            }
            
            ::CloseHandle(Dup);
        }
        
        m_Handle += 4;
    }
        
    Len = TypeInfo->TypeName.Length;
    if (Len > (TypeNameChars - 1) * sizeof(*TypeName)) {
        Len = (TypeNameChars - 1) * sizeof(*TypeName);
    }
    memcpy(TypeName, TypeInfo->TypeName.Buffer, Len);
    TypeName[Len / sizeof(*TypeName)] = 0;

    // Don't get the name of file objects as it
    // can cause deadlocks.  If we fail getting the
    // name just leave it out and don't consider it fatal.
    if (GenStrCompareW(TypeName, L"File") &&
        NT_SUCCESS(m_NtQueryObject(Dup, ObjectNameInformation,
                                   NameInfo, sizeof(Buffer), NULL)) &&
        NameInfo->Name.Buffer != NULL) {

        Len = NameInfo->Name.Length;
        if (Len > (ObjectNameChars - 1) * sizeof(*ObjectName)) {
            Len = (ObjectNameChars - 1) * sizeof(*ObjectName);
        }
        memcpy(ObjectName, NameInfo->Name.Buffer, Len);
        ObjectName[Len / sizeof(*ObjectName)] = 0;
    } else {
        ObjectName[0] = 0;
    }

    *Handle = m_Handle;
    *Attributes = BasicInfo.Attributes;
    *GrantedAccess = BasicInfo.GrantedAccess;
    *HandleCount = BasicInfo.HandleCount;
    *PointerCount = BasicInfo.PointerCount;

    ::CloseHandle(Dup);
    m_Handle += 4;
    return S_OK;
#endif // #ifdef _WIN32_WCE
}

void
NtWin32LiveSystemProvider::FinishHandleEnum(void)
{
    // Nothing to do.
}

HRESULT
NtWin32LiveSystemProvider::EnumPebMemory(IN HANDLE Process,
                                         IN ULONG64 PebOffset,
                                         IN ULONG PebSize,
                                         IN MiniDumpProviderCallbacks*
                                         Callback)
{
    HRESULT Status;
    PEB Peb;

    if (PebSize > sizeof(Peb)) {
        PebSize = sizeof(Peb);
    }
    
    if ((Status = ReadAllVirtual(Process, PebOffset, &Peb, PebSize)) != S_OK) {
        return Status;
    }
    
    //
    // Save the process parameters.
    //

    RTL_USER_PROCESS_PARAMETERS Params;

    if (Peb.ProcessParameters &&
        ReadAllVirtual(Process, (LONG_PTR)Peb.ProcessParameters,
                       &Params, sizeof(Params)) == S_OK) {

        Callback->EnumMemory((LONG_PTR)Peb.ProcessParameters, sizeof(Params));

        EnumUnicodeString(&Params.CurrentDirectory.DosPath, Callback);
        EnumUnicodeString(&Params.DllPath, Callback);
        EnumUnicodeString(&Params.ImagePathName, Callback);
        EnumUnicodeString(&Params.CommandLine, Callback);
        // There's no indicator of how big the environment is,
        // so just save an arbitrary amount.
        Callback->EnumMemory((LONG_PTR)Params.Environment, 8192);
        EnumUnicodeString(&Params.WindowTitle, Callback);
        EnumUnicodeString(&Params.DesktopInfo, Callback);
        EnumUnicodeString(&Params.ShellInfo, Callback);
        EnumUnicodeString(&Params.RuntimeData, Callback);
    }

    return S_OK;
}

HRESULT
NtWin32LiveSystemProvider::EnumTebMemory(IN HANDLE Process,
                                         IN HANDLE Thread,
                                         IN ULONG64 TebOffset,
                                         IN ULONG TebSize,
                                         IN MiniDumpProviderCallbacks*
                                         Callback)
{
    HRESULT Status;
    TEB Teb;
    
    if (TebSize > sizeof(Teb)) {
        TebSize = sizeof(Teb);
    }
    
    if ((Status = ReadAllVirtual(Process, TebOffset, &Teb, TebSize)) != S_OK) {
        return Status;
    }
    
    //
    // Save any TLS expansion.
    //

    if (m_BuildNumber >= NT_BUILD_WIN2K &&
        Teb.TlsExpansionSlots) {
        Callback->EnumMemory((LONG_PTR)Teb.TlsExpansionSlots,
                             TLS_EXPANSION_SLOTS * sizeof(ULONG_PTR));
    }

    //
    // Save FLS data.
    //

    if (m_BuildNumber > NT_BUILD_XP &&
        Teb.FlsData) {
        Callback->EnumMemory((LONG_PTR)Teb.FlsData,
                             (FLS_MAXIMUM_AVAILABLE + 2) * sizeof(ULONG_PTR));
    }
    
    return S_OK;
}

void
NtWin32LiveSystemProvider::TranslateNtPathName(IN OUT PWSTR Path)
{
    if (Path[0] == L'\\' &&
        Path[1] == L'?' &&
        Path[2] == L'?' &&
        Path[3] == L'\\')
    {
        ULONG Len = (GenStrLengthW(Path) + 1) * sizeof(*Path);
        
        if (Path[4] == L'U' &&
            Path[5] == L'N' &&
            Path[6] == L'C' &&
            Path[7] == L'\\')
        {
            // Compress \??\UNC\ to \\.
            memmove(Path + 1, Path + 7,
                    Len - 7 * sizeof(*Path));
        }
        else
        {
            // Remove \??\.
            memmove(Path, Path + 4,
                    Len - 4 * sizeof(*Path));
        }
    }
}

//----------------------------------------------------------------------------
//
// NtEnumModWin32LiveSystemProvider.
//
//----------------------------------------------------------------------------

class NtEnumModWin32LiveSystemProvider : public NtWin32LiveSystemProvider
{
public:
    NtEnumModWin32LiveSystemProvider(ULONG BuildNumber);
    ~NtEnumModWin32LiveSystemProvider(void);

    virtual void Release(void);
    virtual HRESULT StartProcessEnum(IN HANDLE Process,
                                     IN ULONG ProcessId);
    virtual HRESULT EnumModules(OUT PULONG64 Base,
                                OUT PWSTR Path,
                                IN ULONG PathChars);
    virtual void    FinishProcessEnum(void);
    
protected:
    HMODULE* m_ProcModules;
    ULONG m_NumProcModules;
};

NtEnumModWin32LiveSystemProvider::
NtEnumModWin32LiveSystemProvider(ULONG BuildNumber)
    : NtWin32LiveSystemProvider(BuildNumber)
{
    m_ProcModules = NULL;
    m_NumProcModules = 0;
}

NtEnumModWin32LiveSystemProvider::~NtEnumModWin32LiveSystemProvider(void)
{
    if (m_ProcModules) {
        HeapFree(GetProcessHeap(), 0, m_ProcModules);
    }
}

void
NtEnumModWin32LiveSystemProvider::Release(void)
{
    delete this;
}

HRESULT
NtEnumModWin32LiveSystemProvider::StartProcessEnum(IN HANDLE Process,
                                                   IN ULONG ProcessId)
{
    HRESULT Status;

    if (!m_EnumProcessModules ||
        !m_GetModuleFileNameExW) {
        return E_NOTIMPL;
    }
    
    if ((Status = NtWin32LiveSystemProvider::
         StartProcessEnum(Process, ProcessId)) != S_OK) {
        return Status;
    }

    ULONG ProcModSize = 16384;

    m_ProcModules = (HMODULE*)HeapAlloc(GetProcessHeap(), 0, ProcModSize);
    if (!m_ProcModules) {
        NtWin32LiveSystemProvider::FinishProcessEnum();
        return E_OUTOFMEMORY;
    }

    //
    // Walk module list, getting module information. Use PSAPI instead of
    // toolhelp since it it does not exhibit the deadlock issues with
    // the loader lock. ( on old versions of os )
    //

    ULONG Needed;
    
    if (!m_EnumProcessModules(Process,
                              m_ProcModules,
                              ProcModSize,
                              &Needed)) {
        Status = WIN32_LAST_STATUS();
        NtWin32LiveSystemProvider::FinishProcessEnum();
        HeapFree(GetProcessHeap(), 0, m_ProcModules);
        m_ProcModules = NULL;
        return Status;
    }

    m_NumProcModules = Needed / sizeof(m_ProcModules[0]);
    return S_OK;
}

HRESULT
NtEnumModWin32LiveSystemProvider::EnumModules(OUT PULONG64 Base,
                                              OUT PWSTR Path,
                                              IN ULONG PathChars)
{
    HRESULT Status;

    if (m_ModuleIndex >= m_NumProcModules) {
        return S_FALSE;
    }

    *Base = (LONG_PTR)m_ProcModules[m_ModuleIndex];
    if (!m_GetModuleFileNameExW(m_ProcessHandle,
                                m_ProcModules[m_ModuleIndex],
                                Path,
                                PathChars)) {
        return WIN32_LAST_STATUS();
    }

    TranslateNtPathName(Path);
    m_ModuleIndex++;
    return S_OK;
}

void
NtEnumModWin32LiveSystemProvider::FinishProcessEnum(void)
{
    HeapFree(GetProcessHeap(), 0, m_ProcModules);
    m_ProcModules = NULL;
    NtWin32LiveSystemProvider::FinishProcessEnum();
}

//----------------------------------------------------------------------------
//
// Nt4Win32LiveSystemProvider.
//
//----------------------------------------------------------------------------

class Nt4Win32LiveSystemProvider : public NtWin32LiveSystemProvider
{
public:
    Nt4Win32LiveSystemProvider(ULONG BuildNumber);
    ~Nt4Win32LiveSystemProvider(void);

    virtual void Release(void);
    virtual HRESULT StartProcessEnum(IN HANDLE Process,
                                     IN ULONG ProcessId);
    virtual HRESULT EnumThreads(OUT PULONG ThreadId);
    virtual HRESULT EnumModules(OUT PULONG64 Base,
                                OUT PWSTR Path,
                                IN ULONG PathChars);
    virtual void    FinishProcessEnum(void);
    
protected:
    PLIST_ENTRY m_LdrHead;
    PLIST_ENTRY m_LdrEntry;
    PNT4_SYSTEM_PROCESS_INFORMATION m_NtProcessInfo;
    PNT4_SYSTEM_THREAD_INFORMATION m_NtThread;
    ULONG m_NtThreads;
};

Nt4Win32LiveSystemProvider::
Nt4Win32LiveSystemProvider(ULONG BuildNumber)
    : NtWin32LiveSystemProvider(BuildNumber)
{
    m_NtProcessInfo = NULL;
}

Nt4Win32LiveSystemProvider::~Nt4Win32LiveSystemProvider(void)
{
    if (m_NtProcessInfo) {
        HeapFree(GetProcessHeap(), 0, m_NtProcessInfo);
    }
}

void
Nt4Win32LiveSystemProvider::Release(void)
{
    delete this;
}

HRESULT
Nt4Win32LiveSystemProvider::StartProcessEnum(IN HANDLE Process,
                                             IN ULONG ProcessId)
{
    NTSTATUS NtStatus;

    if (!m_NtQuerySystemInformation ||
        !m_NtQueryInformationProcess) {
        return E_NOTIMPL;
    }

    //
    // Get the head of the loaded module list.
    // Some system processes have no PEB and it's
    // possible for a process to not have a loader list.
    //
    
    NT4_PROCESS_BASIC_INFORMATION BasicInfo;
    PNT4_PEB Peb;
    PNT4_PEB_LDR_DATA Ldr;
    SIZE_T Done;

    NtStatus = m_NtQueryInformationProcess(Process,
                                           Nt4ProcessBasicInformation,
                                           &BasicInfo,
                                           sizeof(BasicInfo),
                                           NULL);
    if (!NT_SUCCESS(NtStatus)) {
        return HRESULT_FROM_NT(NtStatus);
    }

    m_LdrHead = NULL;
    m_LdrEntry = NULL;
    
    Peb = BasicInfo.PebBaseAddress;
    if (Peb) {

        if (!ReadProcessMemory(Process, &Peb->Ldr, &Ldr, sizeof(Ldr), &Done)) {
            return WIN32_LAST_STATUS();
        }
        if (Done < sizeof(Ldr)) {
            return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
        }

        if (Ldr) {
            m_LdrHead = &Ldr->InMemoryOrderModuleList;
            
            if (!ReadProcessMemory(Process, &m_LdrHead->Flink,
                                   &m_LdrEntry, sizeof(m_LdrEntry), &Done)) {
                return WIN32_LAST_STATUS();
            }
            if (Done < sizeof(m_LdrEntry)) {
                return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }
        }
    }
    
    //
    // Snap the set of threads in the process.
    //
    
    ULONG ProcInfoSize = 65536;

    do {

        if (m_NtProcessInfo) {
            HeapFree(GetProcessHeap(), 0, m_NtProcessInfo);
        }
        m_NtProcessInfo = (PNT4_SYSTEM_PROCESS_INFORMATION)
            HeapAlloc(GetProcessHeap(), 0, ProcInfoSize);
        if (!m_NtProcessInfo) {
            return E_OUTOFMEMORY;
        }
    
        NtStatus = m_NtQuerySystemInformation(Nt4SystemProcessInformation,
                                              m_NtProcessInfo,
                                              ProcInfoSize,
                                              NULL);
        if (NT_SUCCESS(NtStatus)) {
            break;
        } else if (NtStatus != STATUS_INFO_LENGTH_MISMATCH) {
            HeapFree(GetProcessHeap(), 0, m_NtProcessInfo);
            m_NtProcessInfo = NULL;
            return HRESULT_FROM_NT(NtStatus);
        }

        ProcInfoSize += 16384;

    } while (NtStatus == STATUS_INFO_LENGTH_MISMATCH);

    //
    // Find the correct process in the process list.
    //

    PNT4_SYSTEM_PROCESS_INFORMATION ProcInfo = m_NtProcessInfo;

    while (ProcInfo->NextEntryOffset &&
           ProcInfo->UniqueProcessId != (HANDLE)(ULONG_PTR)ProcessId) {

        ProcInfo = (PNT4_SYSTEM_PROCESS_INFORMATION)
            ((ULONG_PTR)ProcInfo + ProcInfo->NextEntryOffset);
    }

    if (ProcInfo->UniqueProcessId != (HANDLE)(ULONG_PTR)ProcessId) {
        // Could not find a matching process in the process list.
        HeapFree(GetProcessHeap(), 0, m_NtProcessInfo);
        m_NtProcessInfo = NULL;
        return E_NOINTERFACE;
    }
    
    m_NtThread = (PNT4_SYSTEM_THREAD_INFORMATION)(ProcInfo + 1);
    m_NtThreads = ProcInfo->NumberOfThreads;

    // Don't support function tables for NT4.
    m_FuncTableHead = NULL;
    m_FuncTable = NULL;

    // NT4 doesn't have an unloaded module list.
    m_Unloads = NULL;
    m_Unload = NULL;
    m_NumUnloads = 0;
    m_UnloadArraySize = 0;

    m_ProcessHandle = Process;
    m_ProcessId = ProcessId;
    
    return S_OK;
}

HRESULT
Nt4Win32LiveSystemProvider::EnumThreads(OUT PULONG ThreadId)
{
    if (m_NtThreads == 0) {
        return S_FALSE;
    }

    *ThreadId = (ULONG)(ULONG_PTR)m_NtThread->ClientId.UniqueThread;
    m_NtThread++;
    m_NtThreads--;
    return S_OK;
}

HRESULT
Nt4Win32LiveSystemProvider::EnumModules(OUT PULONG64 Base,
                                        OUT PWSTR Path,
                                        IN ULONG PathChars)
{
    HRESULT Status;

    if (!m_LdrEntry ||
        m_LdrEntry == m_LdrHead) {
        return S_FALSE;
    }

    PNT4_LDR_DATA_TABLE_ENTRY LdrEntry;
    NT4_LDR_DATA_TABLE_ENTRY LdrEntryData;
    SIZE_T Done;

    LdrEntry = CONTAINING_RECORD(m_LdrEntry,
                                 NT4_LDR_DATA_TABLE_ENTRY,
                                 InMemoryOrderLinks);

    if (!ReadProcessMemory(m_ProcessHandle, LdrEntry,
                           &LdrEntryData, sizeof(LdrEntryData), &Done)) {
        return WIN32_LAST_STATUS();
    }
    if (Done < sizeof(LdrEntryData)) {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    *Base = (LONG_PTR)LdrEntryData.DllBase;
    if (PathChars) {
        ULONG Read = LdrEntryData.FullDllName.Length;
        PathChars = (PathChars - 1) * sizeof(Path[0]);
        if (Read > PathChars) {
            Read = PathChars;
        }
        if (Read) {
            if (!ReadProcessMemory(m_ProcessHandle,
                                   LdrEntryData.FullDllName.Buffer,
                                   Path, Read, &Done)) {
                return WIN32_LAST_STATUS();
            }
            if (Done < Read) {
                return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }
        }
        Path[Read / sizeof(Path[0])] = 0;
    }
    
    TranslateNtPathName(Path);
    m_LdrEntry = LdrEntryData.InMemoryOrderLinks.Flink;
    return S_OK;
}

void
Nt4Win32LiveSystemProvider::FinishProcessEnum(void)
{
    HeapFree(GetProcessHeap(), 0, m_NtProcessInfo);
    m_NtProcessInfo = NULL;
}

//----------------------------------------------------------------------------
//
// NewNtWin32LiveSystemProvider.
//
//----------------------------------------------------------------------------

Win32LiveSystemProvider*
NewNtWin32LiveSystemProvider(ULONG BuildNumber)
{
    if (BuildNumber < NT_BUILD_WIN2K) {
        return new Nt4Win32LiveSystemProvider(BuildNumber);
    } else if (BuildNumber < NT_BUILD_TH_MODULES) {
        return new NtEnumModWin32LiveSystemProvider(BuildNumber);
    } else {
        return new NtWin32LiveSystemProvider(BuildNumber);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\addr.cpp ===
//----------------------------------------------------------------------------
//
// General ADDR routines.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

SHORT g_LastSelector = -1;
ULONG64 g_LastBaseOffset;

void
dprintAddr(PADDR Addr)
{
    switch(Addr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86 | FLAT_BASIS:
        dprintf("%s ", FormatAddr64(Addr->flat));
        break;
    case ADDR_V86:
    case ADDR_16:
        dprintf("%04x:%04x ", Addr->seg, (USHORT)Addr->off);
        break;
    case ADDR_1632:
        dprintf("%04x:%08lx ", Addr->seg, (ULONG)Addr->off);
        break;
    case ADDR_1664:
        dprintf("%04x:%s ", Addr->seg, FormatAddr64(Addr->off));
        break;
    case ADDR_FLAT:
        dprintf("%s ", FormatAddr64(Addr->off));
        break;
    }
}

void
sprintAddr(PSTR* Buffer, PADDR Addr)
{
    switch(Addr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86 | FLAT_BASIS:
        sprintf(*Buffer, "%s ", FormatAddr64(Addr->flat));
        break;
    case ADDR_V86:
    case ADDR_16:
        sprintf(*Buffer, "%04x:%04x ", Addr->seg, (USHORT)Addr->off);
        break;
    case ADDR_1632:
        sprintf(*Buffer, "%04x:%08lx ", Addr->seg, (ULONG)Addr->off);
        break;
    case ADDR_1664:
        sprintf(*Buffer, "%04x:%s ",
                Addr->seg, FormatAddr64(Addr->off));
        break;
    case ADDR_FLAT:
        sprintf(*Buffer, "%s ", FormatAddr64(Addr->off));
        break;
    }
    while (**Buffer)
    {
        (*Buffer)++;
    }
}

void
MaskOutAddr(ULONG Mask, PADDR Addr)
{
    switch(Addr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86 | FLAT_BASIS:
        MaskOut(Mask, "%s ", FormatAddr64(Addr->flat));
        break;
    case ADDR_V86:
    case ADDR_16:
        MaskOut(Mask, "%04x:%04x ", Addr->seg, (USHORT)Addr->off);
        break;
    case ADDR_1632:
        MaskOut(Mask, "%04x:%08lx ", Addr->seg, (ULONG)Addr->off);
        break;
    case ADDR_1664:
        MaskOut(Mask, "%04x:%s ", Addr->seg, FormatAddr64(Addr->off));
        break;
    case ADDR_FLAT:
        MaskOut(Mask, "%s ", FormatAddr64(Addr->off));
        break;
    }
}

void
ComputeNativeAddress(PADDR Addr)
{
    switch(Addr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86 | FLAT_BASIS:
        // Segment isn't actually used.
        Addr->seg = 0;
        Addr->off = Flat(*Addr) & 0xffff;
        break;
        
    case ADDR_V86:
        Addr->off = Flat(*Addr) - ((ULONG64)Addr->seg << 4);
        if (Addr->off > 0xffff)
        {
            ULONG64 excess = 1 + ((Addr->off - 0xffffL) >> 4);
            Addr->seg  += (USHORT)excess;
            Addr->off  -= excess << 4;
        }
        break;

    case ADDR_16:
    case ADDR_1632:
    case ADDR_1664:
        DESCRIPTOR64 Desc;

        if (Addr->seg != g_LastSelector)
        {
            if (g_Target->GetSelDescriptor(g_Thread, g_Machine,
                                           Addr->seg, &Desc) == S_OK)
            {
                g_LastSelector = Addr->seg;
                g_LastBaseOffset = Desc.Base;
            }
            else
            {
                g_LastSelector = -1;
                g_LastBaseOffset = 0;
            }
        }
        Addr->off = Flat(*Addr) - g_LastBaseOffset;
        break;

    case ADDR_FLAT:
        Addr->off = Flat(*Addr);
        break;

    default:
        return;
    }
}

void
ComputeFlatAddress(PADDR Addr, PDESCRIPTOR64 Desc)
{
    if (Addr->type & FLAT_COMPUTED)
    {
        return;
    }

    switch(Addr->type & (~INSTR_POINTER))
    {
    case ADDR_V86 | FLAT_BASIS:
        Flat(*Addr) = Addr->off;
        // Segment isn't actually used.
        Addr->seg = 0;
        Addr->off = Flat(*Addr) & 0xffff;
        break;
        
    case ADDR_V86:
        Addr->off &= 0xffff;
        Flat(*Addr) = ((ULONG64)Addr->seg << 4) + Addr->off;
        break;

    case ADDR_16:
        Addr->off &= 0xffff;

    case ADDR_1632:
    case ADDR_1664:
        DESCRIPTOR64 DescBuf;
        ULONG64 Base;

        if (Desc != NULL)
        {
            Base = Desc->Base;
        }
        else
        {
            if (Addr->seg != g_LastSelector)
            {
                if (g_Target->GetSelDescriptor(g_Thread, g_Machine,
                                               Addr->seg, &DescBuf) == S_OK)
                {
                    g_LastSelector = Addr->seg;
                    g_LastBaseOffset = DescBuf.Base;
                }
                else
                {
                    g_LastSelector = -1;
                    g_LastBaseOffset = 0;
                }
            }

            Base = g_LastBaseOffset;
        }
        
        if ((Addr->type & (~INSTR_POINTER)) != ADDR_1664)
        {
            Flat(*Addr) = EXTEND64((ULONG)Addr->off + (ULONG)Base);
        }
        else
        {
            Flat(*Addr) = Addr->off + Base;
        }
        break;

    case ADDR_FLAT:
        Flat(*Addr) = Addr->off;
        break;

    default:
        return;
    }

    Addr->type |= FLAT_COMPUTED;
}

PADDR
AddrAdd(PADDR Addr, ULONG64 Scalar)
{
    if (fnotFlat(*Addr))
    {
        ComputeFlatAddress(Addr, NULL);
    }

    Flat(*Addr) += Scalar;
    Addr->off += Scalar;
    
    switch(Addr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86:
        Addr->off = Flat(*Addr) - EXTEND64((ULONG64)Addr->seg << 4);
    case ADDR_V86 | FLAT_BASIS:
        if (Addr->off > 0xffff)
        {
            ULONG64 excess = 1 + ((Addr->off - 0x10000) >> 4);
            Addr->seg += (USHORT)excess;
            Addr->off -= excess << 4;
        }
        break;

    case ADDR_16:
        if (Addr->off > 0xffff)
        {
            Flat(*Addr) -= Addr->off & ~0xffff;
            Addr->off &= 0xffff;
        }
        break;
        
    case ADDR_1632:
        if (Addr->off > 0xffffffff)
        {
            Flat(*Addr) -= Addr->off & ~0xffffffff;
            Addr->off &= 0xffffffff;
        }
        break;
    }
    
    return Addr;
}

PADDR
AddrSub(PADDR Addr, ULONG64 Scalar)
{
    if (fnotFlat(*Addr))
    {
        ComputeFlatAddress(Addr, NULL);
    }

    Flat(*Addr) -= Scalar;
    Addr->off -= Scalar;

    switch(Addr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86:
        Addr->off = Flat(*Addr) - EXTEND64((ULONG64)Addr->seg << 4);
    case ADDR_V86 | FLAT_BASIS:
        if (Addr->off > 0xffff)
        {
            ULONG64 excess = 1 + ((0xffffffffffffffffUI64 - Addr->off) >> 4);
            Addr->seg -= (USHORT)excess;
            Addr->off += excess << 4;
        }
        break;

    case ADDR_16:
        if (Addr->off > 0xffff)
        {
            Flat(*Addr) -= Addr->off & ~0xffff;
            Addr->off &= 0xffff;
        }
        break;
        
    case ADDR_1632:
        if (Addr->off > 0xffffffff)
        {
            Flat(*Addr) -= Addr->off & ~0xffffffff;
            Addr->off &= 0xffffffff;
        }
        break;
    }
    
    return Addr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\msi\makefile.inc ===
i386\dbgx.msi: dbgx_idts\*.idt dbgx_idts\binary\* dbgx_idts\i386\*.idt 
    createdbgxmsi.cmd dbgx.msi

ia64\dbgx.msi: dbgx_idts\*.idt dbgx_idts\binary\* dbgx_idts\ia64\*.idt
    createdbgxmsi.cmd dbgx.msi

amd64\dbgx.msi: dbgx_idts\*.idt dbgx_idts\binary\* dbgx_idts\amd64\*.idt
    createdbgxmsi.cmd dbgx.msi
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\addr.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _ADDR_H_
#define _ADDR_H_

typedef struct _ADDR
{
    USHORT    type;
    USHORT    seg;
    ULONG64   off;
    ULONG64   flat;
} ADDR, *PADDR;

#define ADDRFLAT(paddr, x) {           \
    (paddr)->type = ADDR_FLAT;         \
    (paddr)->seg  = 0;                 \
    (paddr)->off  = (x);               \
    ComputeFlatAddress((paddr), NULL); \
}


#define ADDR_NONE       ((USHORT)0)
#define ADDR_UNKNOWN    ((USHORT)0x0001)
#define ADDR_V86        ((USHORT)0x0002)
#define ADDR_16         ((USHORT)0x0004)
#define ADDR_FLAT       ((USHORT)0x0008)
#define ADDR_1632       ((USHORT)0x0010)
#define FLAT_COMPUTED   ((USHORT)0x0020)
#define INSTR_POINTER   ((USHORT)0x0040)
#define ADDR_1664       ((USHORT)0x0080)
#define FLAT_BASIS      ((USHORT)0x0100)
#define NO_DEFAULT      0xFFFF
#define fnotFlat(x)     (!(((x).type) & FLAT_COMPUTED))
#define fFlat(x)        (((x).type) & FLAT_COMPUTED)
#define fInstrPtr(x)    (((x).type) & INSTR_POINTER)
#define AddrEqu(x,y)    ((x).flat == (y).flat)
#define AddrLt(x,y)     ((x).flat < (y).flat)
#define AddrGt(x,y)     ((x).flat > (y).flat)
#define AddrDiff(x,y)   ((x).flat - (y).flat)
#define Flat(x)         ((x).flat)
#define Off(x)          ((x).off)
#define Type(x)         ((x).type)
#define NotFlat(x)      ((x).type &= ~FLAT_COMPUTED)

extern SHORT g_LastSelector;
extern ULONG64 g_LastBaseOffset;

extern void ComputeFlatAddress(PADDR Addr, PDESCRIPTOR64 Desc);
extern void ComputeNativeAddress(PADDR Addr);

extern PADDR AddrAdd(PADDR Addr, ULONG64 Scalar);
extern PADDR AddrSub(PADDR, ULONG64 Scalar);

void dprintAddr(IN PADDR Addr);
void sprintAddr(IN OUT PSTR* Buffer, IN PADDR Addr);
void MaskOutAddr(ULONG Mask, PADDR Addr);

#define ClearAddr(Addr) \
    ZeroMemory(Addr, sizeof(ADDR))

#endif // #ifndef _ADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\alias.cpp ===
//----------------------------------------------------------------------------
//
// Establish, maintain, and translate alias command tokens.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
// Revision History:
//
//  [-]  08-Aug-1999 RichG      Created.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

PALIAS g_AliasListHead;                 // List of alias elements
ULONG  g_NumAliases;

HRESULT
SetAlias(PCSTR SrcText, PCSTR DstText)
{
    PALIAS PrevAlias;
    PALIAS CurAlias;
    PALIAS NewAlias;

    NewAlias = (PALIAS)malloc( sizeof(ALIAS) + strlen(SrcText) +
                               strlen(DstText) + 2 );
    if (!NewAlias)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Locate Alias, or insertion point
    //
    //  This insertion scheme maintains a sorted list of
    //  alias elements by name.
    //

    PrevAlias = NULL;
    CurAlias  = g_AliasListHead;

    while (( CurAlias != NULL )  &&
           ( strcmp( SrcText, CurAlias->Name ) > 0 ))
    {
        PrevAlias = CurAlias;
        CurAlias  = CurAlias->Next;
    }

    //  If there is already an element by that name, clear it.
    if (CurAlias != NULL &&
        !strcmp(SrcText, CurAlias->Name))
    {
        PALIAS TmpAlias = CurAlias->Next;
        free(CurAlias);
        CurAlias = TmpAlias;
        g_NumAliases--;
    }

    NewAlias->Next = CurAlias;
    if (PrevAlias == NULL)
    {
        g_AliasListHead = NewAlias;
    }
    else
    {
        PrevAlias->Next = NewAlias;
    }
    
    NewAlias->Name = (PSTR)(NewAlias + 1);
    NewAlias->Value = NewAlias->Name + strlen(SrcText) + 1;
    strcpy( NewAlias->Name, SrcText  );
    strcpy( NewAlias->Value, DstText );
    g_NumAliases++;

    NotifyChangeEngineState(DEBUG_CES_TEXT_REPLACEMENTS, DEBUG_ANY_ID, TRUE);
    return S_OK;
}

/*** ParseSetAlias - Set an alias expression
*
*   Purpose:
*       From the current command line position at g_CurCmd,
*       read the alias name and value tokens.  Once obtained
*       perform an alias list lookup to see if it is a redefinition.
*       If not allocate a new alias element and place it on the
*       alias element list.
*
*
*   Input:
*       Global: g_CurCmd - command line position
*       Global: g_AliasListHead
*
*   Returns:
*       Status
*
*   Exceptions:
*       error exit: SYNTAX errors
*
*************************************************************************/

void
ParseSetAlias(void)
{
    PSTR AliasName;
    PSTR AliasValue;
    CHAR Ch;

    //
    //  Locate alias name
    //
    PeekChar();

    AliasName = g_CurCmd;

    do
    {
        Ch = *g_CurCmd++;
    } while (Ch != ' ' && Ch != '\t' && Ch != '\0' && Ch != ';');

    if ( (ULONG_PTR)(g_CurCmd - 1) == (ULONG_PTR)AliasName )
    {
        error(SYNTAX);
    }

    *--g_CurCmd = '\0';       // Back up and null terminate
                              // the alias name token
    g_CurCmd++;               // -> next char

    //
    //   Locate alias value,  take remaining cmd line as value
    //

    PeekChar();

    AliasValue = g_CurCmd;

    do
    {
        Ch = *g_CurCmd++;
    } while (Ch != '\t' && Ch != '\0');

    if ( (ULONG_PTR)(g_CurCmd - 1) == (ULONG_PTR)AliasValue )
    {
        error(SYNTAX);
    }

    *--g_CurCmd = '\0';       // Back up and Null terminate
                              // the alias value token

    if (SetAlias(AliasName, AliasValue) != S_OK)
    {
        error(MEMORY);
    }
}

HRESULT
DeleteAlias(PCSTR SrcText)
{
    PALIAS CurAlias;

    if (SrcText[0] == '*' && SrcText[1] == 0)
    {
        //
        //  Delete all aliases
        //
        while ( g_AliasListHead != NULL )
        {
            //
            //  Unchain the element and free it
            //
            CurAlias = g_AliasListHead->Next;
            free(g_AliasListHead);
            g_AliasListHead = CurAlias;
        }

        g_NumAliases = 0;
    }
    else
    {
        PALIAS PrevAlias;
    
        //
        //  Locate and delete the specified alias
        //

        PrevAlias = NULL;
        CurAlias  = g_AliasListHead;

        while (( CurAlias != NULL )  &&
               ( strcmp( SrcText, CurAlias->Name )))
        {
            PrevAlias = CurAlias;
            CurAlias  = CurAlias->Next;
        }

        if ( CurAlias == NULL )
        {
            return E_NOINTERFACE;
        }

        //
        //  Unchain the element and free it
        //
        if (PrevAlias == NULL)
        {
            g_AliasListHead = CurAlias->Next;
        }
        else
        {
            PrevAlias->Next = CurAlias->Next;
        }
        free( CurAlias );
        g_NumAliases--;
    }

    NotifyChangeEngineState(DEBUG_CES_TEXT_REPLACEMENTS, DEBUG_ANY_ID, TRUE);
    return S_OK;
}

/*** ParseDeleteAlias - Delete an alias expression
*
*   Purpose:
*       From the current command line position at g_CurCmd,
*       read the ALias name and perform an alias list lookup
*       to see if it exists and unlink and delete the element.
*
*
*   Input:
*       Global: g_CurCmd - command line position
*       Global: g_AliasListHead
*
*   Returns:
*       Status
*
*   Exceptions:
*       error exit: SYNTAX errors or non-existent element
*
*************************************************************************/

void
ParseDeleteAlias(void)
{
    PSTR  AliasName;
    UCHAR Ch;

    //
    //  Locate alias name on cmd line
    //
    PeekChar();

    AliasName = g_CurCmd;

    do
    {
        Ch = *g_CurCmd++;
    } while (Ch != ' ' && Ch != '\t' && Ch != '\0' && Ch != ';');

    if ( (ULONG_PTR)(g_CurCmd - 1) == (ULONG_PTR)AliasName )
    {
        error(SYNTAX);
    }

    *--g_CurCmd = '\0';       // Null terminate the token
    if (Ch != '\0')
    {
        g_CurCmd++;
    }

    if (DeleteAlias(AliasName) != S_OK)
    {
        error(NOTFOUND);
    }
}

/*** ListAliases - List the alias structures
*
*   Purpose:
*       Read and display all of the alias list elements.
*
*
*   Input:
*       Global:  g_AliasListHead
*
*   Returns:
*       Status
*
*   Exceptions:
*       None
*
*************************************************************************/

void
ListAliases(void)
{
    PALIAS CurAlias;

    CurAlias = g_AliasListHead;

    if ( CurAlias == NULL )
    {
        dprintf( "No Alias entries to list. \n" );
        return;
    }

    dprintf   ("  Alias            Value  \n");
    dprintf   (" -------          ------- \n");

    while ( CurAlias != NULL )
    {
        dprintf(" %-16s %s \n", CurAlias->Name, CurAlias->Value);
        CurAlias = CurAlias->Next;
    }
}

void
DotAliasCmds(PDOT_COMMAND Cmd, DebugClient* Client)
{
    PALIAS CurAlias = g_AliasListHead;
    while ( CurAlias != NULL )
    {
        dprintf("as %s %s\n", CurAlias->Name, CurAlias->Value);
        CurAlias = CurAlias->Next;
    }
}

/*** ReplaceAliases - Replace aliases in the given command string
*
*   Purpose:
*       From the current command line position at g_CurCmd,
*       read each token and build a new command line, replacing
*       tokens with alias value data.  A lookup is performed on
*       each original command line token to determine if it is
*       defined in the alias list.  If so it is replaced on the
*       new command line,  otherwise the original token is
*       placed on the new command line.
*
*************************************************************************/

void
ReplaceAliases(PSTR CommandString, ULONG CommandStringSize)
{
    PSTR        Command = CommandString;
    CHAR       *Token;
    CHAR        Ch;
    CHAR        Delim[2];
    CHAR        AliasCommandBuf[MAX_COMMAND];      //  Alias build command area
    CHAR       *AliasCommand;
    ULONG       AliasCommandSize;
    ULONG       TokenLen;
    PALIAS      CurAlias;
    BOOLEAN     LineEnd;
    ULONG       StrLen;

    // If the incoming command looks like an alias-manipulation
    // command don't replace aliases.
    if (CommandString[0] == 'a' &&
        (CommandString[1] == 'd' ||
         CommandString[1] == 'l' ||
         CommandString[1] == 's'))
    {
        return;
    }

    // If the incoming command is all spaces it's probably
    // the result of control characters getting mapped to
    // spaces.  Don't process it as there can't be any
    // aliases and we don't want the trailing space trimming
    // to remove the input space.
    while (*Command == ' ')
    {
        Command++;
    }
    if (*Command == 0)
    {
        return;
    }

    Command = CommandString;
    AliasCommand = AliasCommandBuf;
    AliasCommandSize = DIMA(AliasCommandBuf);

    ZeroMemory( AliasCommand, sizeof(AliasCommandBuf) );

    LineEnd = FALSE;

    do
    {
        //
        //  Locate command line token
        //
        while (isspace(*Command))
        {
            PSTR AliasCmdEnd;

            StrLen = strlen(AliasCommand);
            AliasCmdEnd = AliasCommand + StrLen;
            if (StrLen + 1 == AliasCommandSize)
            {
                // Overflow.
                return;
            }
            *AliasCmdEnd++ = *Command++;
            *AliasCmdEnd = 0;
        }
       
        Token = Command;

        do
        {
            Ch = *Command++;
        } while (Ch != ' '  &&
                 Ch != '\'' &&
                 Ch != '"'  &&
                 Ch != ';'  &&
                 Ch != '\t' &&
                 Ch != '\0');

        //
        //  Preserve the token delimiter
        //
        Delim[0] = Ch;
        Delim[1] = '\0';

        if ( Ch == '\0' )
        {
            LineEnd = TRUE;
        }

        TokenLen = (ULONG)((Command - 1) - Token);

        if ( TokenLen != 0 )
        {
            *--Command = '\0';       // Null terminate the string
            Command++;
            Ch = *Command;

            //
            //  Locate Alias or end of list
            //
            CurAlias = g_AliasListHead;

            while (( CurAlias != NULL )  &&
                   ( strcmp( Token, CurAlias->Name )))
            {
                CurAlias = CurAlias->Next;
            }

            if ( CurAlias != NULL )
            {
                CatString( AliasCommand, CurAlias->Value, AliasCommandSize );
            }
            else
            {
                CatString( AliasCommand, Token, AliasCommandSize );
            }
        }
        CatString( AliasCommand, Delim, AliasCommandSize );

    } while( !LineEnd );

    //
    //  Strip off any trailing blanks
    //
    AliasCommand += strlen( AliasCommand );
    Ch = *AliasCommand;
    while ( Ch == '\0' || Ch == ' ' )
    {
        *AliasCommand = '\0';
        Ch = *--AliasCommand;
    }

    //
    //  Place the new command line in the command string buffer.
    //
    CopyString( CommandString, AliasCommandBuf, CommandStringSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\amd64_dis.cpp ===
//----------------------------------------------------------------------------
//
// Disassembly portions of AMD64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#define BIT20(b) ((b) & 0x07)
#define BIT53(b) (((b) >> 3) & 0x07)
#define BIT76(b) (((b) >> 6) & 0x03)

HRESULT
Amd64MachineInfo::NewBreakpoint(DebugClient* Client, 
                                ULONG Type,
                                ULONG Id,
                                Breakpoint** RetBp)
{
    HRESULT Status;

    switch(Type & (DEBUG_BREAKPOINT_CODE | DEBUG_BREAKPOINT_DATA))
    {
    case DEBUG_BREAKPOINT_CODE:
        *RetBp = new CodeBreakpoint(Client, Id, IMAGE_FILE_MACHINE_AMD64);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    case DEBUG_BREAKPOINT_DATA:
        *RetBp = new X86DataBreakpoint(Client, Id, AMD64_CR4,
                                       IS_KERNEL_TARGET(m_Target) ?
                                       AMD64_KDR6 : AMD64_DR6,
                                       IMAGE_FILE_MACHINE_AMD64);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    default:
        // Unknown breakpoint type.
        Status = E_NOINTERFACE;
    }

    return Status;
}

void
Amd64MachineInfo::InsertThreadDataBreakpoints(void)
{
    ULONG64 Dr7Value;
    ULONG Dr6Idx, Dr7Idx, Dr0Idx;

    BpOut("Thread %d data breaks %d\n",
          g_Thread->m_UserId, g_Thread->m_NumDataBreaks);

    if (IS_KERNEL_TARGET(m_Target))
    {
        Dr6Idx = AMD64_KDR6;
        Dr7Idx = AMD64_KDR7;
        Dr0Idx = AMD64_KDR0;
    }
    else
    {
        Dr6Idx = AMD64_DR6;
        Dr7Idx = AMD64_DR7;
        Dr0Idx = AMD64_DR0;
    }
               
    // Start with all breaks turned off.
    Dr7Value = GetReg64(Dr7Idx) & ~X86_DR7_CTRL_03_MASK;
    
    if (g_Thread->m_NumDataBreaks > 0)
    {
        ULONG i;
                
        for (i = 0; i < g_Thread->m_NumDataBreaks; i++)
        {
            X86DataBreakpoint* Bp =
                (X86DataBreakpoint *)g_Thread->m_DataBreakBps[i];
                    
            ULONG64 Addr = Flat(*Bp->GetAddr());
            BpOut("  dbp %d at %I64x\n", i, Addr);
            if (g_DataBreakpointsChanged)
            {
                SetReg64(Dr0Idx + i, Addr);
            }
            // There are two enable bits per breakpoint
            // and four len/rw bits so split up enables
            // and len/rw when shifting into place.
            Dr7Value |=
                ((Bp->m_Dr7Bits & 0xffff0000) << (i * 4)) |
                ((Bp->m_Dr7Bits & X86_DR7_ALL_ENABLES) << (i * 2));
        }

        // The kernel automatically clears DR6 when it
        // processes a DBGKD_CONTROL_SET.
        if (IS_USER_TARGET(m_Target))
        {
            SetReg64(Dr6Idx, 0);
        }
                
        // Set local exact match, which is effectively global on NT.
        Dr7Value |= X86_DR7_LOCAL_EXACT_ENABLE;
    }

    BpOut("  thread %d DR7 %I64X\n", g_Thread->m_UserId, Dr7Value);
    SetReg64(Dr7Idx, Dr7Value);
}

void
Amd64MachineInfo::RemoveThreadDataBreakpoints(void)
{
    SetReg64(IS_KERNEL_TARGET(m_Target) ? AMD64_KDR7 : AMD64_DR7, 0);
}

ULONG
Amd64MachineInfo::IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr)
{
    if (Record->ExceptionCode == STATUS_BREAKPOINT)
    {
        // Data breakpoints hit as STATUS_SINGLE_STEP so
        // this can only be a code breakpoint.
        if (IS_USER_TARGET(m_Target) && FirstChance)
        {
            // Back up to the actual breakpoint instruction.
            AddrSub(BpAddr, X86_INT3_LEN);
            SetPC(BpAddr);
        }
        return EXBS_BREAKPOINT_CODE;
    }
    else if (Record->ExceptionCode == STATUS_SINGLE_STEP)
    {
        ULONG64 Dr6;
        ULONG64 Dr7;

        if (IS_KERNEL_TARGET(m_Target))
        {
            Dr6 = GetReg64(AMD64_KDR6);
            Dr7 = GetReg64(AMD64_KDR7);
        }
        else
        {
            Dr6 = GetReg64(AMD64_DR6);
            Dr7 = GetReg64(AMD64_DR7);
        }

        BpOut("Amd64 step: DR6 %I64X, DR7 %I64X\n", Dr6, Dr7);

        // The single step bit should always be clear if a data breakpoint
        // is hit but also check the DR7 enables just in case.
        // We've also seen cases where DR6 shows no hits, so consider
        // that a single step also.
        if ((Dr6 & X86_DR6_SINGLE_STEP) || (Dr7 & X86_DR7_ALL_ENABLES) == 0 ||
            (Dr6 & X86_DR6_BREAK_03) == 0)
        {
            // This is a true single step exception, not
            // a data breakpoint.
            return EXBS_STEP_INSTRUCTION;
        }
        else
        {
            // Some data breakpoint must be hit.
            // There doesn't appear to be any way to get the
            // faulting instruction address so just leave the PC.
            return EXBS_BREAKPOINT_DATA;
        }
    }

    return EXBS_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\alias.hpp ===
//----------------------------------------------------------------------------
//
// Establish, maintain, and translate alias command tokens.
//
// 08-Aug-1999 Richg      Created.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __ALIAS_HPP__
#define __ALIAS_HPP__

/************************************************************************
 *                                                                      *
 *  Name:     ALIAS structure                                           *
 *                                                                      *
 *  Purpose:  Structure used to contain Alias elements. This sturcture  *
 *            is only forward linked (Next.flink).                      *
 *                                                                      *
 *            This structure is allocated by fnSetAliasExpression( )    *
 *            and freed by fnDeleteAliasExpression( ).                  *
 *                                                                      *
 *  Anchor:   AliasListHead                                             *
 *                                                                      *
 ************************************************************************/
typedef struct _ALIAS
{
    struct _ALIAS* Next;                // Link
    PSTR           Name;                // Name\text of aliased token
    PSTR           Value;               // Alias text
} ALIAS, *PALIAS;

extern PALIAS g_AliasListHead;
extern ULONG  g_NumAliases;

HRESULT SetAlias(PCSTR SrcText, PCSTR DstText);
void    ParseSetAlias(void);
HRESULT DeleteAlias(PCSTR SrcText);
void    ParseDeleteAlias(void);
void    ListAliases(void);
void    DotAliasCmds(PDOT_COMMAND Cmd, DebugClient* Client);

void    ReplaceAliases(PSTR CommandString, ULONG CommandStringSize);

#endif // #ifndef __ALIAS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\amd64_mach.hpp ===
//----------------------------------------------------------------------------
//
// AMD64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __AMD64_MACH_HPP__
#define __AMD64_MACH_HPP__

//
// NOTE: Be very careful when using machine-specific header files
// such as nt<plat>.h.  The machine implementation class is
// compiled for all platforms so the nt<plat>.h file will be the
// one for the build platform, not necessarily the platform
// of the machine implementation.  ntdbg.h contains many cross-platform
// types and definitions that can be used to avoid problems.
//

#define AMD64_MAX_INSTRUCTION_LEN 16

class Amd64MachineInfo : public BaseX86MachineInfo
{
public:
    Amd64MachineInfo(TargetInfo* Target);

    // MachineInfo.
    virtual HRESULT Initialize(void);
    
    virtual void GetSystemTypeInfo(PSYSTEM_TYPE_INFO Info);
    virtual void GetDefaultKdData(PKDDEBUGGER_DATA64 KdData);
    
    virtual void InitializeContext
        (ULONG64 Pc, PDBGKD_ANY_CONTROL_REPORT ControlReport);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);
    virtual HRESULT ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG FromSver,
                                       ULONG FromSize, PVOID From);
    virtual HRESULT ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG ToSver, ULONG ToSize, PVOID To);
    virtual void InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version);
    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              ULONG64 Stack);
    virtual HRESULT GetContextFromFiber(ProcessInfo* Process,
                                        ULONG64 FiberBase,
                                        PCROSS_PLATFORM_CONTEXT Context,
                                        BOOL Verbose);
    virtual HRESULT GetContextFromTrapFrame(ULONG64 TrapBase,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            BOOL Verbose);
    virtual void GetScopeFrameFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                          PDEBUG_STACK_FRAME ScopeFrame);
    virtual HRESULT GetScopeFrameRegister(ULONG Reg,
                                          PDEBUG_STACK_FRAME ScopeFrame,
                                          PULONG64 Value);
    virtual HRESULT SetScopeFrameRegister(ULONG Reg,
                                          PDEBUG_STACK_FRAME ScopeFrame,
                                          ULONG64 Value);

    virtual HRESULT GetExdiContext(IUnknown* Exdi,
                                   PEXDI_CONTEXT Context,
                                   EXDI_CONTEXT_TYPE CtxType);
    virtual HRESULT SetExdiContext(IUnknown* Exdi,
                                   PEXDI_CONTEXT Context,
                                   EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                               PEXDI_CONTEXT ExdiContext,
                                               EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                             EXDI_CONTEXT_TYPE CtxType,
                                             PCROSS_PLATFORM_CONTEXT Context);
    virtual void ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                              EXDI_CONTEXT_TYPE CtxType,
                                              ULONG Start, ULONG Count,
                                              PDESCRIPTOR64 Descs);
    virtual void ConvertExdiContextFromSpecial
        (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
         PEXDI_CONTEXT ExdiContext,
         EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextToSpecial
        (PEXDI_CONTEXT ExdiContext,
         EXDI_CONTEXT_TYPE CtxType,
         PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    
    virtual int GetType(ULONG Reg);
    virtual HRESULT GetVal(ULONG Reg, REGVAL* Val);
    virtual HRESULT SetVal(ULONG Reg, REGVAL* Val);

    virtual void GetPC(PADDR Address);
    virtual void SetPC(PADDR Address);
    virtual void GetFP(PADDR Address);
    virtual void GetSP(PADDR Address);
    virtual ULONG64 GetArgReg(void);
    virtual ULONG64 GetRetReg(void);
    virtual ULONG GetSegRegNum(ULONG SegReg);
    virtual HRESULT GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc);

    virtual void OutputAll(ULONG Mask, ULONG OutMask);

    virtual HRESULT SetAndOutputTrapFrame(ULONG64 TrapBase,
                                          PCROSS_PLATFORM_CONTEXT Context);

    virtual TRACEMODE GetTraceMode(void);
    virtual void SetTraceMode(TRACEMODE Mode);
    virtual BOOL IsStepStatusSupported(ULONG Status);

    virtual void KdUpdateControlSet
        (PDBGKD_ANY_CONTROL_SET ControlSet);

    virtual ULONG ExecutingMachine(void);

    virtual HRESULT SetPageDirectory(ThreadInfo* Thread,
                                     ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ThreadInfo* Thread, ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastVal);
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset);
    virtual void DecodePte(ULONG64 Pte, PULONG64 PageFrameNumber,
                           PULONG Flags);

    virtual HRESULT NewBreakpoint(DebugClient* Client, 
                                  ULONG Type, 
                                  ULONG Id, 
                                  Breakpoint** RetBp);

    virtual void InsertThreadDataBreakpoints(void);
    virtual void RemoveThreadDataBreakpoints(void);
    virtual ULONG IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr, 
                                              PADDR RelAddr);
    
    virtual void OutputFunctionEntry(PVOID RawEntry);
    virtual HRESULT ReadDynamicFunctionTable(ProcessInfo* Process,
                                             ULONG64 Table,
                                             PULONG64 NextTable,
                                             PULONG64 MinAddress,
                                             PULONG64 MaxAddress,
                                             PULONG64 BaseAddress,
                                             PULONG64 TableData,
                                             PULONG TableSize,
                                             PWSTR OutOfProcessDll,
                                             PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable);
    virtual PVOID FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize);
    virtual HRESULT GetUnwindInfoBounds(ProcessInfo* Process,
                                        ULONG64 TableBase,
                                        PVOID RawTableEntries,
                                        ULONG EntryIndex,
                                        PULONG64 Start,
                                        PULONG Size);
    
    virtual HRESULT ReadKernelProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);
        
    // Amd64MachineInfo.
    
    static HRESULT StaticGetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context,
                                        EXDI_CONTEXT_TYPE CtxType);

    BOOL IsIa32CodeSegment(void)
    {
        return GetReg16(AMD64_CS) == m_Target->m_KdDebuggerData.Gdt64R3CmCode;
    }
};

extern BOOL g_Amd64InCode64;

#endif // #ifndef __AMD64_MACH_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\amd64_reg.h ===
//----------------------------------------------------------------------------
//
// AMD64 register definitions.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __AMD64_REG_H__
#define __AMD64_REG_H__

//
// x86 common registers.
//

#define	AMD64_RAX		X86_NAX
#define	AMD64_RCX	        X86_NCX
#define	AMD64_RDX		X86_NDX
#define	AMD64_RBX		X86_NBX
#define	AMD64_RSP		X86_NSP
#define	AMD64_RBP		X86_NBP
#define	AMD64_RSI		X86_NSI
#define	AMD64_RDI	        X86_NDI
#define	AMD64_RIP		X86_NIP

#define	AMD64_EFL		X86_NFL

#define	AMD64_CS		X86_NCS
#define	AMD64_DS		X86_NDS
#define	AMD64_ES		X86_NES
#define	AMD64_FS		X86_NFS
#define	AMD64_GS	        X86_NGS
#define	AMD64_SS		X86_NSS

#define AMD64_SEG_FIRST         X86_NSEG_FIRST
#define AMD64_SEG_LAST          X86_NSEG_LAST

//
// AMD64 registers.
//

#define AMD64_R8                17
#define AMD64_R9                18
#define AMD64_R10               19
#define AMD64_R11               20
#define AMD64_R12               21
#define AMD64_R13               22
#define AMD64_R14               23
#define AMD64_R15               24

#define AMD64_CR0		25
#define AMD64_CR2		26
#define AMD64_CR3		27
#define AMD64_CR4               28
#define AMD64_CR8               29

#define AMD64_DR0               30
#define AMD64_DR1               31
#define AMD64_DR2               32
#define AMD64_DR3               33
#define AMD64_DR6               34
#define AMD64_DR7               35

#define AMD64_GDTR              36
#define AMD64_GDTL              37
#define AMD64_IDTR              38
#define AMD64_IDTL              39
#define AMD64_TR                40
#define AMD64_LDTR              41
#define AMD64_KMXCSR            42
#define AMD64_KDR0              43
#define AMD64_KDR1              44
#define AMD64_KDR2              45
#define AMD64_KDR3              46
#define AMD64_KDR6              47
#define AMD64_KDR7              48

// Floating-point registers:
#define AMD64_FPCW              50
#define AMD64_FPSW              51
#define AMD64_FPTW              52

#define AMD64_FPCTRL_FIRST      AMD64_FPCW
#define AMD64_FPCTRL_LAST       AMD64_FPTW

#define AMD64_ST0               53
#define AMD64_ST1               54
#define AMD64_ST2               55
#define AMD64_ST3               56
#define AMD64_ST4               57
#define AMD64_ST5               58
#define AMD64_ST6               59
#define AMD64_ST7               60

#define AMD64_ST_FIRST          AMD64_ST0
#define AMD64_ST_LAST           AMD64_ST7

// MMX registers:
#define AMD64_MM0               61
#define AMD64_MM1               62
#define AMD64_MM2               63
#define AMD64_MM3               64
#define AMD64_MM4               65
#define AMD64_MM5               66
#define AMD64_MM6               67
#define AMD64_MM7               68

#define AMD64_MM_FIRST          AMD64_MM0
#define AMD64_MM_LAST           AMD64_MM7

// SSE registers:
#define AMD64_MXCSR             69

#define AMD64_XMM0              70
#define AMD64_XMM1              71
#define AMD64_XMM2              72
#define AMD64_XMM3              73
#define AMD64_XMM4              74
#define AMD64_XMM5              75
#define AMD64_XMM6              76
#define AMD64_XMM7              77
#define AMD64_XMM8              78
#define AMD64_XMM9              79
#define AMD64_XMM10             80
#define AMD64_XMM11             81
#define AMD64_XMM12             82
#define AMD64_XMM13             83
#define AMD64_XMM14             84
#define AMD64_XMM15             85

#define AMD64_XMM_FIRST         AMD64_XMM0
#define AMD64_XMM_LAST          AMD64_XMM15

#define	AMD64_EAX		100
#define	AMD64_ECX		101
#define	AMD64_EDX		102
#define	AMD64_EBX		103
#define	AMD64_ESP		104
#define	AMD64_EBP		105
#define	AMD64_ESI		106
#define	AMD64_EDI		107
#define AMD64_R8D               108
#define AMD64_R9D               109
#define AMD64_R10D              110
#define AMD64_R11D              111
#define AMD64_R12D              112
#define AMD64_R13D              113
#define AMD64_R14D              114
#define AMD64_R15D              115
#define	AMD64_EIP		116

#define	AMD64_AX		117
#define	AMD64_CX		118
#define	AMD64_DX		119
#define	AMD64_BX		120
#define	AMD64_SP		121
#define	AMD64_BP		122
#define	AMD64_SI		123
#define	AMD64_DI		124
#define AMD64_R8W               125
#define AMD64_R9W               126
#define AMD64_R10W              127
#define AMD64_R11W              128
#define AMD64_R12W              129
#define AMD64_R13W              130
#define AMD64_R14W              131
#define AMD64_R15W              132
#define	AMD64_IP		133
#define	AMD64_FL		134

#define	AMD64_AL		135
#define	AMD64_CL		136
#define	AMD64_DL		137
#define	AMD64_BL		138
#define AMD64_SPL               139
#define AMD64_BPL               140
#define AMD64_SIL               141
#define AMD64_DIL               142
#define AMD64_R8B               143
#define AMD64_R9B               144
#define AMD64_R10B              145
#define AMD64_R11B              146
#define AMD64_R12B              147
#define AMD64_R13B              148
#define AMD64_R14B              149
#define AMD64_R15B              150

#define	AMD64_AH		151
#define	AMD64_CH		152
#define	AMD64_DH		153
#define	AMD64_BH		154

#define	AMD64_IOPL              200
#define	AMD64_OF		201
#define	AMD64_DF		202
#define	AMD64_IF		203
#define	AMD64_TF		204
#define	AMD64_SF		205
#define	AMD64_ZF		206
#define	AMD64_AF		207
#define AMD64_PF		208
#define AMD64_CF		209
#define AMD64_VIP               210
#define AMD64_VIF               211

#define	AMD64_SUBREG_BASE       AMD64_EAX

#endif // #ifndef __AMD64_AMD64_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\amd64_reg.cpp ===
//----------------------------------------------------------------------------
//
// Register portions of AMD64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#define REGALL_SEGREG   REGALL_EXTRA0
#define REGALL_MMXREG   REGALL_EXTRA1
#define REGALL_DREG     REGALL_EXTRA2

REGALLDESC g_Amd64AllExtraDesc[] =
{
    REGALL_SEGREG, "Segment registers",
    REGALL_MMXREG, "MMX registers",
    REGALL_DREG,   "Debug registers and, in kernel, CR4",
    REGALL_XMMREG, "SSE XMM registers",
    0,             NULL,
};

#define REGALL_CREG     REGALL_EXTRA4
#define REGALL_DESC     REGALL_EXTRA5
REGALLDESC g_Amd64KernelExtraDesc[] =
{
    REGALL_CREG,   "CR0, CR2 and CR3",
    REGALL_DESC,   "Descriptor and task state",
    0,             NULL,
};

char g_Rax[] = "rax";
char g_Rcx[] = "rcx";
char g_Rdx[] = "rdx";
char g_Rbx[] = "rbx";
char g_Rsp[] = "rsp";
char g_Rbp[] = "rbp";
char g_Rsi[] = "rsi";
char g_Rdi[] = "rdi";
char g_Rip[] = "rip";

char g_KMxcsr[] = "kmxcsr";
char g_KDr0[]   = "kdr0";
char g_KDr1[]   = "kdr1";
char g_KDr2[]   = "kdr2";
char g_KDr3[]   = "kdr3";
char g_KDr6[]   = "kdr6";
char g_KDr7[]   = "kdr7";

char g_Xmm8[] = "xmm8";
char g_Xmm9[] = "xmm9";
char g_Xmm10[] = "xmm10";
char g_Xmm11[] = "xmm11";
char g_Xmm12[] = "xmm12";
char g_Xmm13[] = "xmm13";
char g_Xmm14[] = "xmm14";
char g_Xmm15[] = "xmm15";

char g_Cr8[] = "cr8";

char g_Spl[] = "spl";
char g_Bpl[] = "bpl";
char g_Sil[] = "sil";
char g_Dil[] = "dil";

char g_R8d[] = "r8d";
char g_R9d[] = "r9d";
char g_R10d[] = "r10d";
char g_R11d[] = "r11d";
char g_R12d[] = "r12d";
char g_R13d[] = "r13d";
char g_R14d[] = "r14d";
char g_R15d[] = "r15d";

char g_R8w[] = "r8w";
char g_R9w[] = "r9w";
char g_R10w[] = "r10w";
char g_R11w[] = "r11w";
char g_R12w[] = "r12w";
char g_R13w[] = "r13w";
char g_R14w[] = "r14w";
char g_R15w[] = "r15w";

char g_R8b[] = "r8b";
char g_R9b[] = "r9b";
char g_R10b[] = "r10b";
char g_R11b[] = "r11b";
char g_R12b[] = "r12b";
char g_R13b[] = "r13b";
char g_R14b[] = "r14b";
char g_R15b[] = "r15b";

REGDEF g_Amd64Defs[] =
{
    { g_Rax,   AMD64_RAX   },
    { g_Rcx,   AMD64_RCX   },
    { g_Rdx,   AMD64_RDX   },
    { g_Rbx,   AMD64_RBX   },
    { g_Rsp,   AMD64_RSP   },
    { g_Rbp,   AMD64_RBP   },
    { g_Rsi,   AMD64_RSI   },
    { g_Rdi,   AMD64_RDI   },
    { g_R8,    AMD64_R8    },
    { g_R9,    AMD64_R9    },
    { g_R10,   AMD64_R10   },
    { g_R11,   AMD64_R11   },
    { g_R12,   AMD64_R12   },
    { g_R13,   AMD64_R13   },
    { g_R14,   AMD64_R14   },
    { g_R15,   AMD64_R15   },
    
    { g_Rip,   AMD64_RIP   },
    { g_Efl,   AMD64_EFL   },
    
    { g_Cs,    AMD64_CS    },
    { g_Ds,    AMD64_DS    },
    { g_Es,    AMD64_ES    },
    { g_Fs,    AMD64_FS    },
    { g_Gs,    AMD64_GS    },
    { g_Ss,    AMD64_SS    },
    
    { g_Dr0,   AMD64_DR0   },
    { g_Dr1,   AMD64_DR1   },
    { g_Dr2,   AMD64_DR2   },
    { g_Dr3,   AMD64_DR3   },
    { g_Dr6,   AMD64_DR6   },
    { g_Dr7,   AMD64_DR7   },
    
    { g_Fpcw,  AMD64_FPCW  },
    { g_Fpsw,  AMD64_FPSW  },
    { g_Fptw,  AMD64_FPTW  },
    
    { g_St0,   AMD64_ST0   },
    { g_St1,   AMD64_ST1   },
    { g_St2,   AMD64_ST2   },
    { g_St3,   AMD64_ST3   },
    { g_St4,   AMD64_ST4   },
    { g_St5,   AMD64_ST5   },
    { g_St6,   AMD64_ST6   },
    { g_St7,   AMD64_ST7   },
    
    { g_Mm0,   AMD64_MM0   },
    { g_Mm1,   AMD64_MM1   },
    { g_Mm2,   AMD64_MM2   },
    { g_Mm3,   AMD64_MM3   },
    { g_Mm4,   AMD64_MM4   },
    { g_Mm5,   AMD64_MM5   },
    { g_Mm6,   AMD64_MM6   },
    { g_Mm7,   AMD64_MM7   },
    
    { g_Mxcsr, AMD64_MXCSR },
    
    { g_Xmm0,  AMD64_XMM0  },
    { g_Xmm1,  AMD64_XMM1  },
    { g_Xmm2,  AMD64_XMM2  },
    { g_Xmm3,  AMD64_XMM3  },
    { g_Xmm4,  AMD64_XMM4  },
    { g_Xmm5,  AMD64_XMM5  },
    { g_Xmm6,  AMD64_XMM6  },
    { g_Xmm7,  AMD64_XMM7  },
    { g_Xmm8,  AMD64_XMM8  },
    { g_Xmm9,  AMD64_XMM9  },
    { g_Xmm10, AMD64_XMM10 },
    { g_Xmm11, AMD64_XMM11 },
    { g_Xmm12, AMD64_XMM12 },
    { g_Xmm13, AMD64_XMM13 },
    { g_Xmm14, AMD64_XMM14 },
    { g_Xmm15, AMD64_XMM15 },
    
    { g_Eax,   AMD64_EAX   },
    { g_Ecx,   AMD64_ECX   },
    { g_Edx,   AMD64_EDX   },
    { g_Ebx,   AMD64_EBX   },
    { g_Esp,   AMD64_ESP   },
    { g_Ebp,   AMD64_EBP   },
    { g_Esi,   AMD64_ESI   },
    { g_Edi,   AMD64_EDI   },
    { g_R8d,   AMD64_R8D   },
    { g_R9d,   AMD64_R9D   },
    { g_R10d,  AMD64_R10D  },
    { g_R11d,  AMD64_R11D  },
    { g_R12d,  AMD64_R12D  },
    { g_R13d,  AMD64_R13D  },
    { g_R14d,  AMD64_R14D  },
    { g_R15d,  AMD64_R15D  },
    { g_Eip,   AMD64_EIP   },
    
    { g_Ax,    AMD64_AX    },
    { g_Cx,    AMD64_CX    },
    { g_Dx,    AMD64_DX    },
    { g_Bx,    AMD64_BX    },
    { g_Sp,    AMD64_SP    },
    { g_Bp,    AMD64_BP    },
    { g_Si,    AMD64_SI    },
    { g_Di,    AMD64_DI    },
    { g_R8w,   AMD64_R8W   },
    { g_R9w,   AMD64_R9W   },
    { g_R10w,  AMD64_R10W  },
    { g_R11w,  AMD64_R11W  },
    { g_R12w,  AMD64_R12W  },
    { g_R13w,  AMD64_R13W  },
    { g_R14w,  AMD64_R14W  },
    { g_R15w,  AMD64_R15W  },
    { g_Ip,    AMD64_IP    },
    { g_Fl,    AMD64_FL    },
    
    { g_Al,    AMD64_AL    },
    { g_Cl,    AMD64_CL    },
    { g_Dl,    AMD64_DL    },
    { g_Bl,    AMD64_BL    },
    { g_Spl,   AMD64_SPL   },
    { g_Bpl,   AMD64_BPL   },
    { g_Sil,   AMD64_SIL   },
    { g_Dil,   AMD64_DIL   },
    { g_R8b,   AMD64_R8B   },
    { g_R9b,   AMD64_R9B   },
    { g_R10b,  AMD64_R10B  },
    { g_R11b,  AMD64_R11B  },
    { g_R12b,  AMD64_R12B  },
    { g_R13b,  AMD64_R13B  },
    { g_R14b,  AMD64_R14B  },
    { g_R15b,  AMD64_R15B  },
    
    { g_Ah,    AMD64_AH    },
    { g_Ch,    AMD64_CH    },
    { g_Dh,    AMD64_DH    },
    { g_Bh,    AMD64_BH    },
    
    { g_Iopl,  AMD64_IOPL },
    { g_Of,    AMD64_OF   },
    { g_Df,    AMD64_DF   },
    { g_If,    AMD64_IF   },
    { g_Tf,    AMD64_TF   },
    { g_Sf,    AMD64_SF   },
    { g_Zf,    AMD64_ZF   },
    { g_Af,    AMD64_AF   },
    { g_Pf,    AMD64_PF   },
    { g_Cf,    AMD64_CF   },
    { g_Vip,   AMD64_VIP  },
    { g_Vif,   AMD64_VIF  },
    
    { NULL,    REG_ERROR },
};

REGDEF g_Amd64KernelReg[] =
{
    { g_Cr0,   AMD64_CR0   },
    { g_Cr2,   AMD64_CR2   },
    { g_Cr3,   AMD64_CR3   },
    { g_Cr4,   AMD64_CR4   },
    { g_Cr8,   AMD64_CR8   },
    { g_Gdtr,  AMD64_GDTR  },
    { g_Gdtl,  AMD64_GDTL  },
    { g_Idtr,  AMD64_IDTR  },
    { g_Idtl,  AMD64_IDTL  },
    { g_Tr,    AMD64_TR    },
    { g_Ldtr,  AMD64_LDTR  },

    { g_KMxcsr,AMD64_KMXCSR},
    
    { g_KDr0,  AMD64_KDR0  },
    { g_KDr1,  AMD64_KDR1  },
    { g_KDr2,  AMD64_KDR2  },
    { g_KDr3,  AMD64_KDR3  },
    { g_KDr6,  AMD64_KDR6  },
    { g_KDr7,  AMD64_KDR7  },
    
    { NULL,    REG_ERROR },
};

REGSUBDEF g_Amd64SubDefs[] =
{
    { AMD64_EAX,    AMD64_RAX,  0, 0xffffffff }, //  EAX register
    { AMD64_ECX,    AMD64_RCX,  0, 0xffffffff }, //  ECX register
    { AMD64_EDX,    AMD64_RDX,  0, 0xffffffff }, //  EDX register
    { AMD64_EBX,    AMD64_RBX,  0, 0xffffffff }, //  EBX register
    { AMD64_ESP,    AMD64_RSP,  0, 0xffffffff }, //  ESP register
    { AMD64_EBP,    AMD64_RBP,  0, 0xffffffff }, //  EBP register
    { AMD64_ESI,    AMD64_RSI,  0, 0xffffffff }, //  ESI register
    { AMD64_EDI,    AMD64_RDI,  0, 0xffffffff }, //  EDI register
    { AMD64_R8D,    AMD64_R8,   0, 0xffffffff }, //  R8D register
    { AMD64_R9D,    AMD64_R9,   0, 0xffffffff }, //  R9D register
    { AMD64_R10D,   AMD64_R10,  0, 0xffffffff }, //  R10D register
    { AMD64_R11D,   AMD64_R11,  0, 0xffffffff }, //  R11D register
    { AMD64_R12D,   AMD64_R12,  0, 0xffffffff }, //  R12D register
    { AMD64_R13D,   AMD64_R13,  0, 0xffffffff }, //  R13D register
    { AMD64_R14D,   AMD64_R14,  0, 0xffffffff }, //  R14D register
    { AMD64_R15D,   AMD64_R15,  0, 0xffffffff }, //  R15D register
    { AMD64_EIP,    AMD64_RIP,  0, 0xffffffff }, //  EIP register
    
    { AMD64_AX,     AMD64_RAX,  0, 0xffff }, //  AX register
    { AMD64_CX,     AMD64_RCX,  0, 0xffff }, //  CX register
    { AMD64_DX,     AMD64_RDX,  0, 0xffff }, //  DX register
    { AMD64_BX,     AMD64_RBX,  0, 0xffff }, //  BX register
    { AMD64_SP,     AMD64_RSP,  0, 0xffff }, //  SP register
    { AMD64_BP,     AMD64_RBP,  0, 0xffff }, //  BP register
    { AMD64_SI,     AMD64_RSI,  0, 0xffff }, //  SI register
    { AMD64_DI,     AMD64_RDI,  0, 0xffff }, //  DI register
    { AMD64_R8W,    AMD64_R8,   0, 0xffff }, //  R8W register
    { AMD64_R9W,    AMD64_R9,   0, 0xffff }, //  R9W register
    { AMD64_R10W,   AMD64_R10,  0, 0xffff }, //  R10W register
    { AMD64_R11W,   AMD64_R11,  0, 0xffff }, //  R11W register
    { AMD64_R12W,   AMD64_R12,  0, 0xffff }, //  R12W register
    { AMD64_R13W,   AMD64_R13,  0, 0xffff }, //  R13W register
    { AMD64_R14W,   AMD64_R14,  0, 0xffff }, //  R14W register
    { AMD64_R15W,   AMD64_R15,  0, 0xffff }, //  R15W register
    { AMD64_IP,     AMD64_RIP,  0, 0xffff }, //  IP register
    { AMD64_FL,     AMD64_EFL,  0, 0xffff }, //  FL register
    
    { AMD64_AL,     AMD64_RAX,  0, 0xff }, //  AL register
    { AMD64_CL,     AMD64_RCX,  0, 0xff }, //  CL register
    { AMD64_DL,     AMD64_RDX,  0, 0xff }, //  DL register
    { AMD64_BL,     AMD64_RBX,  0, 0xff }, //  BL register
    { AMD64_SPL,    AMD64_RSP,  0, 0xff }, //  SPL register
    { AMD64_BPL,    AMD64_RBP,  0, 0xff }, //  BPL register
    { AMD64_SIL,    AMD64_RSI,  0, 0xff }, //  SIL register
    { AMD64_DIL,    AMD64_RDI,  0, 0xff }, //  DIL register
    { AMD64_R8B,    AMD64_R8,   0, 0xff }, //  R8B register
    { AMD64_R9B,    AMD64_R9,   0, 0xff }, //  R9B register
    { AMD64_R10B,   AMD64_R10,  0, 0xff }, //  R10B register
    { AMD64_R11B,   AMD64_R11,  0, 0xff }, //  R11B register
    { AMD64_R12B,   AMD64_R12,  0, 0xff }, //  R12B register
    { AMD64_R13B,   AMD64_R13,  0, 0xff }, //  R13B register
    { AMD64_R14B,   AMD64_R14,  0, 0xff }, //  R14B register
    { AMD64_R15B,   AMD64_R15,  0, 0xff }, //  R15B register
    
    { AMD64_AH,     AMD64_RAX,  8, 0xff }, //  AH register
    { AMD64_CH,     AMD64_RCX,  8, 0xff }, //  CH register
    { AMD64_DH,     AMD64_RDX,  8, 0xff }, //  DH register
    { AMD64_BH,     AMD64_RBX,  8, 0xff }, //  BH register
    
    { AMD64_IOPL,  AMD64_EFL, 12,     3 }, //  IOPL level value
    { AMD64_OF,    AMD64_EFL, 11,     1 }, //  OF (overflow flag)
    { AMD64_DF,    AMD64_EFL, 10,     1 }, //  DF (direction flag)
    { AMD64_IF,    AMD64_EFL,  9,     1 }, //  IF (interrupt enable flag)
    { AMD64_TF,    AMD64_EFL,  8,     1 }, //  TF (trace flag)
    { AMD64_SF,    AMD64_EFL,  7,     1 }, //  SF (sign flag)
    { AMD64_ZF,    AMD64_EFL,  6,     1 }, //  ZF (zero flag)
    { AMD64_AF,    AMD64_EFL,  4,     1 }, //  AF (aux carry flag)
    { AMD64_PF,    AMD64_EFL,  2,     1 }, //  PF (parity flag)
    { AMD64_CF,    AMD64_EFL,  0,     1 }, //  CF (carry flag)
    { AMD64_VIP,   AMD64_EFL, 20,     1 }, //  VIP (virtual interrupt pending)
    { AMD64_VIF,   AMD64_EFL, 19,     1 }, //  VIF (virtual interrupt flag)
    
    { REG_ERROR, REG_ERROR, 0, 0    }
};

RegisterGroup g_Amd64BaseGroup =
{
    0, g_Amd64Defs, g_Amd64SubDefs, g_Amd64AllExtraDesc
};
RegisterGroup g_Amd64KernelGroup =
{
    0, g_Amd64KernelReg, NULL, g_Amd64KernelExtraDesc
};

// First ExecTypes entry must be the actual processor type.
ULONG g_Amd64ExecTypes[] =
{
    IMAGE_FILE_MACHINE_AMD64, IMAGE_FILE_MACHINE_I386,
};

// This array must be sorted by CV reg value.
CvRegMap g_Amd64CvRegMap[] =
{
    {CV_AMD64_AL, AMD64_AL},
    {CV_AMD64_CL, AMD64_CL},
    {CV_AMD64_DL, AMD64_DL},
    {CV_AMD64_BL, AMD64_BL},
    {CV_AMD64_AH, AMD64_AH},
    {CV_AMD64_CH, AMD64_CH},
    {CV_AMD64_DH, AMD64_DH},
    {CV_AMD64_BH, AMD64_BH},
    {CV_AMD64_AX, AMD64_AX},
    {CV_AMD64_CX, AMD64_CX},
    {CV_AMD64_DX, AMD64_DX},
    {CV_AMD64_BX, AMD64_BX},
    {CV_AMD64_SP, AMD64_SP},
    {CV_AMD64_BP, AMD64_BP},
    {CV_AMD64_SI, AMD64_SI},
    {CV_AMD64_DI, AMD64_DI},
    {CV_AMD64_EAX, AMD64_EAX},
    {CV_AMD64_ECX, AMD64_ECX},
    {CV_AMD64_EDX, AMD64_EDX},
    {CV_AMD64_EBX, AMD64_EBX},
    {CV_AMD64_ESP, AMD64_ESP},
    {CV_AMD64_EBP, AMD64_EBP},
    {CV_AMD64_ESI, AMD64_ESI},
    {CV_AMD64_EDI, AMD64_EDI},
    {CV_AMD64_ES, AMD64_ES},
    {CV_AMD64_CS, AMD64_CS},
    {CV_AMD64_SS, AMD64_SS},
    {CV_AMD64_DS, AMD64_DS},
    {CV_AMD64_FS, AMD64_FS},
    {CV_AMD64_GS, AMD64_GS},
    {CV_AMD64_FLAGS, AMD64_FL},
    {CV_AMD64_RIP, AMD64_RIP},
    {CV_AMD64_EFLAGS, AMD64_EFL},
    
    {CV_AMD64_CR0, AMD64_CR0},
    {CV_AMD64_CR2, AMD64_CR2},
    {CV_AMD64_CR3, AMD64_CR3},
    {CV_AMD64_CR4, AMD64_CR4},
    {CV_AMD64_CR8, AMD64_CR8},
    
    {CV_AMD64_DR0, AMD64_DR0},
    {CV_AMD64_DR1, AMD64_DR1},
    {CV_AMD64_DR2, AMD64_DR2},
    {CV_AMD64_DR3, AMD64_DR3},
    {CV_AMD64_DR6, AMD64_DR6},
    {CV_AMD64_DR7, AMD64_DR7},
    
    {CV_AMD64_GDTR, AMD64_GDTR},
    {CV_AMD64_GDTL, AMD64_GDTL},
    {CV_AMD64_IDTR, AMD64_IDTR},
    {CV_AMD64_IDTL, AMD64_IDTL},
    {CV_AMD64_LDTR, AMD64_LDTR},
    {CV_AMD64_TR, AMD64_TR},

    {CV_AMD64_ST0, AMD64_ST0},
    {CV_AMD64_ST1, AMD64_ST1},
    {CV_AMD64_ST2, AMD64_ST2},
    {CV_AMD64_ST3, AMD64_ST3},
    {CV_AMD64_ST4, AMD64_ST4},
    {CV_AMD64_ST5, AMD64_ST5},
    {CV_AMD64_ST6, AMD64_ST6},
    {CV_AMD64_ST7, AMD64_ST7},
    {CV_AMD64_CTRL, AMD64_FPCW},
    {CV_AMD64_STAT, AMD64_FPSW},
    {CV_AMD64_TAG, AMD64_FPTW},

    {CV_AMD64_MM0, AMD64_MM0},
    {CV_AMD64_MM1, AMD64_MM1},
    {CV_AMD64_MM2, AMD64_MM2},
    {CV_AMD64_MM3, AMD64_MM3},
    {CV_AMD64_MM4, AMD64_MM4},
    {CV_AMD64_MM5, AMD64_MM5},
    {CV_AMD64_MM6, AMD64_MM6},
    {CV_AMD64_MM7, AMD64_MM7},

    {CV_AMD64_XMM0, AMD64_XMM0},
    {CV_AMD64_XMM1, AMD64_XMM1},
    {CV_AMD64_XMM2, AMD64_XMM2},
    {CV_AMD64_XMM3, AMD64_XMM3},
    {CV_AMD64_XMM4, AMD64_XMM4},
    {CV_AMD64_XMM5, AMD64_XMM5},
    {CV_AMD64_XMM6, AMD64_XMM6},
    {CV_AMD64_XMM7, AMD64_XMM7},

    {CV_AMD64_MXCSR, AMD64_MXCSR},

    {CV_AMD64_XMM8, AMD64_XMM8},
    {CV_AMD64_XMM9, AMD64_XMM9},
    {CV_AMD64_XMM10, AMD64_XMM10},
    {CV_AMD64_XMM11, AMD64_XMM11},
    {CV_AMD64_XMM12, AMD64_XMM12},
    {CV_AMD64_XMM13, AMD64_XMM13},
    {CV_AMD64_XMM14, AMD64_XMM14},
    {CV_AMD64_XMM15, AMD64_XMM15},

    {CV_AMD64_SIL, AMD64_SIL},
    {CV_AMD64_DIL, AMD64_DIL},
    {CV_AMD64_BPL, AMD64_BPL},
    {CV_AMD64_SPL, AMD64_SPL},

    {CV_AMD64_RAX, AMD64_RAX},
    {CV_AMD64_RBX, AMD64_RBX},
    {CV_AMD64_RCX, AMD64_RCX},
    {CV_AMD64_RDX, AMD64_RDX},
    {CV_AMD64_RSI, AMD64_RSI},
    {CV_AMD64_RDI, AMD64_RDI},
    {CV_AMD64_RBP, AMD64_RBP},
    {CV_AMD64_RSP, AMD64_RSP},

    {CV_AMD64_R8, AMD64_R8},
    {CV_AMD64_R9, AMD64_R9},
    {CV_AMD64_R10, AMD64_R10},
    {CV_AMD64_R11, AMD64_R11},
    {CV_AMD64_R12, AMD64_R12},
    {CV_AMD64_R13, AMD64_R13},
    {CV_AMD64_R14, AMD64_R14},
    {CV_AMD64_R15, AMD64_R15},

    {CV_AMD64_R8B, AMD64_R8B},
    {CV_AMD64_R9B, AMD64_R9B},
    {CV_AMD64_R10B, AMD64_R10B},
    {CV_AMD64_R11B, AMD64_R11B},
    {CV_AMD64_R12B, AMD64_R12B},
    {CV_AMD64_R13B, AMD64_R13B},
    {CV_AMD64_R14B, AMD64_R14B},
    {CV_AMD64_R15B, AMD64_R15B},

    {CV_AMD64_R8W, AMD64_R8W},
    {CV_AMD64_R9W, AMD64_R9W},
    {CV_AMD64_R10W, AMD64_R10W},
    {CV_AMD64_R11W, AMD64_R11W},
    {CV_AMD64_R12W, AMD64_R12W},
    {CV_AMD64_R13W, AMD64_R13W},
    {CV_AMD64_R14W, AMD64_R14W},
    {CV_AMD64_R15W, AMD64_R15W},

    {CV_AMD64_R8D, AMD64_R8D},
    {CV_AMD64_R9D, AMD64_R9D},
    {CV_AMD64_R10D, AMD64_R10D},
    {CV_AMD64_R11D, AMD64_R11D},
    {CV_AMD64_R12D, AMD64_R12D},
    {CV_AMD64_R13D, AMD64_R13D},
    {CV_AMD64_R14D, AMD64_R14D},
    {CV_AMD64_R15D, AMD64_R15D},
};

BOOL g_Amd64InCode64;

Amd64MachineInfo::Amd64MachineInfo(TargetInfo* Target)
    : BaseX86MachineInfo(Target)
{
    m_FullName = "AMD x86-64";
    m_AbbrevName = "AMD64";
    m_PageSize = AMD64_PAGE_SIZE;
    m_PageShift = AMD64_PAGE_SHIFT;
    m_NumExecTypes = DIMA(g_Amd64ExecTypes);
    m_ExecTypes = g_Amd64ExecTypes;
    m_Ptr64 = TRUE;
    m_RetRegIndex = AMD64_RAX;

    m_AllMask = REGALL_INT64 | REGALL_SEGREG;
    
    m_SizeCanonicalContext = sizeof(AMD64_CONTEXT);
    m_SverCanonicalContext = NT_SVER_XP;

    m_MaxDataBreakpoints = 4;
    m_SymPrefix = NULL;

    m_CvRegMapSize = DIMA(g_Amd64CvRegMap);
    m_CvRegMap = g_Amd64CvRegMap;
}

HRESULT
Amd64MachineInfo::Initialize(void)
{
    m_NumGroups = 1;
    m_Groups[0] = &g_Amd64BaseGroup;
    if (IS_KERNEL_TARGET(m_Target))
    {
        m_Groups[m_NumGroups] = &g_Amd64KernelGroup;
        m_NumGroups++;
    }

    return MachineInfo::Initialize();
}

void
Amd64MachineInfo::GetSystemTypeInfo(PSYSTEM_TYPE_INFO Info)
{
    Info->TriagePrcbOffset = AMD64_TRIAGE_PRCB_ADDRESS;
    Info->SizeTargetContext = sizeof(AMD64_CONTEXT);
    Info->OffsetTargetContextFlags = FIELD_OFFSET(AMD64_CONTEXT, ContextFlags);
    Info->SizeControlReport = sizeof(AMD64_DBGKD_CONTROL_REPORT);
    Info->OffsetSpecialRegisters = AMD64_DEBUG_CONTROL_SPACE_KSPECIAL;
    Info->SizeKspecialRegisters = sizeof(AMD64_KSPECIAL_REGISTERS);
    Info->SizePageFrameNumber = sizeof(ULONG64);
    Info->SizePte = sizeof(ULONG64);
    Info->SizeDynamicFunctionTable = sizeof(AMD64_DYNAMIC_FUNCTION_TABLE);
    Info->SizeRuntimeFunction = sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY);

    Info->SharedUserDataOffset = 0;
    Info->UmSharedUserDataOffset = 0;
    Info->UmSharedSysCallOffset = 0;
    Info->UmSharedSysCallSize = 0;
    if (m_Target->m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        Info->SharedUserDataOffset = IS_KERNEL_TARGET(m_Target) ?
            AMD64_KI_USER_SHARED_DATA : MM_SHARED_USER_DATA_VA;
        Info->UmSharedUserDataOffset = MM_SHARED_USER_DATA_VA;
    }
}

void
Amd64MachineInfo::GetDefaultKdData(PKDDEBUGGER_DATA64 KdData)
{
    //
    // Parts of the data block may already be filled out
    // so don't destroy anything that's already set.
    //

    // AMD64 should always have a certain amount of
    // the data block present.  This routine is also
    // called for default initialization before any
    // data block data has been retrieve, though, so
    // limit the assert to just the data-block-read case.
    DBG_ASSERT(!KdData->Header.Size ||
               KdData->OffsetKThreadNextProcessor);

    if (!KdData->SizePcr)
    {
        KdData->SizePcr = AMD64_KPCR_SIZE;
        KdData->OffsetPcrSelfPcr = AMD64_KPCR_SELF;
        KdData->OffsetPcrCurrentPrcb = AMD64_KPCR_CURRENT_PRCB;
        KdData->OffsetPcrContainedPrcb = AMD64_KPCR_PRCB;
        KdData->OffsetPcrInitialBStore = 0;
        KdData->OffsetPcrBStoreLimit = 0;
        KdData->OffsetPcrInitialStack = 0;
        KdData->OffsetPcrStackLimit = 0;
        KdData->OffsetPrcbPcrPage = 0;
        KdData->OffsetPrcbProcStateSpecialReg = AMD64_KPRCB_SPECIAL_REG;
        KdData->GdtR0Code = AMD64_KGDT64_R0_CODE;
        KdData->GdtR0Data = AMD64_KGDT64_R0_DATA;
        KdData->GdtR0Pcr = 0;
        KdData->GdtR3Code = AMD64_KGDT64_R3_CODE + 3;
        KdData->GdtR3Data = AMD64_KGDT64_R3_DATA + 3;
        KdData->GdtR3Teb = 0;
        KdData->GdtLdt = 0;
        KdData->GdtTss = AMD64_KGDT64_SYS_TSS;
        KdData->Gdt64R3CmCode = AMD64_KGDT64_R3_CMCODE + 3;
        KdData->Gdt64R3CmTeb = AMD64_KGDT64_R3_CMTEB + 3;
    }
}

void
Amd64MachineInfo::
InitializeContext(ULONG64 Pc,
                  PDBGKD_ANY_CONTROL_REPORT ControlReport)
{
    m_Context.Amd64Context.Rip = Pc;
    m_ContextState = Pc ? MCTX_PC : MCTX_NONE;

    if (ControlReport != NULL)
    {
        BpOut("InitializeContext(%d) DR6 %I64X DR7 %I64X\n",
              m_Target->m_RegContextProcessor,
              ControlReport->Amd64ControlReport.Dr6,
              ControlReport->Amd64ControlReport.Dr7);
        
        m_Special.Amd64Special.KernelDr6 = ControlReport->Amd64ControlReport.Dr6;
        m_Special.Amd64Special.KernelDr7 = ControlReport->Amd64ControlReport.Dr7;
        m_ContextState = MCTX_DR67_REPORT;

        if (ControlReport->Amd64ControlReport.ReportFlags &
            AMD64_REPORT_INCLUDES_SEGS)
        {
            m_Context.Amd64Context.SegCs =
                ControlReport->Amd64ControlReport.SegCs;
            m_Context.Amd64Context.SegDs =
                ControlReport->Amd64ControlReport.SegDs;
            m_Context.Amd64Context.SegEs =
                ControlReport->Amd64ControlReport.SegEs;
            m_Context.Amd64Context.SegFs =
                ControlReport->Amd64ControlReport.SegFs;
            m_Context.Amd64Context.EFlags =
                ControlReport->Amd64ControlReport.EFlags;
            m_ContextState = MCTX_REPORT;
        }
    }

    g_X86InVm86 = FALSE;
    g_X86InCode16 = FALSE;
    // In the absence of other information, assume we're
    // executing 64-bit code.
    g_Amd64InCode64 = TRUE;

    // XXX drewb - For the moment, always assume user-mode
    // is flat 64-bit.
    if (IS_KERNEL_TARGET(m_Target) && IS_CONTEXT_POSSIBLE(m_Target))
    {
        if (ControlReport == NULL ||
            (ControlReport->Amd64ControlReport.ReportFlags &
             AMD64_REPORT_STANDARD_CS) == 0)
        {
            DESCRIPTOR64 Desc;
            
            // Check what kind of code segment we're in.
            if (GetSegRegDescriptor(SEGREG_CODE, &Desc) != S_OK)
            {
                WarnOut("CS descriptor lookup failed\n");
            }
            else if ((Desc.Flags & X86_DESC_LONG_MODE) == 0)
            {
                g_Amd64InCode64 = FALSE;
                g_X86InVm86 = X86_IS_VM86(GetReg32(X86_EFL));
                g_X86InCode16 = (Desc.Flags & X86_DESC_DEFAULT_BIG) == 0;
            }
        }
        else
        {
            // We're in a standard code segment so cache
            // a default descriptor for CS to avoid further
            // CS lookups.
            m_Target->EmulateNtAmd64SelDescriptor(m_Target->m_RegContextThread,
                                                  this,
                                                  m_Context.Amd64Context.SegCs,
                                                  &m_SegRegDesc[SEGREG_CODE]);
        }
    }

    // Add instructions to cache only if we're in flat mode.
    if (Pc && ControlReport != NULL &&
        !g_X86InVm86 && !g_X86InCode16 && g_Amd64InCode64)
    {
        CacheReportInstructions
            (Pc, ControlReport->Amd64ControlReport.InstructionCount,
             ControlReport->Amd64ControlReport.InstructionStream);
    }
}

HRESULT
Amd64MachineInfo::KdGetContextState(ULONG State)
{
    HRESULT Status;
        
    if (State >= MCTX_CONTEXT && m_ContextState < MCTX_CONTEXT)
    {
        Status = m_Target->GetContext(m_Target->m_RegContextThread->m_Handle,
                                      &m_Context);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_CONTEXT;
    }

    if (State >= MCTX_FULL && m_ContextState < MCTX_FULL)
    {
        Status = m_Target->GetTargetSpecialRegisters
            (m_Target->m_RegContextThread->m_Handle,
             (PCROSS_PLATFORM_KSPECIAL_REGISTERS)&m_Special.Amd64Special);
        if (Status != S_OK)
        {
            return Status;
        }
        
        Status = m_Target->GetTargetSegRegDescriptors
            (m_Target->m_RegContextThread->m_Handle,
             0, SEGREG_COUNT, m_SegRegDesc);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_FULL;

        BpOut("GetContextState(%d) DR6 %I64X DR7 %I64X\n",
              m_Target->m_RegContextProcessor, m_Special.Amd64Special.KernelDr6,
              m_Special.Amd64Special.KernelDr7);
    }

    return S_OK;
}

HRESULT
Amd64MachineInfo::KdSetContext(void)
{
    HRESULT Status;
    
    Status = m_Target->SetContext(m_Target->m_RegContextThread->m_Handle,
                                  &m_Context);
    if (Status != S_OK)
    {
        return Status;
    }

    Status = m_Target->SetTargetSpecialRegisters
        (m_Target->m_RegContextThread->m_Handle,
         (PCROSS_PLATFORM_KSPECIAL_REGISTERS) &m_Special.Amd64Special);
    
    BpOut("SetContext(%d) DR6 %I64X DR7 %I64X\n",
          m_Target->m_RegContextProcessor, m_Special.Amd64Special.KernelDr6,
          m_Special.Amd64Special.KernelDr7);
    
    return S_OK;
}

HRESULT
Amd64MachineInfo::ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG FromSver, ULONG FromSize,
                                     PVOID From)
{
    if (FromSize >= sizeof(AMD64_CONTEXT))
    {
        memcpy(Context, From, sizeof(AMD64_CONTEXT));
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT
Amd64MachineInfo::ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                   ULONG ToSver, ULONG ToSize, PVOID To)
{
    if (ToSize >= sizeof(AMD64_CONTEXT))
    {
        memcpy(To, Context, sizeof(AMD64_CONTEXT));
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

void
Amd64MachineInfo::InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                         ULONG Version)
{
    ULONG ContextFlags;
    
    ContextFlags = AMD64_CONTEXT_FULL | AMD64_CONTEXT_SEGMENTS;
    if (IS_USER_TARGET(m_Target))
    {
        ContextFlags |= AMD64_CONTEXT_DEBUG_REGISTERS;
    }
    
    Context->Amd64Context.ContextFlags = ContextFlags;
}

HRESULT
Amd64MachineInfo::GetContextFromThreadStack(ULONG64 ThreadBase,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            ULONG64 Stack)
{
    HRESULT Status;
    AMD64_KSWITCH_FRAME SwitchFrame;

    if ((Status = m_Target->ReadAllVirtual(m_Target->m_ProcessHead,
                                           Stack,
                                           &SwitchFrame,
                                           sizeof(SwitchFrame))) != S_OK)
    {
        return Status;
    }
    
    ZeroMemory(Context, sizeof(*Context));
    
    Context->Amd64Context.Rbp = SwitchFrame.Rbp;
    Context->Amd64Context.Rsp = Stack + sizeof(SwitchFrame);
    Context->Amd64Context.Rip = SwitchFrame.Return;

    return S_OK;
}

HRESULT
Amd64MachineInfo::GetContextFromFiber(ProcessInfo* Process,
                                      ULONG64 FiberBase,
                                      PCROSS_PLATFORM_CONTEXT Context,
                                      BOOL Verbose)
{
    HRESULT Status;
    AMD64_FIBER Fiber;

    if ((Status = m_Target->
         ReadAllVirtual(Process, FiberBase, &Fiber, sizeof(Fiber))) != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Unable to read fiber data at %s\n",
                   FormatMachineAddr64(this, FiberBase));
        }
        return Status;
    }

    if ((Status = ConvertContextFrom(Context, m_Target->m_SystemVersion,
                                     m_Target->m_TypeInfo.SizeTargetContext,
                                     &Fiber.FiberContext)) != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Unable to convert context to canonical form\n");
        }
        return Status;
    }

    if (Verbose)
    {
        dprintf("Fiber at %s  Fiber data: %s\n",
                FormatMachineAddr64(this, FiberBase),
                FormatMachineAddr64(this, Fiber.FiberData));
        dprintf("  Stack base: %s  Stack limit: %s\n",
                FormatMachineAddr64(this, Fiber.StackBase),
                FormatMachineAddr64(this, Fiber.StackLimit));
    }
    
    return S_OK;
}

HRESULT
Amd64MachineInfo::GetContextFromTrapFrame(ULONG64 TrapBase,
                                          PCROSS_PLATFORM_CONTEXT Context,
                                          BOOL Verbose)
{
    HRESULT Status;
    AMD64_KTRAP_FRAME TrapContents;

    if ((Status = m_Target->ReadAllVirtual(m_Target->m_ProcessHead,
                                           TrapBase, &TrapContents,
                                           sizeof(TrapContents))) != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Unable to read trap frame at %s\n",
                   FormatMachineAddr64(this, TrapBase));
        }
        return Status;
    }

    ZeroMemory(Context, sizeof(*Context));
    
#define CPCXT(Fld) Context->Amd64Context.Fld = TrapContents.Fld

    CPCXT(MxCsr); CPCXT(Rax); CPCXT(Rcx); CPCXT(Rdx); CPCXT(R8); 
    CPCXT(R9); CPCXT(R10); CPCXT(R11); CPCXT(Dr0); CPCXT(Dr1); 
    CPCXT(Dr2); CPCXT(Dr3); CPCXT(Dr6); CPCXT(Dr7);
    CPCXT(Xmm0); CPCXT(Xmm1); CPCXT(Xmm2); CPCXT(Xmm3); CPCXT(Xmm4);
    CPCXT(Xmm5);
    CPCXT(SegDs); CPCXT(SegEs); CPCXT(SegFs); CPCXT(SegGs);
    CPCXT(Rbx); CPCXT(Rdi); CPCXT(Rsi); CPCXT(Rbp); CPCXT(Rip); 
    CPCXT(SegCs); CPCXT(EFlags); CPCXT(Rsp); CPCXT(SegSs);

#undef CPCXT

    return S_OK;
}

void 
Amd64MachineInfo::GetScopeFrameFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                           PDEBUG_STACK_FRAME ScopeFrame)
{
    ZeroMemory(ScopeFrame, sizeof(*ScopeFrame));
    ScopeFrame->InstructionOffset = Context->Amd64Context.Rip;
    ScopeFrame->FrameOffset       = Context->Amd64Context.Rbp;
    ScopeFrame->StackOffset       = Context->Amd64Context.Rsp;
}

HRESULT
Amd64MachineInfo::GetScopeFrameRegister(ULONG Reg,
                                        PDEBUG_STACK_FRAME ScopeFrame,
                                        PULONG64 Value)
{
    HRESULT Status;
    REGVAL RegVal;
    
    switch(Reg)
    {
    case AMD64_RSP:
        *Value = ScopeFrame->StackOffset;
        return S_OK;
    case AMD64_RBP:
        *Value = ScopeFrame->FrameOffset;
        return S_OK;
    default:
        RegVal.I64 = 0;
        if ((Status = FullGetVal(Reg, &RegVal)) != S_OK)
        {
            return Status;
        }
        *Value = RegVal.I64;
        return S_OK;
    }
}

HRESULT
Amd64MachineInfo::SetScopeFrameRegister(ULONG Reg,
                                        PDEBUG_STACK_FRAME ScopeFrame,
                                        ULONG64 Value)
{
    REGVAL RegVal;
    
    switch(Reg)
    {
    case AMD64_RSP:
        ScopeFrame->StackOffset = Value;
        return S_OK;
    case AMD64_RBP:
        ScopeFrame->FrameOffset = Value;
        return S_OK;
    default:
        RegVal.Type = GetType(Reg);
        RegVal.I64 = Value;
        return FullSetVal(Reg, &RegVal);
    }
}

HRESULT
Amd64MachineInfo::GetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context,
                                 EXDI_CONTEXT_TYPE CtxType)
{
    return StaticGetExdiContext(Exdi, Context, CtxType);
}

HRESULT
Amd64MachineInfo::SetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context,
                                 EXDI_CONTEXT_TYPE CtxType)
{
    DBG_ASSERT(CtxType == EXDI_CTX_AMD64);
    // Don't change the existing group selections on the assumption
    // that there was a full get prior to any modifications so
    // all groups are valid.
    return ((IeXdiX86_64Context*)Exdi)->SetContext(Context->Amd64Context);
}

void
Amd64MachineInfo::ConvertExdiContextFromContext
    (PCROSS_PLATFORM_CONTEXT Context, PEXDI_CONTEXT ExdiContext,
     EXDI_CONTEXT_TYPE CtxType)
{
    DBG_ASSERT(CtxType == EXDI_CTX_AMD64);

    if (Context->Amd64Context.ContextFlags & AMD64_CONTEXT_SEGMENTS)
    {
        ExdiContext->Amd64Context.SegDs = Context->Amd64Context.SegDs;
        ExdiContext->Amd64Context.SegEs = Context->Amd64Context.SegEs;
        ExdiContext->Amd64Context.SegFs = Context->Amd64Context.SegFs;
        ExdiContext->Amd64Context.SegGs = Context->Amd64Context.SegGs;
    }
    
    if (Context->Amd64Context.ContextFlags & AMD64_CONTEXT_CONTROL)
    {
        ExdiContext->Amd64Context.SegCs = Context->Amd64Context.SegCs;
        ExdiContext->Amd64Context.Rip = Context->Amd64Context.Rip;
        ExdiContext->Amd64Context.SegSs = Context->Amd64Context.SegSs;
        ExdiContext->Amd64Context.Rsp = Context->Amd64Context.Rsp;
        ExdiContext->Amd64Context.EFlags = Context->Amd64Context.EFlags;
    }

    if (Context->Amd64Context.ContextFlags & AMD64_CONTEXT_DEBUG_REGISTERS)
    {
        ExdiContext->Amd64Context.Dr0 = Context->Amd64Context.Dr0;
        ExdiContext->Amd64Context.Dr1 = Context->Amd64Context.Dr1;
        ExdiContext->Amd64Context.Dr2 = Context->Amd64Context.Dr2;
        ExdiContext->Amd64Context.Dr3 = Context->Amd64Context.Dr3;
        ExdiContext->Amd64Context.Dr6 = Context->Amd64Context.Dr6;
        ExdiContext->Amd64Context.Dr7 = Context->Amd64Context.Dr7;
    }
    
    if (Context->Amd64Context.ContextFlags & AMD64_CONTEXT_INTEGER)
    {
        ExdiContext->Amd64Context.Rax = Context->Amd64Context.Rax;
        ExdiContext->Amd64Context.Rcx = Context->Amd64Context.Rcx;
        ExdiContext->Amd64Context.Rdx = Context->Amd64Context.Rdx;
        ExdiContext->Amd64Context.Rbx = Context->Amd64Context.Rbx;
        ExdiContext->Amd64Context.Rbp = Context->Amd64Context.Rbp;
        ExdiContext->Amd64Context.Rsi = Context->Amd64Context.Rsi;
        ExdiContext->Amd64Context.Rdi = Context->Amd64Context.Rdi;
        ExdiContext->Amd64Context.R8 = Context->Amd64Context.R8;
        ExdiContext->Amd64Context.R9 = Context->Amd64Context.R9;
        ExdiContext->Amd64Context.R10 = Context->Amd64Context.R10;
        ExdiContext->Amd64Context.R11 = Context->Amd64Context.R11;
        ExdiContext->Amd64Context.R12 = Context->Amd64Context.R12;
        ExdiContext->Amd64Context.R13 = Context->Amd64Context.R13;
        ExdiContext->Amd64Context.R14 = Context->Amd64Context.R14;
        ExdiContext->Amd64Context.R15 = Context->Amd64Context.R15;
    }

    if (Context->Amd64Context.ContextFlags & AMD64_CONTEXT_FLOATING_POINT)
    {
        ExdiContext->Amd64Context.ControlWord =
            Context->Amd64Context.FltSave.ControlWord;
        ExdiContext->Amd64Context.StatusWord =
            Context->Amd64Context.FltSave.StatusWord;
        ExdiContext->Amd64Context.TagWord =
            Context->Amd64Context.FltSave.TagWord;
        ExdiContext->Amd64Context.ErrorOffset =
            Context->Amd64Context.FltSave.ErrorOffset;
        ExdiContext->Amd64Context.ErrorSelector =
            Context->Amd64Context.FltSave.ErrorSelector;
        ExdiContext->Amd64Context.DataOffset =
            Context->Amd64Context.FltSave.DataOffset;
        ExdiContext->Amd64Context.DataSelector =
            Context->Amd64Context.FltSave.DataSelector;
        ExdiContext->Amd64Context.RegMXCSR =
            Context->Amd64Context.MxCsr;
        for (ULONG i = 0; i < 8; i++)
        {
            memcpy(ExdiContext->Amd64Context.RegisterArea + i * 10,
                   Context->Amd64Context.FltSave.FloatRegisters + i * 10,
                   10);
        }
        memcpy(ExdiContext->Amd64Context.RegSSE,
               &Context->Amd64Context.Xmm0, 16 * sizeof(AMD64_M128));
    }
}

void
Amd64MachineInfo::ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                              EXDI_CONTEXT_TYPE CtxType,
                                              PCROSS_PLATFORM_CONTEXT Context)
{
    DBG_ASSERT(CtxType == EXDI_CTX_AMD64);

    Context->Amd64Context.SegCs = (USHORT)ExdiContext->Amd64Context.SegCs;
    Context->Amd64Context.SegDs = (USHORT)ExdiContext->Amd64Context.SegDs;
    Context->Amd64Context.SegEs = (USHORT)ExdiContext->Amd64Context.SegEs;
    Context->Amd64Context.SegFs = (USHORT)ExdiContext->Amd64Context.SegFs;
    Context->Amd64Context.SegGs = (USHORT)ExdiContext->Amd64Context.SegGs;
    Context->Amd64Context.SegSs = (USHORT)ExdiContext->Amd64Context.SegSs;
    Context->Amd64Context.EFlags = (ULONG)ExdiContext->Amd64Context.EFlags;

    Context->Amd64Context.Dr0 = ExdiContext->Amd64Context.Dr0;
    Context->Amd64Context.Dr1 = ExdiContext->Amd64Context.Dr1;
    Context->Amd64Context.Dr2 = ExdiContext->Amd64Context.Dr2;
    Context->Amd64Context.Dr3 = ExdiContext->Amd64Context.Dr3;
    Context->Amd64Context.Dr6 = ExdiContext->Amd64Context.Dr6;
    Context->Amd64Context.Dr7 = ExdiContext->Amd64Context.Dr7;
    
    Context->Amd64Context.Rax = ExdiContext->Amd64Context.Rax;
    Context->Amd64Context.Rcx = ExdiContext->Amd64Context.Rcx;
    Context->Amd64Context.Rdx = ExdiContext->Amd64Context.Rdx;
    Context->Amd64Context.Rbx = ExdiContext->Amd64Context.Rbx;
    Context->Amd64Context.Rsp = ExdiContext->Amd64Context.Rsp;
    Context->Amd64Context.Rbp = ExdiContext->Amd64Context.Rbp;
    Context->Amd64Context.Rsi = ExdiContext->Amd64Context.Rsi;
    Context->Amd64Context.Rdi = ExdiContext->Amd64Context.Rdi;
    Context->Amd64Context.R8 = ExdiContext->Amd64Context.R8;
    Context->Amd64Context.R9 = ExdiContext->Amd64Context.R9;
    Context->Amd64Context.R10 = ExdiContext->Amd64Context.R10;
    Context->Amd64Context.R11 = ExdiContext->Amd64Context.R11;
    Context->Amd64Context.R12 = ExdiContext->Amd64Context.R12;
    Context->Amd64Context.R13 = ExdiContext->Amd64Context.R13;
    Context->Amd64Context.R14 = ExdiContext->Amd64Context.R14;
    Context->Amd64Context.R15 = ExdiContext->Amd64Context.R15;

    Context->Amd64Context.Rip = ExdiContext->Amd64Context.Rip;

    Context->Amd64Context.FltSave.ControlWord =
        (USHORT)ExdiContext->Amd64Context.ControlWord;
    Context->Amd64Context.FltSave.StatusWord =
        (USHORT)ExdiContext->Amd64Context.StatusWord;
    Context->Amd64Context.FltSave.TagWord =
        (USHORT)ExdiContext->Amd64Context.TagWord;
    // XXX drewb - No ErrorOpcode in x86_64.
    Context->Amd64Context.FltSave.ErrorOpcode = 0;
    Context->Amd64Context.FltSave.ErrorOffset =
        ExdiContext->Amd64Context.ErrorOffset;
    Context->Amd64Context.FltSave.ErrorSelector =
        (USHORT)ExdiContext->Amd64Context.ErrorSelector;
    Context->Amd64Context.FltSave.DataOffset =
        ExdiContext->Amd64Context.DataOffset;
    Context->Amd64Context.FltSave.DataSelector =
        (USHORT)ExdiContext->Amd64Context.DataSelector;
    Context->Amd64Context.MxCsr =
        ExdiContext->Amd64Context.RegMXCSR;
    for (ULONG i = 0; i < 8; i++)
    {
        memcpy(Context->Amd64Context.FltSave.FloatRegisters + i * 10,
               ExdiContext->Amd64Context.RegisterArea + i * 10, 10);
    }
    memcpy(&Context->Amd64Context.Xmm0, ExdiContext->Amd64Context.RegSSE,
           16 * sizeof(AMD64_M128));
}

void
Amd64MachineInfo::ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                               EXDI_CONTEXT_TYPE CtxType,
                                               ULONG Start, ULONG Count,
                                               PDESCRIPTOR64 Descs)
{
    DBG_ASSERT(CtxType == EXDI_CTX_AMD64);

    while (Count-- > 0)
    {
        SEG64_DESC_INFO* Desc;

        switch(Start)
        {
        case SEGREG_CODE:
            Desc = &ExdiContext->Amd64Context.DescriptorCs;
            break;
        case SEGREG_DATA:
            Desc = &ExdiContext->Amd64Context.DescriptorDs;
            break;
        case SEGREG_STACK:
            Desc = &ExdiContext->Amd64Context.DescriptorSs;
            break;
        case SEGREG_ES:
            Desc = &ExdiContext->Amd64Context.DescriptorEs;
            break;
        case SEGREG_FS:
            Desc = &ExdiContext->Amd64Context.DescriptorFs;
            break;
        case SEGREG_GS:
            Desc = &ExdiContext->Amd64Context.DescriptorGs;
            break;
        case SEGREG_GDT:
            Descs->Base = ExdiContext->Amd64Context.GDTBase;
            Descs->Limit = ExdiContext->Amd64Context.GDTLimit;
            Descs->Flags = X86_DESC_PRESENT;
            Desc = NULL;
            break;
        case SEGREG_LDT:
            Desc = &ExdiContext->Amd64Context.SegLDT;
            break;
        default:
            Descs->Flags = SEGDESC_INVALID;
            Desc = NULL;
            break;
        }

        if (Desc != NULL)
        {
            Descs->Base = Desc->SegBase;
            Descs->Limit = Desc->SegLimit;
            Descs->Flags =
                ((Desc->SegFlags >> 4) & 0xf00) |
                (Desc->SegFlags & 0xff);
        }

        Descs++;
        Start++;
    }
}

void
Amd64MachineInfo::ConvertExdiContextFromSpecial
    (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
     PEXDI_CONTEXT ExdiContext, EXDI_CONTEXT_TYPE CtxType)
{
    DBG_ASSERT(CtxType == EXDI_CTX_AMD64);

    ExdiContext->Amd64Context.RegCr0 = Special->Amd64Special.Cr0;
    ExdiContext->Amd64Context.RegCr2 = Special->Amd64Special.Cr2;
    ExdiContext->Amd64Context.RegCr3 = Special->Amd64Special.Cr3;
    ExdiContext->Amd64Context.RegCr4 = Special->Amd64Special.Cr4;
    ExdiContext->Amd64Context.RegCr8 = Special->Amd64Special.Cr8;
    ExdiContext->Amd64Context.RegMXCSR = Special->Amd64Special.MxCsr;
    ExdiContext->Amd64Context.Dr0 = Special->Amd64Special.KernelDr0;
    ExdiContext->Amd64Context.Dr1 = Special->Amd64Special.KernelDr1;
    ExdiContext->Amd64Context.Dr2 = Special->Amd64Special.KernelDr2;
    ExdiContext->Amd64Context.Dr3 = Special->Amd64Special.KernelDr3;
    ExdiContext->Amd64Context.Dr6 = Special->Amd64Special.KernelDr6;
    ExdiContext->Amd64Context.Dr7 = Special->Amd64Special.KernelDr7;
    ExdiContext->Amd64Context.GDTLimit = Special->Amd64Special.Gdtr.Limit;
    ExdiContext->Amd64Context.GDTBase = Special->Amd64Special.Gdtr.Base;
    ExdiContext->Amd64Context.IDTLimit = Special->Amd64Special.Idtr.Limit;
    ExdiContext->Amd64Context.IDTBase = Special->Amd64Special.Idtr.Base;
    ExdiContext->Amd64Context.SelTSS = Special->Amd64Special.Tr;
    ExdiContext->Amd64Context.SelLDT = Special->Amd64Special.Ldtr;
}

void
Amd64MachineInfo::ConvertExdiContextToSpecial
    (PEXDI_CONTEXT ExdiContext, EXDI_CONTEXT_TYPE CtxType,
     PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    DBG_ASSERT(CtxType == EXDI_CTX_AMD64);

    Special->Amd64Special.Cr0 = ExdiContext->Amd64Context.RegCr0;
    Special->Amd64Special.Cr2 = ExdiContext->Amd64Context.RegCr2;
    Special->Amd64Special.Cr3 = ExdiContext->Amd64Context.RegCr3;
    Special->Amd64Special.Cr4 = ExdiContext->Amd64Context.RegCr4;
    Special->Amd64Special.Cr8 = ExdiContext->Amd64Context.RegCr8;
    Special->Amd64Special.MxCsr = ExdiContext->Amd64Context.RegMXCSR;
    Special->Amd64Special.KernelDr0 = ExdiContext->Amd64Context.Dr0;
    Special->Amd64Special.KernelDr1 = ExdiContext->Amd64Context.Dr1;
    Special->Amd64Special.KernelDr2 = ExdiContext->Amd64Context.Dr2;
    Special->Amd64Special.KernelDr3 = ExdiContext->Amd64Context.Dr3;
    Special->Amd64Special.KernelDr6 = ExdiContext->Amd64Context.Dr6;
    Special->Amd64Special.KernelDr7 = ExdiContext->Amd64Context.Dr7;
    Special->Amd64Special.Gdtr.Limit =
        (USHORT)ExdiContext->Amd64Context.GDTLimit;
    Special->Amd64Special.Gdtr.Base = ExdiContext->Amd64Context.GDTBase;
    Special->Amd64Special.Idtr.Limit =
        (USHORT)ExdiContext->Amd64Context.IDTLimit;
    Special->Amd64Special.Idtr.Base = ExdiContext->Amd64Context.IDTBase;
    Special->Amd64Special.Tr = (USHORT)ExdiContext->Amd64Context.SelTSS;
    Special->Amd64Special.Ldtr = (USHORT)ExdiContext->Amd64Context.SelLDT;
}

int
Amd64MachineInfo::GetType(ULONG RegNum)
{
    if (RegNum >= AMD64_MM_FIRST && RegNum <= AMD64_MM_LAST)
    {
        return REGVAL_VECTOR64;
    }
    else if (RegNum >= AMD64_XMM_FIRST && RegNum <= AMD64_XMM_LAST)
    {
        return REGVAL_VECTOR128;
    }
    else if (RegNum >= AMD64_ST_FIRST && RegNum <= AMD64_ST_LAST)
    {
        return REGVAL_FLOAT10;
    }
    else if ((RegNum >= AMD64_SEG_FIRST && RegNum <= AMD64_SEG_LAST) ||
             (RegNum >= AMD64_FPCTRL_FIRST && RegNum <= AMD64_FPCTRL_LAST) ||
             RegNum == AMD64_TR || RegNum == AMD64_LDTR ||
             RegNum == AMD64_GDTL || RegNum == AMD64_IDTL)
    {
        return REGVAL_INT16;
    }
    else if (RegNum == AMD64_EFL ||
             RegNum == AMD64_MXCSR || RegNum == AMD64_KMXCSR)
    {
        return REGVAL_INT32;
    }
    else if (RegNum < AMD64_SUBREG_BASE)
    {
        return REGVAL_INT64;
    }
    else
    {
        return REGVAL_SUB64;
    }
}

HRESULT
Amd64MachineInfo::GetVal(ULONG RegNum, REGVAL* Val)
{
    HRESULT Status;
    
    // The majority of the registers are 64-bit so default
    // to that type.
    Val->Type = REGVAL_INT64;
    
    switch(m_ContextState)
    {
    case MCTX_PC:
        if (RegNum == AMD64_RIP)
        {
            Val->I64 = m_Context.Amd64Context.Rip;
            return S_OK;
        }
        goto MctxContext;
        
    case MCTX_DR67_REPORT:
        switch(RegNum)
        {
        case AMD64_KDR6:
            Val->I64 = m_Special.Amd64Special.KernelDr6;
            break;
        case AMD64_KDR7:
            Val->I64 = m_Special.Amd64Special.KernelDr7;
            break;
        default:
            goto MctxContext;
        }
        return S_OK;

    case MCTX_REPORT:
        switch(RegNum)
        {
        case AMD64_RIP:
            Val->I64 = m_Context.Amd64Context.Rip;
            break;
        case AMD64_EFL:
            Val->Type = REGVAL_INT32;
            Val->I64 = m_Context.Amd64Context.EFlags;
            break;
        case AMD64_CS:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.SegCs;
            break;
        case AMD64_DS:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.SegDs;
            break;
        case AMD64_ES:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.SegEs;
            break;
        case AMD64_FS:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.SegFs;
            break;
        case AMD64_KDR6:
            Val->I64 = m_Special.Amd64Special.KernelDr6;
            break;
        case AMD64_KDR7:
            Val->I64 = m_Special.Amd64Special.KernelDr7;
            break;
        default:
            goto MctxContext;
        }
        return S_OK;
        
    case MCTX_NONE:
    MctxContext:
        if ((Status = GetContextState(MCTX_CONTEXT)) != S_OK)
        {
            return Status;
        }
        // Fall through.
        
    case MCTX_CONTEXT:
        switch(RegNum)
        {
        case AMD64_RIP:
            Val->I64 = m_Context.Amd64Context.Rip;
            return S_OK;
        case AMD64_EFL:
            Val->Type = REGVAL_INT32;
            Val->I64 = m_Context.Amd64Context.EFlags;
            return S_OK;
        case AMD64_CS:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.SegCs;
            return S_OK;
        case AMD64_DS:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.SegDs;
            return S_OK;
        case AMD64_ES:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.SegEs;
            return S_OK;
        case AMD64_FS:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.SegFs;
            return S_OK;

        case AMD64_RAX:
            Val->I64 = m_Context.Amd64Context.Rax;
            return S_OK;
        case AMD64_RCX:
            Val->I64 = m_Context.Amd64Context.Rcx;
            return S_OK;
        case AMD64_RDX:
            Val->I64 = m_Context.Amd64Context.Rdx;
            return S_OK;
        case AMD64_RBX:
            Val->I64 = m_Context.Amd64Context.Rbx;
            return S_OK;
        case AMD64_RSP:
            Val->I64 = m_Context.Amd64Context.Rsp;
            return S_OK;
        case AMD64_RBP:
            Val->I64 = m_Context.Amd64Context.Rbp;
            return S_OK;
        case AMD64_RSI:
            Val->I64 = m_Context.Amd64Context.Rsi;
            return S_OK;
        case AMD64_RDI:
            Val->I64 = m_Context.Amd64Context.Rdi;
            return S_OK;
        case AMD64_R8:
            Val->I64 = m_Context.Amd64Context.R8;
            return S_OK;
        case AMD64_R9:
            Val->I64 = m_Context.Amd64Context.R9;
            return S_OK;
        case AMD64_R10:
            Val->I64 = m_Context.Amd64Context.R10;
            return S_OK;
        case AMD64_R11:
            Val->I64 = m_Context.Amd64Context.R11;
            return S_OK;
        case AMD64_R12:
            Val->I64 = m_Context.Amd64Context.R12;
            return S_OK;
        case AMD64_R13:
            Val->I64 = m_Context.Amd64Context.R13;
            return S_OK;
        case AMD64_R14:
            Val->I64 = m_Context.Amd64Context.R14;
            return S_OK;
        case AMD64_R15:
            Val->I64 = m_Context.Amd64Context.R15;
            return S_OK;
            
        case AMD64_GS:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.SegGs;
            return S_OK;
        case AMD64_SS:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.SegSs;
            return S_OK;

        case AMD64_FPCW:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.FltSave.ControlWord;
            return S_OK;
        case AMD64_FPSW:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.FltSave.StatusWord;
            return S_OK;
        case AMD64_FPTW:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Context.Amd64Context.FltSave.TagWord;
            return S_OK;
        
        case AMD64_MXCSR:
            Val->Type = REGVAL_INT32;
            Val->I64 = m_Context.Amd64Context.MxCsr;
            return S_OK;
        }
        
        if (RegNum >= AMD64_MM_FIRST && RegNum <= AMD64_MM_LAST)
        {
            Val->Type = REGVAL_VECTOR64;
            Val->I64 = *(ULONG64 UNALIGNED*)&m_Context.Amd64Context.FltSave.
                FloatRegisters[GetMmxRegOffset(RegNum - AMD64_MM_FIRST,
                                               GetReg32(AMD64_FPSW)) * 10];
            return S_OK;
        }
        else if (RegNum >= AMD64_XMM_FIRST && RegNum <= AMD64_XMM_LAST)
        {
            Val->Type = REGVAL_VECTOR128;
            memcpy(Val->Bytes, (PUCHAR)&m_Context.Amd64Context.Xmm0 +
                   (RegNum - AMD64_XMM_FIRST) * 16, 16);
            return S_OK;
        }
        else if (RegNum >= AMD64_ST_FIRST && RegNum <= AMD64_ST_LAST)
        {
            Val->Type = REGVAL_FLOAT10;
            memcpy(Val->F10, &m_Context.Amd64Context.FltSave.
                   FloatRegisters[(RegNum - AMD64_ST_FIRST) * 10],
                   sizeof(Val->F10));
            return S_OK;
        }
        
        //
        // The requested register is not in our current context, load up
        // a complete context
        //

        if ((Status = GetContextState(MCTX_FULL)) != S_OK)
        {
            return Status;
        }
        break;
    }

    //
    // We must have a complete context...
    //

    switch(RegNum)
    {
    case AMD64_RAX:
        Val->I64 = m_Context.Amd64Context.Rax;
        return S_OK;
    case AMD64_RCX:
        Val->I64 = m_Context.Amd64Context.Rcx;
        return S_OK;
    case AMD64_RDX:
        Val->I64 = m_Context.Amd64Context.Rdx;
        return S_OK;
    case AMD64_RBX:
        Val->I64 = m_Context.Amd64Context.Rbx;
        return S_OK;
    case AMD64_RSP:
        Val->I64 = m_Context.Amd64Context.Rsp;
        return S_OK;
    case AMD64_RBP:
        Val->I64 = m_Context.Amd64Context.Rbp;
        return S_OK;
    case AMD64_RSI:
        Val->I64 = m_Context.Amd64Context.Rsi;
        return S_OK;
    case AMD64_RDI:
        Val->I64 = m_Context.Amd64Context.Rdi;
        return S_OK;
    case AMD64_R8:
        Val->I64 = m_Context.Amd64Context.R8;
        return S_OK;
    case AMD64_R9:
        Val->I64 = m_Context.Amd64Context.R9;
        return S_OK;
    case AMD64_R10:
        Val->I64 = m_Context.Amd64Context.R10;
        return S_OK;
    case AMD64_R11:
        Val->I64 = m_Context.Amd64Context.R11;
        return S_OK;
    case AMD64_R12:
        Val->I64 = m_Context.Amd64Context.R12;
        return S_OK;
    case AMD64_R13:
        Val->I64 = m_Context.Amd64Context.R13;
        return S_OK;
    case AMD64_R14:
        Val->I64 = m_Context.Amd64Context.R14;
        return S_OK;
    case AMD64_R15:
        Val->I64 = m_Context.Amd64Context.R15;
        return S_OK;
        
    case AMD64_RIP:
        Val->I64 = m_Context.Amd64Context.Rip;
        return S_OK;
    case AMD64_EFL:
        Val->Type = REGVAL_INT32;
        Val->I64 = m_Context.Amd64Context.EFlags;
        return S_OK;

    case AMD64_CS:
        Val->Type = REGVAL_INT16;
        Val->I64 = m_Context.Amd64Context.SegCs;
        return S_OK;
    case AMD64_DS:
        Val->Type = REGVAL_INT16;
        Val->I64 = m_Context.Amd64Context.SegDs;
        return S_OK;
    case AMD64_ES:
        Val->Type = REGVAL_INT16;
        Val->I64 = m_Context.Amd64Context.SegEs;
        return S_OK;
    case AMD64_FS:
        Val->Type = REGVAL_INT16;
        Val->I64 = m_Context.Amd64Context.SegFs;
        return S_OK;
    case AMD64_GS:
        Val->Type = REGVAL_INT16;
        Val->I64 = m_Context.Amd64Context.SegGs;
        return S_OK;
    case AMD64_SS:
        Val->Type = REGVAL_INT16;
        Val->I64 = m_Context.Amd64Context.SegSs;
        return S_OK;
        
    case AMD64_DR0:
        Val->I64 = m_Context.Amd64Context.Dr0;
        return S_OK;
    case AMD64_DR1:
        Val->I64 = m_Context.Amd64Context.Dr1;
        return S_OK;
    case AMD64_DR2:
        Val->I64 = m_Context.Amd64Context.Dr2;
        return S_OK;
    case AMD64_DR3:
        Val->I64 = m_Context.Amd64Context.Dr3;
        return S_OK;
    case AMD64_DR6:
        Val->I64 = m_Context.Amd64Context.Dr6;
        return S_OK;
    case AMD64_DR7:
        Val->I64 = m_Context.Amd64Context.Dr7;
        return S_OK;

    case AMD64_FPCW:
        Val->Type = REGVAL_INT16;
        Val->I64 = m_Context.Amd64Context.FltSave.ControlWord;
        return S_OK;
    case AMD64_FPSW:
        Val->Type = REGVAL_INT16;
        Val->I64 = m_Context.Amd64Context.FltSave.StatusWord;
        return S_OK;
    case AMD64_FPTW:
        Val->Type = REGVAL_INT16;
        Val->I64 = m_Context.Amd64Context.FltSave.TagWord;
        return S_OK;
        
    case AMD64_MXCSR:
        Val->Type = REGVAL_INT32;
        Val->I64 = m_Context.Amd64Context.MxCsr;
        return S_OK;
    }

    if (RegNum >= AMD64_MM_FIRST && RegNum <= AMD64_MM_LAST)
    {
        Val->Type = REGVAL_VECTOR64;
        Val->I64 = *(ULONG64 UNALIGNED*)&m_Context.Amd64Context.FltSave.
            FloatRegisters[GetMmxRegOffset(RegNum - AMD64_MM_FIRST,
                                           GetReg32(AMD64_FPSW)) * 10];
        return S_OK;
    }
    else if (RegNum >= AMD64_XMM_FIRST && RegNum <= AMD64_XMM_LAST)
    {
        Val->Type = REGVAL_VECTOR128;
        memcpy(Val->Bytes, (PUCHAR)&m_Context.Amd64Context.Xmm0 +
               (RegNum - AMD64_XMM_FIRST) * 16, 16);
        return S_OK;
    }
    else if (RegNum >= AMD64_ST_FIRST && RegNum <= AMD64_ST_LAST)
    {
        Val->Type = REGVAL_FLOAT10;
        memcpy(Val->F10, &m_Context.Amd64Context.FltSave.
               FloatRegisters[(RegNum - AMD64_ST_FIRST) * 10],
               sizeof(Val->F10));
        return S_OK;
    }
        
    if (IS_KERNEL_TARGET(m_Target))
    {
        switch(RegNum)
        {
        case AMD64_CR0:
            Val->I64 = m_Special.Amd64Special.Cr0;
            return S_OK;
        case AMD64_CR2:
            Val->I64 = m_Special.Amd64Special.Cr2;
            return S_OK;
        case AMD64_CR3:
            Val->I64 = m_Special.Amd64Special.Cr3;
            return S_OK;
        case AMD64_CR4:
            Val->I64 = m_Special.Amd64Special.Cr4;
            return S_OK;
        case AMD64_CR8:
            Val->I64 = m_Special.Amd64Special.Cr8;
            return S_OK;
            
        case AMD64_GDTR:
            Val->I64 = m_Special.Amd64Special.Gdtr.Base;
            return S_OK;
        case AMD64_GDTL:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Special.Amd64Special.Gdtr.Limit;
            return S_OK;
        case AMD64_IDTR:
            Val->I64 = m_Special.Amd64Special.Idtr.Base;
            return S_OK;
        case AMD64_IDTL:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Special.Amd64Special.Idtr.Limit;
            return S_OK;
        case AMD64_TR:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Special.Amd64Special.Tr;
            return S_OK;
        case AMD64_LDTR:
            Val->Type = REGVAL_INT16;
            Val->I64 = m_Special.Amd64Special.Ldtr;
            return S_OK;
            
        case AMD64_KMXCSR:
            Val->Type = REGVAL_INT32;
            Val->I64 = m_Special.Amd64Special.MxCsr;
            return S_OK;
            
        case AMD64_KDR0:
            Val->I64 = m_Special.Amd64Special.KernelDr0;
            return S_OK;
        case AMD64_KDR1:
            Val->I64 = m_Special.Amd64Special.KernelDr1;
            return S_OK;
        case AMD64_KDR2:
            Val->I64 = m_Special.Amd64Special.KernelDr2;
            return S_OK;
        case AMD64_KDR3:
            Val->I64 = m_Special.Amd64Special.KernelDr3;
            return S_OK;
        case AMD64_KDR6:
            Val->I64 = m_Special.Amd64Special.KernelDr6;
            return S_OK;
        case AMD64_KDR7:
            Val->I64 = m_Special.Amd64Special.KernelDr7;
            return S_OK;
        }
    }

    ErrOut("Amd64MachineInfo::GetVal: "
           "unknown register %lx requested\n", RegNum);
    return E_INVALIDARG;
}

HRESULT
Amd64MachineInfo::SetVal(ULONG RegNum, REGVAL* Val)
{
    HRESULT Status;
    
    if (m_ContextIsReadOnly)
    {
        return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    
    if (RegNum >= AMD64_SUBREG_BASE)
    {
        return E_INVALIDARG;
    }

    // Optimize away some common cases where registers are
    // set to their current value.
    if ((m_ContextState >= MCTX_PC && RegNum == AMD64_RIP &&
         Val->I64 == m_Context.Amd64Context.Rip) ||
        (((m_ContextState >= MCTX_DR67_REPORT &&
           m_ContextState <= MCTX_REPORT) ||
          m_ContextState >= MCTX_FULL) && RegNum == AMD64_KDR7 &&
         Val->I64 == m_Special.Amd64Special.KernelDr7))
    {
        return S_OK;
    }
    
    if ((Status = GetContextState(MCTX_DIRTY)) != S_OK)
    {
        return Status;
    }

    if (RegNum >= AMD64_MM_FIRST && RegNum <= AMD64_MM_LAST)
    {
        *(ULONG64 UNALIGNED*)&m_Context.Amd64Context.FltSave.
            FloatRegisters[GetMmxRegOffset(RegNum - AMD64_MM_FIRST,
                                           GetReg32(AMD64_FPSW)) * 10] =
            Val->I64;
        goto Notify;
    }
    else if (RegNum >= AMD64_XMM_FIRST && RegNum <= AMD64_XMM_LAST)
    {
        memcpy((PUCHAR)&m_Context.Amd64Context.Xmm0 +
               (RegNum - AMD64_XMM_FIRST) * 16, Val->Bytes, 16);
        goto Notify;
    }
    else if (RegNum >= AMD64_ST_FIRST && RegNum <= AMD64_ST_LAST)
    {
        memcpy(&m_Context.Amd64Context.FltSave.
               FloatRegisters[(RegNum - AMD64_ST_FIRST) * 10],
               Val->F10, sizeof(Val->F10));
        goto Notify;
    }
        
    BOOL Recognized;

    Recognized = TRUE;
    
    switch(RegNum)
    {
    case AMD64_RAX:
        m_Context.Amd64Context.Rax = Val->I64;
        break;
    case AMD64_RCX:
        m_Context.Amd64Context.Rcx = Val->I64;
        break;
    case AMD64_RDX:
        m_Context.Amd64Context.Rdx = Val->I64;
        break;
    case AMD64_RBX:
        m_Context.Amd64Context.Rbx = Val->I64;
        break;
    case AMD64_RSP:
        m_Context.Amd64Context.Rsp = Val->I64;
        break;
    case AMD64_RBP:
        m_Context.Amd64Context.Rbp = Val->I64;
        break;
    case AMD64_RSI:
        m_Context.Amd64Context.Rsi = Val->I64;
        break;
    case AMD64_RDI:
        m_Context.Amd64Context.Rdi = Val->I64;
        break;
    case AMD64_R8:
        m_Context.Amd64Context.R8 = Val->I64;
        break;
    case AMD64_R9:
        m_Context.Amd64Context.R9 = Val->I64;
        break;
    case AMD64_R10:
        m_Context.Amd64Context.R10 = Val->I64;
        break;
    case AMD64_R11:
        m_Context.Amd64Context.R11 = Val->I64;
        break;
    case AMD64_R12:
        m_Context.Amd64Context.R12 = Val->I64;
        break;
    case AMD64_R13:
        m_Context.Amd64Context.R13 = Val->I64;
        break;
    case AMD64_R14:
        m_Context.Amd64Context.R14 = Val->I64;
        break;
    case AMD64_R15:
        m_Context.Amd64Context.R15 = Val->I64;
        break;
        
    case AMD64_RIP:
        m_Context.Amd64Context.Rip = Val->I64;
        break;
    case AMD64_EFL:
        if (IS_KERNEL_TARGET(m_Target))
        {
            // leave TF clear
            m_Context.Amd64Context.EFlags = Val->I32 & ~0x100;
        }
        else
        {
            // allow TF set
            m_Context.Amd64Context.EFlags = Val->I32;
        }
        break;
        
    case AMD64_CS:
        m_Context.Amd64Context.SegCs = Val->I16;
        m_SegRegDesc[SEGREG_CODE].Flags = SEGDESC_INVALID;
        break;
    case AMD64_DS:
        m_Context.Amd64Context.SegDs = Val->I16;
        m_SegRegDesc[SEGREG_DATA].Flags = SEGDESC_INVALID;
        break;
    case AMD64_ES:
        m_Context.Amd64Context.SegEs = Val->I16;
        m_SegRegDesc[SEGREG_ES].Flags = SEGDESC_INVALID;
        break;
    case AMD64_FS:
        m_Context.Amd64Context.SegFs = Val->I16;
        m_SegRegDesc[SEGREG_FS].Flags = SEGDESC_INVALID;
        break;
    case AMD64_GS:
        m_Context.Amd64Context.SegGs = Val->I16;
        m_SegRegDesc[SEGREG_GS].Flags = SEGDESC_INVALID;
        break;
    case AMD64_SS:
        m_Context.Amd64Context.SegSs = Val->I16;
        m_SegRegDesc[SEGREG_STACK].Flags = SEGDESC_INVALID;
        break;

    case AMD64_DR0:
        m_Context.Amd64Context.Dr0 = Val->I64;
        break;
    case AMD64_DR1:
        m_Context.Amd64Context.Dr1 = Val->I64;
        break;
    case AMD64_DR2:
        m_Context.Amd64Context.Dr2 = Val->I64;
        break;
    case AMD64_DR3:
        m_Context.Amd64Context.Dr3 = Val->I64;
        break;
    case AMD64_DR6:
        m_Context.Amd64Context.Dr6 = Val->I64;
        break;
    case AMD64_DR7:
        m_Context.Amd64Context.Dr7 = Val->I64;
        break;

    case AMD64_FPCW:
        m_Context.Amd64Context.FltSave.ControlWord = Val->I16;
        break;
    case AMD64_FPSW:
        m_Context.Amd64Context.FltSave.StatusWord = Val->I16;
        break;
    case AMD64_FPTW:
        m_Context.Amd64Context.FltSave.TagWord = Val->I16;
        break;

    case AMD64_MXCSR:
        m_Context.Amd64Context.MxCsr = Val->I32;
        break;
        
    default:
        Recognized = FALSE;
        break;
    }
        
    if (!Recognized && IS_KERNEL_TARGET(m_Target))
    {
        Recognized = TRUE;
        
        switch(RegNum)
        {
        case AMD64_CR0:
            m_Special.Amd64Special.Cr0 = Val->I64;
            break;
        case AMD64_CR2:
            m_Special.Amd64Special.Cr2 = Val->I64;
            break;
        case AMD64_CR3:
            m_Special.Amd64Special.Cr3 = Val->I64;
            break;
        case AMD64_CR4:
            m_Special.Amd64Special.Cr4 = Val->I64;
            break;
        case AMD64_CR8:
            m_Special.Amd64Special.Cr8 = Val->I64;
            break;
        case AMD64_GDTR:
            m_Special.Amd64Special.Gdtr.Base = Val->I64;
            break;
        case AMD64_GDTL:
            m_Special.Amd64Special.Gdtr.Limit = Val->I16;
            break;
        case AMD64_IDTR:
            m_Special.Amd64Special.Idtr.Base = Val->I64;
            break;
        case AMD64_IDTL:
            m_Special.Amd64Special.Idtr.Limit = Val->I16;
            break;
        case AMD64_TR:
            m_Special.Amd64Special.Tr = Val->I16;
            break;
        case AMD64_LDTR:
            m_Special.Amd64Special.Ldtr = Val->I16;
            break;

        case AMD64_KMXCSR:
            m_Special.Amd64Special.MxCsr = Val->I32;
            break;
        
        case AMD64_KDR0:
            m_Special.Amd64Special.KernelDr0 = Val->I64;
            break;
        case AMD64_KDR1:
            m_Special.Amd64Special.KernelDr1 = Val->I64;
            break;
        case AMD64_KDR2:
            m_Special.Amd64Special.KernelDr2 = Val->I64;
            break;
        case AMD64_KDR3:
            m_Special.Amd64Special.KernelDr3 = Val->I64;
            break;
        case AMD64_KDR6:
            m_Special.Amd64Special.KernelDr6 = Val->I64;
            break;
        case AMD64_KDR7:
            m_Special.Amd64Special.KernelDr7 = Val->I64;
            break;

        default:
            Recognized = FALSE;
            break;
        }
    }

    if (!Recognized)
    {
        ErrOut("Amd64MachineInfo::SetVal: "
               "unknown register %lx requested\n", RegNum);
        return E_INVALIDARG;
    }

 Notify:
    NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS,
                              RegCountFromIndex(RegNum));
    return S_OK;
}

void
Amd64MachineInfo::GetPC(PADDR Address)
{
    // Right now assume that user-mode is always flat 64-bit.
    // This may need to change depending on what WOW support exists.
    if (IS_USER_TARGET(m_Target))
    {
        ADDRFLAT(Address, GetReg64(AMD64_RIP));
    }
    else
    {
        FormAddr(SEGREG_CODE, GetReg64(AMD64_RIP),
                 FORM_CODE | FORM_SEGREG | X86_FORM_VM86(GetReg32(AMD64_EFL)),
                 Address);
    }
}

void
Amd64MachineInfo::SetPC(PADDR paddr)
{
    // We set RIP to the offset (the non-translated value),
    // because we may not be in "flat" mode.
    SetReg64(AMD64_RIP, Off(*paddr));
}

void
Amd64MachineInfo::GetFP(PADDR Addr)
{
    // Right now assume that user-mode is always flat 64-bit.
    // This may need to change depending on what WOW support exists.
    if (IS_USER_TARGET(m_Target))
    {
        ADDRFLAT(Addr, GetReg64(AMD64_RBP));
    }
    else
    {
        FormAddr(SEGREG_STACK, GetReg64(AMD64_RBP),
                 FORM_SEGREG | X86_FORM_VM86(GetReg32(AMD64_EFL)), Addr);
    }
}

void
Amd64MachineInfo::GetSP(PADDR Addr)
{
    // Right now assume that user-mode is always flat 64-bit.
    // This may need to change depending on what WOW support exists.
    if (IS_USER_TARGET(m_Target))
    {
        ADDRFLAT(Addr, GetReg64(AMD64_RSP));
    }
    else
    {
        FormAddr(SEGREG_STACK, GetReg64(AMD64_RSP),
                 FORM_SEGREG | X86_FORM_VM86(GetReg32(AMD64_EFL)), Addr);
    }
}

ULONG64
Amd64MachineInfo::GetArgReg(void)
{
    return GetReg64(AMD64_RCX);
}

ULONG64
Amd64MachineInfo::GetRetReg(void)
{
    return GetReg64(AMD64_RAX);
}

ULONG
Amd64MachineInfo::GetSegRegNum(ULONG SegReg)
{
    //
    // BUGBUG forrestf: the following is here as a workaround for segment
    // decoding that isn't working correctly yet.
    //

    if (IS_USER_TARGET(m_Target))
    {
        return 0;
    }

    switch(SegReg)
    {
    case SEGREG_CODE:
        return AMD64_CS;
    case SEGREG_DATA:
        return AMD64_DS;
    case SEGREG_STACK:
        return AMD64_SS;
    case SEGREG_ES:
        return AMD64_ES;
    case SEGREG_FS:
        return AMD64_FS;
    case SEGREG_GS:
        return AMD64_GS;
    case SEGREG_LDT:
        return AMD64_LDTR;
    }

    return 0;
}

HRESULT
Amd64MachineInfo::GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc)
{
    if (SegReg == SEGREG_GDT)
    {
        Desc->Base = GetReg64(AMD64_GDTR);
        Desc->Limit = GetReg32(AMD64_GDTL);
        Desc->Flags = 0;
        return S_OK;
    }

    // Check and see if we already have a cached descriptor.
    if (m_SegRegDesc[SegReg].Flags != SEGDESC_INVALID)
    {
        *Desc = m_SegRegDesc[SegReg];
        return S_OK;
    }

    HRESULT Status;

    // Attempt to retrieve segment descriptors directly.
    if ((Status = GetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }

    // Check and see if we now have a cached descriptor.
    if (m_SegRegDesc[SegReg].Flags != SEGDESC_INVALID)
    {
        *Desc = m_SegRegDesc[SegReg];
        return S_OK;
    }

    //
    // Direct information is not available so look things up
    // in the descriptor tables.
    //
    
    ULONG RegNum = GetSegRegNum(SegReg);
    if (RegNum == 0)
    {
        return E_INVALIDARG;
    }

    // Do a quick sanity test to prevent bad values
    // from causing problems.
    ULONG Selector = GetReg32(RegNum);
    if (SegReg == SEGREG_LDT && (Selector & 4))
    {
        // The ldtr selector says that it's an LDT selector,
        // which is invalid.  An LDT selector should always
        // reference the GDT.
        ErrOut("Invalid LDTR contents: %04X\n", Selector);
        return E_FAIL;
    }
        
    return m_Target->GetSelDescriptor(m_Target->m_RegContextThread, this,
                                      Selector, Desc);
}

void
Amd64MachineInfo::OutputAll(ULONG Mask, ULONG OutMask)
{
    if (GetContextState(MCTX_FULL) != S_OK)
    {
        ErrOut("Unable to retrieve register information\n");
        return;
    }
    
    if (Mask & (REGALL_INT32 | REGALL_INT64))
    {
        ULONG Efl;

        MaskOut(OutMask, "rax=%016I64x rbx=%016I64x rcx=%016I64x\n",
                GetReg64(AMD64_RAX), GetReg64(AMD64_RBX),
                GetReg64(AMD64_RCX));
        MaskOut(OutMask, "rdx=%016I64x rsi=%016I64x rdi=%016I64x\n",
                GetReg64(AMD64_RDX), GetReg64(AMD64_RSI),
                GetReg64(AMD64_RDI));
        MaskOut(OutMask, "rip=%016I64x rsp=%016I64x rbp=%016I64x\n",
                GetReg64(AMD64_RIP), GetReg64(AMD64_RSP),
                GetReg64(AMD64_RBP));
        MaskOut(OutMask, " r8=%016I64x  r9=%016I64x r10=%016I64x\n",
                GetReg64(AMD64_R8), GetReg64(AMD64_R9),
                GetReg64(AMD64_R10));
        MaskOut(OutMask, "r11=%016I64x r12=%016I64x r13=%016I64x\n",
                GetReg64(AMD64_R11), GetReg64(AMD64_R12),
                GetReg64(AMD64_R13));
        MaskOut(OutMask, "r14=%016I64x r15=%016I64x\n",
                GetReg64(AMD64_R14), GetReg64(AMD64_R15));

        Efl = GetReg32(AMD64_EFL);
        MaskOut(OutMask, "iopl=%1lx %s %s %s %s %s %s %s %s %s %s\n",
                ((Efl >> X86_SHIFT_FLAGIOPL) & X86_BIT_FLAGIOPL),
                (Efl & X86_BIT_FLAGVIP) ? "vip" : "   ",
                (Efl & X86_BIT_FLAGVIF) ? "vif" : "   ",
                (Efl & X86_BIT_FLAGOF) ? "ov" : "nv",
                (Efl & X86_BIT_FLAGDF) ? "dn" : "up",
                (Efl & X86_BIT_FLAGIF) ? "ei" : "di",
                (Efl & X86_BIT_FLAGSF) ? "ng" : "pl",
                (Efl & X86_BIT_FLAGZF) ? "zr" : "nz",
                (Efl & X86_BIT_FLAGAF) ? "ac" : "na",
                (Efl & X86_BIT_FLAGPF) ? "po" : "pe",
                (Efl & X86_BIT_FLAGCF) ? "cy" : "nc");
    }

    if (Mask & REGALL_SEGREG)
    {
        MaskOut(OutMask, "cs=%04lx  ss=%04lx  ds=%04lx  es=%04lx  fs=%04lx  "
                "gs=%04lx             efl=%08lx\n",
                GetReg32(AMD64_CS),
                GetReg32(AMD64_SS),
                GetReg32(AMD64_DS),
                GetReg32(AMD64_ES),
                GetReg32(AMD64_FS),
                GetReg32(AMD64_GS),
                GetReg32(AMD64_EFL));
    }

    if (Mask & REGALL_FLOAT)
    {
        ULONG i;
        REGVAL Val;
        char Buf[32];

        MaskOut(OutMask, "fpcw=%04X    fpsw=%04X    fptw=%04X\n",
                GetReg32(AMD64_FPCW),
                GetReg32(AMD64_FPSW),
                GetReg32(AMD64_FPTW));

        for (i = AMD64_ST_FIRST; i <= AMD64_ST_LAST; i++)
        {
            GetVal(i, &Val);
            _uldtoa((_ULDOUBLE *)&Val.F10, sizeof(Buf), Buf);
            MaskOut(OutMask, "st%d=%s  ", i - AMD64_ST_FIRST, Buf);
            i++;
            GetVal(i, &Val);
            _uldtoa((_ULDOUBLE *)&Val.F10, sizeof(Buf), Buf);
            MaskOut(OutMask, "st%d=%s\n", i - AMD64_ST_FIRST, Buf);
        }
    }

    if (Mask & REGALL_MMXREG)
    {
        ULONG i;
        REGVAL Val;

        for (i = AMD64_MM_FIRST; i <= AMD64_MM_LAST; i++)
        {
            GetVal(i, &Val);
            MaskOut(OutMask, "mm%d=%016I64x  ", i - AMD64_MM_FIRST, Val.I64);
            i++;
            GetVal(i, &Val);
            MaskOut(OutMask, "mm%d=%016I64x\n", i - AMD64_MM_FIRST, Val.I64);
        }
    }

    if (Mask & REGALL_XMMREG)
    {
        ULONG i;
        REGVAL Val;

        for (i = AMD64_XMM_FIRST; i <= AMD64_XMM_LAST; i++)
        {
            GetVal(i, &Val);
            MaskOut(OutMask, "xmm%d=%hg %hg %hg %hg\n", i - AMD64_XMM_FIRST,
                    *(float *)&Val.Bytes[3 * sizeof(float)],
                    *(float *)&Val.Bytes[2 * sizeof(float)],
                    *(float *)&Val.Bytes[1 * sizeof(float)],
                    *(float *)&Val.Bytes[0 * sizeof(float)]);
        }
    }

    if (Mask & REGALL_CREG)
    {
        MaskOut(OutMask, "cr0=%016I64x cr2=%016I64x cr3=%016I64x\n",
                GetReg64(AMD64_CR0),
                GetReg64(AMD64_CR2),
                GetReg64(AMD64_CR3));
        MaskOut(OutMask, "cr8=%016I64x\n",
                GetReg64(AMD64_CR8));
    }

    if (Mask & REGALL_DREG)
    {
        MaskOut(OutMask, "dr0=%016I64x dr1=%016I64x dr2=%016I64x\n",
                GetReg64(AMD64_DR0),
                GetReg64(AMD64_DR1),
                GetReg64(AMD64_DR2));
        MaskOut(OutMask, "dr3=%016I64x dr6=%016I64x dr7=%016I64x",
                GetReg64(AMD64_DR3),
                GetReg64(AMD64_DR6),
                GetReg64(AMD64_DR7));
        if (IS_USER_TARGET(m_Target))
        {
            MaskOut(OutMask, "\n");
        }
        else
        {
            MaskOut(OutMask, " cr4=%016I64x\n", GetReg64(AMD64_CR4));
            MaskOut(OutMask, "kdr0=%016I64x kdr1=%016I64x kdr2=%016I64x\n",
                    GetReg64(AMD64_KDR0),
                    GetReg64(AMD64_KDR1),
                    GetReg64(AMD64_KDR2));
            MaskOut(OutMask, "kdr3=%016I64x kdr6=%016I64x kdr7=%016I64x",
                    GetReg64(AMD64_KDR3),
                    GetReg64(AMD64_KDR6),
                    GetReg64(AMD64_KDR7));
        }
    }

    if (Mask & REGALL_DESC)
    {
        MaskOut(OutMask, "gdtr=%016I64x   gdtl=%04lx idtr=%016I64x   "
                "idtl=%04lx tr=%04lx  ldtr=%04x\n",
                GetReg64(AMD64_GDTR),
                GetReg32(AMD64_GDTL),
                GetReg64(AMD64_IDTR),
                GetReg32(AMD64_IDTL),
                GetReg32(AMD64_TR),
                GetReg32(AMD64_LDTR));
    }
}

HRESULT
Amd64MachineInfo::SetAndOutputTrapFrame(ULONG64 TrapBase,
                                        PCROSS_PLATFORM_CONTEXT Context)
{
    return SetAndOutputContext(Context, TRUE, REGALL_INT64);
}

TRACEMODE
Amd64MachineInfo::GetTraceMode (void)
{
    if (IS_KERNEL_TARGET(m_Target))
    {
        return m_TraceMode;
    }
    else
    {
        return ((GetReg32(AMD64_EFL) & X86_BIT_FLAGTF) != 0) ? 
                   TRACE_INSTRUCTION : TRACE_NONE;
    }
}

void 
Amd64MachineInfo::SetTraceMode (TRACEMODE Mode)
{
    // (XXX olegk - review for TRACE_TAKEN_BRANCH)
    DBG_ASSERT(Mode != TRACE_TAKEN_BRANCH);

    if (IS_KERNEL_TARGET(m_Target))
    {
        m_TraceMode = Mode;
    }
    else
    {
        ULONG Efl = GetReg32(AMD64_EFL);
        switch (Mode)
        {
        case TRACE_NONE:
            Efl &= ~X86_BIT_FLAGTF;
            break;
        case TRACE_INSTRUCTION:
            Efl |= X86_BIT_FLAGTF;
            break;
        }   
        SetReg32(AMD64_EFL, Efl);
    }
}

BOOL
Amd64MachineInfo::IsStepStatusSupported(ULONG Status)
{
    switch (Status) 
    {
    case DEBUG_STATUS_STEP_INTO:
    case DEBUG_STATUS_STEP_OVER:
        return TRUE;
    default:
        return FALSE;
    }
}

void
Amd64MachineInfo::KdUpdateControlSet
    (PDBGKD_ANY_CONTROL_SET ControlSet)
{
    ControlSet->Amd64ControlSet.TraceFlag = 
        (GetTraceMode() == TRACE_INSTRUCTION);
    ControlSet->Amd64ControlSet.Dr7 = GetReg64(AMD64_KDR7);

    BpOut("UpdateControlSet(%d) trace %d, DR7 %I64X\n",
          m_Target->m_RegContextProcessor,
          ControlSet->Amd64ControlSet.TraceFlag,
          ControlSet->Amd64ControlSet.Dr7);
    
    if (!g_WatchFunctions.IsStarted() && g_WatchBeginCurFunc != 1)
    {
        ControlSet->Amd64ControlSet.CurrentSymbolStart = 0;
        ControlSet->Amd64ControlSet.CurrentSymbolEnd = 0;
    }
    else
    {
        ControlSet->Amd64ControlSet.CurrentSymbolStart = g_WatchBeginCurFunc;
        ControlSet->Amd64ControlSet.CurrentSymbolEnd = g_WatchEndCurFunc;
    }
}

ULONG
Amd64MachineInfo::ExecutingMachine(void)
{
    if (IS_USER_TARGET(m_Target) &&
        IsIa32CodeSegment())
    {
        return IMAGE_FILE_MACHINE_I386;
    }
        
    return IMAGE_FILE_MACHINE_AMD64;
}

HRESULT
Amd64MachineInfo::SetPageDirectory(ThreadInfo* Thread,
                                   ULONG Idx, ULONG64 PageDir,
                                   PULONG NextIdx)
{
    HRESULT Status;
    
    *NextIdx = PAGE_DIR_COUNT;
    
    if (PageDir == 0)
    {
        if ((Status = m_Target->ReadImplicitProcessInfoPointer
             (Thread,
              m_Target->m_KdDebuggerData.OffsetEprocessDirectoryTableBase,
              &PageDir)) != S_OK)
        {
            return Status;
        }
    }

    // Sanitize the value.
    PageDir &= AMD64_PDBR_MASK;

    // There is only one page directory so update all the slots.
    m_PageDirectories[PAGE_DIR_USER] = PageDir;
    m_PageDirectories[PAGE_DIR_SESSION] = PageDir;
    m_PageDirectories[PAGE_DIR_KERNEL] = PageDir;
    
    return S_OK;
}

#define AMD64_PAGE_FILE_INDEX(Entry) \
    (((ULONG)(Entry) >> 28) & MAX_PAGING_FILE_MASK)
#define AMD64_PAGE_FILE_OFFSET(Entry) \
    (((Entry) >> 32) << AMD64_PAGE_SHIFT)

HRESULT
Amd64MachineInfo::GetVirtualTranslationPhysicalOffsets(ThreadInfo* Thread,
                                                       ULONG64 Virt,
                                                       PULONG64 Offsets,
                                                       ULONG OffsetsSize,
                                                       PULONG Levels,
                                                       PULONG PfIndex,
                                                       PULONG64 LastVal)
{
    HRESULT Status;
    
    *Levels = 0;
    
    if (m_Translating)
    {
        return E_UNEXPECTED;
    }
    m_Translating = TRUE;
    
    //
    // Reset the page directory in case it was 0
    //
    if (m_PageDirectories[PAGE_DIR_SINGLE] == 0)
    {
        if ((Status = SetDefaultPageDirectories(Thread,
                                                1 << PAGE_DIR_SINGLE)) != S_OK)
        {
            m_Translating = FALSE;
            return Status;
        }
    }
    
    KdOut("Amd64VtoP: Virt %s, pagedir %s\n",
          FormatMachineAddr64(this, Virt),
          FormatDisp64(m_PageDirectories[PAGE_DIR_SINGLE]));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = m_PageDirectories[PAGE_DIR_SINGLE];
        OffsetsSize--;
    }
        
    //
    // Certain ranges of the system are mapped directly.
    //

    if ((Virt >= AMD64_PHYSICAL_START) && (Virt <= AMD64_PHYSICAL_END))
    {
        *LastVal = Virt - AMD64_PHYSICAL_START;

        KdOut("Amd64VtoP: Direct phys %s\n",
              FormatDisp64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }

        m_Translating = FALSE;
        return S_OK;
    }
    
    ULONG64 Addr;
    ULONG64 Entry;

    // Read the Page Map Level 4 entry.
    
    Addr = (((Virt >> AMD64_PML4E_SHIFT) & AMD64_PML4E_MASK) *
            sizeof(Entry)) + m_PageDirectories[PAGE_DIR_SINGLE];

    KdOut("Amd64VtoP: PML4E %s\n", FormatDisp64(Addr));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = Addr;
        OffsetsSize--;
    }

    if ((Status = m_Target->
         ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
    {
        KdOut("Amd64VtoP: PML4E read error 0x%X\n", Status);
        m_Translating = FALSE;
        return Status;
    }

    // Read the Page Directory Pointer entry.
    
    if (Entry == 0)
    {
        KdOut("Amd64VtoP: zero PML4E\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> AMD64_PDPE_SHIFT) & AMD64_PDPE_MASK) *
                sizeof(Entry)) + AMD64_PAGE_FILE_OFFSET(Entry);

        KdOut("Amd64VtoP: pagefile PDPE %d:%s\n",
              AMD64_PAGE_FILE_INDEX(Entry), FormatDisp64(Addr));
        
        if ((Status = m_Target->
             ReadPageFile(AMD64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PML4E not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = (((Virt >> AMD64_PDPE_SHIFT) & AMD64_PDPE_MASK) *
                sizeof(Entry)) + (Entry & AMD64_VALID_PFN_MASK);

        KdOut("Amd64VtoP: PDPE %s\n", FormatDisp64(Addr));
        
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }

        if ((Status = m_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PDPE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    // Read the Page Directory entry.
        
    if (Entry == 0)
    {
        KdOut("Amd64VtoP: zero PDPE\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> AMD64_PDE_SHIFT) & AMD64_PDE_MASK) *
                sizeof(Entry)) + AMD64_PAGE_FILE_OFFSET(Entry);

        KdOut("Amd64VtoP: pagefile PDE %d:%s\n",
              AMD64_PAGE_FILE_INDEX(Entry), FormatDisp64(Addr));
        
        if ((Status = m_Target->
             ReadPageFile(AMD64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PDPE not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = (((Virt >> AMD64_PDE_SHIFT) & AMD64_PDE_MASK) *
                sizeof(Entry)) + (Entry & AMD64_VALID_PFN_MASK);

        KdOut("Amd64VtoP: PDE %s\n", FormatDisp64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }

        if ((Status = m_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PDE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    // Check for a large page.  Large pages can
    // never be paged out so also check for the present bit.
    if ((Entry & (AMD64_LARGE_PAGE_MASK | 1)) == (AMD64_LARGE_PAGE_MASK | 1))
    {
        *LastVal = ((Entry & ~(AMD64_LARGE_PAGE_SIZE - 1)) |
                     (Virt & (AMD64_LARGE_PAGE_SIZE - 1)));
            
        KdOut("Amd64VtoP: Large page mapped phys %s\n",
              FormatDisp64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }

        m_Translating = FALSE;
        return S_OK;
    }
        
    // Read the Page Table entry.

    if (Entry == 0)
    {
        KdOut("Amd64VtoP: zero PDE\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> AMD64_PTE_SHIFT) & AMD64_PTE_MASK) *
                sizeof(Entry)) + AMD64_PAGE_FILE_OFFSET(Entry);

        KdOut("Amd64VtoP: pagefile PTE %d:%s\n",
              AMD64_PAGE_FILE_INDEX(Entry), FormatDisp64(Addr));
        
        if ((Status = m_Target->
             ReadPageFile(AMD64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PDE not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = (((Virt >> AMD64_PTE_SHIFT) & AMD64_PTE_MASK) *
                sizeof(Entry)) + (Entry & AMD64_VALID_PFN_MASK);

        KdOut("Amd64VtoP: PTE %s\n", FormatDisp64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }

        if ((Status = m_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PTE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    if (!(Entry & 0x1) &&
        ((Entry & AMD64_MM_PTE_PROTOTYPE_MASK) ||
         !(Entry & AMD64_MM_PTE_TRANSITION_MASK)))
    {
        if (Entry == 0)
        {
            KdOut("Amd64VtoP: zero PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else if (Entry & AMD64_MM_PTE_PROTOTYPE_MASK)
        {
            KdOut("Amd64VtoP: prototype PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else
        {
            *PfIndex = AMD64_PAGE_FILE_INDEX(Entry);
            *LastVal = (Virt & (AMD64_PAGE_SIZE - 1)) +
                AMD64_PAGE_FILE_OFFSET(Entry);
            KdOut("Amd64VtoP: PTE not present, pagefile %d:%s\n",
                  *PfIndex, FormatDisp64(*LastVal));
            Status = HR_PAGE_IN_PAGE_FILE;
        }
        m_Translating = FALSE;
        return Status;
    }

    *LastVal = ((Entry & AMD64_VALID_PFN_MASK) |
                 (Virt & (AMD64_PAGE_SIZE - 1)));
    
    KdOut("Amd64VtoP: Mapped phys %s\n", FormatDisp64(*LastVal));

    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = *LastVal;
        OffsetsSize--;
    }

    m_Translating = FALSE;
    return S_OK;
}

HRESULT
Amd64MachineInfo::GetBaseTranslationVirtualOffset(PULONG64 Offset)
{
    *Offset = AMD64_BASE_VIRT;
    return S_OK;
}
 
void
Amd64MachineInfo::DecodePte(ULONG64 Pte, PULONG64 PageFrameNumber,
                            PULONG Flags)
{
    *PageFrameNumber = (Pte & AMD64_VALID_PFN_MASK) >> AMD64_PAGE_SHIFT;
    *Flags = (Pte & 1) ? MPTE_FLAG_VALID : 0;
}

void
Amd64MachineInfo::OutputFunctionEntry(PVOID RawEntry)
{
    _PIMAGE_RUNTIME_FUNCTION_ENTRY Entry =
        (_PIMAGE_RUNTIME_FUNCTION_ENTRY)RawEntry;
    
    dprintf("BeginAddress      = %s\n",
            FormatMachineAddr64(this, Entry->BeginAddress));
    dprintf("EndAddress        = %s\n",
            FormatMachineAddr64(this, Entry->EndAddress));
    dprintf("UnwindInfoAddress = %s\n",
            FormatMachineAddr64(this, Entry->UnwindInfoAddress));
}

HRESULT
Amd64MachineInfo::ReadDynamicFunctionTable(ProcessInfo* Process,
                                           ULONG64 Table,
                                           PULONG64 NextTable,
                                           PULONG64 MinAddress,
                                           PULONG64 MaxAddress,
                                           PULONG64 BaseAddress,
                                           PULONG64 TableData,
                                           PULONG TableSize,
                                           PWSTR OutOfProcessDll,
                                           PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable)
{
    HRESULT Status;

    if ((Status = m_Target->
         ReadAllVirtual(Process, Table, &RawTable->Amd64Table,
                        sizeof(RawTable->Amd64Table))) != S_OK)
    {
        return Status;
    }

    *NextTable = RawTable->Amd64Table.ListEntry.Flink;
    *MinAddress = RawTable->Amd64Table.MinimumAddress;
    *MaxAddress = RawTable->Amd64Table.MaximumAddress;
    *BaseAddress = RawTable->Amd64Table.BaseAddress;
    if (RawTable->Amd64Table.Type == AMD64_RF_CALLBACK)
    {
        ULONG Done;
        
        *TableData = 0;
        *TableSize = 0;
        if ((Status = m_Target->
             ReadVirtual(Process, RawTable->Amd64Table.OutOfProcessCallbackDll,
                         OutOfProcessDll, (MAX_PATH - 1) * sizeof(WCHAR),
                         &Done)) != S_OK)
        {
            return Status;
        }

        OutOfProcessDll[Done / sizeof(WCHAR)] = 0;
    }
    else
    {
        *TableData = RawTable->Amd64Table.FunctionTable;
        *TableSize = RawTable->Amd64Table.EntryCount *
            sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY);
        OutOfProcessDll[0] = 0;
    }
    return S_OK;
}

PVOID
Amd64MachineInfo::FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize)
{
    ULONG i;
    _PIMAGE_RUNTIME_FUNCTION_ENTRY Func;
    static _IMAGE_RUNTIME_FUNCTION_ENTRY s_RetFunc;

    Func = (_PIMAGE_RUNTIME_FUNCTION_ENTRY)TableData;
    for (i = 0; i < TableSize / sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY); i++)
    {
        if (Address >= Table->Amd64Table.BaseAddress + Func->BeginAddress &&
            Address < Table->Amd64Table.BaseAddress + Func->EndAddress)
        {
            // The table data is temporary so copy the data into
            // a static buffer for longer-term storage.
            s_RetFunc.BeginAddress = Func->BeginAddress;
            s_RetFunc.EndAddress = Func->EndAddress;
            s_RetFunc.UnwindInfoAddress = Func->UnwindInfoAddress;
            return (PVOID)&s_RetFunc;
        }

        Func++;
    }

    return NULL;
}

HRESULT
Amd64MachineInfo::GetUnwindInfoBounds(ProcessInfo* Process,
                                      ULONG64 TableBase,
                                      PVOID RawTableEntries,
                                      ULONG EntryIndex,
                                      PULONG64 Start,
                                      PULONG Size)
{
    HRESULT Status;
    _PIMAGE_RUNTIME_FUNCTION_ENTRY FuncEnt =
        (_PIMAGE_RUNTIME_FUNCTION_ENTRY)RawTableEntries + EntryIndex;
    AMD64_UNWIND_INFO Info;
    
    *Start = TableBase + FuncEnt->UnwindInfoAddress;
    if ((Status = m_Target->
         ReadAllVirtual(Process, *Start, &Info, sizeof(Info))) != S_OK)
    {
        return Status;
    }
    *Size = sizeof(Info) + (Info.CountOfCodes - 1) * sizeof(AMD64_UNWIND_CODE);
    // An extra alignment code and pointer may be added on to handle
    // the chained info case where the chain pointer is just
    // beyond the end of the normal code array.
    if ((Info.Flags & AMD64_UNW_FLAG_CHAININFO) != 0)
    {
        if ((Info.CountOfCodes & 1) != 0)
        {
            (*Size) += sizeof(AMD64_UNWIND_CODE);
        }
        (*Size) += sizeof(ULONG64);
    }

    return S_OK;
}

HRESULT
Amd64MachineInfo::ReadKernelProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    HRESULT Status;
    ULONG64 Prcb;
    ULONG Data;

    if ((Status = m_Target->
         GetProcessorSystemDataOffset(Processor, DEBUG_DATA_KPRCB_OFFSET,
                                      &Prcb)) != S_OK)
    {
        return Status;
    }

    if ((Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        Prcb + m_Target->m_KdDebuggerData.OffsetPrcbCpuType,
                        &Data, sizeof(Data))) != S_OK)
    {
        return Status;
    }

    Id->Amd64.Family = Data & 0xf;
    Id->Amd64.Model = (Data >> 24) & 0xf;
    Id->Amd64.Stepping = (Data >> 16) & 0xf;
    
    if ((Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        Prcb +
                        m_Target->m_KdDebuggerData.OffsetPrcbVendorString,
                        Id->Amd64.VendorString,
                        sizeof(Id->Amd64.VendorString))) != S_OK)
    {
        return Status;
    }

    return S_OK;
}

HRESULT
Amd64MachineInfo::StaticGetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context,
                                       EXDI_CONTEXT_TYPE CtxType)
{
    DBG_ASSERT(CtxType == EXDI_CTX_AMD64);

    // Always ask for everything.
    Context->Amd64Context.RegGroupSelection.fSegmentRegs = TRUE;
    Context->Amd64Context.RegGroupSelection.fControlRegs = TRUE;
    Context->Amd64Context.RegGroupSelection.fIntegerRegs = TRUE;
    Context->Amd64Context.RegGroupSelection.fFloatingPointRegs = TRUE;
    Context->Amd64Context.RegGroupSelection.fDebugRegs = TRUE;
    Context->Amd64Context.RegGroupSelection.fSegmentDescriptors = TRUE;
    Context->Amd64Context.RegGroupSelection.fSSERegisters = TRUE;
    Context->Amd64Context.RegGroupSelection.fSystemRegisters = TRUE;
    return ((IeXdiX86_64Context*)Exdi)->GetContext(&Context->Amd64Context);
}
    
//----------------------------------------------------------------------------
//
// X86OnAmd64MachineInfo.
//
//----------------------------------------------------------------------------

X86OnAmd64MachineInfo::X86OnAmd64MachineInfo(TargetInfo* Target)
    : X86MachineInfo(Target)
{
    // Nothing right now.
}

HRESULT
X86OnAmd64MachineInfo::UdGetContextState(ULONG State)
{
    HRESULT Status;
    
    if ((Status = m_Target->m_Machines[MACHIDX_AMD64]->
         UdGetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }

    Amd64ContextToX86(&m_Target->m_Machines[MACHIDX_AMD64]->
                      m_Context.Amd64Context,
                      &m_Context.X86Nt5Context);
    m_ContextState = MCTX_FULL;

    return S_OK;
}

HRESULT
X86OnAmd64MachineInfo::UdSetContext(void)
{
    m_Target->m_Machines[MACHIDX_AMD64]->
        InitializeContextFlags(&m_Target->m_Machines[MACHIDX_AMD64]->m_Context,
                               m_Target->m_SystemVersion);
    X86ContextToAmd64(&m_Context.X86Nt5Context,
                      &m_Target->m_Machines[MACHIDX_AMD64]->
                      m_Context.Amd64Context);
    return m_Target->m_Machines[MACHIDX_AMD64]->UdSetContext();
}

HRESULT
X86OnAmd64MachineInfo::KdGetContextState(ULONG State)
{
    HRESULT Status;
    
    dprintf("The context is partially valid. "
            "Only x86 user-mode context is available.\n");
    if ((Status = m_Target->m_Machines[MACHIDX_AMD64]->
         KdGetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }

    Amd64ContextToX86(&m_Target->m_Machines[MACHIDX_AMD64]->
                      m_Context.Amd64Context,
                      &m_Context.X86Nt5Context);
    m_ContextState = MCTX_FULL;

    return S_OK;
}

HRESULT
X86OnAmd64MachineInfo::KdSetContext(void)
{
    dprintf("The context is partially valid. "
            "Only x86 user-mode context is available.\n");
    m_Target->m_Machines[MACHIDX_AMD64]->
        InitializeContextFlags(&m_Target->m_Machines[MACHIDX_AMD64]->m_Context,
                               m_Target->m_SystemVersion);
    X86ContextToAmd64(&m_Context.X86Nt5Context,
                      &m_Target->m_Machines[MACHIDX_AMD64]->
                      m_Context.Amd64Context);
    return m_Target->m_Machines[MACHIDX_AMD64]->KdSetContext();
}

HRESULT
X86OnAmd64MachineInfo::GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc)
{
    ULONG RegNum = GetSegRegNum(SegReg);
    if (RegNum == 0)
    {
        return E_INVALIDARG;
    }

    return m_Target->
        EmulateNtAmd64SelDescriptor(m_Target->m_RegContextThread,
                                    m_Target->m_Machines[MACHIDX_AMD64],
                                    GetIntReg(RegNum),
                                    Desc);
}

void
X86OnAmd64MachineInfo::Amd64ContextToX86(PAMD64_CONTEXT ContextAmd64,
                                         PX86_NT5_CONTEXT ContextX86)
{
    ULONG Ia32ContextFlags = ContextX86->ContextFlags;
    ULONG i;

    ULONG Tid = GetCurrentThreadId();
    DebugClient* Client;
 

    if ((Ia32ContextFlags & VDMCONTEXT_CONTROL) == VDMCONTEXT_CONTROL)
    {
        //
        // And the control stuff
        //
        ContextX86->Ebp    = (ULONG)ContextAmd64->Rbp;
        ContextX86->SegCs  = ContextAmd64->SegCs;
        ContextX86->Eip    = (ULONG)ContextAmd64->Rip;
        ContextX86->SegSs  = ContextAmd64->SegSs;
        ContextX86->Esp    = (ULONG)ContextAmd64->Rsp;
        ContextX86->EFlags = ContextAmd64->EFlags;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_INTEGER)  == VDMCONTEXT_INTEGER)
    {
        //
        // Now for the integer state...
        //
        ContextX86->Edi = (ULONG)ContextAmd64->Rdi;
        ContextX86->Esi = (ULONG)ContextAmd64->Rsi;
        ContextX86->Ebx = (ULONG)ContextAmd64->Rbx;
        ContextX86->Edx = (ULONG)ContextAmd64->Rdx;
        ContextX86->Ecx = (ULONG)ContextAmd64->Rcx;
        ContextX86->Eax = (ULONG)ContextAmd64->Rax;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_SEGMENTS) == VDMCONTEXT_SEGMENTS)
    {
        ContextX86->SegGs = ContextAmd64->SegGs;
        ContextX86->SegEs = ContextAmd64->SegEs;
        ContextX86->SegDs = ContextAmd64->SegDs;
        ContextX86->SegSs = ContextAmd64->SegSs;
        ContextX86->SegFs = ContextAmd64->SegFs;
        ContextX86->SegCs = ContextAmd64->SegCs;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_EXTENDED_REGISTERS) ==
        VDMCONTEXT_EXTENDED_REGISTERS)
    {
        PX86_FXSAVE_FORMAT FxSave =
            (PX86_FXSAVE_FORMAT)ContextX86->ExtendedRegisters;
        
        FxSave->ControlWord   = ContextAmd64->FltSave.ControlWord;
        FxSave->StatusWord    = ContextAmd64->FltSave.StatusWord;
        FxSave->TagWord       = ContextAmd64->FltSave.TagWord;
        FxSave->ErrorOpcode   = ContextAmd64->FltSave.ErrorOpcode;
        FxSave->ErrorOffset   = ContextAmd64->FltSave.ErrorOffset;
        FxSave->ErrorSelector = ContextAmd64->FltSave.ErrorSelector;
        FxSave->DataOffset    = ContextAmd64->FltSave.DataOffset;
        FxSave->DataSelector  = ContextAmd64->FltSave.DataSelector;
        FxSave->MXCsr         = ContextAmd64->MxCsr;

        for (i = 0; i < NUMBER_OF_387_REGS; i++)
        {
            memcpy(FxSave->RegisterArea + 16 * i,
                   ContextAmd64->FltSave.FloatRegisters + 10 * i,
                   10);
        }

        for (i = 0; i < NUMBER_OF_XMMI_REGS; i++)
        {
            memcpy(FxSave->Reserved3 + 16 * i,
                   &ContextAmd64->Xmm0 + 16 * i,
                   16);
        }
    }

    if ((Ia32ContextFlags & VDMCONTEXT_FLOATING_POINT) ==
        VDMCONTEXT_FLOATING_POINT)
    {
        //
        // Copy over the floating point status/control stuff
        //
        ContextX86->FloatSave.ControlWord   = ContextAmd64->FltSave.ControlWord;
        ContextX86->FloatSave.StatusWord    = ContextAmd64->FltSave.StatusWord;
        ContextX86->FloatSave.TagWord       = ContextAmd64->FltSave.TagWord;
        ContextX86->FloatSave.ErrorOffset   = ContextAmd64->FltSave.ErrorOffset;
        ContextX86->FloatSave.ErrorSelector = ContextAmd64->FltSave.ErrorSelector;
        ContextX86->FloatSave.DataOffset    = ContextAmd64->FltSave.DataOffset;
        ContextX86->FloatSave.DataSelector  = ContextAmd64->FltSave.DataSelector;

        for (i = 0; i < NUMBER_OF_387_REGS; i++)
        {
            memcpy(ContextX86->FloatSave.RegisterArea + 10 * i,
                   ContextAmd64->FltSave.FloatRegisters + 10 * i,
                   10);
        }
    }

    if ((Ia32ContextFlags & VDMCONTEXT_DEBUG_REGISTERS) ==
        VDMCONTEXT_DEBUG_REGISTERS)
    {
        ContextX86->Dr0 = (ULONG)ContextAmd64->Dr0;
        ContextX86->Dr1 = (ULONG)ContextAmd64->Dr1;
        ContextX86->Dr2 = (ULONG)ContextAmd64->Dr2;
        ContextX86->Dr3 = (ULONG)ContextAmd64->Dr3;
        ContextX86->Dr6 = (ULONG)ContextAmd64->Dr6;
        ContextX86->Dr7 = (ULONG)ContextAmd64->Dr7;
    }

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_ThreadId == Tid)
        {
            break;
        }
    }

    DBG_ASSERT(Client != NULL);

    if (!((Amd64MachineInfo*)m_Target->m_Machines[MACHIDX_AMD64])->
        IsIa32CodeSegment())
    {
        if (g_Wow64exts == NULL)
        {
            dprintf("Need to load wow64exts.dll to retrieve context!\n");
            return;
        }
        (*g_Wow64exts)(WOW64EXTS_GET_CONTEXT, 
                       (ULONG64)Client,
                       (ULONG64)ContextX86,
                       (ULONG64)NULL);
        return;
    }
}

void
X86OnAmd64MachineInfo::X86ContextToAmd64(PX86_NT5_CONTEXT ContextX86,
                                         PAMD64_CONTEXT ContextAmd64)
{
    ULONG Ia32ContextFlags = ContextX86->ContextFlags;
    ULONG i;

    ULONG Tid = GetCurrentThreadId();
    DebugClient* Client;
 
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_ThreadId == Tid)
        {
            break;
        }
    }

    DBG_ASSERT(Client != NULL);

    if (!((Amd64MachineInfo*)m_Target->m_Machines[MACHIDX_AMD64])->
        IsIa32CodeSegment())
    {
        if (g_Wow64exts == NULL)
        {
            dprintf("Need to load wow64exts.dll to retrieve context!\n");
            return;
        }
        (*g_Wow64exts)(WOW64EXTS_SET_CONTEXT, 
                       (ULONG64)Client,
                       (ULONG64)ContextX86,
                       (ULONG64)NULL);
        return;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_CONTROL) == VDMCONTEXT_CONTROL)
    {
        //
        // And the control stuff
        //
        ContextAmd64->Rbp = ContextX86->Ebp;
        ContextAmd64->Rip = ContextX86->Eip;
        ContextAmd64->SegCs = (USHORT)ContextX86->SegCs;
        ContextAmd64->Rsp = ContextX86->Esp;
        ContextAmd64->SegSs = (USHORT)ContextX86->SegSs;
        ContextAmd64->EFlags = ContextX86->EFlags;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_INTEGER) == VDMCONTEXT_INTEGER)
    {
        //
        // Now for the integer state...
        //
         ContextAmd64->Rdi = ContextX86->Edi;
         ContextAmd64->Rsi = ContextX86->Esi;
         ContextAmd64->Rbx = ContextX86->Ebx;
         ContextAmd64->Rdx = ContextX86->Edx;
         ContextAmd64->Rcx = ContextX86->Ecx;
         ContextAmd64->Rax = ContextX86->Eax;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_SEGMENTS) == VDMCONTEXT_SEGMENTS)
    {
        ContextAmd64->SegGs = (USHORT)ContextX86->SegGs;
        ContextAmd64->SegEs = (USHORT)ContextX86->SegEs;
        ContextAmd64->SegDs = (USHORT)ContextX86->SegDs;
        ContextAmd64->SegSs = (USHORT)ContextX86->SegSs;
        ContextAmd64->SegFs = (USHORT)ContextX86->SegFs;
        ContextAmd64->SegCs = (USHORT)ContextX86->SegCs;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_EXTENDED_REGISTERS) ==
        VDMCONTEXT_EXTENDED_REGISTERS)
    {
        PX86_FXSAVE_FORMAT FxSave =
            (PX86_FXSAVE_FORMAT)ContextX86->ExtendedRegisters;
 
        //
        // And copy over the floating point status/control stuff
        //
        ContextAmd64->FltSave.ControlWord   = FxSave->ControlWord;
        ContextAmd64->FltSave.StatusWord    = FxSave->StatusWord;
        ContextAmd64->FltSave.TagWord       = FxSave->TagWord;
        ContextAmd64->FltSave.ErrorOpcode   = FxSave->ErrorOpcode;
        ContextAmd64->FltSave.ErrorOffset   = FxSave->ErrorOffset;
        ContextAmd64->FltSave.ErrorSelector = (USHORT)FxSave->ErrorSelector;
        ContextAmd64->FltSave.DataOffset    = FxSave->DataOffset;
        ContextAmd64->FltSave.DataSelector  = (USHORT)FxSave->DataSelector;
        ContextAmd64->MxCsr                 = FxSave->MXCsr;

        for (i = 0; i < NUMBER_OF_387_REGS; i++)
        {
            memcpy(ContextAmd64->FltSave.FloatRegisters + 10 * i,
                   FxSave->RegisterArea + 16 * i,
                   10);
        }

        for (i = 0; i < NUMBER_OF_XMMI_REGS; i++)
        {
            memcpy(&ContextAmd64->Xmm0 + 16 * i,
                   FxSave->Reserved3 + 16 * i,
                   16);
        }
    }

    if ((Ia32ContextFlags & VDMCONTEXT_FLOATING_POINT) ==
        VDMCONTEXT_FLOATING_POINT)
    {
        //
        // Copy over the floating point status/control stuff
        // Leave the MXCSR stuff alone
        //
        ContextAmd64->FltSave.ControlWord   = (USHORT)ContextX86->FloatSave.ControlWord;
        ContextAmd64->FltSave.StatusWord    = (USHORT)ContextX86->FloatSave.StatusWord;
        ContextAmd64->FltSave.TagWord       = (USHORT)ContextX86->FloatSave.TagWord;
        ContextAmd64->FltSave.ErrorOffset   = ContextX86->FloatSave.ErrorOffset;
        ContextAmd64->FltSave.ErrorSelector = (USHORT)ContextX86->FloatSave.ErrorSelector;
        ContextAmd64->FltSave.DataOffset    = ContextX86->FloatSave.DataOffset;
        ContextAmd64->FltSave.DataSelector  = (USHORT)ContextX86->FloatSave.DataSelector;

        for (i = 0; i < NUMBER_OF_387_REGS; i++)
        {
            memcpy(ContextAmd64->FltSave.FloatRegisters + 10 * i,
                   ContextX86->FloatSave.RegisterArea + 10 * i,
                   10);
        }
    }

    if ((Ia32ContextFlags & VDMCONTEXT_DEBUG_REGISTERS) ==
        VDMCONTEXT_DEBUG_REGISTERS)
    {
        ContextAmd64->Dr0 = ContextX86->Dr0;
        ContextAmd64->Dr1 = ContextX86->Dr1;
        ContextAmd64->Dr2 = ContextX86->Dr2;
        ContextAmd64->Dr3 = ContextX86->Dr3;
        ContextAmd64->Dr6 = ContextX86->Dr6;
        ContextAmd64->Dr7 = ContextX86->Dr7;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\arm_reg.h ===
//----------------------------------------------------------------------------
//
// ARM registers.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#ifndef __ARM_REG_H__
#define __ARM_REG_H__

#define ARM_FLAG_N (1 << 31)
#define ARM_FLAG_Z (1 << 30)
#define ARM_FLAG_C (1 << 29)
#define ARM_FLAG_V (1 << 28)
#define ARM_FLAG_Q (1 << 27)
#define ARM_FLAG_T (1 << 5)

enum
{
    ARM_INVALID,
    
    ARM_R0, ARM_R1, ARM_R2, ARM_R3, ARM_R4, ARM_R5, ARM_R6,
    ARM_R7, ARM_R8, ARM_R9, ARM_R10, ARM_R11, ARM_R12,
    ARM_SP, ARM_LR, ARM_PC, ARM_PSR,

    ARM_PSR_N, ARM_PSR_Z, ARM_PSR_C, ARM_PSR_V, ARM_PSR_Q,
    ARM_PSR_I, ARM_PSR_F, ARM_PSR_T, ARM_PSR_MODE,
};

#define ARM_INT_FIRST ARM_R0
#define ARM_INT_LAST ARM_PSR

#define ARM_FLAG_FIRST ARM_PSR_N
#define ARM_FLAG_LAST ARM_PSR_MODE

#endif // #ifndef __ARM_REG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\arm_dis.cpp ===
//----------------------------------------------------------------------------
//
// Disassembly portions of ARM machine implementation.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include "arminst.h"

PSTR g_ArmCond[] =
{
    "eq", "ne", "cs", "cc", "mi", "pl", "vs", "vc",
    "hi", "ls", "ge", "lt", "gt", "le", "al", "nv",
};

PSTR g_ArmShift[] =
{
    "lsl", "lsr", "asr", "ror", "rrx",
};

enum ARM_DECODE
{
    ARMDEC_INVALID,
    ARMDEC_ARTH_IMM,
    ARMDEC_ARTH_ISHF,
    ARMDEC_ARTH_RSHF,
    ARMDEC_BI,
    ARMDEC_BKPT,
    ARMDEC_BXI,
    ARMDEC_BXR,
    ARMDEC_CDP,
    ARMDEC_CLZ,
    ARMDEC_CMP_IMM,
    ARMDEC_CMP_ISHF,
    ARMDEC_CMP_RSHF,
    ARMDEC_LDC,
    ARMDEC_LDM,
    ARMDEC_LDR_IMM,
    ARMDEC_LDR_RSHF,
    ARMDEC_LDRH_IMM,
    ARMDEC_LDRH_REG,
    ARMDEC_MCR,
    ARMDEC_MCRR,
    ARMDEC_MOV_IMM,
    ARMDEC_MOV_ISHF,
    ARMDEC_MOV_RSHF,
    ARMDEC_MRC,
    ARMDEC_MRRC,
    ARMDEC_MRS,
    ARMDEC_MSR_IMM,
    ARMDEC_MSR_REG,
    ARMDEC_MUL,
    ARMDEC_QADD,
    ARMDEC_SMLA,
    ARMDEC_SMLAL,
    ARMDEC_SMUL,
    ARMDEC_SWI,
    ARMDEC_SWP,
    ARMDEC_UNDEF,
};

struct ArmDecode
{
    ULONG Mask;
    ULONG Encoded;
    ARM_DECODE Op;
    PSTR Name;
};

#define ARTH_OP(Op, Name) \
    0xffe00000, 0x02000000 | ((Op) << 21), ARMDEC_ARTH_IMM, Name, \
    0xffe00010, 0x00000000 | ((Op) << 21), ARMDEC_ARTH_ISHF, Name, \
    0xffe00090, 0x00000010 | ((Op) << 21), ARMDEC_ARTH_RSHF, Name

#define MOV_OP(Op, Name) \
    0xffef0000, 0x02000000 | ((Op) << 21), ARMDEC_MOV_IMM, Name, \
    0xffef0010, 0x00000000 | ((Op) << 21), ARMDEC_MOV_ISHF, Name, \
    0xffef0090, 0x00000010 | ((Op) << 21), ARMDEC_MOV_RSHF, Name

#define CMP_OP(Op, Name) \
    0xfff0f000, 0x02100000 | ((Op) << 21), ARMDEC_CMP_IMM, Name, \
    0xfff0f010, 0x00100000 | ((Op) << 21), ARMDEC_CMP_ISHF, Name, \
    0xfff0f090, 0x00100010 | ((Op) << 21), ARMDEC_CMP_RSHF, Name

#define LDC_OP(Op, Name) \
    0xfe100000, 0x0c000000 | ((Op) << 20), ARMDEC_LDC, Name, \
    0xfe100000, 0xfc000000 | ((Op) << 20), ARMDEC_LDC, Name ## "2"

#define LDM_OP(Op, Name) \
    0xfe500000, 0x08000000 | ((Op) << 20), ARMDEC_LDM, Name, \
    0xfe700000, 0x08400000 | ((Op) << 20), ARMDEC_LDM, Name

#define LDR_OP(Op, Name) \
    0xfe100000, 0x04000000 | ((Op) << 20), ARMDEC_LDR_IMM, Name, \
    0xfe100000, 0x06000000 | ((Op) << 20), ARMDEC_LDR_RSHF, Name

ArmDecode g_ArmDecode[] =
{
    // Undefined instruction space.
    0xf6000010, 0x06000010, ARMDEC_UNDEF,       "???",

    ARTH_OP(OP_ADC, "adc"),
    ARTH_OP(OP_ADD, "add"),
    ARTH_OP(OP_AND, "and"),
    0xff000000, 0x0a000000, ARMDEC_BI,          "b",
    0xff000000, 0x0b000000, ARMDEC_BI,          "bl",
    ARTH_OP(OP_BIC, "bic"),
    0xfff000f0, 0x01200070, ARMDEC_BKPT,        "bkpt",
    0xfe000000, 0xfa000000, ARMDEC_BXI,         "blx",
    0xfffffff0, 0x012fff30, ARMDEC_BXR,         "blx",
    0xfffffff0, 0x012fff10, ARMDEC_BXR,         "bx",
    0xff000010, 0x0e000000, ARMDEC_CDP,         "cdp",
    0xff000010, 0xfe000000, ARMDEC_CDP,         "cdp2",
    0xffff0ff0, 0x016f0f10, ARMDEC_CLZ,         "clz",
    CMP_OP(OP_CMN, "cmn"),
    CMP_OP(OP_CMP, "cmp"),
    ARTH_OP(OP_EOR, "eor"),
    LDC_OP(1, "ldc"),
    LDM_OP(1, "ldm"),
    LDR_OP(1, "ldr"),
    0xfe5000f0, 0x004000d0, ARMDEC_LDRH_IMM,    "ldr",
    0xfe500ff0, 0x000000d0, ARMDEC_LDRH_REG,    "ldr",
    0xfe5000f0, 0x005000b0, ARMDEC_LDRH_IMM,    "ldr",
    0xfe500ff0, 0x001000b0, ARMDEC_LDRH_REG,    "ldr",
    0xfe5000f0, 0x005000d0, ARMDEC_LDRH_IMM,    "ldr",
    0xfe500ff0, 0x001000d0, ARMDEC_LDRH_REG,    "ldr",
    0xfe5000f0, 0x005000f0, ARMDEC_LDRH_IMM,    "ldr",
    0xfe500ff0, 0x001000f0, ARMDEC_LDRH_REG,    "ldr",
    0xff100010, 0x0e000010, ARMDEC_MCR,         "mcr",
    0xff100010, 0xfe000010, ARMDEC_MCR,         "mcr2",
    0xfff00000, 0x0e400000, ARMDEC_MCRR,        "mcrr",
    0xffe000f0, 0x00200090, ARMDEC_MUL,         "mla",
    MOV_OP(OP_MOV, "mov"),
    0xff100010, 0x0e100010, ARMDEC_MRC,         "mrc",
    0xff100010, 0xfe100010, ARMDEC_MRC,         "mrc2",
    0xfff00000, 0x0e500000, ARMDEC_MRRC,        "mrrc",
    0xffbf0fff, 0x010f0000, ARMDEC_MRS,         "mrs",
    0xffb0f000, 0x0320f000, ARMDEC_MSR_IMM,     "msr",
    0xffb0f0f0, 0x0120f000, ARMDEC_MSR_REG,     "msr",
    0xffe0f0f0, 0x00000090, ARMDEC_MUL,         "mul",
    MOV_OP(OP_MVN, "mvn"),
    ARTH_OP(OP_ORR, "orr"),
    ARTH_OP(OP_RSB, "rsb"),
    ARTH_OP(OP_RSC, "rsc"),
    ARTH_OP(OP_SBC, "sbc"),
    0xfff00090, 0x01000080, ARMDEC_SMLA,        "smla",
    0xfff00090, 0x01400080, ARMDEC_SMLAL,       "smlal",
    0xffe000f0, 0x00e00090, ARMDEC_MUL,         "smlal",
    0xfff000b0, 0x01200080, ARMDEC_SMLA,        "smlaw",
    0xfff0f090, 0x01600080, ARMDEC_SMUL,        "smulb",
    0xffe000f0, 0x00c00090, ARMDEC_MUL,         "smull",
    0xfff0f0b0, 0x016000a0, ARMDEC_SMUL,        "smulw",
    0xff70f000, 0xf750f000, ARMDEC_LDR_IMM,     "pld",
    0xff70f000, 0xf550f000, ARMDEC_LDR_RSHF,    "pld",
    0xfff00ff0, 0x01000050, ARMDEC_QADD,        "qadd",
    0xfff00ff0, 0x01400050, ARMDEC_QADD,        "qdadd",
    0xfff00ff0, 0x01600050, ARMDEC_QADD,        "qdsub",
    0xfff00ff0, 0x01200050, ARMDEC_QADD,        "qsub",
    LDC_OP(0, "stc"),
    LDM_OP(0, "stm"),
    LDR_OP(0, "str"),
    0xfe5000f0, 0x004000f0, ARMDEC_LDRH_IMM,    "str",
    0xfe500ff0, 0x000000f0, ARMDEC_LDRH_REG,    "str",
    0xfe5000f0, 0x004000b0, ARMDEC_LDRH_IMM,    "str",
    0xfe500ff0, 0x000000b0, ARMDEC_LDRH_REG,    "str",
    ARTH_OP(OP_SUB, "sub"),
    0xff000000, 0x0f000000, ARMDEC_SWI,         "swi",
    0xffb00ff0, 0x01000090, ARMDEC_SWP,         "swp",
    CMP_OP(OP_TEQ, "teq"),
    CMP_OP(OP_TST, "tst"),
    0xffe000f0, 0x00a00090, ARMDEC_MUL,         "umlal",
    0xffe000f0, 0x00800090, ARMDEC_MUL,         "umull",

    // End marker.
    0x00000000, 0x00000000, ARMDEC_INVALID,     NULL,
};

BOOL
ArmMachineInfo::Disassemble(ProcessInfo* Process,
                            PADDR Addr, PSTR Buffer, BOOL EffAddr)
{
    ARMI Instr;

    m_DisStart = *Addr;
    
    ADDRFLAT(&m_EffAddr, 0);
    m_EaSize = 0;
    
    m_BufStart = m_Buf = Buffer;
    sprintAddr(&m_Buf, Addr);
    *m_Buf++ = ' ';

    if (m_Target->
        ReadAllVirtual(Process, Flat(*Addr), &Instr, sizeof(Instr)) != S_OK)
    {
        AddrAdd(Addr, 4);
        if (!(g_AsmOptions & DEBUG_ASMOPT_NO_CODE_BYTES))
        {
            BufferString("????????  ");
        }
        BufferString("???\n");
        *m_Buf = 0;
        return FALSE;
    }

    m_ArgCol = 19;
    
    if (!(g_AsmOptions & DEBUG_ASMOPT_NO_CODE_BYTES))
    {
        BufferHex(Instr.instruction, 8, FALSE);
        *m_Buf++ = ' ';
        *m_Buf++ = ' ';
        m_ArgCol += 10;
    }

    //
    // All of the condition bits are AND'ed before being
    // used to search the decode table.  This allows simple
    // matching and filtering for unconditional instructions.
    //

    ULONG InstrBits = Instr.instruction;
    if ((InstrBits & COND_MASK) != COND_NV)
    {
        InstrBits &= ~COND_MASK;
    }
    
    ArmDecode* Decode = g_ArmDecode;
    while (Decode->Mask)
    {
        if ((InstrBits & Decode->Mask) == Decode->Encoded)
        {
            break;
        }

        Decode++;
    }

    if (!Decode->Mask || Decode->Op == ARMDEC_UNDEF)
    {
        BufferString("???");
    }
    else
    {
        BufferString(Decode->Name);
        BufferCond(Instr.instruction & COND_MASK);
        
        switch(Decode->Op)
        {
        case ARMDEC_ARTH_IMM:
        case ARMDEC_ARTH_ISHF:
        case ARMDEC_ARTH_RSHF:
            DisArmArth(Decode, &Instr);
            break;
        case ARMDEC_BI:
            DisArmBi(Decode, &Instr);
            break;
        case ARMDEC_BKPT:
            DisArmBkpt(Decode, &Instr);
            break;
        case ARMDEC_BXI:
            DisArmBxi(Decode, &Instr);
            break;
        case ARMDEC_BXR:
            DisArmBxr(Decode, &Instr);
            break;
        case ARMDEC_CDP:
            DisArmCdp(Decode, &Instr);
            break;
        case ARMDEC_CLZ:
            DisArmClz(Decode, &Instr);
            break;
        case ARMDEC_CMP_IMM:
        case ARMDEC_CMP_ISHF:
        case ARMDEC_CMP_RSHF:
            DisArmCmp(Decode, &Instr);
            break;
        case ARMDEC_LDC:
            DisArmLdc(Decode, &Instr);
            break;
        case ARMDEC_LDM:
            DisArmLdm(Decode, &Instr);
            break;
        case ARMDEC_LDR_IMM:
        case ARMDEC_LDR_RSHF:
            DisArmLdr(Decode, &Instr);
            break;
        case ARMDEC_LDRH_IMM:
        case ARMDEC_LDRH_REG:
            DisArmLdrh(Decode, &Instr);
            break;
        case ARMDEC_MCR:
        case ARMDEC_MRC:
            DisArmMcr(Decode, &Instr);
            break;
        case ARMDEC_MCRR:
        case ARMDEC_MRRC:
            DisArmMcrr(Decode, &Instr);
            break;
        case ARMDEC_MOV_IMM:
        case ARMDEC_MOV_ISHF:
        case ARMDEC_MOV_RSHF:
            DisArmMov(Decode, &Instr);
            break;
        case ARMDEC_MRS:
            DisArmMrs(Decode, &Instr);
            break;
        case ARMDEC_MSR_IMM:
        case ARMDEC_MSR_REG:
            DisArmMsr(Decode, &Instr);
            break;
        case ARMDEC_MUL:
            DisArmMul(Decode, &Instr);
            break;
        case ARMDEC_QADD:
            DisArmQadd(Decode, &Instr);
            break;
        case ARMDEC_SMLA:
            DisArmSmla(Decode, &Instr);
            break;
        case ARMDEC_SMLAL:
            DisArmSmlal(Decode, &Instr);
            break;
        case ARMDEC_SMUL:
            DisArmSmul(Decode, &Instr);
            break;
        case ARMDEC_SWI:
            DisArmSwi(Decode, &Instr);
            break;
        case ARMDEC_SWP:
            DisArmSwp(Decode, &Instr);
            break;
        default:
            BufferString("** ARM diassembly bug **");
            break;
        }
    }
    
    *m_Buf++ = '\n';
    *m_Buf = 0;
    AddrAdd(Addr, 4);
    return TRUE;
}

void
ArmMachineInfo::DisArmArth(ArmDecode* Decode, PARMI Instr)
{
    if (Instr->dataproc.s)
    {
        *m_Buf++ = 's';
    }
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->dataproc.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->dataproc.rn);
    BufferArmDpArg(Instr);
}

void
ArmMachineInfo::DisArmBi(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    BufferEffectiveAddress(Flat(m_DisStart) + 8 +
                           ((LONG)Instr->bl.offset << 2), 4);
}

void
ArmMachineInfo::DisArmBkpt(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    *m_Buf++ = '#';
    *m_Buf++ = '0';
    *m_Buf++ = 'x';
    BufferHex((Instr->bkpt.immed2 << 4) || Instr->bkpt.immed1,
              4, FALSE);
}

void
ArmMachineInfo::DisArmBxi(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    BufferEffectiveAddress(Flat(m_DisStart) + 8 +
                           ((LONG)Instr->blxi.offset << 2) +
                           (Instr->blxi.h << 1), 4);
}

void
ArmMachineInfo::DisArmBxr(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->bx.rn);
}

void
ArmMachineInfo::DisArmCdp(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    *m_Buf++ = 'p';
    BufferInt(Instr->cpdo.cpn, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferInt(Instr->cpdo.cpop, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = 'c';
    BufferInt(Instr->cpdo.crd, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = 'c';
    BufferInt(Instr->cpdo.crn, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = 'c';
    BufferInt(Instr->cpdo.crm, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferInt(Instr->cpdo.cp, 0, FALSE);
}

void
ArmMachineInfo::DisArmClz(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->clz.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->clz.rm);
}

void
ArmMachineInfo::DisArmCmp(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->dataproc.rn);
    BufferArmDpArg(Instr);
}

void
ArmMachineInfo::DisArmLdc(ArmDecode* Decode, PARMI Instr)
{
    if (Instr->cpdt.n)
    {
        *m_Buf++ = 'l';
    }
    BufferBlanks(m_ArgCol);
    *m_Buf++ = 'p';
    BufferInt(Instr->cpdt.cpn, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = 'c';
    BufferInt(Instr->cpdt.crd, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = '[';
    BufferRegName(Instr->cpdt.rn);
    if (!Instr->cpdt.p)
    {
        *m_Buf++ = ']';
    }
    if (Instr->cpdt.offset)
    {
        *m_Buf++ = ',';
        *m_Buf++ = ' ';
        *m_Buf++ = '#';
        *m_Buf++ = '0';
        *m_Buf++ = 'x';
        BufferHex(Instr->cpdt.offset, 2, FALSE);
    }
    if (Instr->cpdt.p)
    {
        *m_Buf++ = ']';
    }
    if (Instr->cpdt.w)
    {
        *m_Buf++ = '!';
    }
}

void
ArmMachineInfo::DisArmLdm(ArmDecode* Decode, PARMI Instr)
{
    ULONG i;
    BOOL Separate = FALSE;
    
    if (Instr->ldm.rn == ARM_SP)
    {
        *m_Buf++ = Instr->ldm.p ? 'e' : 'f';
        *m_Buf++ = Instr->ldm.u ? 'd' : 'a';
    }
    else
    {
        *m_Buf++ = Instr->ldm.u ? 'i' : 'd';
        *m_Buf++ = Instr->ldm.p ? 'b' : 'a';
    }
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->ldm.rn);
    if (Instr->ldm.w)
    {
        *m_Buf++ = '!';
    }
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = '{';
    for (i = 0; i < 16; i++)
    {
        if (Instr->ldm.reglist & (1 << i))
        {
            ULONG Len = 0;

            if (Separate)
            {
                *m_Buf++ = ',';
                *m_Buf++ = ' ';
            }
            else
            {
                Separate = TRUE;
            }
            
            BufferRegName(i);
            
            do
            {
                Len++;
                i++;
            } while (i < 16 && (Instr->ldm.reglist & (1 << i)));

            if (Len > 1)
            {
                if (Len > 2)
                {
                    *m_Buf++ = ' ';
                    *m_Buf++ = '-';
                }
                else
                {
                    *m_Buf++ = ',';
                }
                *m_Buf++ = ' ';
                BufferRegName(i - 1);
            }
        }
    }
    *m_Buf++ = '}';
    if (Instr->ldm.s)
    {
        *m_Buf++ = '^';
    }
}

void
ArmMachineInfo::DisArmLdr(ArmDecode* Decode, PARMI Instr)
{
    if (Instr->ldr.b)
    {
        *m_Buf++ = 'b';
    }
    if (!Instr->ldr.p && Instr->ldr.w)
    {
        *m_Buf++ = 't';
    }
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->ldr.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = '[';
    BufferRegName(Instr->ldr.rn);
    if (Instr->ldr.p)
    {
        if (Instr->ldr.offset)
        {
            *m_Buf++ = ',';
            *m_Buf++ = ' ';
            if (!Instr->ldr.i)
            {
                *m_Buf++ = '#';
                if (!Instr->ldr.u)
                {
                    *m_Buf++ = '-';
                }
                *m_Buf++ = '0';
                *m_Buf++ = 'x';
                BufferHex(Instr->ldr.offset, 3, FALSE);
            }
            else
            {
                *m_Buf++ = Instr->ldr.u ? '+' : '-';
                BufferArmShift(Instr->ldr.offset);
            }
        }
        *m_Buf++ = ']';
    }
    else
    {
        *m_Buf++ = ']';
        *m_Buf++ = ',';
        *m_Buf++ = ' ';
        if (!Instr->ldr.i)
        {
            *m_Buf++ = '#';
            if (!Instr->ldr.u)
            {
                *m_Buf++ = '-';
            }
            *m_Buf++ = '0';
            *m_Buf++ = 'x';
            BufferHex(Instr->ldr.offset, 3, FALSE);
        }
        else
        {
            *m_Buf++ = Instr->ldr.u ? '+' : '-';
            BufferArmShift(Instr->ldr.offset);
        }
    }
    if (Instr->ldr.w)
    {
        *m_Buf++ = '!';
    }
}

void
ArmMachineInfo::DisArmLdrh(ArmDecode* Decode, PARMI Instr)
{
    if (!Instr->miscdt.l && Instr->miscdt.s)
    {
        *m_Buf++ = 'd';
    }
    else
    {
        if (Instr->miscdt.s)
        {
            *m_Buf++ = 's';
        }
        *m_Buf++ = Instr->miscdt.h ? 'h' : 'b';
    }
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->miscdt.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = '[';
    BufferRegName(Instr->miscdt.rn);
    if (!Instr->miscdt.p)
    {
        *m_Buf++ = ']';
    }
    if (Instr->miscdt.i)
    {
        ULONG Offset =
            (Instr->miscdt.operand2 << 4) | Instr->miscdt.operand1;
        if (Offset)
        {
            *m_Buf++ = ',';
            *m_Buf++ = ' ';
            *m_Buf++ = '#';
            if (!Instr->miscdt.u)
            {
                *m_Buf++ = '-';
            }
            *m_Buf++ = '0';
            *m_Buf++ = 'x';
            BufferHex(Offset, 2, FALSE);
        }
    }
    else
    {
        *m_Buf++ = ',';
        *m_Buf++ = ' ';
        *m_Buf++ = Instr->miscdt.u ? '+' : '-';
        BufferRegName(Instr->miscdt.operand1);
    }
    if (Instr->miscdt.p)
    {
        *m_Buf++ = ']';
        if (Instr->miscdt.w)
        {
            *m_Buf++ = '!';
        }
    }
}

void
ArmMachineInfo::DisArmMcr(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    *m_Buf++ = 'p';
    BufferInt(Instr->cprt.cpn, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferInt(Instr->cprt.cpop, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->cprt.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = 'c';
    BufferInt(Instr->cprt.crn, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = 'c';
    BufferInt(Instr->cprt.crm, 0, FALSE);
    if (Instr->cprt.cp)
    {
        *m_Buf++ = ',';
        *m_Buf++ = ' ';
        BufferInt(Instr->cprt.cp, 0, FALSE);
    }
}

void
ArmMachineInfo::DisArmMcrr(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    *m_Buf++ = 'p';
    BufferInt(Instr->mcrr.cpn, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferInt(Instr->mcrr.cpop, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->mcrr.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferInt(Instr->mcrr.rn, 0, FALSE);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = 'c';
    BufferInt(Instr->mcrr.crm, 0, FALSE);
}

void
ArmMachineInfo::DisArmMov(ArmDecode* Decode, PARMI Instr)
{
    if (Instr->dataproc.s)
    {
        *m_Buf++ = 's';
    }
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->dataproc.rd);
    BufferArmDpArg(Instr);
}

void
ArmMachineInfo::DisArmMrs(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->dpmrs.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferString("psr");
}

void
ArmMachineInfo::DisArmMsr(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    BufferString("psr_");
    if (Instr->dpmsr.fc)
    {
        *m_Buf++ = 'c';
    }
    if (Instr->dpmsr.fx)
    {
        *m_Buf++ = 'x';
    }
    if (Instr->dpmsr.fs)
    {
        *m_Buf++ = 's';
    }
    if (Instr->dpmsr.ff)
    {
        *m_Buf++ = 'f';
    }
    if (Instr->dpmsr.i)
    {
        BufferArmDpArg(Instr);
    }
    else
    {
        *m_Buf++ = ',';
        *m_Buf++ = ' ';
        BufferRegName(Instr->dpmsr.operand & 0xf);
    }
}

void
ArmMachineInfo::DisArmMul(ArmDecode* Decode, PARMI Instr)
{
    if (Instr->mul.s)
    {
        *m_Buf++ = 's';
    }
    BufferBlanks(m_ArgCol);
    if (Instr->mul.lng)
    {
        BufferRegName(Instr->mul.rn);
        *m_Buf++ = ',';
        *m_Buf++ = ' ';
    }
    BufferRegName(Instr->mul.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->mul.rm);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->mul.rs);
    if (Instr->mul.a && !Instr->mul.lng)
    {
        *m_Buf++ = ',';
        *m_Buf++ = ' ';
        BufferRegName(Instr->mul.rn);
    }
}

void
ArmMachineInfo::DisArmQadd(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->qadd.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->qadd.rm);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->qadd.rn);
}

void
ArmMachineInfo::DisArmSmla(ArmDecode* Decode, PARMI Instr)
{
    if (strcmp(Decode->Name, "smlaw"))
    {
        *m_Buf++ = Instr->smla.x ? 't' : 'b';
    }
    *m_Buf++ = Instr->smla.y ? 't' : 'b';
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->smla.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->smla.rm);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->smla.rs);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->smla.rn);
}

void
ArmMachineInfo::DisArmSmlal(ArmDecode* Decode, PARMI Instr)
{
    *m_Buf++ = Instr->smla.x ? 't' : 'b';
    *m_Buf++ = Instr->smla.y ? 't' : 'b';
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->smlal.rdlo);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->smlal.rdhi);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->smlal.rm);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->smlal.rs);
}

void
ArmMachineInfo::DisArmSmul(ArmDecode* Decode, PARMI Instr)
{
    if (strcmp(Decode->Name, "smulw"))
    {
        *m_Buf++ = Instr->smul.x ? 't' : 'b';
    }
    *m_Buf++ = Instr->smul.y ? 't' : 'b';
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->smul.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->smul.rm);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->smlal.rs);
}

void
ArmMachineInfo::DisArmSwi(ArmDecode* Decode, PARMI Instr)
{
    BufferBlanks(m_ArgCol);
    *m_Buf++ = '#';
    *m_Buf++ = '0';
    *m_Buf++ = 'x';
    BufferHex(Instr->swi.comment, 6, FALSE);
}

void
ArmMachineInfo::DisArmSwp(ArmDecode* Decode, PARMI Instr)
{
    if (Instr->swp.b)
    {
        *m_Buf++ = 'b';
    }
    BufferBlanks(m_ArgCol);
    BufferRegName(Instr->swp.rd);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferRegName(Instr->swp.rm);
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    *m_Buf++ = '[';
    BufferRegName(Instr->swp.rn);
    *m_Buf++ = ']';
}

void
ArmMachineInfo::BufferEffectiveAddress(ULONG64 Offset, ULONG Size)
{
    CHAR Symbol[MAX_SYMBOL_LEN];
    ULONG64 Disp;

    GetSymbol(Offset, Symbol, sizeof(Symbol), &Disp);
    if (Symbol[0])
    {
        BufferString(Symbol);
        if (Disp)
        {
            *m_Buf++ = '+';
            *m_Buf++ = '0';
            *m_Buf++ = 'x';
            BufferHex(Disp, 8, TRUE);
        }
        *m_Buf++ = ' ';
        *m_Buf++ = '(';
        BufferHex(Offset, 8, FALSE);
        *m_Buf++ = ')';
    }
    else
    {
        BufferHex(Offset, 8, FALSE);
    }

    // Save EA.
    ADDRFLAT(&m_EffAddr, Offset);
    m_EaSize = Size;
}

void
ArmMachineInfo::BufferArmDpArg(PARMI Instr)
{
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    if (Instr->dataproc.bits & 1)
    {
        ULONG64 Immed;
        
        *m_Buf++ = '#';
        *m_Buf++ = '0';
        *m_Buf++ = 'x';
        // The immediate forms takes the low 8 bits as an unsigned
        // value and rotates it right by twice the upper 4 bits to
        // form a 32-bit immediate.
        // Emulate the rotate by shifting a 64-bit value and piecing
        // together the appropriate parts.
        Immed = (((ULONG64)(Instr->dataproc.operand2 & 0xff)) << 32) >>
            ((Instr->dataproc.operand2 >> 7) & 0x1e);
        BufferHex((ULONG)((Immed & 0xffffffff) | (Immed >> 32)), 8, FALSE);
    }
    else
    {
        BufferArmShift(Instr->dataproc.operand2);
    }
}

void
ArmMachineInfo::BufferArmShift(ULONG Shift)
{
    ULONG Op = (Shift >> 5) & 3;
    ULONG Amount = (Shift >> 7) & 0x1f;
    
    if (Op == 3 && !(Shift & 0x10) && Amount == 0)
    {
        // ror #0 is replaced by rrx.
        Op = 4;
    }
    
    BufferRegName(Shift & 0xf);

    if (Op == 0 && Amount == 0)
    {
        // No shift.
        return;
    }
    
    *m_Buf++ = ',';
    *m_Buf++ = ' ';
    BufferString(g_ArmShift[Op]);
    *m_Buf++ = ' ';
    if (Shift & 0x10)
    {
        DBG_ASSERT(!(Shift & 0x80));
        BufferRegName((Shift >> 8) & 0xf);
    }
    else
    {
        if ((Op == 1 || Op == 2) && Amount == 0)
        {
            // lsr #0 and asr #0 are actually [la]sr #32.
            Amount = 32;
        }
            
        *m_Buf++ = '#';
        BufferInt(Amount, 0, FALSE);
    }
}

void
ArmMachineInfo::BufferRegName(ULONG Reg)
{
    PCSTR Name = RegNameFromIndex(Reg + ARM_INT_FIRST);
    if (Name)
    {
        BufferString(Name);
    }
    else
    {
        BufferString("ArmMachineInfo::BufferRegName invalid arg");
    }
}

void
ArmMachineInfo::BufferCond(ULONG Cond)
{
    if (Cond != COND_AL && Cond != COND_NV)
    {
        BufferString(g_ArmCond[Cond >> COND_SHIFT]);
    }
}

BOOL
ArmMachineInfo::IsBreakpointInstruction(ProcessInfo* Process, PADDR Addr)
{
    // XXX drewb - Presumably some form of BKPT, but what?
    return FALSE;
}

HRESULT
ArmMachineInfo::InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                            ULONG64 Process,
                                            ULONG64 Offset,
                                            ULONG Flags,
                                            PUCHAR SaveInstr,
                                            PULONG64 ChangeStart,
                                            PULONG ChangeLen)
{
    if (Flags != IBI_DEFAULT)
    {
        return E_INVALIDARG;
    }

    return E_NOTIMPL;
}

HRESULT
ArmMachineInfo::RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                            ULONG64 Process,
                                            ULONG64 Offset,
                                            PUCHAR SaveInstr,
                                            PULONG64 ChangeStart,
                                            PULONG ChangeLen)
{
    return E_NOTIMPL;
}

void
ArmMachineInfo::AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                  ULONG BreakType)
{
    DBG_ASSERT(BreakType == DEBUG_BREAKPOINT_CODE);
    
    AddrAdd(Addr, 4);
    SetPC(Addr);
}

BOOL
ArmMachineInfo::IsCallDisasm(PCSTR Disasm)
{
    // XXX.
    return FALSE;
}

BOOL
ArmMachineInfo::IsReturnDisasm(PCSTR Disasm)
{
    // XXX.
    return FALSE;
}

BOOL
ArmMachineInfo::IsSystemCallDisasm(PCSTR Disasm)
{
    // XXX.
    return FALSE;
}
    
BOOL
ArmMachineInfo::IsDelayInstruction(PADDR Addr)
{
    // ARM does not have delay slots.
    return FALSE;
}

void
ArmMachineInfo::GetEffectiveAddr(PADDR Addr, PULONG Size)
{
    *Addr = m_EffAddr;
    *Size = m_EaSize;
}

BOOL
ArmCheckConditionCodes(
    PARM_CONTEXT Context,
    DWORD instr
    )
/*++

Routine Description:

    Checks the condition codes of the instruction and the values of the
    condition flags in the current program status register, and determines
    whether or not the instruction will be executed.

Return Value:

    TRUE if the instruction will be executed, FALSE otherwise.

--*/
{
    BOOL Execute = FALSE;
    BOOL Nset = (Context->Psr & 0x80000000L) == 0x80000000L;
    BOOL Zset = (Context->Psr & 0x40000000L) == 0x40000000L;
    BOOL Cset = (Context->Psr & 0x20000000L) == 0x20000000L;
    BOOL Vset = (Context->Psr & 0x10000000L) == 0x10000000L;

    instr &= COND_MASK;

    switch( instr )
    {
    case COND_EQ:   // Z set
        if ( Zset ) Execute = TRUE;
        break;

    case COND_NE:   // Z clear
        if ( !Zset ) Execute = TRUE;
        break;

    case COND_CS:   // C set
        if ( Cset ) Execute = TRUE;
        break;

    case COND_CC:   // C clear
        if ( !Cset ) Execute = TRUE;
        break;

    case COND_MI:   // N set
        if ( Nset ) Execute = TRUE;
        break;

    case COND_PL:   // N clear
        if ( !Nset ) Execute = TRUE;
        break;

    case COND_VS:   // V set
        if ( Vset ) Execute = TRUE;
        break;

    case COND_VC:   // V clear
        if ( !Vset ) Execute = TRUE;
        break;

    case COND_HI:   // C set and Z clear
        if ( Cset && !Zset ) Execute = TRUE;
        break;

    case COND_LS:   // C clear or Z set
        if ( !Cset || Zset ) Execute = TRUE;
        break;

    case COND_GE:   // N == V
        if (( Nset && Vset ) || ( !Nset && !Vset )) Execute = TRUE;
        break;

    case COND_LT:   // N != V
        if (( Nset && !Vset ) || ( !Nset && Vset )) Execute = TRUE;
        break;

    case COND_GT:   // Z clear, and N == V
        if ( !Zset &&
             (( Nset && Vset ) || ( !Nset && !Vset ))) Execute = TRUE;
        break;

    case COND_LE:   // Z set, and N != V
        if ( Zset &&
             (( Nset && !Vset ) || ( !Nset && Vset ))) Execute = TRUE;
        break;

    case COND_AL:   // Always execute
    case COND_NV:
        Execute = TRUE;
        break;

    default:
        DBG_ASSERT(FALSE);
        break;
    }

    return Execute;
}

void
ArmMachineInfo::GetNextOffset(ProcessInfo* Process,
                              BOOL StepOver,
                              PADDR NextAddr, PULONG NextMachine)
{
    ARMI    instr;
    PULONG  Register = &m_Context.ArmContext.R0;
    ULONG   returnvalue;
    BOOL    QualifyReturnAddress = FALSE;   // ADDED for ARM WINCE, fixes up LR
    BOOL    Ldm_instr = FALSE;

    *NextMachine = m_ExecTypes[0];

    GetPC(NextAddr);

    if (m_Target->ReadAllVirtual(Process, Flat(*NextAddr), &instr.instruction,
                                 sizeof(instr.instruction)) != S_OK)
    {
        // Couldn't read the instruction so just return the
        // next offset.
        AddrAdd(NextAddr, 4);
        return;
    }
    
    //
    // We are only testing for data processing, load multiple, bx and bl
    // instructions.  We might have to check regular loads and stores that
    // have the PC as the destination.
    //

    if (!ArmCheckConditionCodes(&m_Context.ArmContext, instr.instruction))
    {
        //
        // Instruction will not be executed.  Bump PC normally.
        //

        AddrAdd(NextAddr, 4);
        return;
    }

    if (( instr.instruction & BX_MASK ) == BX_INSTR )
    {
        ULONG Rn;

        //
        // Check Rn (lower 4 bits). To compute the target address:
        //      Mask out the T bit. We don't care if we're transferring to Thumb
        //      Shift bits 31-1 left 1 bit.
        //

        Rn = Register[ instr.bx.rn ];
        Rn &= 0xfffffffe;
        returnvalue = Rn << 1;
    }
    else if (( instr.instruction & DATA_PROC_MASK ) == DP_PC_INSTR )
    {
        ULONG Op1, Op2;
        ULONG Cflag = (m_Context.ArmContext.Psr & 0x20000000L) == 0x20000000L;
        ULONG shift;

        //
        // We are not making sure that data processing instructions are not the
        // multiply instructions, because we are checking to make sure that the
        // PC is the destination register. The PC is not a legal destination
        // register on multiply instructions.
        //
        // Currently only the MOV instruction (returns, branches) and the ADDLS
        // instruction (switch statement) are used.  Both of these instructions
        // use the addressing mode "Register, Logical shift left by immediate."
        // I'm leaving the other cases in case they are used in the future.
        //

        //
        // Figure out the addressing mode (there are 11 of them), and get the
        // operands.
        //

        Op1 = Register[ instr.dataproc.rn ];

        if ( instr.dataproc.rn == 15 )
        {
            //
            // If this is the PC, add 8.
            //

            Op1 += 8;
        }

        if ( instr.dataproc.bits == 0x1 )
        {
            //
            // Immediate addressing - Type 1
            //

            Op2 = _lrotr( instr.dpi.immediate, instr.dpi.rotate * 2 );
        }
        else
        {
            //
            // Register addressing - start by getting the value of Rm.
            //

            Op2 = Register[ instr.dpshi.rm ];

            if ( instr.dpshi.rm == 15 )
            {
                //
                // If this is the PC, add 8.
                //

                Op2 += 8;
            }

            if ( instr.dprre.bits == 0x6 )
            {
                //
                // Rotate right with extended - Type 11
                //

                Op2 = ( Cflag << 31 ) | ( Op2 >> 1 );
            }
            else if ( instr.dataproc.operand2 & 0x10 )
            {
                //
                // Register shifts. Types 4, 6, 8, and 10
                //

                //
                // Get the shift value from the least-significant byte of the
                // shift register.
                //

                shift = Register[ instr.dpshr.rs ];

                shift &= 0xff;

                switch( instr.dpshr.bits )
                {
                case 0x1: //  4 Logical shift left by register
                    if ( shift >= 32 )
                    {
                        Op2 = 0;
                    }
                    else
                    {
                        Op2 = Op2 << shift;
                    }
                    break;

                case 0x3: //  6 Logical shift right by register
                    if ( shift >= 32 )
                    {
                        Op2 = 0;
                    }
                    else
                    {
                        Op2 = Op2 >> shift;
                    }
                    break;

                case 0x5: //  8 Arithmetic shift right by register
                    if ( shift >= 32 )
                    {
                        if ( Op2 & 0x80000000 )
                        {
                            Op2 = 0xffffffff;
                        }
                        else
                        {
                            Op2 = 0;
                        }
                    }
                    else
                    {
                        Op2 = (LONG)Op2 >> shift;
                    }
                    break;

                case 0x7: // 10 Rotate right by register
                    if ( !( shift == 0 ) && !(( shift & 0xf ) == 0 ) )
                    {
                        Op2 = _lrotl( Op2, shift );
                    }
                    break;

                default:
                    break;
                }
            }
            else
            {
                //
                // Immediate shifts. Types 2, 3, 5, 7, and 9
                //

                //
                // Get the shift value from the instruction.
                //

                shift = instr.dpshi.shift;

                switch( instr.dpshi.bits )
                {
                case 0x0: // 2,3 Register, Logical shift left by immediate
                    if ( shift != 0 )
                    {
                        Op2 = Op2 << shift;
                    }
                    break;

                case 0x2: // 5 Logical shift right by immediate
                    if ( shift == 0 )
                    {
                        Op2 = 0;
                    }
                    else
                    {
                        Op2 = Op2 >> shift;
                    }
                    break;

                case 0x4: // 7 Arithmetic shift right by immediate
                    if ( shift == 0 )
                    {
                        Op2 = 0;
                    }
                    else
                    {
                        Op2 = (LONG)Op2 >> shift;
                    }
                    break;

                case 0x6: // 9 Rotate right by immediate
                    Op2 = _lrotl( Op2, shift );
                    break;

                default:
                    break;
                }
            }
        }

        //
        // Determine the result (the new PC), based on the opcode.
        //

        switch( instr.dataproc.opcode )
        {
        case OP_AND:
            returnvalue = Op1 & Op2;
            break;

        case OP_EOR:
            returnvalue = Op1 ^ Op2;
            break;

        case OP_SUB:
            returnvalue = Op1 - Op2;
            break;

        case OP_RSB:
            returnvalue = Op2 - Op1;
            break;

        case OP_ADD:
            returnvalue = Op1 + Op2;
            break;

        case OP_ADC:
            returnvalue = (Op1 + Op2) + Cflag;
            break;

        case OP_SBC:
            returnvalue = (Op1 - Op2) - ~Cflag;
            break;

        case OP_RSC:
            returnvalue = (Op2 - Op1) - ~Cflag;
            break;

        case OP_ORR:
            returnvalue = Op1 | Op2;
            break;

        case OP_MOV:
            if (( instr.dataproc.operand2 != 0xe ) && StepOver )
            {
                //
                // A move from any register but LR to the PC is a call.
                // We are stepping over, so bump the PC normally.
                //

                returnvalue = (ULONG)Flat(*NextAddr) + sizeof(ARMI);
            }
            else
            {
                //ie: mov       pc, lr
                returnvalue = Op2;
                //[Moonshot 6841]: fix up the LR reg.
                QualifyReturnAddress = TRUE;
            }
            break;

        case OP_BIC:
            returnvalue = Op1 & ~Op2;
            break;

        case OP_MVN:
            returnvalue = ~Op2;
            break;

        case OP_TST:
        case OP_TEQ:
        case OP_CMP:
        case OP_CMN:
        default:
            //
            // This really isn't a branch.  Bump the PC normally.
            //

            returnvalue = (ULONG)Flat(*NextAddr) + sizeof(ARMI);
            break;
        }
    }
    else if (( instr.instruction & LDM_PC_MASK ) == LDM_PC_INSTR )
    {
        // ie: ldmia     sp!, {pc}
        // Load multiple with the PC bit set.  We don't need to check the
        // step over flag in this case, because a load multiple is never a
        // call, only a return.
        //

        ULONG RegList, i, count = 0, Rn;

        //
        // Get the address from Rn.
        //

        Rn = Register[ instr.ldm.rn ];

        if ( instr.ldm.u )
        {
            //
            // Increment the address. Check to see how many other registers
            // are to be read.
            //

            RegList = instr.ldm.reglist;

            for ( i = 0; i < 15; i++ )
            {
                if ( RegList & 0x1 ) count++;
                RegList = RegList >> 1;
            }

            //
            // Check the p bit to see how big to make the offset to the PC.
            //

            if ( instr.ldm.p )
            {
                // Before
                count = (count + 1) * sizeof(ARMI);
            }
            else
            {
                // After
                count = count * sizeof(ARMI);
            }

            Rn += count;
        }
        else
        {
            //
            // Decrement the address.  If we decrement before, we need to
            // subract the instruction size now.  Otherwise, do nothing.
            //

            if ( instr.ldm.p )
            {
                // Before
                Rn -= sizeof(ARMI);
            }
        }

        // reading values from the stack
        if (m_Target->ReadAllVirtual(Process, EXTEND64(Rn), &returnvalue,
                                     sizeof(returnvalue)) != S_OK)
        {
            // Unable to read, so what should be returned?
            returnvalue = (ULONG)Flat(*NextAddr) + sizeof(ARMI);
        }
        
        //[Moonshot 6838]: fix up the LR reg.
        QualifyReturnAddress = TRUE;
        Ldm_instr = TRUE;
    }
    else if ((( instr.instruction & B_BL_MASK ) == B_INSTR ) ||
             (( instr.instruction & B_BL_MASK ) == BL_INSTR ))
    {
        //
        // If this is a call (branch and link), and we are stepping over, the
        // next offset is the addr + 8.
        //

        if ( instr.bl.link && StepOver )
        {
            returnvalue = (ULONG)Flat(*NextAddr) + sizeof(ARMI);
        }
        else
        {
            LONG BranchOffset;

            //
            // To calculate the branch target:
            //      Shift the 24-bit offset left 2 bits
            //      Sign-extend it to 32 bits
            //      Add it to the contents of the PC
            //      (Which would be the current address + 8);
            //

            BranchOffset = instr.bl.offset;
            BranchOffset <<= 2;
            if( BranchOffset & 0x2000000 )
            {
                BranchOffset |= 0xfc000000;
            }
            returnvalue = (ULONG)Flat(*NextAddr) + BranchOffset;
            returnvalue += 8;
        }
    }
    else if ( instr.instruction == LDR_THUNK_2 )
    {
        //
        // Need to handle import DLL thunk type branches to destination func Foo
        //
        // 0001ACA0: ldr    r12, [pc]   ;  pc+8+0 = 0x0001ACA8
        // 0001ACA4: ldr    pc, [r12]
        // 0001ACA8: DCD    0x0001C020  ; This memory location holds the address, of the address, of Foo
        // 
        // 0001C020: DCD    Foo         ; This memory location holds the address of Foo
        //

        //
        // Get the address of Foo from Rn.
        // simple register indirect. no offsets, no scaling, no indexing addressing mode
        //
        if (m_Target->ReadAllVirtual(Process, EXTEND64(Register[instr.ldr.rn]),
                                     &returnvalue,
                                     sizeof(returnvalue)) != S_OK)
        {
            // Unable to read, so what should be returned?
            returnvalue = (ULONG)Flat(*NextAddr) + sizeof(ARMI);
        }
    }
    else
    {
        // Bump PC normally
        returnvalue = (ULONG)Flat(*NextAddr) + sizeof(ARMI);
    }

#if 0
    //jvp 
    //[Moonshot 6838, 6841]:  fix up the LR register.
    // Taken from the same function in ppcmach.c
    // The value we get from the LR register is not necessarily fully
    // qualified.  In WINCE, when a process is running it is mapped into the 
    // ZERO slot, meaning that the upper 6 bits contain 0.  To fully
    // qualify an address, the upper 6 bits contain the current process.  The
    // LR regs is set at runtime so we need to fix it up so breakpoint
    // comparisons make sense.
    if (QualifyReturnAddress == TRUE)
    {
        ULONG Status, NextOffset;
        ARMI I1;
        ADDR addr;

        NextOffset = returnvalue;

        ZeroMemory(&addr, sizeof(ADDR));
        GetAddrOff(addr) = NextOffset;
        TranslateAddress(hthd->hprc, 0, &addr, TRUE);
        NextOffset = GetAddrOff(addr);
        Status = STATUS_SUCCESS;

        //
        // Because the next offset translation is meant for NK, the
        // stub and simulator will return STATUS_UNSUCCESSFUL.
        //
        // On a successful transaction our new address will be fully qualified
        // otherwise, just leave.
        if (Status == STATUS_SUCCESS)
        {
            if (!Ldm_instr)
            {
                // DP_PC_INSTR; Moonshot 6841
                returnvalue = NextOffset;       // fully qualified.
            }

            //since this is a ldm instruction, it's reading values from the stack;
            //so do error checking to make sure that these values must be a valid 
            //instruction.  At this moment, we know that NextOffset contains the address
            //of the instruction after the branch instruction (also contains the value
            //of LR).  So make sure that the previous instruction (from the NextOffset) 
            //must be a branch instruction.
            else if (NextOffset && (!(NextOffset % 4)))
            {
                AddrInit( &memaddr, 0, 0, NextOffset-4, TRUE, TRUE, FALSE, FALSE );
                AddrReadMemory( hthd->hprc,     //read previous instruction.
                                hthd,
                                &memaddr,
                                &I1.instruction,
                                sizeof(ARMI),
                                &cBytes );

                //previous instruction must be a branch instruction.
                if ( ((I1.instruction & BX_MASK ) == BX_INSTR ) ||
                     ((I1.instruction & B_BL_MASK ) == B_INSTR) ||
                     ((I1.instruction & B_BL_MASK ) == BL_INSTR) )
                {
                    returnvalue = NextOffset;       //fully qualified.
                }
            }
        }
    }

    {
        // make sure a fully fixed up offset is returned
        ADDR    addr;
        DWORD   dwTemp;
        DWORD   dwPC;
        BOOL    bReturn;
        
        ZeroMemory(&addr, sizeof(ADDR));
        GetAddrOff(addr) = returnvalue;
        TranslateAddress(hthd->hprc, 0, &addr, TRUE);

        if (!StepOver)
        {
            cBytes = 0;
            dwTemp = 0;
            returnvalue = GetAddrOff(addr);
            bReturn = DbgReadMemory(hthd->hprc,
                       (LPVOID)returnvalue,
                       &dwTemp,
                       sizeof(DWORD),
                       &cBytes);
            if (!bReturn || cBytes != sizeof(DWORD) || dwTemp == 0 ) 
            {
                returnvalue = pcaddr.addr.off + sizeof(ARMI);
                GetAddrOff(addr) = returnvalue;
                TranslateAddress(hthd->hprc, 0, &addr, TRUE);
                dwPC = 0;
            }
            else
            {
                dwPC = returnvalue;
            }
            // Now need to find if its a thunk, if yes, we need to 
            // probe the thunk destination
            if ( dwPC )
            {
                while (IsThunk(hthd, dwPC, NULL, &dwPC, NULL ) && dwPC)
                {
                    GetAddrOff(addr) = dwPC;
                    TranslateAddress(hthd->hprc, 0, &addr, FALSE);
                    dwPC = GetAddrOff(addr);
                    cBytes = 0;
                    dwTemp = 0;
                    bReturn = DbgReadMemory(hthd->hprc,
                       (LPVOID)dwPC,
                       &dwTemp,
                       sizeof(DWORD),
                       &cBytes);
                    if (!bReturn || cBytes != sizeof(DWORD) || dwTemp == 0 ) 
                    {
                        returnvalue = pcaddr.addr.off + sizeof(ARMI);
                        GetAddrOff(addr) = returnvalue;
                        TranslateAddress(hthd->hprc, 0, &addr, TRUE);
                        break;
                    }
                }
            }
        }

        returnvalue = GetAddrOff(addr);
    }
#endif

    ADDRFLAT(NextAddr, EXTEND64(returnvalue));
}

void
ArmMachineInfo::IncrementBySmallestInstruction(PADDR Addr)
{
    AddrAdd(Addr, 4);
}

void
ArmMachineInfo::DecrementBySmallestInstruction(PADDR Addr)
{
    AddrSub(Addr, 4);
}

void
ArmMachineInfo::Assemble(ProcessInfo* Process,
                         PADDR Address, PSTR Input)
{
    // Not going to implement assemble command at this time
    ErrOut("No assemble support for ARM\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\arm_mach.hpp ===
//----------------------------------------------------------------------------
//
// ARM machine implementation.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#ifndef __ARM_MACH_HPP__
#define __ARM_MACH_HPP__

//
// NOTE: Be very careful when using machine-specific header files
// such as nt<plat>.h.  The machine implementation class is
// compiled for all platforms so the nt<plat>.h file will be the
// one for the build platform, not necessarily the platform
// of the machine implementation.  ntdbg.h contains many cross-platform
// types and definitions that can be used to avoid problems.
//

typedef union _ARMI* PARMI;
struct ArmDecode;

class ArmMachineInfo : public MachineInfo
{
public:
    ArmMachineInfo(TargetInfo* Target);

    // MachineInfo.

    virtual HRESULT Initialize(void);
    
    virtual void GetSystemTypeInfo(PSYSTEM_TYPE_INFO Info);
    virtual void GetDefaultKdData(PKDDEBUGGER_DATA64 KdData);

    virtual void InitializeContext
        (ULONG64 Pc, PDBGKD_ANY_CONTROL_REPORT ControlReport);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);
    virtual HRESULT ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG FromSver,
                                       ULONG FromSize, PVOID From);
    virtual HRESULT ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG ToSver, ULONG ToSize, PVOID To);
    virtual void InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version);
    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              ULONG64 Stack);

    virtual HRESULT GetContextFromFiber(ProcessInfo* Process,
                                        ULONG64 FiberBase,
                                        PCROSS_PLATFORM_CONTEXT Context,
                                        BOOL Verbose);
    virtual HRESULT GetContextFromTrapFrame(ULONG64 TrapBase,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            BOOL Verbose);
    virtual void GetScopeFrameFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                          PDEBUG_STACK_FRAME ScopeFrame);
    virtual HRESULT GetScopeFrameRegister(ULONG Reg,
                                          PDEBUG_STACK_FRAME ScopeFrame,
                                          PULONG64 Value);
    virtual HRESULT SetScopeFrameRegister(ULONG Reg,
                                          PDEBUG_STACK_FRAME ScopeFrame,
                                          ULONG64 Value);
                                              
    virtual int GetType(ULONG Reg);
    virtual HRESULT GetVal(ULONG Reg, REGVAL* Val);
    virtual HRESULT SetVal(ULONG Reg, REGVAL* Val);

    virtual void GetPC(PADDR Address);
    virtual void SetPC(PADDR Address);
    virtual void GetFP(PADDR Address);
    virtual void GetSP(PADDR Address);
    virtual ULONG64 GetArgReg(void);
    virtual ULONG64 GetRetReg(void);

    virtual void OutputAll(ULONG Mask, ULONG OutMask);

    virtual HRESULT SetAndOutputTrapFrame(ULONG64 TrapBase,
                                          PCROSS_PLATFORM_CONTEXT Context);

    virtual TRACEMODE GetTraceMode(void);
    virtual void SetTraceMode(TRACEMODE Mode);
    virtual BOOL IsStepStatusSupported(ULONG Status);

    virtual ULONG ExecutingMachine(void);

    virtual HRESULT SetPageDirectory(ThreadInfo* Thread,
                                     ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ThreadInfo* Thread, ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastPhys);
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset);
    virtual void DecodePte(ULONG64 Pte, PULONG64 PageFrameNumber,
                           PULONG Flags);

    virtual void Assemble(ProcessInfo* Process,
                          PADDR Addr, PSTR Input);
    virtual BOOL Disassemble(ProcessInfo* Process,
                             PADDR Addr, PSTR Buffer, BOOL EffAddr);

    virtual BOOL IsBreakpointInstruction(ProcessInfo* Process, PADDR Addr);
    virtual HRESULT InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                ULONG Flags,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual HRESULT RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual void AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                   ULONG BreakType);
    
    virtual BOOL IsCallDisasm(PCSTR Disasm);
    virtual BOOL IsReturnDisasm(PCSTR Disasm);
    virtual BOOL IsSystemCallDisasm(PCSTR Disasm);
    
    virtual BOOL IsDelayInstruction(PADDR Addr);
    virtual void GetEffectiveAddr(PADDR Addr, PULONG Size);
    virtual void GetNextOffset(ProcessInfo* Process, BOOL StepOver,
                               PADDR NextAddr, PULONG NextMachine);

    virtual void IncrementBySmallestInstruction(PADDR Addr);
    virtual void DecrementBySmallestInstruction(PADDR Addr);

    virtual void OutputFunctionEntry(PVOID RawEntry);
    virtual HRESULT ReadDynamicFunctionTable(ProcessInfo* Process,
                                             ULONG64 Table,
                                             PULONG64 NextTable,
                                             PULONG64 MinAddress,
                                             PULONG64 MaxAddress,
                                             PULONG64 BaseAddress,
                                             PULONG64 TableData,
                                             PULONG TableSize,
                                             PWSTR OutOfProcessDll,
                                             PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable);
    virtual PVOID FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize);

    virtual HRESULT ReadKernelProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);
    
    // ArmMachineInfo.

protected:
    void DisArmArth(ArmDecode* Decode, PARMI Instr);
    void DisArmBi(ArmDecode* Decode, PARMI Instr);
    void DisArmBkpt(ArmDecode* Decode, PARMI Instr);
    void DisArmBxi(ArmDecode* Decode, PARMI Instr);
    void DisArmBxr(ArmDecode* Decode, PARMI Instr);
    void DisArmCdp(ArmDecode* Decode, PARMI Instr);
    void DisArmClz(ArmDecode* Decode, PARMI Instr);
    void DisArmCmp(ArmDecode* Decode, PARMI Instr);
    void DisArmLdc(ArmDecode* Decode, PARMI Instr);
    void DisArmLdm(ArmDecode* Decode, PARMI Instr);
    void DisArmLdr(ArmDecode* Decode, PARMI Instr);
    void DisArmLdrh(ArmDecode* Decode, PARMI Instr);
    void DisArmMcr(ArmDecode* Decode, PARMI Instr);
    void DisArmMcrr(ArmDecode* Decode, PARMI Instr);
    void DisArmMov(ArmDecode* Decode, PARMI Instr);
    void DisArmMrs(ArmDecode* Decode, PARMI Instr);
    void DisArmMsr(ArmDecode* Decode, PARMI Instr);
    void DisArmMul(ArmDecode* Decode, PARMI Instr);
    void DisArmQadd(ArmDecode* Decode, PARMI Instr);
    void DisArmSmla(ArmDecode* Decode, PARMI Instr);
    void DisArmSmlal(ArmDecode* Decode, PARMI Instr);
    void DisArmSmul(ArmDecode* Decode, PARMI Instr);
    void DisArmSwi(ArmDecode* Decode, PARMI Instr);
    void DisArmSwp(ArmDecode* Decode, PARMI Instr);
    
    void BufferEffectiveAddress(ULONG64 Offset, ULONG Size);
    void BufferArmDpArg(PARMI Instr);
    void BufferArmShift(ULONG Shift);
    void BufferRegName(ULONG Reg);
    void BufferCond(ULONG Cond);

    ADDR m_DisStart;
    ULONG m_ArgCol;
    
    ADDR m_EffAddr;
    ULONG m_EaSize;
};

#endif // #ifndef __ARM_MACH_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\arm_reg.cpp ===
//----------------------------------------------------------------------------
//
// ARM machine implementation.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

char g_ArmSp[] = "sp";
char g_ArmLr[] = "lr";
char g_ArmPc[] = "pc";
char g_ArmPsr[] = "psr";
char g_ArmPsrN[] = "nf";
char g_ArmPsrZ[] = "zf";
char g_ArmPsrC[] = "cf";
char g_ArmPsrV[] = "vf";
char g_ArmPsrQ[] = "qf";
char g_ArmPsrI[] = "if";
char g_ArmPsrF[] = "ff";
char g_ArmPsrT[] = "tf";
char g_ArmPsrMode[] = "mode";

REGDEF g_ArmRegs[] =
{
    g_R0, ARM_R0, g_R1, ARM_R1, g_R2, ARM_R2, g_R3, ARM_R3,
    g_R4, ARM_R4, g_R5, ARM_R5, g_R6, ARM_R6,
    g_R7, ARM_R7, g_R8, ARM_R8, g_R9, ARM_R9, g_R10, ARM_R10,
    g_R11, ARM_R11, g_R12, ARM_R12,
    
    g_ArmSp, ARM_SP, g_ArmLr, ARM_LR, g_ArmPc, ARM_PC, g_ArmPsr, ARM_PSR,

    g_ArmPsrN, ARM_PSR_N, g_ArmPsrZ, ARM_PSR_Z, g_ArmPsrC, ARM_PSR_C,
    g_ArmPsrV, ARM_PSR_V, g_ArmPsrQ, ARM_PSR_Q, g_ArmPsrI, ARM_PSR_I,
    g_ArmPsrF, ARM_PSR_F, g_ArmPsrT, ARM_PSR_T,
    g_ArmPsrMode, ARM_PSR_MODE,
    
    NULL, 0,
};

REGSUBDEF g_ArmSubRegs[] =
{
    { ARM_PSR_N,    ARM_PSR,  31, 1 },
    { ARM_PSR_Z,    ARM_PSR,  30, 1 },
    { ARM_PSR_C,    ARM_PSR,  29, 1 },
    { ARM_PSR_V,    ARM_PSR,  28, 1 },
    { ARM_PSR_Q,    ARM_PSR,  27, 1 },
    { ARM_PSR_I,    ARM_PSR,   7, 1 },
    { ARM_PSR_F,    ARM_PSR,   6, 1 },
    { ARM_PSR_T,    ARM_PSR,   5, 1 },
    { ARM_PSR_MODE, ARM_PSR,   0, 5 },
    { REG_ERROR,    REG_ERROR, 0, 0 },
};

RegisterGroup g_ArmGroup =
{
    0, g_ArmRegs, g_ArmSubRegs, NULL
};

// First ExecTypes entry must be the actual processor type.
ULONG g_ArmExecTypes[] =
{
    IMAGE_FILE_MACHINE_ARM
};

// This array must be sorted by CV reg value.
CvRegMap g_ArmCvRegMap[] =
{
    {CV_ARM_R0, ARM_R0},
    {CV_ARM_R1, ARM_R1},
    {CV_ARM_R2, ARM_R2},
    {CV_ARM_R3, ARM_R3},
    {CV_ARM_R4, ARM_R4},
    {CV_ARM_R5, ARM_R5},
    {CV_ARM_R6, ARM_R6},
    {CV_ARM_R7, ARM_R7},
    {CV_ARM_R8, ARM_R8},
    {CV_ARM_R9, ARM_R9},
    {CV_ARM_R10, ARM_R10},
    {CV_ARM_R11, ARM_R11},
    {CV_ARM_R12, ARM_R12},
    {CV_ARM_SP, ARM_SP},
    {CV_ARM_LR, ARM_LR},
    {CV_ARM_PC, ARM_PC},
    {CV_ARM_CPSR, ARM_PSR},
};

ArmMachineInfo::ArmMachineInfo(TargetInfo* Target)
    : MachineInfo(Target)
{
    m_FullName = "ARM 32-bit";
    m_AbbrevName = "arm";
    m_PageSize = ARM_PAGE_SIZE;
    m_PageShift = ARM_PAGE_SHIFT;
    m_NumExecTypes = 1;
    m_ExecTypes = g_ArmExecTypes;
    m_Ptr64 = FALSE;
    m_RetRegIndex = ARM_R0;

    m_MaxDataBreakpoints = 0;
    m_SymPrefix = NULL;

    m_AllMask = REGALL_INT32;

    m_SizeCanonicalContext = sizeof(ARM_CONTEXT);
    m_SverCanonicalContext = NT_SVER_NT4;

    m_CvRegMapSize = DIMA(g_ArmCvRegMap);
    m_CvRegMap = g_ArmCvRegMap;
}

HRESULT
ArmMachineInfo::Initialize(void)
{
    m_NumGroups = 1;
    m_Groups[0] = &g_ArmGroup;

    return MachineInfo::Initialize();
}

void
ArmMachineInfo::
InitializeContext(ULONG64 Pc,
                  PDBGKD_ANY_CONTROL_REPORT ControlReport)
{
    // No ARM KD support.
}

void
ArmMachineInfo::GetSystemTypeInfo(PSYSTEM_TYPE_INFO Info)
{
    Info->SizeTargetContext = sizeof(ARM_CONTEXT);
    Info->OffsetTargetContextFlags =
        FIELD_OFFSET(ARM_CONTEXT, ContextFlags);

    // NT doesn't run on the ARM so these NT-related
    // data structure constants are not meaningful.
    Info->SizeControlReport = 0;
    Info->OffsetSpecialRegisters = 0;
    Info->SizeKspecialRegisters = 0;
    Info->TriagePrcbOffset = 0;
    Info->SizePageFrameNumber = sizeof(ULONG);
    Info->SizePte = sizeof(ULONG);
    Info->SharedUserDataOffset = 0;
    Info->UmSharedUserDataOffset = 0;
    Info->UmSharedSysCallOffset = 0;
    Info->UmSharedSysCallSize = 0;
    Info->SizeDynamicFunctionTable = 0;
    Info->SizeRuntimeFunction = 0;
}
    
void
ArmMachineInfo::GetDefaultKdData(PKDDEBUGGER_DATA64 KdData)
{
    // No KD data to fill in.
}

HRESULT
ArmMachineInfo::KdGetContextState(ULONG State)
{
    // MCTX_CONTEXT and MCTX_FULL are the same for Arm.
    if (State >= MCTX_CONTEXT && m_ContextState < MCTX_FULL)
    {
        HRESULT Status;
            
        Status = m_Target->GetContext(m_Target->m_RegContextThread->m_Handle,
                                      &m_Context);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_FULL;
    }

    return S_OK;
}

HRESULT
ArmMachineInfo::KdSetContext(void)
{
    return m_Target->SetContext(m_Target->m_RegContextThread->m_Handle,
                                &m_Context);
}

HRESULT
ArmMachineInfo::ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                   ULONG FromSver,
                                   ULONG FromSize, PVOID From)
{
    if (FromSize < sizeof(ARM_CONTEXT))
    {
        return E_INVALIDARG;
    }

    memcpy(Context, From, sizeof(ARM_CONTEXT));
    return S_OK;
}

HRESULT
ArmMachineInfo::ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                 ULONG ToSver, ULONG ToSize, PVOID To)
{
    if (ToSize < sizeof(ARM_CONTEXT))
    {
        return E_INVALIDARG;
    }
        
    memcpy(To, Context, sizeof(ARM_CONTEXT));
    return S_OK;
}

void
ArmMachineInfo::InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG Version)
{
    Context->ArmContext.ContextFlags = ARM_CONTEXT_FULL;
}

HRESULT
ArmMachineInfo::GetContextFromThreadStack(ULONG64 ThreadBase,
                                          PCROSS_PLATFORM_CONTEXT Context,
                                          ULONG64 Stack)
{
    return E_NOTIMPL;
}

HRESULT
ArmMachineInfo::GetContextFromFiber(ProcessInfo* Process,
                                    ULONG64 FiberBase,
                                    PCROSS_PLATFORM_CONTEXT Context,
                                    BOOL Verbose)
{
    return E_NOTIMPL;
}

HRESULT
ArmMachineInfo::GetContextFromTrapFrame(ULONG64 TrapBase,
                                        PCROSS_PLATFORM_CONTEXT Context,
                                        BOOL Verbose)
{
    return E_NOTIMPL;
}
    
void
ArmMachineInfo::GetScopeFrameFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                         PDEBUG_STACK_FRAME ScopeFrame)
{
    ZeroMemory(ScopeFrame, sizeof(*ScopeFrame));
    ScopeFrame->InstructionOffset = Context->ArmContext.Pc;
    ScopeFrame->FrameOffset = Context->ArmContext.R11;
    ScopeFrame->StackOffset = Context->ArmContext.Sp;
}

HRESULT
ArmMachineInfo::GetScopeFrameRegister(ULONG Reg,
                                      PDEBUG_STACK_FRAME ScopeFrame,
                                      PULONG64 Value)
{
    HRESULT Status;
    REGVAL RegVal;
    
    switch(Reg)
    {
    case ARM_SP:
        *Value = ScopeFrame->StackOffset;
        return S_OK;
    case ARM_R11:
        *Value = ScopeFrame->FrameOffset;
        return S_OK;
    default:
        RegVal.I64 = 0;
        if ((Status = FullGetVal(Reg, &RegVal)) != S_OK)
        {
            return Status;
        }
        *Value = RegVal.I64;
        return S_OK;
    }
}

HRESULT
ArmMachineInfo::SetScopeFrameRegister(ULONG Reg,
                                      PDEBUG_STACK_FRAME ScopeFrame,
                                      ULONG64 Value)
{
    REGVAL RegVal;
    
    switch(Reg)
    {
    case ARM_SP:
        ScopeFrame->StackOffset = Value;
        return S_OK;
    case ARM_R11:
        ScopeFrame->FrameOffset = Value;
        return S_OK;
    default:
        RegVal.Type = GetType(Reg);
        RegVal.I64 = Value;
        return FullSetVal(Reg, &RegVal);
    }
}

int
ArmMachineInfo::GetType(ULONG Reg)
{
    if (Reg < ARM_INT_FIRST || Reg > ARM_INT_LAST)
    {
        return REGVAL_SUB32;
    }
    else
    {
        return REGVAL_INT32;
    }
}

HRESULT
ArmMachineInfo::GetVal(ULONG Reg, REGVAL *Val)
{
    HRESULT Status;

    if (Reg < ARM_INT_FIRST || Reg > ARM_INT_LAST)
    {
        return E_INVALIDARG;
    }
    
    if ((Status = GetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }

    Val->Type = GetType(Reg);
    Val->I64 = *(&m_Context.ArmContext.R0 + (Reg - ARM_INT_FIRST));

    return S_OK;
}

HRESULT
ArmMachineInfo::SetVal(ULONG Reg, REGVAL *Val)
{
    HRESULT Status;
    
    if (m_ContextIsReadOnly)
    {
        return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    
    if (Reg < ARM_INT_FIRST || Reg > ARM_INT_LAST)
    {
        return E_INVALIDARG;
    }
    
    // Optimize away some common cases where registers are
    // set to their current value.
    if (m_ContextState >= MCTX_PC && Reg == ARM_PC &&
        Val->I64 == m_Context.ArmContext.Pc)
    {
        return S_OK;
    }
    
    if ((Status = GetContextState(MCTX_DIRTY)) != S_OK)
    {
        return Status;
    }

    *(&m_Context.ArmContext.R0 + (Reg - ARM_INT_FIRST)) = Val->I32;

    NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS,
                              RegCountFromIndex(Reg));
    return S_OK;
}

void
ArmMachineInfo::GetPC(PADDR Address)
{
    ADDRFLAT(Address, EXTEND64(GetReg32(ARM_PC)));
}

void
ArmMachineInfo::SetPC(PADDR Address)
{
    SetReg32(ARM_PC, (ULONG)Flat(*Address));
}

void
ArmMachineInfo::GetFP(PADDR Address)
{
    ADDRFLAT(Address, EXTEND64(GetReg32(ARM_R11)));
}

void
ArmMachineInfo::GetSP(PADDR Address)
{
    ADDRFLAT(Address, EXTEND64(GetReg32(ARM_SP)));
}

ULONG64
ArmMachineInfo::GetArgReg(void)
{
    return EXTEND64(GetReg32(ARM_R0));
}

ULONG64
ArmMachineInfo::GetRetReg(void)
{
    return EXTEND64(GetReg32(ARM_R0));
}

void
ArmMachineInfo::OutputAll(ULONG Mask, ULONG OutMask)
{
    if (GetContextState(MCTX_FULL) != S_OK)
    {
        ErrOut("Unable to retrieve register information\n");
        return;
    }
    
    if (Mask & (REGALL_INT32 | REGALL_INT64))
    {
        MaskOut(OutMask, " r0=%08x  r1=%08x  r2=%08x  "
                "r3=%08x  r4=%08x  r5=%08x\n",
                m_Context.ArmContext.R0, m_Context.ArmContext.R1,
                m_Context.ArmContext.R2, m_Context.ArmContext.R3,
                m_Context.ArmContext.R4, m_Context.ArmContext.R5);
        MaskOut(OutMask, " r6=%08x  r7=%08x  r8=%08x  "
                "r9=%08x r10=%08x r11=%08x\n",
                m_Context.ArmContext.R6, m_Context.ArmContext.R7,
                m_Context.ArmContext.R8, m_Context.ArmContext.R9,
                m_Context.ArmContext.R10, m_Context.ArmContext.R11);
        MaskOut(OutMask, "r12=%08x  sp=%08x  lr=%08x  "
                "pc=%08x psr=%08x %s%s%s%s%s %s\n",
                m_Context.ArmContext.R12, m_Context.ArmContext.Sp,
                m_Context.ArmContext.Lr, m_Context.ArmContext.Pc,
                m_Context.ArmContext.Psr,
                (m_Context.ArmContext.Psr & ARM_FLAG_N) ? "N" : "-",
                (m_Context.ArmContext.Psr & ARM_FLAG_Z) ? "Z" : "-",
                (m_Context.ArmContext.Psr & ARM_FLAG_C) ? "C" : "-",
                (m_Context.ArmContext.Psr & ARM_FLAG_V) ? "V" : "-",
                (m_Context.ArmContext.Psr & ARM_FLAG_Q) ? "Q" : "-",
                (m_Context.ArmContext.Psr & ARM_FLAG_T) ? "Thumb" : "ARM");
    }
}

HRESULT
ArmMachineInfo::SetAndOutputTrapFrame(ULONG64 TrapBase,
                                      PCROSS_PLATFORM_CONTEXT Context)
{
    return SetAndOutputContext(Context, TRUE, REGALL_INT32);
}
    
TRACEMODE
ArmMachineInfo::GetTraceMode(void)
{
    return TRACE_NONE;
}

void
ArmMachineInfo::SetTraceMode(TRACEMODE Mode)
{
    // No explicit trace mode needed.
}

BOOL
ArmMachineInfo::IsStepStatusSupported(ULONG Status)
{
    switch (Status) 
    {
    case DEBUG_STATUS_STEP_INTO:
    case DEBUG_STATUS_STEP_OVER:
        return TRUE;
    default:
        return FALSE;
    }
}

ULONG
ArmMachineInfo::ExecutingMachine(void)
{
    return m_ExecTypes[0];
}

HRESULT
ArmMachineInfo::SetPageDirectory(ThreadInfo* Thread,
                                 ULONG Idx, ULONG64 PageDir,
                                 PULONG NextIdx)
{
    return E_NOTIMPL;
}

HRESULT
ArmMachineInfo::GetVirtualTranslationPhysicalOffsets(ThreadInfo* Thread,
                                                     ULONG64 Virt,
                                                     PULONG64 Offsets,
                                                     ULONG OffsetsSize,
                                                     PULONG Levels,
                                                     PULONG PfIndex,
                                                     PULONG64 LastVal)
{
    return E_NOTIMPL;
}

HRESULT
ArmMachineInfo::GetBaseTranslationVirtualOffset(PULONG64 Offset)
{
    return E_NOTIMPL;
}

void
ArmMachineInfo::DecodePte(ULONG64 Pte, PULONG64 PageFrameNumber,
                            PULONG Flags)
{
    // XXX
    *PageFrameNumber = 0;
    *Flags = 0;
}

void
ArmMachineInfo::OutputFunctionEntry(PVOID RawEntry)
{
    ErrOut("ARM function entries not implemented\n");
}

HRESULT
ArmMachineInfo::ReadDynamicFunctionTable(ProcessInfo* Process,
                                         ULONG64 Table,
                                         PULONG64 NextTable,
                                         PULONG64 MinAddress,
                                         PULONG64 MaxAddress,
                                         PULONG64 BaseAddress,
                                         PULONG64 TableData,
                                         PULONG TableSize,
                                         PWSTR OutOfProcessDll,
                                         PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable)
{
    return E_NOTIMPL;
}

PVOID
ArmMachineInfo::FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                         ULONG64 Address,
                                         PVOID TableData,
                                         ULONG TableSize)
{
    return NULL;
}

HRESULT
ArmMachineInfo::ReadKernelProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    // No ARM KD support.
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\brkpt.cpp ===
//----------------------------------------------------------------------------
//
// Breakpoint handling functions.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// Currently used only to watch for list changes when
// doing callbacks for breakpoint hit notifications.
BOOL g_BreakpointListChanged;

// Always update data breakpoints the very first time in
// order to flush out any stale data breakpoints.
BOOL g_UpdateDataBreakpoints = TRUE;
BOOL g_DataBreakpointsChanged;
BOOL g_BreakpointsSuspended;

Breakpoint* g_StepTraceBp;      // Trace breakpoint.
CHAR g_StepTraceCmdState;
Breakpoint* g_DeferBp;          // Deferred breakpoint.
BOOL g_DeferDefined;            // TRUE if deferred breakpoint is active.

Breakpoint* g_LastBreakpointHit;
ADDR g_LastBreakpointHitPc;

HRESULT
BreakpointInit(void)
{
    // These breakpoints are never put in any list so their
    // IDs can be anything.  Pick unusual numbers to make them
    // easy to identify when debugging the debugger.
    g_StepTraceBp = new
        CodeBreakpoint(NULL, 0xffff0000, IMAGE_FILE_MACHINE_UNKNOWN);
    g_StepTraceCmdState = 't';
    g_DeferBp = new
        CodeBreakpoint(NULL, 0xffff0001, IMAGE_FILE_MACHINE_UNKNOWN);
    if (g_StepTraceBp == NULL ||
        g_DeferBp == NULL)
    {
        delete g_StepTraceBp;
        g_StepTraceBp = NULL;
        delete g_DeferBp;
        g_DeferBp = NULL;
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// Breakpoint.
//
//----------------------------------------------------------------------------

Breakpoint::Breakpoint(DebugClient* Adder, ULONG Id, ULONG Type,
                       ULONG ProcType)
{
    m_Next = NULL;
    m_Prev = NULL;
    m_Refs = 1;
    m_Id = Id;
    m_BreakType = Type;
    // Breakpoints are always created disabled since they
    // are not initialized at the time of creation.
    m_Flags = 0;
    m_CodeFlags = IBI_DEFAULT;
    ADDRFLAT(&m_Addr, 0);
    // Initial data parameters must be set to something
    // valid so that Validate calls will allow the offset
    // to be changed.
    m_DataSize = 1;
    m_DataAccessType = DEBUG_BREAK_EXECUTE;
    m_PassCount = 1;
    m_CurPassCount = 1;
    m_CommandLen = 0;
    m_Command = NULL;
    m_MatchThread = NULL;
    m_Process = g_Process;
    m_OffsetExprLen = 0;
    m_OffsetExpr = NULL;
    m_Adder = Adder;
    m_MatchThreadData = 0;
    m_MatchProcessData = 0;

    SetProcType(ProcType);

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }
}

Breakpoint::~Breakpoint(void)
{
    ULONG i;

    // There used to be an assert here checking that
    // the inserted flag wasn't set before a breakpoint
    // structure was deleted.  However, the inserted flag
    // might still be set at this point if a breakpoint
    // restore failed, so the assert is not valid.

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }

    // Make sure stale pointers aren't left in the
    // go breakpoints array.  This can happen if
    // a process exits or the target reboots while
    // go breakpoints are active.
    for (i = 0; i < g_NumGoBreakpoints; i++)
    {
        if (g_GoBreakpoints[i] == this)
        {
            g_GoBreakpoints[i] = NULL;
        }
    }

    if (this == g_LastBreakpointHit)
    {
        g_LastBreakpointHit = NULL;
    }

    // Take this item out of the list if necessary.
    if (m_Flags & BREAKPOINT_IN_LIST)
    {
        UnlinkFromList();
    }

    delete [] (PSTR)m_Command;
    delete [] (PSTR)m_OffsetExpr;
}

STDMETHODIMP
Breakpoint::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    // Interface specific casts are necessary in order to
    // get the right vtable pointer in our multiple
    // inheritance scheme.
    if (DbgIsEqualIID(InterfaceId, IID_IUnknown) ||
        DbgIsEqualIID(InterfaceId, IID_IDebugBreakpoint))
    {
        *Interface = (IDebugBreakpoint *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
Breakpoint::AddRef(
    THIS
    )
{
    // This object's lifetime is not controlled by
    // the interface.
    return 1;
}

STDMETHODIMP_(ULONG)
Breakpoint::Release(
    THIS
    )
{
    // This object's lifetime is not controlled by
    // the interface.
    return 0;
}

STDMETHODIMP
Breakpoint::GetId(
    THIS_
    OUT PULONG Id
    )
{
    ENTER_ENGINE();

    *Id = m_Id;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetType(
    THIS_
    OUT PULONG BreakType,
    OUT PULONG ProcType
    )
{
    ENTER_ENGINE();

    *BreakType = m_BreakType;
    *ProcType = m_ProcType;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetAdder(
    THIS_
    OUT PDEBUG_CLIENT* Adder
    )
{
    ENTER_ENGINE();

    *Adder = (PDEBUG_CLIENT)m_Adder;
    m_Adder->AddRef();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetFlags(
    THIS_
    OUT PULONG Flags
    )
{
    ENTER_ENGINE();

    *Flags = m_Flags & BREAKPOINT_EXTERNAL_FLAGS;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::AddFlags(
    THIS_
    IN ULONG Flags
    )
{
    if (Flags & ~BREAKPOINT_EXTERNAL_MODIFY_FLAGS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    m_Flags |= Flags;

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }

    UpdateInternal();
    NotifyChanged();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::RemoveFlags(
    THIS_
    IN ULONG Flags
    )
{
    if (Flags & ~BREAKPOINT_EXTERNAL_MODIFY_FLAGS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    m_Flags &= ~Flags;

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }

    UpdateInternal();
    NotifyChanged();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::SetFlags(
    THIS_
    IN ULONG Flags
    )
{
    if (Flags & ~BREAKPOINT_EXTERNAL_MODIFY_FLAGS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    m_Flags = (m_Flags & ~BREAKPOINT_EXTERNAL_MODIFY_FLAGS) |
        (Flags & BREAKPOINT_EXTERNAL_MODIFY_FLAGS);

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }

    UpdateInternal();
    NotifyChanged();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    if (m_Flags & DEBUG_BREAKPOINT_DEFERRED)
    {
        return E_NOINTERFACE;
    }

    ENTER_ENGINE();

    *Offset = Flat(m_Addr);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::SetOffset(
    THIS_
    IN ULONG64 Offset
    )
{
    if (m_Flags & DEBUG_BREAKPOINT_DEFERRED)
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ADDR Addr;
    HRESULT Status;

    ADDRFLAT(&Addr, Offset);
    Status = SetAddr(&Addr, BREAKPOINT_WARN_MATCH);
    if (Status == S_OK)
    {
        NotifyChanged();
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::GetDataParameters(
    THIS_
    OUT PULONG Size,
    OUT PULONG AccessType
    )
{
    if (m_BreakType != DEBUG_BREAKPOINT_DATA)
    {
        return E_NOINTERFACE;
    }

    ENTER_ENGINE();

    *Size = m_DataSize;
    *AccessType = m_DataAccessType;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::SetDataParameters(
    THIS_
    IN ULONG Size,
    IN ULONG AccessType
    )
{
    if (m_BreakType != DEBUG_BREAKPOINT_DATA)
    {
        return E_NOINTERFACE;
    }

    ENTER_ENGINE();

    ULONG OldSize = m_DataSize;
    ULONG OldAccess = m_DataAccessType;
    HRESULT Status;

    m_DataSize = Size;
    m_DataAccessType = AccessType;
    Status = Validate();
    if (Status != S_OK)
    {
        m_DataSize = OldSize;
        m_DataAccessType = OldAccess;
    }
    else
    {
        g_DataBreakpointsChanged = TRUE;
        NotifyChanged();
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::GetPassCount(
    THIS_
    OUT PULONG Count
    )
{
    ENTER_ENGINE();

    *Count = m_PassCount;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::SetPassCount(
    THIS_
    IN ULONG Count
    )
{
    if (Count < 1)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    m_PassCount = Count;
    m_CurPassCount = Count;
    NotifyChanged();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetCurrentPassCount(
    THIS_
    OUT PULONG Count
    )
{
    ENTER_ENGINE();

    *Count = m_CurPassCount;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetMatchThreadId(
    THIS_
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (m_MatchThread)
    {
        *Id = m_MatchThread->m_UserId;
        Status = S_OK;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::SetMatchThreadId(
    THIS_
    IN ULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (IS_KERNEL_TARGET(m_Process->m_Target) &&
        m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        ErrOut("Kernel data breakpoints cannot be limited to a processor\n");
        Status = E_INVALIDARG;
    }
    else
    {
        ThreadInfo* Thread = FindAnyThreadByUserId(Id);
        if (Thread != NULL)
        {
            m_MatchThread = Thread;
            NotifyChanged();
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::GetCommand(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG CommandSize
    )
{
    ENTER_ENGINE();

    HRESULT Status = FillStringBuffer(m_Command, m_CommandLen,
                                      Buffer, BufferSize, CommandSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::SetCommand(
    THIS_
    IN PCSTR Command
    )
{
    HRESULT Status;

    if (strlen(Command) >= MAX_COMMAND)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    Status = ChangeString((PSTR*)&m_Command, &m_CommandLen, Command);
    if (Status == S_OK)
    {
        NotifyChanged();
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::GetOffsetExpression(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG ExpressionSize
    )
{
    ENTER_ENGINE();

    HRESULT Status = FillStringBuffer(m_OffsetExpr, m_OffsetExprLen,
                                      Buffer, BufferSize, ExpressionSize);

    LEAVE_ENGINE();
    return Status;
}

HRESULT
Breakpoint::SetEvaluatedOffsetExpression(PCSTR Expr,
                                         BreakpointEvalResult Valid,
                                         PADDR Addr)
{
    HRESULT Status =
        ChangeString((PSTR*)&m_OffsetExpr, &m_OffsetExprLen, Expr);
    if (Status != S_OK)
    {
        return Status;
    }

    if (Expr != NULL)
    {
        // Do initial evaluation in case the expression can be
        // resolved right away.  This will also set the deferred
        // flag if the expression can't be evaluated.
        EvalOffsetExpr(Valid, Addr);
    }
    else
    {
        // This breakpoint is no longer deferred since there's
        // no way to activate it later any more.
        m_Flags &= ~DEBUG_BREAKPOINT_DEFERRED;
        UpdateInternal();
    }

    NotifyChanged();
    return S_OK;
}

STDMETHODIMP
Breakpoint::SetOffsetExpression(
    THIS_
    IN PCSTR Expression
    )
{
    HRESULT Status;

    if (strlen(Expression) >= MAX_COMMAND)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    ADDR Addr;

    Status = SetEvaluatedOffsetExpression(Expression, BPEVAL_UNKNOWN, &Addr);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::GetParameters(
    THIS_
    OUT PDEBUG_BREAKPOINT_PARAMETERS Params
    )
{
    ENTER_ENGINE();

    if (m_Flags & DEBUG_BREAKPOINT_DEFERRED)
    {
        Params->Offset = DEBUG_INVALID_OFFSET;
    }
    else
    {
        Params->Offset = Flat(m_Addr);
    }
    Params->Id = m_Id;
    Params->BreakType = m_BreakType;
    Params->ProcType = m_ProcType;
    Params->Flags = m_Flags & BREAKPOINT_EXTERNAL_FLAGS;
    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        Params->DataSize = m_DataSize;
        Params->DataAccessType = m_DataAccessType;
    }
    else
    {
        Params->DataSize = 0;
        Params->DataAccessType = 0;
    }
    Params->PassCount = m_PassCount;
    Params->CurrentPassCount = m_CurPassCount;
    Params->MatchThread = m_MatchThread != NULL ?
        m_MatchThread->m_UserId : DEBUG_ANY_ID;
    Params->CommandSize = m_CommandLen;
    Params->OffsetExpressionSize = m_OffsetExprLen;

    LEAVE_ENGINE();
    return S_OK;
}

void
Breakpoint::LinkIntoList(void)
{
    Breakpoint* NextBp;
    Breakpoint* PrevBp;

    DBG_ASSERT((m_Flags & BREAKPOINT_IN_LIST) == 0);

    // Link into list sorted by ID.
    PrevBp = NULL;
    for (NextBp = m_Process->m_Breakpoints;
         NextBp != NULL;
         NextBp = NextBp->m_Next)
    {
        if (m_Id < NextBp->m_Id)
        {
            break;
        }

        PrevBp = NextBp;
    }

    m_Prev = PrevBp;
    if (PrevBp == NULL)
    {
        m_Process->m_Breakpoints = this;
    }
    else
    {
        PrevBp->m_Next = this;
    }
    m_Next = NextBp;
    if (NextBp == NULL)
    {
        m_Process->m_BreakpointsTail = this;
    }
    else
    {
        NextBp->m_Prev = this;
    }

    m_Flags |= BREAKPOINT_IN_LIST;
    m_Process->m_NumBreakpoints++;
    g_BreakpointListChanged = TRUE;
}

void
Breakpoint::UnlinkFromList(void)
{
    DBG_ASSERT(m_Flags & BREAKPOINT_IN_LIST);

    if (m_Prev == NULL)
    {
        m_Process->m_Breakpoints = m_Next;
    }
    else
    {
        m_Prev->m_Next = m_Next;
    }
    if (m_Next == NULL)
    {
        m_Process->m_BreakpointsTail = m_Prev;
    }
    else
    {
        m_Next->m_Prev = m_Prev;
    }

    m_Flags &= ~BREAKPOINT_IN_LIST;
    m_Process->m_NumBreakpoints--;
    g_BreakpointListChanged = TRUE;
}

void
Breakpoint::UpdateInternal(void)
{
    // This only has an effect with internal breakpoints.
    if ((m_Flags & BREAKPOINT_KD_INTERNAL) == 0)
    {
        return;
    }

    // If the breakpoint is ready turn it on, otherwise
    // turn it off.
    ULONG Flags;

    if ((m_Flags & (DEBUG_BREAKPOINT_ENABLED |
                    DEBUG_BREAKPOINT_DEFERRED)) == DEBUG_BREAKPOINT_ENABLED)
    {
        Flags = (m_Flags & BREAKPOINT_KD_COUNT_ONLY) ?
            DBGKD_INTERNAL_BP_FLAG_COUNTONLY : 0;
    }
    else
    {
        Flags = DBGKD_INTERNAL_BP_FLAG_INVALID;
    }

    BpOut("Set internal bp at %s to %X\n",
          FormatAddr64(Flat(m_Addr)), Flags);

    if (Flags != DBGKD_INTERNAL_BP_FLAG_INVALID)
    {
        m_Process->m_Target->
            InsertTargetCountBreakpoint(&m_Addr, Flags);
    }
    else
    {
        m_Process->m_Target->
            RemoveTargetCountBreakpoint(&m_Addr);
    }
}

BreakpointEvalResult
EvalAddrExpression(ProcessInfo* Process, ULONG Machine, PADDR Addr)
{
    BOOL Error = FALSE;
    ULONG NumUn;
    StackSaveLayers Save;
    EvalExpression* Eval;
    EvalExpression* RelChain;

    //
    // This function can be reentered if evaluating an
    // expression causes symbol changes which provoke
    // reevaluation of existing address expressions.
    // Save away current settings to support nesting.
    //

    // Evaluate the expression in the context of the breakpoint's
    // machine type so that registers and such are available.
    ULONG OldMachine = Process->m_Target->m_EffMachineType;
    Process->m_Target->SetEffMachine(Machine, FALSE);

    SetLayersFromProcess(Process);

    RelChain = g_EvalReleaseChain;
    g_EvalReleaseChain = NULL;

    __try
    {
        Eval = GetCurEvaluator();
        Eval->m_AllowUnresolvedSymbols++;
        Eval->EvalCurAddr(SEGREG_CODE, Addr);
        NumUn = Eval->m_NumUnresolvedSymbols;
        ReleaseEvaluator(Eval);
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        // Skip the remainder of the command as there
        // was an error during processing.
        g_CurCmd += strlen(g_CurCmd);
        Error = TRUE;
    }

    g_EvalReleaseChain = RelChain;
    Process->m_Target->SetEffMachine(OldMachine, FALSE);

    if (Error)
    {
        return BPEVAL_ERROR;
    }
    else if (NumUn > 0)
    {
        return BPEVAL_UNRESOLVED;
    }
    else
    {
        ImageInfo* Image;

        // Check if this address falls within an existing module.
        for (Image = Process->m_ImageHead;
             Image != NULL;
             Image = Image->m_Next)
        {
            if (Flat(*Addr) >= Image->m_BaseOfImage &&
                Flat(*Addr) < Image->m_BaseOfImage + Image->m_SizeOfImage)
            {
                return BPEVAL_RESOLVED;
            }
        }

        return BPEVAL_RESOLVED_NO_MODULE;
    }
}

BOOL
Breakpoint::EvalOffsetExpr(BreakpointEvalResult Valid, PADDR Addr)
{
    ULONG OldFlags = m_Flags;

    DBG_ASSERT(m_OffsetExpr != NULL);

    if (Valid == BPEVAL_UNKNOWN)
    {
        PSTR CurCommand = g_CurCmd;

        g_CurCmd = (PSTR)m_OffsetExpr;
        g_DisableErrorPrint++;
        g_PrefixSymbols = TRUE;

        Valid = EvalAddrExpression(m_Process, m_ProcType, Addr);

        g_PrefixSymbols = FALSE;
        g_DisableErrorPrint--;
        g_CurCmd = CurCommand;
    }

    // Silently allow matching breakpoints when resolving
    // as it is difficult for the expression setter to know
    // whether there'll be matches or not at the time
    // the expression is set.
    if (Valid == BPEVAL_RESOLVED)
    {
        m_Flags &= ~DEBUG_BREAKPOINT_DEFERRED;

        if (SetAddr(Addr, BREAKPOINT_ALLOW_MATCH) != S_OK)
        {
            m_Flags |= DEBUG_BREAKPOINT_DEFERRED;
        }
    }
    else
    {
        m_Flags |= DEBUG_BREAKPOINT_DEFERRED;
        // The module containing the breakpoint is being
        // unloaded so just mark this breakpoint as not-inserted.
        m_Flags &= ~BREAKPOINT_INSERTED;
    }

    if ((OldFlags ^ m_Flags) & DEBUG_BREAKPOINT_DEFERRED)
    {
        // Update internal BP status.
        UpdateInternal();

        if (m_Flags & DEBUG_BREAKPOINT_DEFERRED)
        {
            BpOut("Deferring %u '%s'\n", m_Id, m_OffsetExpr);
        }
        else
        {
            BpOut("Enabling deferred %u '%s' at %s\n",
                  m_Id, m_OffsetExpr, FormatAddr64(Flat(m_Addr)));
        }

        return TRUE;
    }

    return FALSE;
}

HRESULT
Breakpoint::CheckAddr(PADDR Addr)
{
    ULONG AddrSpace, AddrFlags;

    if (m_Process->m_Target->
        QueryAddressInformation(m_Process,
                                Flat(*Addr), DBGKD_QUERY_MEMORY_VIRTUAL,
                                &AddrSpace, &AddrFlags) != S_OK)
    {
        ErrOut("Invalid breakpoint address\n");
        return E_INVALIDARG;
    }

    if (m_BreakType != DEBUG_BREAKPOINT_DATA &&
        !(AddrFlags & DBGKD_QUERY_MEMORY_WRITE) ||
        (AddrFlags & DBGKD_QUERY_MEMORY_FIXED))
    {
        ErrOut("Software breakpoints cannot be used on ROM code or\n"
               "other read-only memory. "
               "Use hardware execution breakpoints (ba e) instead.\n");
        return E_INVALIDARG;
    }

    if (m_BreakType != DEBUG_BREAKPOINT_DATA &&
        AddrSpace == DBGKD_QUERY_MEMORY_SESSION)
    {
        WarnOut("WARNING: Software breakpoints on session "
                "addresses can cause bugchecks.\n"
                "Use hardware execution breakpoints (ba e) "
                "if possible.\n");
        return S_FALSE;
    }

    return S_OK;
}

HRESULT
Breakpoint::SetAddr(PADDR Addr, BreakpointMatchAction MatchAction)
{
    if (m_Flags & DEBUG_BREAKPOINT_DEFERRED)
    {
        // Address is unknown.
        return S_OK;
    }

    // Lock the breakpoint processor type to the
    // type of the module containing it.
    ULONG ProcType = m_ProcType;
    if (m_BreakType == DEBUG_BREAKPOINT_CODE)
    {
        ImageInfo* Image = m_Process->FindImageByOffset(Flat(*Addr), FALSE);
        if (Image)
        {
            ProcType = Image->GetMachineType();
            if (ProcType == IMAGE_FILE_MACHINE_UNKNOWN)
            {
                ProcType = m_ProcType;
            }
        }
        else
        {
            ProcType = m_ProcType;
        }
    }

    if (m_Flags & BREAKPOINT_VIRT_ADDR)
    {
        // Old flag used on ALPHA
    }

    ADDR OldAddr = m_Addr;
    HRESULT Valid;

    m_Addr = *Addr;

    Valid = Validate();
    if (Valid != S_OK)
    {
        m_Addr = OldAddr;
        return Valid;
    }

    if (ProcType != m_ProcType)
    {
        SetProcType(ProcType);
    }

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }

    if (MatchAction == BREAKPOINT_ALLOW_MATCH)
    {
        return S_OK;
    }

    for (;;)
    {
        Breakpoint* MatchBp;

        MatchBp = CheckMatchingBreakpoints(this, TRUE, 0xffffffff);
        if (MatchBp == NULL)
        {
            break;
        }

        if (MatchAction == BREAKPOINT_REMOVE_MATCH)
        {
            ULONG MoveId;

            WarnOut("breakpoint %u redefined\n", MatchBp->m_Id);
            // Move breakpoint towards lower IDs.
            if (MatchBp->m_Id < m_Id)
            {
                MoveId = MatchBp->m_Id;
            }
            else
            {
                MoveId = DEBUG_ANY_ID;
            }

            RemoveBreakpoint(MatchBp);

            if (MoveId != DEBUG_ANY_ID)
            {
                // Take over the removed ID.
                UnlinkFromList();
                m_Id = MoveId;
                LinkIntoList();
            }
        }
        else
        {
            WarnOut("Breakpoints %u and %u match\n",
                    m_Id, MatchBp->m_Id);
            break;
        }
    }

    return S_OK;
}

#define INSERTION_MATCH_FLAGS \
    (BREAKPOINT_KD_INTERNAL | BREAKPOINT_VIRT_ADDR)

BOOL
Breakpoint::IsInsertionMatch(Breakpoint* Match)
{
    if ((m_Flags & DEBUG_BREAKPOINT_DEFERRED) ||
        (Match->m_Flags & DEBUG_BREAKPOINT_DEFERRED) ||
        m_BreakType != Match->m_BreakType ||
        ((m_Flags ^ Match->m_Flags) & INSERTION_MATCH_FLAGS) ||
        !AddrEqu(m_Addr, Match->m_Addr) ||
        m_Process != Match->m_Process ||
        (m_BreakType == DEBUG_BREAKPOINT_DATA &&
         m_MatchThread != Match->m_MatchThread))
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

#define PUBLIC_MATCH_FLAGS \
    (BREAKPOINT_HIDDEN | DEBUG_BREAKPOINT_ADDER_ONLY)

BOOL
Breakpoint::IsPublicMatch(Breakpoint* Match)
{
    if (!IsInsertionMatch(Match) ||
        m_ProcType != Match->m_ProcType ||
        ((m_Flags ^ Match->m_Flags) & PUBLIC_MATCH_FLAGS) ||
        ((m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) &&
         m_Adder != Match->m_Adder) ||
        m_MatchThread != Match->m_MatchThread ||
        m_MatchThreadData != Match->m_MatchThreadData ||
        m_MatchProcessData != Match->m_MatchProcessData)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
Breakpoint::MatchesCurrentState(void)
{
    HRESULT Status;
    ULONG64 ThreadData = 0, ProcData = 0;

    // If querying the current state fails go ahead
    // and return a match so that the breakpoint will
    // break as often as possible.
    if (m_MatchThreadData)
    {
        if ((Status = g_EventTarget->
             GetThreadInfoDataOffset(g_EventThread, 0, &ThreadData)) != S_OK)
        {
            ErrOut("Unable to determine current thread data, %s\n",
                   FormatStatusCode(Status));
            return TRUE;
        }
    }
    if (m_MatchProcessData)
    {
        if ((Status = g_EventTarget->
             GetProcessInfoDataOffset(g_EventThread, 0, 0, &ProcData)) != S_OK)
        {
            ErrOut("Unable to determine current process data, %s\n",
                   FormatStatusCode(Status));
            return TRUE;
        }
    }

    return
        (m_MatchThread == NULL ||
         m_MatchThread == g_EventThread) &&
        m_MatchThreadData == ThreadData &&
        m_MatchProcessData == ProcData;
}

//----------------------------------------------------------------------------
//
// CodeBreakpoint.
//
//----------------------------------------------------------------------------

HRESULT
CodeBreakpoint::Validate(void)
{
    // No easy way to check for validity of offset.
    return S_OK;
}

HRESULT
CodeBreakpoint::Insert(void)
{
    if (m_Flags & BREAKPOINT_INSERTED)
    {
        // Nothing to insert.  This can happen in cases where
        // the breakpoint remove failed.
        return S_OK;
    }

    if (!m_Process)
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;

    DBG_ASSERT((m_Flags & (DEBUG_BREAKPOINT_DEFERRED |
                           BREAKPOINT_KD_INTERNAL)) == 0);

    // Force recomputation of flat address.
    NotFlat(m_Addr);
    ComputeFlatAddress(&m_Addr, NULL);

    Status = m_Process->m_Target->
        InsertCodeBreakpoint(m_Process,
                             m_Process->m_Target->
                             m_Machines[m_ProcIndex],
                             &m_Addr,
                             m_CodeFlags,
                             m_InsertStorage);
    if (Status == S_OK)
    {
        BpOut("  inserted bp %u at %s\n",
              m_Id, FormatAddr64(Flat(m_Addr)));

        m_Flags |= BREAKPOINT_INSERTED;
        return S_OK;
    }
    else
    {
        ErrOut("Unable to insert breakpoint %u at %s, %s\n    \"%s\"\n",
               m_Id, FormatAddr64(Flat(m_Addr)),
               FormatStatusCode(Status), FormatStatus(Status));
        return Status;
    }
}

HRESULT
CodeBreakpoint::Remove(void)
{
    if ((m_Flags & BREAKPOINT_INSERTED) == 0)
    {
        // Nothing to remove.  This can happen in cases where
        // the breakpoint insertion failed.
        return S_OK;
    }

    if (!m_Process)
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;

    DBG_ASSERT((m_Flags & (DEBUG_BREAKPOINT_DEFERRED |
                           BREAKPOINT_KD_INTERNAL)) == 0);

    // Force recomputation of flat address.
    NotFlat(m_Addr);
    ComputeFlatAddress(&m_Addr, NULL);

    Status = m_Process->m_Target->
        RemoveCodeBreakpoint(m_Process,
                             m_Process->m_Target->
                             m_Machines[m_ProcIndex],
                             &m_Addr,
                             m_CodeFlags,
                             m_InsertStorage);
    if (Status == S_OK)
    {
        BpOut("  removed bp %u from %s\n",
              m_Id, FormatAddr64(Flat(m_Addr)));

        m_Flags &= ~BREAKPOINT_INSERTED;
        return S_OK;
    }
    else
    {
        ErrOut("Unable to remove breakpoint %u at %s, %s\n    \"%s\"\n",
               m_Id, FormatAddr64(Flat(m_Addr)),
               FormatStatusCode(Status), FormatStatus(Status));
        return Status;
    }
}

ULONG
CodeBreakpoint::IsHit(PADDR Addr)
{
    // Code breakpoints are code modifications and
    // therefore aren't restricted to a particular
    // thread.
    // If this breakpoint can only match hits on
    // a particular thread this is a partial hit
    // because the exception occurred but it's
    // being ignored.
    if (AddrEqu(m_Addr, *Addr))
    {
        if (MatchesCurrentState())
        {
            return BREAKPOINT_HIT;
        }
        else
        {
            return BREAKPOINT_HIT_IGNORED;
        }
    }
    else
    {
        return BREAKPOINT_NOT_HIT;
    }
}

//----------------------------------------------------------------------------
//
// DataBreakpoint.
//
//----------------------------------------------------------------------------

HRESULT
DataBreakpoint::Insert(void)
{
    HRESULT Status;
    ThreadInfo* Thread;

    DBG_ASSERT((m_Flags & (BREAKPOINT_INSERTED |
                           DEBUG_BREAKPOINT_DEFERRED)) == 0);

    // Force recomputation of flat address for non-I/O breakpoints.
    if (m_Flags & BREAKPOINT_VIRT_ADDR)
    {
        NotFlat(m_Addr);
        ComputeFlatAddress(&m_Addr, NULL);
    }

    Status = m_Process->m_Target->
        InsertDataBreakpoint(m_Process,
                             m_MatchThread,
                             m_Process->m_Target->
                             m_Machines[m_ProcIndex],
                             &m_Addr,
                             m_DataSize,
                             m_DataAccessType,
                             m_InsertStorage);
    // If the target returns S_FALSE it wants
    // the generic insertion processing to occur.
    if (Status == S_OK)
    {
        BpOut("  service inserted dbp %u at %s\n",
              m_Id, FormatAddr64(Flat(m_Addr)));

        m_Flags |= BREAKPOINT_INSERTED;
        return Status;
    }
    else if (Status != S_FALSE)
    {
        ErrOut("Unable to insert breakpoint %u at %s, %s\n    \"%s\"\n",
               m_Id, FormatAddr64(Flat(m_Addr)),
               FormatStatusCode(Status), FormatStatus(Status));
        return Status;
    }

    // If this breakpoint is restricted to a thread
    // only modify that thread's state.  Otherwise
    // update all threads in the process.
    Thread = m_Process->m_ThreadHead;
    while (Thread)
    {
        if (Thread->m_NumDataBreaks >=
            m_Process->m_Target->m_Machine->m_MaxDataBreakpoints)
        {
            ErrOut("Too many data breakpoints for %s %d\n",
                   IS_KERNEL_TARGET(m_Process->m_Target) ?
                   "processor" : "thread", Thread->m_UserId);
            return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        }
        else if (m_MatchThread == NULL || m_MatchThread == Thread)
        {
            BpOut("Add %s data bp %u to thread %u\n",
                  m_Process->m_Target->m_Machines[m_ProcIndex]->m_AbbrevName,
                  m_Id, Thread->m_UserId);

            AddToThread(Thread);
        }

        Thread = Thread->m_Next;
    }

    g_UpdateDataBreakpoints = TRUE;
    m_Flags |= BREAKPOINT_INSERTED;

    return S_OK;
}

HRESULT
DataBreakpoint::Remove(void)
{
    HRESULT Status;

    if ((m_Flags & BREAKPOINT_INSERTED) == 0)
    {
        // Nothing to remove.  This can happen in cases where
        // the breakpoint insertion failed.
        return S_OK;
    }

    DBG_ASSERT((m_Flags & DEBUG_BREAKPOINT_DEFERRED) == 0);

    Status = m_Process->m_Target->
        RemoveDataBreakpoint(m_Process,
                             m_MatchThread,
                             m_Process->m_Target->
                             m_Machines[m_ProcIndex],
                             &m_Addr,
                             m_DataSize,
                             m_DataAccessType,
                             m_InsertStorage);
    // If the target returns S_FALSE it wants
    // the generic removal processing to occur.
    if (Status == S_OK)
    {
        BpOut("  service removed dbp %u at %s\n",
              m_Id, FormatAddr64(Flat(m_Addr)));

        m_Flags &= ~BREAKPOINT_INSERTED;
        return Status;
    }
    else if (Status != S_FALSE)
    {
        ErrOut("Unable to remove breakpoint %u at %s, %s\n    \"%s\"\n",
               m_Id, FormatAddr64(Flat(m_Addr)),
               FormatStatusCode(Status), FormatStatus(Status));
        return Status;
    }

    // When breakpoints are inserted the data breakpoint state
    // is always started completely empty so no special
    // work needs to be done when removing.
    g_UpdateDataBreakpoints = TRUE;
    m_Flags &= ~BREAKPOINT_INSERTED;
    return S_OK;
}

void
DataBreakpoint::ClearThreadDataBreaks(ThreadInfo* Thread)
{
    Thread->m_NumDataBreaks = 0;
    memset(Thread->m_DataBreakBps, 0, sizeof(Thread->m_DataBreakBps));
}

void
DataBreakpoint::AddToThread(ThreadInfo* Thread)
{
    DBG_ASSERT(Thread->m_NumDataBreaks <
               Thread->m_Process->m_Target->m_Machine->m_MaxDataBreakpoints);

    Thread->m_DataBreakBps[Thread->m_NumDataBreaks] = this;
    Thread->m_NumDataBreaks++;
}

//----------------------------------------------------------------------------
//
// X86DataBreakpoint.
//
//----------------------------------------------------------------------------

HRESULT
X86DataBreakpoint::Validate(void)
{
    ULONG Dr7Bits;
    ULONG Align;

    if (!IsPow2(m_DataSize) || m_DataSize == 0 ||
        (m_ProcType == IMAGE_FILE_MACHINE_AMD64 && m_DataSize > 8) ||
        (m_ProcType != IMAGE_FILE_MACHINE_AMD64 && m_DataSize > 4))
    {
        ErrOut("Unsupported data breakpoint size\n");
        return E_INVALIDARG;
    }

    Align = (ULONG)(Flat(m_Addr) & (m_DataSize - 1));
    if (Align != 0)
    {
        ErrOut("Data breakpoint must be aligned\n");
        return E_INVALIDARG;
    }

    if (m_DataSize < 8)
    {
        Dr7Bits = (m_DataSize - 1) << X86_DR7_LEN0_SHIFT;
    }
    else
    {
        Dr7Bits = 2 << X86_DR7_LEN0_SHIFT;
    }

    switch(m_DataAccessType)
    {
    case DEBUG_BREAK_EXECUTE:
        Dr7Bits |= X86_DR7_RW0_EXECUTE;
        // Code execution breakpoints must have a
        // size of one.
        // They must also be at the beginning
        // of an instruction.  This could be checked via
        // examining the instructions but it doesn't seem
        // that worth the trouble.
        if (m_DataSize > 1)
        {
            ErrOut("Execution data breakpoint too large\n");
            return E_INVALIDARG;
        }
        break;
    case DEBUG_BREAK_WRITE:
        Dr7Bits |= X86_DR7_RW0_WRITE;
        break;
    case DEBUG_BREAK_IO:
        if (IS_USER_TARGET(m_Process->m_Target) ||
            !(m_Process->m_Target->m_Machines[m_ProcIndex]->
              GetReg32(m_Cr4Reg) & X86_CR4_DEBUG_EXTENSIONS))
        {
            ErrOut("I/O breakpoints not enabled\n");
            return E_INVALIDARG;
        }
        if (Flat(m_Addr) > 0xffff)
        {
            ErrOut("I/O breakpoint port too large\n");
            return E_INVALIDARG;
        }

        Dr7Bits |= X86_DR7_RW0_IO;
        break;
    case DEBUG_BREAK_READ:
    case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
        // There is no pure read-only option so
        // lump it in with read-write.
        Dr7Bits |= X86_DR7_RW0_READ_WRITE;
        break;
    default:
        ErrOut("Unsupported data breakpoint access type\n");
        return E_INVALIDARG;
    }

    m_Dr7Bits = Dr7Bits | X86_DR7_L0_ENABLE;
    if (m_DataAccessType == DEBUG_BREAK_IO)
    {
        m_Flags &= ~BREAKPOINT_VIRT_ADDR;
    }
    else
    {
        m_Flags |= BREAKPOINT_VIRT_ADDR;
    }

    return S_OK;
}

ULONG
X86DataBreakpoint::IsHit(PADDR Addr)
{
    ULONG i;
    ThreadInfo* Thread = g_EventThread;
    HRESULT Status;

    // Data breakpoints are only inserted in the contexts
    // of matching threads so if the event thread doesn't match
    // the breakpoint can't be hit.
    if (m_MatchThread && m_MatchThread != Thread)
    {
        return BREAKPOINT_NOT_HIT;
    }

    Status = m_Process->m_Target->
        IsDataBreakpointHit(Thread, &m_Addr,
                            m_DataSize, m_DataAccessType,
                            m_InsertStorage);
    // If the target returns S_FALSE it wants
    // the generic processing to occur.
    if (Status == S_OK)
    {
        if (MatchesCurrentState())
        {
            return BREAKPOINT_HIT;
        }
        else
        {
            return BREAKPOINT_HIT_IGNORED;
        }
    }
    else if (Status != S_FALSE)
    {
        return BREAKPOINT_NOT_HIT;
    }

    // Locate this breakpoint in the thread's data breakpoints
    // if possible.
    for (i = 0; i < Thread->m_NumDataBreaks; i++)
    {
        // Check for match in addition to equality to handle
        // multiple identical data breakpoints.
        if (Thread->m_DataBreakBps[i] == this ||
            IsInsertionMatch(Thread->m_DataBreakBps[i]))
        {
            // Is this breakpoint's index set in the debug status register?
            // Address is not meaningful so this is the only way to check.
            if ((m_Process->m_Target->m_Machines[m_ProcIndex]->
                 GetReg32(m_Dr6Reg) >> i) & 1)
            {
                if (MatchesCurrentState())
                {
                    return BREAKPOINT_HIT;
                }
                else
                {
                    return BREAKPOINT_HIT_IGNORED;
                }
            }
            else
            {
                // Breakpoint can't be listed in more than one slot
                // so there's no need to finish the loop.
                return BREAKPOINT_NOT_HIT;
            }
        }
    }

    return BREAKPOINT_NOT_HIT;
}

//----------------------------------------------------------------------------
//
// Ia64DataBreakpoint.
//
//----------------------------------------------------------------------------

HRESULT
Ia64DataBreakpoint::Validate(void)
{
    if (!IsPow2(m_DataSize))
    {
        ErrOut("Hardware breakpoint size must be power of 2\n");
        return E_INVALIDARG;
    }

    if (Flat(m_Addr) & (m_DataSize - 1))
    {
        ErrOut("Hardware breakpoint must be size aligned\n");
        return E_INVALIDARG;
    }

    switch (m_DataAccessType)
    {
    case DEBUG_BREAK_WRITE:
    case DEBUG_BREAK_READ:
    case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
        break;
    case DEBUG_BREAK_EXECUTE:
        if (m_DataSize & 0xf)
        {
            if (m_DataSize > 0xf)
            {
                ErrOut("Execution breakpoint size must be bundle aligned.\n");
                return E_INVALIDARG;
            }
            else
            {
                WarnOut("Execution breakpoint size extended to bundle size "
                          "(16 bytes).\n");
                m_DataSize = 0x10;
            }
        }
        break;
    default:
        ErrOut("Unsupported data breakpoint access type\n");
        return E_INVALIDARG;
    }

    m_Control = GetControl(m_DataAccessType, m_DataSize);
    m_Flags |= BREAKPOINT_VIRT_ADDR;

    return S_OK;
}

ULONG
Ia64DataBreakpoint::IsHit(PADDR Addr)
{
    HRESULT Status;
    ULONG i;
    ThreadInfo* Thread = g_EventThread;

    // Data breakpoints are only inserted in the contexts
    // of matching threads so if the event thread doesn't match
    // the breakpoint can't be hit.
    if (m_MatchThread && m_MatchThread != Thread)
    {
        return BREAKPOINT_NOT_HIT;
    }

    Status = m_Process->m_Target->
        IsDataBreakpointHit(Thread, &m_Addr,
                            m_DataSize, m_DataAccessType,
                            m_InsertStorage);
    // If the target returns S_FALSE it wants
    // the generic processing to occur.
    if (Status == S_OK)
    {
        if (MatchesCurrentState())
        {
            return BREAKPOINT_HIT;
        }
        else
        {
            return BREAKPOINT_HIT_IGNORED;
        }
    }
    else if (Status != S_FALSE)
    {
        return BREAKPOINT_NOT_HIT;
    }

    // Locate this breakpoint in the thread's data breakpoints
    // if possible.
    for (i = 0; i < Thread->m_NumDataBreaks; i++)
    {
        // Check for match in addition to equality to handle
        // multiple identical data breakpoints.
        if (Thread->m_DataBreakBps[i] == this ||
            IsInsertionMatch(Thread->m_DataBreakBps[i]))
        {
            if ((Flat(*Thread->m_DataBreakBps[i]->GetAddr()) ^
                 Flat(*Addr)) &
                (m_Control & IA64_DBG_MASK_MASK))
            {
                // Breakpoint can't be listed in more than one slot
                // so there's no need to finish the loop.
                return BREAKPOINT_NOT_HIT;
            }
            else
            {
                if (MatchesCurrentState())
                {
                    return BREAKPOINT_HIT;
                }
                else
                {
                    return BREAKPOINT_HIT_IGNORED;
                }
            }
        }
    }

    return BREAKPOINT_NOT_HIT;
}

ULONG64
Ia64DataBreakpoint::GetControl(ULONG AccessType, ULONG Size)
{
    ULONG64 Control = (ULONG64(IA64_DBG_REG_PLM_ALL) |
                       ULONG64(IA64_DBG_MASK_MASK)) &
                      ~ULONG64(Size - 1);

    switch (AccessType)
    {
    case DEBUG_BREAK_WRITE:
        Control |= IA64_DBR_WR;
        break;
    case DEBUG_BREAK_READ:
        Control |= IA64_DBR_RD;
        break;
    case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
        Control |= IA64_DBR_RDWR;
        break;
    case DEBUG_BREAK_EXECUTE:
        Control |= IA64_DBR_EXEC;
        break;
    }

    return Control;
}

//----------------------------------------------------------------------------
//
// X86OnIa64DataBreakpoint.
//
//----------------------------------------------------------------------------

X86OnIa64DataBreakpoint::X86OnIa64DataBreakpoint(DebugClient* Adder, ULONG Id)
    : X86DataBreakpoint(Adder, Id, X86_CR4, X86_DR6, IMAGE_FILE_MACHINE_I386)
{
    m_Control = 0;
}

HRESULT
X86OnIa64DataBreakpoint::Validate(void)
{
    HRESULT Status = X86DataBreakpoint::Validate();
    if (Status != S_OK)
    {
        return Status;
    }

    switch (m_DataAccessType)
    {
    case DEBUG_BREAK_WRITE:
    case DEBUG_BREAK_READ:
    case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
    case DEBUG_BREAK_EXECUTE:
        break;
    default:
        ErrOut("Unsupported data breakpoint access type\n");
        return E_INVALIDARG;
    }

    m_Control = Ia64DataBreakpoint::GetControl(m_DataAccessType, m_DataSize);

    return S_OK;
}


// XXX olegk -This is pure hack
// (see X86OnIa64MachineInfo::IsBreakpointOrStepException implementation
// for more info)

ULONG
X86OnIa64DataBreakpoint::IsHit(PADDR Addr)
{
    HRESULT Status;
    ULONG i;
    ThreadInfo* Thread = g_EventThread;

    // Data breakpoints are only inserted in the contexts
    // of matching threads so if the event thread doesn't match
    // the breakpoint can't be hit.
    if (m_MatchThread && m_MatchThread != Thread)
    {
        return BREAKPOINT_NOT_HIT;
    }

    Status = m_Process->m_Target->
        IsDataBreakpointHit(Thread, &m_Addr,
                            m_DataSize, m_DataAccessType,
                            m_InsertStorage);
    // If the target returns S_FALSE it wants
    // the generic processing to occur.
    if (Status == S_OK)
    {
        if (MatchesCurrentState())
        {
            return BREAKPOINT_HIT;
        }
        else
        {
            return BREAKPOINT_HIT_IGNORED;
        }
    }
    else if (Status != S_FALSE)
    {
        return BREAKPOINT_NOT_HIT;
    }

    // Locate this breakpoint in the thread's data breakpoints
    // if possible.
    for (i = 0; i < Thread->m_NumDataBreaks; i++)
    {
        // Check for match in addition to equality to handle
        // multiple identical data breakpoints.
        if (Thread->m_DataBreakBps[i] == this ||
            IsInsertionMatch(Thread->m_DataBreakBps[i]))
        {
            if (((ULONG)Flat(*Thread->m_DataBreakBps[i]->GetAddr()) ^
                 (ULONG)Flat(*Addr)) &
                (ULONG)(m_Control & IA64_DBG_MASK_MASK))
            {
                // Breakpoint can't be listed in more than one slot
                // so there's no need to finish the loop.
                return BREAKPOINT_NOT_HIT;
            }
            else
            {
                if (MatchesCurrentState())
                {
                    return BREAKPOINT_HIT;
                }
                else
                {
                    return BREAKPOINT_HIT_IGNORED;
                }
            }
        }
    }

    return BREAKPOINT_NOT_HIT;
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

BOOL
BreakpointNeedsToBeDeferred(Breakpoint* Bp,
                            ProcessInfo* Process, PADDR PcAddr)
{
    if (Process && IS_CONTEXT_POSSIBLE(Process->m_Target) &&
        (Bp->m_Process == Process))
    {
        // If this breakpoint matches the current IP and
        // the current thread is going to be running
        // we can't insert the breakpoint as the thread
        // needs to run the real code.
        if ((Bp->m_Flags & BREAKPOINT_VIRT_ADDR) &&
            AddrEqu(*Bp->GetAddr(), *PcAddr) &&
            ThreadWillResume(g_EventThread))
        {
            return TRUE;
        }

        if ((Bp == g_LastBreakpointHit) && Bp->PcAtHit() &&
            AddrEqu(g_LastBreakpointHitPc, *PcAddr))
        {
            if (g_ContextChanged)
            {
                WarnOut("Breakpoint %u will not be deferred because of "
                        "changes in the context. Breakpoint may hit again.\n",
                        Bp->m_Id);
                return FALSE;
            }
            return TRUE;
        }
    }
    return FALSE;
}

//----------------------------------------------------------------------------
//
// Modify debuggee to activate current breakpoints.
//
//----------------------------------------------------------------------------

HRESULT
InsertBreakpoints(void)
{
    HRESULT Status = S_OK;
    ADDR PcAddr;
    BOOL DeferredData = FALSE;
    ThreadInfo* OldThread;

    if (g_Thread != NULL)
    {
        // Aggressively clear this flag always in order to be
        // as conservative as possible when recognizing
        // trace events.  We would rather misrecognize
        // single-step events and break in instead of
        // misrecognizing an app-generated single-step and
        // ignoring it.
        g_Thread->m_Flags &= ~ENG_THREAD_DEFER_BP_TRACE;
    }

    if ((g_EngStatus & ENG_STATUS_BREAKPOINTS_INSERTED) ||
        (g_EngStatus & ENG_STATUS_SUSPENDED) == 0)
    {
        return Status;
    }

    g_DeferDefined = FALSE;
    ADDRFLAT(&PcAddr, 0);

    // Switch to the event thread to get the event thread's
    // PC so we can see if we need to defer breakpoints in
    // order to allow the event thread to keep running.
    if (g_EventTarget)
    {
        OldThread = g_EventTarget->m_RegContextThread;
        g_EventTarget->ChangeRegContext(g_EventThread);
    }

    if (g_BreakpointsSuspended)
    {
        goto StepTraceOnly;
    }

    //
    // Turn off all data breakpoints.  (We will turn the enabled ones back
    // on when we restart execution).
    //

    TargetInfo* Target;

    // Allow target to prepare for breakpoint insertion.
    ForAllLayersToTarget()
    {
        if ((Status = Target->BeginInsertingBreakpoints()) != S_OK)
        {
            return Status;
        }
    }

    if (IS_CONTEXT_POSSIBLE(g_EventTarget))
    {
        g_EventTarget->m_EffMachine->GetPC(&PcAddr);
    }

    BpOut("InsertBreakpoints PC ");
    if (IS_CONTEXT_POSSIBLE(g_EventTarget))
    {
        MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT, &PcAddr);
        BpOut("\n");
    }
    else
    {
        BpOut("?\n");
    }

    //
    // Set any appropriate permanent breakpoints.
    //

    Breakpoint* Bp;
    ProcessInfo* Process;

    ForAllLayersToProcess()
    {
        BpOut("  Process %d with %d bps\n", Process->m_UserId,
              Process->m_NumBreakpoints);

        for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
        {
            if (Bp->IsNormalEnabled() &&
                (g_CmdState == 'g' ||
                 (Bp->m_Flags & DEBUG_BREAKPOINT_GO_ONLY) == 0))
            {
                Bp->ForceFlatAddr();

                // Check if this breakpoint matches a previously
                // inserted breakpoint.  If so there's no need
                // to insert this one.
                Breakpoint* MatchBp;

                for (MatchBp = Bp->m_Prev;
                     MatchBp != NULL;
                     MatchBp = MatchBp->m_Prev)
                {
                    if ((MatchBp->m_Flags & BREAKPOINT_INSERTED) &&
                        Bp->IsInsertionMatch(MatchBp))
                    {
                        break;
                    }
                }
                if (MatchBp != NULL)
                {
                    // Skip this breakpoint.  It won't be marked as
                    // inserted so Remove is automatically handled.
                    continue;
                }

                if (BreakpointNeedsToBeDeferred(Bp,
                                                g_EventProcess, &PcAddr))
                {
                    g_DeferDefined = TRUE;
                    if (Bp->m_BreakType == DEBUG_BREAKPOINT_DATA)
                    {
                        DeferredData = TRUE;
                        // Force data breakpoint addresses to
                        // get updated because a dbp will now
                        // be missing.
                        g_DataBreakpointsChanged = TRUE;
                    }
                    BpOut("    deferred bp %u, dd %d\n",
                          Bp->m_Id, DeferredData);
                }
                else
                {
                    HRESULT InsertStatus;

                    InsertStatus = Bp->Insert();
                    if (InsertStatus != S_OK)
                    {
                        if (Bp->m_Flags & DEBUG_BREAKPOINT_GO_ONLY)
                        {
                            ErrOut("go ");
                        }
                        ErrOut("bp%u at ", Bp->m_Id);
                        MaskOutAddr(DEBUG_OUTPUT_ERROR, Bp->GetAddr());
                        ErrOut("failed\n");

                        Status = InsertStatus;
                    }
                }
            }
        }
    }

    ForAllLayersToTarget()
    {
        Target->EndInsertingBreakpoints();
    }

    // If we deferred a data breakpoint we haven't
    // fully updated the data breakpoint state
    // so leave the update flags set.
    if (g_UpdateDataBreakpoints && !DeferredData)
    {
        g_UpdateDataBreakpoints = FALSE;
        g_DataBreakpointsChanged = FALSE;
    }
    BpOut("  after insert udb %d, dbc %d\n",
          g_UpdateDataBreakpoints, g_DataBreakpointsChanged);

 StepTraceOnly:

    //  set the step/trace breakpoint if appropriate

    if (g_StepTraceBp->m_Flags & DEBUG_BREAKPOINT_ENABLED)
    {
        BpOut("Step/trace addr = ");
        MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT, g_StepTraceBp->GetAddr());
        BpOut("\n");

        if (Flat(*g_StepTraceBp->GetAddr()) == OFFSET_TRACE)
        {
            ThreadInfo* StepRegThread;

            Target = g_StepTraceBp->m_Process->m_Target;

            if (g_StepTraceBp->m_MatchThread &&
                IS_USER_TARGET(Target))
            {
                StepRegThread = Target->m_RegContextThread;
                Target->ChangeRegContext(g_StepTraceBp->m_MatchThread);
            }

            BpOut("Setting trace flag for step/trace thread %d:%x\n",
                  Target->m_RegContextThread ?
                  Target->m_RegContextThread->m_UserId : 0,
                  Target->m_RegContextThread ?
                  Target->m_RegContextThread->m_SystemId : 0);
            Target->m_EffMachine->
                QuietSetTraceMode(g_StepTraceCmdState == 'b' ?
                                  TRACE_TAKEN_BRANCH :
                                  TRACE_INSTRUCTION);

            if (g_StepTraceBp->m_MatchThread &&
                IS_USER_TARGET(Target))
            {
                Target->ChangeRegContext(StepRegThread);
            }
        }
        else if (IS_CONTEXT_POSSIBLE(g_EventTarget) &&
                 AddrEqu(*g_StepTraceBp->GetAddr(), PcAddr))
        {
            BpOut("Setting defer flag for step/trace\n");

            g_DeferDefined = TRUE;
        }
        else if (CheckMatchingBreakpoints(g_StepTraceBp, FALSE,
                                          BREAKPOINT_INSERTED))
        {
            // There's already a breakpoint inserted at the
            // step/trace address so we don't need to set another.
            BpOut("Trace bp matches existing bp\n");
        }
        else
        {
            if (g_StepTraceBp->Insert() != S_OK)
            {
                ErrOut("Trace bp at addr ");
                MaskOutAddr(DEBUG_OUTPUT_ERROR, g_StepTraceBp->GetAddr());
                ErrOut("failed\n");

                Status = E_FAIL;
            }
            else
            {
                BpOut("Trace bp at addr ");
                MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT,
                            g_StepTraceBp->GetAddr());
                BpOut("succeeded\n");
            }
        }
    }

    // Process deferred breakpoint.
    // If a deferred breakpoint is active it means that
    // the debugger needs to do some work on the current instruction
    // so it wants to step forward one instruction and then
    // get control back.  The deferred breakpoint forces a break
    // back to the debugger as soon as possible so that it
    // can carry out any deferred work.

    if (g_DeferDefined)
    {
        ULONG NextMachine;

        g_DeferBp->m_Process = g_EventProcess;
        g_EventTarget->m_EffMachine->
            GetNextOffset(g_EventProcess, FALSE,
                          g_DeferBp->GetAddr(), &NextMachine);
        g_DeferBp->SetProcType(NextMachine);

        BpOut("Defer addr = ");
        MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT, g_DeferBp->GetAddr());
        BpOut("\n");

        if ((g_EngOptions & DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS) &&
            IS_USER_TARGET(g_Target) &&
            !IsSelectedExecutionThread(NULL, SELTHREAD_ANY))
        {
            // The user wants breakpoint management to occur
            // precisely in order to properly handle breakpoints
            // in code executed by multiple threads.  Force
            // the defer thread to be the only thread executing
            // in order to avoid other threads running through
            // the breakpoint location or generating events.
            SelectExecutionThread(g_EventThread, SELTHREAD_INTERNAL_THREAD);
        }

        if (Flat(*g_DeferBp->GetAddr()) == OFFSET_TRACE)
        {
            BpOut("Setting trace flag for defer thread %d:%x\n",
                  g_EventTarget->m_RegContextThread ?
                  g_EventTarget->m_RegContextThread->m_UserId : 0,
                  g_EventTarget->m_RegContextThread ?
                  g_EventTarget->m_RegContextThread->m_SystemId : 0);
            g_EventTarget->m_EffMachine->
                QuietSetTraceMode(TRACE_INSTRUCTION);

            if (IS_USER_TARGET(g_EventTarget) &&
                g_EventThread != NULL)
            {
                // If the debugger is setting the trace flag
                // for the current thread remember that it
                // did so in order to properly recognize
                // debugger-provoked single-step events even
                // when events occur on other threads before
                // the single-step event comes back.
                g_EventThread->m_Flags |=
                    ENG_THREAD_DEFER_BP_TRACE;
            }
        }
        else
        {
            // If an existing breakpoint or the step/trace breakpoint
            // isn't already set on the next offset, insert the deferred
            // breakpoint.
            if (CheckMatchingBreakpoints(g_DeferBp, FALSE,
                                         BREAKPOINT_INSERTED) == NULL &&
                ((g_StepTraceBp->m_Flags & BREAKPOINT_INSERTED) == 0 ||
                 !AddrEqu(*g_StepTraceBp->GetAddr(), *g_DeferBp->GetAddr())))
            {
                if (g_DeferBp->Insert() != S_OK)
                {
                    ErrOut("Deferred bp at addr ");
                    MaskOutAddr(DEBUG_OUTPUT_ERROR, g_DeferBp->GetAddr());
                    ErrOut("failed\n");

                    Status = E_FAIL;
                }
                else
                {
                    BpOut("Deferred bp at addr ");
                    MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT,
                                g_DeferBp->GetAddr());
                    BpOut("succeeded\n");
                }
            }
            else
            {
                BpOut("Defer bp matches existing bp\n");
            }
        }
    }

    if (g_EventTarget)
    {
        g_EventTarget->ChangeRegContext(OldThread);
    }

    // Always consider breakpoints inserted since some
    // of them may have been inserted even if some failed.
    g_EngStatus |= ENG_STATUS_BREAKPOINTS_INSERTED;

    return Status;
}

//----------------------------------------------------------------------------
//
// Reverse any debuggee changes caused by breakpoint insertion.
//
//----------------------------------------------------------------------------

HRESULT
RemoveBreakpoints(void)
{
    if ((g_EngStatus & ENG_STATUS_BREAKPOINTS_INSERTED) == 0 ||
        (g_EngStatus & ENG_STATUS_SUSPENDED) == 0)
    {
        return S_FALSE; // do nothing
    }

    BpOut("RemoveBreakpoints\n");

    //  restore the deferred breakpoint if set
    g_DeferBp->Remove();

    //  restore the step/trace breakpoint if set
    g_StepTraceBp->Remove();

    if (!g_BreakpointsSuspended)
    {
        //
        // Restore any appropriate permanent breakpoints (reverse order).
        //

        TargetInfo* Target;
        ProcessInfo* Process;
        Breakpoint* Bp;

        ForAllLayersToTarget()
        {
            Target->BeginRemovingBreakpoints();
        }

        ForAllLayersToProcess()
        {
            BpOut("  Process %d with %d bps\n", Process->m_UserId,
                  Process->m_NumBreakpoints);

            for (Bp = Process->m_BreakpointsTail;
                 Bp != NULL;
                 Bp = Bp->m_Prev)
            {
                Bp->Remove();
            }
        }

        ForAllLayersToTarget()
        {
            Target->EndRemovingBreakpoints();
        }
    }

    g_EngStatus &= ~ENG_STATUS_BREAKPOINTS_INSERTED;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// Create a new breakpoint object.
//
//----------------------------------------------------------------------------

HRESULT
AddBreakpoint(DebugClient* Client,
              MachineInfo* Machine,
              ULONG Type,
              ULONG DesiredId,
              Breakpoint** RetBp)
{
    Breakpoint* Bp;
    ULONG Id;
    TargetInfo* Target;
    ProcessInfo* Process;

    if (DesiredId == DEBUG_ANY_ID)
    {
        // Find the lowest unused ID across all processes.
        // Breakpoint IDs are kept unique across all
        // breakpoints to prevent user confusion and also
        // to give extensions a unique ID for breakpoints.
        Id = 0;

    Restart:
        // Search all bps to see if the current ID is in use.
        ForAllLayersToProcess()
        {
            for (Bp = Process->m_Breakpoints; Bp; Bp = Bp->m_Next)
            {
                if (Bp->m_Id == Id)
                {
                    // A breakpoint is already using the current ID.
                    // Try the next one.
                    Id++;
                    goto Restart;
                }
            }
        }
    }
    else
    {
        // Check to see if the desired ID is in use.
        ForAllLayersToProcess()
        {
            for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
            {
                if (Bp->m_Id == DesiredId)
                {
                    return E_INVALIDARG;
                }
            }
        }

        Id = DesiredId;
    }

    HRESULT Status = Machine->NewBreakpoint(Client, Type, Id, &Bp);
    if (Status != S_OK)
    {
        return Status;
    }

    *RetBp = Bp;
    Bp->LinkIntoList();

    // If this is an internal, hidden breakpoint set
    // the flag immediately and do not notify.
    if (Type & BREAKPOINT_HIDDEN)
    {
        Bp->m_Flags |= BREAKPOINT_HIDDEN;
    }
    else
    {
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, Id, TRUE);
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// Delete a breakpoint object.
//
//----------------------------------------------------------------------------

void
RemoveBreakpoint(Breakpoint* Bp)
{
    ULONG Id = Bp->m_Id;
    ULONG Flags = Bp->m_Flags;

    Bp->Relinquish();

    if ((Flags & BREAKPOINT_HIDDEN) == 0)
    {
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, Id, TRUE);
    }
}

//----------------------------------------------------------------------------
//
// Clean up breakpoints owned by a particular process or thread.
//
//----------------------------------------------------------------------------

void
RemoveProcessBreakpoints(ProcessInfo* Process)
{
    g_EngNotify++;

    Breakpoint* Bp;
    Breakpoint* NextBp;
    BOOL NeedNotify = FALSE;

    for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = NextBp)
    {
        NextBp = Bp->m_Next;

        DBG_ASSERT(Bp->m_Process == Process);

        RemoveBreakpoint(Bp);
        NeedNotify = TRUE;
    }

    g_EngNotify--;
    if (NeedNotify)
    {
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, DEBUG_ANY_ID, TRUE);
    }
}

void
RemoveThreadBreakpoints(ThreadInfo* Thread)
{
    g_EngNotify++;

    Breakpoint* Bp;
    Breakpoint* NextBp;
    BOOL NeedNotify = FALSE;

    DBG_ASSERT(Thread->m_Process);

    for (Bp = Thread->m_Process->m_Breakpoints; Bp != NULL; Bp = NextBp)
    {
        NextBp = Bp->m_Next;

        DBG_ASSERT(Bp->m_Process == Thread->m_Process);

        if (Bp->m_MatchThread == Thread)
        {
            RemoveBreakpoint(Bp);
            NeedNotify = TRUE;
        }
    }

    g_EngNotify--;
    if (NeedNotify)
    {
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, DEBUG_ANY_ID, TRUE);
    }
}

//----------------------------------------------------------------------------
//
// Remove all breakpoints and reset breakpoint state.
//
//----------------------------------------------------------------------------

void
RemoveAllBreakpoints(ULONG Reason)
{
    TargetInfo* Target;
    ProcessInfo* Process;

    g_EngNotify++;

    ForAllLayersToProcess()
    {
        while (Process->m_Breakpoints != NULL)
        {
            RemoveBreakpoint(Process->m_Breakpoints);
        }
    }

    g_EngNotify--;
    NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, DEBUG_ANY_ID, TRUE);

    g_NumGoBreakpoints = 0;

    // If the machine is not waiting for commands we can't
    // remove breakpoints.  This happens when rebooting or
    // when a wait doesn't successfully receive a state change.
    if (Reason != DEBUG_SESSION_REBOOT &&
        Reason != DEBUG_SESSION_HIBERNATE &&
        Reason != DEBUG_SESSION_FAILURE &&
        (g_EngStatus & ENG_STATUS_WAIT_SUCCESSFUL))
    {
        ForAllLayersToTarget()
        {
            Target->RemoveAllTargetBreakpoints();
            ForTargetProcesses(Target)
            {
                Target->RemoveAllDataBreakpoints(Process);
            }
        }
    }

    // Always update data breakpoints the very first time in
    // order to flush out any stale data breakpoints.
    g_UpdateDataBreakpoints = TRUE;

    g_DataBreakpointsChanged = FALSE;
    g_BreakpointsSuspended = FALSE;

    g_DeferDefined = FALSE;
}

//----------------------------------------------------------------------------
//
// Look up breakpoints.
//
//----------------------------------------------------------------------------

Breakpoint*
GetBreakpointByIndex(DebugClient* Client, ULONG Index)
{
    Breakpoint* Bp;

    DBG_ASSERT(g_Process);

    for (Bp = g_Process->m_Breakpoints;
         Bp != NULL && Index > 0;
         Bp = Bp->m_Next)
    {
        Index--;
    }

    if (Bp != NULL &&
        (Bp->m_Flags & BREAKPOINT_HIDDEN) == 0 &&
        ((Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) == 0 ||
         Bp->m_Adder == Client))
    {
        return Bp;
    }

    return NULL;
}

Breakpoint*
GetBreakpointById(DebugClient* Client, ULONG Id)
{
    Breakpoint* Bp;

    DBG_ASSERT(g_Process);

    for (Bp = g_Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
    {
        if (Bp->m_Id == Id)
        {
            if ((Bp->m_Flags & BREAKPOINT_HIDDEN) == 0 &&
                ((Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) == 0 ||
                 Bp->m_Adder == Client))
            {
                return Bp;
            }

            break;
        }
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// Check to see if two breakpoints refer to the same breakpoint
// conditions.
//
//----------------------------------------------------------------------------

Breakpoint*
CheckMatchingBreakpoints(Breakpoint* Match, BOOL Public, ULONG IncFlags)
{
    Breakpoint* Bp;

    for (Bp = Match->m_Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
    {
        if (Bp == Match || (Bp->m_Flags & IncFlags) == 0)
        {
            continue;
        }

        if ((Public && Bp->IsPublicMatch(Match)) ||
            (!Public && Bp->IsInsertionMatch(Match)))
        {
            return Bp;
        }
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// Starting at the given breakpoint, check to see if a breakpoint
// is hit with the current processor state.  Breakpoint types
// can be included or excluded by flags.
//
//----------------------------------------------------------------------------

Breakpoint*
CheckBreakpointHit(ProcessInfo* Process, Breakpoint* Start, PADDR Addr,
                   ULONG ExbsType, ULONG IncFlags, ULONG ExcFlags,
                   PULONG HitType,
                   BOOL SetLastBreakpointHit)
{
    DBG_ASSERT(ExbsType & EXBS_BREAKPOINT_ANY);

    ULONG BreakType;

    switch(ExbsType)
    {
    case EXBS_BREAKPOINT_CODE:
        BreakType = DEBUG_BREAKPOINT_CODE;
        break;
    case EXBS_BREAKPOINT_DATA:
        BreakType = DEBUG_BREAKPOINT_DATA;
        break;
    default:
        ExbsType = EXBS_BREAKPOINT_ANY;
        break;
    }

    Breakpoint* Bp;

    BpOut("CheckBp addr ");
    MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT, Addr);
    BpOut("\n");

    for (Bp = (Start == NULL ? Process->m_Breakpoints : Start);
         Bp != NULL;
         Bp = Bp->m_Next)
    {
        // Allow different kinds of breakpoints to be scanned
        // separately if desired.

        if ((ExbsType != EXBS_BREAKPOINT_ANY &&
             Bp->m_BreakType != BreakType) ||
            (Bp->m_Flags & IncFlags) == 0 ||
            (Bp->m_Flags & ExcFlags) != 0)
        {
            continue;
        }

        // Common code is inlined here rather than in the
        // base class because both pre- and post-derived
        // checks are necessary.

        // Force recomputation of flat address.
        if (Bp->m_Flags & BREAKPOINT_VIRT_ADDR)
        {
            NotFlat(*Bp->GetAddr());
            ComputeFlatAddress(Bp->GetAddr(), NULL);
        }

        if (Bp->IsNormalEnabled())
        {
            // We've got a partial match.  Further checks
            // depend on what kind of breakpoint it is.
            *HitType = Bp->IsHit(Addr);
            if (*HitType != BREAKPOINT_NOT_HIT)
            {
                // Do a final check for the pass count.  If the
                // pass count is nonzero this will become a partial hit.
                if (*HitType == BREAKPOINT_HIT &&
                    !Bp->PassHit())
                {
                    *HitType = BREAKPOINT_HIT_IGNORED;
                }

                BpOut("  hit %u\n", Bp->m_Id);

                if (SetLastBreakpointHit)
                {
                    g_LastBreakpointHit = Bp;
                    g_Target->m_EffMachine->GetPC(&g_LastBreakpointHitPc);
                }

                return Bp;
            }
        }
    }

    BpOut("  no hit\n");

    *HitType = BREAKPOINT_NOT_HIT;

    if (SetLastBreakpointHit)
    {
        g_LastBreakpointHit = NULL;
        ZeroMemory(&g_LastBreakpointHitPc, sizeof(g_LastBreakpointHitPc));
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// Walk the breakpoint list and invoke event callbacks for
// any breakpoints that need it.  Watch for and handle list changes
// caused by callbacks.
//
//----------------------------------------------------------------------------

ULONG
NotifyHitBreakpoints(ULONG EventStatus)
{
    Breakpoint* Bp;
    TargetInfo* Target;
    ProcessInfo* Process;

 Restart:
    g_BreakpointListChanged = FALSE;

    ForAllLayersToProcess()
    {
        for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
        {
            if (Bp->m_Flags & BREAKPOINT_NOTIFY)
            {
                // Ensure the breakpoint isn't cleaned up before
                // we're done with it.
                Bp->Preserve();

                Bp->m_Flags &= ~BREAKPOINT_NOTIFY;
                EventStatus = NotifyBreakpointEvent(EventStatus, Bp);

                if (Bp->m_Flags & DEBUG_BREAKPOINT_ONE_SHOT)
                {
                    RemoveBreakpoint(Bp);
                }

                Bp->Relinquish();

                // If the callback caused the breakpoint list to
                // change we can no longer rely on the pointer
                // we have and we need to restart the iteration.
                if (g_BreakpointListChanged)
                {
                    goto Restart;
                }
            }
        }
    }

    return EventStatus;
}

//----------------------------------------------------------------------------
//
// A module load/unload event has occurred so go through every
// breakpoint with an offset expression and reevaluate it.
//
//----------------------------------------------------------------------------

void
EvaluateOffsetExpressions(ProcessInfo* Process, ULONG Flags)
{
    static BOOL s_Evaluating;

    // Don't reevaluate when not notifying because
    // lack of notification usually means that a group
    // of operations is being done and that notify/reevaluate
    // will be done later after all of them are finished.
    // It is also possible to have nested evaluations as
    // evaluation may provoke symbol loads on deferred
    // modules, which leads to a symbol notification and
    // thus another evaluation.  If we're already evaluating
    // there's no need to evaluate again.
    if (g_EngNotify > 0 || s_Evaluating)
    {
        return;
    }
    s_Evaluating = TRUE;

    Breakpoint* Bp;
    BOOL AnyEnabled = FALSE;

    for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
    {
        // Optimize evaluation somewhat.
        // If a module is added then deferred breakpoints
        // can become active.  If a module is removed then
        // active breakpoints can become deferred.
        // XXX drewb - This doesn't hold up with general
        // conditional expressions but currently the
        // only thing that is officially supported is a simple symbol.
        if (Bp->m_OffsetExpr != NULL &&
            (((Flags & DEBUG_CSS_LOADS) &&
              (Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED)) ||
             ((Flags & DEBUG_CSS_UNLOADS) &&
              (Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED) == 0)))
        {
            ADDR Addr;

            if (Bp->EvalOffsetExpr(BPEVAL_UNKNOWN, &Addr) &&
                (Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED) == 0)
            {
                // No need to update on newly disabled breakpoints
                // as the module is being unloaded so they'll
                // go away anyway.  The disabled breakpoint
                // is simply marked not-inserted in EvalOffsetExpr.
                AnyEnabled = TRUE;
            }
        }

        if (PollUserInterrupt(TRUE))
        {
            // Leave the interrupt set as this may be
            // called in the middle of a symbol operation
            // and we want the interrupt to interrupt
            // the entire symbol operation.
            break;
        }
    }

    if (AnyEnabled)
    {
        // A deferred breakpoint has become enabled.
        // Force a refresh of the breakpoints so
        // that the newly enabled breakpoints get inserted.
        SuspendExecution();
        RemoveBreakpoints();
    }

    s_Evaluating = FALSE;
}

//----------------------------------------------------------------------------
//
// Alters breakpoint state for b[cde]<idlist>.
//
//----------------------------------------------------------------------------

void
ChangeBreakpointState(DebugClient* Client, ProcessInfo* ForProcess,
                      ULONG Id, UCHAR StateChange)
{
    Breakpoint* Bp;
    Breakpoint* NextBp;
    TargetInfo* Target;
    ProcessInfo* Process;

    ForAllLayersToProcess()
    {
        if (ForProcess != NULL && Process != ForProcess)
        {
            continue;
        }

        for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = NextBp)
        {
            // Prefetch the next breakpoint in case we remove
            // the current breakpoint from the list.
            NextBp = Bp->m_Next;

            if ((Id == ALL_ID_LIST || Bp->m_Id == Id) &&
                (Bp->m_Flags & BREAKPOINT_HIDDEN) == 0 &&
                ((Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) == 0 ||
                 Bp->m_Adder == Client))
            {
                if (StateChange == 'c')
                {
                    RemoveBreakpoint(Bp);
                }
                else
                {
                    if (StateChange == 'e')
                    {
                        Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED);
                    }
                    else
                    {
                        Bp->RemoveFlags(DEBUG_BREAKPOINT_ENABLED);
                    }
                }
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Lists current breakpoints for bl.
//
//----------------------------------------------------------------------------

void
ListBreakpoints(DebugClient* Client, ProcessInfo* ForProcess,
                ULONG Id)
{
    StackSaveLayers Save;
    Breakpoint* Bp;
    TargetInfo* Target;
    ProcessInfo* Process;

    ForAllLayersToProcess()
    {
        if (ForProcess != NULL && Process != ForProcess)
        {
            continue;
        }

        SetLayersFromProcess(Process);

        for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
        {
            char StatusChar;

            if ((Bp->m_Flags & BREAKPOINT_HIDDEN) ||
                ((Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) &&
                 Client != Bp->m_Adder) ||
                (Id != ALL_ID_LIST && Bp->m_Id != Id))
            {
                continue;
            }

            if (Bp->m_Flags & DEBUG_BREAKPOINT_ENABLED)
            {
                if (Bp->m_Flags & BREAKPOINT_KD_INTERNAL)
                {
                    StatusChar = (Bp->m_Flags & BREAKPOINT_KD_COUNT_ONLY) ?
                        'i' : 'w';
                }
                else
                {
                    StatusChar = 'e';
                }
            }
            else
            {
                StatusChar = 'd';
            }

            dprintf("%2u %c", Bp->m_Id, StatusChar);

            if (Bp->GetProcType() != g_Target->m_MachineType)
            {
                dprintf("%s ",
                        Bp->m_Process->m_Target->
                        m_Machines[Bp->GetProcIndex()]->m_AbbrevName);
            }

            if ((Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED) == 0)
            {
                dprintf(" ");
                if (Bp->m_BreakType == DEBUG_BREAKPOINT_CODE &&
                    (g_SrcOptions & SRCOPT_STEP_SOURCE))
                {
                    if (!OutputLineAddr(Flat(*Bp->GetAddr()), "[%s @ %d]"))
                    {
                        dprintAddr(Bp->GetAddr());
                    }
                }
                else
                {
                    dprintAddr(Bp->GetAddr());
                }
            }
            else if (g_Target->m_Machine->m_Ptr64)
            {
                dprintf("u                  ");
            }
            else
            {
                dprintf("u         ");
            }

            char OptionChar;

            if (Bp->m_BreakType == DEBUG_BREAKPOINT_DATA)
            {
                switch(Bp->m_DataAccessType)
                {
                case DEBUG_BREAK_EXECUTE:
                    OptionChar = 'e';
                    break;
                case DEBUG_BREAK_WRITE:
                    OptionChar = 'w';
                    break;
                case DEBUG_BREAK_IO:
                    OptionChar = 'i';
                    break;
                case DEBUG_BREAK_READ:
                case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
                    OptionChar = 'r';
                    break;
                default:
                    OptionChar = '?';
                    break;
                }
                dprintf("%c %d", OptionChar, Bp->m_DataSize);
            }
            else
            {
                dprintf("   ");
            }

            if (Bp->m_Flags & DEBUG_BREAKPOINT_ONE_SHOT)
            {
                dprintf("/1 ");
            }

            dprintf(" %04lx (%04lx) ",
                    Bp->m_CurPassCount, Bp->m_PassCount);

            if ((Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED) == 0)
            {
                if (IS_USER_TARGET(Bp->m_Process->m_Target))
                {
                    dprintf("%2ld:", Bp->m_Process->m_UserId);
                    if (Bp->m_MatchThread != NULL)
                    {
                        dprintf("~%03ld ", Bp->m_MatchThread->m_UserId);
                    }
                    else
                    {
                        dprintf("*** ");
                    }
                }

                OutputSymAddr(Flat(*Bp->GetAddr()), SYMADDR_FORCE, NULL);

                if (Bp->m_Command != NULL)
                {
                    dprintf("\"%s\"", Bp->m_Command);
                }
            }
            else
            {
                dprintf(" (%s)", Bp->m_OffsetExpr);
            }

            dprintf("\n");

            if (Bp->m_MatchThreadData || Bp->m_MatchProcessData)
            {
                dprintf("   ");
                if (Bp->m_MatchThreadData)
                {
                    dprintf("  Match thread data %s",
                            FormatAddr64(Bp->m_MatchThreadData));
                }
                if (Bp->m_MatchProcessData)
                {
                    dprintf("  Match process data %s",
                            FormatAddr64(Bp->m_MatchProcessData));
                }
                dprintf("\n");
            }
        }
    }

    if (IS_KERNEL_TARGET(g_Target))
    {
        dprintf("\n");

        ForAllLayersToProcess()
        {
            if (ForProcess != NULL && Process != ForProcess)
            {
                continue;
            }

            SetLayersFromProcess(Process);

            for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
            {
                if (Bp->m_Flags & BREAKPOINT_KD_INTERNAL)
                {
                    ULONG Flags, Calls, MinInst, MaxInst, TotInst, MaxCps;

                    g_Target->QueryTargetCountBreakpoint(Bp->GetAddr(),
                                                         &Flags,
                                                         &Calls,
                                                         &MinInst,
                                                         &MaxInst,
                                                         &TotInst,
                                                         &MaxCps);
                    dprintf("%s %6d %8d %8d %8d %2x %4d",
                            FormatAddr64(Flat(*Bp->GetAddr())),
                            Calls, MinInst, MaxInst,
                            TotInst, Flags, MaxCps);
                    OutputSymAddr(Flat(*Bp->GetAddr()), SYMADDR_FORCE, " ");
                    dprintf("\n");
                }
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Outputs commands necessary to recreate current breakpoints.
//
//----------------------------------------------------------------------------

void
ListBreakpointsAsCommands(DebugClient* Client, ProcessInfo* Process,
                          ULONG Flags)
{
    Breakpoint* Bp;

    if (Process == NULL)
    {
        return;
    }

    for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
    {
        if ((Bp->m_Flags & BREAKPOINT_HIDDEN) ||
            ((Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) &&
             Client != Bp->m_Adder) ||
            ((Flags & BPCMDS_EXPR_ONLY && Bp->m_OffsetExpr == NULL)))
        {
            continue;
        }

        if (IS_USER_TARGET(Bp->m_Process->m_Target))
        {
            if (Bp->m_MatchThread != NULL ||
                Bp->m_MatchThreadData ||
                Bp->m_MatchProcessData)
            {
                // Ignore thread- and data-specific breakpoints
                // as the things they are specific to may
                // not exist in a new session.
                continue;
            }
        }

        if (Bp->GetProcType() != Process->m_Target->m_MachineType)
        {
            dprintf(".effmach %s;%c",
                    Bp->m_Process->m_Target->
                    m_Machines[Bp->GetProcIndex()]->m_AbbrevName,
                    (Flags & BPCMDS_ONE_LINE) ? ' ' : '\n');
        }

        if ((Flags & BPCMDS_MODULE_HINT) &&
            (Bp->m_Flags & (DEBUG_BREAKPOINT_DEFERRED |
                            BREAKPOINT_VIRT_ADDR)) == BREAKPOINT_VIRT_ADDR)
        {
            ImageInfo* Image =
                Bp->m_Process->FindImageByOffset(Flat(*Bp->GetAddr()), FALSE);
            if (Image != NULL)
            {
                dprintf("ld %s;%c", Image->m_ModuleName,
                    (Flags & BPCMDS_ONE_LINE) ? ' ' : '\n');
            }
        }

        char TypeChar;

        if (Bp->m_Flags & BREAKPOINT_KD_INTERNAL)
        {
            TypeChar = (Bp->m_Flags & BREAKPOINT_KD_COUNT_ONLY) ? 'i' : 'w';
        }
        else if (Bp->m_BreakType == DEBUG_BREAKPOINT_CODE)
        {
            TypeChar = Bp->m_OffsetExpr != NULL ? 'u' : 'p';
        }
        else
        {
            TypeChar = 'a';
        }

        dprintf("b%c%u", TypeChar, Bp->m_Id);

        char OptionChar;

        if (Bp->m_BreakType == DEBUG_BREAKPOINT_DATA)
        {
            switch(Bp->m_DataAccessType)
            {
            case DEBUG_BREAK_EXECUTE:
                OptionChar = 'e';
                break;
            case DEBUG_BREAK_WRITE:
                OptionChar = 'w';
                break;
            case DEBUG_BREAK_IO:
                OptionChar = 'i';
                break;
            case DEBUG_BREAK_READ:
            case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
                OptionChar = 'r';
                break;
            default:
                continue;
            }
            dprintf(" %c%d", OptionChar, Bp->m_DataSize);
        }

        if (Bp->m_Flags & DEBUG_BREAKPOINT_ONE_SHOT)
        {
            dprintf(" /1");
        }

        if (Bp->m_OffsetExpr != NULL)
        {
            dprintf(" %s", Bp->m_OffsetExpr);
        }
        else
        {
            dprintf(" 0x");
            dprintAddr(Bp->GetAddr());
        }

        if (Bp->m_PassCount > 1)
        {
            dprintf(" 0x%x", Bp->m_PassCount);
        }

        if (Bp->m_Command != NULL)
        {
            dprintf(" \"%s\"", Bp->m_Command);
        }

        dprintf(";%c", (Flags & BPCMDS_ONE_LINE) ? ' ' : '\n');

        if ((Flags & BPCMDS_FORCE_DISABLE) ||
            (Bp->m_Flags & DEBUG_BREAKPOINT_ENABLED) == 0)
        {
            dprintf("bd %u;%c", Bp->m_Id,
                    (Flags & BPCMDS_ONE_LINE) ? ' ' : '\n');
        }

        if (Bp->GetProcType() != Process->m_Target->m_MachineType)
        {
            dprintf(".effmach .;%c",
                    (Flags & BPCMDS_ONE_LINE) ? ' ' : '\n');
        }
    }

    if (Flags & BPCMDS_ONE_LINE)
    {
        dprintf("\n");
    }
}

//----------------------------------------------------------------------------
//
// Parses command-line breakpoint commands for b[aimpw].
//
//----------------------------------------------------------------------------

struct SET_SYMBOL_MATCH_BP
{
    DebugClient* Client;
    ProcessInfo* Process;
    PSTR MatchString;
    Breakpoint* ProtoBp;
    ULONG Matches;
    ULONG Error;
};

BOOL CALLBACK
SetSymbolMatchBp(PSYMBOL_INFO SymInfo,
                 ULONG Size,
                 PVOID UserContext)
{
    SET_SYMBOL_MATCH_BP* Context =
        (SET_SYMBOL_MATCH_BP*)UserContext;

    ImageInfo* Image = Context->Process->
        FindImageByOffset(SymInfo->Address, FALSE);
    if (!Image)
    {
        return TRUE;
    }

    MachineInfo* Machine = MachineTypeInfo(Context->Process->m_Target,
                                           Image->GetMachineType());

    if (IgnoreEnumeratedSymbol(Context->Process, Context->MatchString,
                               Machine, SymInfo) ||
        !ForceSymbolCodeAddress(Context->Process, SymInfo, Machine))
    {
        return TRUE;
    }

    ADDR Addr;

    ADDRFLAT(&Addr, SymInfo->Address);
    if (FAILED(Context->ProtoBp->CheckAddr(&Addr)))
    {
        Context->Error = MEMORY;
        return FALSE;
    }

    Breakpoint* Bp;

    if (AddBreakpoint(Context->Client, Machine, DEBUG_BREAKPOINT_CODE,
                      DEBUG_ANY_ID, &Bp) != S_OK)
    {
        Context->Error = BPLISTFULL;
        return FALSE;
    }

    if (Context->ProtoBp->m_Flags & DEBUG_BREAKPOINT_ONE_SHOT)
    {
        Bp->AddFlags(DEBUG_BREAKPOINT_ONE_SHOT);
    }

    Bp->m_CodeFlags = Context->ProtoBp->m_CodeFlags;
    Bp->m_MatchProcessData = Context->ProtoBp->m_MatchProcessData;
    Bp->m_MatchThreadData = Context->ProtoBp->m_MatchThreadData;
    Bp->SetPassCount(Context->ProtoBp->m_PassCount);
    if (Context->ProtoBp->m_MatchThread)
    {
        Bp->SetMatchThreadId(Context->ProtoBp->m_MatchThread->m_UserId);
    }

    if (Bp->SetAddr(&Addr, BREAKPOINT_REMOVE_MATCH) != S_OK ||
        (Context->ProtoBp->m_Command &&
         Bp->SetCommand(Context->ProtoBp->m_Command) != S_OK))
    {
        Bp->Relinquish();
        Context->Error = NOMEMORY;
        return FALSE;
    }

    Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED);

    dprintf("%3d: %s %s!%s\n",
            Bp->m_Id, FormatAddr64(SymInfo->Address),
            Image->m_ModuleName, SymInfo->Name);

    Context->Matches++;

    return TRUE;
}

PDEBUG_BREAKPOINT
ParseBpCmd(DebugClient* Client,
           UCHAR Type,
           ThreadInfo* Thread)
{
    ULONG UserId = DEBUG_ANY_ID;
    char Ch;
    ADDR Addr;
    Breakpoint* Bp;

    if (IS_LOCAL_KERNEL_TARGET(g_Target) || IS_DUMP_TARGET(g_Target))
    {
        error(SESSIONNOTSUP);
    }
    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        error(BADTHREAD);
    }

    if (IS_LIVE_USER_TARGET(g_Target) && Type == 'a' &&
        (g_EngStatus & ENG_STATUS_AT_INITIAL_BREAK))
    {
        ErrOut("The system resets thread contexts after the process\n");
        ErrOut("breakpoint so hardware breakpoints cannot be set.\n");
        ErrOut("Go to the executable's entry point and set it then.\n");
        *g_CurCmd = 0;
        return NULL;
    }

    //  get the breakpoint number if given

    Ch = *g_CurCmd;
    if (Ch == '[')
    {
        UserId = (ULONG)GetTermExpression("Breakpoint ID missing from");
    }
    else if (Ch >= '0' && Ch <= '9')
    {
        UserId = Ch - '0';
        Ch = *++g_CurCmd;
        while (Ch >= '0' && Ch <= '9')
        {
            UserId = UserId * 10 + Ch - '0';
            Ch = *++g_CurCmd;
        }

        if (Ch != ' ' && Ch != '\t' && Ch != '\0')
        {
            error(SYNTAX);
        }
    }

    if (UserId != DEBUG_ANY_ID)
    {
        // Remove any existing breakpoint with the given ID.
        Breakpoint* IdBp;

        if (Type == 'm')
        {
            error(SYNTAX);
        }

        if ((IdBp = GetBreakpointById(Client, UserId)) != NULL)
        {
            WarnOut("breakpoint %ld exists, redefining\n", UserId);
            RemoveBreakpoint(IdBp);
        }
    }

    // Create a new breakpoint.
    if (AddBreakpoint(Client, g_Machine, Type == 'a' ?
                      DEBUG_BREAKPOINT_DATA : DEBUG_BREAKPOINT_CODE,
                      UserId, &Bp) != S_OK)
    {
        error(BPLISTFULL);
    }

    // Add in KD internal flags if necessary.
    if (Type == 'i' || Type == 'w')
    {
        if (IS_KERNEL_TARGET(g_Target))
        {
            Bp->m_Flags = Bp->m_Flags | BREAKPOINT_KD_INTERNAL |
                (Type == 'i' ? BREAKPOINT_KD_COUNT_ONLY : 0);
            if (Type == 'w')
            {
                g_Target->InitializeTargetControlledStepping();
            }
        }
        else
        {
            // KD internal breakpoints are only supported in
            // kernel debugging.
            Bp->Relinquish();
            error(SYNTAX);
        }
    }

    // If data breakpoint, get option and size values.
    if (Type == 'a')
    {
        ULONG64 Size;
        ULONG AccessType;

        Ch = PeekChar();
        Ch = (char)tolower(Ch);

        if (Ch == 'e')
        {
            AccessType = DEBUG_BREAK_EXECUTE;
        }
        else if (Ch == 'w')
        {
            AccessType = DEBUG_BREAK_WRITE;
        }
        else if (Ch == 'i')
        {
            AccessType = DEBUG_BREAK_IO;
        }
        else if (Ch == 'r')
        {
            AccessType = DEBUG_BREAK_READ;
        }
        else
        {
            Bp->Relinquish();
            error(SYNTAX);
        }

        g_CurCmd++;
        Size = GetTermExpression("Hardware breakpoint length missing from");
        if (Size & ~ULONG(-1))
        {
            ErrOut("Breakpoint length too big\n");
            Bp->Relinquish();
            error(SYNTAX);
        }

        // Validate the selections.  This assumes that
        // the default offset of zero won't cause problems.
        if (Bp->SetDataParameters((ULONG)Size, AccessType) != S_OK)
        {
            Bp->Relinquish();
            error(SYNTAX);
        }

        g_CurCmd++;
    }

    //
    // Parse breakpoint options.
    //

    while (PeekChar() == '/')
    {
        g_CurCmd++;
        switch(*g_CurCmd++)
        {
        case '1':
            Bp->AddFlags(DEBUG_BREAKPOINT_ONE_SHOT);
            break;
        case 'f':
            Bp->m_CodeFlags = (ULONG)GetTermExpression(NULL);
            break;
        case 'p':
            Bp->m_MatchProcessData = GetTermExpression(NULL);
            break;
        case 't':
            Bp->m_MatchThreadData = GetTermExpression(NULL);
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }
    }

    PSTR ExprStart, ExprEnd;

    Ch = PeekChar();

    if (Type == 'm')
    {
        char Save;

        ExprStart = StringValue(STRV_SPACE_IS_SEPARATOR |
                                STRV_TRIM_TRAILING_SPACE, &Save);
        ExprEnd = g_CurCmd;
        *g_CurCmd = Save;
        Ch = PeekChar();
    }
    else
    {
        //
        // Get the breakpoint address, if given, otherwise
        // default to the current IP.
        //

        BreakpointEvalResult AddrValid = BPEVAL_RESOLVED;

        g_Target->m_EffMachine->GetPC(&Addr);

        if (Ch != '"' && Ch != '\0')
        {
            ExprStart = g_CurCmd;

            g_PrefixSymbols = Type == 'p' || Type == 'u';

            AddrValid = EvalAddrExpression(g_Process,
                                           g_Target->m_EffMachineType,
                                           &Addr);

            g_PrefixSymbols = FALSE;

            if (AddrValid == BPEVAL_ERROR)
            {
                Bp->Relinquish();
                return NULL;
            }

            // If an unresolved symbol was encountered this
            // breakpoint will be deferred.  Users can also force
            // breakpoints to use expressions for cases where the
            // address could be resolved but also may become invalid
            // later.
            if (Type == 'u' || AddrValid == BPEVAL_UNRESOLVED)
            {
                HRESULT Status;
                UCHAR Save = *g_CurCmd;
                *g_CurCmd = 0;

                Status = Bp->SetEvaluatedOffsetExpression(ExprStart,
                                                          AddrValid,
                                                          &Addr);

                if (Type != 'u' && Status == S_OK)
                {
                    WarnOut("Bp expression '%s' could not be resolved, "
                            "adding deferred bp\n", ExprStart);
                }

                *g_CurCmd = Save;

                if (Status != S_OK)
                {
                    Bp->Relinquish();
                    error(NOMEMORY);
                }
            }

            Ch = PeekChar();
        }

        if (AddrValid != BPEVAL_UNRESOLVED &&
            FAILED(Bp->CheckAddr(&Addr)))
        {
            Bp->Relinquish();
            error(MEMORY);
        }

        // The public interface only supports flat addresses
        // so use an internal method to set the true address.
        // Do not allow matching breakpoints through the parsing
        // interface as that was the previous behavior.
        if (Bp->SetAddr(&Addr, BREAKPOINT_REMOVE_MATCH) != S_OK)
        {
            Bp->Relinquish();
            error(SYNTAX);
        }
    }

    // Get the pass count, if given.
    if (Ch != '"' && Ch != ';' && Ch != '\0')
    {
        ULONG64 PassCount = GetExpression();
        if (PassCount < 1 || PassCount > 0xffffffff)
        {
            error(BADRANGE);
        }
        Bp->SetPassCount((ULONG)PassCount);
        Ch = PeekChar();
    }

    // If next character is double quote, get the command string.
    if (Ch == '"')
    {
        PSTR Str;
        CHAR Save;

        Str = StringValue(STRV_ESCAPED_CHARACTERS, &Save);

        if (Bp->SetCommand(Str) != S_OK)
        {
            Bp->Relinquish();
            error(NOMEMORY);
        }

        *g_CurCmd = Save;
    }

    // Set some final information.
    if (Thread != NULL)
    {
        Bp->SetMatchThreadId(Thread->m_UserId);
    }

    // Turn breakpoint on.
    Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED);

    if (Type == 'm')
    {
        SET_SYMBOL_MATCH_BP Context;

        // Now that we have the prototype breakpoint created,
        // enumerate all symbol matches for the symbol
        // expression and create specific breakpoints for
        // each hit from the prototype breakpoint.
        *ExprEnd = 0;
        Context.Client = Client;
        Context.Process = g_Process;
        Context.MatchString = ExprStart;
        Context.ProtoBp = Bp;
        Context.Matches = 0;
        Context.Error = 0;

        SymEnumSymbols(g_Process->m_SymHandle, 0, ExprStart,
                       SetSymbolMatchBp, &Context);
        if (Context.Error)
        {
            error(Context.Error);
        }
        if (!Context.Matches)
        {
            ErrOut("No matching symbols found, no breakpoints set\n");
        }

        Bp->Relinquish();
        Bp = NULL;
    }

    return Bp;
}

inline BOOL
IsCodeBreakpointInsertedInRange(Breakpoint* Bp,
                                ULONG64 Start, ULONG64 End)
{
    return (Bp->m_Flags & BREAKPOINT_INSERTED) &&
        Bp->m_BreakType == DEBUG_BREAKPOINT_CODE &&
        Flat(*Bp->GetAddr()) >= Start &&
        Flat(*Bp->GetAddr()) <= End;
}

BOOL
CheckBreakpointInsertedInRange(ProcessInfo* Process,
                               ULONG64 Start, ULONG64 End)
{
    if ((g_EngStatus & ENG_STATUS_BREAKPOINTS_INSERTED) == 0)
    {
        return FALSE;
    }

    //
    // Check for a breakpoint that might have caused
    // a break instruction to be inserted in the given
    // offset range.  Data breakpoints don't count
    // as they don't actually modify the address they
    // break on.
    //

    Breakpoint* Bp;

    for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
    {
        if (IsCodeBreakpointInsertedInRange(Bp, Start, End))
        {
            return TRUE;
        }
    }

    if ((g_DeferBp->m_Process == Process &&
         IsCodeBreakpointInsertedInRange(g_DeferBp, Start, End)) ||
        (g_StepTraceBp->m_Process == Process &&
         IsCodeBreakpointInsertedInRange(g_StepTraceBp, Start, End)))
    {
        return TRUE;
    }

    return FALSE;
}

//----------------------------------------------------------------------------
//
// TargetInfo methods.
//
//----------------------------------------------------------------------------

HRESULT
TargetInfo::BeginInsertingBreakpoints(void)
{
    ProcessInfo* Process;
    ThreadInfo* Thread;

    ForTargetProcesses(this)
    {
        ForProcessThreads(Process)
        {
            DataBreakpoint::ClearThreadDataBreaks(Thread);
        }
    }

    return S_OK;
}

HRESULT
TargetInfo::InsertDataBreakpoint(ProcessInfo* Process,
                                 ThreadInfo* Thread,
                                 class MachineInfo* Machine,
                                 PADDR Addr,
                                 ULONG Size,
                                 ULONG AccessType,
                                 PUCHAR StorageSpace)
{
    // Ask for default processing.
    return S_FALSE;
}

void
TargetInfo::EndInsertingBreakpoints(void)
{
    ProcessInfo* Process;
    ThreadInfo* Thread;

    if (!g_UpdateDataBreakpoints ||
        !IS_CONTEXT_POSSIBLE(this))
    {
        return;
    }

    //
    // It's the target machine's responsibility to manage
    // all data breakpoints for all machines, so always
    // force the usage of the target machine here.
    //

    ThreadInfo* SaveThread = m_RegContextThread;

    ForTargetProcesses(this)
    {
        ForProcessThreads(Process)
        {
            SetLayersFromThread(Thread);
            ChangeRegContext(Thread);
            m_Machine->InsertThreadDataBreakpoints();
        }
    }

    ChangeRegContext(SaveThread);
}

void
TargetInfo::BeginRemovingBreakpoints(void)
{
    // No work necessary.
}

HRESULT
TargetInfo::RemoveDataBreakpoint(ProcessInfo* Process,
                                 ThreadInfo* Thread,
                                 class MachineInfo* Machine,
                                 PADDR Addr,
                                 ULONG Size,
                                 ULONG AccessType,
                                 PUCHAR StorageSpace)
{
    // Ask for default processing.
    return S_FALSE;
}

void
TargetInfo::EndRemovingBreakpoints(void)
{
    // No work necessary.
}

HRESULT
TargetInfo::RemoveAllDataBreakpoints(ProcessInfo* Process)
{
    // No work necessary.
    return S_OK;
}

HRESULT
TargetInfo::RemoveAllTargetBreakpoints(void)
{
    // No work necessary.
    return S_OK;
}

HRESULT
TargetInfo::IsDataBreakpointHit(ThreadInfo* Thread,
                                PADDR Addr,
                                ULONG Size,
                                ULONG AccessType,
                                PUCHAR StorageSpace)
{
    // Ask for default processing.
    return S_FALSE;
}

HRESULT
ConnLiveKernelTargetInfo::InsertCodeBreakpoint(ProcessInfo* Process,
                                               MachineInfo* Machine,
                                               PADDR Addr,
                                               ULONG InstrFlags,
                                               PUCHAR StorageSpace)
{
    if (InstrFlags != IBI_DEFAULT)
    {
        return E_INVALIDARG;
    }

    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_WRITE_BREAKPOINT64 a = &m.u.WriteBreakPoint;
    NTSTATUS st;
    ULONG rc;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdWriteBreakPointApi;
    m.ReturnStatus = STATUS_PENDING;
    a->BreakPointAddress = Flat(*Addr);

    //
    // Send the message and context and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdWriteBreakPointApi);

    st = Reply->ReturnStatus;

    *(PULONG)StorageSpace = Reply->u.WriteBreakPoint.BreakPointHandle;

    KdOut("DbgKdWriteBreakPoint(%s) returns %08lx, %x\n",
          FormatAddr64(Flat(*Addr)), st,
          Reply->u.WriteBreakPoint.BreakPointHandle);

    return CONV_NT_STATUS(st);
}

NTSTATUS
ConnLiveKernelTargetInfo::KdRestoreBreakPoint(ULONG BreakPointHandle)
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_RESTORE_BREAKPOINT a = &m.u.RestoreBreakPoint;
    NTSTATUS st;
    ULONG rc;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdRestoreBreakPointApi;
    m.ReturnStatus = STATUS_PENDING;
    a->BreakPointHandle = BreakPointHandle;

    //
    // Send the message and context and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdRestoreBreakPointApi);

    st = Reply->ReturnStatus;

    KdOut("DbgKdRestoreBreakPoint(%x) returns %08lx\n",
          BreakPointHandle, st);

    return st;
}

HRESULT
ConnLiveKernelTargetInfo::RemoveCodeBreakpoint(ProcessInfo* Process,
                                               MachineInfo* Machine,
                                               PADDR Addr,
                                               ULONG InstrFlags,
                                               PUCHAR StorageSpace)
{
    // When the kernel fills out the CONTROL_REPORT.InstructionStream
    // array it clears any breakpoints that might fall within the
    // array.  This means that some breakpoints may already be
    // restored, so the restore call will fail.  We could do some
    // checks to try and figure out which ones might be affected
    // but it doesn't seem worthwhile.  Just ignore the return
    // value from the restore.
    KdRestoreBreakPoint(*(PULONG)StorageSpace);
    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::RemoveAllDataBreakpoints(ProcessInfo* Process)
{
    if (m_Transport->m_WaitingThread)
    {
        // A thread is waiting so we can't communicate
        // with the target machine.
        return E_UNEXPECTED;
    }

    // If there were any data breakpoints active
    // remove them from all processors.  This can't be in
    // RemoveAllKernelBreakpoints as that
    // code is called in the middle of state
    // change processing when the context hasn't
    // been initialized.
    if (g_UpdateDataBreakpoints)
    {
        ULONG Proc;

        SetEffMachine(m_MachineType, FALSE);

        g_EngNotify++;
        for (Proc = 0; Proc < m_NumProcessors; Proc++)
        {
            SetCurrentProcessorThread(this, Proc, TRUE);

            // Force the context to be dirty so it
            // gets written back.
            m_Machine->GetContextState(MCTX_DIRTY);
            m_Machine->RemoveThreadDataBreakpoints();
        }
        g_EngNotify--;

        // Flush final context.
        ChangeRegContext(NULL);
    }

    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::RemoveAllTargetBreakpoints(void)
{
    ULONG i;

    if (m_Transport->m_WaitingThread)
    {
        // A thread is waiting so we can't communicate
        // with the target machine.
        return E_UNEXPECTED;
    }

    // Indices are array index plus one.
    for (i = 1; i <= BREAKPOINT_TABLE_SIZE; i++)
    {
        KdRestoreBreakPoint(i);
    }

    // ClearAllInternalBreakpointsApi was added for XP
    // so it fails against any previous OS.
    if (m_KdMaxManipulate > DbgKdClearAllInternalBreakpointsApi)
    {
        DBGKD_MANIPULATE_STATE64 Request;

        Request.ApiNumber = DbgKdClearAllInternalBreakpointsApi;
        Request.ReturnStatus = STATUS_PENDING;

        m_Transport->WritePacket(&Request, sizeof(Request),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
    }

    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::InsertTargetCountBreakpoint(PADDR Addr,
                                                      ULONG Flags)
{
    DBGKD_MANIPULATE_STATE64 m;
    ULONG64 Offset = Flat(*Addr);

    m.ApiNumber = DbgKdSetInternalBreakPointApi;
    m.ReturnStatus = STATUS_PENDING;

#ifdef IBP_WORKAROUND
    // The kernel code keeps a ULONG64 for an internal breakpoint
    // address but older kernels did not sign-extend the current IP
    // when comparing against them.  In order to work with both
    // broken and fixed kernels send down zero-extended addresses.
    // Don't actually enable this workaround right now as other
    // internal breakpoint bugs can cause the machine to bugcheck.
    Offset = m_Machine->m_Ptr64 ? Offset : (ULONG)Offset;
#endif

    m.u.SetInternalBreakpoint.BreakpointAddress = Offset;
    m.u.SetInternalBreakpoint.Flags = Flags;

    m_Transport->WritePacket(&m, sizeof(m),
                             PACKET_TYPE_KD_STATE_MANIPULATE,
                             NULL, 0);

    KdOut("DbgKdSetInternalBp returns 0x00000000\n");
    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::RemoveTargetCountBreakpoint(PADDR Addr)
{
    DBGKD_MANIPULATE_STATE64 m;
    ULONG64 Offset = Flat(*Addr);

    m.ApiNumber = DbgKdSetInternalBreakPointApi;
    m.ReturnStatus = STATUS_PENDING;

#ifdef IBP_WORKAROUND
    // The kernel code keeps a ULONG64 for an internal breakpoint
    // address but older kernels did not sign-extend the current IP
    // when comparing against them.  In order to work with both
    // broken and fixed kernels send down zero-extended addresses.
    // Don't actually enable this workaround right now as other
    // internal breakpoint bugs can cause the machine to bugcheck.
    Offset = m_Machine->m_Ptr64 ? Offset : (ULONG)Offset;
#endif

    m.u.SetInternalBreakpoint.BreakpointAddress = Offset;
    m.u.SetInternalBreakpoint.Flags = DBGKD_INTERNAL_BP_FLAG_INVALID;

    m_Transport->WritePacket(&m, sizeof(m),
                             PACKET_TYPE_KD_STATE_MANIPULATE,
                             NULL, 0);

    KdOut("DbgKdSetInternalBp returns 0x00000000\n");
    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::QueryTargetCountBreakpoint(PADDR Addr,
                                                     PULONG Flags,
                                                     PULONG Calls,
                                                     PULONG MinInstr,
                                                     PULONG MaxInstr,
                                                     PULONG TotInstr,
                                                     PULONG MaxCps)
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    ULONG rc;
    ULONG64 Offset = Flat(*Addr);

    m.ApiNumber = DbgKdGetInternalBreakPointApi;
    m.ReturnStatus = STATUS_PENDING;

#ifdef IBP_WORKAROUND
    // The kernel code keeps a ULONG64 for an internal breakpoint
    // address but older kernels did not sign-extend the current IP
    // when comparing against them.  In order to work with both
    // broken and fixed kernels send down zero-extended addresses.
    // Don't actually enable this workaround right now as other
    // internal breakpoint bugs can cause the machine to bugcheck.
    Offset = m_Machine->m_Ptr64 ? Offset : (ULONG)Offset;
#endif

    m.u.GetInternalBreakpoint.BreakpointAddress = Offset;

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    }
    while (rc != DBGKD_WAIT_PACKET);

    *Flags = Reply->u.GetInternalBreakpoint.Flags;
    *Calls = Reply->u.GetInternalBreakpoint.Calls;
    *MaxInstr = Reply->u.GetInternalBreakpoint.MaxInstructions;
    *MinInstr = Reply->u.GetInternalBreakpoint.MinInstructions;
    *TotInstr = Reply->u.GetInternalBreakpoint.TotalInstructions;
    *MaxCps = Reply->u.GetInternalBreakpoint.MaxCallsPerPeriod;

    KdOut("DbgKdGetInternalBp returns 0x00000000\n");
    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::BeginInsertingBreakpoints(void)
{
    if (!m_ExdiDataBreaks)
    {
        return TargetInfo::BeginInsertingBreakpoints();
    }
    else
    {
        // If direct eXDI support for data breakpoints is
        // used this method doesn't need to do anything.
        return S_OK;
    }
}

HRESULT
ExdiLiveKernelTargetInfo::InsertCodeBreakpoint(ProcessInfo* Process,
                                               MachineInfo* Machine,
                                               PADDR Addr,
                                               ULONG InstrFlags,
                                               PUCHAR StorageSpace)
{
    if (InstrFlags != IBI_DEFAULT)
    {
        return E_INVALIDARG;
    }

    IeXdiCodeBreakpoint** BpStorage = (IeXdiCodeBreakpoint**)StorageSpace;
    HRESULT Status = m_Server->
        AddCodeBreakpoint(Flat(*Addr), m_CodeBpType, mtVirtual, 0, 0,
                          BpStorage);
    if (Status == S_OK)
    {
        // Breakpoints are created disabled so enable it.
        Status = (*BpStorage)->SetState(TRUE, TRUE);
        if (Status != S_OK)
        {
            m_Server->DelCodeBreakpoint(*BpStorage);
            RELEASE(*BpStorage);
        }
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::InsertDataBreakpoint(ProcessInfo* Process,
                                               ThreadInfo* Thread,
                                               class MachineInfo* Machine,
                                               PADDR Addr,
                                               ULONG Size,
                                               ULONG AccessType,
                                               PUCHAR StorageSpace)
{
    if (!m_ExdiDataBreaks)
    {
        return TargetInfo::InsertDataBreakpoint(Process, Thread, Machine,
                                                Addr, Size, AccessType,
                                                StorageSpace);
    }

    DATA_ACCESS_TYPE ExdiAccess;

    if (AccessType & (DEBUG_BREAK_IO | DEBUG_BREAK_EXECUTE))
    {
        // Not supported.
        return E_NOTIMPL;
    }
    switch(AccessType)
    {
    case 0:
        return E_INVALIDARG;
    case DEBUG_BREAK_READ:
        ExdiAccess = daRead;
        break;
    case DEBUG_BREAK_WRITE:
        ExdiAccess = daWrite;
        break;
    case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
        ExdiAccess = daBoth;
        break;
    }

    IeXdiDataBreakpoint** BpStorage = (IeXdiDataBreakpoint**)StorageSpace;
    HRESULT Status = m_Server->
        AddDataBreakpoint(Flat(*Addr), -1, 0, 0, (BYTE)(Size * 8),
                          mtVirtual, 0, ExdiAccess, 0, BpStorage);
    if (Status == S_OK)
    {
        // Breakpoints are created disabled so enable it.
        Status = (*BpStorage)->SetState(TRUE, TRUE);
        if (Status != S_OK)
        {
            m_Server->DelDataBreakpoint(*BpStorage);
            RELEASE(*BpStorage);
        }
    }
    return Status;
}

void
ExdiLiveKernelTargetInfo::EndInsertingBreakpoints(void)
{
    if (!m_ExdiDataBreaks)
    {
        TargetInfo::EndInsertingBreakpoints();
    }
}

void
ExdiLiveKernelTargetInfo::BeginRemovingBreakpoints(void)
{
    if (!m_ExdiDataBreaks)
    {
        TargetInfo::BeginRemovingBreakpoints();
    }
}

HRESULT
ExdiLiveKernelTargetInfo::RemoveCodeBreakpoint(ProcessInfo* Process,
                                               MachineInfo* Machine,
                                               PADDR Addr,
                                               ULONG InstrFlags,
                                               PUCHAR StorageSpace)
{
    IeXdiCodeBreakpoint** BpStorage = (IeXdiCodeBreakpoint**)StorageSpace;
    HRESULT Status = m_Server->
        DelCodeBreakpoint(*BpStorage);
    if (Status == S_OK)
    {
        RELEASE(*BpStorage);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::RemoveDataBreakpoint(ProcessInfo* Process,
                                               ThreadInfo* Thread,
                                               class MachineInfo* Machine,
                                               PADDR Addr,
                                               ULONG Size,
                                               ULONG AccessType,
                                               PUCHAR StorageSpace)
{
    if (!m_ExdiDataBreaks)
    {
        return TargetInfo::RemoveDataBreakpoint(Process, Thread, Machine,
                                                Addr, Size, AccessType,
                                                StorageSpace);
    }

    IeXdiDataBreakpoint** BpStorage = (IeXdiDataBreakpoint**)StorageSpace;
    HRESULT Status = m_Server->
        DelDataBreakpoint(*BpStorage);
    if (Status == S_OK)
    {
        RELEASE(*BpStorage);
    }
    return Status;
}

void
ExdiLiveKernelTargetInfo::EndRemovingBreakpoints(void)
{
    if (!m_ExdiDataBreaks)
    {
        TargetInfo::EndRemovingBreakpoints();
    }
}

HRESULT
ExdiLiveKernelTargetInfo::IsDataBreakpointHit(ThreadInfo* Thread,
                                              PADDR Addr,
                                              ULONG Size,
                                              ULONG AccessType,
                                              PUCHAR StorageSpace)
{
    if (!m_ExdiDataBreaks)
    {
        return S_FALSE;
    }

    if (m_BpHit.Type != DBGENG_EXDI_IOCTL_BREAKPOINT_DATA ||
        m_BpHit.Address != Flat(*Addr) ||
        m_BpHit.AccessWidth != Size)
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

HRESULT
LiveUserTargetInfo::BeginInsertingBreakpoints(void)
{
    if (m_ServiceFlags & DBGSVC_GENERIC_DATA_BREAKPOINTS)
    {
        return TargetInfo::BeginInsertingBreakpoints();
    }

    // Services handle everything so there's no preparation.
    return S_OK;
}

HRESULT
LiveUserTargetInfo::InsertCodeBreakpoint(ProcessInfo* Process,
                                         MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG InstrFlags,
                                         PUCHAR StorageSpace)
{
    HRESULT Status;

    if (m_ServiceFlags & DBGSVC_GENERIC_CODE_BREAKPOINTS)
    {
        ULONG64 ChangeStart;
        ULONG ChangeLen;

        Status = Machine->
            InsertBreakpointInstruction(m_Services,
                                        Process->m_SysHandle,
                                        Flat(*Addr), InstrFlags, StorageSpace,
                                        &ChangeStart, &ChangeLen);
        if ((Status == HRESULT_FROM_WIN32(ERROR_PARTIAL_COPY) ||
             Status == HRESULT_FROM_WIN32(ERROR_NOACCESS) ||
             Status == HRESULT_FROM_WIN32(ERROR_WRITE_FAULT)) &&
            (g_EngOptions & DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS))
        {
            HRESULT NewStatus;
            ULONG OldProtect;

            // Change the page protections to read-write and try again.
            NewStatus = m_Services->
                ProtectVirtual(Process->m_SysHandle, ChangeStart, ChangeLen,
                               PAGE_READWRITE, &OldProtect);
            if (NewStatus == S_OK)
            {
                // If the page was already writable there's no point in
                // retrying
                if ((OldProtect & (PAGE_READWRITE |
                                   PAGE_WRITECOPY |
                                   PAGE_EXECUTE_READWRITE |
                                   PAGE_EXECUTE_WRITECOPY)) == 0)
                {
                    NewStatus = Machine->
                        InsertBreakpointInstruction(m_Services,
                                                    Process->m_SysHandle,
                                                    Flat(*Addr), InstrFlags,
                                                    StorageSpace,
                                                    &ChangeStart, &ChangeLen);
                    if (NewStatus == S_OK)
                    {
                        Status = S_OK;
                    }
                }

                NewStatus = m_Services->
                    ProtectVirtual(Process->m_SysHandle,
                                   ChangeStart, ChangeLen,
                                   OldProtect, &OldProtect);
                if (NewStatus != S_OK)
                {
                    // Couldn't restore page permissions so fail.
                    if (Status == S_OK)
                    {
                        Machine->
                            RemoveBreakpointInstruction(m_Services,
                                                        Process->m_SysHandle,
                                                        Flat(*Addr),
                                                        StorageSpace,
                                                        &ChangeStart,
                                                        &ChangeLen);
                    }

                    Status = NewStatus;
                }
            }
        }

        return Status;
    }
    else
    {
        if (InstrFlags != IBI_DEFAULT)
        {
            return E_INVALIDARG;
        }

        return m_Services->
            InsertCodeBreakpoint(Process->m_SysHandle,
                                 Flat(*Addr), Machine->m_ExecTypes[0],
                                 StorageSpace, MAX_BREAKPOINT_LENGTH);
    }
}

HRESULT
LiveUserTargetInfo::InsertDataBreakpoint(ProcessInfo* Process,
                                         ThreadInfo* Thread,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG Size,
                                         ULONG AccessType,
                                         PUCHAR StorageSpace)
{
    if (m_ServiceFlags & DBGSVC_GENERIC_DATA_BREAKPOINTS)
    {
        return S_FALSE;
    }

    return m_Services->
        InsertDataBreakpoint(Process->m_SysHandle,
                             Thread ? Thread->m_Handle : 0,
                             Flat(*Addr), Size, AccessType,
                             Machine->m_ExecTypes[0]);
}

void
LiveUserTargetInfo::EndInsertingBreakpoints(void)
{
    if (m_ServiceFlags & DBGSVC_GENERIC_DATA_BREAKPOINTS)
    {
        return TargetInfo::EndInsertingBreakpoints();
    }

    // Services handle everything so there's no preparation.
}

HRESULT
LiveUserTargetInfo::RemoveCodeBreakpoint(ProcessInfo* Process,
                                         MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG InstrFlags,
                                         PUCHAR StorageSpace)
{
    HRESULT Status;

    if (m_ServiceFlags & DBGSVC_GENERIC_CODE_BREAKPOINTS)
    {
        ULONG64 ChangeStart;
        ULONG ChangeLen;

        Status = Machine->
            RemoveBreakpointInstruction(m_Services,
                                        Process->m_SysHandle,
                                        Flat(*Addr), StorageSpace,
                                        &ChangeStart, &ChangeLen);
        if ((Status == HRESULT_FROM_WIN32(ERROR_PARTIAL_COPY) ||
             Status == HRESULT_FROM_WIN32(ERROR_NOACCESS) ||
             Status == HRESULT_FROM_WIN32(ERROR_WRITE_FAULT)) &&
            (g_EngOptions & DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS))
        {
            HRESULT NewStatus;
            ULONG OldProtect;

            // Change the page protections to read-write and try again.
            NewStatus = m_Services->
                ProtectVirtual(Process->m_SysHandle, ChangeStart, ChangeLen,
                               PAGE_READWRITE, &OldProtect);
            if (NewStatus == S_OK)
            {
                // If the page was already writable there's no point in
                // retrying
                if ((OldProtect & (PAGE_READWRITE |
                                   PAGE_WRITECOPY |
                                   PAGE_EXECUTE_READWRITE |
                                   PAGE_EXECUTE_WRITECOPY)) == 0)
                {
                    NewStatus = Machine->
                        RemoveBreakpointInstruction(m_Services,
                                                    Process->m_SysHandle,
                                                    Flat(*Addr), StorageSpace,
                                                    &ChangeStart, &ChangeLen);
                    if (NewStatus == S_OK)
                    {
                        Status = S_OK;
                    }
                }

                NewStatus = m_Services->
                    ProtectVirtual(Process->m_SysHandle, ChangeStart,
                                   ChangeLen, OldProtect, &OldProtect);
                if (NewStatus != S_OK)
                {
                    // Couldn't restore page permissions so fail.
                    if (Status == S_OK)
                    {
                        Machine->
                            InsertBreakpointInstruction(m_Services,
                                                        Process->m_SysHandle,
                                                        Flat(*Addr),
                                                        InstrFlags,
                                                        StorageSpace,
                                                        &ChangeStart,
                                                        &ChangeLen);
                    }

                    Status = NewStatus;
                }
            }
        }

        return Status;
    }
    else
    {
        return m_Services->
            RemoveCodeBreakpoint(Process->m_SysHandle,
                                 Flat(*Addr), Machine->m_ExecTypes[0],
                                 StorageSpace, MAX_BREAKPOINT_LENGTH);
    }
}

HRESULT
LiveUserTargetInfo::RemoveDataBreakpoint(ProcessInfo* Process,
                                         ThreadInfo* Thread,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG Size,
                                         ULONG AccessType,
                                         PUCHAR StorageSpace)
{
    if (m_ServiceFlags & DBGSVC_GENERIC_DATA_BREAKPOINTS)
    {
        return S_FALSE;
    }

    return m_Services->
        RemoveDataBreakpoint(Process->m_SysHandle,
                             Thread ? Thread->m_Handle : 0,
                             Flat(*Addr), Size, AccessType,
                             Machine->m_ExecTypes[0]);
}

HRESULT
LiveUserTargetInfo::IsDataBreakpointHit(ThreadInfo* Thread,
                                        PADDR Addr,
                                        ULONG Size,
                                        ULONG AccessType,
                                        PUCHAR StorageSpace)
{
    if (m_ServiceFlags & DBGSVC_GENERIC_DATA_BREAKPOINTS)
    {
        // Ask for default processing.
        return S_FALSE;
    }

    if (!m_DataBpAddrValid)
    {
        m_DataBpAddrStatus = m_Services->
             GetLastDataBreakpointHit(Thread->m_Process->m_SysHandle,
                                      Thread->m_Handle,
                                      &m_DataBpAddr, &m_DataBpAccess);
        m_DataBpAddrValid = TRUE;
    }

    if (m_DataBpAddrStatus != S_OK ||
        m_DataBpAddr < Flat(*Addr) ||
        m_DataBpAddr >= Flat(*Addr) + Size ||
        !(m_DataBpAccess & AccessType))
    {
        return E_NOINTERFACE;
    }
    else
    {
        return S_OK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\callback.h ===
//----------------------------------------------------------------------------
//
// Callback notification routines.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __CALLBACK_H__
#define __CALLBACK_H__

//
// Notification compression support.  If the current notification
// level is above zero notifications are not actually sent
// to clients.  This allows code that knows it will be
// causing many similar notifications to bracket their operation
// with an increment/decrement, suppressing notifications
// during the bracket.
// Due to the counted nature it nests properly.
//
// This support is primarily for the Change* callbacks.
// Using it with the event callbacks is only partially supported.
//

extern ULONG g_EngNotify;
extern BOOL g_PartialOutputLine;
extern ULONG g_LastOutputMask;

ULONG ExecuteEventCommand(ULONG EventStatus, DebugClient* Client,
                          PCSTR Command);

//
// Event callbacks.
//

HRESULT NotifyBreakpointEvent(ULONG Vote, Breakpoint* Bp);
HRESULT NotifyExceptionEvent(PEXCEPTION_RECORD64 Record,
                             ULONG FirstChance, BOOL OutputDone);
HRESULT NotifyCreateThreadEvent(ULONG64 Handle,
                                ULONG64 DataOffset,
                                ULONG64 StartOffset,
                                ULONG Flags);
HRESULT NotifyExitThreadEvent(ULONG ExitCode);
HRESULT NotifyCreateProcessEvent(ULONG64 ImageFileHandle,
                                 HANDLE SymHandle,
                                 ULONG64 SysHandle,
                                 ULONG64 BaseOffset,
                                 ULONG ModuleSize,
                                 PSTR ModuleName,
                                 PSTR ImageName,
                                 ULONG CheckSum,
                                 ULONG TimeDateStamp,
                                 ULONG64 InitialThreadHandle,
                                 ULONG64 ThreadDataOffset,
                                 ULONG64 StartOffset,
                                 ULONG Flags,
                                 ULONG Options,
                                 ULONG InitialThreadFlags,
                                 BOOL QueryImageInfo,
                                 ULONG64 ImageNameOffset,
                                 BOOL ImageNameUnicode);
HRESULT NotifyExitProcessEvent(ULONG ExitCode);
HRESULT NotifyLoadModuleEvent(ULONG64 ImageFileHandle,
                              ULONG64 BaseOffset,
                              ULONG ModuleSize,
                              PSTR ModuleName,
                              PSTR ImageName,
                              ULONG CheckSum,
                              ULONG TimeDateStamp,
                              BOOL UserMode);
HRESULT NotifyUnloadModuleEvent(PCSTR ImageBaseName,
                                ULONG64 BaseOffset);
HRESULT NotifySystemErrorEvent(ULONG Error,
                               ULONG Level);
HRESULT NotifySessionStatus(ULONG Status);
    
void NotifyChangeDebuggeeState(ULONG Flags, ULONG64 Argument);
void NotifyChangeEngineState(ULONG Flags, ULONG64 Argument,
                             BOOL HaveEngineLock);
void NotifyChangeSymbolState(ULONG Flags, ULONG64 Argument,
                             ProcessInfo* Process);

//
// Input callbacks.
//

extern ULONG g_InputNesting;

#define GETIN_DEFAULT                0x00000001
#define GETIN_LOG_INPUT              0x00000002
#define GETIN_LOG_INPUT_ADD_NEW_LINE 0x00000004

#define GETIN_LOG_INPUT_LINE (GETIN_LOG_INPUT | GETIN_LOG_INPUT_ADD_NEW_LINE)

ULONG GetInput(PCSTR Prompt, PSTR Buffer, ULONG BufferSize, ULONG Flags);

//
// Output callbacks.
//

#define DEFAULT_OUT_MASK                                        \
    (DEBUG_OUTPUT_NORMAL | DEBUG_OUTPUT_ERROR |                 \
     DEBUG_OUTPUT_PROMPT | DEBUG_OUTPUT_PROMPT_REGISTERS |      \
     DEBUG_OUTPUT_WARNING | DEBUG_OUTPUT_EXTENSION_WARNING |    \
     DEBUG_OUTPUT_DEBUGGEE | DEBUG_OUTPUT_DEBUGGEE_PROMPT |     \
     DEBUG_OUTPUT_SYMBOLS)

#define DEFAULT_OUT_HISTORY_MASK                                \
    (DEBUG_OUTPUT_NORMAL | DEBUG_OUTPUT_ERROR |                 \
     DEBUG_OUTPUT_PROMPT | DEBUG_OUTPUT_PROMPT_REGISTERS |      \
     DEBUG_OUTPUT_WARNING | DEBUG_OUTPUT_EXTENSION_WARNING |    \
     DEBUG_OUTPUT_DEBUGGEE | DEBUG_OUTPUT_DEBUGGEE_PROMPT |     \
     DEBUG_OUTPUT_SYMBOLS)

#define OUT_BUFFER_SIZE (1024 * 16)

extern char g_OutBuffer[];
extern char g_FormatBuffer[];
extern char g_OutFilterPattern[MAX_IMAGE_PATH];
extern BOOL g_OutFilterResult;

// Bitwise-OR of all client's output masks for
// quick rejection of output that nobody cares about.
extern ULONG g_AllOutMask;

struct OutHistoryEntryHeader
{
    ULONG Mask;
};
typedef OutHistoryEntryHeader UNALIGNED* OutHistoryEntry;

extern PSTR g_OutHistory;
extern ULONG g_OutHistoryActualSize;
extern ULONG g_OutHistoryRequestedSize;
extern OutHistoryEntry g_OutHistRead, g_OutHistWrite;
extern ULONG g_OutHistoryMask;
extern ULONG g_OutHistoryUsed;

struct OutCtlSave
{
    ULONG OutputControl;
    DebugClient* Client;
    BOOL BufferOutput;
    ULONG OutputWidth;
    PCSTR OutputLinePrefix;
};

extern ULONG g_OutputControl;
extern DebugClient* g_OutputClient;
extern BOOL g_BufferOutput;

void CollectOutMasks(void);

BOOL PushOutCtl(ULONG OutputControl, DebugClient* Client,
                OutCtlSave* Save);
void PopOutCtl(OutCtlSave* Save);

void FlushCallbacks(void);
void TimedFlushCallbacks(void);
void SendOutputHistory(DebugClient* Client, ULONG HistoryLimit);
void CompletePartialLine(ULONG MatchMask);

#define OUT_LINE_DEFAULT      0x00000000
#define OUT_LINE_NO_PREFIX    0x00000001
#define OUT_LINE_NO_TIMESTAMP 0x00000002

void StartOutLine(ULONG Mask, ULONG Flags);
BOOL TranslateFormat(LPSTR formatOut, LPCSTR format,
                     va_list args, ULONG formatOutSize,
                     BOOL Ptr64);
void MaskOutVa(ULONG Mask, PCSTR Format, va_list Args, BOOL Translate);

void __cdecl dprintf(PCSTR, ...);
void __cdecl dprintf64(PCSTR, ...);
void __cdecl ErrOut(PCSTR, ...);
void __cdecl WarnOut(PCSTR, ...);
void __cdecl MaskOut(ULONG, PCSTR, ...);
void __cdecl VerbOut(PCSTR, ...);
void __cdecl BpOut(PCSTR, ...);
void __cdecl EventOut(PCSTR, ...);
void __cdecl KdOut(PCSTR, ...);

#endif // #ifndef __CALLBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\callback.cpp ===
//----------------------------------------------------------------------------
//
// Callback notification routines.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// Event APCs end up calling out to external code so it's difficult
// to pick a reasonable timeout.  However, we need to ensure that
// a server won't hang indefinitely if something goes wrong with
// event notifications.
#define EVENT_APC_TIMEOUT 300000

PSTR
EventIdStr(void)
{
    static char s_Buf[128];

    if (IS_USER_TARGET(g_EventTarget))
    {
        PrintString(s_Buf, DIMA(s_Buf), "(%x.%x): ",
                    g_EventProcessSysId, g_EventThreadSysId);
    }
    else
    {
        s_Buf[0] = 0;
    }
    return s_Buf;
}

//----------------------------------------------------------------------------
//
// APC support for dispatching event callbacks on the proper thread.
//
//----------------------------------------------------------------------------

struct AnyApcData
{
    AnyApcData(ULONG Mask, PCSTR Name)
    {
        m_Mask = Mask;
        m_Name = Name;
    }
    
    ULONG m_Mask;
    PCSTR m_Name;

    virtual ULONG Dispatch(DebugClient* Client) = 0;
};

struct BreakpointEventApcData : public AnyApcData
{
    BreakpointEventApcData()
        : AnyApcData(DEBUG_EVENT_BREAKPOINT,
                     "IDebugEventCallbacks::Breakpoint")
    {
    }
    
    Breakpoint* m_Bp;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        if ((m_Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) == 0 ||
            Client == m_Bp->m_Adder)
        {
            return Client->m_EventCb->
                Breakpoint(m_Bp);
        }
        else
        {
            return DEBUG_STATUS_NO_CHANGE;
        }
    }
};

struct ExceptionEventApcData : public AnyApcData
{
    ExceptionEventApcData()
        : AnyApcData(DEBUG_EVENT_EXCEPTION,
                     "IDebugEventCallbacks::Exception")
    {
    }
    
    PEXCEPTION_RECORD64 m_Record;
    ULONG m_FirstChance;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            Exception(m_Record, m_FirstChance);
    }
};

struct CreateThreadEventApcData : public AnyApcData
{
    CreateThreadEventApcData()
        : AnyApcData(DEBUG_EVENT_CREATE_THREAD,
                     "IDebugEventCallbacks::CreateThread")
    {
    }
    
    ULONG64 m_Handle;
    ULONG64 m_DataOffset;
    ULONG64 m_StartOffset;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            CreateThread(m_Handle, m_DataOffset, m_StartOffset);
    }
};

struct ExitThreadEventApcData : public AnyApcData
{
    ExitThreadEventApcData()
        : AnyApcData(DEBUG_EVENT_EXIT_THREAD,
                     "IDebugEventCallbacks::ExitThread")
    {
    }
    
    ULONG m_ExitCode;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            ExitThread(m_ExitCode);
    }
};

struct CreateProcessEventApcData : public AnyApcData
{
    CreateProcessEventApcData()
        : AnyApcData(DEBUG_EVENT_CREATE_PROCESS,
                     "IDebugEventCallbacks::CreateProcess")
    {
    }
    
    ULONG64 m_ImageFileHandle;
    ULONG64 m_Handle;
    ULONG64 m_BaseOffset;
    ULONG m_ModuleSize;
    PCSTR m_ModuleName;
    PCSTR m_ImageName;
    ULONG m_CheckSum;
    ULONG m_TimeDateStamp;
    ULONG64 m_InitialThreadHandle;
    ULONG64 m_ThreadDataOffset;
    ULONG64 m_StartOffset;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            CreateProcess(m_ImageFileHandle, m_Handle, m_BaseOffset,
                          m_ModuleSize, m_ModuleName, m_ImageName,
                          m_CheckSum, m_TimeDateStamp, m_InitialThreadHandle,
                          m_ThreadDataOffset, m_StartOffset);
    }
};

struct ExitProcessEventApcData : public AnyApcData
{
    ExitProcessEventApcData()
        : AnyApcData(DEBUG_EVENT_EXIT_PROCESS,
                     "IDebugEventCallbacks::ExitProcess")
    {
    }
    
    ULONG m_ExitCode;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            ExitProcess(m_ExitCode);
    }
};

struct LoadModuleEventApcData : public AnyApcData
{
    LoadModuleEventApcData()
        : AnyApcData(DEBUG_EVENT_LOAD_MODULE,
                     "IDebugEventCallbacks::LoadModule")
    {
    }
    
    ULONG64 m_ImageFileHandle;
    ULONG64 m_BaseOffset;
    ULONG m_ModuleSize;
    PCSTR m_ModuleName;
    PCSTR m_ImageName;
    ULONG m_CheckSum;
    ULONG m_TimeDateStamp;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            LoadModule(m_ImageFileHandle, m_BaseOffset, m_ModuleSize,
                       m_ModuleName, m_ImageName, m_CheckSum,
                       m_TimeDateStamp);
    }
};

struct UnloadModuleEventApcData : public AnyApcData
{
    UnloadModuleEventApcData()
        : AnyApcData(DEBUG_EVENT_UNLOAD_MODULE,
                     "IDebugEventCallbacks::UnloadModule")
    {
    }
    
    PCSTR m_ImageBaseName;
    ULONG64 m_BaseOffset;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            UnloadModule(m_ImageBaseName, m_BaseOffset);
    }
};

struct SystemErrorEventApcData : public AnyApcData
{
    SystemErrorEventApcData()
        : AnyApcData(DEBUG_EVENT_SYSTEM_ERROR,
                     "IDebugEventCallbacks::SystemError")
    {
    }
    
    ULONG m_Error;
    ULONG m_Level;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            SystemError(m_Error, m_Level);
    }
};

struct SessionStatusApcData : public AnyApcData
{
    SessionStatusApcData()
        : AnyApcData(DEBUG_EVENT_SESSION_STATUS,
                     "IDebugEventCallbacks::SessionStatus")
    {
    }
    
    ULONG m_Status;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            SessionStatus(m_Status);
    }
};

ULONG
ApcDispatch(DebugClient* Client, AnyApcData* ApcData, ULONG EventStatus)
{
    DBG_ASSERT(Client->m_EventCb != NULL);

    HRESULT Vote;

    __try
    {
        Vote = ApcData->Dispatch(Client);
    }
    __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                      NULL, ApcData->m_Name))
    {
        Vote = DEBUG_STATUS_NO_CHANGE;
    }
            
    return MergeVotes(EventStatus, Vote);
}

void APIENTRY
EventApc(ULONG_PTR Param)
{
    AnyApcData* ApcData = (AnyApcData*)Param;
    ULONG Tid = GetCurrentThreadId();
    DebugClient* Client;
    ULONG EventStatus = DEBUG_STATUS_NO_CHANGE;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_ThreadId == Tid &&
            (Client->m_EventInterest & ApcData->m_Mask))
        {
            EventStatus = ApcDispatch(Client, ApcData, EventStatus);
        }
    }

    if (WaitForSingleObject(g_EventStatusWaiting, EVENT_APC_TIMEOUT) !=
        WAIT_OBJECT_0)
    {
        ErrOut("Unable to wait for StatusWaiting, %d\n",
               GetLastError());
        EventStatus = WIN32_LAST_STATUS();
    }

    g_EventStatus = EventStatus;
    
    if (!SetEvent(g_EventStatusReady))
    {
        ErrOut("Unable to set StatusReady, %d\n",
               GetLastError());
        g_EventStatus = WIN32_LAST_STATUS();
    }
}

ULONG
SendEvent(AnyApcData* ApcData, ULONG EventStatus)
{
    DebugClient* Client;
    ULONG NumQueued = 0;
    ULONG TidDone = 0;
    static ULONG s_TidSending = 0;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        // Only queue one APC per thread regardless of how
        // many clients.  The APC function will deliver the
        // callback to all clients on that thread.
        if (Client->m_ThreadId != TidDone &&
            (Client->m_EventInterest & ApcData->m_Mask))
        {
            // SessionStatus callbacks are made at unusual
            // times so do not do full call preparation.
            if (TidDone == 0 &&
                ApcData->m_Mask != DEBUG_EVENT_SESSION_STATUS)
            {
                PrepareForCalls(DEBUG_STATUS_INSIDE_WAIT);
            }

            if (Client->m_ThreadId == GetCurrentThreadId())
            {
                // Don't hold the engine lock while the client
                // is called.
                SUSPEND_ENGINE();
                
                EventStatus = ApcDispatch(Client, ApcData, EventStatus);

                RESUME_ENGINE();
            }
            else if (QueueUserAPC(EventApc, Client->m_Thread,
                                  (ULONG_PTR)ApcData))
            {
                TidDone = Client->m_ThreadId;
                NumQueued++;
            }
            else
            {
                ErrOut("Unable to deliver callback, %d\n", GetLastError());
            }
        }
    }

    if (NumQueued == 0)
    {
        // No APCs queued.
        return EventStatus;
    }

    // This function's use of global data is only safe as
    // long as a single send is active at once.  Synchronous
    // sends are almost exclusively sent by the session thread
    // so competition to send is very rare, therefore we
    // don't really attempt to handle it.
    if (s_TidSending != 0)
    {
        return E_FAIL;
    }
    s_TidSending = GetCurrentThreadId();

    // Leave the lock while waiting.
    SUSPEND_ENGINE();
    
    while (NumQueued-- > 0)
    {
        if (!SetEvent(g_EventStatusWaiting))
        {
            // If the event can't be set everything is hosed
            // and threads may be stuck waiting so we
            // just panic.
            ErrOut("Unable to set StatusWaiting, %d\n",
                   GetLastError());
            EventStatus = WIN32_LAST_STATUS();
            break;
        }

        for (;;)
        {
            ULONG Wait;
            
            Wait = WaitForSingleObjectEx(g_EventStatusReady,
                                         EVENT_APC_TIMEOUT, TRUE);
            if (Wait == WAIT_OBJECT_0)
            {
                EventStatus = MergeVotes(EventStatus, g_EventStatus);
                break;
            }
            else if (Wait != WAIT_IO_COMPLETION)
            {
                ErrOut("Unable to wait for StatusReady, %d\n",
                       GetLastError());
                EventStatus = WIN32_LAST_STATUS();
                NumQueued = 0;
                break;
            }
        }
    }

    RESUME_ENGINE();
    s_TidSending = 0;
    return EventStatus;
}

//----------------------------------------------------------------------------
//
// Event callbacks.
//
//----------------------------------------------------------------------------

ULONG g_EngNotify;

ULONG
ExecuteEventCommand(ULONG EventStatus, DebugClient* Client, PCSTR Command)
{
    if (Command == NULL)
    {
        return EventStatus;
    }
    
    // Don't output any noise while processing event
    // command strings.
    BOOL OldOutReg = g_OciOutputRegs;
    g_OciOutputRegs = FALSE;

    PrepareForCalls(DEBUG_STATUS_INSIDE_WAIT);
    // Stop execution as soon as the execution status
    // changes.
    g_EngStatus |= ENG_STATUS_NO_AUTO_WAIT;
        
    Execute(Client, Command, DEBUG_EXECUTE_NOT_LOGGED);
        
    g_EngStatus &= ~ENG_STATUS_NO_AUTO_WAIT;
    g_OciOutputRegs = OldOutReg;

    // Translate the continuation status from
    // the state the engine was left in by the command.
    if (IS_RUNNING(g_CmdState))
    {
        // If the command left the engine running override
        // the incoming event status.  This allows a user
        // to create conditional commands that can resume
        // execution even when the basic setting may be to break.
        return g_ExecutionStatusRequest;
    }
    else
    {
        return EventStatus;
    }
}

HRESULT
NotifyBreakpointEvent(ULONG Vote, Breakpoint* Bp)
{
    ULONG EventStatus;

    // Processing of commands can delete breakpoints.
    // For example, 'g' will delete any go breakpoints.
    // Preserve this breakpoint as long as we need it.
    Bp->Preserve();
    
    g_LastEventType = DEBUG_EVENT_BREAKPOINT;
    g_LastEventInfo.Breakpoint.Id = Bp->m_Id;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.Breakpoint);
    sprintf(g_LastEventDesc, "Hit breakpoint %d", Bp->m_Id);
    
    // Execute breakpoint command first if one exists.
    if (Bp->m_Command != NULL)
    {
        EventStatus = ExecuteEventCommand(DEBUG_STATUS_NO_CHANGE,
                                          Bp->m_Adder, Bp->m_Command);
    }
    else
    {
        if ((Bp->m_Flags & (BREAKPOINT_HIDDEN |
                            DEBUG_BREAKPOINT_ADDER_ONLY)) == 0)
        {
            StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_PREFIX);
            dprintf("Breakpoint %u hit\n", Bp->m_Id);
        }
        
        EventStatus = DEBUG_STATUS_NO_CHANGE;
    }

    BreakpointEventApcData ApcData;
    ApcData.m_Bp = Bp;
    EventStatus = SendEvent(&ApcData, EventStatus);

    Bp->Relinquish();
    
    // If there weren't any votes default to breaking in.
    if (EventStatus == DEBUG_STATUS_NO_CHANGE)
    {
        EventStatus = DEBUG_STATUS_BREAK;
    }

    // Fold command status into votes from previous breakpoints.
    return MergeVotes(Vote, EventStatus);
}

void
ProcessVcppException(PEXCEPTION_RECORD64 Record)
{
    EXCEPTION_VISUALCPP_DEBUG_INFO64 Info64;
    EXCEPTION_VISUALCPP_DEBUG_INFO64* Info;

    SuspendExecution();
    if (!g_EventMachine ||
        !g_EventProcess)
    {
        return;
    }
    
    // If this is a 32-bit system we need to convert
    // back to a 32-bit exception record so that
    // we can properly reconstruct the info from
    // the arguments.
    if (!g_EventMachine->m_Ptr64)
    {
        EXCEPTION_RECORD32 Record32;
        EXCEPTION_VISUALCPP_DEBUG_INFO32* Info32;
        
        ExceptionRecord64To32(Record, &Record32);
        Info32 = (EXCEPTION_VISUALCPP_DEBUG_INFO32*)
            Record32.ExceptionInformation;
        Info = &Info64;
        Info->dwType = Info32->dwType;
        switch(Info->dwType)
        {
        case VCPP_DEBUG_SET_NAME:
            Info->SetName.szName = EXTEND64(Info32->SetName.szName);
            Info->SetName.dwThreadID = Info32->SetName.dwThreadID;
            Info->SetName.dwFlags = Info32->SetName.dwFlags;
            break;
        }
    }
    else
    {
        Info = (EXCEPTION_VISUALCPP_DEBUG_INFO64*)
            Record->ExceptionInformation;
    }

    ThreadInfo* Thread;
    
    switch(Info->dwType)
    {
    case VCPP_DEBUG_SET_NAME:
        if (Info->SetName.dwThreadID == -1)
        {
            Thread = g_EventThread;
        }
        else
        {
            Thread = g_EventProcess->
                FindThreadBySystemId(Info->SetName.dwThreadID);
        }
        if (Thread != NULL)
        {
            DWORD Read;
            
            if (g_EventTarget->ReadVirtual(g_EventProcess,
                                           Info->SetName.szName,
                                           Thread->m_Name,
                                           MAX_THREAD_NAME - 1,
                                           &Read) != S_OK)
            {
                Thread->m_Name[0] = 0;
            }
            else
            {
                Thread->m_Name[Read] = 0;
            }
        }
        break;
    }
}

ULONG
ProcessCommandException(ULONG EventStatus, PEXCEPTION_RECORD64 Record)
{
    if (Record->NumberParameters != 4 ||
        (ULONG)Record->ExceptionInformation[0] != DEBUG_COMMAND_EXCEPTION_ID ||
        Record->ExceptionInformation[1] < DEBUG_CMDEX_ADD_EVENT_STRING ||
        Record->ExceptionInformation[1] > DEBUG_CMDEX_RESET_EVENT_STRINGS)
    {
        // Malformed exception.
        return EventStatus;
    }

    switch(Record->ExceptionInformation[1])
    {
    case DEBUG_CMDEX_ADD_EVENT_STRING:
        if (Record->ExceptionInformation[2] > 0 &&
            Record->ExceptionInformation[2] < 0x100000)
        {
            EventString* Str = g_EventThread->
                AllocEventString((ULONG)Record->ExceptionInformation[2]);
            if (Str == NULL)
            {
                ErrOut("Unable to allocate event string\n");
                return DEBUG_STATUS_BREAK;
            }

            if (g_Target->
                ReadAllVirtual(g_EventProcess,
                               Record->ExceptionInformation[3],
                               Str->String,
                               (ULONG)Record->ExceptionInformation[2]) != S_OK)
            {
                ErrOut("Unable to read event string\n");
                return DEBUG_STATUS_BREAK;
            }

            Str->String[(ULONG)Record->ExceptionInformation[2]] = 0;
            g_EventThread->AppendEventString(Str);
        }
        break;
        
    case DEBUG_CMDEX_RESET_EVENT_STRINGS:
        if (Record->ExceptionInformation[2] == 0 &&
            Record->ExceptionInformation[3] == 0)
        {
            g_EventThread->ClearEventStrings();
        }
        break;
    }
    
    return EventStatus;
}

void
ProcessAssertException(PEXCEPTION_RECORD64 Record)
{
    char FileName[MAX_PATH];
    ULONG Line;
    char Text[2 * MAX_PATH];
    ImageInfo* Image;

    Image = g_EventProcess->FindImageByOffset(Record->ExceptionAddress, FALSE);
    if (!Image ||
        FAILED(Image->FindSysAssert(Record->ExceptionAddress,
                                    FileName, DIMA(FileName),
                                    &Line,
                                    Text, DIMA(Text))))
    {
        return;
    }

    dprintf("Assertion %s(%d): %s\n", FileName, Line, Text);
}

HRESULT
NotifyExceptionEvent(PEXCEPTION_RECORD64 Record,
                     ULONG FirstChance, BOOL OutputDone)
{
    ULONG EventStatus;
    EVENT_FILTER* Filter;
    EVENT_COMMAND* Command;
    PDEBUG_EXCEPTION_FILTER_PARAMETERS Params;
    BOOL FirstChanceMessage = FALSE;

    if (g_EventThread == NULL)
    {
        ErrOut("ERROR: Exception %X occurred on unknown thread %X\n",
               Record->ExceptionCode, g_EventThreadSysId);
    }
    
    g_LastEventType = DEBUG_EVENT_EXCEPTION;
    g_LastEventInfo.Exception.ExceptionRecord = *Record;
    g_LastEventInfo.Exception.FirstChance = FirstChance;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.Exception);

    if (Record->ExceptionCode == STATUS_VCPP_EXCEPTION)
    {
        // Handle special VC++ exceptions as they
        // pass information from the debuggee to the debugger.
        ProcessVcppException(Record);
    }

    Filter = GetSpecificExceptionFilter(Record->ExceptionCode);
    if (Filter == NULL)
    {
        // Use the default filter for name and handling.
        Filter = &g_EventFilters[FILTER_DEFAULT_EXCEPTION];
        GetOtherExceptionParameters(Record->ExceptionCode, TRUE,
                                    &Params, &Command);
    }
    else
    {
        Params = &Filter->Params;
        Command = &Filter->Command;
    }

    g_EngDefer |= ENG_DEFER_EXCEPTION_HANDLING;
    g_EventExceptionFilter = Params;
    g_ExceptionFirstChance = FirstChance;
    
    if (Params->ExecutionOption != DEBUG_FILTER_IGNORE)
    {
        if (!OutputDone)
        {
            StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_PREFIX);
            dprintf("%s%s", EventIdStr(), Filter->Name);
            if (Filter->OutArgFormat != NULL)
            {
                dprintf(Filter->OutArgFormat,
                        Record->ExceptionInformation[Filter->OutArgIndex]);
            }

            dprintf(" - code %08lx (%s)\n",
                    Record->ExceptionCode,
                    FirstChance ? "first chance" : "!!! second chance !!!");

            FirstChanceMessage = FirstChance != 0;
        }

        if (Params->ExecutionOption == DEBUG_FILTER_BREAK ||
            (Params->ExecutionOption == DEBUG_FILTER_SECOND_CHANCE_BREAK &&
             !FirstChance))
        {
            EventStatus = DEBUG_STATUS_BREAK;
        }
        else
        {
            EventStatus = DEBUG_STATUS_IGNORE_EVENT;
        }
    }
    else
    {
        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
    }

    strcpy(g_LastEventDesc, Filter->Name);
    if (Filter->OutArgFormat != NULL)
    {
        sprintf(g_LastEventDesc + strlen(g_LastEventDesc),
                Filter->OutArgFormat,
                Record->ExceptionInformation[Filter->OutArgIndex]);
    }
    sprintf(g_LastEventDesc + strlen(g_LastEventDesc),
            " - code %08lx (%s)",
            Record->ExceptionCode,
            FirstChance ? "first chance" : "!!! second chance !!!");

    if (g_EventThread && Record->ExceptionCode == DBG_COMMAND_EXCEPTION)
    {
        EventStatus = ProcessCommandException(EventStatus, Record);
    }
    
    // If this is the initial breakpoint execute the
    // initial breakpoint command.
    if ((g_EngStatus & ENG_STATUS_AT_INITIAL_BREAK) &&
        IS_EFEXECUTION_BREAK(g_EventFilters[DEBUG_FILTER_INITIAL_BREAKPOINT].
                             Params.ExecutionOption))
    {
        EventStatus = ExecuteEventCommand
            (EventStatus,
             g_EventFilters[DEBUG_FILTER_INITIAL_BREAKPOINT].Command.Client,
             g_EventFilters[DEBUG_FILTER_INITIAL_BREAKPOINT].
             Command.Command[0]);
    }
    
    EventStatus = ExecuteEventCommand(EventStatus,
                                      Command->Client,
                                      Command->Command[FirstChance ? 0 : 1]);
    
    ExceptionEventApcData ApcData;
    ApcData.m_Record = Record;
    ApcData.m_FirstChance = FirstChance;
    EventStatus = SendEvent(&ApcData, EventStatus);

    if (FirstChanceMessage && EventStatus == DEBUG_STATUS_BREAK)
    {
        // Show a verbose message for first-chance exceptions
        // to try and explain to users that they may not
        // necessarily be a problem.  Don't show the message
        // for hard-coded break instructions as those are
        // common and very rarely handled.
        if (Record->ExceptionCode != STATUS_BREAKPOINT &&
            Record->ExceptionCode != STATUS_WAKE_SYSTEM_DEBUGGER)
        {
            dprintf("First chance exceptions are reported "
                    "before any exception handling.\n");
            dprintf("This exception may be expected and handled.\n");
        }
    }

    return EventStatus;
}

HRESULT
NotifyCreateThreadEvent(ULONG64 Handle,
                        ULONG64 DataOffset,
                        ULONG64 StartOffset,
                        ULONG Flags)
{
    ProcessInfo* Process;
    
    StartOutLine(DEBUG_OUTPUT_VERBOSE, OUT_LINE_NO_PREFIX);
    VerbOut("*** Create thread %x:%x\n",
            g_EventProcessSysId, g_EventThreadSysId);

    if ((Process = g_EventTarget->
         FindProcessBySystemId(g_EventProcessSysId)) == NULL)
    {
        ErrOut("Unable to find system process %x\n", g_EventProcessSysId);

        if (g_EngNotify == 0)
        {
            // Put in a placeholder description to make it easy
            // to identify this case.
            g_LastEventType = DEBUG_EVENT_CREATE_THREAD;
            sprintf(g_LastEventDesc, "Create unowned thread %x for %x",
                    g_EventThreadSysId, g_EventProcessSysId);
        }
        
        // Can't really continue the notification.
        return DEBUG_STATUS_BREAK;
    }

    ThreadInfo* Thread;
    
    // There's a small window when attaching during process creation where
    // it's possible to get two create thread events for the
    // same thread.  Check and see if this process already has
    // a thread with the given ID and handle.
    // If a process attach times out and the process is examined,
    // there's a possibility that the attach may succeed later,
    // yielding events for processes and threads already created
    // by examination.  In that case just check for an ID match
    // as the handles will be different.

    ForProcessThreads(Process)
    {
        if (((Process->m_Flags & ENG_PROC_EXAMINED) ||
             Thread->m_Handle == Handle) &&
            Thread->m_SystemId == g_EventThreadSysId)
        {
            // We already know about this thread, just
            // ignore the event.
            if ((Process->m_Flags & ENG_PROC_EXAMINED) == 0)
            {
                WarnOut("WARNING: Duplicate thread create event for %x:%x\n",
                        g_EventProcessSysId, g_EventThreadSysId);
            }
            return DEBUG_STATUS_IGNORE_EVENT;
        }
    }
    
    Thread = new ThreadInfo(Process, g_EventThreadSysId,
                            DataOffset, Handle, Flags, StartOffset);
    if (Thread == NULL)
    {
        ErrOut("Unable to allocate thread record for create thread event\n");
        ErrOut("Thread %x:%x will be lost\n",
               g_EventProcessSysId, g_EventThreadSysId);

        if (g_EngNotify == 0)
        {
            // Put in a placeholder description to make it easy
            // to identify this case.
            g_LastEventType = DEBUG_EVENT_CREATE_THREAD;
            sprintf(g_LastEventDesc, "Can't create thread %x for %x",
                    g_EventThreadSysId, g_EventProcessSysId);
        }
        
        // Can't really continue the notification.
        return DEBUG_STATUS_BREAK;
    }
    
    // Look up infos now that they've been added.
    FindEventProcessThread();
    if (g_EventProcess == NULL || g_EventThread == NULL)
    {
        // This should never happen with the above failure
        // checks but handle it just in case.
        ErrOut("Create thread unable to locate process or thread %x:%x\n",
               g_EventProcessSysId, g_EventThreadSysId);
        return DEBUG_STATUS_BREAK;
    }

    VerbOut("Thread created: %lx.%lx\n",
            g_EventProcessSysId, g_EventThreadSysId);

    if (g_EngNotify > 0)
    {
        // This call is just to update internal thread state.
        // Do not make real callbacks.
        return DEBUG_STATUS_NO_CHANGE;
    }

    g_EventTarget->OutputProcessesAndThreads("*** Create thread ***");

    g_LastEventType = DEBUG_EVENT_CREATE_THREAD;
    sprintf(g_LastEventDesc, "Create thread %d:%x",
            g_EventThread->m_UserId, g_EventThreadSysId);
    
    // Always update breakpoints to account for the new thread.
    SuspendExecution();
    RemoveBreakpoints();
    g_UpdateDataBreakpoints = TRUE;
    g_DataBreakpointsChanged = TRUE;
    
    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_CREATE_THREAD];

    EventStatus =
        IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) ?
        DEBUG_STATUS_BREAK : DEBUG_STATUS_IGNORE_EVENT;
    
    EventStatus = ExecuteEventCommand(EventStatus,
                                      Filter->Command.Client,
                                      Filter->Command.Command[0]);
    
    CreateThreadEventApcData ApcData;
    ApcData.m_Handle = Handle;
    ApcData.m_DataOffset = DataOffset;
    ApcData.m_StartOffset = StartOffset;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifyExitThreadEvent(ULONG ExitCode)
{
    StartOutLine(DEBUG_OUTPUT_VERBOSE, OUT_LINE_NO_PREFIX);
    VerbOut("*** Exit thread\n");

    g_EngDefer |= ENG_DEFER_DELETE_EXITED;
    // There's a small possibility that exit events can
    // be delivered when the engine is not expecting them.
    // When attaching to a process that's exiting it's possible
    // to get an exit but no create.  When restarting it's
    // possible that not all events were successfully drained.
    // Protect this code from faulting in that case.
    if (g_EventThread == NULL)
    {
        WarnOut("WARNING: Unknown thread exit: %lx.%lx\n",
                g_EventProcessSysId, g_EventThreadSysId);
    }
    else
    {
        g_EventThread->m_Exited = TRUE;
    }
    VerbOut("Thread exited: %lx.%lx, code %X\n",
            g_EventProcessSysId, g_EventThreadSysId, ExitCode);

    g_LastEventType = DEBUG_EVENT_EXIT_THREAD;
    g_LastEventInfo.ExitThread.ExitCode = ExitCode;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.ExitThread);
    if (g_EventThread == NULL)
    {
        sprintf(g_LastEventDesc, "Exit thread ???:%x, code %X",
                g_EventThreadSysId, ExitCode);
    }
    else
    {
        sprintf(g_LastEventDesc, "Exit thread %d:%x, code %X",
                g_EventThread->m_UserId, g_EventThreadSysId, ExitCode);
    }
    
    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_EXIT_THREAD];

    EventStatus =
        IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) ?
        DEBUG_STATUS_BREAK : DEBUG_STATUS_IGNORE_EVENT;

    // If we were stepping on this thread then force a breakin
    // so it's clear to the user that the thread exited.
    if (g_EventThread != NULL &&
        (g_StepTraceBp->m_Flags & DEBUG_BREAKPOINT_ENABLED) &&
        (g_StepTraceBp->m_MatchThread == g_EventThread ||
         g_DeferBp->m_MatchThread == g_EventThread))
    {
        WarnOut("WARNING: Step/trace thread exited\n");
        g_WatchFunctions.End(NULL);
        EventStatus = DEBUG_STATUS_BREAK;
        // Ensure that p/t isn't repeated.
        g_LastCommand[0] = 0;
    }
    
    EventStatus = ExecuteEventCommand(EventStatus,
                                      Filter->Command.Client,
                                      Filter->Command.Command[0]);
    
    ExitThreadEventApcData ApcData;
    ApcData.m_ExitCode = ExitCode;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifyCreateProcessEvent(ULONG64 ImageFileHandle,
                         HANDLE SymHandle,
                         ULONG64 SysHandle,
                         ULONG64 BaseOffset,
                         ULONG ModuleSize,
                         PSTR ModuleName,
                         PSTR ImageName,
                         ULONG CheckSum,
                         ULONG TimeDateStamp,
                         ULONG64 InitialThreadHandle,
                         ULONG64 ThreadDataOffset,
                         ULONG64 StartOffset,
                         ULONG Flags,
                         ULONG Options,
                         ULONG InitialThreadFlags,
                         BOOL QueryImageInfo,
                         ULONG64 ImageNameOffset,
                         BOOL ImageNameUnicode)
{
    CHAR NameBuffer[MAX_IMAGE_PATH];
    char ModuleNameBuffer[MAX_MODULE];
    
    StartOutLine(DEBUG_OUTPUT_VERBOSE, OUT_LINE_NO_PREFIX);
    VerbOut("*** Create process %x\n", g_EventProcessSysId);

    ProcessInfo* Process;
    
    // If a process attach times out and the process is examined,
    // there's a possibility that the attach may succeed later,
    // yielding events for processes and threads already created
    // by examination.  In that case just check for an ID match
    // as the handles will be different.

    ForTargetProcesses(g_EventTarget)
    {
        if (((Process->m_Flags & ENG_PROC_EXAMINED) ||
             Process->m_SysHandle == SysHandle) &&
            Process->m_SystemId == g_EventProcessSysId)
        {
            // We already know about this process, just
            // ignore the event.
            if ((Process->m_Flags & ENG_PROC_EXAMINED) == 0)
            {
                WarnOut("WARNING: Duplicate process create event for %x\n",
                        g_EventProcessSysId);
            }
            return DEBUG_STATUS_IGNORE_EVENT;
        }
    }

    ThreadInfo* Thread;
    
    Process = new ProcessInfo(g_EventTarget, g_EventProcessSysId,
                              SymHandle, SysHandle, Flags, Options);
    if (Process)
    {
        Thread = new ThreadInfo(Process, g_EventThreadSysId,
                                ThreadDataOffset, InitialThreadHandle,
                                InitialThreadFlags, StartOffset);
    }
    else
    {
        Thread = NULL;
    }

    if (!Process || !Thread)
    {
        // Clean up the process in case one was created.
        delete Process;
        
        ErrOut("Unable to allocate process record for create process event\n");
        ErrOut("Process %x will be lost\n", g_EventProcessSysId);

        if (g_EngNotify == 0)
        {
            // Put in a placeholder description to make it easy
            // to identify this case.
            g_LastEventType = DEBUG_EVENT_CREATE_PROCESS;
            sprintf(g_LastEventDesc, "Can't create process %x",
                    g_EventProcessSysId);
        }
        
        // Can't really continue the notification.
        return DEBUG_STATUS_BREAK;
    }
    
    // Look up infos now that they've been added.
    FindEventProcessThread();
    if (g_EventProcess == NULL || g_EventThread == NULL)
    {
        // This should never happen with the above failure
        // checks but handle it just in case.
        ErrOut("Create process unable to locate process or thread %x:%x\n",
               g_EventProcessSysId, g_EventThreadSysId);
        return DEBUG_STATUS_BREAK;
    }

    VerbOut("Process created: %lx.%lx\n",
            g_EventProcessSysId, g_EventThreadSysId);

    if (g_EngNotify > 0)
    {
        // This call is just to update internal process state.
        // Do not make real callbacks.
        g_EventTarget->m_ProcessesAdded = TRUE;
        return DEBUG_STATUS_NO_CHANGE;
    }
    
    g_EventTarget->OutputProcessesAndThreads("*** Create process ***");

    g_LastEventType = DEBUG_EVENT_CREATE_PROCESS;
    sprintf(g_LastEventDesc, "Create process %d:%x",
            g_EventProcess->m_UserId, g_EventProcessSysId);
    
    // Simulate a load module event for the process but do
    // not send it to the client.
    g_EngNotify++;
    
    if (QueryImageInfo)
    {
        GetEventName(ImageFileHandle, BaseOffset,
                     ImageNameOffset, (WORD)ImageNameUnicode,
                     NameBuffer, sizeof(NameBuffer));
        GetHeaderInfo(g_EventProcess, BaseOffset,
                      &CheckSum, &TimeDateStamp, &ModuleSize);
        CreateModuleNameFromPath(NameBuffer, ModuleNameBuffer);
        ImageName = NameBuffer;
        ModuleName = ModuleNameBuffer;
    }

    NotifyLoadModuleEvent(ImageFileHandle, BaseOffset, ModuleSize,
                          ModuleName, ImageName, CheckSum, TimeDateStamp,
                          IS_USER_TARGET(g_EventTarget));
    
    g_EngNotify--;

    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_CREATE_PROCESS];
    BOOL MatchesEvent;

    MatchesEvent = BreakOnThisImageTail(ImageName, Filter->Argument);

    EventStatus =
        (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
         MatchesEvent) ?
        DEBUG_STATUS_BREAK : DEBUG_STATUS_IGNORE_EVENT;

    if (MatchesEvent)
    {
        EventStatus = ExecuteEventCommand(EventStatus,
                                          Filter->Command.Client,
                                          Filter->Command.Command[0]);
    }
    
    g_EventTarget->m_ProcessesAdded = TRUE;
    
    CreateProcessEventApcData ApcData;
    ApcData.m_ImageFileHandle = ImageFileHandle;
    ApcData.m_Handle = SysHandle;
    ApcData.m_BaseOffset = BaseOffset;
    ApcData.m_ModuleSize = ModuleSize;
    ApcData.m_ModuleName = ModuleName;
    ApcData.m_ImageName = ImageName;
    ApcData.m_CheckSum = CheckSum;
    ApcData.m_TimeDateStamp = TimeDateStamp;
    ApcData.m_InitialThreadHandle = InitialThreadHandle;
    ApcData.m_ThreadDataOffset = ThreadDataOffset;
    ApcData.m_StartOffset = StartOffset;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifyExitProcessEvent(ULONG ExitCode)
{
    StartOutLine(DEBUG_OUTPUT_VERBOSE, OUT_LINE_NO_PREFIX);
    VerbOut("*** Exit process\n");
    
    g_EngDefer |= ENG_DEFER_DELETE_EXITED;
    // There's a small possibility that exit events can
    // be delivered when the engine is not expecting them.
    // When attaching to a process that's exiting it's possible
    // to get an exit but no create.  When restarting it's
    // possible that not all events were successfully drained.
    // Protect this code from faulting in that case.
    if (g_EventProcess == NULL)
    {
        WarnOut("WARNING: Unknown process exit: %lx.%lx\n",
                g_EventProcessSysId, g_EventThreadSysId);
    }
    else
    {
        g_EventProcess->m_Exited = TRUE;
    }
    VerbOut("Process exited: %lx.%lx, code %X\n",
            g_EventProcessSysId, g_EventThreadSysId, ExitCode);

    g_LastEventType = DEBUG_EVENT_EXIT_PROCESS;
    g_LastEventInfo.ExitProcess.ExitCode = ExitCode;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.ExitProcess);
    if (g_EventProcess == NULL)
    {
        sprintf(g_LastEventDesc, "Exit process ???:%x, code %X",
                g_EventProcessSysId, ExitCode);
    }
    else
    {
        sprintf(g_LastEventDesc, "Exit process %d:%x, code %X",
                g_EventProcess->m_UserId, g_EventProcessSysId, ExitCode);
    }
    
    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_EXIT_PROCESS];
    BOOL MatchesEvent;

    if (g_EventProcess && g_EventProcess->m_ExecutableImage)
    {
        MatchesEvent =
            BreakOnThisImageTail(g_EventProcess->m_ExecutableImage->
                                 m_ImagePath, Filter->Argument);
    }
    else
    {
        // If this process doesn't have a specific name always break.
        MatchesEvent = TRUE;
    }
    
    EventStatus =
        ((g_EngOptions & DEBUG_ENGOPT_FINAL_BREAK) ||
         (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
          MatchesEvent)) ?
        DEBUG_STATUS_BREAK : DEBUG_STATUS_IGNORE_EVENT;

    if (MatchesEvent)
    {
        EventStatus = ExecuteEventCommand(EventStatus,
                                          Filter->Command.Client,
                                          Filter->Command.Command[0]);
    }
    
    ExitProcessEventApcData ApcData;
    ApcData.m_ExitCode = ExitCode;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifyLoadModuleEvent(ULONG64 ImageFileHandle,
                      ULONG64 BaseOffset,
                      ULONG ModuleSize,
                      PSTR ModuleName,
                      PSTR ImagePathName,
                      ULONG CheckSum,
                      ULONG TimeDateStamp,
                      BOOL UserMode)
{
    if (!g_EventProcess)
    {
        ErrOut("ERROR: Module load event for unknown process\n");
        
        if (g_EngNotify == 0)
        {
            // Put in a placeholder description to make it easy
            // to identify this case.
            g_LastEventType = DEBUG_EVENT_LOAD_MODULE;
            sprintf(g_LastEventDesc, "Ignored load module at %s",
                    FormatAddr64(BaseOffset));
        }

        return DEBUG_STATUS_BREAK;
    }

    MODULE_INFO_ENTRY ModEntry = {0};
    ImageInfo* ImageEntry;

    ModEntry.NamePtr       = ImagePathName;
    ModEntry.File          = (HANDLE)ImageFileHandle;
    ModEntry.Base          = BaseOffset;
    ModEntry.Size          = ModuleSize;
    ModEntry.CheckSum      = CheckSum;
    ModEntry.ModuleName    = ModuleName;
    ModEntry.TimeDateStamp = TimeDateStamp;
    ModEntry.UserMode      = UserMode ? TRUE : FALSE;

    if (g_EventProcess->AddImage(&ModEntry, FALSE, &ImageEntry) != S_OK)
    {
        ImageEntry = NULL;
    }

    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_LOAD_MODULE];

    //
    // ntsd has always shown mod loads by default.
    //

    if (IS_USER_TARGET(g_EventTarget))
    {
        //if (Filter->Params.ExecutionOption == DEBUG_FILTER_OUTPUT)
        {
            StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_PREFIX);
            dprintf("ModLoad: %s %s   %-8s\n",
                    FormatAddr64(BaseOffset),
                    FormatAddr64(BaseOffset + ModuleSize),
                    ImagePathName);
        }
    }

    g_EventTarget->OutputProcessesAndThreads("*** Load dll ***");

    if (g_EngNotify > 0)
    {
        g_EventProcess->m_ModulesLoaded = TRUE;
        return DEBUG_STATUS_IGNORE_EVENT;
    }
    
    g_LastEventType = DEBUG_EVENT_LOAD_MODULE;
    g_LastEventInfo.LoadModule.Base = BaseOffset;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.LoadModule);
    PrintString(g_LastEventDesc, DIMA(g_LastEventDesc),
                "Load module %.*s at %s",
                MAX_IMAGE_PATH - 32, ImagePathName, FormatAddr64(BaseOffset));
    
    ULONG EventStatus;
    BOOL MatchesEvent;

    if (!g_EventProcess->m_ModulesLoaded)
    {
        g_EngStatus |= ENG_STATUS_AT_INITIAL_MODULE_LOAD;
    }
    
    MatchesEvent = BreakOnThisImageTail(ImagePathName, Filter->Argument);
    
    if ((IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
         MatchesEvent) ||
        ((g_EngOptions & DEBUG_ENGOPT_INITIAL_MODULE_BREAK) &&
         !g_EventProcess->m_ModulesLoaded))
    {
        EventStatus = DEBUG_STATUS_BREAK;
    }
    else
    {
        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
    }

    // If this is the very first module load give breakpoints
    // a chance to get established.  Execute the initial
    // module command if there is one.
    if (g_EngStatus & ENG_STATUS_AT_INITIAL_MODULE_LOAD)
    {
        // On NT4 boot the breakpoint update and context management caused
        // by this seems to hit the system at a fragile time and
        // usually causes a bugcheck 50, so don't do it.  Win2K seems
        // to be able to handle it, so allow it there.
        if (IS_USER_TARGET(g_EventTarget) ||
            g_EventTarget->m_ActualSystemVersion != NT_SVER_NT4)
        {
            SuspendExecution();
            RemoveBreakpoints();
            
            if (IS_EFEXECUTION_BREAK(g_EventFilters
                                     [DEBUG_FILTER_INITIAL_MODULE_LOAD].
                                     Params.ExecutionOption))
            {
                EventStatus = ExecuteEventCommand
                    (EventStatus,
                     g_EventFilters[DEBUG_FILTER_INITIAL_MODULE_LOAD].
                     Command.Client,
                     g_EventFilters[DEBUG_FILTER_INITIAL_MODULE_LOAD].
                     Command.Command[0]);
            }
        }
    }

    if (MatchesEvent)
    {
        EventStatus = ExecuteEventCommand(EventStatus,
                                          Filter->Command.Client,
                                          Filter->Command.Command[0]);
    }
    
    g_EventProcess->m_ModulesLoaded = TRUE;

    LoadModuleEventApcData ApcData;
    ApcData.m_ImageFileHandle = ImageFileHandle;
    ApcData.m_BaseOffset = BaseOffset;
    ApcData.m_ModuleSize = ModuleSize;
    ApcData.m_ModuleName = ModuleName;
    ApcData.m_ImageName = ImagePathName;
    ApcData.m_CheckSum = CheckSum;
    ApcData.m_TimeDateStamp = TimeDateStamp;
    EventStatus = SendEvent(&ApcData, EventStatus);

    if (EventStatus > DEBUG_STATUS_GO_NOT_HANDLED &&
        EventStatus < DEBUG_STATUS_IGNORE_EVENT &&
        IS_KERNEL_TARGET(g_EventTarget) &&
        g_EventTarget->m_ActualSystemVersion == NT_SVER_NT4)
    {
        WarnOut("WARNING: Any modification to state may cause bugchecks.\n");
        WarnOut("         The debugger will not write "
                "any register changes.\n");
    }
    
    return EventStatus;
}

HRESULT
NotifyUnloadModuleEvent(PCSTR ImageBaseName,
                        ULONG64 BaseOffset)
{
    ImageInfo* Image = NULL;
    
    if (!g_EventProcess)
    {
        ErrOut("ERROR: Module unload event for unknown process\n");
        
        if (g_EngNotify == 0)
        {
            // Put in a placeholder description to make it easy
            // to identify this case.
            g_LastEventType = DEBUG_EVENT_UNLOAD_MODULE;
            sprintf(g_LastEventDesc, "Ignored unload module at %s",
                    FormatAddr64(BaseOffset));
        }

        return DEBUG_STATUS_BREAK;
    }
        
    // First try to look up the image by the base offset
    // as that's the most reliable identifier.
    if (BaseOffset)
    {
        Image = g_EventProcess->FindImageByOffset(BaseOffset, FALSE);
    }

    // Next try to look up the image by the full name given.
    if (!Image && ImageBaseName)
    {
        Image = g_EventProcess->FindImageByName(ImageBaseName, 0,
                                                INAME_IMAGE_PATH, FALSE);

        // Finally try to look up the image by the tail of the name given.
        if (!Image)
        {
            Image = g_EventProcess->FindImageByName(PathTail(ImageBaseName), 0,
                                                    INAME_IMAGE_PATH_TAIL,
                                                    FALSE);
        }
    }

    if (Image)
    {
        ImageBaseName = Image->m_ImagePath;
        BaseOffset = Image->m_BaseOfImage;
        Image->m_Unloaded = TRUE;
        g_EngDefer |= ENG_DEFER_DELETE_EXITED;
    }
    
    g_LastEventType = DEBUG_EVENT_UNLOAD_MODULE;
    g_LastEventInfo.UnloadModule.Base = BaseOffset;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.UnloadModule);
    PrintString(g_LastEventDesc, DIMA(g_LastEventDesc),
                "Unload module %.*s at %s",
                MAX_IMAGE_PATH - 32,
                ImageBaseName ? ImageBaseName : "<not found>",
                FormatAddr64(BaseOffset));
    
    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_UNLOAD_MODULE];
    BOOL MatchesEvent;

    if (Filter->Params.ExecutionOption == DEBUG_FILTER_OUTPUT)
    {
        StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_PREFIX);
        dprintf("%s\n", g_LastEventDesc);
    }

    MatchesEvent = BreakOnThisDllUnload(BaseOffset);
    
    if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
        MatchesEvent)
    {
        EventStatus = DEBUG_STATUS_BREAK;
    }
    else
    {
        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
    }

    if (MatchesEvent)
    {
        EventStatus = ExecuteEventCommand(EventStatus,
                                          Filter->Command.Client,
                                          Filter->Command.Command[0]);
    }
    
    UnloadModuleEventApcData ApcData;
    ApcData.m_ImageBaseName = ImageBaseName;
    ApcData.m_BaseOffset = BaseOffset;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifySystemErrorEvent(ULONG Error,
                       ULONG Level)
{
    g_LastEventType = DEBUG_EVENT_SYSTEM_ERROR;
    g_LastEventInfo.SystemError.Error = Error;
    g_LastEventInfo.SystemError.Level = Level;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.SystemError);
    sprintf(g_LastEventDesc, "System error %d.%d",
            Error, Level);
    
    if (Level <= g_SystemErrorOutput)
    {
        char ErrorString[_MAX_PATH];
        va_list Args;

        StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_PREFIX);
        dprintf("%s%s - %s: ",
                EventIdStr(),
                Level == SLE_WARNING ?
                "WARNING" : "ERROR", g_EventProcess->m_ImageHead->m_ImagePath);

        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                      FORMAT_MESSAGE_IGNORE_INSERTS,
                      NULL,
                      Error,
                      0,
                      ErrorString,
                      sizeof(ErrorString),
                      &Args);

        dprintf("%s", ErrorString);
    }
    
    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_SYSTEM_ERROR];

    if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) ||
        Level <= g_SystemErrorBreak)
    {
        EventStatus = DEBUG_STATUS_BREAK;
    }
    else
    {
        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
    }

    EventStatus = ExecuteEventCommand(EventStatus,
                                      Filter->Command.Client,
                                      Filter->Command.Command[0]);
    
    SystemErrorEventApcData ApcData;
    ApcData.m_Error = Error;
    ApcData.m_Level = Level;
    return SendEvent(&ApcData, EventStatus);
}
    
HRESULT
NotifySessionStatus(ULONG Status)
{
    SessionStatusApcData ApcData;
    ApcData.m_Status = Status;
    return SendEvent(&ApcData, DEBUG_STATUS_NO_CHANGE);
}

void
NotifyChangeDebuggeeState(ULONG Flags, ULONG64 Argument)
{
    if (g_EngNotify > 0)
    {
        // Notifications are being suppressed.
        return;
    }
    
    DebugClient* Client;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_EventInterest & DEBUG_EVENT_CHANGE_DEBUGGEE_STATE)
        {
            HRESULT Status;
            
            DBG_ASSERT(Client->m_EventCb != NULL);

            __try
            {
                Status = Client->m_EventCb->
                    ChangeDebuggeeState(Flags, Argument);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugEventCallbacks::"
                                              "ChangeDebuggeeState"))
            {
                Status = E_FAIL;
            }

            if (HRESULT_FACILITY(Status) == FACILITY_RPC)
            {
                Client->Destroy();
            }
        }
    }
}

void
NotifyChangeEngineState(ULONG Flags, ULONG64 Argument, BOOL HaveEngineLock)
{
    if (g_EngNotify > 0)
    {
        // Notifications are being suppressed.
        return;
    }

    DebugClient* Client;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_EventInterest & DEBUG_EVENT_CHANGE_ENGINE_STATE)
        {
            HRESULT Status;
            
            DBG_ASSERT(Client->m_EventCb != NULL);

            __try
            {
                Status = Client->m_EventCb->
                    ChangeEngineState(Flags, Argument);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugEventCallbacks::"
                                              "ChangeEngineState"))
            {
                Status = E_FAIL;
            }

            if (HRESULT_FACILITY(Status) == FACILITY_RPC)
            {
                Client->Destroy();
            }
        }
    }
}

void
NotifyChangeSymbolState(ULONG Flags, ULONG64 Argument, ProcessInfo* Process)
{
    if (g_EngNotify > 0)
    {
        // Notifications are being suppressed.
        return;
    }

    if ((Flags & (DEBUG_CSS_LOADS | DEBUG_CSS_UNLOADS)) &&
        Process)
    {
        // Reevaluate any offset expressions to account
        // for the change in symbols.
        EvaluateOffsetExpressions(Process, Flags);
    }
    
    DebugClient* Client;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_EventInterest & DEBUG_EVENT_CHANGE_SYMBOL_STATE)
        {
            HRESULT Status;
            
            DBG_ASSERT(Client->m_EventCb != NULL);

            __try
            {
                Status = Client->m_EventCb->
                    ChangeSymbolState(Flags, Argument);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugEventCallbacks::"
                                              "ChangeSymbolState"))
            {
                Status = E_FAIL;
            }

            if (HRESULT_FACILITY(Status) == FACILITY_RPC)
            {
                Client->Destroy();
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Input callbacks.
//
//----------------------------------------------------------------------------

//
// IMPORTANT: GetInput may be called in the middle of an operation.
// For example, an extension command may request input, so the engine
// is still in the middle of processing that command
// text.  Nothing in the engine should change at this point but
// it's necessary to suspend the engine lock to allow new
// connections and processing while waiting.  In theory
// all write operations should be prevented if g_InputNesting >= 1,
// indicating an input wait.  Right now key
// methods like WaitForEvent and Execute have such checks,
// but all writes should have them.  If you see problems
// with GetInput it might indicate a need for more checks.
//
ULONG g_InputNesting;

ULONG
GetInput(PCSTR Prompt,
         PSTR Buffer,
         ULONG BufferSize,
         ULONG Flags)
{
    DebugClient* Client;
    ULONG Len;
    HRESULT Status;

    // Start a new sequence for this input.
    g_InputSequence = 0;
    g_InputSizeRequested = BufferSize;
    g_InputNesting++;
    
    if (Prompt != NULL && Prompt[0] != 0)
    {
        dprintf("%s", Prompt);
    }

    SUSPEND_ENGINE();
    
    // Begin the input process by notifying all
    // clients with input callbacks that input
    // is needed.
    
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        // Update the input sequence for all clients so that
        // clients that don't have input callbacks can still
        // return input.  This is necessary in some threading cases.
        // This must occur before any callbacks are called as
        // the callbacks may use a different client for
        // ReturnInput.
        Client->m_InputSequence = 1;
    }
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_InputCb != NULL)
        {
            __try
            {
                Status = Client->m_InputCb->StartInput(BufferSize);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugInputCallbacks::"
                                              "StartInput"))
            {
                Status = E_FAIL;
            }

            if (Status != S_OK)
            {
                if (HRESULT_FACILITY(Status) == FACILITY_RPC)
                {
                    Client->Destroy();
                }
                else
                {
                    Len = 0;
                    ErrOut("Client %N refused StartInput, 0x%X\n",
                           Client, Status);
                    goto End;
                }
            }
        }
    }

    // Wait for input to be returned.
    if (WaitForSingleObject(g_InputEvent, INFINITE) != WAIT_OBJECT_0)
    {
        Len = 0;
        Status = WIN32_LAST_STATUS();
        ErrOut("Input event wait failed, 0x%X\n", Status);
    }
    else
    {
        ULONG CopyLen;
        
        Len = strlen(g_InputBuffer) + 1;
        CopyLen = min(Len, BufferSize);
        memcpy(Buffer, g_InputBuffer, CopyLen);
        Buffer[BufferSize - 1] = 0;
    }
    
 End:
    RESUME_ENGINE();
    
    g_InputSizeRequested = 0;
    g_InputNesting--;
    
    // Notify all clients that input process is done.
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_InputCb != NULL)
        {
            __try
            {
                Client->m_InputCb->EndInput();
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugInputCallbacks::"
                                              "EndInput"))
            {
            }
        }
    }
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        Client->m_InputSequence = 0xffffffff;
    }

    if (Len &&
        (Flags & GETIN_LOG_INPUT) &&
        g_LogFile >= 0)
    {
        ULONG BufLen = strlen(Buffer);
        if (BufLen)
        {
            _write(g_LogFile, Buffer, BufLen);
        }
        if (Flags & GETIN_LOG_INPUT_ADD_NEW_LINE)
        {
            _write(g_LogFile, "\n", 1);
        }
    }
        
    return Len;
}

//----------------------------------------------------------------------------
//
// Output callbacks.
//
//----------------------------------------------------------------------------

char g_OutBuffer[OUT_BUFFER_SIZE], g_FormatBuffer[OUT_BUFFER_SIZE];

char g_OutFilterPattern[MAX_IMAGE_PATH];
BOOL g_OutFilterResult = TRUE;

ULONG g_AllOutMask;

// Don't split up entries if they'll result in data so
// small that the extra callbacks are worse than the wasted space.
#define MIN_HISTORY_ENTRY_SIZE (256 + sizeof(OutHistoryEntryHeader))

PSTR g_OutHistory;
ULONG g_OutHistoryActualSize;
ULONG g_OutHistoryRequestedSize = 512 * 1024;
ULONG g_OutHistWriteMask;
OutHistoryEntry g_OutHistRead, g_OutHistWrite;
ULONG g_OutHistoryMask;
ULONG g_OutHistoryUsed;

ULONG g_OutputControl = DEBUG_OUTCTL_ALL_CLIENTS;
DebugClient* g_OutputClient;
BOOL g_BufferOutput;

#define BUFFERED_OUTPUT_SIZE 1024

// Largest delay allowed in TimedFlushCallbacks, in ticks.
#define MAX_FLUSH_DELAY 250

ULONG g_BufferedOutputMask;
char g_BufferedOutput[BUFFERED_OUTPUT_SIZE];
ULONG g_BufferedOutputUsed;
ULONG g_LastFlushTicks;

BOOL g_PartialOutputLine;
ULONG g_LastOutputMask;

void
CollectOutMasks(void)
{
    DebugClient* Client;

    g_AllOutMask = 0;
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_OutputCb != NULL)
        {
            g_AllOutMask |= Client->m_OutMask;
        }
    }
}

BOOL
PushOutCtl(ULONG OutputControl, DebugClient* Client,
           OutCtlSave* Save)
{
    BOOL Status;

    FlushCallbacks();
    
    Save->OutputControl = g_OutputControl;
    Save->Client = g_OutputClient;
    Save->BufferOutput = g_BufferOutput;
    Save->OutputWidth = g_OutputWidth;
    Save->OutputLinePrefix = g_OutputLinePrefix;

    if (OutputControl == DEBUG_OUTCTL_AMBIENT)
    {
        // Leave settings unchanged.
        Status = TRUE;
    }
    else
    {
        ULONG SendMask = OutputControl & DEBUG_OUTCTL_SEND_MASK;
    
        if (
#if DEBUG_OUTCTL_THIS_CLIENT > 0
            SendMask < DEBUG_OUTCTL_THIS_CLIENT ||
#endif
            SendMask > DEBUG_OUTCTL_LOG_ONLY ||
            (OutputControl & ~(DEBUG_OUTCTL_SEND_MASK |
                               DEBUG_OUTCTL_NOT_LOGGED |
                               DEBUG_OUTCTL_OVERRIDE_MASK)))
        {
            Status = FALSE;
        }
        else
        {
            g_OutputControl = OutputControl;
            g_OutputClient = Client;
            g_BufferOutput = TRUE;
            if (Client != NULL)
            {
                g_OutputWidth = Client->m_OutputWidth;
                g_OutputLinePrefix = Client->m_OutputLinePrefix;
            }
            Status = TRUE;
        }
    }

    return Status;
}

void
PopOutCtl(OutCtlSave* Save)
{
    FlushCallbacks();
    g_OutputControl = Save->OutputControl;
    g_OutputClient = Save->Client;
    g_BufferOutput = Save->BufferOutput;
    g_OutputWidth = Save->OutputWidth;
    g_OutputLinePrefix = Save->OutputLinePrefix;
}

void
SendOutput(ULONG Mask, PCSTR Text)
{
    ULONG OutTo = g_OutputControl & DEBUG_OUTCTL_SEND_MASK;
    HRESULT Status;

    if (OutTo == DEBUG_OUTCTL_THIS_CLIENT)
    {
        if (g_OutputClient->m_OutputCb != NULL &&
            ((g_OutputControl & DEBUG_OUTCTL_OVERRIDE_MASK) ||
             (Mask & g_OutputClient->m_OutMask)))
        {
            __try
            {
                Status = g_OutputClient->m_OutputCb->Output(Mask, Text);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugOutputCallbacks::"
                                              "Output"))
            {
                Status = E_FAIL;
            }

            if (HRESULT_FACILITY(Status) == FACILITY_RPC)
            {
                g_OutputClient->Destroy();
            }
        }
    }
    else
    {
        DebugClient* Client;

        for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
        {
            if ((OutTo == DEBUG_OUTCTL_ALL_CLIENTS ||
                 Client != g_OutputClient) &&
                Client->m_OutputCb != NULL &&
                ((g_OutputControl & DEBUG_OUTCTL_OVERRIDE_MASK) ||
                 (Client->m_OutMask & Mask)))
            {
                __try
                {
                    Status = Client->m_OutputCb->Output(Mask, Text);
                }
                __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                                  NULL,
                                                  "IDebugOutputCallbacks::"
                                                  "Output"))
                {
                    Status = E_FAIL;
                }

                if (HRESULT_FACILITY(Status) == FACILITY_RPC)
                {
                    Client->Destroy();
                }
            }
        }
    }
}

void
BufferOutput(ULONG Mask, PCSTR Text, ULONG Len)
{
    EnterCriticalSection(&g_QuickLock);

    if (Mask != g_BufferedOutputMask ||
        g_BufferedOutputUsed + Len >= BUFFERED_OUTPUT_SIZE)
    {
        FlushCallbacks();

        if (Len >= BUFFERED_OUTPUT_SIZE)
        {
            SendOutput(Mask, Text);
            LeaveCriticalSection(&g_QuickLock);
            return;
        }

        g_BufferedOutputMask = Mask;
    }

    memcpy(g_BufferedOutput + g_BufferedOutputUsed, Text, Len + 1);
    g_BufferedOutputUsed += Len;
    
    LeaveCriticalSection(&g_QuickLock);
}

void
FlushCallbacks(void)
{
    EnterCriticalSection(&g_QuickLock);
    
    if (g_BufferedOutputUsed > 0)
    {
        SendOutput(g_BufferedOutputMask, g_BufferedOutput);
        g_BufferedOutputMask = 0;
        g_BufferedOutputUsed = 0;
        g_LastFlushTicks = GetTickCount();
    }

    LeaveCriticalSection(&g_QuickLock);
}

void
TimedFlushCallbacks(void)
{
    EnterCriticalSection(&g_QuickLock);

    if (g_BufferedOutputUsed > 0)
    {
        ULONG Ticks = GetTickCount();
    
        // Flush if the last flush was a "long" time ago.
        if (g_LastFlushTicks == 0 ||
            g_LastFlushTicks > Ticks ||
            (Ticks - g_LastFlushTicks) > MAX_FLUSH_DELAY)
        {
            FlushCallbacks();
        }
    }

    LeaveCriticalSection(&g_QuickLock);
}

#if 0
#define DBGHIST(Args) g_NtDllCalls.DbgPrint Args
#else
#define DBGHIST(Args)
#endif

void
WriteHistoryEntry(ULONG Mask, PCSTR Text, ULONG Len)
{
    PSTR Buf;

    DBG_ASSERT((PSTR)g_OutHistWrite + sizeof(OutHistoryEntryHeader) +
               Len + 1 <= g_OutHistory + g_OutHistoryActualSize);
    
    if (Mask != g_OutHistWriteMask)
    {
        // Start new entry.
        g_OutHistWrite->Mask = Mask;
        g_OutHistWriteMask = Mask;
        Buf = (PSTR)(g_OutHistWrite + 1);
        g_OutHistoryUsed += sizeof(OutHistoryEntryHeader);
        
        DBGHIST(("  Write new "));
    }
    else
    {
        // Merge with previous entry.
        Buf = (PSTR)g_OutHistWrite - 1;
        g_OutHistoryUsed--;

        DBGHIST(("  Merge old "));
    }

    DBGHIST(("entry %p:%X, %d\n", g_OutHistWrite, Mask, Len));
    
    // Len does not include the terminator here so
    // always append a terminator.
    memcpy(Buf, Text, Len);
    Buf += Len;
    *Buf++ = 0;

    g_OutHistWrite = (OutHistoryEntry)Buf;
    g_OutHistoryUsed += Len + 1;
    DBG_ASSERT(g_OutHistoryUsed <= g_OutHistoryActualSize);
}

void
AddToOutputHistory(ULONG Mask, PCSTR Text, ULONG Len)
{
    if (Len == 0 || g_OutHistoryRequestedSize == 0)
    {
        return;
    }

    if (g_OutHistory == NULL)
    {
        // Output history buffer hasn't been allocated yet,
        // so go ahead and do it now.
        g_OutHistory = (PSTR)malloc(g_OutHistoryRequestedSize);
        if (g_OutHistory == NULL)
        {
            return;
        }
        
        // Reserve space for a trailing header as terminator.
        g_OutHistoryActualSize = g_OutHistoryRequestedSize -
            sizeof(OutHistoryEntryHeader);
    }
 
    ULONG TotalLen = Len + sizeof(OutHistoryEntryHeader) + 1;

    DBGHIST(("Add %X, %d\n", Mask, Len));
    
    if (TotalLen > g_OutHistoryActualSize)
    {
        Text += TotalLen - g_OutHistoryActualSize;
        TotalLen = g_OutHistoryActualSize;
        Len = TotalLen - sizeof(OutHistoryEntryHeader) - 1;
    }
    
    if (g_OutHistWrite == NULL)
    {
        g_OutHistRead = (OutHistoryEntry)g_OutHistory;
        g_OutHistWrite = (OutHistoryEntry)g_OutHistory;
        g_OutHistWriteMask = 0;
    }

    while (Len > 0)
    {
        ULONG Left;

        if (g_OutHistoryUsed == 0 || g_OutHistWrite > g_OutHistRead)
        {
            Left = g_OutHistoryActualSize -
                (ULONG)((PSTR)g_OutHistWrite - g_OutHistory);

            if (TotalLen > Left)
            {
                // See if it's worth splitting this request to
                // fill the space at the end of the buffer.
                if (Left >= MIN_HISTORY_ENTRY_SIZE &&
                    (TotalLen - Left) >= MIN_HISTORY_ENTRY_SIZE)
                {
                    ULONG Used = Left - sizeof(OutHistoryEntryHeader) - 1;
                
                    // Pack as much data as possible into the
                    // end of the buffer.
                    WriteHistoryEntry(Mask, Text, Used);
                    Text += Used;
                    Len -= Used;
                    TotalLen -= Used;
                }

                // Terminate the buffer and wrap around.  A header's
                // worth of space is reserved at the buffer end so
                // there should always be enough space for this.
                DBG_ASSERT((ULONG)((PSTR)g_OutHistWrite - g_OutHistory) <=
                           g_OutHistoryActualSize);
                g_OutHistWrite->Mask = 0;
                g_OutHistWriteMask = 0;
                g_OutHistWrite = (OutHistoryEntry)g_OutHistory;
                Left = (ULONG)((PUCHAR)g_OutHistRead - (PUCHAR)g_OutHistWrite);
            }
        }
        else
        {
            Left = (ULONG)((PUCHAR)g_OutHistRead - (PUCHAR)g_OutHistWrite);
        }

        if (TotalLen > Left)
        {
            ULONG Need = TotalLen - Left;
        
            // Advance the read pointer to make room.
            while (Need > 0)
            {
                PSTR EntText = (PSTR)(g_OutHistRead + 1);
                ULONG EntTextLen = strlen(EntText);
                ULONG EntTotal =
                    sizeof(OutHistoryEntryHeader) + EntTextLen + 1;

                if (EntTotal <= Need ||
                    EntTotal - Need < MIN_HISTORY_ENTRY_SIZE)
                {
                    DBGHIST(("  Remove %p:%X, %d\n", g_OutHistRead,
                             g_OutHistRead->Mask, EntTextLen));
                    
                    // Remove the whole entry.
                    g_OutHistRead = (OutHistoryEntry)
                        ((PUCHAR)g_OutHistRead + EntTotal);
                    DBG_ASSERT((ULONG)((PSTR)g_OutHistRead - g_OutHistory) <=
                               g_OutHistoryActualSize);
                    if (g_OutHistRead->Mask == 0)
                    {
                        g_OutHistRead = (OutHistoryEntry)g_OutHistory;
                    }
                    
                    Need -= EntTotal <= Need ? EntTotal : Need;
                    DBG_ASSERT(g_OutHistoryUsed >= EntTotal);
                    g_OutHistoryUsed -= EntTotal;
                }
                else
                {
                    OutHistoryEntryHeader EntHdr = *g_OutHistRead;

                    DBGHIST(("  Trim %p:%X, %d\n", g_OutHistRead,
                             g_OutHistRead->Mask, EntTextLen));
                    
                    // Remove part of the head of the entry.
                    g_OutHistRead = (OutHistoryEntry)
                        ((PUCHAR)g_OutHistRead + Need);
                    DBG_ASSERT((ULONG)
                               ((PSTR)g_OutHistRead + (EntTotal - Need) -
                                g_OutHistory) <= g_OutHistoryActualSize);
                    *g_OutHistRead = EntHdr;
                    DBG_ASSERT(g_OutHistoryUsed >= Need);
                    g_OutHistoryUsed -= Need;
                    Need = 0;
                }

                DBGHIST(("  Advance read to %p:%X\n",
                         g_OutHistRead, g_OutHistRead->Mask));
            }
        }
        else
        {
            WriteHistoryEntry(Mask, Text, Len);
            break;
        }
    }
    
    DBGHIST(("History read %p, write %p, used %d\n",
             g_OutHistRead, g_OutHistWrite, g_OutHistoryUsed));
}

void
SendOutputHistory(DebugClient* Client, ULONG HistoryLimit)
{
    if (g_OutHistRead == NULL ||
        Client->m_OutputCb == NULL ||
        (Client->m_OutMask & g_OutHistoryMask) == 0 ||
        HistoryLimit == 0)
    {
        return;
    }

    FlushCallbacks();
    
    OutHistoryEntry Ent;
    ULONG Total;
    ULONG Len;

    Ent = g_OutHistRead;
    Total = 0;
    while (Ent != g_OutHistWrite)
    {
        if (Ent->Mask == 0)
        {
            Ent = (OutHistoryEntry)g_OutHistory;
        }

        PSTR Text = (PSTR)(Ent + 1);
        Len = strlen(Text);
        Total += Len;

        Ent = (OutHistoryEntry)(Text + Len + 1);
    }

    DBGHIST(("Total history %X\n", Total));
    
    Ent = g_OutHistRead;
    while (Ent != g_OutHistWrite)
    {
        if (Ent->Mask == 0)
        {
            Ent = (OutHistoryEntry)g_OutHistory;
        }

        PSTR Text = (PSTR)(Ent + 1);
        Len = strlen(Text);

        if (Total - Len <= HistoryLimit)
        {
            PSTR Part = Text;
            if (Total > HistoryLimit)
            {
                Part += Total - HistoryLimit;
            }
            
            DBGHIST(("Send %p:%X, %d\n",
                     Ent, Ent->Mask, strlen(Part)));

            Client->m_OutputCb->Output(Ent->Mask, Part);
        }

        Total -= Len;
        Ent = (OutHistoryEntry)(Text + Len + 1);
    }
}

void
CompletePartialLine(ULONG MatchMask)
{
    // There are often cases where special output, such
    // as !sym noisy output, will come in the middle
    // of some other output.  If the last output was
    // a partial line and not special output, insert
    // a newline so that the special output isn't stuck
    // out on the end of a line somewhere.
    if (g_PartialOutputLine && g_LastOutputMask != MatchMask)
    {
        dprintf("\n");
    }
}

void
StartOutLine(ULONG Mask, ULONG Flags)
{
    if ((Flags & OUT_LINE_NO_TIMESTAMP) == 0 &&
        g_EchoEventTimestamps)
    {
        MaskOut(Mask, "%s: ", TimeToStr((ULONG)time(NULL)));
    }
    
    if ((Flags & OUT_LINE_NO_PREFIX) == 0 &&
        g_OutputLinePrefix)
    {
        MaskOut(Mask, "%s", g_OutputLinePrefix);
    }
}

//
// Translates various printf formats to account for the target platform.
//
// This looks for %p type format and truncates the top 4 bytes of the ULONG64
// address argument if the debugee is a 32 bit machine.
// The %p is replaced by %I64x in format string.
//
BOOL
TranslateFormat(
    LPSTR formatOut,
    LPCSTR format,
    va_list args,
    ULONG formatOutSize,
    BOOL Ptr64
    )
{
#define Duplicate(j,i) (formatOut[j++] = format[i++])
    ULONG minSize = strlen(format), i = 0, j = 0;
    CHAR c;
    BOOL TypeFormat = FALSE;
    BOOL FormatChanged = FALSE;

    do
    {
        c = format[i];

        if (c=='%')
        {
            TypeFormat = !TypeFormat;
        }
        if (TypeFormat)
        {
            switch (c)
            {
            case 'c': case 'C': case 'i': case 'd':
            case 'o': case 'u': case 'x': case 'X':
                Duplicate(j,i);
                (void)va_arg(args, int);
                TypeFormat = FALSE;
                break;
            case 'e': case 'E': case 'f': case 'g':
            case 'G':
                Duplicate(j,i);
                (void)va_arg(args, double);
                TypeFormat = FALSE;
                break;
            case 'n':
                Duplicate(j,i);
                (void)va_arg(args, int*);
                TypeFormat = FALSE;
                break;
            case 'N':
                // Native pointer, turns into %p.
                formatOut[j++] = 'p';
                FormatChanged = TRUE;
                i++;
                (void)va_arg(args, void*);
                TypeFormat = FALSE;
                break;
            case 's': case 'S':
                Duplicate(j,i);
                (void)va_arg(args, char*);
                TypeFormat = FALSE;
                break;

            case 'I':
                if ((format[i+1] == '6') && (format[i+2] == '4'))
                {
                    Duplicate(j,i);
                    Duplicate(j,i);
                    (void)va_arg(args, ULONG64);
                    TypeFormat = FALSE;
                }
                // dprintf("I64 a0 %lx, off %lx\n", args.a0, args.offset);
                Duplicate(j,i);
                break;
            
            case 'z': case 'Z':
                // unicode string
                Duplicate(j,i);
                (void)va_arg(args, void*);
                TypeFormat = FALSE;
                break;

            case 'p':
            case 'P':
                minSize +=3;
                if (format[i-1] == '%')
                {
                    minSize++;
                    if (Ptr64)
                    {
                        minSize += 2;
                        if (minSize > formatOutSize)
                        {
                            return FALSE;
                        }
                        formatOut[j++] = '0';
                        formatOut[j++] = '1';
                        formatOut[j++] = '6';
                    }
                    else
                    {
                        if (minSize > formatOutSize)
                        {
                            return FALSE;
                        }
                        formatOut[j++] = '0';
                        formatOut[j++] = '8';
                    }
                }

                if (minSize > formatOutSize)
                {
                    return FALSE;
                }
                formatOut[j++] = 'I';
                formatOut[j++] = '6';
                formatOut[j++] = '4';
                formatOut[j++] = (c == 'p') ? 'x' : 'X'; ++i;
                FormatChanged = TRUE;

                if (!Ptr64)
                {
                    PULONG64 Arg;

                    Arg = (PULONG64) (args);

                    //
                    // Truncate signextended addresses
                    //
                    *Arg = (ULONG64) (ULONG) *Arg;
                }

                (void)va_arg(args, ULONG64);
                TypeFormat = FALSE;
                break;

            default:
                Duplicate(j,i);
            } /* switch */
        }
        else
        {
            Duplicate(j,i);
        }
    }
    while (format[i] != '\0');

    formatOut[j] = '\0';
    return FormatChanged;
#undef Duplicate
}

void
MaskOutVa(ULONG Mask, PCSTR Format, va_list Args, BOOL Translate)
{
    int Len;
    ULONG OutTo = g_OutputControl & DEBUG_OUTCTL_SEND_MASK;

    // Reject output as quickly as possible to avoid
    // doing the format translation and sprintf.
    if (OutTo == DEBUG_OUTCTL_IGNORE ||
        (((g_OutputControl & DEBUG_OUTCTL_NOT_LOGGED) ||
          (Mask & g_OutHistoryMask) == 0) &&
         ((g_OutputControl & DEBUG_OUTCTL_NOT_LOGGED) ||
          (Mask & g_LogMask) == 0 ||
          g_LogFile == -1) &&
         (OutTo == DEBUG_OUTCTL_LOG_ONLY ||
          ((g_OutputControl & DEBUG_OUTCTL_OVERRIDE_MASK) == 0 &&
           (OutTo == DEBUG_OUTCTL_THIS_CLIENT &&
            ((Mask & g_OutputClient->m_OutMask) == 0 ||
             g_OutputClient->m_OutputCb == NULL)) ||
           (Mask & g_AllOutMask) == 0))))
    {
        return;
    }

    // Do not suspend the engine lock as this may be called
    // in the middle of an operation.

    EnterCriticalSection(&g_QuickLock);
    
    __try
    {
        if (Translate &&
            TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1,
                            g_Machine ? g_Machine->m_Ptr64 : TRUE))
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                             g_FormatBuffer, Args);
        }
        else
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
        }
        if (Len == 0)
        {
            __leave;
        }
        else if (Len < 0)
        {
            Len = OUT_BUFFER_SIZE - 1;
            g_OutBuffer[Len] = 0;
        }

        // Check and see if this output is filtered away.
        if ((Mask & DEBUG_OUTPUT_DEBUGGEE) &&
            g_OutFilterPattern[0] &&
            !(MatchPattern(g_OutBuffer, g_OutFilterPattern) ==
              g_OutFilterResult))
        {
            __leave;
        }
        
        // If the caller doesn't think this output should
        // be logged it probably also shouldn't go in the
        // history.
        if ((g_OutputControl & DEBUG_OUTCTL_NOT_LOGGED) == 0 &&
            (Mask & g_OutHistoryMask))
        {
            AddToOutputHistory(Mask, g_OutBuffer, Len);
        }
        
        if ((g_OutputControl & DEBUG_OUTCTL_NOT_LOGGED) == 0 &&
            (Mask & g_LogMask) &&
            g_LogFile != -1)
        {
            _write(g_LogFile, g_OutBuffer, Len);
        }

        if (OutTo == DEBUG_OUTCTL_LOG_ONLY)
        {
            __leave;
        }

        if (g_OutBuffer[Len - 1] != '\n' &&
            g_OutBuffer[Len - 1] != '\r')
        {
            // The current output is not a complete line.
            g_PartialOutputLine = TRUE;
        }
        else
        {
            g_PartialOutputLine = FALSE;
        }
        g_LastOutputMask = Mask;
        
        if (g_BufferOutput)
        {
            BufferOutput(Mask, g_OutBuffer, Len);
        }
        else
        {
            SendOutput(Mask, g_OutBuffer);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        OutputDebugStringA("Exception in MaskOutVa\n");
    }

    LeaveCriticalSection(&g_QuickLock);
}

void __cdecl
MaskOut(ULONG Mask, PCSTR Format, ...)
{
    va_list Args;
    va_start(Args, Format);
    MaskOutVa(Mask, Format, Args, TRUE);
    va_end(Args);
}

void __cdecl
dprintf(PCSTR Format, ...)
{
    va_list Args;
    va_start(Args, Format);
    MaskOutVa(DEBUG_OUTPUT_NORMAL, Format, Args, FALSE);
    va_end(Args);
}

#define OUT_FN(Name, Mask)                      \
void __cdecl                                    \
Name(PCSTR Format, ...)                         \
{                                               \
    va_list Args;                               \
    va_start(Args, Format);                     \
    MaskOutVa(Mask, Format, Args, TRUE);        \
    va_end(Args);                               \
}

OUT_FN(dprintf64, DEBUG_OUTPUT_NORMAL)
OUT_FN(ErrOut,    DEBUG_OUTPUT_ERROR)
OUT_FN(WarnOut,   DEBUG_OUTPUT_WARNING)
OUT_FN(VerbOut,   DEBUG_OUTPUT_VERBOSE)
OUT_FN(BpOut,     DEBUG_IOUTPUT_BREAKPOINT)
OUT_FN(EventOut,  DEBUG_IOUTPUT_EVENT)
OUT_FN(KdOut,     DEBUG_IOUTPUT_KD_PROTOCOL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgadv.cpp ===
//----------------------------------------------------------------------------
//
// IDebugAdvanced implementation.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

STDMETHODIMP
DebugClient::GetThreadContext(
    THIS_
    OUT PVOID Context,
    IN ULONG ContextSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if ((Status = g_Machine->GetContextState(MCTX_FULL)) == S_OK)
    {
        Status = g_Machine->ConvertContextTo(&g_Machine->m_Context,
                                             g_Target->m_SystemVersion,
                                             ContextSize, Context);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetThreadContext(
    THIS_
    IN PVOID Context,
    IN ULONG ContextSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if ((Status = g_Machine->GetContextState(MCTX_DIRTY)) == S_OK)
    {
        Status = g_Machine->ConvertContextFrom(&g_Machine->m_Context,
                                               g_Target->m_SystemVersion,
                                               ContextSize, Context);
        if (Status == S_OK)
        {
            NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS, DEBUG_ANY_ID);
        }
    }

    LEAVE_ENGINE();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\brkpt.hpp ===
//----------------------------------------------------------------------------
//
// Breakpoint support.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _BRKPT_HPP_
#define _BRKPT_HPP_

// Ways in which a breakpoint can be hit.  There's full
// match, hit but ignored and not hit.
#define BREAKPOINT_HIT         0
#define BREAKPOINT_HIT_IGNORED 1
#define BREAKPOINT_NOT_HIT     2

//----------------------------------------------------------------------------
//
// Breakpoint.
//
//----------------------------------------------------------------------------

#define BREAKPOINT_EXTERNAL_MODIFY_FLAGS \
    (DEBUG_BREAKPOINT_GO_ONLY | DEBUG_BREAKPOINT_ENABLED | \
     DEBUG_BREAKPOINT_ADDER_ONLY | DEBUG_BREAKPOINT_ONE_SHOT)
#define BREAKPOINT_EXTERNAL_FLAGS \
    (BREAKPOINT_EXTERNAL_MODIFY_FLAGS | DEBUG_BREAKPOINT_DEFERRED)

// Internal flags.
#define BREAKPOINT_KD_INTERNAL          0x80000000
#define BREAKPOINT_KD_COUNT_ONLY        0x40000000
#define BREAKPOINT_VIRT_ADDR            0x20000000
#define BREAKPOINT_INSERTED             0x10000000
#define BREAKPOINT_IN_LIST              0x08000000
#define BREAKPOINT_HIDDEN               0x04000000
#define BREAKPOINT_NOTIFY               0x02000000

// Internal types.
#define EXBS_NONE              0x00000000
#define EXBS_BREAKPOINT_DATA   0x00000001
#define EXBS_BREAKPOINT_CODE   0x00000002
#define EXBS_BREAKPOINT_ANY    0x00000003
#define EXBS_STEP_INSTRUCTION  0x00000004
#define EXBS_STEP_BRANCH       0x00000008
#define EXBS_STEP_ANY          0x0000000c
#define EXBS_ANY               0xffffffff

enum BreakpointMatchAction
{
    BREAKPOINT_ALLOW_MATCH,
    BREAKPOINT_WARN_MATCH,
    BREAKPOINT_REMOVE_MATCH
};
    
enum BreakpointEvalResult
{
    BPEVAL_RESOLVED,
    BPEVAL_RESOLVED_NO_MODULE,
    BPEVAL_UNRESOLVED,
    BPEVAL_ERROR,
    BPEVAL_UNKNOWN,
};

class Breakpoint
    : public IDebugBreakpoint
{
public:
    Breakpoint* m_Next;
    Breakpoint* m_Prev;
    ULONG m_Refs;
    ULONG m_Id;
    ULONG m_BreakType;
    ULONG m_Flags;
    ULONG m_CodeFlags;
    ULONG m_DataSize;
    ULONG m_DataAccessType;
    ULONG m_PassCount;
    ULONG m_CurPassCount;
    PCSTR m_Command;
    ThreadInfo* m_MatchThread;
    ProcessInfo* m_Process;
    PCSTR m_OffsetExpr;
    DebugClient* m_Adder;
    ULONG64 m_MatchThreadData;
    ULONG64 m_MatchProcessData;

    Breakpoint(DebugClient* Adder, ULONG Id, ULONG Type, ULONG ProcType);
    ~Breakpoint(void);

    //
    // IUnknown.
    //
    
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    //
    // IDebugBreakpoint.
    //
    
    STDMETHOD(GetId)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(GetType)(
        THIS_
        OUT PULONG BreakType,
        OUT PULONG ProcType
        );
    STDMETHOD(GetAdder)(
        THIS_
        OUT PDEBUG_CLIENT* Adder
        );
    STDMETHOD(GetFlags)(
        THIS_
        OUT PULONG Flags
        );
    STDMETHOD(AddFlags)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(RemoveFlags)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(SetFlags)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(GetOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(SetOffset)(
        THIS_
        IN ULONG64 Offset
        );
    STDMETHOD(GetDataParameters)(
        THIS_
        OUT PULONG Size,
        OUT PULONG AccessType
        );
    STDMETHOD(SetDataParameters)(
        THIS_
        IN ULONG Size,
        IN ULONG AccessType
        );
    STDMETHOD(GetPassCount)(
        THIS_
        OUT PULONG Count
        );
    STDMETHOD(SetPassCount)(
        THIS_
        IN ULONG Count
        );
    STDMETHOD(GetCurrentPassCount)(
        THIS_
        OUT PULONG Count
        );
    STDMETHOD(GetMatchThreadId)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(SetMatchThreadId)(
        THIS_
        IN ULONG Id
        );
    STDMETHOD(GetCommand)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        );
    STDMETHOD(SetCommand)(
        THIS_
        IN PCSTR Command
        );
    STDMETHOD(GetOffsetExpression)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ExpressionSize
        );
    STDMETHOD(SetOffsetExpression)(
        THIS_
        IN PCSTR Expression
        );
    STDMETHOD(GetParameters)(
        THIS_
        OUT PDEBUG_BREAKPOINT_PARAMETERS Params
        );

    //
    // Breakpoint.
    //
    
    virtual HRESULT Validate(void) = 0;
    virtual HRESULT Insert(void) = 0;
    virtual HRESULT Remove(void) = 0;
    virtual ULONG IsHit(PADDR Addr) = 0;

    // Must resturn true if in case of THIS breakpoint hit
    // Pc points to the instruction caused the hit
    virtual BOOL PcAtHit() = 0;

    // Internal refcounting which does true counting,
    // as opposed to the disabled public AddRef/Release.
    void Preserve(void)
    {
        m_Refs++;
    }
    void Relinquish(void)
    {
        if (--m_Refs == 0)
        {
            delete this;
        }
    }
    
    PADDR GetAddr(void)
    {
        return &m_Addr;
    }
    
    BOOL PassHit(void)
    {
        if (--m_CurPassCount == 0)
        {
            m_CurPassCount = 1;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    ULONG GetProcType(void)
    {
        return m_ProcType;
    }
    void SetProcType(ULONG ProcType)
    {
        m_ProcType = ProcType;
        m_ProcIndex = MachineTypeIndex(ProcType);
    }
    ULONG GetProcIndex(void)
    {
        return m_ProcIndex;
    }
    
    void ForceFlatAddr(void)
    {
        NotFlat(m_Addr);
        ComputeFlatAddress(&m_Addr, NULL);
    }

    // Breakpoint is enabled, not deferred, not internal.
    BOOL IsNormalEnabled(void)
    {
        return (m_Flags & (DEBUG_BREAKPOINT_ENABLED |
                           BREAKPOINT_KD_INTERNAL |
                           DEBUG_BREAKPOINT_DEFERRED)) ==
            DEBUG_BREAKPOINT_ENABLED;
    }

    void NotifyChanged(void)
    {
        if (!(m_Flags & BREAKPOINT_HIDDEN))
        {
            NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, m_Id, TRUE);
        }
    }
    
    HRESULT SetEvaluatedOffsetExpression(PCSTR Expr,
                                         BreakpointEvalResult Valid,
                                         PADDR Addr);

    void LinkIntoList(void);
    void UnlinkFromList(void);
    void UpdateInternal(void);
    BOOL EvalOffsetExpr(BreakpointEvalResult Valid, PADDR Addr);
    HRESULT CheckAddr(PADDR Addr);
    HRESULT SetAddr(PADDR Addr, BreakpointMatchAction MatchAction);
    // Matches breakpoints if they have the same insertion effect.
    // Used when determining whether a breakpoint needs to be
    // inserted or if another breakpoint is already covering the break.
    BOOL IsInsertionMatch(Breakpoint* Match);
    // Matches breakpoints if they have an insertion match and
    // if they match publicly, such as between flags, hiddenness
    // and so on.  Used when determining whether a user breakpoint
    // redefines an existing breakpoint.
    BOOL IsPublicMatch(Breakpoint* Match);
    // Check m_Match* fields against current state.
    BOOL MatchesCurrentState(void);

protected:
    // ProcType is private so that ProcType and ProcIndex can
    // be kept in sync.
    ULONG m_ProcType;
    MachineIndex m_ProcIndex;
    // Address is private to force users to go through SetAddr.
    ADDR m_Addr;
    ULONG m_CommandLen;
    ULONG m_OffsetExprLen;
    UCHAR m_InsertStorage[MAX_BREAKPOINT_LENGTH];
};

//----------------------------------------------------------------------------
//
// CodeBreakpoint.
//
//----------------------------------------------------------------------------

class CodeBreakpoint :
    public Breakpoint
{
public:
    CodeBreakpoint(DebugClient* Adder, ULONG Id, ULONG ProcType)
        : Breakpoint(Adder, Id, DEBUG_BREAKPOINT_CODE, ProcType)
    {
        m_Flags |= BREAKPOINT_VIRT_ADDR;
    }

    // Breakpoint.
    virtual HRESULT Validate(void);
    virtual HRESULT Insert(void);
    virtual HRESULT Remove(void);
    virtual ULONG IsHit(PADDR Addr);
    virtual BOOL PcAtHit()
    {
        return TRUE;
    }
};

//----------------------------------------------------------------------------
//
// DataBreakpoint.
//
//----------------------------------------------------------------------------

class DataBreakpoint :
    public Breakpoint
{
public:
    DataBreakpoint(DebugClient* Adder, ULONG Id, ULONG ProcType)
        : Breakpoint(Adder, Id, DEBUG_BREAKPOINT_DATA, ProcType) {}

    // Breakpoint.
    virtual HRESULT Insert(void);
    virtual HRESULT Remove(void);

    // DataBreakpoint.
    static void ClearThreadDataBreaks(ThreadInfo* Thread);
    void AddToThread(ThreadInfo* Thread);
};

//----------------------------------------------------------------------------
//
// X86DataBreakpoint.
//
//----------------------------------------------------------------------------

class X86DataBreakpoint :
    public DataBreakpoint
{
public:
    X86DataBreakpoint(DebugClient* Adder, ULONG Id,
                      ULONG Cr4Reg, ULONG Dr6Reg, ULONG ProcType)
        : DataBreakpoint(Adder, Id, ProcType)
    {
        m_Dr7Bits = 0;
        m_Cr4Reg = Cr4Reg;
        m_Dr6Reg = Dr6Reg;
    }

    // Breakpoint.
    virtual HRESULT Validate(void);
    virtual ULONG IsHit(PADDR Addr);

    virtual BOOL PcAtHit()
    {
        return FALSE;
    }

private:
    // Precomputed enable bits.
    ULONG m_Dr7Bits;
    
    // Register indices for getting breakpoint-related information.
    ULONG m_Cr4Reg;
    ULONG m_Dr6Reg;

    friend class X86MachineInfo;
    friend class Amd64MachineInfo;
};

//----------------------------------------------------------------------------
//
// Ia64DataBreakpoint.
//
//----------------------------------------------------------------------------

class Ia64DataBreakpoint :
    public DataBreakpoint
{
public:
    Ia64DataBreakpoint(DebugClient* Adder, ULONG Id)
        : DataBreakpoint(Adder, Id, IMAGE_FILE_MACHINE_IA64)
    {
        m_Control = 0;
    }

    // Breakpoint.
    virtual HRESULT Validate(void);
    virtual ULONG IsHit(PADDR Addr);
    virtual BOOL PcAtHit()
    {
        return TRUE;
    }

    static ULONG64 GetControl(ULONG AccessType, ULONG Size);

private:
    ULONG64 m_Control;

    friend class Ia64MachineInfo;
};

//----------------------------------------------------------------------------
//
// X86OnIa64DataBreakpoint.
//
//----------------------------------------------------------------------------
class X86OnIa64DataBreakpoint :
    public X86DataBreakpoint
{
public:
    X86OnIa64DataBreakpoint(DebugClient* Adder, ULONG Id);

    // Breakpoint.
    virtual HRESULT Validate(void);
    virtual ULONG IsHit(PADDR Addr);

private:
    ULONG64 m_Control;

    friend class Ia64MachineInfo;
};

extern BOOL g_BreakpointListChanged;
extern BOOL g_UpdateDataBreakpoints;
extern BOOL g_DataBreakpointsChanged;
extern BOOL g_BreakpointsSuspended;
extern BOOL g_DeferDefined;
extern Breakpoint* g_DeferBp;
extern Breakpoint* g_StepTraceBp;
extern CHAR g_StepTraceCmdState;

HRESULT BreakpointInit(void);

HRESULT InsertBreakpoints(void);
HRESULT RemoveBreakpoints(void);

HRESULT AddBreakpoint(DebugClient* Client,
                      MachineInfo* Machine,
                      ULONG Type,
                      ULONG DesiredId,
                      Breakpoint** Bp);
void RemoveBreakpoint(Breakpoint* Bp);
void RemoveProcessBreakpoints(ProcessInfo* Process);
void RemoveThreadBreakpoints(ThreadInfo* Thread);
void RemoveAllBreakpoints(ULONG Reason);

Breakpoint* GetBreakpointByIndex(DebugClient* Client, ULONG Index);
Breakpoint* GetBreakpointById(DebugClient* Client, ULONG Id);
Breakpoint* CheckMatchingBreakpoints(Breakpoint* Match, BOOL PUBLIC,
                                     ULONG IncFlags);
Breakpoint* CheckBreakpointHit(ProcessInfo* Process,
                               Breakpoint* Start, PADDR Addr,
                               ULONG ExbsType, ULONG IncFlags, ULONG ExcFlags,
                               PULONG HitType,
                               BOOL SetLastBreakpointHit);
ULONG NotifyHitBreakpoints(ULONG EventStatus);

void EvaluateOffsetExpressions(ProcessInfo* Process, ULONG Flags);

#define BPCMDS_FORCE_DISABLE 0x00000001
#define BPCMDS_ONE_LINE      0x00000002
#define BPCMDS_EXPR_ONLY     0x00000004
#define BPCMDS_MODULE_HINT   0x00000008

void ChangeBreakpointState(DebugClient* Client, ProcessInfo* ForProcess,
                           ULONG Id, UCHAR StateChange);
void ListBreakpoints(DebugClient* Client, ProcessInfo* ForProcess,
                     ULONG Id);
void ListBreakpointsAsCommands(DebugClient* Client, ProcessInfo* Process,
                               ULONG Flags);
PDEBUG_BREAKPOINT ParseBpCmd(DebugClient* Client, UCHAR Type,
                             ThreadInfo* Thread);
BOOL CheckBreakpointInsertedInRange(ProcessInfo* Process,
                                    ULONG64 Start, ULONG64 End);

#endif // #ifndef _BRKPT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgclt.hpp ===
//----------------------------------------------------------------------------
//
// Debug client classes.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __DBGCLT_HPP__
#define __DBGCLT_HPP__

// Most-derived interfaces.  When casting back and forth
// from DebugClient to a specific interface these defines
// should be used so that when new versions of interfaces
// are added this is the only place that needs to be updated.
#define IDebugAdvancedN      IDebugAdvanced
#define IDebugClientN        IDebugClient4
#define IDebugControlN       IDebugControl3
#define IDebugDataSpacesN    IDebugDataSpaces3
#define IDebugRegistersN     IDebugRegisters
#define IDebugSymbolGroupN   IDebugSymbolGroup
#define IDebugSymbolsN       IDebugSymbols2
#define IDebugSystemObjectsN IDebugSystemObjects3

#define INPUT_BUFFER_SIZE 4096

extern ULONG g_SystemAllocGranularity;

extern BOOL g_QuietMode;

extern ULONG g_SessionThread;

// The platform ID of the machine running the debugger.  Note
// that this may be different from g_TargetPlatformId, which
// is the platform ID of the machine being debugged.
extern ULONG g_DebuggerPlatformId;

// A lock that can be used for any short-term protection needs.
// This lock should not be held for a long time nor should
// other locks be taken when it is held.  Users of the lock
// can expect little contention and no deadlock possibilities.
extern CRITICAL_SECTION g_QuickLock;

// The global lock protecting engine state.  This lock
// should be taken everywhere and held any time engine
// activity occurs.  It should be suspended whenever a
// call needs to call out of the engine, such as with
// callbacks.
extern CRITICAL_SECTION g_EngineLock;
extern ULONG g_EngineNesting;

#define ENTER_ENGINE() \
    (EnterCriticalSection(&g_EngineLock), g_EngineNesting++)
#define LEAVE_ENGINE() \
    (::FlushCallbacks(), g_EngineNesting--, \
     LeaveCriticalSection(&g_EngineLock))
#define SUSPEND_ENGINE() \
    (::FlushCallbacks(), LeaveCriticalSection(&g_EngineLock))
#define RESUME_ENGINE() \
    EnterCriticalSection(&g_EngineLock)

// Special routine which opportunistically takes the engine lock.
inline HRESULT
TRY_ENTER_ENGINE()
{
    if (g_DebuggerPlatformId != VER_PLATFORM_WIN32_NT)
    {
        return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
    }

    if (!g_NtDllCalls.RtlTryEnterCriticalSection(&g_EngineLock))
    {
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    g_EngineNesting++;
    return S_OK;
}
     
// Events and storage space for returning event callback
// status from an APC.
extern HANDLE g_EventStatusWaiting;
extern HANDLE g_EventStatusReady;
extern ULONG g_EventStatus;

// Named event to sleep on.
extern HANDLE g_SleepPidEvent;

void ResetImplicitData(void);
void DotThread(PDOT_COMMAND Cmd, DebugClient* Client);
void DotProcess(PDOT_COMMAND Cmd, DebugClient* Client);
void DotFiber(PDOT_COMMAND Cmd, DebugClient* Client);

void DotKernelKill(PDOT_COMMAND Cmd, DebugClient* Client);
void DotPageIn(PDOT_COMMAND Cmd, DebugClient* Client);

HRESULT SetScopeContextFromThreadData(ULONG64 ThreadBase, BOOL Verbose);

HRESULT RawWaitForEvent(ULONG Flags, ULONG Timeout);

//----------------------------------------------------------------------------
//
// DebugClient.
//
//----------------------------------------------------------------------------

extern DebugClient* g_Clients;

extern ULONG g_LogMask;
extern ULONG g_OutputWidth;
extern PCSTR g_OutputLinePrefix;

extern char g_InputBuffer[INPUT_BUFFER_SIZE];
extern ULONG g_InputSequence;
extern HANDLE g_InputEvent;
extern ULONG g_InputSizeRequested;

extern ULONG g_EngOptions;
extern ULONG g_GlobalProcOptions;

//
// Engine status flags.
//

#define ENG_STATUS_WAITING                    0x00000001
#define ENG_STATUS_SUSPENDED                  0x00000002
#define ENG_STATUS_BREAKPOINTS_INSERTED       0x00000004
// A true system state change occurred.
#define ENG_STATUS_STATE_CHANGED              0x00000008
#define ENG_STATUS_STOP_SESSION               0x00000010
#define ENG_STATUS_PREPARED_FOR_CALLS         0x00000020
#define ENG_STATUS_NO_AUTO_WAIT               0x00000040
#define ENG_STATUS_PENDING_BREAK_IN           0x00000080
#define ENG_STATUS_AT_INITIAL_BREAK           0x00000100
#define ENG_STATUS_AT_INITIAL_MODULE_LOAD     0x00000200
#define ENG_STATUS_EXIT_CURRENT_WAIT          0x00000400
#define ENG_STATUS_USER_INTERRUPT             0x00000800
// Indicates a wait-for-state-change finished successfully.
// Primarily used to determine whether a kernel session is
// waiting for commands or not.
#define ENG_STATUS_WAIT_SUCCESSFUL            0x00001000
#define ENG_STATUS_SPECIAL_EXECUTION          0x00002000

extern ULONG g_EngStatus;

//
// Deferred action flags.
// These flags are set during processing in order to indicate
// actions that should be performed before execution begins
// again.
//

#define ENG_DEFER_SET_EVENT             0x00000001
#define ENG_DEFER_RESUME_THREAD         0x00000002
#define ENG_DEFER_DELETE_EXITED         0x00000004
#define ENG_DEFER_EXCEPTION_HANDLING    0x00000008
#define ENG_DEFER_UPDATE_CONTROL_SET    0x00000010
#define ENG_DEFER_HARDWARE_TRACING      0x00000020
#define ENG_DEFER_OUTPUT_CURRENT_INFO   0x00000040

extern ULONG g_EngDefer;

//
// Error suppression flags.
// These flags are set when particular errors are displayed
// in order to avoid repeated errors.
//

#define ENG_ERR_DEBUGGER_DATA           0x00000001

extern ULONG g_EngErr;

//
// Per-client flags.
//

#define CLIENT_IN_LIST                  0x00000001
#define CLIENT_DESTROYED                0x00000002
#define CLIENT_REMOTE                   0x00000004
#define CLIENT_PRIMARY                  0x00000008

class DebugClient
    : public IDebugAdvancedN,
      public IDebugClientN,
      public IDebugControlN,
      public IDebugDataSpacesN,
      public IDebugRegistersN,
      public IDebugSymbolsN,
      public IDebugSystemObjectsN,
      public DbgRpcClientObject
{
public:
    DebugClient(void);
    ~DebugClient(void);
    void Destroy(void);

    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugAdvanced.
    STDMETHOD(GetThreadContext)(
        THIS_
        OUT PVOID Context,
        IN ULONG ContextSize
        );
    STDMETHOD(SetThreadContext)(
        THIS_
        IN PVOID Context,
        IN ULONG ContextSize
        );
    
    // IDebugClient*.
    STDMETHOD(AttachKernel)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PCSTR ConnectOptions
        );
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG OptionsSize
        );
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        IN PCSTR Options
        );
    STDMETHOD(StartProcessServer)(
        THIS_
        IN ULONG Flags,
        IN PCSTR Options,
        IN PVOID Reserved
        );
    STDMETHOD(ConnectProcessServer)(
        THIS_
        IN PCSTR RemoteOptions,
        OUT PULONG64 Server
        );
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        IN ULONG64 Server
        );
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        IN ULONG64 Server,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        );
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        IN ULONG64 Server,
        IN PCSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        );
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        IN ULONG64 Server,
        IN ULONG SystemId,
        IN ULONG Flags,
        OUT OPTIONAL PSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        );
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG64 Server,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        );
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 Server,
        IN PSTR CommandLine,
        IN ULONG CreateFlags
        );
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        IN ULONG64 Server,
        IN OPTIONAL PSTR CommandLine,
        IN ULONG CreateFlags,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        );
    STDMETHOD(GetProcessOptions)(
        THIS_
        OUT PULONG Options
        );
    STDMETHOD(AddProcessOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(OpenDumpFile)(
        THIS_
        IN PCSTR DumpFile
        );
    STDMETHOD(WriteDumpFile)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier
        );
    STDMETHOD(ConnectSession)(
        THIS_
        IN ULONG Flags,
        IN ULONG HistoryLimit
        );
    STDMETHOD(StartServer)(
        THIS_
        IN PCSTR Options
        );
    STDMETHOD(OutputServers)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Machine,
        IN ULONG Flags
        );
    STDMETHOD(TerminateProcesses)(
        THIS
        );
    STDMETHOD(DetachProcesses)(
        THIS
        );
    STDMETHOD(EndSession)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(GetExitCode)(
        THIS_
        OUT PULONG Code
        );
    STDMETHOD(DispatchCallbacks)(
        THIS_
        IN ULONG Timeout
        );
    STDMETHOD(ExitDispatch)(
        THIS_
        IN PDEBUG_CLIENT Client
        );
    STDMETHOD(CreateClient)(
        THIS_
        OUT PDEBUG_CLIENT* Client
        );
    STDMETHOD(GetInputCallbacks)(
        THIS_
        OUT PDEBUG_INPUT_CALLBACKS* Callbacks
        );
    STDMETHOD(SetInputCallbacks)(
        THIS_
        IN PDEBUG_INPUT_CALLBACKS Callbacks
        );
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        OUT PDEBUG_OUTPUT_CALLBACKS* Callbacks
        );
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        IN PDEBUG_OUTPUT_CALLBACKS Callbacks
        );
    STDMETHOD(GetOutputMask)(
        THIS_
        OUT PULONG Mask
        );
    STDMETHOD(SetOutputMask)(
        THIS_
        IN ULONG Mask
        );
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        OUT PULONG Mask
        );
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        IN ULONG Mask
        );
    STDMETHOD(GetOutputWidth)(
        THIS_
        OUT PULONG Columns
        );
    STDMETHOD(SetOutputWidth)(
        THIS_
        IN ULONG Columns
        );
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PrefixSize
        );
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        IN OPTIONAL PCSTR Prefix
        );
    STDMETHOD(GetIdentity)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG IdentitySize
        );
    STDMETHOD(OutputIdentity)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN PCSTR Format
        );
    STDMETHOD(GetEventCallbacks)(
        THIS_
        OUT PDEBUG_EVENT_CALLBACKS* Callbacks
        );
    STDMETHOD(SetEventCallbacks)(
        THIS_
        IN PDEBUG_EVENT_CALLBACKS Callbacks
        );
    STDMETHOD(FlushCallbacks)(
        THIS
        );
    STDMETHOD(WriteDumpFile2)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier,
        IN ULONG FormatFlags,
        IN OPTIONAL PCSTR Comment
        );
    STDMETHOD(AddDumpInformationFile)(
        THIS_
        IN PCSTR InfoFile,
        IN ULONG Type
        );
    STDMETHOD(EndProcessServer)(
        THIS_
        IN ULONG64 Server
        );
    STDMETHOD(WaitForProcessServerEnd)(
        THIS_
        IN ULONG Timeout
        );
    STDMETHOD(IsKernelDebuggerEnabled)(
        THIS
        );
    STDMETHOD(TerminateCurrentProcess)(
        THIS
        );
    STDMETHOD(DetachCurrentProcess)(
        THIS
        );
    STDMETHOD(AbandonCurrentProcess)(
        THIS
        );
    STDMETHOD(GetRunningProcessSystemIdByExecutableNameWide)(
        THIS_
        IN ULONG64 Server,
        IN PCWSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        );
    STDMETHOD(GetRunningProcessDescriptionWide)(
        THIS_
        IN ULONG64 Server,
        IN ULONG SystemId,
        IN ULONG Flags,
        OUT OPTIONAL PWSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PWSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        );
    STDMETHOD(CreateProcessWide)(
        THIS_
        IN ULONG64 Server,
        IN PWSTR CommandLine,
        IN ULONG CreateFlags
        );
    STDMETHOD(CreateProcessAndAttachWide)(
        THIS_
        IN ULONG64 Server,
        IN OPTIONAL PWSTR CommandLine,
        IN ULONG CreateFlags,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        );
    STDMETHOD(OpenDumpFileWide)(
        THIS_
        IN OPTIONAL PCWSTR FileName,
        IN ULONG64 FileHandle
        );
    STDMETHOD(WriteDumpFileWide)(
        THIS_
        IN OPTIONAL PCWSTR FileName,
        IN ULONG64 FileHandle,
        IN ULONG Qualifier,
        IN ULONG FormatFlags,
        IN OPTIONAL PCWSTR Comment
        );
    STDMETHOD(AddDumpInformationFileWide)(
        THIS_
        IN OPTIONAL PCWSTR FileName,
        IN ULONG64 FileHandle,
        IN ULONG Type
        );
    STDMETHOD(GetNumberDumpFiles)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetDumpFile)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Handle,
        OUT PULONG Type
        );
    STDMETHOD(GetDumpFileWide)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PWSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Handle,
        OUT PULONG Type
        );

    // IDebugControl-3.
    STDMETHOD(GetInterrupt)(
        THIS
        );
    STDMETHOD(SetInterrupt)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(GetInterruptTimeout)(
        THIS_
        OUT PULONG Seconds
        );
    STDMETHOD(SetInterruptTimeout)(
        THIS_
        IN ULONG Seconds
        );
    STDMETHOD(GetLogFile)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT PBOOL Append
        );
    STDMETHOD(OpenLogFile)(
        THIS_
        IN PCSTR File,
        IN BOOL Append
        );
    STDMETHOD(CloseLogFile)(
        THIS
        );
    STDMETHOD(GetLogMask)(
        THIS_
        OUT PULONG Mask
        );
    STDMETHOD(SetLogMask)(
        THIS_
        IN ULONG Mask
        );
    STDMETHOD(Input)(
        THIS_
        OUT PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG InputSize
        );
    STDMETHOD(ReturnInput)(
        THIS_
        IN PCSTR Buffer
        );
    STDMETHODV(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        );
    STDMETHOD(OutputVaList)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        );
    STDMETHODV(ControlledOutput)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        );
    STDMETHOD(ControlledOutputVaList)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        );
    STDMETHOD(OutputPrompt)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        ...
        );
    STDMETHOD(OutputPromptVaList)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        IN va_list Args
        );
    STDMETHOD(GetPromptText)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        );
    STDMETHOD(OutputCurrentState)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        );
    STDMETHOD(OutputVersionInformation)(
        THIS_
        IN ULONG OutputControl
        );
    STDMETHOD(GetNotifyEventHandle)(
        THIS_
        OUT PULONG64 Handle
        );
    STDMETHOD(SetNotifyEventHandle)(
        THIS_
        IN ULONG64 Handle
        );
    STDMETHOD(Assemble)(
        THIS_
        IN ULONG64 Offset,
        IN PCSTR Instr,
        OUT PULONG64 EndOffset
        );
    STDMETHOD(Disassemble)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DisassemblySize,
        OUT PULONG64 EndOffset
        );
    STDMETHOD(GetDisassembleEffectiveOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(OutputDisassembly)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT PULONG64 EndOffset
        );
    STDMETHOD(OutputDisassemblyLines)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG PreviousLines,
        IN ULONG TotalLines,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PULONG OffsetLine,
        OUT OPTIONAL PULONG64 StartOffset,
        OUT OPTIONAL PULONG64 EndOffset,
        OUT OPTIONAL /* size_is(TotalLines) */ PULONG64 LineOffsets
        );
    STDMETHOD(GetNearInstruction)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT PULONG64 NearOffset
        );
    STDMETHOD(GetStackTrace)(
        THIS_
        IN ULONG64 FrameOffset,
        IN ULONG64 StackOffset,
        IN ULONG64 InstructionOffset,
        OUT PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        OUT PULONG FramesFilled
        );
    STDMETHOD(GetReturnOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(OutputStackTrace)(
        THIS_
        IN ULONG OutputControl,
        IN PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        IN ULONG Flags
        );
    STDMETHOD(GetDebuggeeType)(
        THIS_
        OUT PULONG Class,
        OUT PULONG Qualifier
        );
    STDMETHOD(GetActualProcessorType)(
        THIS_
        OUT PULONG Type
        );
    STDMETHOD(GetExecutingProcessorType)(
        THIS_
        OUT PULONG Type
        );
    STDMETHOD(GetNumberPossibleExecutingProcessorTypes)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetPossibleExecutingProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT PULONG Types
        );
    STDMETHOD(GetNumberProcessors)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetSystemVersion)(
        THIS_
        OUT PULONG PlatformId,
        OUT PULONG Major,
        OUT PULONG Minor,
        OUT OPTIONAL PSTR ServicePackString,
        IN ULONG ServicePackStringSize,
        OUT OPTIONAL PULONG ServicePackStringUsed,
        OUT PULONG ServicePackNumber,
        OUT OPTIONAL PSTR BuildString,
        IN ULONG BuildStringSize,
        OUT OPTIONAL PULONG BuildStringUsed
        );
    STDMETHOD(GetPageSize)(
        THIS_
        OUT PULONG Size
        );
    STDMETHOD(IsPointer64Bit)(
        THIS
        );
    STDMETHOD(ReadBugCheckData)(
        THIS_
        OUT PULONG Code,
        OUT PULONG64 Arg1,
        OUT PULONG64 Arg2,
        OUT PULONG64 Arg3,
        OUT PULONG64 Arg4
        );
    STDMETHOD(GetNumberSupportedProcessorTypes)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetSupportedProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT PULONG Types
        );
    STDMETHOD(GetProcessorTypeNames)(
        THIS_
        IN ULONG Type,
        OUT OPTIONAL PSTR FullNameBuffer,
        IN ULONG FullNameBufferSize,
        OUT OPTIONAL PULONG FullNameSize,
        OUT OPTIONAL PSTR AbbrevNameBuffer,
        IN ULONG AbbrevNameBufferSize,
        OUT OPTIONAL PULONG AbbrevNameSize
        );
    STDMETHOD(GetEffectiveProcessorType)(
        THIS_
        OUT PULONG Type
        );
    STDMETHOD(SetEffectiveProcessorType)(
        THIS_
        IN ULONG Type
        );
    STDMETHOD(GetExecutionStatus)(
        THIS_
        OUT PULONG Status
        );
    STDMETHOD(SetExecutionStatus)(
        THIS_
        IN ULONG Status
        );
    STDMETHOD(GetCodeLevel)(
        THIS_
        OUT PULONG Level
        );
    STDMETHOD(SetCodeLevel)(
        THIS_
        IN ULONG Level
        );
    STDMETHOD(GetEngineOptions)(
        THIS_
        OUT PULONG Options
        );
    STDMETHOD(AddEngineOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(RemoveEngineOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(SetEngineOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(GetSystemErrorControl)(
        THIS_
        OUT PULONG OutputLevel,
        OUT PULONG BreakLevel
        );
    STDMETHOD(SetSystemErrorControl)(
        THIS_
        IN ULONG OutputLevel,
        IN ULONG BreakLevel
        );
    STDMETHOD(GetTextMacro)(
        THIS_
        IN ULONG Slot,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MacroSize
        );
    STDMETHOD(SetTextMacro)(
        THIS_
        IN ULONG Slot,
        IN PCSTR Macro
        );
    STDMETHOD(GetRadix)(
        THIS_
        OUT PULONG Radix
        );
    STDMETHOD(SetRadix)(
        THIS_
        IN ULONG Radix
        );
    STDMETHOD(Evaluate)(
        THIS_
        IN PCSTR Expression,
        IN ULONG DesiredType,
        OUT PDEBUG_VALUE Value,
        OUT OPTIONAL PULONG RemainderIndex
        );
    STDMETHOD(CoerceValue)(
        THIS_
        IN PDEBUG_VALUE In,
        IN ULONG OutType,
        OUT PDEBUG_VALUE Out
        );
    STDMETHOD(CoerceValues)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_VALUE In,
        IN /* size_is(Count) */ PULONG OutTypes,
        OUT /* size_is(Count) */ PDEBUG_VALUE Out
        );
    STDMETHOD(Execute)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Command,
        IN ULONG Flags
        );
    STDMETHOD(ExecuteCommandFile)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR CommandFile,
        IN ULONG Flags
        );
    STDMETHOD(GetNumberBreakpoints)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetBreakpointByIndex)(
        THIS_
        IN ULONG Index,
        OUT PDEBUG_BREAKPOINT* Bp
        );
    STDMETHOD(GetBreakpointById)(
        THIS_
        IN ULONG Id,
        OUT PDEBUG_BREAKPOINT* Bp
        );
    STDMETHOD(GetBreakpointParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_BREAKPOINT_PARAMETERS Params
        );
    STDMETHOD(AddBreakpoint)(
        THIS_
        IN ULONG Type,
        IN ULONG DesiredId,
        OUT PDEBUG_BREAKPOINT* Bp
        );
    STDMETHOD(RemoveBreakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        );
    STDMETHOD(AddExtension)(
        THIS_
        IN PCSTR Path,
        IN ULONG Flags,
        OUT PULONG64 Handle
        );
    STDMETHOD(RemoveExtension)(
        THIS_
        IN ULONG64 Handle
        );
    STDMETHOD(GetExtensionByPath)(
        THIS_
        IN PCSTR Path,
        OUT PULONG64 Handle
        );
    STDMETHOD(CallExtension)(
        THIS_
        IN OPTIONAL ULONG64 Handle,
        IN PCSTR Function,
        IN OPTIONAL PCSTR Arguments
        );
    STDMETHOD(GetExtensionFunction)(
        THIS_
        IN ULONG64 Handle,
        IN PCSTR FuncName,
        OUT FARPROC* Function
        );
    STDMETHOD(GetWindbgExtensionApis32)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS32 Api
        );
    STDMETHOD(GetWindbgExtensionApis64)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS64 Api
        );
    STDMETHOD(GetNumberEventFilters)(
        THIS_
        OUT PULONG SpecificEvents,
        OUT PULONG SpecificExceptions,
        OUT PULONG ArbitraryExceptions
        );
    STDMETHOD(GetEventFilterText)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        );
    STDMETHOD(GetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        );
    STDMETHOD(SetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        );
    STDMETHOD(GetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        );
    STDMETHOD(SetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        );
    STDMETHOD(GetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ArgumentSize
        );
    STDMETHOD(SetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        IN PCSTR Argument
        );
    STDMETHOD(GetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Codes,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        );
    STDMETHOD(SetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        );
    STDMETHOD(GetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        );
    STDMETHOD(SetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        );
    STDMETHOD(WaitForEvent)(
        THIS_
        IN ULONG Flags,
        IN ULONG Timeout
        );
    STDMETHOD(GetLastEventInformation)(
        THIS_
        PULONG Type,
        OUT PULONG ProcessId,
        OUT PULONG ThreadId,
        OUT OPTIONAL PVOID ExtraInformation,
        IN ULONG ExtraInformationSize,
        OUT OPTIONAL PULONG ExtraInformationUsed,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG DescriptionUsed
        );
    STDMETHOD(GetCurrentTimeDate)(
        THIS_
        OUT PULONG TimeDate
        );
    STDMETHOD(GetCurrentSystemUpTime)(
        THIS_
        OUT PULONG UpTime
        );
    STDMETHOD(GetDumpFormatFlags)(
        THIS_
        OUT PULONG FormatFlags
        );
    STDMETHOD(GetNumberTextReplacements)(
        THIS_
        OUT PULONG NumRepl
        );
    STDMETHOD(GetTextReplacement)(
        THIS_
        IN OPTIONAL PCSTR SrcText,
        IN ULONG Index,
        OUT OPTIONAL PSTR SrcBuffer,
        IN ULONG SrcBufferSize,
        OUT OPTIONAL PULONG SrcSize,
        OUT OPTIONAL PSTR DstBuffer,
        IN ULONG DstBufferSize,
        OUT OPTIONAL PULONG DstSize
        );
    STDMETHOD(SetTextReplacement)(
        THIS_
        IN PCSTR SrcText,
        IN OPTIONAL PCSTR DstText
        );
    STDMETHOD(RemoveTextReplacements)(
        THIS
        );
    STDMETHOD(OutputTextReplacements)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        );
    STDMETHOD(GetAssemblyOptions)(
        THIS_
        OUT PULONG Options
        );
    STDMETHOD(AddAssemblyOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(RemoveAssemblyOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(SetAssemblyOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(GetExpressionSyntax)(
        THIS_
        OUT PULONG Flags
        );
    STDMETHOD(SetExpressionSyntax)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(SetExpressionSyntaxByName)(
        THIS_
        IN PCSTR AbbrevName
        );
    STDMETHOD(GetNumberExpressionSyntaxes)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetExpressionSyntaxNames)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR FullNameBuffer,
        IN ULONG FullNameBufferSize,
        OUT OPTIONAL PULONG FullNameSize,
        OUT OPTIONAL PSTR AbbrevNameBuffer,
        IN ULONG AbbrevNameBufferSize,
        OUT OPTIONAL PULONG AbbrevNameSize
        );
    STDMETHOD(GetNumberEvents)(
        THIS_
        OUT PULONG Events
        );
    STDMETHOD(GetEventIndexDescription)(
        THIS_
        IN ULONG Index,
        IN ULONG Which,
        IN OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DescSize
        );
    STDMETHOD(GetCurrentEventIndex)(
        THIS_
        OUT PULONG Index
        );
    STDMETHOD(SetNextEventIndex)(
        THIS_
        IN ULONG Relation,
        IN ULONG Value,
        OUT PULONG NextIndex
        );

    // IDebugDataSpaces-3.
    STDMETHOD(ReadVirtual)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(SearchVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        IN ULONG PatternGranularity,
        OUT PULONG64 MatchOffset
        );
    STDMETHOD(ReadVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(ReadPointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        OUT /* size_is(Count) */ PULONG64 Ptrs
        );
    STDMETHOD(WritePointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        IN /* size_is(Count) */ PULONG64 Ptrs
        );
    STDMETHOD(ReadPhysical)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WritePhysical)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(ReadControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(ReadIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(ReadMsr)(
        THIS_
        IN ULONG Msr,
        OUT PULONG64 Value
        );
    STDMETHOD(WriteMsr)(
        THIS_
        IN ULONG Msr,
        IN ULONG64 Value
        );
    STDMETHOD(ReadBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(CheckLowMemory)(
        THIS
        );
    STDMETHOD(ReadDebuggerData)(
        THIS_
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(ReadProcessorSystemData)(
        THIS_
        IN ULONG Processor,
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(VirtualToPhysical)(
        THIS_
        IN ULONG64 Virtual,
        OUT PULONG64 Physical
        );
    STDMETHOD(GetVirtualTranslationPhysicalOffsets)(
        THIS_
        IN ULONG64 Virtual,
        OUT OPTIONAL /* size_is(OffsetsSize) */ PULONG64 Offsets,
        IN ULONG OffsetsSize,
        OUT OPTIONAL PULONG Levels
        );
    STDMETHOD(ReadHandleData)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        );
    STDMETHOD(FillVirtual)(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT OPTIONAL PULONG Filled
        );
    STDMETHOD(FillPhysical)(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT OPTIONAL PULONG Filled
        );
    STDMETHOD(QueryVirtual)(
        THIS_
        IN ULONG64 Offset,
        OUT PMEMORY_BASIC_INFORMATION64 Info
        );
    STDMETHOD(ReadImageNtHeaders)(
        THIS_
        IN ULONG64 ImageBase,
        OUT PIMAGE_NT_HEADERS64 Headers
        );
    STDMETHOD(ReadTagged)(
        THIS_
        IN LPGUID Tag,
        IN ULONG Offset,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TotalSize
        );
    STDMETHOD(StartEnumTagged)(
        THIS_
        OUT PULONG64 Handle
        );
    STDMETHOD(GetNextTagged)(
        THIS_
        IN ULONG64 Handle,
        OUT LPGUID Tag,
        OUT PULONG Size
        );
    STDMETHOD(EndEnumTagged)(
        THIS_
        IN ULONG64 Handle
        );

    // IDebugRegisters.
    STDMETHOD(GetNumberRegisters)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetDescription)(
        THIS_
        IN ULONG Register,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PDEBUG_REGISTER_DESCRIPTION Desc
        );
    STDMETHOD(GetIndexByName)(
        THIS_
        IN PCSTR Name,
        OUT PULONG Index
        );
    STDMETHOD(GetValue)(
        THIS_
        IN ULONG Register,
        OUT PDEBUG_VALUE Value
        );
    STDMETHOD(SetValue)(
        THIS_
        IN ULONG Register,
        IN PDEBUG_VALUE Value
        );
    STDMETHOD(GetValues)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL PULONG Indices,
        IN ULONG Start,
        OUT PDEBUG_VALUE Values
        );
    STDMETHOD(SetValues)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL PULONG Indices,
        IN ULONG Start,
        IN PDEBUG_VALUE Values
        );
    STDMETHOD(OutputRegisters)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        );
    STDMETHOD(GetInstructionOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetStackOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetFrameOffset)(
        THIS_
        OUT PULONG64 Offset
        );

    // IDebugSymbols and IDebugSymbols2.
    STDMETHOD(GetSymbolOptions)(
        THIS_
        OUT PULONG Options
        );
    STDMETHOD(AddSymbolOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(RemoveSymbolOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(SetSymbolOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(GetNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        );
    STDMETHOD(GetOffsetByName)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Offset
        );
    STDMETHOD(GetNearNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        );
    STDMETHOD(GetLineByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Line,
        OUT OPTIONAL PSTR FileBuffer,
        IN ULONG FileBufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT OPTIONAL PULONG64 Displacement
        );
    STDMETHOD(GetOffsetByLine)(
        THIS_
        IN ULONG Line,
        IN PCSTR File,
        OUT PULONG64 Offset
        );
    STDMETHOD(GetNumberModules)(
        THIS_
        OUT PULONG Loaded,
        OUT PULONG Unloaded
        );
    STDMETHOD(GetModuleByIndex)(
        THIS_
        IN ULONG Index,
        OUT PULONG64 Base
        );
    STDMETHOD(GetModuleByModuleName)(
        THIS_
        IN PCSTR Name,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        );
    STDMETHOD(GetModuleByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        );
    STDMETHOD(GetModuleNames)(
        THIS_
        IN ULONG Index,
        IN ULONG64 Base,
        OUT OPTIONAL PSTR ImageNameBuffer,
        IN ULONG ImageNameBufferSize,
        OUT OPTIONAL PULONG ImageNameSize,
        OUT OPTIONAL PSTR ModuleNameBuffer,
        IN ULONG ModuleNameBufferSize,
        OUT OPTIONAL PULONG ModuleNameSize,
        OUT OPTIONAL PSTR LoadedImageNameBuffer,
        IN ULONG LoadedImageNameBufferSize,
        OUT OPTIONAL PULONG LoadedImageNameSize
        );
    STDMETHOD(GetModuleParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG64 Bases,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_MODULE_PARAMETERS Params
        );
    STDMETHOD(GetSymbolModule)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Base
        );
    STDMETHOD(GetTypeName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        );
    STDMETHOD(GetTypeId)(
        THIS_
        IN ULONG64 Module,
        IN PCSTR Name,
        OUT PULONG TypeId
        );
    STDMETHOD(GetTypeSize)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PULONG Size
        );
    STDMETHOD(GetFieldOffset)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PCSTR Field,
        OUT PULONG Offset
        );
    STDMETHOD(GetSymbolTypeId)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        );
    STDMETHOD(GetOffsetTypeId)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        );
    STDMETHOD(ReadTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(OutputTypedDataVirtual)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        );
    STDMETHOD(ReadTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(OutputTypedDataPhysical)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        );
    STDMETHOD(GetScope)(
        THIS_
        OUT OPTIONAL PULONG64 InstructionOffset,
        OUT OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        OUT OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        );
    STDMETHOD(SetScope)(
        THIS_
        IN ULONG64 InstructionOffset,
        IN OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        IN OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        );
    STDMETHOD(ResetScope)(
        THIS
        );
    STDMETHOD(GetScopeSymbolGroup)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PDEBUG_SYMBOL_GROUP Update,
        OUT PDEBUG_SYMBOL_GROUP* Symbols
        );
    STDMETHOD(CreateSymbolGroup)(
        THIS_
        OUT PDEBUG_SYMBOL_GROUP* Group
        );
    STDMETHOD(StartSymbolMatch)(
        THIS_
        IN PCSTR Pattern,
        OUT PULONG64 Handle
        );
    STDMETHOD(GetNextSymbolMatch)(
        THIS_
        IN ULONG64 Handle,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MatchSize,
        OUT OPTIONAL PULONG64 Offset
        );
    STDMETHOD(EndSymbolMatch)(
        THIS_
        IN ULONG64 Handle
        );
    STDMETHOD(Reload)(
        THIS_
        IN PCSTR Module
        );
    STDMETHOD(GetSymbolPath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        );
    STDMETHOD(SetSymbolPath)(
        THIS_
        IN PCSTR Path
        );
    STDMETHOD(AppendSymbolPath)(
        THIS_
        IN PCSTR Addition
        );
    STDMETHOD(GetImagePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        );
    STDMETHOD(SetImagePath)(
        THIS_
        IN PCSTR Path
        );
    STDMETHOD(AppendImagePath)(
        THIS_
        IN PCSTR Addition
        );
    STDMETHOD(GetSourcePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        );
    STDMETHOD(GetSourcePathElement)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        );
    STDMETHOD(SetSourcePath)(
        THIS_
        IN PCSTR Path
        );
    STDMETHOD(AppendSourcePath)(
        THIS_
        IN PCSTR Addition
        );
    STDMETHOD(FindSourceFile)(
        THIS_
        IN ULONG StartElement,
        IN PCSTR File,
        IN ULONG Flags,
        OUT OPTIONAL PULONG FoundElement,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FoundSize
        );
    STDMETHOD(GetSourceFileLineOffsets)(
        THIS_
        IN PCSTR File,
        OUT OPTIONAL PULONG64 Buffer,
        IN ULONG BufferLines,
        OUT OPTIONAL PULONG FileLines
        );
    STDMETHOD(GetModuleVersionInformation)(
        THIS_
        IN ULONG Index,
        IN ULONG64 Base,
        IN PCSTR Item,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG VerInfoSize
        );
    STDMETHOD(GetModuleNameString)(
        THIS_
        IN ULONG Which,
        IN ULONG Index,
        IN ULONG64 Base,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize
        );
    STDMETHOD(GetConstantName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG64 Value,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        );
    STDMETHOD(GetFieldName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG FieldIndex,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        );
    STDMETHOD(GetTypeOptions)(
        THIS_
        OUT PULONG Options
        );
    STDMETHOD(SetTypeOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(AddTypeOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(RemoveTypeOptions)(
        THIS_
        IN ULONG Options
        );

    // IDebugSystemObjects-3.
    STDMETHOD(GetEventThread)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(GetEventProcess)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentThreadId)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(SetCurrentThreadId)(
        THIS_
        IN ULONG Id
        );
    STDMETHOD(GetCurrentProcessId)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(SetCurrentProcessId)(
        THIS_
        IN ULONG Id
        );
    STDMETHOD(GetNumberThreads)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetTotalNumberThreads)(
        THIS_
        OUT PULONG Total,
        OUT PULONG LargestProcess
        );
    STDMETHOD(GetThreadIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        );
    STDMETHOD(GetThreadIdByProcessor)(
        THIS_
        IN ULONG Processor,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentThreadDataOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetThreadIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentThreadTeb)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetThreadIdByTeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentThreadSystemId)(
        THIS_
        OUT PULONG SysId
        );
    STDMETHOD(GetThreadIdBySystemId)(
        THIS_
        IN ULONG SysId,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentThreadHandle)(
        THIS_
        OUT PULONG64 Handle
        );
    STDMETHOD(GetThreadIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        );
    STDMETHOD(GetNumberProcesses)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetProcessIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        );
    STDMETHOD(GetCurrentProcessDataOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetProcessIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentProcessPeb)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetProcessIdByPeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentProcessSystemId)(
        THIS_
        OUT PULONG SysId
        );
    STDMETHOD(GetProcessIdBySystemId)(
        THIS_                                      
        IN ULONG SysId,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentProcessHandle)(
        THIS_
        OUT PULONG64 Handle
        );
    STDMETHOD(GetProcessIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentProcessExecutableName)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ExeSize
        );
    STDMETHOD(GetCurrentProcessUpTime)(
        THIS_
        OUT PULONG UpTime
        );
    STDMETHOD(GetImplicitThreadDataOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(SetImplicitThreadDataOffset)(
        THIS_
        IN ULONG64 Offset
        );
    STDMETHOD(GetImplicitProcessDataOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(SetImplicitProcessDataOffset)(
        THIS_
        IN ULONG64 Offset
        );
    STDMETHOD(GetEventSystem)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentSystemId)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(SetCurrentSystemId)(
        THIS_
        IN ULONG Id
        );
    STDMETHOD(GetNumberSystems)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetSystemIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PULONG Ids
        );
    STDMETHOD(GetTotalNumberThreadsAndProcesses)(
        THIS_
        OUT PULONG TotalThreads,
        OUT PULONG TotalProcesses,
        OUT PULONG LargestProcessThreads,
        OUT PULONG LargestSystemThreads,
        OUT PULONG LargestSystemProcesses
        );
    STDMETHOD(GetCurrentSystemServer)(
        THIS_
        OUT PULONG64 Server
        );
    STDMETHOD(GetSystemByServer)(
        THIS_
        IN ULONG64 Server,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentSystemServerName)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize
        );

    // DbgRpcClientObject.
    virtual HRESULT RpcInitialize(PSTR ClientIdentity, PSTR TransIdentity,
                                  PVOID* Interface);
    virtual void    RpcFinalize(void);
    virtual void    RpcUninitialize(void);
    
    //------------------------------------------------------------------------
    // General.

    HRESULT Initialize(void);
    void InitializePrimary(void);
    
    void Link(void);
    void Unlink(void);

    HRESULT WriteDumpFileInternal(
        IN OPTIONAL PCWSTR FileName,
        IN ULONG64 FileHandle,
        IN ULONG Qualifier,
        IN ULONG FormatFlags,
        IN OPTIONAL PCSTR CommentA,
        IN OPTIONAL PCWSTR CommentW
        );

    DebugClient* m_Next;
    DebugClient* m_Prev;
    
    ULONG m_Refs;
    ULONG m_Flags;
    ULONG m_ThreadId;
    HANDLE m_Thread;
    char m_Identity[DBGRPC_MAX_IDENTITY];
    time_t m_LastActivity;
    
    PDEBUG_EVENT_CALLBACKS m_EventCb;
    ULONG m_EventInterest;
    HANDLE m_DispatchSema;

    PDEBUG_INPUT_CALLBACKS m_InputCb;
    ULONG m_InputSequence;
    
    PDEBUG_OUTPUT_CALLBACKS m_OutputCb;
    ULONG m_OutMask;
    ULONG m_OutputWidth;
    PCSTR m_OutputLinePrefix;
};

DebugClient* FindClient(ULONG Tid, ULONG IncFlags, ULONG ExcFlags);

HRESULT SetEngOptions(ULONG Options);

HRESULT ClientStartServer(PCSTR Options, BOOL Wait);

ULONG GetExecutionStatus(void);
HRESULT SetExecutionStatus(ULONG Status);
HRESULT SetExprSyntax(ULONG Flags);
HRESULT SetExprSyntaxByName(PCSTR Name);

HRESULT Execute(DebugClient* Client, PCSTR Command, ULONG Flags);
HRESULT ExecuteCommandFile(DebugClient* Client, PCSTR File, ULONG Flags);

HRESULT CheckSessionInitialize(DebugClient* Client);
HRESULT LiveKernelInitialize(DebugClient* Client, ULONG Qual, PCSTR Options,
                             TargetInfo** TargetRet);
HRESULT UserInitialize(DebugClient* Client, ULONG64 Server,
                       TargetInfo** TargetRet, PBOOL CreatedTargetRet);
HRESULT DumpInitialize(DebugClient* Client,
                       PCWSTR FileName, ULONG64 FileHandle,
                       TargetInfo** TargetRet);

void DiscardSession(ULONG Reason);
void DiscardedTargets(ULONG Reason);
void DiscardTargets(ULONG Reason);

void GetClientIdentity(PSTR Identity);

void CheckForStaleBinary(PCSTR DllName, BOOL Thorough);

#endif // #ifndef __DBGCLT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgclt.cpp ===
//----------------------------------------------------------------------------
//
// Debug client implementation.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"
#include "dbgver.h"

#define VER_STRING(Specific)            \
"\n"                                    \
"Microsoft (R) Windows " Specific       \
"  Version " VER_PRODUCTVERSION_STR     \
"\n" VER_LEGALCOPYRIGHT_STR             \
"\n"                                    \
"\n"

PCHAR g_WinVersionString = VER_STRING("Debugger");

BOOL g_VersionMessage;

ULONG g_SessionThread;

ULONG g_SystemAllocGranularity;

BOOL g_QuietMode;

ULONG g_OutputWidth = 80;
PCSTR g_OutputLinePrefix;

// The platform ID of the machine running the debugger.  Note
// that this may be different from g_TargetPlatformId, which
// is the platform ID of the machine being debugged.
ULONG g_DebuggerPlatformId;

CRITICAL_SECTION g_QuickLock;

CRITICAL_SECTION g_EngineLock;
ULONG g_EngineNesting;

// Events and storage space for returning event callback
// status from an APC.
HANDLE g_EventStatusWaiting;
HANDLE g_EventStatusReady;
ULONG g_EventStatus;

// Named event to sleep on.
HANDLE g_SleepPidEvent;

API_VERSION g_EngApiVersion =
{
    BUILD_MAJOR_VERSION, BUILD_MINOR_VERSION, API_VERSION_NUMBER, 0
};

API_VERSION g_DbgHelpVersion;

WCHAR g_LastFailedDumpFileW[MAX_PATH];

//----------------------------------------------------------------------------
//
// DebugClient.
//
//----------------------------------------------------------------------------

// List of all clients.
DebugClient* g_Clients;

char g_InputBuffer[INPUT_BUFFER_SIZE];
ULONG g_InputSequence;
HANDLE g_InputEvent;
ULONG g_InputSizeRequested;

ULONG g_EngOptions;
ULONG g_EngStatus;
ULONG g_EngDefer;
ULONG g_EngErr;

// Some options set through the process options apply to
// all processes and some are per-process.  The global
// options are collected here.
ULONG g_GlobalProcOptions;

#if DBG
ULONG g_EnvOutMask;
#endif

DebugClient::DebugClient(void)
{
    m_Next = NULL;
    m_Prev = NULL;

    m_Refs = 1;
    m_Flags = 0;
    m_ThreadId = ::GetCurrentThreadId();
    m_Thread = NULL;
    m_EventCb = NULL;
    m_EventInterest = 0;
    m_DispatchSema = NULL;
    m_InputCb = NULL;
    m_InputSequence = 0xffffffff;
    m_OutputCb = NULL;
#if DBG
    m_OutMask = DEFAULT_OUT_MASK | g_EnvOutMask;
#else
    m_OutMask = DEFAULT_OUT_MASK;
#endif
    m_OutputWidth = 80;
    m_OutputLinePrefix = NULL;
}

DebugClient::~DebugClient(void)
{
    // Most of the work is done in Destroy.

    if (m_Flags & CLIENT_IN_LIST)
    {
        Unlink();
    }
}

void
DebugClient::Destroy(void)
{
    // Clients cannot arbitrarily be removed from the client list
    // or their memory deleted due to the possibility of a callback
    // loop occurring at the same time.  Instead clients are left
    // in the list and zeroed out to prevent further callbacks
    // from occurring.
    // XXX drewb - This memory needs to be reclaimed at some
    // point, but there's no simple safe time to do so since
    // callbacks can occur at any time.  Clients are very small
    // right now so the leakage is negligible.

    m_Flags = (m_Flags & ~(CLIENT_REMOTE | CLIENT_PRIMARY)) |
        CLIENT_DESTROYED;

    //
    // Remove any references from breakpoints this client added.
    //

    TargetInfo* Target;
    ProcessInfo* Process;
    Breakpoint* Bp;

    ForAllLayersToProcess()
    {
        for (Bp = Process->m_Breakpoints; Bp != NULL; Bp = Bp->m_Next)
        {
            if (Bp->m_Adder == this)
            {
                Bp->m_Adder = NULL;
            }
        }
    }

    if (m_Thread != NULL)
    {
        CloseHandle(m_Thread);
        m_Thread = NULL;
    }

    m_EventInterest = 0;
    RELEASE(m_EventCb);
    if (m_DispatchSema != NULL)
    {
        CloseHandle(m_DispatchSema);
        m_DispatchSema = NULL;
    }

    RELEASE(m_InputCb);
    m_InputSequence = 0xffffffff;

    RELEASE(m_OutputCb);
    m_OutMask = 0;
    CollectOutMasks();
}

STDMETHODIMP
DebugClient::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;

    *Interface = NULL;
    Status = S_OK;

    // Interface specific casts are necessary in order to
    // get the right vtable pointer in our multiple
    // inheritance scheme.
    if (DbgIsEqualIID(InterfaceId, IID_IUnknown) ||
        DbgIsEqualIID(InterfaceId, IID_IDebugClient) ||
        DbgIsEqualIID(InterfaceId, IID_IDebugClient2) ||
        DbgIsEqualIID(InterfaceId, IID_IDebugClient3) ||
        DbgIsEqualIID(InterfaceId, IID_IDebugClient4))
    {
        *Interface = (IDebugClientN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugAdvanced))
    {
        *Interface = (IDebugAdvancedN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugControl) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugControl2) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugControl3))
    {
        *Interface = (IDebugControlN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugDataSpaces) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugDataSpaces2) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugDataSpaces3))
    {
        *Interface = (IDebugDataSpacesN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugRegisters))
    {
        *Interface = (IDebugRegistersN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugSymbols) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugSymbols2))
    {
        *Interface = (IDebugSymbolsN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugSystemObjects) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugSystemObjects2) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugSystemObjects3))
    {
        *Interface = (IDebugSystemObjectsN *)this;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    if (Status == S_OK)
    {
        AddRef();
    }

    return Status;
}

STDMETHODIMP_(ULONG)
DebugClient::AddRef(
    THIS
    )
{
    return InterlockedIncrement((PLONG)&m_Refs);
}

STDMETHODIMP_(ULONG)
DebugClient::Release(
    THIS
    )
{
    LONG Refs = InterlockedDecrement((PLONG)&m_Refs);
    if (Refs == 0)
    {
        Destroy();
    }
    return Refs;
}

STDMETHODIMP
DebugClient::AttachKernel(
    THIS_
    IN ULONG Flags,
    IN OPTIONAL PCSTR ConnectOptions
    )
{
    HRESULT Status;
    ULONG Qual;

    if (
#if DEBUG_ATTACH_KERNEL_CONNECTION > 0
        Flags < DEBUG_ATTACH_KERNEL_CONNECTION ||
#endif
        Flags > DEBUG_ATTACH_EXDI_DRIVER)
    {
        return E_INVALIDARG;
    }

    if (Flags == DEBUG_ATTACH_LOCAL_KERNEL)
    {
        if (ConnectOptions != NULL)
        {
            return E_INVALIDARG;
        }
        if (g_DebuggerPlatformId != VER_PLATFORM_WIN32_NT)
        {
            return E_UNEXPECTED;
        }

        Qual = DEBUG_KERNEL_LOCAL;
    }
    else if (Flags == DEBUG_ATTACH_EXDI_DRIVER)
    {
        Qual = DEBUG_KERNEL_EXDI_DRIVER;
    }
    else
    {
        Qual = DEBUG_KERNEL_CONNECTION;
    }

    ENTER_ENGINE();

    TargetInfo* Target;

    if ((Status = LiveKernelInitialize(this, Qual, ConnectOptions,
                                       &Target)) == S_OK)
    {
        DBG_ASSERT(!g_SessionThread ||
                   g_SessionThread == ::GetCurrentThreadId());
        g_SessionThread = ::GetCurrentThreadId();

        g_Target = Target;
        InitializePrimary();
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetKernelConnectionOptions(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG OptionsSize
    )
{
    if (BufferSize == 0)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    ConnLiveKernelTargetInfo* KdTarg = (ConnLiveKernelTargetInfo*)g_Target;

    if (!IS_CONN_KERNEL_TARGET(g_Target) ||
        KdTarg->m_Transport == NULL)
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    char LocalBuf[4 * (MAX_PARAM_NAME + MAX_PARAM_VALUE + 16)];

    KdTarg->m_Transport->GetParameters(LocalBuf, DIMA(LocalBuf));
    Status = FillStringBuffer(LocalBuf, 0,
                              Buffer, BufferSize, OptionsSize);

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetKernelConnectionOptions(
    THIS_
    IN PCSTR Options
    )
{
    ConnLiveKernelTargetInfo* KdTarg = (ConnLiveKernelTargetInfo*)g_Target;

    if (!IS_CONN_KERNEL_TARGET(g_Target) ||
        KdTarg->m_Transport == NULL)
    {
        return E_UNEXPECTED;
    }

    // This method is reentrant.

    if (!_strcmpi(Options, "resync"))
    {
        KdTarg->m_Transport->m_Resync = TRUE;
    }
    else if (!_strcmpi(Options, "cycle_speed"))
    {
        KdTarg->m_Transport->CycleSpeed();
    }
    else
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

DBGRPC_SIMPLE_FACTORY(LiveUserDebugServices, IID_IUserDebugServices, \
                      "Remote Process Server", (TRUE))
LiveUserDebugServicesFactory g_LiveUserDebugServicesFactory;

STDMETHODIMP
DebugClient::StartProcessServer(
    THIS_
    IN ULONG Flags,
    IN PCSTR Options,
    IN PVOID Reserved
    )
{
    if (Flags <= DEBUG_CLASS_KERNEL || Flags > DEBUG_CLASS_USER_WINDOWS)
    {
        return E_INVALIDARG;
    }
    // XXX drewb - Turn reserved into public IUserDebugServices
    // parameter so that a server can be started over arbitrary services.
    if (Reserved != NULL)
    {
        return E_NOTIMPL;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        DbgRpcClientObjectFactory* Factory;

        switch(Flags)
        {
        case DEBUG_CLASS_USER_WINDOWS:
            Factory = &g_LiveUserDebugServicesFactory;
            Status = DbgRpcCreateServer(Options, Factory, FALSE);
            break;
        default:
            // Flags has already been validated, but check
            // to prevent PREfast warnings.
            Status = E_INVALIDARG;
            break;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ConnectProcessServer(
    THIS_
    IN PCSTR RemoteOptions,
    OUT PULONG64 Server
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        PUSER_DEBUG_SERVICES Services;

        if ((Status = DbgRpcConnectServer(RemoteOptions,
                                          &IID_IUserDebugServices,
                                          (IUnknown**)&Services)) == S_OK)
        {
            *Server = (ULONG64)(ULONG_PTR)Services;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::DisconnectProcessServer(
    THIS_
    IN ULONG64 Server
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    PVOID Object = (PVOID)(ULONG_PTR)Server;

    if (IsBadReadPtr(Object, sizeof(PVOID)) ||
        IsBadReadPtr(*(PVOID*)Object, 3 * sizeof(PVOID)) ||
        IsBadCodePtr(**(FARPROC**)Object))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        ((PUSER_DEBUG_SERVICES)Server)->Release();
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetRunningProcessSystemIds(
    THIS_
    IN ULONG64 Server,
    OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
    IN ULONG Count,
    OUT OPTIONAL PULONG ActualCount
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        Status = SERVER_SERVICES(Server)->
            GetProcessIds(Ids, Count, ActualCount);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetRunningProcessSystemIdByExecutableName(
    THIS_
    IN ULONG64 Server,
    IN PCSTR ExeName,
    IN ULONG Flags,
    OUT PULONG Id
    )
{
    HRESULT Status;
    PWSTR Wide;

    if ((Status = AnsiToWide(ExeName, &Wide)) == S_OK)
    {
        Status = GetRunningProcessSystemIdByExecutableNameWide(Server, Wide,
                                                               Flags, Id);

        FreeWide(Wide);
    }

    return Status;
}

STDMETHODIMP
DebugClient::GetRunningProcessSystemIdByExecutableNameWide(
    THIS_
    IN ULONG64 Server,
    IN PCWSTR ExeName,
    IN ULONG Flags,
    OUT PULONG Id
    )
{
    if (Flags & ~(DEBUG_GET_PROC_DEFAULT |
                  DEBUG_GET_PROC_FULL_MATCH |
                  DEBUG_GET_PROC_ONLY_MATCH))
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        Status = SERVER_SERVICES(Server)->
            GetProcessIdByExecutableNameW(ExeName, Flags, Id);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetRunningProcessDescription(
    THIS_
    IN ULONG64 Server,
    IN ULONG SystemId,
    IN ULONG Flags,
    OUT OPTIONAL PSTR ExeName,
    IN ULONG ExeNameSize,
    OUT OPTIONAL PULONG ActualExeNameSize,
    OUT OPTIONAL PSTR Description,
    IN ULONG DescriptionSize,
    OUT OPTIONAL PULONG ActualDescriptionSize
    )
{
    HRESULT Status;
    PWSTR ExeWide;
    PWSTR DescWide;

    if (ExeName && ExeNameSize > 0)
    {
        ExeWide = (PWSTR)malloc(ExeNameSize * sizeof(WCHAR));
        if (ExeWide == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        ExeWide = NULL;
    }

    if (Description && DescriptionSize > 0)
    {
        DescWide = (PWSTR)malloc(DescriptionSize * sizeof(WCHAR));
        if (DescWide == NULL)
        {
            free(ExeWide);
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        DescWide = NULL;
    }

    Status = GetRunningProcessDescriptionWide(Server, SystemId, Flags,
                                              ExeWide,
                                              ExeNameSize * sizeof(WCHAR),
                                              ActualExeNameSize,
                                              DescWide,
                                              DescriptionSize * sizeof(WCHAR),
                                              ActualDescriptionSize);
    if (SUCCEEDED(Status))
    {
        if ((ExeWide &&
             !WideCharToMultiByte(CP_ACP, 0, ExeWide, -1,
                                  ExeName, ExeNameSize,
                                  NULL, NULL)) ||
            (DescWide &&
             !WideCharToMultiByte(CP_ACP, 0, DescWide, -1,
                                  Description, DescriptionSize,
                                  NULL, NULL)))
        {
            Status = WIN32_LAST_STATUS();
        }
    }

    free(ExeWide);
    free(DescWide);

    return Status;
}

STDMETHODIMP
DebugClient::GetRunningProcessDescriptionWide(
    THIS_
    IN ULONG64 Server,
    IN ULONG SystemId,
    IN ULONG Flags,
    OUT OPTIONAL PWSTR ExeName,
    IN ULONG ExeNameSize,
    OUT OPTIONAL PULONG ActualExeNameSize,
    OUT OPTIONAL PWSTR Description,
    IN ULONG DescriptionSize,
    OUT OPTIONAL PULONG ActualDescriptionSize
    )
{
    HRESULT Status;

    if (Flags & ~(DEBUG_PROC_DESC_DEFAULT |
                  DEBUG_PROC_DESC_NO_PATHS |
                  DEBUG_PROC_DESC_NO_SERVICES |
                  DEBUG_PROC_DESC_NO_MTS_PACKAGES |
                  DEBUG_PROC_DESC_NO_COMMAND_LINE))
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        Status = SERVER_SERVICES(Server)->
            GetProcessDescriptionW(SystemId, Flags,
                                   ExeName, ExeNameSize, ActualExeNameSize,
                                   Description, DescriptionSize,
                                   ActualDescriptionSize);
    }

    LEAVE_ENGINE();
    return Status;
}

#define ALL_ATTACH_FLAGS \
    (DEBUG_ATTACH_NONINVASIVE | \
     DEBUG_ATTACH_EXISTING | \
     DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND | \
     DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK | \
     DEBUG_ATTACH_INVASIVE_RESUME_PROCESS)

BOOL
InvalidAttachFlags(ULONG AttachFlags)
{
    return
        (AttachFlags & ~ALL_ATTACH_FLAGS) ||
        (AttachFlags & (DEBUG_ATTACH_NONINVASIVE | DEBUG_ATTACH_EXISTING)) ==
        (DEBUG_ATTACH_NONINVASIVE | DEBUG_ATTACH_EXISTING) ||
        ((AttachFlags & DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND) &&
         !(AttachFlags & DEBUG_ATTACH_NONINVASIVE)) ||
        ((AttachFlags & DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK) &&
         (AttachFlags & (DEBUG_ATTACH_NONINVASIVE | DEBUG_ATTACH_EXISTING))) ||
        ((AttachFlags & DEBUG_ATTACH_INVASIVE_RESUME_PROCESS) &&
         (AttachFlags & (DEBUG_ATTACH_NONINVASIVE | DEBUG_ATTACH_EXISTING)));
}

STDMETHODIMP
DebugClient::AttachProcess(
    THIS_
    IN ULONG64 Server,
    IN ULONG ProcessId,
    IN ULONG AttachFlags
    )
{
    HRESULT Status;

    if (InvalidAttachFlags(AttachFlags))
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    PPENDING_PROCESS Pending;
    TargetInfo* Target;
    BOOL CreatedTarget;

    if ((Status = UserInitialize(this, Server,
                                 &Target, &CreatedTarget)) != S_OK)
    {
        goto Exit;
    }

    if ((Status = Target->
         StartAttachProcess(ProcessId, AttachFlags, &Pending)) != S_OK)
    {
        if (CreatedTarget)
        {
            delete Target;
        }
        goto Exit;
    }

    DBG_ASSERT(!g_SessionThread ||
               g_SessionThread == ::GetCurrentThreadId());
    g_SessionThread = ::GetCurrentThreadId();

    InitializePrimary();
    g_Target = Target;

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::CreateProcess(
    THIS_
    IN ULONG64 Server,
    IN PSTR CommandLine,
    IN ULONG CreateFlags
    )
{
    HRESULT Status;
    PWSTR Wide;

    if ((Status = AnsiToWide(CommandLine, &Wide)) == S_OK)
    {
        Status = CreateProcessWide(Server, Wide, CreateFlags);

        FreeWide(Wide);
    }

    return Status;
}

STDMETHODIMP
DebugClient::CreateProcessWide(
    THIS_
    IN ULONG64 Server,
    IN PWSTR CommandLine,
    IN ULONG CreateFlags
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!(CreateFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)))
    {
        IUserDebugServices* Services = SERVER_SERVICES(Server);
        ULONG ProcId, ThreadId;
        ULONG64 ProcHandle, ThreadHandle;
        
        // The caller is not requesting that the process be
        // debugged, so we're just being used as a create process
        // wrapper.  This is handy for remote process creation.
        Status = Services->
            CreateProcessW(CommandLine, CreateFlags,
                           TRUE, g_StartProcessDir,
                           &ProcId, &ThreadId,
                           &ProcHandle, &ThreadHandle);
        if (Status == S_OK)
        {
            Services->CloseHandle(ProcHandle);
            Services->CloseHandle(ThreadHandle);
        }
        goto Exit;
    }
    
    PPENDING_PROCESS Pending;
    TargetInfo* Target;
    BOOL CreatedTarget;

    if ((Status = UserInitialize(this, Server,
                                 &Target, &CreatedTarget)) != S_OK)
    {
        goto Exit;
    }

    if ((Status = Target->
         StartCreateProcess(CommandLine, CreateFlags, NULL, NULL,
                            &Pending)) != S_OK)
    {
        if (CreatedTarget)
        {
            delete Target;
        }
        goto Exit;
    }

    DBG_ASSERT(!g_SessionThread ||
               g_SessionThread == ::GetCurrentThreadId());
    g_SessionThread = ::GetCurrentThreadId();

    InitializePrimary();
    g_Target = Target;

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::CreateProcessAndAttach(
    THIS_
    IN ULONG64 Server,
    IN OPTIONAL PSTR CommandLine,
    IN ULONG CreateFlags,
    IN ULONG ProcessId,
    IN ULONG AttachFlags
    )
{
    HRESULT Status;
    PWSTR Wide;

    if (CommandLine)
    {
        Status = AnsiToWide(CommandLine, &Wide);
    }
    else
    {
        Wide = NULL;
        Status = S_OK;
    }

    if (Status == S_OK)
    {
        Status = CreateProcessAndAttachWide(Server, Wide, CreateFlags,
                                            ProcessId, AttachFlags);

        FreeWide(Wide);
    }

    return Status;
}

STDMETHODIMP
DebugClient::CreateProcessAndAttachWide(
    THIS_
    IN ULONG64 Server,
    IN OPTIONAL PWSTR CommandLine,
    IN ULONG CreateFlags,
    IN ULONG ProcessId,
    IN ULONG AttachFlags
    )
{
    if ((CommandLine == NULL && ProcessId == 0) ||
        InvalidAttachFlags(AttachFlags))
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    PPENDING_PROCESS PendCreate, PendAttach;
    TargetInfo* Target;
    BOOL CreatedTarget;

    if ((Status = UserInitialize(this, Server,
                                 &Target, &CreatedTarget)) != S_OK)
    {
        goto Exit;
    }

    if (CommandLine != NULL)
    {
        if (ProcessId != 0)
        {
            CreateFlags |= CREATE_SUSPENDED;
        }

        if ((Status = Target->
             StartCreateProcess(CommandLine, CreateFlags, NULL, NULL,
                                &PendCreate)) != S_OK)
        {
            goto EH_Target;
        }
    }

    if (ProcessId != 0)
    {
        if ((Status = Target->
             StartAttachProcess(ProcessId, AttachFlags,
                                &PendAttach)) != S_OK)
        {
            goto EH_Target;
        }

        // If we previously created a process we need to wake
        // it up when we attach since we created it suspended.
        if (CommandLine != NULL)
        {
            g_ThreadToResume = PendCreate->InitialThreadHandle;
            g_ThreadToResumeServices =
                ((LiveUserTargetInfo*)Target)->m_Services;
        }
    }

    DBG_ASSERT(!g_SessionThread ||
               g_SessionThread == ::GetCurrentThreadId());
    g_SessionThread = ::GetCurrentThreadId();

    InitializePrimary();
    g_Target = Target;

 Exit:
    LEAVE_ENGINE();
    return Status;

 EH_Target:
    if (CreatedTarget)
    {
        delete Target;
    }
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessOptions(
    THIS_
    OUT PULONG Options
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_LIVE_USER_TARGET(g_Target))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = S_OK;
        *Options = g_GlobalProcOptions;
        if (g_Process != NULL)
        {
            *Options |= g_Process->m_Options;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

#define PROCESS_ALL \
    (DEBUG_PROCESS_DETACH_ON_EXIT | DEBUG_PROCESS_ONLY_THIS_PROCESS)
#define PROCESS_GLOBAL \
    (DEBUG_PROCESS_DETACH_ON_EXIT)

HRESULT
ChangeProcessOptions(ULONG Options, ULONG OptFn)
{
    if (Options & ~PROCESS_ALL)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_LIVE_USER_TARGET(g_Target))
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Exit;
    }

    ULONG NewPer, OldPer;
    ULONG NewGlobal;

    switch(OptFn)
    {
    case OPTFN_ADD:
        if (Options & ~PROCESS_GLOBAL)
        {
            if (g_Process == NULL)
            {
                Status = E_UNEXPECTED;
                goto Exit;
            }

            OldPer = g_Process->m_Options;
            NewPer = OldPer | (Options & ~PROCESS_GLOBAL);
        }
        else
        {
            NewPer = 0;
            OldPer = 0;
        }
        NewGlobal = g_GlobalProcOptions | (Options & PROCESS_GLOBAL);
        break;

    case OPTFN_REMOVE:
        if (Options & ~PROCESS_GLOBAL)
        {
            if (g_Process == NULL)
            {
                Status = E_UNEXPECTED;
                goto Exit;
            }

            OldPer = g_Process->m_Options;
            NewPer = OldPer & ~(Options & ~PROCESS_GLOBAL);
        }
        else
        {
            NewPer = 0;
            OldPer = 0;
        }
        NewGlobal = g_GlobalProcOptions & ~(Options & PROCESS_GLOBAL);
        break;

    case OPTFN_SET:
        // Always require a process in this case as otherwise
        // there's no way to know whether a call to SetProcessOptions
        // is actually necessary or not.
        if (g_Process == NULL)
        {
            Status = E_UNEXPECTED;
            goto Exit;
        }

        OldPer = g_Process->m_Options;
        NewPer = Options & ~PROCESS_GLOBAL;
        NewGlobal = Options & PROCESS_GLOBAL;
        break;
    }

    PUSER_DEBUG_SERVICES Services =
        ((LiveUserTargetInfo*)g_Target)->m_Services;
    BOOL Notify = FALSE;

    if (NewGlobal ^ g_GlobalProcOptions)
    {
        // Global options can only be changed by the session thread.
        if (::GetCurrentThreadId() != g_SessionThread)
        {
            Status = E_UNEXPECTED;
            goto Exit;
        }

        if ((Status = Services->SetDebugObjectOptions(0, NewGlobal)) != S_OK)
        {
            goto Exit;
        }

        Notify = TRUE;
        g_GlobalProcOptions = NewGlobal;
    }

    if (NewPer ^ OldPer)
    {
        if ((Status = Services->
             SetProcessOptions(g_Process->m_SysHandle, NewPer)) != S_OK)
        {
            goto Exit;
        }

        g_Process->m_Options = NewPer;
        Notify = TRUE;
    }

    if (Notify)
    {
        NotifyChangeEngineState(DEBUG_CES_PROCESS_OPTIONS,
                                NewPer | NewGlobal, FALSE);
    }

    Status = S_OK;

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AddProcessOptions(
    THIS_
    IN ULONG Options
    )
{
    return ChangeProcessOptions(Options, OPTFN_ADD);
}

STDMETHODIMP
DebugClient::RemoveProcessOptions(
    THIS_
    IN ULONG Options
    )
{
    return ChangeProcessOptions(Options, OPTFN_REMOVE);
}

STDMETHODIMP
DebugClient::SetProcessOptions(
    THIS_
    IN ULONG Options
    )
{
    return ChangeProcessOptions(Options, OPTFN_SET);
}

STDMETHODIMP
DebugClient::OpenDumpFile(
    THIS_
    IN PCSTR DumpFile
    )
{
    HRESULT Status;
    PWSTR Wide;

    if ((Status = AnsiToWide(DumpFile, &Wide)) == S_OK)
    {
        Status = OpenDumpFileWide(Wide, 0);
        FreeWide(Wide);
    }

    return Status;
}

STDMETHODIMP
DebugClient::OpenDumpFileWide(
    THIS_
    IN OPTIONAL PCWSTR FileName,
    IN ULONG64 FileHandle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    //
    // Special feature that works in conjunction with the perl scripts that
    // index customer minidumps to the database.
    // The script checks machine commit when running multithreaded indexing.
    // Reserve 3 Meg of memory so we don't run into commit problems
    // if the scripts start launching large number of debuggers.
    // Free it up as soon as we know the dump file has loaded.
    //

    LPVOID TmpMem = VirtualAlloc(NULL, 0x300000, MEM_RESERVE, PAGE_READWRITE);
    TargetInfo* Target;

    Status = DumpInitialize(this, FileName, FileHandle, &Target);

    if (TmpMem)
    {
        VirtualFree(TmpMem, 0, MEM_RELEASE);
    }

    if (Status == S_OK)
    {
        DBG_ASSERT(!g_SessionThread ||
                   g_SessionThread == ::GetCurrentThreadId());
        g_SessionThread = ::GetCurrentThreadId();

        InitializePrimary();
        g_Target = Target;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteDumpFile(
    THIS_
    IN PCSTR DumpFile,
    IN ULONG Qualifier
    )
{
    return WriteDumpFile2(DumpFile, Qualifier, DEBUG_FORMAT_DEFAULT, NULL);
}

STDMETHODIMP
DebugClient::WriteDumpFile2(
    THIS_
    IN PCSTR DumpFile,
    IN ULONG Qualifier,
    IN ULONG FormatFlags,
    IN OPTIONAL PCSTR Comment
    )
{
    HRESULT Status;
    PWSTR WideFile;

    if ((Status = AnsiToWide(DumpFile, &WideFile)) == S_OK)
    {
        Status = WriteDumpFileInternal(WideFile, 0, Qualifier, FormatFlags,
                                       Comment, NULL);
        FreeWide(WideFile);
    }

    return Status;
}

STDMETHODIMP
DebugClient::WriteDumpFileWide(
    THIS_
    IN OPTIONAL PCWSTR FileName,
    IN ULONG64 FileHandle,
    IN ULONG Qualifier,
    IN ULONG FormatFlags,
    IN OPTIONAL PCWSTR Comment
    )
{
    return WriteDumpFileInternal(FileName, FileHandle,
                                 Qualifier, FormatFlags,
                                 NULL, Comment);
}

HRESULT
DebugClient::WriteDumpFileInternal(
    IN OPTIONAL PCWSTR FileName,
    IN ULONG64 FileHandle,
    IN ULONG Qualifier,
    IN ULONG FormatFlags,
    IN OPTIONAL PCSTR CommentA,
    IN OPTIONAL PCWSTR CommentW
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if ((IS_KERNEL_TARGET(g_Target) &&
         (Qualifier < DEBUG_KERNEL_SMALL_DUMP ||
          Qualifier > DEBUG_KERNEL_FULL_DUMP)) ||
        (IS_USER_TARGET(g_Target) &&
         (Qualifier < DEBUG_USER_WINDOWS_SMALL_DUMP ||
          Qualifier > DEBUG_USER_WINDOWS_DUMP)))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        Status = ::WriteDumpFile(FileName, FileHandle,
                                 Qualifier, FormatFlags,
                                 CommentA, CommentW);
    }

    LEAVE_ENGINE();
    return Status;
}

#define ALL_CONNECT_SESSION_FLAGS \
    (DEBUG_CONNECT_SESSION_NO_VERSION | \
     DEBUG_CONNECT_SESSION_NO_ANNOUNCE)

STDMETHODIMP
DebugClient::ConnectSession(
    THIS_
    IN ULONG Flags,
    IN ULONG HistoryLimit
    )
{
    if (Flags & ~ALL_CONNECT_SESSION_FLAGS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    PushOutCtl(DEBUG_OUTCTL_THIS_CLIENT | DEBUG_OUTCTL_NOT_LOGGED,
               this, &OldCtl);

    if ((Flags & DEBUG_CONNECT_SESSION_NO_VERSION) == 0)
    {
        dprintf("%s", g_WinVersionString);
    }

    SendOutputHistory(this, HistoryLimit);

    // If we're in the middle of an input request and
    // a new client has joined immediately start
    // the input cycle for it.
    ULONG InputRequest = g_InputSizeRequested;

    if (InputRequest > 0)
    {
        m_InputSequence = 1;
        if (m_InputCb != NULL)
        {
            m_InputCb->StartInput(InputRequest);
        }
    }

    PopOutCtl(&OldCtl);

    if ((Flags & DEBUG_CONNECT_SESSION_NO_ANNOUNCE) == 0)
    {
        InitializePrimary();
        dprintf("%s connected at %s", m_Identity, ctime(&m_LastActivity));
    }

    LEAVE_ENGINE();
    return S_OK;
}

DBGRPC_SIMPLE_FACTORY(DebugClient, IID_IDebugClient, \
                      "Debugger Server", ())
DebugClientFactory g_DebugClientFactory;

HRESULT
ClientStartServer(PCSTR Options, BOOL Wait)
{
    HRESULT Status;

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        Status = DbgRpcCreateServer(Options, &g_DebugClientFactory, Wait);
        if (Status == S_OK)
        {
            // Turn on output history collection.
            g_OutHistoryMask = DEFAULT_OUT_HISTORY_MASK;
        }
    }

    return Status;
}

STDMETHODIMP
DebugClient::StartServer(
    THIS_
    IN PCSTR Options
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = ClientStartServer(Options, FALSE);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputServers(
    THIS_
    IN ULONG OutputControl,
    IN PCSTR Machine,
    IN ULONG Flags
    )
{
    if (Flags & ~DEBUG_SERVERS_ALL)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        LONG RegStatus;
        HKEY RegKey;
        HKEY Key;

        Status = S_OK;

        if ((RegStatus = RegConnectRegistry(Machine, HKEY_LOCAL_MACHINE,
                                            &RegKey)) != ERROR_SUCCESS)
        {
            Status = HRESULT_FROM_WIN32(RegStatus);
            goto Pop;
        }
        if ((RegStatus = RegOpenKeyEx(RegKey, DEBUG_SERVER_KEY,
                                      0, KEY_READ,
                                      &Key)) != ERROR_SUCCESS)
        {
            // Don't report not-found as an error since it just
            // means there's nothing to enumerate.
            if (RegStatus != ERROR_FILE_NOT_FOUND)
            {
                Status = HRESULT_FROM_WIN32(RegStatus);
            }
            goto RegClose;
        }

        ULONG Index;
        char Name[32];
        char Value[2 * MAX_PARAM_VALUE];
        ULONG NameLen, ValueLen;
        ULONG Type;

        Index = 0;
        for (;;)
        {
            NameLen = sizeof(Name);
            ValueLen = sizeof(Value);
            if ((RegStatus = RegEnumValue(Key, Index, Name, &NameLen,
                                          NULL, &Type, (LPBYTE)Value,
                                          &ValueLen)) != ERROR_SUCCESS)
            {
                // Done with the enumeration.
                break;
            }
            if (Type != REG_SZ)
            {
                // Only string values should be present.
                Status = E_FAIL;
                break;
            }

            BOOL Output;

            Output = FALSE;
            if (!strncmp(Value, "Debugger Server", 15))
            {
                if (Flags & DEBUG_SERVERS_DEBUGGER)
                {
                    Output = TRUE;
                }
            }
            else if (Flags & DEBUG_SERVERS_PROCESS)
            {
                Output = TRUE;
            }

            if (Output)
            {
                dprintf("%s\n", Value);
            }

            Index++;
        }

        RegCloseKey(Key);
    RegClose:
        RegCloseKey(RegKey);
    Pop:
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::TerminateProcesses(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = ::TerminateProcesses();

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::DetachProcesses(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = ::DetachProcesses();

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::EndSession(
    THIS_
    IN ULONG Flags
    )
{
    if (
#if DEBUG_END_PASSIVE > 0
        Flags < DEBUG_END_PASSIVE ||
#endif
        Flags > DEBUG_END_DISCONNECT)
    {
        return E_INVALIDARG;
    }

    if (Flags == DEBUG_END_REENTRANT)
    {
        // If somebody's doing a reentrant end that means
        // the process is going away so we can clean up
        // any running server registration entries.
        DbgRpcDeregisterServers();
        return S_OK;
    }
    else if (Flags == DEBUG_END_DISCONNECT)
    {
        if (!(m_Flags & CLIENT_REMOTE))
        {
            return E_INVALIDARG;
        }

        Destroy();
        m_LastActivity = time(NULL);
        dprintf("%s disconnected at %s",
                m_Identity, ctime(&m_LastActivity));
        return S_OK;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Exit;
    }

    //
    // Clean up any processes sitting around.
    //

    // If this is an active end, terminate or detach.
    if (Flags == DEBUG_END_ACTIVE_TERMINATE)
    {
        Status = ::TerminateProcesses();
        if (FAILED(Status))
        {
            goto Exit;
        }
    }
    else if (Flags == DEBUG_END_ACTIVE_DETACH)
    {
        Status = ::DetachProcesses();
        if (FAILED(Status))
        {
            goto Exit;
        }
    }

    if (AnySystemProcesses(FALSE) &&
        (g_GlobalProcOptions & DEBUG_PROCESS_DETACH_ON_EXIT) == 0)
    {
        //
        // If we try to quit while debugging CSRSS, raise an
        // error.
        //

        ErrOut("(%d): FATAL ERROR: Exiting Debugger while debugging CSR\n",
               ::GetCurrentProcessId());
        g_NtDllCalls.DbgPrint("(%d): FATAL ERROR: "
                              "Exiting Debugger while debugging CSR\n",
                              ::GetCurrentProcessId());

        if (g_DebuggerPlatformId == VER_PLATFORM_WIN32_NT)
        {
            g_NtDllCalls.NtSystemDebugControl
                (SysDbgBreakPoint, NULL, 0, NULL, 0, 0);
        }

        DebugBreak();
    }

    DiscardSession(Flags == DEBUG_END_ACTIVE_TERMINATE ?
                   DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE :
                   (Flags == DEBUG_END_ACTIVE_DETACH ?
                    DEBUG_SESSION_END_SESSION_ACTIVE_DETACH :
                    DEBUG_SESSION_END_SESSION_PASSIVE));

    Status = S_OK;

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetExitCode(
    THIS_
    OUT PULONG Code
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    if (!IS_LIVE_USER_TARGET(g_Target) ||
        g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = ((LiveUserTargetInfo*)g_Target)->m_Services->
            GetProcessExitCode(g_Process->m_SysHandle, Code);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::DispatchCallbacks(
    THIS_
    IN ULONG Timeout
    )
{
    DWORD Wait;

    // If this client was destroyed its resources are gone.
    // There's also a race condition here that's not easy to fix.
    if (!m_DispatchSema)
    {
        return E_UNEXPECTED;
    }

    // This constitutes interesting activity.
    m_LastActivity = time(NULL);

    // Do not hold the engine lock while waiting.

    for (;;)
    {
        Wait = WaitForSingleObjectEx(m_DispatchSema, Timeout, TRUE);
        if (Wait == WAIT_OBJECT_0)
        {
            return S_OK;
        }
        else if (Wait == WAIT_TIMEOUT)
        {
            return S_FALSE;
        }
        else if (Wait != WAIT_IO_COMPLETION)
        {
            return WIN32_LAST_STATUS();
        }
    }
}

STDMETHODIMP
DebugClient::ExitDispatch(
    THIS_
    IN PDEBUG_CLIENT Client
    )
{
    DebugClient* IntClient = (DebugClient*)(IDebugClientN*)Client;

    // This method is reentrant.

    // If this client was destroyed its resources are gone.
    // There's also a race condition here that's not easy to fix.
    if (!IntClient->m_DispatchSema)
    {
        return E_UNEXPECTED;
    }

    if (!ReleaseSemaphore(IntClient->m_DispatchSema, 1, NULL))
    {
        return WIN32_LAST_STATUS();
    }
    else
    {
        return S_OK;
    }
}

STDMETHODIMP
DebugClient::CreateClient(
    THIS_
    OUT PDEBUG_CLIENT* Client
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    DebugClient* DbgClient = new DebugClient;
    if (DbgClient == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        if ((Status = DbgClient->Initialize()) == S_OK)
        {
            DbgClient->Link();
            *Client = (PDEBUG_CLIENT)(IDebugClientN*)DbgClient;
        }
        else
        {
            DbgClient->Release();
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetInputCallbacks(
    THIS_
    OUT PDEBUG_INPUT_CALLBACKS* Callbacks
    )
{
    ENTER_ENGINE();

    *Callbacks = m_InputCb;
    if (m_InputCb)
    {
        m_InputCb->AddRef();
    }

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetInputCallbacks(
    THIS_
    IN PDEBUG_INPUT_CALLBACKS Callbacks
    )
{
    ENTER_ENGINE();

    TRANSFER(m_InputCb, Callbacks);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetOutputCallbacks(
    THIS_
    OUT PDEBUG_OUTPUT_CALLBACKS* Callbacks
    )
{
    ENTER_ENGINE();

    *Callbacks = m_OutputCb;
    if (m_OutputCb)
    {
        m_OutputCb->AddRef();
    }

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetOutputCallbacks(
    THIS_
    IN PDEBUG_OUTPUT_CALLBACKS Callbacks
    )
{
    ENTER_ENGINE();

    TRANSFER(m_OutputCb, Callbacks);
    CollectOutMasks();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetOutputMask(
    THIS_
    OUT PULONG Mask
    )
{
    // This method is reentrant.
    *Mask = m_OutMask;
    return S_OK;
}

STDMETHODIMP
DebugClient::SetOutputMask(
    THIS_
    IN ULONG Mask
    )
{
    // This method is reentrant.
    m_OutMask = Mask;
    CollectOutMasks();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetOtherOutputMask(
    THIS_
    IN PDEBUG_CLIENT Client,
    OUT PULONG Mask
    )
{
    return Client->GetOutputMask(Mask);
}

STDMETHODIMP
DebugClient::SetOtherOutputMask(
    THIS_
    IN PDEBUG_CLIENT Client,
    IN ULONG Mask
    )
{
    return Client->SetOutputMask(Mask);
}

STDMETHODIMP
DebugClient::GetOutputWidth(
    THIS_
    OUT PULONG Columns
    )
{
    ENTER_ENGINE();

    *Columns = m_OutputWidth;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetOutputWidth(
    THIS_
    IN ULONG Columns
    )
{
    if (Columns < 1)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    m_OutputWidth = Columns;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetOutputLinePrefix(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG PrefixSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = FillStringBuffer(m_OutputLinePrefix, 0,
                              Buffer, BufferSize, PrefixSize);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetOutputLinePrefix(
    THIS_
    IN OPTIONAL PCSTR Prefix
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    ULONG Len;

    Status = ChangeString((PSTR*)&m_OutputLinePrefix, &Len, Prefix);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetIdentity(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG IdentitySize
    )
{
    return FillStringBuffer(m_Identity, 0,
                            Buffer, BufferSize, IdentitySize);
}

STDMETHODIMP
DebugClient::OutputIdentity(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Flags,
    IN PCSTR Format
    )
{
    HRESULT Status;

    if (Flags != DEBUG_OUTPUT_IDENTITY_DEFAULT)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        dprintf(Format, m_Identity);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetEventCallbacks(
    THIS_
    OUT PDEBUG_EVENT_CALLBACKS* Callbacks
    )
{
    ENTER_ENGINE();

    *Callbacks = m_EventCb;
    if (m_EventCb)
    {
        m_EventCb->AddRef();
    }

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetEventCallbacks(
    THIS_
    IN PDEBUG_EVENT_CALLBACKS Callbacks
    )
{
    ENTER_ENGINE();

    HRESULT Status;
    ULONG Interest;

    if (Callbacks != NULL)
    {
        Status = Callbacks->GetInterestMask(&Interest);
    }
    else
    {
        Status = S_OK;
        Interest = 0;
    }

    if (Status == S_OK)
    {
        TRANSFER(m_EventCb, Callbacks);
        m_EventInterest = Interest;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::FlushCallbacks(
    THIS
    )
{
    ::FlushCallbacks();
    return S_OK;
}

STDMETHODIMP
DebugClient::AddDumpInformationFile(
    THIS_
    IN PCSTR InfoFile,
    IN ULONG Type
    )
{
    HRESULT Status;
    PWSTR WideFile;

    if ((Status = AnsiToWide(InfoFile, &WideFile)) == S_OK)
    {
        Status = AddDumpInformationFileWide(WideFile, 0, Type);
        FreeWide(WideFile);
    }
    return Status;
}

STDMETHODIMP
DebugClient::AddDumpInformationFileWide(
    THIS_
    IN OPTIONAL PCWSTR FileName,
    IN ULONG64 FileHandle,
    IN ULONG Type
    )
{
    HRESULT Status;

    if (Type != DEBUG_DUMP_FILE_PAGE_FILE_DUMP)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    // This method must be called before OpenDumpFile.
    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = AddDumpInfoFile(FileName, FileHandle,
                                 DUMP_INFO_PAGE_FILE, 64 * 1024);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::EndProcessServer(
    THIS_
    IN ULONG64 Server
    )
{
    return ((IUserDebugServices*)Server)->
        Uninitialize(TRUE);
}

STDMETHODIMP
DebugClient::WaitForProcessServerEnd(
    THIS_
    IN ULONG Timeout
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_UserServicesUninitialized)
    {
        Status = S_OK;
    }
    else
    {
        //
        // This could be done with an event to get true
        // waiting but precision isn't that important.
        //

        Status = S_FALSE;

        while (Timeout)
        {
            ULONG UseTimeout;

            UseTimeout = min(1000, Timeout);
            Sleep(UseTimeout);

            if (g_UserServicesUninitialized)
            {
                Status = S_OK;
                break;
            }

            if (Timeout != INFINITE)
            {
                Timeout -= UseTimeout;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::IsKernelDebuggerEnabled(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_DebuggerPlatformId != VER_PLATFORM_WIN32_NT)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        NTSTATUS NtStatus;
        SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo;

        NtStatus = g_NtDllCalls.
            NtQuerySystemInformation(SystemKernelDebuggerInformation,
                                     &KdInfo, sizeof(KdInfo), NULL);
        if (NT_SUCCESS(NtStatus))
        {
            Status = KdInfo.KernelDebuggerEnabled ? S_OK : S_FALSE;
        }
        else
        {
            Status = HRESULT_FROM_NT(NtStatus);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::TerminateCurrentProcess(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        Status = SeparateCurrentProcess(SEP_TERMINATE, NULL);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::DetachCurrentProcess(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        Status = SeparateCurrentProcess(SEP_DETACH, NULL);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AbandonCurrentProcess(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_SymOptions & SYMOPT_SECURE)
    {
        Status = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        Status = SeparateCurrentProcess(SEP_ABANDON, NULL);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberDumpFiles(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_DUMP_TARGET(g_Target))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        DumpTargetInfo* DumpTarget = (DumpTargetInfo*)g_Target;
        ULONG i;
        ULONG Count = 0;

        for (i = 0; i < DUMP_INFO_COUNT; i++)
        {
            if (DumpTarget->m_InfoFiles[i].m_File)
            {
                Count++;
            }
        }

        *Number = Count;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetDumpFile(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG NameSize,
    OUT OPTIONAL PULONG64 Handle,
    OUT PULONG Type
    )
{
    HRESULT Status;
    PWSTR BufferWide;

    if (Buffer && BufferSize > 0)
    {
        BufferWide = (PWSTR)malloc(BufferSize * sizeof(WCHAR));
        if (!BufferWide)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
       BufferWide = NULL;
    }

    Status = GetDumpFileWide(Index, BufferWide, BufferSize * sizeof(WCHAR),
                             NameSize, Handle, Type);

    if (BufferWide)
    {
        if (SUCCEEDED(Status))
        {
            if (!WideCharToMultiByte(CP_ACP, 0, BufferWide, -1,
                                     Buffer, BufferSize,
                                     NULL, NULL))
            {
                Status = WIN32_LAST_STATUS();
            }
        }

        free(BufferWide);
    }

    return Status;
}

STDMETHODIMP
DebugClient::GetDumpFileWide(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PWSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG NameSize,
    OUT OPTIONAL PULONG64 Handle,
    OUT PULONG Type
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (Index == DEBUG_DUMP_FILE_LOAD_FAILED_INDEX)
    {
        //
        // Special case to return a failed dump file open
        //

        Status = FillStringBufferW(g_LastFailedDumpFileW, 0,
                                   Buffer, BufferSize, NameSize);
    }
    else if (!IS_DUMP_TARGET(g_Target))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        DumpTargetInfo* DumpTarget = (DumpTargetInfo*)g_Target;
        ULONG i;
        ULONG Count = 0;

        Status = E_NOINTERFACE;
        for (i = 0; i < DUMP_INFO_COUNT; i++)
        {
            if (DumpTarget->m_InfoFiles[i].m_File)
            {
                if (Count == Index)
                {
                    Status = FillStringBufferW(DumpTarget->
                                               m_InfoFiles[i].m_FileNameW, 0,
                                               Buffer, BufferSize, NameSize);
                    if (Handle)
                    {
                        *Handle = (ULONG_PTR)DumpTarget->m_InfoFiles[i].m_File;
                    }
                    *Type = g_DumpApiTypes[i];
                    break;
                }

                Count++;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
DebugClient::Initialize(void)
{
    m_DispatchSema = CreateSemaphore(NULL, 0, 0x7fffffff, NULL);
    if (m_DispatchSema == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    if (!DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),
                         GetCurrentProcess(), &m_Thread,
                         0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        return WIN32_LAST_STATUS();
    }

    // If we're requesting input allow this client
    // to return input immediately.
    if (g_InputSizeRequested > 0)
    {
        m_InputSequence = 1;
    }

    return S_OK;
}

void
DebugClient::InitializePrimary(void)
{
    if (m_Flags & CLIENT_PRIMARY)
    {
        return;
    }

    m_Flags |= CLIENT_PRIMARY;
    if ((m_Flags & CLIENT_REMOTE) == 0)
    {
        // Can't call GetClientIdentity here as it uses
        // many system APIs and therefore can cause trouble
        // when debugging system processes such as LSA.
        strcpy(m_Identity, "HostMachine\\HostUser");
    }
    m_LastActivity = time(NULL);
}

void
DebugClient::Link(void)
{
    EnterCriticalSection(&g_QuickLock);

    // Keep list grouped by thread ID.
    DebugClient* Cur;

    for (Cur = g_Clients; Cur != NULL; Cur = Cur->m_Next)
    {
        if (Cur->m_ThreadId == m_ThreadId)
        {
            break;
        }
    }

    m_Prev = Cur;
    if (Cur != NULL)
    {
        m_Next = Cur->m_Next;
        Cur->m_Next = this;
    }
    else
    {
        // No ID match so just put it in the front.
        m_Next = g_Clients;
        g_Clients = this;
    }
    if (m_Next != NULL)
    {
        m_Next->m_Prev = this;
    }

    m_Flags |= CLIENT_IN_LIST;

    LeaveCriticalSection(&g_QuickLock);
}

void
DebugClient::Unlink(void)
{
    EnterCriticalSection(&g_QuickLock);

    m_Flags &= ~CLIENT_IN_LIST;

    if (m_Next != NULL)
    {
        m_Next->m_Prev = m_Prev;
    }
    if (m_Prev != NULL)
    {
        m_Prev->m_Next = m_Next;
    }
    else
    {
        g_Clients = m_Next;
    }

    LeaveCriticalSection(&g_QuickLock);
}

//----------------------------------------------------------------------------
//
// Initialize/uninitalize functions.
//
//----------------------------------------------------------------------------

DebugClient*
FindClient(ULONG Tid, ULONG IncFlags, ULONG ExcFlags)
{
    DebugClient* Client;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if ((!Tid || Client->m_ThreadId == Tid) &&
            (Client->m_Flags & IncFlags) &&
            !(Client->m_Flags & ExcFlags))
        {
            return Client;
        }
    }

    return NULL;
}

ULONG __cdecl
Win32DbgPrint(char *Text, ...)
{
    char Temp[OUT_BUFFER_SIZE - 16];
    va_list Args;

    va_start(Args, Text);
    _vsnprintf(Temp, sizeof(Temp) - 1, Text, Args);
    Temp[sizeof(Temp) - 1] = 0;
    va_end(Args);
    OutputDebugStringA(Temp);

    return 0;
}

HRESULT
OneTimeInitialization(void)
{
    static BOOL Init = FALSE;
    if (Init)
    {
        return S_OK;
    }

    // This function is called exactly once at the first
    // DebugCreate for a process.  It should perform any
    // global one-time initialization necessary.
    // Nothing initialized here will be explicitly cleaned
    // up, instead it should all be the kind of thing
    // that can wait for process cleanup.

    HRESULT Status = S_OK;

    // These sizes are hard-coded into the remoting script
    // so verify them to ensure no mismatch.
    C_ASSERT(sizeof(DEBUG_BREAKPOINT_PARAMETERS) == 56);
    C_ASSERT(sizeof(DEBUG_STACK_FRAME) == 128);
    C_ASSERT(sizeof(DEBUG_VALUE) == 32);
    C_ASSERT(sizeof(DEBUG_REGISTER_DESCRIPTION) == 32);
    C_ASSERT(sizeof(DEBUG_SYMBOL_PARAMETERS) == 32);
    C_ASSERT(sizeof(DEBUG_MODULE_PARAMETERS) == 64);
    C_ASSERT(sizeof(DEBUG_SPECIFIC_FILTER_PARAMETERS) == 20);
    C_ASSERT(sizeof(DEBUG_EXCEPTION_FILTER_PARAMETERS) == 24);
    C_ASSERT(sizeof(EXCEPTION_RECORD64) == 152);
    C_ASSERT(sizeof(MEMORY_BASIC_INFORMATION64) == 48);

    g_Sym->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL64);
    g_Sym->MaxNameLength = MAX_SYMBOL_LEN;

    SYSTEM_INFO SystemInfo;

    GetSystemInfo(&SystemInfo);
    g_SystemAllocGranularity = SystemInfo.dwAllocationGranularity;

    // Get the debugger host system's OS type.  Note that
    // this may be different from g_TargetPlatformId, which
    // is the OS type of the debug target.
    OSVERSIONINFO OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
    if (!GetVersionEx(&OsVersionInfo))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Fail;
    }
    g_DebuggerPlatformId = OsVersionInfo.dwPlatformId;

    if (g_DebuggerPlatformId == VER_PLATFORM_WIN32_NT)
    {
        if ((Status = InitDynamicCalls(&g_NtDllCallsDesc)) != S_OK)
        {
            goto EH_Fail;
        }
    }
    else
    {
        g_NtDllCalls.DbgPrint = Win32DbgPrint;
    }

    if ((Status = InitDynamicCalls(&g_Kernel32CallsDesc)) != S_OK)
    {
        goto EH_Fail;
    }

    if ((Status = InitDynamicCalls(&g_Advapi32CallsDesc)) != S_OK)
    {
        goto EH_Fail;
    }

    ULONG SvcFlags;

    if ((Status = g_LiveUserDebugServices.Initialize(&SvcFlags)) != S_OK)
    {
        goto EH_Fail;
    }

    g_InputEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_InputEvent == NULL)
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Fail;
    }

    g_EventStatusWaiting = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_EventStatusWaiting == NULL)
    {
        Status = WIN32_LAST_STATUS();
        goto EH_InputEvent;
    }

    g_EventStatusReady = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_EventStatusReady == NULL)
    {
        Status = WIN32_LAST_STATUS();
        goto EH_EventStatusWaiting;
    }

    g_SleepPidEvent = CreatePidEvent(GetCurrentProcessId(), CREATE_NEW);
    if (g_SleepPidEvent == NULL)
    {
        Status = E_FAIL;
        goto EH_EventStatusReady;
    }

    if ((Status = InitializeAllAccessSecObj()) != S_OK)
    {
        goto EH_SleepPidEvent;
    }

    __try
    {
        InitializeCriticalSection(&g_QuickLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = HRESULT_FROM_NT(GetExceptionCode());
        goto EH_AllAccessObj;
    }

    __try
    {
        InitializeCriticalSection(&g_EngineLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = HRESULT_FROM_NT(GetExceptionCode());
        goto EH_QuickLock;
    }

    if ((Status = BreakpointInit()) != S_OK)
    {
        goto EH_EngineLock;
    }

    g_SrcPath = getenv("_NT_SOURCE_PATH");
    if (g_SrcPath != NULL)
    {
        // This path must be in allocated space.
        // If this fails it's not catastrophic.
        g_SrcPath = _strdup(g_SrcPath);
    }

    // Set default symbol options.
    SymSetOptions(g_SymOptions);

    if (getenv("KDQUIET"))
    {
        g_QuietMode = TRUE;
    }
    else
    {
        g_QuietMode = FALSE;
    }

    ReadDebugOptions(TRUE, NULL);

    PCSTR Env;

#if DBG
    // Get default out mask from environment variables.
    Env = getenv("DBGENG_OUT_MASK");
    if (Env != NULL)
    {
        ULONG Mask = strtoul(Env, NULL, 0);
        g_EnvOutMask |= Mask;
        g_LogMask |= Mask;
    }
#endif

    Env = getenv("_NT_DEBUG_HISTORY_SIZE");
    if (Env != NULL)
    {
        g_OutHistoryRequestedSize = atoi(Env) * 1024;
    }

    Env = getenv("_NT_EXPR_EVAL");
    if (Env)
    {
        SetExprSyntaxByName(Env);
    }

    Init = TRUE;

    return S_OK;

 EH_EngineLock:
    DeleteCriticalSection(&g_EngineLock);
 EH_QuickLock:
    DeleteCriticalSection(&g_QuickLock);
 EH_AllAccessObj:
    DeleteAllAccessSecObj();
 EH_SleepPidEvent:
    CloseHandle(g_SleepPidEvent);
    g_SleepPidEvent = NULL;
 EH_EventStatusReady:
    CloseHandle(g_EventStatusReady);
    g_EventStatusReady = NULL;
 EH_EventStatusWaiting:
    CloseHandle(g_EventStatusWaiting);
    g_EventStatusWaiting = NULL;
 EH_InputEvent:
    CloseHandle(g_InputEvent);
    g_InputEvent = NULL;
 EH_Fail:
    return Status;
}

STDAPI
DebugConnect(
    IN PCSTR RemoteOptions,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;

    if ((Status = OneTimeInitialization()) != S_OK)
    {
        return Status;
    }

    IUnknown* Client;

    if ((Status = DbgRpcConnectServer(RemoteOptions, &IID_IDebugClient,
                                      &Client)) != S_OK)
    {
        return Status;
    }

    Status = Client->QueryInterface(InterfaceId, Interface);

    Client->Release();
    return Status;
}

STDAPI
DebugCreate(
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;

    if ((Status = OneTimeInitialization()) != S_OK)
    {
        return Status;
    }

    DebugClient* Client = new DebugClient;
    if (Client == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        if ((Status = Client->Initialize()) == S_OK)
        {
            Status = Client->QueryInterface(InterfaceId, Interface);
            if (Status == S_OK)
            {
                Client->Link();
            }
        }

        Client->Release();
    }

    return Status;
}

HRESULT
CheckDbgHelpVersion(DebugClient* Client)
{
    g_DbgHelpVersion = *ImagehlpApiVersionEx(&g_EngApiVersion);
    if (g_DbgHelpVersion.Revision < g_EngApiVersion.Revision)
    {
        //
        // Version mismatch.
        //
        if ((g_EngOptions & DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION) == 0)
        {
            ErrOut("dbghelp.dll has a version mismatch with the debugger\n\n");
            OutputVersionInformation(Client);
            return E_FAIL;
        }
        else
        {
            WarnOut("dbghelp.dll has a version mismatch "
                    "with the debugger\n\n");
        }
    }

    return S_OK;
}

// Roughly 1.5 months.
#define STALE_SECONDS (60 * 60 * 24 * 45)

void
CheckForStaleBinary(PCSTR DllName, BOOL Thorough)
{
    HMODULE Mod;
    PIMAGE_NT_HEADERS NtHdr;
    time_t CurTime;

    if (!IsInternalPackage())
    {
        // Don't give any warnings for external packages.
        return;
    }

    Mod = GetModuleHandle(DllName);
    if (!Mod)
    {
        return;
    }

    NtHdr = ImageNtHeader(Mod);
    if (!NtHdr)
    {
        return;
    }

    CurTime = time(NULL);
    if (NtHdr->FileHeader.TimeDateStamp + STALE_SECONDS < (ULONG)CurTime)
    {
        WarnOut("\n"
                "***** WARNING: Your debugger is probably out-of-date.\n"
                "*****          Check http://dbg for updates.\n"
                "\n");
        return;
    }

    //
    // The debugger is reasonably recent.  If we're allowed
    // to, check for a new version on \\dbg\privates.
    //

    if (!Thorough ||
        (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS))
    {
        return;
    }

    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    BOOL Stale;
    ULARGE_INTEGER WriteTime;

    FindHandle = FindFirstFile("\\\\dbg\\privates\\latest\\dbg_x86.msi",
                               &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        return;
    }

    Stale = FALSE;

    WriteTime.LowPart = FindData.ftLastWriteTime.dwLowDateTime;
    WriteTime.HighPart = FindData.ftLastWriteTime.dwHighDateTime;
    // The package is built after the binaries so its time will
    // normally be slightly more recent than the binary headers.
    // Throw in a fudge factor to account for this.
    if (WriteTime.QuadPart >
        TimeDateStampToFileTime(NtHdr->FileHeader.TimeDateStamp) +
        TimeToFileTime(60I64 * 60 * 24))
    {
        Stale = TRUE;
    }

    FindClose(FindHandle);

    if (Stale)
    {
        WarnOut("\n"
                "***** WARNING: A newer debugger is available.\n"
                "*****          Check http://dbg for updates.\n"
                "\n");
    }
}

HRESULT
CheckSessionInitialize(DebugClient* Client)
{
    HRESULT Status;

    // Enforce that all target creations must come
    // from the same thread.
    if (g_SessionThread &&
        (g_SessionThread != ::GetCurrentThreadId()))
    {
        return E_INVALIDARG;
    }

    if ((Status = CheckDbgHelpVersion(Client)) != S_OK)
    {
        return Status;
    }

    // Show a version message once for the very
    // first session start.
    if (!g_VersionMessage)
    {
        dprintf("%s", g_WinVersionString);
        g_VersionMessage = TRUE;

        CheckForStaleBinary(ENGINE_DLL_NAME, FALSE);
    }

    return S_OK;
}

HRESULT
LiveKernelInitialize(DebugClient* Client, ULONG Qual, PCSTR Options,
                     TargetInfo** TargetRet)
{
    HRESULT Status;
    LiveKernelTargetInfo* Target;

    if ((Status = CheckSessionInitialize(Client)) != S_OK)
    {
        return Status;
    }

    if (Qual == DEBUG_KERNEL_CONNECTION)
    {
        Target = new ConnLiveKernelTargetInfo;
    }
    else if (Qual == DEBUG_KERNEL_LOCAL)
    {
        if (g_SymOptions & SYMOPT_SECURE)
        {
            return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        }

        //
        // We need to get the debug privilege to enable local kernel debugging
        //
        if ((Status = EnableDebugPrivilege()) != S_OK)
        {
            ErrOut("Unable to enable debug privilege, %s\n    \"%s\"\n",
                   FormatStatusCode(Status), FormatStatus(Status));
            return Status;
        }

        Target = new LocalLiveKernelTargetInfo;
    }
    else
    {
        if (g_SymOptions & SYMOPT_SECURE)
        {
            return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        }

        Target = new ExdiLiveKernelTargetInfo;
    }
    if (!Target)
    {
        return E_OUTOFMEMORY;
    }

    // These options only need to stay valid until Initialize.
    Target->m_ConnectOptions = Options;

    Status = Target->Initialize();
    if (Status != S_OK)
    {
        delete Target;
        return Status;
    }

    Target->Link();
    *TargetRet = Target;
    return S_OK;
}

HRESULT
UserInitialize(DebugClient* Client, ULONG64 Server,
               TargetInfo** TargetRet, PBOOL CreatedTargetRet)
{
    HRESULT Status;
    LiveUserTargetInfo* Target;
    PUSER_DEBUG_SERVICES Services;

    if (g_SymOptions & SYMOPT_SECURE)
    {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    if ((Status = CheckSessionInitialize(Client)) != S_OK)
    {
        return Status;
    }

    //
    // Look for an existed target handled by this server.
    //

    *TargetRet = FindTargetByServer(Server);
    if (*TargetRet)
    {
        *CreatedTargetRet = FALSE;
        return S_OK;
    }

    //
    // No existing target, so create a new target.
    //

    Target = new LiveUserTargetInfo(Server ?
                                    DEBUG_USER_WINDOWS_PROCESS_SERVER :
                                    DEBUG_USER_WINDOWS_PROCESS);
    if (!Target)
    {
        return E_OUTOFMEMORY;
    }
    if ((Status = Target->Initialize()) != S_OK)
    {
        delete Target;
        return Status;
    }

    if (Server == 0)
    {
        Services = new LiveUserDebugServices(FALSE);
        if (!Services)
        {
            delete Target;
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        Services = (PUSER_DEBUG_SERVICES)Server;
        Services->AddRef();
    }

    // Set the services right away so they'll get
    // cleaned up by the target destructor.
    Target->m_Services = Services;

    Status = Target->SetServices(Services, Server != 0);
    if (Status != S_OK)
    {
        delete Target;
        return Status;
    }

    Target->Link();
    *TargetRet = Target;
    *CreatedTargetRet = TRUE;
    return S_OK;
}

HRESULT
DumpInitialize(DebugClient* Client,
               PCWSTR FileName, ULONG64 FileHandle,
               TargetInfo** TargetRet)
{
    HRESULT Status;

    if (g_SymOptions & SYMOPT_SECURE)
    {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    if ((Status = CheckSessionInitialize(Client)) != S_OK)
    {
        return Status;
    }

    //
    // Automatically expand CAB files.
    //

    PCWSTR OpenFile = FileName;
    PWSTR CabWide = NULL;
    INT_PTR CabDumpFh = -1;
    PWSTR Ext;

    if (!FileHandle)
    {
        Ext = wcsrchr(FileName, L'.');
    }
    else
    {
        Ext = NULL;
    }
    if (Ext != NULL && _wcsicmp(Ext, L".cab") == 0)
    {
        PSTR AnsiFile;
        char CabDumpFile[2 * MAX_PATH];

        if ((Status = WideToAnsi(FileName, &AnsiFile)) != S_OK)
        {
            return Status;
        }

        // Expand the first .dmp or .mdmp file in the CAB.
        // Mark it as delete-on-close so it always gets
        // cleaned up regardless of how the process exits.
        if ((Status = ExpandDumpCab(AnsiFile,
                                    _O_CREAT | _O_EXCL | _O_TEMPORARY,
                                    NULL,
                                    CabDumpFile, DIMA(CabDumpFile),
                                    &CabDumpFh)) != S_OK)
        {
            ErrOut("Unable to extract dump file from CAB file\n");
        }
        else
        {
            Status = AnsiToWide(CabDumpFile, &CabWide);
        }

        FreeAnsi(AnsiFile);

        if (Status != S_OK)
        {
            return Status;
        }

        OpenFile = CabWide;
        dprintf("Extracted %s\n", CabDumpFile);
    }

    DumpTargetInfo* Target;

    Status = IdentifyDump(OpenFile, FileHandle, &Target);

    if (CabDumpFh >= 0)
    {
        // We expanded a file from a CAB and can close it
        // now because it was either reopened or we need
        // to get rid of it.
        _close((int)CabDumpFh);
    }

    if (Status != S_OK)
    {
        CopyStringW(g_LastFailedDumpFileW,
                    OpenFile,
                    sizeof(g_LastFailedDumpFileW)/sizeof(WCHAR));

        FreeWide(CabWide);

        ErrOut("Could not open dump file [%ws], %s\n    \"%s\"\n",
               FileName ? FileName : L"<HandleOnly>",
               FormatStatusCode(Status),
               FormatStatusArgs(Status, &FileName));
        return Status;
    }

    FreeWide(CabWide);

    Status = Target->Initialize();

    if (Status != S_OK)
    {
        delete Target;
    }
    else
    {
        Target->Link();
        *TargetRet = Target;
    }

    return Status;
}

void
DiscardSession(ULONG Reason)
{
    if (g_TargetHead)
    {
        DiscardTargets(Reason);
    }

    g_SessionThread = 0;

    ClearEventLog();

    g_ThreadToResume = 0;
    g_ThreadToResumeServices = NULL;
    ZeroMemory(g_UserIdFragmented, sizeof(g_UserIdFragmented));
    ZeroMemory(g_HighestUserId, sizeof(g_HighestUserId));

    g_OciOutputRegs = FALSE;
    g_LastCommand[0] = 0;

    g_GlobalProcOptions = 0;
    g_EngStatus = 0;
    g_EngDefer = 0;
    g_EngErr = 0;
    g_OutHistRead = NULL;
    g_OutHistWrite = NULL;
    g_OutHistoryMask = 0;
    g_OutHistoryUsed = 0;
}

void
DiscardedTargets(ULONG Reason)
{
    // Unload all extension DLLs to allow people to
    // update extensions after shutdown/during reboot.
    DeferAllExtensionDlls();

    ::FlushCallbacks();

    // Send final notifications.
    // This must be done after all the work as the lock
    // will be suspended during the callbacks, allowing
    // other threads in, so the state must be consistent.

    ULONG ExecStatus = GetExecutionStatus();
    if (ExecStatus == DEBUG_STATUS_NO_DEBUGGEE)
    {
        NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                                ExecStatus, TRUE);
        NotifySessionStatus(Reason);
        NotifyExtensions(DEBUG_NOTIFY_SESSION_INACTIVE, 0);
    }
}

void
DiscardTargets(ULONG Reason)
{
    g_CmdState = 'i';
    g_ExecutionStatusRequest = DEBUG_STATUS_NO_CHANGE;

    TargetInfo* Target;

    ForAllLayersToTarget()
    {
        Target->m_Exited = TRUE;
    }

    // Breakpoint removal must wait until everything is marked as
    // exited to avoid asserts on breakpoints that are inserted.
    RemoveAllBreakpoints(Reason);

    DeleteAllExitedInfos();

    DiscardLastEvent();
    ZeroMemory(&g_LastEventInfo, sizeof(g_LastEventInfo));

    ResetStepTrace();

    g_EngStatus &= ~(ENG_STATUS_SUSPENDED |
                     ENG_STATUS_BREAKPOINTS_INSERTED |
                     ENG_STATUS_STATE_CHANGED |
                     ENG_STATUS_PREPARED_FOR_CALLS |
                     ENG_STATUS_NO_AUTO_WAIT |
                     ENG_STATUS_PENDING_BREAK_IN |
                     ENG_STATUS_AT_INITIAL_BREAK |
                     ENG_STATUS_AT_INITIAL_MODULE_LOAD |
                     ENG_STATUS_EXIT_CURRENT_WAIT |
                     ENG_STATUS_USER_INTERRUPT |
                     ENG_STATUS_WAIT_SUCCESSFUL);
    g_EngDefer &= ~(ENG_DEFER_EXCEPTION_HANDLING |
                    ENG_DEFER_UPDATE_CONTROL_SET |
                    ENG_DEFER_HARDWARE_TRACING |
                    ENG_DEFER_OUTPUT_CURRENT_INFO);
    g_EngErr &= ~(ENG_ERR_DEBUGGER_DATA);

    g_LastSelector = -1;
    ClearAddr(&g_EventPc);
    ClearAddr(&g_PrevEventPc);
    ClearAddr(&g_PrevRelatedPc);

    // Delete all remaining generated types.
    g_GenTypes.DeleteByImage(IMAGE_BASE_ALL);

    DiscardedTargets(Reason);
}

//----------------------------------------------------------------------------
//
// DbgRpcClientObject implementation.
//
//----------------------------------------------------------------------------

HRESULT
DebugClient::RpcInitialize(PSTR ClientIdentity, PSTR TransIdentity,
                           PVOID* Interface)
{
    HRESULT Status;
    ULONG Len, Used;

    m_Flags |= CLIENT_REMOTE;
    if ((Status = Initialize()) != S_OK)
    {
        return Status;
    }

    Len = strlen(ClientIdentity);
    if (Len > sizeof(m_Identity) - 16)
    {
        Len = sizeof(m_Identity) - 16;
    }
    memcpy(m_Identity, ClientIdentity, Len);
    Used = Len;
    m_Identity[Used++] = ' ';
    m_Identity[Used++] = '(';
    Len = strlen(TransIdentity);
    if (Len > sizeof(m_Identity) - Used - 2)
    {
        Len = sizeof(m_Identity) - Used - 2;
    }
    memcpy(m_Identity + Used, TransIdentity, Len);
    Used += Len;
    m_Identity[Used++] = ')';
    m_Identity[Used] = 0;

    *Interface = (IDebugClientN*)this;

    return S_OK;
}

void
DebugClient::RpcFinalize(void)
{
    Link();

    // Take a reference on this object for the RPC client
    // thread to hold.
    AddRef();
}

void
DebugClient::RpcUninitialize(void)
{
    // Directly destroy the client object rather than releasing
    // as the remote client may have exited without politely
    // cleaning up references.
    Destroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgctrl.cpp ===
//----------------------------------------------------------------------------
//
// IDebugControl implementation.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

ULONG g_LogMask = DEFAULT_OUT_MASK;

STDMETHODIMP
DebugClient::GetInterrupt(
    THIS
    )
{
    // This method is reentrant.
    return CheckUserInterrupt() ? S_OK : S_FALSE;
}

STDMETHODIMP
DebugClient::SetInterrupt(
    THIS_
    IN ULONG Flags
    )
{
    // This method is reentrant.

    if (
#if DEBUG_INTERRUPT_ACTIVE > 0
        Flags < DEBUG_INTERRUPT_ACTIVE ||
#endif
        Flags > DEBUG_INTERRUPT_EXIT)
    {
        return E_INVALIDARG;
    }

    if (!g_Target)
    {
        return E_UNEXPECTED;
    }

    // If the debuggee isn't currently running
    // we just need to set the operation-interrupt
    // flag.  If this is a passive interrupt that's
    // all that's ever done.
    if (Flags == DEBUG_INTERRUPT_PASSIVE ||
        (IS_MACHINE_SET(g_Target) && g_CmdState == 'c'))
    {
        g_EngStatus |= ENG_STATUS_USER_INTERRUPT;
        return S_OK;
    }

    // If this is an exit interrupt we don't want
    // to actually interrupt the running debuggee,
    // we just want to terminate the current wait.
    if (Flags == DEBUG_INTERRUPT_EXIT)
    {
        g_EngStatus |= ENG_STATUS_EXIT_CURRENT_WAIT;
        return S_OK;
    }
    
    //
    // Force a break-in.  Don't set user-interrupt in
    // this case as that's just a marker for
    // interrupting commands.  Setting it can
    // interfere with break-in processing since commands
    // executed during break-in may be affected by it.
    //
    
    HRESULT Status = g_Target->RequestBreakIn();

    if (Status == S_OK)
    {
        g_EngStatus |= ENG_STATUS_PENDING_BREAK_IN;
    }

    return Status;
}

STDMETHODIMP
DebugClient::GetInterruptTimeout(
    THIS_
    OUT PULONG Seconds
    )
{
    ENTER_ENGINE();

    *Seconds = g_PendingBreakInTimeoutLimit;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetInterruptTimeout(
    THIS_
    IN ULONG Seconds
    )
{
    if (Seconds < 1)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    g_PendingBreakInTimeoutLimit = Seconds;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetLogFile(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG FileSize,
    OUT PBOOL Append
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_OpenLogFileName[0])
    {
        Status = E_NOINTERFACE;
        *Append = FALSE;
    }
    else
    {
        Status = FillStringBuffer(g_OpenLogFileName, 0,
                                  Buffer, BufferSize, FileSize);
        *Append = g_OpenLogFileAppended;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OpenLogFile(
    THIS_
    IN PCSTR File,
    IN BOOL Append
    )
{
    ENTER_ENGINE();

    ::OpenLogFile(File, Append);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::CloseLogFile(
    THIS
    )
{
    ENTER_ENGINE();

    ::CloseLogFile();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetLogMask(
    THIS_
    OUT PULONG Mask
    )
{
    // This method is reentrant.
    *Mask = g_LogMask;
    return S_OK;
}

STDMETHODIMP
DebugClient::SetLogMask(
    THIS_
    IN ULONG Mask
    )
{
    // This method is reentrant.
    g_LogMask = Mask;
    return S_OK;
}

STDMETHODIMP
DebugClient::Input(
    THIS_
    OUT PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG InputSize
    )
{
    HRESULT Status;
    
    if (BufferSize < 2)
    {
        // Must have space for at least a character and a terminator.
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    ULONG Size;

    //
    // XXX drewb.
    // In condbg we needed a way to see how many clients
    // were available for input.  Rather than define a new
    // interface and method just for this purpose we've added
    // this hack where you pass in a magic combination of parameters.
    // If a new IDebugControl ever gets defined this should be
    // formalized and the hack removed.
    //
    
    if (!Buffer && BufferSize == DEBUG_ANY_ID)
    {
        DebugClient* Client;

        Size = 0;
        for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
        {
            if (Client->m_InputCb != NULL)
            {
                Size++;
            }
        }

        Status = S_OK;
    }
    else
    {
        Size = GetInput(NULL, Buffer, BufferSize, GETIN_DEFAULT);
        if (Size == 0)
        {
            Status = E_FAIL;
            goto Exit;
        }

        Status = Size > BufferSize ? S_FALSE : S_OK;
    }
    
    if (InputSize != NULL)
    {
        *InputSize = Size;
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReturnInput(
    THIS_
    IN PCSTR Buffer
    )
{
    // This method is reentrant.

    HRESULT Status;
    ULONG Seq = (ULONG)InterlockedIncrement((PLONG)&g_InputSequence);
    if (Seq == m_InputSequence)
    {
        ULONG CopyLen = strlen(Buffer) + 1;
        CopyLen = min(CopyLen, INPUT_BUFFER_SIZE);
        memcpy(g_InputBuffer, Buffer, CopyLen);
        g_InputBuffer[INPUT_BUFFER_SIZE - 1] = 0;
        SetEvent(g_InputEvent);
        Status = S_OK;
    }
    else
    {
        Status = S_FALSE;
    }

    m_InputSequence = 0xffffffff;
    return Status;
}

STDMETHODIMPV
DebugClient::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    ENTER_ENGINE();

    va_list Args;

    va_start(Args, Format);
    MaskOutVa(Mask, Format, Args, TRUE);
    va_end(Args);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::OutputVaList(
    THIS_
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    ENTER_ENGINE();

    MaskOutVa(Mask, Format, Args, TRUE);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMPV
DebugClient::ControlledOutput(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        va_list Args;

        va_start(Args, Format);
        MaskOutVa(Mask, Format, Args, TRUE);
        va_end(Args);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ControlledOutputVaList(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        MaskOutVa(Mask, Format, Args, TRUE);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMPV
DebugClient::OutputPrompt(
    THIS_
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    ...
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        va_list Args;

        va_start(Args, Format);
        ::OutputPrompt(Format, Args);
        va_end(Args);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputPromptVaList(
    THIS_
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    IN va_list Args
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        ::OutputPrompt(Format, Args);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetPromptText(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG TextSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = ::GetPromptText(Buffer, BufferSize, TextSize);

    LEAVE_ENGINE();
    return Status;
}

#define CURRENT_ALL DEBUG_CURRENT_DEFAULT

STDMETHODIMP
DebugClient::OutputCurrentState(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Flags
    )
{
    if (Flags & ~CURRENT_ALL)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    
    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        ULONG Oci = 0;

        if (Flags & DEBUG_CURRENT_SYMBOL)
        {
            Oci |= OCI_SYMBOL;
        }
        if (Flags & DEBUG_CURRENT_DISASM)
        {
            Oci |= OCI_DISASM | OCI_ALLOW_EA;
        }
        if (Flags & DEBUG_CURRENT_REGISTERS)
        {
            Oci |= OCI_ALLOW_REG;
        }
        if (Flags & DEBUG_CURRENT_SOURCE_LINE)
        {
            Oci |= OCI_ALLOW_SOURCE;
        }

        OutCurInfo(Oci, g_Machine->m_AllMask, DEBUG_OUTPUT_PROMPT_REGISTERS);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputVersionInformation(
    THIS_
    IN ULONG OutputControl
    )
{
    HRESULT Status;

    // This method is reentrant.  It uses many pieces of
    // global information, though, so try and get
    // the engine lock.

    Status = TRY_ENTER_ENGINE();
    if (Status != S_OK)
    {
        return Status;
    }

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        return E_INVALIDARG;
    }

    ::OutputVersionInformation(this);

    PopOutCtl(&OldCtl);
    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetNotifyEventHandle(
    THIS_
    OUT PULONG64 Handle
    )
{
    ENTER_ENGINE();

    *Handle = (ULONG64)g_EventToSignal;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetNotifyEventHandle(
    THIS_
    IN ULONG64 Handle
    )
{
    if ((ULONG64)(HANDLE)Handle != Handle)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    g_EventToSignal = (HANDLE)Handle;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::Assemble(
    THIS_
    IN ULONG64 Offset,
    IN PCSTR Instr,
    OUT PULONG64 EndOffset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    __try
    {
        if (!IS_CUR_CONTEXT_ACCESSIBLE())
        {
            Status = E_UNEXPECTED;
            __leave;
        }

        ADDR Addr;

        // Assume this is a code segment address so that assembly
        // picks up the appropriate type of address.
        g_Machine->FormAddr(SEGREG_CODE, Offset,
                            FORM_SEGREG | FORM_CODE, &Addr);

        g_Machine->Assemble(g_Process, &Addr, (PSTR)Instr);
        *EndOffset = Flat(Addr);
        Status = S_OK;
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        Status = E_FAIL;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::Disassemble(
    THIS_
    IN ULONG64 Offset,
    IN ULONG Flags,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DisassemblySize,
    OUT PULONG64 EndOffset
    )
{
    if (Flags & ~DEBUG_DISASM_EFFECTIVE_ADDRESS)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;
        CHAR Disasm[MAX_DISASM_LEN];

        // Assume this is a code segment address so that disassembly
        // picks up the appropriate type of address.
        g_Machine->FormAddr(SEGREG_CODE, Offset, FORM_SEGREG | FORM_CODE,
                            &Addr);

        g_Machine->Disassemble(g_Process, &Addr, Disasm,
                               (Flags & DEBUG_DISASM_EFFECTIVE_ADDRESS));
        Status = FillStringBuffer(Disasm, 0,
                                  Buffer, BufferSize, DisassemblySize);
        *EndOffset = Flat(Addr);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetDisassembleEffectiveOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;
        ULONG Size;

        g_Machine->GetEffectiveAddr(&Addr, &Size);
        *Offset = Flat(Addr);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
DoOutputDisassembly(PADDR Addr, ULONG Fla